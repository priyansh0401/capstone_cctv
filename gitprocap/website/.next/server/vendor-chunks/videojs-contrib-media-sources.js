/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/videojs-contrib-media-sources";
exports.ids = ["vendor-chunks/videojs-contrib-media-sources"];
exports.modules = {

/***/ "(ssr)/./node_modules/videojs-contrib-media-sources/es5/add-text-track-data.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/videojs-contrib-media-sources/es5/add-text-track-data.js ***!
  \*******************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("/**\n * @file add-text-track-data.js\n */\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nvar _globalWindow = __webpack_require__(/*! global/window */ \"(ssr)/./node_modules/videojs-contrib-media-sources/node_modules/global/window.js\");\n\nvar _globalWindow2 = _interopRequireDefault(_globalWindow);\n\nvar _videoJs = __webpack_require__(/*! video.js */ \"(ssr)/./node_modules/videojs-contrib-media-sources/node_modules/video.js/dist/video.cjs.js\");\n\nvar _videoJs2 = _interopRequireDefault(_videoJs);\n\n/**\n * Define properties on a cue for backwards compatability,\n * but warn the user that the way that they are using it\n * is depricated and will be removed at a later date.\n *\n * @param {Cue} cue the cue to add the properties on\n * @private\n */\nvar deprecateOldCue = function deprecateOldCue(cue) {\n  Object.defineProperties(cue.frame, {\n    id: {\n      get: function get() {\n        _videoJs2['default'].log.warn('cue.frame.id is deprecated. Use cue.value.key instead.');\n        return cue.value.key;\n      }\n    },\n    value: {\n      get: function get() {\n        _videoJs2['default'].log.warn('cue.frame.value is deprecated. Use cue.value.data instead.');\n        return cue.value.data;\n      }\n    },\n    privateData: {\n      get: function get() {\n        _videoJs2['default'].log.warn('cue.frame.privateData is deprecated. Use cue.value.data instead.');\n        return cue.value.data;\n      }\n    }\n  });\n};\n\nvar durationOfVideo = function durationOfVideo(duration) {\n  var dur = undefined;\n\n  if (isNaN(duration) || Math.abs(duration) === Infinity) {\n    dur = Number.MAX_VALUE;\n  } else {\n    dur = duration;\n  }\n  return dur;\n};\n/**\n * Add text track data to a source handler given the captions and\n * metadata from the buffer.\n *\n * @param {Object} sourceHandler the flash or virtual source buffer\n * @param {Array} captionArray an array of caption data\n * @param {Array} metadataArray an array of meta data\n * @private\n */\nvar addTextTrackData = function addTextTrackData(sourceHandler, captionArray, metadataArray) {\n  var Cue = _globalWindow2['default'].WebKitDataCue || _globalWindow2['default'].VTTCue;\n\n  if (captionArray) {\n    captionArray.forEach(function (caption) {\n      var track = caption.stream;\n\n      this.inbandTextTracks_[track].addCue(new Cue(caption.startTime + this.timestampOffset, caption.endTime + this.timestampOffset, caption.text));\n    }, sourceHandler);\n  }\n\n  if (metadataArray) {\n    (function () {\n      var videoDuration = durationOfVideo(sourceHandler.mediaSource_.duration);\n\n      metadataArray.forEach(function (metadata) {\n        var time = metadata.cueTime + this.timestampOffset;\n\n        metadata.frames.forEach(function (frame) {\n          var cue = new Cue(time, time, frame.value || frame.url || frame.data || '');\n\n          cue.frame = frame;\n          cue.value = frame;\n          deprecateOldCue(cue);\n\n          this.metadataTrack_.addCue(cue);\n        }, this);\n      }, sourceHandler);\n\n      // Updating the metadeta cues so that\n      // the endTime of each cue is the startTime of the next cue\n      // the endTime of last cue is the duration of the video\n      if (sourceHandler.metadataTrack_ && sourceHandler.metadataTrack_.cues && sourceHandler.metadataTrack_.cues.length) {\n        (function () {\n          var cues = sourceHandler.metadataTrack_.cues;\n          var cuesArray = [];\n\n          // Create a copy of the TextTrackCueList...\n          // ...disregarding cues with a falsey value\n          for (var i = 0; i < cues.length; i++) {\n            if (cues[i]) {\n              cuesArray.push(cues[i]);\n            }\n          }\n\n          // Group cues by their startTime value\n          var cuesGroupedByStartTime = cuesArray.reduce(function (obj, cue) {\n            var timeSlot = obj[cue.startTime] || [];\n\n            timeSlot.push(cue);\n            obj[cue.startTime] = timeSlot;\n\n            return obj;\n          }, {});\n\n          // Sort startTimes by ascending order\n          var sortedStartTimes = Object.keys(cuesGroupedByStartTime).sort(function (a, b) {\n            return Number(a) - Number(b);\n          });\n\n          // Map each cue group's endTime to the next group's startTime\n          sortedStartTimes.forEach(function (startTime, idx) {\n            var cueGroup = cuesGroupedByStartTime[startTime];\n            var nextTime = Number(sortedStartTimes[idx + 1]) || videoDuration;\n\n            // Map each cue's endTime the next group's startTime\n            cueGroup.forEach(function (cue) {\n              cue.endTime = nextTime;\n            });\n          });\n        })();\n      }\n    })();\n  }\n};\n\nexports[\"default\"] = {\n  addTextTrackData: addTextTrackData,\n  durationOfVideo: durationOfVideo\n};\nmodule.exports = exports['default'];//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdmlkZW9qcy1jb250cmliLW1lZGlhLXNvdXJjZXMvZXM1L2FkZC10ZXh0LXRyYWNrLWRhdGEuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ2E7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDOztBQUVGLHVDQUF1Qyx1Q0FBdUM7O0FBRTlFLG9CQUFvQixtQkFBTyxDQUFDLHVHQUFlOztBQUUzQzs7QUFFQSxlQUFlLG1CQUFPLENBQUMsNEdBQVU7O0FBRWpDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNULE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBCQUEwQixpQkFBaUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLElBQUk7O0FBRWY7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL215LXYwLXByb2plY3QvLi9ub2RlX21vZHVsZXMvdmlkZW9qcy1jb250cmliLW1lZGlhLXNvdXJjZXMvZXM1L2FkZC10ZXh0LXRyYWNrLWRhdGEuanM/NGY2NiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBmaWxlIGFkZC10ZXh0LXRyYWNrLWRhdGEuanNcbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG52YXIgX2dsb2JhbFdpbmRvdyA9IHJlcXVpcmUoJ2dsb2JhbC93aW5kb3cnKTtcblxudmFyIF9nbG9iYWxXaW5kb3cyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2xvYmFsV2luZG93KTtcblxudmFyIF92aWRlb0pzID0gcmVxdWlyZSgndmlkZW8uanMnKTtcblxudmFyIF92aWRlb0pzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3ZpZGVvSnMpO1xuXG4vKipcbiAqIERlZmluZSBwcm9wZXJ0aWVzIG9uIGEgY3VlIGZvciBiYWNrd2FyZHMgY29tcGF0YWJpbGl0eSxcbiAqIGJ1dCB3YXJuIHRoZSB1c2VyIHRoYXQgdGhlIHdheSB0aGF0IHRoZXkgYXJlIHVzaW5nIGl0XG4gKiBpcyBkZXByaWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgYXQgYSBsYXRlciBkYXRlLlxuICpcbiAqIEBwYXJhbSB7Q3VlfSBjdWUgdGhlIGN1ZSB0byBhZGQgdGhlIHByb3BlcnRpZXMgb25cbiAqIEBwcml2YXRlXG4gKi9cbnZhciBkZXByZWNhdGVPbGRDdWUgPSBmdW5jdGlvbiBkZXByZWNhdGVPbGRDdWUoY3VlKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGN1ZS5mcmFtZSwge1xuICAgIGlkOiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgX3ZpZGVvSnMyWydkZWZhdWx0J10ubG9nLndhcm4oJ2N1ZS5mcmFtZS5pZCBpcyBkZXByZWNhdGVkLiBVc2UgY3VlLnZhbHVlLmtleSBpbnN0ZWFkLicpO1xuICAgICAgICByZXR1cm4gY3VlLnZhbHVlLmtleTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHZhbHVlOiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgX3ZpZGVvSnMyWydkZWZhdWx0J10ubG9nLndhcm4oJ2N1ZS5mcmFtZS52YWx1ZSBpcyBkZXByZWNhdGVkLiBVc2UgY3VlLnZhbHVlLmRhdGEgaW5zdGVhZC4nKTtcbiAgICAgICAgcmV0dXJuIGN1ZS52YWx1ZS5kYXRhO1xuICAgICAgfVxuICAgIH0sXG4gICAgcHJpdmF0ZURhdGE6IHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICBfdmlkZW9KczJbJ2RlZmF1bHQnXS5sb2cud2FybignY3VlLmZyYW1lLnByaXZhdGVEYXRhIGlzIGRlcHJlY2F0ZWQuIFVzZSBjdWUudmFsdWUuZGF0YSBpbnN0ZWFkLicpO1xuICAgICAgICByZXR1cm4gY3VlLnZhbHVlLmRhdGE7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn07XG5cbnZhciBkdXJhdGlvbk9mVmlkZW8gPSBmdW5jdGlvbiBkdXJhdGlvbk9mVmlkZW8oZHVyYXRpb24pIHtcbiAgdmFyIGR1ciA9IHVuZGVmaW5lZDtcblxuICBpZiAoaXNOYU4oZHVyYXRpb24pIHx8IE1hdGguYWJzKGR1cmF0aW9uKSA9PT0gSW5maW5pdHkpIHtcbiAgICBkdXIgPSBOdW1iZXIuTUFYX1ZBTFVFO1xuICB9IGVsc2Uge1xuICAgIGR1ciA9IGR1cmF0aW9uO1xuICB9XG4gIHJldHVybiBkdXI7XG59O1xuLyoqXG4gKiBBZGQgdGV4dCB0cmFjayBkYXRhIHRvIGEgc291cmNlIGhhbmRsZXIgZ2l2ZW4gdGhlIGNhcHRpb25zIGFuZFxuICogbWV0YWRhdGEgZnJvbSB0aGUgYnVmZmVyLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2VIYW5kbGVyIHRoZSBmbGFzaCBvciB2aXJ0dWFsIHNvdXJjZSBidWZmZXJcbiAqIEBwYXJhbSB7QXJyYXl9IGNhcHRpb25BcnJheSBhbiBhcnJheSBvZiBjYXB0aW9uIGRhdGFcbiAqIEBwYXJhbSB7QXJyYXl9IG1ldGFkYXRhQXJyYXkgYW4gYXJyYXkgb2YgbWV0YSBkYXRhXG4gKiBAcHJpdmF0ZVxuICovXG52YXIgYWRkVGV4dFRyYWNrRGF0YSA9IGZ1bmN0aW9uIGFkZFRleHRUcmFja0RhdGEoc291cmNlSGFuZGxlciwgY2FwdGlvbkFycmF5LCBtZXRhZGF0YUFycmF5KSB7XG4gIHZhciBDdWUgPSBfZ2xvYmFsV2luZG93MlsnZGVmYXVsdCddLldlYktpdERhdGFDdWUgfHwgX2dsb2JhbFdpbmRvdzJbJ2RlZmF1bHQnXS5WVFRDdWU7XG5cbiAgaWYgKGNhcHRpb25BcnJheSkge1xuICAgIGNhcHRpb25BcnJheS5mb3JFYWNoKGZ1bmN0aW9uIChjYXB0aW9uKSB7XG4gICAgICB2YXIgdHJhY2sgPSBjYXB0aW9uLnN0cmVhbTtcblxuICAgICAgdGhpcy5pbmJhbmRUZXh0VHJhY2tzX1t0cmFja10uYWRkQ3VlKG5ldyBDdWUoY2FwdGlvbi5zdGFydFRpbWUgKyB0aGlzLnRpbWVzdGFtcE9mZnNldCwgY2FwdGlvbi5lbmRUaW1lICsgdGhpcy50aW1lc3RhbXBPZmZzZXQsIGNhcHRpb24udGV4dCkpO1xuICAgIH0sIHNvdXJjZUhhbmRsZXIpO1xuICB9XG5cbiAgaWYgKG1ldGFkYXRhQXJyYXkpIHtcbiAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHZpZGVvRHVyYXRpb24gPSBkdXJhdGlvbk9mVmlkZW8oc291cmNlSGFuZGxlci5tZWRpYVNvdXJjZV8uZHVyYXRpb24pO1xuXG4gICAgICBtZXRhZGF0YUFycmF5LmZvckVhY2goZnVuY3Rpb24gKG1ldGFkYXRhKSB7XG4gICAgICAgIHZhciB0aW1lID0gbWV0YWRhdGEuY3VlVGltZSArIHRoaXMudGltZXN0YW1wT2Zmc2V0O1xuXG4gICAgICAgIG1ldGFkYXRhLmZyYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChmcmFtZSkge1xuICAgICAgICAgIHZhciBjdWUgPSBuZXcgQ3VlKHRpbWUsIHRpbWUsIGZyYW1lLnZhbHVlIHx8IGZyYW1lLnVybCB8fCBmcmFtZS5kYXRhIHx8ICcnKTtcblxuICAgICAgICAgIGN1ZS5mcmFtZSA9IGZyYW1lO1xuICAgICAgICAgIGN1ZS52YWx1ZSA9IGZyYW1lO1xuICAgICAgICAgIGRlcHJlY2F0ZU9sZEN1ZShjdWUpO1xuXG4gICAgICAgICAgdGhpcy5tZXRhZGF0YVRyYWNrXy5hZGRDdWUoY3VlKTtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgICB9LCBzb3VyY2VIYW5kbGVyKTtcblxuICAgICAgLy8gVXBkYXRpbmcgdGhlIG1ldGFkZXRhIGN1ZXMgc28gdGhhdFxuICAgICAgLy8gdGhlIGVuZFRpbWUgb2YgZWFjaCBjdWUgaXMgdGhlIHN0YXJ0VGltZSBvZiB0aGUgbmV4dCBjdWVcbiAgICAgIC8vIHRoZSBlbmRUaW1lIG9mIGxhc3QgY3VlIGlzIHRoZSBkdXJhdGlvbiBvZiB0aGUgdmlkZW9cbiAgICAgIGlmIChzb3VyY2VIYW5kbGVyLm1ldGFkYXRhVHJhY2tfICYmIHNvdXJjZUhhbmRsZXIubWV0YWRhdGFUcmFja18uY3VlcyAmJiBzb3VyY2VIYW5kbGVyLm1ldGFkYXRhVHJhY2tfLmN1ZXMubGVuZ3RoKSB7XG4gICAgICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIGN1ZXMgPSBzb3VyY2VIYW5kbGVyLm1ldGFkYXRhVHJhY2tfLmN1ZXM7XG4gICAgICAgICAgdmFyIGN1ZXNBcnJheSA9IFtdO1xuXG4gICAgICAgICAgLy8gQ3JlYXRlIGEgY29weSBvZiB0aGUgVGV4dFRyYWNrQ3VlTGlzdC4uLlxuICAgICAgICAgIC8vIC4uLmRpc3JlZ2FyZGluZyBjdWVzIHdpdGggYSBmYWxzZXkgdmFsdWVcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGN1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChjdWVzW2ldKSB7XG4gICAgICAgICAgICAgIGN1ZXNBcnJheS5wdXNoKGN1ZXNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIEdyb3VwIGN1ZXMgYnkgdGhlaXIgc3RhcnRUaW1lIHZhbHVlXG4gICAgICAgICAgdmFyIGN1ZXNHcm91cGVkQnlTdGFydFRpbWUgPSBjdWVzQXJyYXkucmVkdWNlKGZ1bmN0aW9uIChvYmosIGN1ZSkge1xuICAgICAgICAgICAgdmFyIHRpbWVTbG90ID0gb2JqW2N1ZS5zdGFydFRpbWVdIHx8IFtdO1xuXG4gICAgICAgICAgICB0aW1lU2xvdC5wdXNoKGN1ZSk7XG4gICAgICAgICAgICBvYmpbY3VlLnN0YXJ0VGltZV0gPSB0aW1lU2xvdDtcblxuICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgICB9LCB7fSk7XG5cbiAgICAgICAgICAvLyBTb3J0IHN0YXJ0VGltZXMgYnkgYXNjZW5kaW5nIG9yZGVyXG4gICAgICAgICAgdmFyIHNvcnRlZFN0YXJ0VGltZXMgPSBPYmplY3Qua2V5cyhjdWVzR3JvdXBlZEJ5U3RhcnRUaW1lKS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gTnVtYmVyKGEpIC0gTnVtYmVyKGIpO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgLy8gTWFwIGVhY2ggY3VlIGdyb3VwJ3MgZW5kVGltZSB0byB0aGUgbmV4dCBncm91cCdzIHN0YXJ0VGltZVxuICAgICAgICAgIHNvcnRlZFN0YXJ0VGltZXMuZm9yRWFjaChmdW5jdGlvbiAoc3RhcnRUaW1lLCBpZHgpIHtcbiAgICAgICAgICAgIHZhciBjdWVHcm91cCA9IGN1ZXNHcm91cGVkQnlTdGFydFRpbWVbc3RhcnRUaW1lXTtcbiAgICAgICAgICAgIHZhciBuZXh0VGltZSA9IE51bWJlcihzb3J0ZWRTdGFydFRpbWVzW2lkeCArIDFdKSB8fCB2aWRlb0R1cmF0aW9uO1xuXG4gICAgICAgICAgICAvLyBNYXAgZWFjaCBjdWUncyBlbmRUaW1lIHRoZSBuZXh0IGdyb3VwJ3Mgc3RhcnRUaW1lXG4gICAgICAgICAgICBjdWVHcm91cC5mb3JFYWNoKGZ1bmN0aW9uIChjdWUpIHtcbiAgICAgICAgICAgICAgY3VlLmVuZFRpbWUgPSBuZXh0VGltZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KSgpO1xuICAgICAgfVxuICAgIH0pKCk7XG4gIH1cbn07XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IHtcbiAgYWRkVGV4dFRyYWNrRGF0YTogYWRkVGV4dFRyYWNrRGF0YSxcbiAgZHVyYXRpb25PZlZpZGVvOiBkdXJhdGlvbk9mVmlkZW9cbn07XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/videojs-contrib-media-sources/es5/add-text-track-data.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/videojs-contrib-media-sources/es5/codec-utils.js":
/*!***********************************************************************!*\
  !*** ./node_modules/videojs-contrib-media-sources/es5/codec-utils.js ***!
  \***********************************************************************/
/***/ ((module, exports) => {

"use strict";
eval("/**\n * @file codec-utils.js\n */\n\n/**\n * Check if a codec string refers to an audio codec.\n *\n * @param {String} codec codec string to check\n * @return {Boolean} if this is an audio codec\n * @private\n */\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nvar isAudioCodec = function isAudioCodec(codec) {\n  return (/mp4a\\.\\d+.\\d+/i.test(codec)\n  );\n};\n\n/**\n * Check if a codec string refers to a video codec.\n *\n * @param {String} codec codec string to check\n * @return {Boolean} if this is a video codec\n * @private\n */\nvar isVideoCodec = function isVideoCodec(codec) {\n  return (/avc1\\.[\\da-f]+/i.test(codec)\n  );\n};\n\n/**\n * Parse a content type header into a type and parameters\n * object\n *\n * @param {String} type the content type header\n * @return {Object} the parsed content-type\n * @private\n */\nvar parseContentType = function parseContentType(type) {\n  var object = { type: '', parameters: {} };\n  var parameters = type.trim().split(';');\n\n  // first parameter should always be content-type\n  object.type = parameters.shift().trim();\n  parameters.forEach(function (parameter) {\n    var pair = parameter.trim().split('=');\n\n    if (pair.length > 1) {\n      var _name = pair[0].replace(/\"/g, '').trim();\n      var value = pair[1].replace(/\"/g, '').trim();\n\n      object.parameters[_name] = value;\n    }\n  });\n\n  return object;\n};\n\n/**\n * Replace the old apple-style `avc1.<dd>.<dd>` codec string with the standard\n * `avc1.<hhhhhh>`\n *\n * @param {Array} codecs an array of codec strings to fix\n * @return {Array} the translated codec array\n * @private\n */\nvar translateLegacyCodecs = function translateLegacyCodecs(codecs) {\n  return codecs.map(function (codec) {\n    return codec.replace(/avc1\\.(\\d+)\\.(\\d+)/i, function (orig, profile, avcLevel) {\n      var profileHex = ('00' + Number(profile).toString(16)).slice(-2);\n      var avcLevelHex = ('00' + Number(avcLevel).toString(16)).slice(-2);\n\n      return 'avc1.' + profileHex + '00' + avcLevelHex;\n    });\n  });\n};\n\nexports[\"default\"] = {\n  isAudioCodec: isAudioCodec,\n  parseContentType: parseContentType,\n  isVideoCodec: isVideoCodec,\n  translateLegacyCodecs: translateLegacyCodecs\n};\nmodule.exports = exports['default'];//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdmlkZW9qcy1jb250cmliLW1lZGlhLXNvdXJjZXMvZXM1L2NvZGVjLXV0aWxzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDYTs7QUFFYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLHVDQUF1Qzs7QUFFdkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktdjAtcHJvamVjdC8uL25vZGVfbW9kdWxlcy92aWRlb2pzLWNvbnRyaWItbWVkaWEtc291cmNlcy9lczUvY29kZWMtdXRpbHMuanM/N2IxNCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBmaWxlIGNvZGVjLXV0aWxzLmpzXG4gKi9cblxuLyoqXG4gKiBDaGVjayBpZiBhIGNvZGVjIHN0cmluZyByZWZlcnMgdG8gYW4gYXVkaW8gY29kZWMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGNvZGVjIGNvZGVjIHN0cmluZyB0byBjaGVja1xuICogQHJldHVybiB7Qm9vbGVhbn0gaWYgdGhpcyBpcyBhbiBhdWRpbyBjb2RlY1xuICogQHByaXZhdGVcbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbnZhciBpc0F1ZGlvQ29kZWMgPSBmdW5jdGlvbiBpc0F1ZGlvQ29kZWMoY29kZWMpIHtcbiAgcmV0dXJuICgvbXA0YVxcLlxcZCsuXFxkKy9pLnRlc3QoY29kZWMpXG4gICk7XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIGEgY29kZWMgc3RyaW5nIHJlZmVycyB0byBhIHZpZGVvIGNvZGVjLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBjb2RlYyBjb2RlYyBzdHJpbmcgdG8gY2hlY2tcbiAqIEByZXR1cm4ge0Jvb2xlYW59IGlmIHRoaXMgaXMgYSB2aWRlbyBjb2RlY1xuICogQHByaXZhdGVcbiAqL1xudmFyIGlzVmlkZW9Db2RlYyA9IGZ1bmN0aW9uIGlzVmlkZW9Db2RlYyhjb2RlYykge1xuICByZXR1cm4gKC9hdmMxXFwuW1xcZGEtZl0rL2kudGVzdChjb2RlYylcbiAgKTtcbn07XG5cbi8qKlxuICogUGFyc2UgYSBjb250ZW50IHR5cGUgaGVhZGVyIGludG8gYSB0eXBlIGFuZCBwYXJhbWV0ZXJzXG4gKiBvYmplY3RcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZSB0aGUgY29udGVudCB0eXBlIGhlYWRlclxuICogQHJldHVybiB7T2JqZWN0fSB0aGUgcGFyc2VkIGNvbnRlbnQtdHlwZVxuICogQHByaXZhdGVcbiAqL1xudmFyIHBhcnNlQ29udGVudFR5cGUgPSBmdW5jdGlvbiBwYXJzZUNvbnRlbnRUeXBlKHR5cGUpIHtcbiAgdmFyIG9iamVjdCA9IHsgdHlwZTogJycsIHBhcmFtZXRlcnM6IHt9IH07XG4gIHZhciBwYXJhbWV0ZXJzID0gdHlwZS50cmltKCkuc3BsaXQoJzsnKTtcblxuICAvLyBmaXJzdCBwYXJhbWV0ZXIgc2hvdWxkIGFsd2F5cyBiZSBjb250ZW50LXR5cGVcbiAgb2JqZWN0LnR5cGUgPSBwYXJhbWV0ZXJzLnNoaWZ0KCkudHJpbSgpO1xuICBwYXJhbWV0ZXJzLmZvckVhY2goZnVuY3Rpb24gKHBhcmFtZXRlcikge1xuICAgIHZhciBwYWlyID0gcGFyYW1ldGVyLnRyaW0oKS5zcGxpdCgnPScpO1xuXG4gICAgaWYgKHBhaXIubGVuZ3RoID4gMSkge1xuICAgICAgdmFyIF9uYW1lID0gcGFpclswXS5yZXBsYWNlKC9cIi9nLCAnJykudHJpbSgpO1xuICAgICAgdmFyIHZhbHVlID0gcGFpclsxXS5yZXBsYWNlKC9cIi9nLCAnJykudHJpbSgpO1xuXG4gICAgICBvYmplY3QucGFyYW1ldGVyc1tfbmFtZV0gPSB2YWx1ZTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBvYmplY3Q7XG59O1xuXG4vKipcbiAqIFJlcGxhY2UgdGhlIG9sZCBhcHBsZS1zdHlsZSBgYXZjMS48ZGQ+LjxkZD5gIGNvZGVjIHN0cmluZyB3aXRoIHRoZSBzdGFuZGFyZFxuICogYGF2YzEuPGhoaGhoaD5gXG4gKlxuICogQHBhcmFtIHtBcnJheX0gY29kZWNzIGFuIGFycmF5IG9mIGNvZGVjIHN0cmluZ3MgdG8gZml4XG4gKiBAcmV0dXJuIHtBcnJheX0gdGhlIHRyYW5zbGF0ZWQgY29kZWMgYXJyYXlcbiAqIEBwcml2YXRlXG4gKi9cbnZhciB0cmFuc2xhdGVMZWdhY3lDb2RlY3MgPSBmdW5jdGlvbiB0cmFuc2xhdGVMZWdhY3lDb2RlY3MoY29kZWNzKSB7XG4gIHJldHVybiBjb2RlY3MubWFwKGZ1bmN0aW9uIChjb2RlYykge1xuICAgIHJldHVybiBjb2RlYy5yZXBsYWNlKC9hdmMxXFwuKFxcZCspXFwuKFxcZCspL2ksIGZ1bmN0aW9uIChvcmlnLCBwcm9maWxlLCBhdmNMZXZlbCkge1xuICAgICAgdmFyIHByb2ZpbGVIZXggPSAoJzAwJyArIE51bWJlcihwcm9maWxlKS50b1N0cmluZygxNikpLnNsaWNlKC0yKTtcbiAgICAgIHZhciBhdmNMZXZlbEhleCA9ICgnMDAnICsgTnVtYmVyKGF2Y0xldmVsKS50b1N0cmluZygxNikpLnNsaWNlKC0yKTtcblxuICAgICAgcmV0dXJuICdhdmMxLicgKyBwcm9maWxlSGV4ICsgJzAwJyArIGF2Y0xldmVsSGV4O1xuICAgIH0pO1xuICB9KTtcbn07XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IHtcbiAgaXNBdWRpb0NvZGVjOiBpc0F1ZGlvQ29kZWMsXG4gIHBhcnNlQ29udGVudFR5cGU6IHBhcnNlQ29udGVudFR5cGUsXG4gIGlzVmlkZW9Db2RlYzogaXNWaWRlb0NvZGVjLFxuICB0cmFuc2xhdGVMZWdhY3lDb2RlY3M6IHRyYW5zbGF0ZUxlZ2FjeUNvZGVjc1xufTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/videojs-contrib-media-sources/es5/codec-utils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/videojs-contrib-media-sources/es5/create-text-tracks-if-necessary.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/videojs-contrib-media-sources/es5/create-text-tracks-if-necessary.js ***!
  \*******************************************************************************************/
/***/ ((module, exports) => {

"use strict";
eval("/**\n * @file create-text-tracks-if-necessary.js\n */\n\n/**\n * Create text tracks on video.js if they exist on a segment.\n *\n * @param {Object} sourceBuffer the VSB or FSB\n * @param {Object} mediaSource the HTML or Flash media source\n * @param {Object} segment the segment that may contain the text track\n * @private\n */\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nvar createTextTracksIfNecessary = function createTextTracksIfNecessary(sourceBuffer, mediaSource, segment) {\n  var player = mediaSource.player_;\n\n  // create an in-band caption track if one is present in the segment\n  if (segment.captions && segment.captions.length) {\n    if (!sourceBuffer.inbandTextTracks_) {\n      sourceBuffer.inbandTextTracks_ = {};\n    }\n\n    for (var trackId in segment.captionStreams) {\n      if (!sourceBuffer.inbandTextTracks_[trackId]) {\n        player.tech_.trigger({ type: 'usage', name: 'hls-608' });\n        var track = player.textTracks().getTrackById(trackId);\n\n        if (track) {\n          // Resuse an existing track with a CC# id because this was\n          // very likely created by videojs-contrib-hls from information\n          // in the m3u8 for us to use\n          sourceBuffer.inbandTextTracks_[trackId] = track;\n        } else {\n          // Otherwise, create a track with the default `CC#` label and\n          // without a language\n          sourceBuffer.inbandTextTracks_[trackId] = player.addRemoteTextTrack({\n            kind: 'captions',\n            id: trackId,\n            label: trackId\n          }, false).track;\n        }\n      }\n    }\n  }\n\n  if (segment.metadata && segment.metadata.length && !sourceBuffer.metadataTrack_) {\n    sourceBuffer.metadataTrack_ = player.addRemoteTextTrack({\n      kind: 'metadata',\n      label: 'Timed Metadata'\n    }, false).track;\n    sourceBuffer.metadataTrack_.inBandMetadataTrackDispatchType = segment.metadata.dispatchType;\n  }\n};\n\nexports[\"default\"] = createTextTracksIfNecessary;\nmodule.exports = exports['default'];//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdmlkZW9qcy1jb250cmliLW1lZGlhLXNvdXJjZXMvZXM1L2NyZWF0ZS10ZXh0LXRyYWNrcy1pZi1uZWNlc3NhcnkuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDYTs7QUFFYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtCQUErQixnQ0FBZ0M7QUFDL0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBLGtCQUFrQjtBQUNsQiIsInNvdXJjZXMiOlsid2VicGFjazovL215LXYwLXByb2plY3QvLi9ub2RlX21vZHVsZXMvdmlkZW9qcy1jb250cmliLW1lZGlhLXNvdXJjZXMvZXM1L2NyZWF0ZS10ZXh0LXRyYWNrcy1pZi1uZWNlc3NhcnkuanM/NDM2MSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBmaWxlIGNyZWF0ZS10ZXh0LXRyYWNrcy1pZi1uZWNlc3NhcnkuanNcbiAqL1xuXG4vKipcbiAqIENyZWF0ZSB0ZXh0IHRyYWNrcyBvbiB2aWRlby5qcyBpZiB0aGV5IGV4aXN0IG9uIGEgc2VnbWVudC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlQnVmZmVyIHRoZSBWU0Igb3IgRlNCXG4gKiBAcGFyYW0ge09iamVjdH0gbWVkaWFTb3VyY2UgdGhlIEhUTUwgb3IgRmxhc2ggbWVkaWEgc291cmNlXG4gKiBAcGFyYW0ge09iamVjdH0gc2VnbWVudCB0aGUgc2VnbWVudCB0aGF0IG1heSBjb250YWluIHRoZSB0ZXh0IHRyYWNrXG4gKiBAcHJpdmF0ZVxuICovXG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xudmFyIGNyZWF0ZVRleHRUcmFja3NJZk5lY2Vzc2FyeSA9IGZ1bmN0aW9uIGNyZWF0ZVRleHRUcmFja3NJZk5lY2Vzc2FyeShzb3VyY2VCdWZmZXIsIG1lZGlhU291cmNlLCBzZWdtZW50KSB7XG4gIHZhciBwbGF5ZXIgPSBtZWRpYVNvdXJjZS5wbGF5ZXJfO1xuXG4gIC8vIGNyZWF0ZSBhbiBpbi1iYW5kIGNhcHRpb24gdHJhY2sgaWYgb25lIGlzIHByZXNlbnQgaW4gdGhlIHNlZ21lbnRcbiAgaWYgKHNlZ21lbnQuY2FwdGlvbnMgJiYgc2VnbWVudC5jYXB0aW9ucy5sZW5ndGgpIHtcbiAgICBpZiAoIXNvdXJjZUJ1ZmZlci5pbmJhbmRUZXh0VHJhY2tzXykge1xuICAgICAgc291cmNlQnVmZmVyLmluYmFuZFRleHRUcmFja3NfID0ge307XG4gICAgfVxuXG4gICAgZm9yICh2YXIgdHJhY2tJZCBpbiBzZWdtZW50LmNhcHRpb25TdHJlYW1zKSB7XG4gICAgICBpZiAoIXNvdXJjZUJ1ZmZlci5pbmJhbmRUZXh0VHJhY2tzX1t0cmFja0lkXSkge1xuICAgICAgICBwbGF5ZXIudGVjaF8udHJpZ2dlcih7IHR5cGU6ICd1c2FnZScsIG5hbWU6ICdobHMtNjA4JyB9KTtcbiAgICAgICAgdmFyIHRyYWNrID0gcGxheWVyLnRleHRUcmFja3MoKS5nZXRUcmFja0J5SWQodHJhY2tJZCk7XG5cbiAgICAgICAgaWYgKHRyYWNrKSB7XG4gICAgICAgICAgLy8gUmVzdXNlIGFuIGV4aXN0aW5nIHRyYWNrIHdpdGggYSBDQyMgaWQgYmVjYXVzZSB0aGlzIHdhc1xuICAgICAgICAgIC8vIHZlcnkgbGlrZWx5IGNyZWF0ZWQgYnkgdmlkZW9qcy1jb250cmliLWhscyBmcm9tIGluZm9ybWF0aW9uXG4gICAgICAgICAgLy8gaW4gdGhlIG0zdTggZm9yIHVzIHRvIHVzZVxuICAgICAgICAgIHNvdXJjZUJ1ZmZlci5pbmJhbmRUZXh0VHJhY2tzX1t0cmFja0lkXSA9IHRyYWNrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIE90aGVyd2lzZSwgY3JlYXRlIGEgdHJhY2sgd2l0aCB0aGUgZGVmYXVsdCBgQ0MjYCBsYWJlbCBhbmRcbiAgICAgICAgICAvLyB3aXRob3V0IGEgbGFuZ3VhZ2VcbiAgICAgICAgICBzb3VyY2VCdWZmZXIuaW5iYW5kVGV4dFRyYWNrc19bdHJhY2tJZF0gPSBwbGF5ZXIuYWRkUmVtb3RlVGV4dFRyYWNrKHtcbiAgICAgICAgICAgIGtpbmQ6ICdjYXB0aW9ucycsXG4gICAgICAgICAgICBpZDogdHJhY2tJZCxcbiAgICAgICAgICAgIGxhYmVsOiB0cmFja0lkXG4gICAgICAgICAgfSwgZmFsc2UpLnRyYWNrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKHNlZ21lbnQubWV0YWRhdGEgJiYgc2VnbWVudC5tZXRhZGF0YS5sZW5ndGggJiYgIXNvdXJjZUJ1ZmZlci5tZXRhZGF0YVRyYWNrXykge1xuICAgIHNvdXJjZUJ1ZmZlci5tZXRhZGF0YVRyYWNrXyA9IHBsYXllci5hZGRSZW1vdGVUZXh0VHJhY2soe1xuICAgICAga2luZDogJ21ldGFkYXRhJyxcbiAgICAgIGxhYmVsOiAnVGltZWQgTWV0YWRhdGEnXG4gICAgfSwgZmFsc2UpLnRyYWNrO1xuICAgIHNvdXJjZUJ1ZmZlci5tZXRhZGF0YVRyYWNrXy5pbkJhbmRNZXRhZGF0YVRyYWNrRGlzcGF0Y2hUeXBlID0gc2VnbWVudC5tZXRhZGF0YS5kaXNwYXRjaFR5cGU7XG4gIH1cbn07XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IGNyZWF0ZVRleHRUcmFja3NJZk5lY2Vzc2FyeTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/videojs-contrib-media-sources/es5/create-text-tracks-if-necessary.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/videojs-contrib-media-sources/es5/flash-constants.js":
/*!***************************************************************************!*\
  !*** ./node_modules/videojs-contrib-media-sources/es5/flash-constants.js ***!
  \***************************************************************************/
/***/ ((module, exports) => {

"use strict";
eval("/**\n * @file flash-constants.js\n */\n/**\n * The maximum size in bytes for append operations to the video.js\n * SWF. Calling through to Flash blocks and can be expensive so\n * we chunk data and pass through 4KB at a time, yielding to the\n * browser between chunks. This gives a theoretical maximum rate of\n * 1MB/s into Flash. Any higher and we begin to drop frames and UI\n * responsiveness suffers.\n *\n * @private\n */\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nvar flashConstants = {\n  // times in milliseconds\n  TIME_BETWEEN_CHUNKS: 1,\n  BYTES_PER_CHUNK: 1024 * 32\n};\n\nexports[\"default\"] = flashConstants;\nmodule.exports = exports[\"default\"];//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdmlkZW9qcy1jb250cmliLW1lZGlhLXNvdXJjZXMvZXM1L2ZsYXNoLWNvbnN0YW50cy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNhOztBQUViLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCO0FBQ2xCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktdjAtcHJvamVjdC8uL25vZGVfbW9kdWxlcy92aWRlb2pzLWNvbnRyaWItbWVkaWEtc291cmNlcy9lczUvZmxhc2gtY29uc3RhbnRzLmpzPzY2ZGUiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAZmlsZSBmbGFzaC1jb25zdGFudHMuanNcbiAqL1xuLyoqXG4gKiBUaGUgbWF4aW11bSBzaXplIGluIGJ5dGVzIGZvciBhcHBlbmQgb3BlcmF0aW9ucyB0byB0aGUgdmlkZW8uanNcbiAqIFNXRi4gQ2FsbGluZyB0aHJvdWdoIHRvIEZsYXNoIGJsb2NrcyBhbmQgY2FuIGJlIGV4cGVuc2l2ZSBzb1xuICogd2UgY2h1bmsgZGF0YSBhbmQgcGFzcyB0aHJvdWdoIDRLQiBhdCBhIHRpbWUsIHlpZWxkaW5nIHRvIHRoZVxuICogYnJvd3NlciBiZXR3ZWVuIGNodW5rcy4gVGhpcyBnaXZlcyBhIHRoZW9yZXRpY2FsIG1heGltdW0gcmF0ZSBvZlxuICogMU1CL3MgaW50byBGbGFzaC4gQW55IGhpZ2hlciBhbmQgd2UgYmVnaW4gdG8gZHJvcCBmcmFtZXMgYW5kIFVJXG4gKiByZXNwb25zaXZlbmVzcyBzdWZmZXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xudmFyIGZsYXNoQ29uc3RhbnRzID0ge1xuICAvLyB0aW1lcyBpbiBtaWxsaXNlY29uZHNcbiAgVElNRV9CRVRXRUVOX0NIVU5LUzogMSxcbiAgQllURVNfUEVSX0NIVU5LOiAxMDI0ICogMzJcbn07XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gZmxhc2hDb25zdGFudHM7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbXCJkZWZhdWx0XCJdOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/videojs-contrib-media-sources/es5/flash-constants.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/videojs-contrib-media-sources/es5/flash-media-source.js":
/*!******************************************************************************!*\
  !*** ./node_modules/videojs-contrib-media-sources/es5/flash-media-source.js ***!
  \******************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("/**\n * @file flash-media-source.js\n */\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nvar _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar _globalDocument = __webpack_require__(/*! global/document */ \"(ssr)/./node_modules/videojs-contrib-media-sources/node_modules/global/document.js\");\n\nvar _globalDocument2 = _interopRequireDefault(_globalDocument);\n\nvar _videoJs = __webpack_require__(/*! video.js */ \"(ssr)/./node_modules/videojs-contrib-media-sources/node_modules/video.js/dist/video.cjs.js\");\n\nvar _videoJs2 = _interopRequireDefault(_videoJs);\n\nvar _flashSourceBuffer = __webpack_require__(/*! ./flash-source-buffer */ \"(ssr)/./node_modules/videojs-contrib-media-sources/es5/flash-source-buffer.js\");\n\nvar _flashSourceBuffer2 = _interopRequireDefault(_flashSourceBuffer);\n\nvar _flashConstants = __webpack_require__(/*! ./flash-constants */ \"(ssr)/./node_modules/videojs-contrib-media-sources/es5/flash-constants.js\");\n\nvar _flashConstants2 = _interopRequireDefault(_flashConstants);\n\nvar _codecUtils = __webpack_require__(/*! ./codec-utils */ \"(ssr)/./node_modules/videojs-contrib-media-sources/es5/codec-utils.js\");\n\n/**\n * A flash implmentation of HTML MediaSources and a polyfill\n * for browsers that don't support native or HTML MediaSources..\n *\n * @link https://developer.mozilla.org/en-US/docs/Web/API/MediaSource\n * @class FlashMediaSource\n * @extends videojs.EventTarget\n */\n\nvar FlashMediaSource = (function (_videojs$EventTarget) {\n  _inherits(FlashMediaSource, _videojs$EventTarget);\n\n  function FlashMediaSource() {\n    var _this = this;\n\n    _classCallCheck(this, FlashMediaSource);\n\n    _get(Object.getPrototypeOf(FlashMediaSource.prototype), 'constructor', this).call(this);\n    this.sourceBuffers = [];\n    this.readyState = 'closed';\n\n    this.on(['sourceopen', 'webkitsourceopen'], function (event) {\n      // find the swf where we will push media data\n      _this.swfObj = _globalDocument2['default'].getElementById(event.swfId);\n      _this.player_ = (0, _videoJs2['default'])(_this.swfObj.parentNode);\n      _this.tech_ = _this.swfObj.tech;\n      _this.readyState = 'open';\n\n      _this.tech_.on('seeking', function () {\n        var i = _this.sourceBuffers.length;\n\n        while (i--) {\n          _this.sourceBuffers[i].abort();\n        }\n      });\n\n      // trigger load events\n      if (_this.swfObj) {\n        _this.swfObj.vjs_load();\n      }\n    });\n  }\n\n  /**\n    * Set or return the presentation duration.\n    *\n    * @param {Double} value the duration of the media in seconds\n    * @param {Double} the current presentation duration\n    * @link http://www.w3.org/TR/media-source/#widl-MediaSource-duration\n    */\n\n  /**\n   * We have this function so that the html and flash interfaces\n   * are the same.\n   *\n   * @private\n   */\n\n  _createClass(FlashMediaSource, [{\n    key: 'addSeekableRange_',\n    value: function addSeekableRange_() {}\n    // intentional no-op\n\n    /**\n     * Create a new flash source buffer and add it to our flash media source.\n     *\n     * @link https://developer.mozilla.org/en-US/docs/Web/API/MediaSource/addSourceBuffer\n     * @param {String} type the content-type of the source\n     * @return {Object} the flash source buffer\n     */\n\n  }, {\n    key: 'addSourceBuffer',\n    value: function addSourceBuffer(type) {\n      var parsedType = (0, _codecUtils.parseContentType)(type);\n      var sourceBuffer = undefined;\n\n      // if this is an FLV type, we'll push data to flash\n      if (parsedType.type === 'video/mp2t' || parsedType.type === 'audio/mp2t') {\n        // Flash source buffers\n        sourceBuffer = new _flashSourceBuffer2['default'](this);\n      } else {\n        throw new Error('NotSupportedError (Video.js)');\n      }\n\n      this.sourceBuffers.push(sourceBuffer);\n      return sourceBuffer;\n    }\n\n    /**\n     * Signals the end of the stream.\n     *\n     * @link https://w3c.github.io/media-source/#widl-MediaSource-endOfStream-void-EndOfStreamError-error\n     * @param {String=} error Signals that a playback error\n     * has occurred. If specified, it must be either \"network\" or\n     * \"decode\".\n     */\n  }, {\n    key: 'endOfStream',\n    value: function endOfStream(error) {\n      if (error === 'network') {\n        // MEDIA_ERR_NETWORK\n        this.tech_.error(2);\n      } else if (error === 'decode') {\n        // MEDIA_ERR_DECODE\n        this.tech_.error(3);\n      }\n      if (this.readyState !== 'ended') {\n        this.readyState = 'ended';\n        this.swfObj.vjs_endOfStream();\n      }\n    }\n  }]);\n\n  return FlashMediaSource;\n})(_videoJs2['default'].EventTarget);\n\nexports[\"default\"] = FlashMediaSource;\ntry {\n  Object.defineProperty(FlashMediaSource.prototype, 'duration', {\n    /**\n     * Return the presentation duration.\n     *\n     * @return {Double} the duration of the media in seconds\n     * @link http://www.w3.org/TR/media-source/#widl-MediaSource-duration\n     */\n    get: function get() {\n      if (!this.swfObj) {\n        return NaN;\n      }\n      // get the current duration from the SWF\n      return this.swfObj.vjs_getProperty('duration');\n    },\n    /**\n     * Set the presentation duration.\n     *\n     * @param {Double} value the duration of the media in seconds\n     * @return {Double} the duration of the media in seconds\n     * @link http://www.w3.org/TR/media-source/#widl-MediaSource-duration\n     */\n    set: function set(value) {\n      var i = undefined;\n      var oldDuration = this.swfObj.vjs_getProperty('duration');\n\n      this.swfObj.vjs_setProperty('duration', value);\n\n      if (value < oldDuration) {\n        // In MSE, this triggers the range removal algorithm which causes\n        // an update to occur\n        for (i = 0; i < this.sourceBuffers.length; i++) {\n          this.sourceBuffers[i].remove(value, oldDuration);\n        }\n      }\n\n      return value;\n    }\n  });\n} catch (e) {\n  // IE8 throws if defineProperty is called on a non-DOM node. We\n  // don't support IE8 but we shouldn't throw an error if loaded\n  // there.\n  FlashMediaSource.prototype.duration = NaN;\n}\n\nfor (var property in _flashConstants2['default']) {\n  FlashMediaSource[property] = _flashConstants2['default'][property];\n}\nmodule.exports = exports['default'];//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdmlkZW9qcy1jb250cmliLW1lZGlhLXNvdXJjZXMvZXM1L2ZsYXNoLW1lZGlhLXNvdXJjZS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDYTs7QUFFYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7O0FBRUYsa0NBQWtDLDJDQUEyQyxnQkFBZ0Isa0JBQWtCLE9BQU8sMkJBQTJCLHdEQUF3RCxnQ0FBZ0MsdURBQXVELCtEQUErRCx5REFBeUQscUVBQXFFLDZEQUE2RCx3QkFBd0I7O0FBRWxqQix3Q0FBd0MsbUJBQW1CLDRCQUE0QixpREFBaUQsZ0JBQWdCLGtEQUFrRCw4REFBOEQsMEJBQTBCLDRDQUE0Qyx1QkFBdUIsb0JBQW9CLE9BQU8sYUFBYSxnQkFBZ0IsZ0JBQWdCLGVBQWUsMkJBQTJCLHdCQUF3Qiw0QkFBNEIscUJBQXFCLE9BQU8sdUJBQXVCLDRCQUE0QixvQkFBb0I7O0FBRTltQix1Q0FBdUMsdUNBQXVDOztBQUU5RSxrREFBa0QsMENBQTBDOztBQUU1RiwyQ0FBMkMsK0RBQStELHVHQUF1Ryx5RUFBeUUsZUFBZSwwRUFBMEUsR0FBRzs7QUFFdFgsc0JBQXNCLG1CQUFPLENBQUMsMkdBQWlCOztBQUUvQzs7QUFFQSxlQUFlLG1CQUFPLENBQUMsNEdBQVU7O0FBRWpDOztBQUVBLHlCQUF5QixtQkFBTyxDQUFDLDRHQUF1Qjs7QUFFeEQ7O0FBRUEsc0JBQXNCLG1CQUFPLENBQUMsb0dBQW1COztBQUVqRDs7QUFFQSxrQkFBa0IsbUJBQU8sQ0FBQyw0RkFBZTs7QUFFekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixnQkFBZ0IsUUFBUTtBQUN4Qjs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVELGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsK0JBQStCO0FBQ25EO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktdjAtcHJvamVjdC8uL25vZGVfbW9kdWxlcy92aWRlb2pzLWNvbnRyaWItbWVkaWEtc291cmNlcy9lczUvZmxhc2gtbWVkaWEtc291cmNlLmpzP2I1MGMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAZmlsZSBmbGFzaC1tZWRpYS1zb3VyY2UuanNcbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IChmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoJ3ZhbHVlJyBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSkoKTtcblxudmFyIF9nZXQgPSBmdW5jdGlvbiBnZXQoX3gsIF94MiwgX3gzKSB7IHZhciBfYWdhaW4gPSB0cnVlOyBfZnVuY3Rpb246IHdoaWxlIChfYWdhaW4pIHsgdmFyIG9iamVjdCA9IF94LCBwcm9wZXJ0eSA9IF94MiwgcmVjZWl2ZXIgPSBfeDM7IF9hZ2FpbiA9IGZhbHNlOyBpZiAob2JqZWN0ID09PSBudWxsKSBvYmplY3QgPSBGdW5jdGlvbi5wcm90b3R5cGU7IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3BlcnR5KTsgaWYgKGRlc2MgPT09IHVuZGVmaW5lZCkgeyB2YXIgcGFyZW50ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChwYXJlbnQgPT09IG51bGwpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSBlbHNlIHsgX3ggPSBwYXJlbnQ7IF94MiA9IHByb3BlcnR5OyBfeDMgPSByZWNlaXZlcjsgX2FnYWluID0gdHJ1ZTsgZGVzYyA9IHBhcmVudCA9IHVuZGVmaW5lZDsgY29udGludWUgX2Z1bmN0aW9uOyB9IH0gZWxzZSBpZiAoJ3ZhbHVlJyBpbiBkZXNjKSB7IHJldHVybiBkZXNjLnZhbHVlOyB9IGVsc2UgeyB2YXIgZ2V0dGVyID0gZGVzYy5nZXQ7IGlmIChnZXR0ZXIgPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IHJldHVybiBnZXR0ZXIuY2FsbChyZWNlaXZlcik7IH0gfSB9O1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uJyk7IH0gfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSAnZnVuY3Rpb24nICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCAnICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgX2dsb2JhbERvY3VtZW50ID0gcmVxdWlyZSgnZ2xvYmFsL2RvY3VtZW50Jyk7XG5cbnZhciBfZ2xvYmFsRG9jdW1lbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2xvYmFsRG9jdW1lbnQpO1xuXG52YXIgX3ZpZGVvSnMgPSByZXF1aXJlKCd2aWRlby5qcycpO1xuXG52YXIgX3ZpZGVvSnMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdmlkZW9Kcyk7XG5cbnZhciBfZmxhc2hTb3VyY2VCdWZmZXIgPSByZXF1aXJlKCcuL2ZsYXNoLXNvdXJjZS1idWZmZXInKTtcblxudmFyIF9mbGFzaFNvdXJjZUJ1ZmZlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9mbGFzaFNvdXJjZUJ1ZmZlcik7XG5cbnZhciBfZmxhc2hDb25zdGFudHMgPSByZXF1aXJlKCcuL2ZsYXNoLWNvbnN0YW50cycpO1xuXG52YXIgX2ZsYXNoQ29uc3RhbnRzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ZsYXNoQ29uc3RhbnRzKTtcblxudmFyIF9jb2RlY1V0aWxzID0gcmVxdWlyZSgnLi9jb2RlYy11dGlscycpO1xuXG4vKipcbiAqIEEgZmxhc2ggaW1wbG1lbnRhdGlvbiBvZiBIVE1MIE1lZGlhU291cmNlcyBhbmQgYSBwb2x5ZmlsbFxuICogZm9yIGJyb3dzZXJzIHRoYXQgZG9uJ3Qgc3VwcG9ydCBuYXRpdmUgb3IgSFRNTCBNZWRpYVNvdXJjZXMuLlxuICpcbiAqIEBsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9NZWRpYVNvdXJjZVxuICogQGNsYXNzIEZsYXNoTWVkaWFTb3VyY2VcbiAqIEBleHRlbmRzIHZpZGVvanMuRXZlbnRUYXJnZXRcbiAqL1xuXG52YXIgRmxhc2hNZWRpYVNvdXJjZSA9IChmdW5jdGlvbiAoX3ZpZGVvanMkRXZlbnRUYXJnZXQpIHtcbiAgX2luaGVyaXRzKEZsYXNoTWVkaWFTb3VyY2UsIF92aWRlb2pzJEV2ZW50VGFyZ2V0KTtcblxuICBmdW5jdGlvbiBGbGFzaE1lZGlhU291cmNlKCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRmxhc2hNZWRpYVNvdXJjZSk7XG5cbiAgICBfZ2V0KE9iamVjdC5nZXRQcm90b3R5cGVPZihGbGFzaE1lZGlhU291cmNlLnByb3RvdHlwZSksICdjb25zdHJ1Y3RvcicsIHRoaXMpLmNhbGwodGhpcyk7XG4gICAgdGhpcy5zb3VyY2VCdWZmZXJzID0gW107XG4gICAgdGhpcy5yZWFkeVN0YXRlID0gJ2Nsb3NlZCc7XG5cbiAgICB0aGlzLm9uKFsnc291cmNlb3BlbicsICd3ZWJraXRzb3VyY2VvcGVuJ10sIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgLy8gZmluZCB0aGUgc3dmIHdoZXJlIHdlIHdpbGwgcHVzaCBtZWRpYSBkYXRhXG4gICAgICBfdGhpcy5zd2ZPYmogPSBfZ2xvYmFsRG9jdW1lbnQyWydkZWZhdWx0J10uZ2V0RWxlbWVudEJ5SWQoZXZlbnQuc3dmSWQpO1xuICAgICAgX3RoaXMucGxheWVyXyA9ICgwLCBfdmlkZW9KczJbJ2RlZmF1bHQnXSkoX3RoaXMuc3dmT2JqLnBhcmVudE5vZGUpO1xuICAgICAgX3RoaXMudGVjaF8gPSBfdGhpcy5zd2ZPYmoudGVjaDtcbiAgICAgIF90aGlzLnJlYWR5U3RhdGUgPSAnb3Blbic7XG5cbiAgICAgIF90aGlzLnRlY2hfLm9uKCdzZWVraW5nJywgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaSA9IF90aGlzLnNvdXJjZUJ1ZmZlcnMubGVuZ3RoO1xuXG4gICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICBfdGhpcy5zb3VyY2VCdWZmZXJzW2ldLmFib3J0KCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICAvLyB0cmlnZ2VyIGxvYWQgZXZlbnRzXG4gICAgICBpZiAoX3RoaXMuc3dmT2JqKSB7XG4gICAgICAgIF90aGlzLnN3Zk9iai52anNfbG9hZCgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAgKiBTZXQgb3IgcmV0dXJuIHRoZSBwcmVzZW50YXRpb24gZHVyYXRpb24uXG4gICAgKlxuICAgICogQHBhcmFtIHtEb3VibGV9IHZhbHVlIHRoZSBkdXJhdGlvbiBvZiB0aGUgbWVkaWEgaW4gc2Vjb25kc1xuICAgICogQHBhcmFtIHtEb3VibGV9IHRoZSBjdXJyZW50IHByZXNlbnRhdGlvbiBkdXJhdGlvblxuICAgICogQGxpbmsgaHR0cDovL3d3dy53My5vcmcvVFIvbWVkaWEtc291cmNlLyN3aWRsLU1lZGlhU291cmNlLWR1cmF0aW9uXG4gICAgKi9cblxuICAvKipcbiAgICogV2UgaGF2ZSB0aGlzIGZ1bmN0aW9uIHNvIHRoYXQgdGhlIGh0bWwgYW5kIGZsYXNoIGludGVyZmFjZXNcbiAgICogYXJlIHRoZSBzYW1lLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuICBfY3JlYXRlQ2xhc3MoRmxhc2hNZWRpYVNvdXJjZSwgW3tcbiAgICBrZXk6ICdhZGRTZWVrYWJsZVJhbmdlXycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZFNlZWthYmxlUmFuZ2VfKCkge31cbiAgICAvLyBpbnRlbnRpb25hbCBuby1vcFxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IGZsYXNoIHNvdXJjZSBidWZmZXIgYW5kIGFkZCBpdCB0byBvdXIgZmxhc2ggbWVkaWEgc291cmNlLlxuICAgICAqXG4gICAgICogQGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL01lZGlhU291cmNlL2FkZFNvdXJjZUJ1ZmZlclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIHRoZSBjb250ZW50LXR5cGUgb2YgdGhlIHNvdXJjZVxuICAgICAqIEByZXR1cm4ge09iamVjdH0gdGhlIGZsYXNoIHNvdXJjZSBidWZmZXJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnYWRkU291cmNlQnVmZmVyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkU291cmNlQnVmZmVyKHR5cGUpIHtcbiAgICAgIHZhciBwYXJzZWRUeXBlID0gKDAsIF9jb2RlY1V0aWxzLnBhcnNlQ29udGVudFR5cGUpKHR5cGUpO1xuICAgICAgdmFyIHNvdXJjZUJ1ZmZlciA9IHVuZGVmaW5lZDtcblxuICAgICAgLy8gaWYgdGhpcyBpcyBhbiBGTFYgdHlwZSwgd2UnbGwgcHVzaCBkYXRhIHRvIGZsYXNoXG4gICAgICBpZiAocGFyc2VkVHlwZS50eXBlID09PSAndmlkZW8vbXAydCcgfHwgcGFyc2VkVHlwZS50eXBlID09PSAnYXVkaW8vbXAydCcpIHtcbiAgICAgICAgLy8gRmxhc2ggc291cmNlIGJ1ZmZlcnNcbiAgICAgICAgc291cmNlQnVmZmVyID0gbmV3IF9mbGFzaFNvdXJjZUJ1ZmZlcjJbJ2RlZmF1bHQnXSh0aGlzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm90U3VwcG9ydGVkRXJyb3IgKFZpZGVvLmpzKScpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnNvdXJjZUJ1ZmZlcnMucHVzaChzb3VyY2VCdWZmZXIpO1xuICAgICAgcmV0dXJuIHNvdXJjZUJ1ZmZlcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTaWduYWxzIHRoZSBlbmQgb2YgdGhlIHN0cmVhbS5cbiAgICAgKlxuICAgICAqIEBsaW5rIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby9tZWRpYS1zb3VyY2UvI3dpZGwtTWVkaWFTb3VyY2UtZW5kT2ZTdHJlYW0tdm9pZC1FbmRPZlN0cmVhbUVycm9yLWVycm9yXG4gICAgICogQHBhcmFtIHtTdHJpbmc9fSBlcnJvciBTaWduYWxzIHRoYXQgYSBwbGF5YmFjayBlcnJvclxuICAgICAqIGhhcyBvY2N1cnJlZC4gSWYgc3BlY2lmaWVkLCBpdCBtdXN0IGJlIGVpdGhlciBcIm5ldHdvcmtcIiBvclxuICAgICAqIFwiZGVjb2RlXCIuXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdlbmRPZlN0cmVhbScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVuZE9mU3RyZWFtKGVycm9yKSB7XG4gICAgICBpZiAoZXJyb3IgPT09ICduZXR3b3JrJykge1xuICAgICAgICAvLyBNRURJQV9FUlJfTkVUV09SS1xuICAgICAgICB0aGlzLnRlY2hfLmVycm9yKDIpO1xuICAgICAgfSBlbHNlIGlmIChlcnJvciA9PT0gJ2RlY29kZScpIHtcbiAgICAgICAgLy8gTUVESUFfRVJSX0RFQ09ERVxuICAgICAgICB0aGlzLnRlY2hfLmVycm9yKDMpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMucmVhZHlTdGF0ZSAhPT0gJ2VuZGVkJykge1xuICAgICAgICB0aGlzLnJlYWR5U3RhdGUgPSAnZW5kZWQnO1xuICAgICAgICB0aGlzLnN3Zk9iai52anNfZW5kT2ZTdHJlYW0oKTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gRmxhc2hNZWRpYVNvdXJjZTtcbn0pKF92aWRlb0pzMlsnZGVmYXVsdCddLkV2ZW50VGFyZ2V0KTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gRmxhc2hNZWRpYVNvdXJjZTtcbnRyeSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGbGFzaE1lZGlhU291cmNlLnByb3RvdHlwZSwgJ2R1cmF0aW9uJywge1xuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgcHJlc2VudGF0aW9uIGR1cmF0aW9uLlxuICAgICAqXG4gICAgICogQHJldHVybiB7RG91YmxlfSB0aGUgZHVyYXRpb24gb2YgdGhlIG1lZGlhIGluIHNlY29uZHNcbiAgICAgKiBAbGluayBodHRwOi8vd3d3LnczLm9yZy9UUi9tZWRpYS1zb3VyY2UvI3dpZGwtTWVkaWFTb3VyY2UtZHVyYXRpb25cbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIGlmICghdGhpcy5zd2ZPYmopIHtcbiAgICAgICAgcmV0dXJuIE5hTjtcbiAgICAgIH1cbiAgICAgIC8vIGdldCB0aGUgY3VycmVudCBkdXJhdGlvbiBmcm9tIHRoZSBTV0ZcbiAgICAgIHJldHVybiB0aGlzLnN3Zk9iai52anNfZ2V0UHJvcGVydHkoJ2R1cmF0aW9uJyk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHByZXNlbnRhdGlvbiBkdXJhdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RG91YmxlfSB2YWx1ZSB0aGUgZHVyYXRpb24gb2YgdGhlIG1lZGlhIGluIHNlY29uZHNcbiAgICAgKiBAcmV0dXJuIHtEb3VibGV9IHRoZSBkdXJhdGlvbiBvZiB0aGUgbWVkaWEgaW4gc2Vjb25kc1xuICAgICAqIEBsaW5rIGh0dHA6Ly93d3cudzMub3JnL1RSL21lZGlhLXNvdXJjZS8jd2lkbC1NZWRpYVNvdXJjZS1kdXJhdGlvblxuICAgICAqL1xuICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICB2YXIgaSA9IHVuZGVmaW5lZDtcbiAgICAgIHZhciBvbGREdXJhdGlvbiA9IHRoaXMuc3dmT2JqLnZqc19nZXRQcm9wZXJ0eSgnZHVyYXRpb24nKTtcblxuICAgICAgdGhpcy5zd2ZPYmoudmpzX3NldFByb3BlcnR5KCdkdXJhdGlvbicsIHZhbHVlKTtcblxuICAgICAgaWYgKHZhbHVlIDwgb2xkRHVyYXRpb24pIHtcbiAgICAgICAgLy8gSW4gTVNFLCB0aGlzIHRyaWdnZXJzIHRoZSByYW5nZSByZW1vdmFsIGFsZ29yaXRobSB3aGljaCBjYXVzZXNcbiAgICAgICAgLy8gYW4gdXBkYXRlIHRvIG9jY3VyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLnNvdXJjZUJ1ZmZlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB0aGlzLnNvdXJjZUJ1ZmZlcnNbaV0ucmVtb3ZlKHZhbHVlLCBvbGREdXJhdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgfSk7XG59IGNhdGNoIChlKSB7XG4gIC8vIElFOCB0aHJvd3MgaWYgZGVmaW5lUHJvcGVydHkgaXMgY2FsbGVkIG9uIGEgbm9uLURPTSBub2RlLiBXZVxuICAvLyBkb24ndCBzdXBwb3J0IElFOCBidXQgd2Ugc2hvdWxkbid0IHRocm93IGFuIGVycm9yIGlmIGxvYWRlZFxuICAvLyB0aGVyZS5cbiAgRmxhc2hNZWRpYVNvdXJjZS5wcm90b3R5cGUuZHVyYXRpb24gPSBOYU47XG59XG5cbmZvciAodmFyIHByb3BlcnR5IGluIF9mbGFzaENvbnN0YW50czJbJ2RlZmF1bHQnXSkge1xuICBGbGFzaE1lZGlhU291cmNlW3Byb3BlcnR5XSA9IF9mbGFzaENvbnN0YW50czJbJ2RlZmF1bHQnXVtwcm9wZXJ0eV07XG59XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/videojs-contrib-media-sources/es5/flash-media-source.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/videojs-contrib-media-sources/es5/flash-source-buffer.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/videojs-contrib-media-sources/es5/flash-source-buffer.js ***!
  \*******************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("/**\n * @file flash-source-buffer.js\n */\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nvar _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar _globalWindow = __webpack_require__(/*! global/window */ \"(ssr)/./node_modules/videojs-contrib-media-sources/node_modules/global/window.js\");\n\nvar _globalWindow2 = _interopRequireDefault(_globalWindow);\n\nvar _videoJs = __webpack_require__(/*! video.js */ \"(ssr)/./node_modules/videojs-contrib-media-sources/node_modules/video.js/dist/video.cjs.js\");\n\nvar _videoJs2 = _interopRequireDefault(_videoJs);\n\nvar _muxJsLibFlv = __webpack_require__(/*! mux.js/lib/flv */ \"(ssr)/./node_modules/videojs-contrib-media-sources/node_modules/mux.js/lib/flv/index.js\");\n\nvar _muxJsLibFlv2 = _interopRequireDefault(_muxJsLibFlv);\n\nvar _removeCuesFromTrack = __webpack_require__(/*! ./remove-cues-from-track */ \"(ssr)/./node_modules/videojs-contrib-media-sources/es5/remove-cues-from-track.js\");\n\nvar _removeCuesFromTrack2 = _interopRequireDefault(_removeCuesFromTrack);\n\nvar _createTextTracksIfNecessary = __webpack_require__(/*! ./create-text-tracks-if-necessary */ \"(ssr)/./node_modules/videojs-contrib-media-sources/es5/create-text-tracks-if-necessary.js\");\n\nvar _createTextTracksIfNecessary2 = _interopRequireDefault(_createTextTracksIfNecessary);\n\nvar _addTextTrackData = __webpack_require__(/*! ./add-text-track-data */ \"(ssr)/./node_modules/videojs-contrib-media-sources/es5/add-text-track-data.js\");\n\nvar _flashTransmuxerWorker = __webpack_require__(/*! ./flash-transmuxer-worker */ \"(ssr)/./node_modules/videojs-contrib-media-sources/es5/flash-transmuxer-worker.js\");\n\nvar _flashTransmuxerWorker2 = _interopRequireDefault(_flashTransmuxerWorker);\n\nvar _webwackify = __webpack_require__(/*! webwackify */ \"(ssr)/./node_modules/webwackify/index.js\");\n\nvar _webwackify2 = _interopRequireDefault(_webwackify);\n\nvar _flashConstants = __webpack_require__(/*! ./flash-constants */ \"(ssr)/./node_modules/videojs-contrib-media-sources/es5/flash-constants.js\");\n\nvar _flashConstants2 = _interopRequireDefault(_flashConstants);\n\nvar resolveFlashTransmuxWorker = function resolveFlashTransmuxWorker() {\n  var result = undefined;\n\n  try {\n    result = /*require.resolve*/(/*! ./flash-transmuxer-worker */ \"(ssr)/./node_modules/videojs-contrib-media-sources/es5/flash-transmuxer-worker.js\");\n  } catch (e) {\n    // no result\n  }\n\n  return result;\n};\n\n/**\n * A wrapper around the setTimeout function that uses\n * the flash constant time between ticks value.\n *\n * @param {Function} func the function callback to run\n * @private\n */\nvar scheduleTick = function scheduleTick(func) {\n  // Chrome doesn't invoke requestAnimationFrame callbacks\n  // in background tabs, so use setTimeout.\n  _globalWindow2['default'].setTimeout(func, _flashConstants2['default'].TIME_BETWEEN_CHUNKS);\n};\n\n/**\n * Generates a random string of max length 6\n *\n * @return {String} the randomly generated string\n * @function generateRandomString\n * @private\n */\nvar generateRandomString = function generateRandomString() {\n  return Math.random().toString(36).slice(2, 8);\n};\n\n/**\n * Round a number to a specified number of places much like\n * toFixed but return a number instead of a string representation.\n *\n * @param {Number} num A number\n * @param {Number} places The number of decimal places which to\n * round\n * @private\n */\nvar toDecimalPlaces = function toDecimalPlaces(num, places) {\n  if (typeof places !== 'number' || places < 0) {\n    places = 0;\n  }\n\n  var scale = Math.pow(10, places);\n\n  return Math.round(num * scale) / scale;\n};\n\n/**\n * A SourceBuffer implementation for Flash rather than HTML.\n *\n * @link https://developer.mozilla.org/en-US/docs/Web/API/MediaSource\n * @param {Object} mediaSource the flash media source\n * @class FlashSourceBuffer\n * @extends videojs.EventTarget\n */\n\nvar FlashSourceBuffer = (function (_videojs$EventTarget) {\n  _inherits(FlashSourceBuffer, _videojs$EventTarget);\n\n  function FlashSourceBuffer(mediaSource) {\n    var _this = this;\n\n    _classCallCheck(this, FlashSourceBuffer);\n\n    _get(Object.getPrototypeOf(FlashSourceBuffer.prototype), 'constructor', this).call(this);\n    var encodedHeader = undefined;\n\n    // Start off using the globally defined value but refine\n    // as we append data into flash\n    this.chunkSize_ = _flashConstants2['default'].BYTES_PER_CHUNK;\n\n    // byte arrays queued to be appended\n    this.buffer_ = [];\n\n    // the total number of queued bytes\n    this.bufferSize_ = 0;\n\n    // to be able to determine the correct position to seek to, we\n    // need to retain information about the mapping between the\n    // media timeline and PTS values\n    this.basePtsOffset_ = NaN;\n\n    this.mediaSource_ = mediaSource;\n\n    this.audioBufferEnd_ = NaN;\n    this.videoBufferEnd_ = NaN;\n\n    // indicates whether the asynchronous continuation of an operation\n    // is still being processed\n    // see https://w3c.github.io/media-source/#widl-SourceBuffer-updating\n    this.updating = false;\n    this.timestampOffset_ = 0;\n\n    encodedHeader = _globalWindow2['default'].btoa(String.fromCharCode.apply(null, Array.prototype.slice.call(_muxJsLibFlv2['default'].getFlvHeader())));\n\n    // create function names with added randomness for the global callbacks flash will use\n    // to get data from javascript into the swf. Random strings are added as a safety\n    // measure for pages with multiple players since these functions will be global\n    // instead of per instance. When making a call to the swf, the browser generates a\n    // try catch code snippet, but just takes the function name and writes out an unquoted\n    // call to that function. If the player id has any special characters, this will result\n    // in an error, so safePlayerId replaces all special characters to '_'\n    var safePlayerId = this.mediaSource_.player_.id().replace(/[^a-zA-Z0-9]/g, '_');\n\n    this.flashEncodedHeaderName_ = 'vjs_flashEncodedHeader_' + safePlayerId + generateRandomString();\n    this.flashEncodedDataName_ = 'vjs_flashEncodedData_' + safePlayerId + generateRandomString();\n\n    _globalWindow2['default'][this.flashEncodedHeaderName_] = function () {\n      delete _globalWindow2['default'][_this.flashEncodedHeaderName_];\n      return encodedHeader;\n    };\n\n    this.mediaSource_.swfObj.vjs_appendChunkReady(this.flashEncodedHeaderName_);\n\n    this.transmuxer_ = (0, _webwackify2['default'])(_flashTransmuxerWorker2['default'], resolveFlashTransmuxWorker());\n    this.transmuxer_.postMessage({ action: 'init', options: {} });\n    this.transmuxer_.onmessage = function (event) {\n      if (event.data.action === 'data') {\n        _this.receiveBuffer_(event.data.segment);\n      }\n    };\n\n    this.one('updateend', function () {\n      _this.mediaSource_.tech_.trigger('loadedmetadata');\n    });\n\n    Object.defineProperty(this, 'timestampOffset', {\n      get: function get() {\n        return this.timestampOffset_;\n      },\n      set: function set(val) {\n        if (typeof val === 'number' && val >= 0) {\n          this.timestampOffset_ = val;\n          // We have to tell flash to expect a discontinuity\n          this.mediaSource_.swfObj.vjs_discontinuity();\n          // the media <-> PTS mapping must be re-established after\n          // the discontinuity\n          this.basePtsOffset_ = NaN;\n          this.audioBufferEnd_ = NaN;\n          this.videoBufferEnd_ = NaN;\n\n          this.transmuxer_.postMessage({ action: 'reset' });\n        }\n      }\n    });\n\n    Object.defineProperty(this, 'buffered', {\n      get: function get() {\n        if (!this.mediaSource_ || !this.mediaSource_.swfObj || !('vjs_getProperty' in this.mediaSource_.swfObj)) {\n          return _videoJs2['default'].createTimeRange();\n        }\n\n        var buffered = this.mediaSource_.swfObj.vjs_getProperty('buffered');\n\n        if (buffered && buffered.length) {\n          buffered[0][0] = toDecimalPlaces(buffered[0][0], 3);\n          buffered[0][1] = toDecimalPlaces(buffered[0][1], 3);\n        }\n        return _videoJs2['default'].createTimeRanges(buffered);\n      }\n    });\n\n    // On a seek we remove all text track data since flash has no concept\n    // of a buffered-range and everything else is reset on seek\n    this.mediaSource_.player_.on('seeked', function () {\n      (0, _removeCuesFromTrack2['default'])(0, Infinity, _this.metadataTrack_);\n      if (_this.inbandTextTracks_) {\n        for (var track in _this.inbandTextTracks_) {\n          (0, _removeCuesFromTrack2['default'])(0, Infinity, _this.inbandTextTracks_[track]);\n        }\n      }\n    });\n\n    var onHlsReset = this.onHlsReset_.bind(this);\n\n    // hls-reset is fired by videojs.Hls on to the tech after the main SegmentLoader\n    // resets its state and flushes the buffer\n    this.mediaSource_.player_.tech_.on('hls-reset', onHlsReset);\n\n    this.mediaSource_.player_.tech_.hls.on('dispose', function () {\n      _this.transmuxer_.terminate();\n      _this.mediaSource_.player_.tech_.off('hls-reset', onHlsReset);\n    });\n  }\n\n  /**\n   * Append bytes to the sourcebuffers buffer, in this case we\n   * have to append it to swf object.\n   *\n   * @link https://developer.mozilla.org/en-US/docs/Web/API/SourceBuffer/appendBuffer\n   * @param {Array} bytes\n   */\n\n  _createClass(FlashSourceBuffer, [{\n    key: 'appendBuffer',\n    value: function appendBuffer(bytes) {\n      var error = undefined;\n\n      if (this.updating) {\n        error = new Error('SourceBuffer.append() cannot be called ' + 'while an update is in progress');\n        error.name = 'InvalidStateError';\n        error.code = 11;\n        throw error;\n      }\n      this.updating = true;\n      this.mediaSource_.readyState = 'open';\n      this.trigger({ type: 'update' });\n\n      this.transmuxer_.postMessage({\n        action: 'push',\n        data: bytes.buffer,\n        byteOffset: bytes.byteOffset,\n        byteLength: bytes.byteLength\n      }, [bytes.buffer]);\n      this.transmuxer_.postMessage({ action: 'flush' });\n    }\n\n    /**\n     * Reset the parser and remove any data queued to be sent to the SWF.\n     *\n     * @link https://developer.mozilla.org/en-US/docs/Web/API/SourceBuffer/abort\n     */\n  }, {\n    key: 'abort',\n    value: function abort() {\n      this.buffer_ = [];\n      this.bufferSize_ = 0;\n      this.mediaSource_.swfObj.vjs_abort();\n\n      // report any outstanding updates have ended\n      if (this.updating) {\n        this.updating = false;\n        this.trigger({ type: 'updateend' });\n      }\n    }\n\n    /**\n     * Flash cannot remove ranges already buffered in the NetStream\n     * but seeking clears the buffer entirely. For most purposes,\n     * having this operation act as a no-op is acceptable.\n     *\n     * @link https://developer.mozilla.org/en-US/docs/Web/API/SourceBuffer/remove\n     * @param {Double} start start of the section to remove\n     * @param {Double} end end of the section to remove\n     */\n  }, {\n    key: 'remove',\n    value: function remove(start, end) {\n      (0, _removeCuesFromTrack2['default'])(start, end, this.metadataTrack_);\n      if (this.inbandTextTracks_) {\n        for (var track in this.inbandTextTracks_) {\n          (0, _removeCuesFromTrack2['default'])(start, end, this.inbandTextTracks_[track]);\n        }\n      }\n      this.trigger({ type: 'update' });\n      this.trigger({ type: 'updateend' });\n    }\n\n    /**\n     * Receive a buffer from the flv.\n     *\n     * @param {Object} segment\n     * @private\n     */\n  }, {\n    key: 'receiveBuffer_',\n    value: function receiveBuffer_(segment) {\n      var _this2 = this;\n\n      // create an in-band caption track if one is present in the segment\n      (0, _createTextTracksIfNecessary2['default'])(this, this.mediaSource_, segment);\n      (0, _addTextTrackData.addTextTrackData)(this, segment.captions, segment.metadata);\n\n      // Do this asynchronously since convertTagsToData_ can be time consuming\n      scheduleTick(function () {\n        var flvBytes = _this2.convertTagsToData_(segment);\n\n        if (_this2.buffer_.length === 0) {\n          scheduleTick(_this2.processBuffer_.bind(_this2));\n        }\n\n        if (flvBytes) {\n          _this2.buffer_.push(flvBytes);\n          _this2.bufferSize_ += flvBytes.byteLength;\n        }\n      });\n    }\n\n    /**\n     * Append a portion of the current buffer to the SWF.\n     *\n     * @private\n     */\n  }, {\n    key: 'processBuffer_',\n    value: function processBuffer_() {\n      var _this3 = this;\n\n      var chunkSize = _flashConstants2['default'].BYTES_PER_CHUNK;\n\n      if (!this.buffer_.length) {\n        if (this.updating !== false) {\n          this.updating = false;\n          this.trigger({ type: 'updateend' });\n        }\n        // do nothing if the buffer is empty\n        return;\n      }\n\n      // concatenate appends up to the max append size\n      var chunk = this.buffer_[0].subarray(0, chunkSize);\n\n      // requeue any bytes that won't make it this round\n      if (chunk.byteLength < chunkSize || this.buffer_[0].byteLength === chunkSize) {\n        this.buffer_.shift();\n      } else {\n        this.buffer_[0] = this.buffer_[0].subarray(chunkSize);\n      }\n\n      this.bufferSize_ -= chunk.byteLength;\n\n      // base64 encode the bytes\n      var binary = [];\n      var length = chunk.byteLength;\n\n      for (var i = 0; i < length; i++) {\n        binary.push(String.fromCharCode(chunk[i]));\n      }\n      var b64str = _globalWindow2['default'].btoa(binary.join(''));\n\n      _globalWindow2['default'][this.flashEncodedDataName_] = function () {\n        // schedule another processBuffer to process any left over data or to\n        // trigger updateend\n        scheduleTick(_this3.processBuffer_.bind(_this3));\n        delete _globalWindow2['default'][_this3.flashEncodedDataName_];\n        return b64str;\n      };\n\n      // Notify the swf that segment data is ready to be appended\n      this.mediaSource_.swfObj.vjs_appendChunkReady(this.flashEncodedDataName_);\n    }\n\n    /**\n     * Turns an array of flv tags into a Uint8Array representing the\n     * flv data. Also removes any tags that are before the current\n     * time so that playback begins at or slightly after the right\n     * place on a seek\n     *\n     * @private\n     * @param {Object} segmentData object of segment data\n     */\n  }, {\n    key: 'convertTagsToData_',\n    value: function convertTagsToData_(segmentData) {\n      var segmentByteLength = 0;\n      var tech = this.mediaSource_.tech_;\n      var videoTargetPts = 0;\n      var segment = undefined;\n      var videoTags = segmentData.tags.videoTags;\n      var audioTags = segmentData.tags.audioTags;\n\n      // Establish the media timeline to PTS translation if we don't\n      // have one already\n      if (isNaN(this.basePtsOffset_) && (videoTags.length || audioTags.length)) {\n        // We know there is at least one video or audio tag, but since we may not have both,\n        // we use pts: Infinity for the missing tag. The will force the following Math.min\n        // call will to use the proper pts value since it will always be less than Infinity\n        var firstVideoTag = videoTags[0] || { pts: Infinity };\n        var firstAudioTag = audioTags[0] || { pts: Infinity };\n\n        this.basePtsOffset_ = Math.min(firstAudioTag.pts, firstVideoTag.pts);\n      }\n\n      if (tech.seeking()) {\n        // Do not use previously saved buffer end values while seeking since buffer\n        // is cleared on all seeks\n        this.videoBufferEnd_ = NaN;\n        this.audioBufferEnd_ = NaN;\n      }\n\n      if (isNaN(this.videoBufferEnd_)) {\n        if (tech.buffered().length) {\n          videoTargetPts = tech.buffered().end(0) - this.timestampOffset;\n        }\n\n        // Trim to currentTime if seeking\n        if (tech.seeking()) {\n          videoTargetPts = Math.max(videoTargetPts, tech.currentTime() - this.timestampOffset);\n        }\n\n        // PTS values are represented in milliseconds\n        videoTargetPts *= 1e3;\n        videoTargetPts += this.basePtsOffset_;\n      } else {\n        // Add a fudge factor of 0.1 to the last video pts appended since a rendition change\n        // could append an overlapping segment, in which case there is a high likelyhood\n        // a tag could have a matching pts to videoBufferEnd_, which would cause\n        // that tag to get appended by the tag.pts >= targetPts check below even though it\n        // is a duplicate of what was previously appended\n        videoTargetPts = this.videoBufferEnd_ + 0.1;\n      }\n\n      // filter complete GOPs with a presentation time less than the seek target/end of buffer\n      var currentIndex = videoTags.length;\n\n      // if the last tag is beyond videoTargetPts, then do not search the list for a GOP\n      // since our videoTargetPts lies in a future segment\n      if (currentIndex && videoTags[currentIndex - 1].pts >= videoTargetPts) {\n        // Start by walking backwards from the end of the list until we reach a tag that\n        // is equal to or less than videoTargetPts\n        while (--currentIndex) {\n          var currentTag = videoTags[currentIndex];\n\n          if (currentTag.pts > videoTargetPts) {\n            continue;\n          }\n\n          // if we see a keyFrame or metadata tag once we've gone below videoTargetPts,\n          // exit the loop as this is the start of the GOP that we want to append\n          if (currentTag.keyFrame || currentTag.metaDataTag) {\n            break;\n          }\n        }\n\n        // We need to check if there are any metadata tags that come before currentIndex\n        // as those will be metadata tags associated with the GOP we are appending\n        // There could be 0 to 2 metadata tags that come before the currentIndex depending\n        // on what videoTargetPts is and whether the transmuxer prepended metadata tags to this\n        // key frame\n        while (currentIndex) {\n          var nextTag = videoTags[currentIndex - 1];\n\n          if (!nextTag.metaDataTag) {\n            break;\n          }\n\n          currentIndex--;\n        }\n      }\n\n      var filteredVideoTags = videoTags.slice(currentIndex);\n\n      var audioTargetPts = undefined;\n\n      if (isNaN(this.audioBufferEnd_)) {\n        audioTargetPts = videoTargetPts;\n      } else {\n        // Add a fudge factor of 0.1 to the last video pts appended since a rendition change\n        // could append an overlapping segment, in which case there is a high likelyhood\n        // a tag could have a matching pts to videoBufferEnd_, which would cause\n        // that tag to get appended by the tag.pts >= targetPts check below even though it\n        // is a duplicate of what was previously appended\n        audioTargetPts = this.audioBufferEnd_ + 0.1;\n      }\n\n      if (filteredVideoTags.length) {\n        // If targetPts intersects a GOP and we appended the tags for the GOP that came\n        // before targetPts, we want to make sure to trim audio tags at the pts\n        // of the first video tag to avoid brief moments of silence\n        audioTargetPts = Math.min(audioTargetPts, filteredVideoTags[0].pts);\n      }\n\n      // skip tags with a presentation time less than the seek target/end of buffer\n      currentIndex = 0;\n\n      while (currentIndex < audioTags.length) {\n        if (audioTags[currentIndex].pts >= audioTargetPts) {\n          break;\n        }\n\n        currentIndex++;\n      }\n\n      var filteredAudioTags = audioTags.slice(currentIndex);\n\n      // update the audio and video buffer ends\n      if (filteredAudioTags.length) {\n        this.audioBufferEnd_ = filteredAudioTags[filteredAudioTags.length - 1].pts;\n      }\n      if (filteredVideoTags.length) {\n        this.videoBufferEnd_ = filteredVideoTags[filteredVideoTags.length - 1].pts;\n      }\n\n      var tags = this.getOrderedTags_(filteredVideoTags, filteredAudioTags);\n\n      if (tags.length === 0) {\n        return;\n      }\n\n      // If we are appending data that comes before our target pts, we want to tell\n      // the swf to adjust its notion of current time to account for the extra tags\n      // we are appending to complete the GOP that intersects with targetPts\n      if (tags[0].pts < videoTargetPts && tech.seeking()) {\n        var fudgeFactor = 1 / 30;\n        var currentTime = tech.currentTime();\n        var diff = (videoTargetPts - tags[0].pts) / 1e3;\n        var adjustedTime = currentTime - diff;\n\n        if (adjustedTime < fudgeFactor) {\n          adjustedTime = 0;\n        }\n\n        try {\n          this.mediaSource_.swfObj.vjs_adjustCurrentTime(adjustedTime);\n        } catch (e) {\n          // no-op for backwards compatability of swf. If adjustCurrentTime fails,\n          // the swf may incorrectly report currentTime and buffered ranges\n          // but should not affect playback over than the time displayed on the\n          // progress bar is inaccurate\n        }\n      }\n\n      // concatenate the bytes into a single segment\n      for (var i = 0; i < tags.length; i++) {\n        segmentByteLength += tags[i].bytes.byteLength;\n      }\n      segment = new Uint8Array(segmentByteLength);\n      for (var i = 0, j = 0; i < tags.length; i++) {\n        segment.set(tags[i].bytes, j);\n        j += tags[i].bytes.byteLength;\n      }\n\n      return segment;\n    }\n\n    /**\n     * Assemble the FLV tags in decoder order.\n     *\n     * @private\n     * @param {Array} videoTags list of video tags\n     * @param {Array} audioTags list of audio tags\n     */\n  }, {\n    key: 'getOrderedTags_',\n    value: function getOrderedTags_(videoTags, audioTags) {\n      var tag = undefined;\n      var tags = [];\n\n      while (videoTags.length || audioTags.length) {\n        if (!videoTags.length) {\n          // only audio tags remain\n          tag = audioTags.shift();\n        } else if (!audioTags.length) {\n          // only video tags remain\n          tag = videoTags.shift();\n        } else if (audioTags[0].dts < videoTags[0].dts) {\n          // audio should be decoded next\n          tag = audioTags.shift();\n        } else {\n          // video should be decoded next\n          tag = videoTags.shift();\n        }\n\n        tags.push(tag);\n      }\n\n      return tags;\n    }\n  }, {\n    key: 'onHlsReset_',\n    value: function onHlsReset_() {\n      this.transmuxer_.postMessage({ action: 'resetCaptions' });\n    }\n  }]);\n\n  return FlashSourceBuffer;\n})(_videoJs2['default'].EventTarget);\n\nexports[\"default\"] = FlashSourceBuffer;\nmodule.exports = exports['default'];//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdmlkZW9qcy1jb250cmliLW1lZGlhLXNvdXJjZXMvZXM1L2ZsYXNoLXNvdXJjZS1idWZmZXIuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ2E7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDOztBQUVGLGtDQUFrQywyQ0FBMkMsZ0JBQWdCLGtCQUFrQixPQUFPLDJCQUEyQix3REFBd0QsZ0NBQWdDLHVEQUF1RCwrREFBK0QseURBQXlELHFFQUFxRSw2REFBNkQsd0JBQXdCOztBQUVsakIsd0NBQXdDLG1CQUFtQiw0QkFBNEIsaURBQWlELGdCQUFnQixrREFBa0QsOERBQThELDBCQUEwQiw0Q0FBNEMsdUJBQXVCLG9CQUFvQixPQUFPLGFBQWEsZ0JBQWdCLGdCQUFnQixlQUFlLDJCQUEyQix3QkFBd0IsNEJBQTRCLHFCQUFxQixPQUFPLHVCQUF1Qiw0QkFBNEIsb0JBQW9COztBQUU5bUIsdUNBQXVDLHVDQUF1Qzs7QUFFOUUsa0RBQWtELDBDQUEwQzs7QUFFNUYsMkNBQTJDLCtEQUErRCx1R0FBdUcseUVBQXlFLGVBQWUsMEVBQTBFLEdBQUc7O0FBRXRYLG9CQUFvQixtQkFBTyxDQUFDLHVHQUFlOztBQUUzQzs7QUFFQSxlQUFlLG1CQUFPLENBQUMsNEdBQVU7O0FBRWpDOztBQUVBLG1CQUFtQixtQkFBTyxDQUFDLCtHQUFnQjs7QUFFM0M7O0FBRUEsMkJBQTJCLG1CQUFPLENBQUMsa0hBQTBCOztBQUU3RDs7QUFFQSxtQ0FBbUMsbUJBQU8sQ0FBQyxvSUFBbUM7O0FBRTlFOztBQUVBLHdCQUF3QixtQkFBTyxDQUFDLDRHQUF1Qjs7QUFFdkQsNkJBQTZCLG1CQUFPLENBQUMsb0hBQTJCOztBQUVoRTs7QUFFQSxrQkFBa0IsbUJBQU8sQ0FBQyw0REFBWTs7QUFFdEM7O0FBRUEsc0JBQXNCLG1CQUFPLENBQUMsb0dBQW1COztBQUVqRDs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxtQkFBZSxDQUFD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QTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDLDhDQUE4Qzs7QUFFOUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0IsaUJBQWlCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixpQkFBaUI7QUFDOUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxxQ0FBcUMseUJBQXlCO0FBQzlEO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQsa0JBQWtCO0FBQ2xCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktdjAtcHJvamVjdC8uL25vZGVfbW9kdWxlcy92aWRlb2pzLWNvbnRyaWItbWVkaWEtc291cmNlcy9lczUvZmxhc2gtc291cmNlLWJ1ZmZlci5qcz9hODkwIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGZpbGUgZmxhc2gtc291cmNlLWJ1ZmZlci5qc1xuICovXG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gKGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmICgndmFsdWUnIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KSgpO1xuXG52YXIgX2dldCA9IGZ1bmN0aW9uIGdldChfeCwgX3gyLCBfeDMpIHsgdmFyIF9hZ2FpbiA9IHRydWU7IF9mdW5jdGlvbjogd2hpbGUgKF9hZ2FpbikgeyB2YXIgb2JqZWN0ID0gX3gsIHByb3BlcnR5ID0gX3gyLCByZWNlaXZlciA9IF94MzsgX2FnYWluID0gZmFsc2U7IGlmIChvYmplY3QgPT09IG51bGwpIG9iamVjdCA9IEZ1bmN0aW9uLnByb3RvdHlwZTsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgcHJvcGVydHkpOyBpZiAoZGVzYyA9PT0gdW5kZWZpbmVkKSB7IHZhciBwYXJlbnQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgaWYgKHBhcmVudCA9PT0gbnVsbCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IGVsc2UgeyBfeCA9IHBhcmVudDsgX3gyID0gcHJvcGVydHk7IF94MyA9IHJlY2VpdmVyOyBfYWdhaW4gPSB0cnVlOyBkZXNjID0gcGFyZW50ID0gdW5kZWZpbmVkOyBjb250aW51ZSBfZnVuY3Rpb247IH0gfSBlbHNlIGlmICgndmFsdWUnIGluIGRlc2MpIHsgcmV0dXJuIGRlc2MudmFsdWU7IH0gZWxzZSB7IHZhciBnZXR0ZXIgPSBkZXNjLmdldDsgaWYgKGdldHRlciA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gcmV0dXJuIGdldHRlci5jYWxsKHJlY2VpdmVyKTsgfSB9IH07XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb24nKTsgfSB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09ICdmdW5jdGlvbicgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90ICcgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBfZ2xvYmFsV2luZG93ID0gcmVxdWlyZSgnZ2xvYmFsL3dpbmRvdycpO1xuXG52YXIgX2dsb2JhbFdpbmRvdzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9nbG9iYWxXaW5kb3cpO1xuXG52YXIgX3ZpZGVvSnMgPSByZXF1aXJlKCd2aWRlby5qcycpO1xuXG52YXIgX3ZpZGVvSnMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdmlkZW9Kcyk7XG5cbnZhciBfbXV4SnNMaWJGbHYgPSByZXF1aXJlKCdtdXguanMvbGliL2ZsdicpO1xuXG52YXIgX211eEpzTGliRmx2MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX211eEpzTGliRmx2KTtcblxudmFyIF9yZW1vdmVDdWVzRnJvbVRyYWNrID0gcmVxdWlyZSgnLi9yZW1vdmUtY3Vlcy1mcm9tLXRyYWNrJyk7XG5cbnZhciBfcmVtb3ZlQ3Vlc0Zyb21UcmFjazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZW1vdmVDdWVzRnJvbVRyYWNrKTtcblxudmFyIF9jcmVhdGVUZXh0VHJhY2tzSWZOZWNlc3NhcnkgPSByZXF1aXJlKCcuL2NyZWF0ZS10ZXh0LXRyYWNrcy1pZi1uZWNlc3NhcnknKTtcblxudmFyIF9jcmVhdGVUZXh0VHJhY2tzSWZOZWNlc3NhcnkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlVGV4dFRyYWNrc0lmTmVjZXNzYXJ5KTtcblxudmFyIF9hZGRUZXh0VHJhY2tEYXRhID0gcmVxdWlyZSgnLi9hZGQtdGV4dC10cmFjay1kYXRhJyk7XG5cbnZhciBfZmxhc2hUcmFuc211eGVyV29ya2VyID0gcmVxdWlyZSgnLi9mbGFzaC10cmFuc211eGVyLXdvcmtlcicpO1xuXG52YXIgX2ZsYXNoVHJhbnNtdXhlcldvcmtlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9mbGFzaFRyYW5zbXV4ZXJXb3JrZXIpO1xuXG52YXIgX3dlYndhY2tpZnkgPSByZXF1aXJlKCd3ZWJ3YWNraWZ5Jyk7XG5cbnZhciBfd2Vid2Fja2lmeTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF93ZWJ3YWNraWZ5KTtcblxudmFyIF9mbGFzaENvbnN0YW50cyA9IHJlcXVpcmUoJy4vZmxhc2gtY29uc3RhbnRzJyk7XG5cbnZhciBfZmxhc2hDb25zdGFudHMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZmxhc2hDb25zdGFudHMpO1xuXG52YXIgcmVzb2x2ZUZsYXNoVHJhbnNtdXhXb3JrZXIgPSBmdW5jdGlvbiByZXNvbHZlRmxhc2hUcmFuc211eFdvcmtlcigpIHtcbiAgdmFyIHJlc3VsdCA9IHVuZGVmaW5lZDtcblxuICB0cnkge1xuICAgIHJlc3VsdCA9IHJlcXVpcmUucmVzb2x2ZSgnLi9mbGFzaC10cmFuc211eGVyLXdvcmtlcicpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gbm8gcmVzdWx0XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBBIHdyYXBwZXIgYXJvdW5kIHRoZSBzZXRUaW1lb3V0IGZ1bmN0aW9uIHRoYXQgdXNlc1xuICogdGhlIGZsYXNoIGNvbnN0YW50IHRpbWUgYmV0d2VlbiB0aWNrcyB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIHRoZSBmdW5jdGlvbiBjYWxsYmFjayB0byBydW5cbiAqIEBwcml2YXRlXG4gKi9cbnZhciBzY2hlZHVsZVRpY2sgPSBmdW5jdGlvbiBzY2hlZHVsZVRpY2soZnVuYykge1xuICAvLyBDaHJvbWUgZG9lc24ndCBpbnZva2UgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIGNhbGxiYWNrc1xuICAvLyBpbiBiYWNrZ3JvdW5kIHRhYnMsIHNvIHVzZSBzZXRUaW1lb3V0LlxuICBfZ2xvYmFsV2luZG93MlsnZGVmYXVsdCddLnNldFRpbWVvdXQoZnVuYywgX2ZsYXNoQ29uc3RhbnRzMlsnZGVmYXVsdCddLlRJTUVfQkVUV0VFTl9DSFVOS1MpO1xufTtcblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSByYW5kb20gc3RyaW5nIG9mIG1heCBsZW5ndGggNlxuICpcbiAqIEByZXR1cm4ge1N0cmluZ30gdGhlIHJhbmRvbWx5IGdlbmVyYXRlZCBzdHJpbmdcbiAqIEBmdW5jdGlvbiBnZW5lcmF0ZVJhbmRvbVN0cmluZ1xuICogQHByaXZhdGVcbiAqL1xudmFyIGdlbmVyYXRlUmFuZG9tU3RyaW5nID0gZnVuY3Rpb24gZ2VuZXJhdGVSYW5kb21TdHJpbmcoKSB7XG4gIHJldHVybiBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zbGljZSgyLCA4KTtcbn07XG5cbi8qKlxuICogUm91bmQgYSBudW1iZXIgdG8gYSBzcGVjaWZpZWQgbnVtYmVyIG9mIHBsYWNlcyBtdWNoIGxpa2VcbiAqIHRvRml4ZWQgYnV0IHJldHVybiBhIG51bWJlciBpbnN0ZWFkIG9mIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBudW0gQSBudW1iZXJcbiAqIEBwYXJhbSB7TnVtYmVyfSBwbGFjZXMgVGhlIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyB3aGljaCB0b1xuICogcm91bmRcbiAqIEBwcml2YXRlXG4gKi9cbnZhciB0b0RlY2ltYWxQbGFjZXMgPSBmdW5jdGlvbiB0b0RlY2ltYWxQbGFjZXMobnVtLCBwbGFjZXMpIHtcbiAgaWYgKHR5cGVvZiBwbGFjZXMgIT09ICdudW1iZXInIHx8IHBsYWNlcyA8IDApIHtcbiAgICBwbGFjZXMgPSAwO1xuICB9XG5cbiAgdmFyIHNjYWxlID0gTWF0aC5wb3coMTAsIHBsYWNlcyk7XG5cbiAgcmV0dXJuIE1hdGgucm91bmQobnVtICogc2NhbGUpIC8gc2NhbGU7XG59O1xuXG4vKipcbiAqIEEgU291cmNlQnVmZmVyIGltcGxlbWVudGF0aW9uIGZvciBGbGFzaCByYXRoZXIgdGhhbiBIVE1MLlxuICpcbiAqIEBsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9NZWRpYVNvdXJjZVxuICogQHBhcmFtIHtPYmplY3R9IG1lZGlhU291cmNlIHRoZSBmbGFzaCBtZWRpYSBzb3VyY2VcbiAqIEBjbGFzcyBGbGFzaFNvdXJjZUJ1ZmZlclxuICogQGV4dGVuZHMgdmlkZW9qcy5FdmVudFRhcmdldFxuICovXG5cbnZhciBGbGFzaFNvdXJjZUJ1ZmZlciA9IChmdW5jdGlvbiAoX3ZpZGVvanMkRXZlbnRUYXJnZXQpIHtcbiAgX2luaGVyaXRzKEZsYXNoU291cmNlQnVmZmVyLCBfdmlkZW9qcyRFdmVudFRhcmdldCk7XG5cbiAgZnVuY3Rpb24gRmxhc2hTb3VyY2VCdWZmZXIobWVkaWFTb3VyY2UpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEZsYXNoU291cmNlQnVmZmVyKTtcblxuICAgIF9nZXQoT2JqZWN0LmdldFByb3RvdHlwZU9mKEZsYXNoU291cmNlQnVmZmVyLnByb3RvdHlwZSksICdjb25zdHJ1Y3RvcicsIHRoaXMpLmNhbGwodGhpcyk7XG4gICAgdmFyIGVuY29kZWRIZWFkZXIgPSB1bmRlZmluZWQ7XG5cbiAgICAvLyBTdGFydCBvZmYgdXNpbmcgdGhlIGdsb2JhbGx5IGRlZmluZWQgdmFsdWUgYnV0IHJlZmluZVxuICAgIC8vIGFzIHdlIGFwcGVuZCBkYXRhIGludG8gZmxhc2hcbiAgICB0aGlzLmNodW5rU2l6ZV8gPSBfZmxhc2hDb25zdGFudHMyWydkZWZhdWx0J10uQllURVNfUEVSX0NIVU5LO1xuXG4gICAgLy8gYnl0ZSBhcnJheXMgcXVldWVkIHRvIGJlIGFwcGVuZGVkXG4gICAgdGhpcy5idWZmZXJfID0gW107XG5cbiAgICAvLyB0aGUgdG90YWwgbnVtYmVyIG9mIHF1ZXVlZCBieXRlc1xuICAgIHRoaXMuYnVmZmVyU2l6ZV8gPSAwO1xuXG4gICAgLy8gdG8gYmUgYWJsZSB0byBkZXRlcm1pbmUgdGhlIGNvcnJlY3QgcG9zaXRpb24gdG8gc2VlayB0bywgd2VcbiAgICAvLyBuZWVkIHRvIHJldGFpbiBpbmZvcm1hdGlvbiBhYm91dCB0aGUgbWFwcGluZyBiZXR3ZWVuIHRoZVxuICAgIC8vIG1lZGlhIHRpbWVsaW5lIGFuZCBQVFMgdmFsdWVzXG4gICAgdGhpcy5iYXNlUHRzT2Zmc2V0XyA9IE5hTjtcblxuICAgIHRoaXMubWVkaWFTb3VyY2VfID0gbWVkaWFTb3VyY2U7XG5cbiAgICB0aGlzLmF1ZGlvQnVmZmVyRW5kXyA9IE5hTjtcbiAgICB0aGlzLnZpZGVvQnVmZmVyRW5kXyA9IE5hTjtcblxuICAgIC8vIGluZGljYXRlcyB3aGV0aGVyIHRoZSBhc3luY2hyb25vdXMgY29udGludWF0aW9uIG9mIGFuIG9wZXJhdGlvblxuICAgIC8vIGlzIHN0aWxsIGJlaW5nIHByb2Nlc3NlZFxuICAgIC8vIHNlZSBodHRwczovL3czYy5naXRodWIuaW8vbWVkaWEtc291cmNlLyN3aWRsLVNvdXJjZUJ1ZmZlci11cGRhdGluZ1xuICAgIHRoaXMudXBkYXRpbmcgPSBmYWxzZTtcbiAgICB0aGlzLnRpbWVzdGFtcE9mZnNldF8gPSAwO1xuXG4gICAgZW5jb2RlZEhlYWRlciA9IF9nbG9iYWxXaW5kb3cyWydkZWZhdWx0J10uYnRvYShTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKF9tdXhKc0xpYkZsdjJbJ2RlZmF1bHQnXS5nZXRGbHZIZWFkZXIoKSkpKTtcblxuICAgIC8vIGNyZWF0ZSBmdW5jdGlvbiBuYW1lcyB3aXRoIGFkZGVkIHJhbmRvbW5lc3MgZm9yIHRoZSBnbG9iYWwgY2FsbGJhY2tzIGZsYXNoIHdpbGwgdXNlXG4gICAgLy8gdG8gZ2V0IGRhdGEgZnJvbSBqYXZhc2NyaXB0IGludG8gdGhlIHN3Zi4gUmFuZG9tIHN0cmluZ3MgYXJlIGFkZGVkIGFzIGEgc2FmZXR5XG4gICAgLy8gbWVhc3VyZSBmb3IgcGFnZXMgd2l0aCBtdWx0aXBsZSBwbGF5ZXJzIHNpbmNlIHRoZXNlIGZ1bmN0aW9ucyB3aWxsIGJlIGdsb2JhbFxuICAgIC8vIGluc3RlYWQgb2YgcGVyIGluc3RhbmNlLiBXaGVuIG1ha2luZyBhIGNhbGwgdG8gdGhlIHN3ZiwgdGhlIGJyb3dzZXIgZ2VuZXJhdGVzIGFcbiAgICAvLyB0cnkgY2F0Y2ggY29kZSBzbmlwcGV0LCBidXQganVzdCB0YWtlcyB0aGUgZnVuY3Rpb24gbmFtZSBhbmQgd3JpdGVzIG91dCBhbiB1bnF1b3RlZFxuICAgIC8vIGNhbGwgdG8gdGhhdCBmdW5jdGlvbi4gSWYgdGhlIHBsYXllciBpZCBoYXMgYW55IHNwZWNpYWwgY2hhcmFjdGVycywgdGhpcyB3aWxsIHJlc3VsdFxuICAgIC8vIGluIGFuIGVycm9yLCBzbyBzYWZlUGxheWVySWQgcmVwbGFjZXMgYWxsIHNwZWNpYWwgY2hhcmFjdGVycyB0byAnXydcbiAgICB2YXIgc2FmZVBsYXllcklkID0gdGhpcy5tZWRpYVNvdXJjZV8ucGxheWVyXy5pZCgpLnJlcGxhY2UoL1teYS16QS1aMC05XS9nLCAnXycpO1xuXG4gICAgdGhpcy5mbGFzaEVuY29kZWRIZWFkZXJOYW1lXyA9ICd2anNfZmxhc2hFbmNvZGVkSGVhZGVyXycgKyBzYWZlUGxheWVySWQgKyBnZW5lcmF0ZVJhbmRvbVN0cmluZygpO1xuICAgIHRoaXMuZmxhc2hFbmNvZGVkRGF0YU5hbWVfID0gJ3Zqc19mbGFzaEVuY29kZWREYXRhXycgKyBzYWZlUGxheWVySWQgKyBnZW5lcmF0ZVJhbmRvbVN0cmluZygpO1xuXG4gICAgX2dsb2JhbFdpbmRvdzJbJ2RlZmF1bHQnXVt0aGlzLmZsYXNoRW5jb2RlZEhlYWRlck5hbWVfXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGRlbGV0ZSBfZ2xvYmFsV2luZG93MlsnZGVmYXVsdCddW190aGlzLmZsYXNoRW5jb2RlZEhlYWRlck5hbWVfXTtcbiAgICAgIHJldHVybiBlbmNvZGVkSGVhZGVyO1xuICAgIH07XG5cbiAgICB0aGlzLm1lZGlhU291cmNlXy5zd2ZPYmoudmpzX2FwcGVuZENodW5rUmVhZHkodGhpcy5mbGFzaEVuY29kZWRIZWFkZXJOYW1lXyk7XG5cbiAgICB0aGlzLnRyYW5zbXV4ZXJfID0gKDAsIF93ZWJ3YWNraWZ5MlsnZGVmYXVsdCddKShfZmxhc2hUcmFuc211eGVyV29ya2VyMlsnZGVmYXVsdCddLCByZXNvbHZlRmxhc2hUcmFuc211eFdvcmtlcigpKTtcbiAgICB0aGlzLnRyYW5zbXV4ZXJfLnBvc3RNZXNzYWdlKHsgYWN0aW9uOiAnaW5pdCcsIG9wdGlvbnM6IHt9IH0pO1xuICAgIHRoaXMudHJhbnNtdXhlcl8ub25tZXNzYWdlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICBpZiAoZXZlbnQuZGF0YS5hY3Rpb24gPT09ICdkYXRhJykge1xuICAgICAgICBfdGhpcy5yZWNlaXZlQnVmZmVyXyhldmVudC5kYXRhLnNlZ21lbnQpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLm9uZSgndXBkYXRlZW5kJywgZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMubWVkaWFTb3VyY2VfLnRlY2hfLnRyaWdnZXIoJ2xvYWRlZG1ldGFkYXRhJyk7XG4gICAgfSk7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3RpbWVzdGFtcE9mZnNldCcsIHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy50aW1lc3RhbXBPZmZzZXRfO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbCkge1xuICAgICAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicgJiYgdmFsID49IDApIHtcbiAgICAgICAgICB0aGlzLnRpbWVzdGFtcE9mZnNldF8gPSB2YWw7XG4gICAgICAgICAgLy8gV2UgaGF2ZSB0byB0ZWxsIGZsYXNoIHRvIGV4cGVjdCBhIGRpc2NvbnRpbnVpdHlcbiAgICAgICAgICB0aGlzLm1lZGlhU291cmNlXy5zd2ZPYmoudmpzX2Rpc2NvbnRpbnVpdHkoKTtcbiAgICAgICAgICAvLyB0aGUgbWVkaWEgPC0+IFBUUyBtYXBwaW5nIG11c3QgYmUgcmUtZXN0YWJsaXNoZWQgYWZ0ZXJcbiAgICAgICAgICAvLyB0aGUgZGlzY29udGludWl0eVxuICAgICAgICAgIHRoaXMuYmFzZVB0c09mZnNldF8gPSBOYU47XG4gICAgICAgICAgdGhpcy5hdWRpb0J1ZmZlckVuZF8gPSBOYU47XG4gICAgICAgICAgdGhpcy52aWRlb0J1ZmZlckVuZF8gPSBOYU47XG5cbiAgICAgICAgICB0aGlzLnRyYW5zbXV4ZXJfLnBvc3RNZXNzYWdlKHsgYWN0aW9uOiAncmVzZXQnIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2J1ZmZlcmVkJywge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIGlmICghdGhpcy5tZWRpYVNvdXJjZV8gfHwgIXRoaXMubWVkaWFTb3VyY2VfLnN3Zk9iaiB8fCAhKCd2anNfZ2V0UHJvcGVydHknIGluIHRoaXMubWVkaWFTb3VyY2VfLnN3Zk9iaikpIHtcbiAgICAgICAgICByZXR1cm4gX3ZpZGVvSnMyWydkZWZhdWx0J10uY3JlYXRlVGltZVJhbmdlKCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYnVmZmVyZWQgPSB0aGlzLm1lZGlhU291cmNlXy5zd2ZPYmoudmpzX2dldFByb3BlcnR5KCdidWZmZXJlZCcpO1xuXG4gICAgICAgIGlmIChidWZmZXJlZCAmJiBidWZmZXJlZC5sZW5ndGgpIHtcbiAgICAgICAgICBidWZmZXJlZFswXVswXSA9IHRvRGVjaW1hbFBsYWNlcyhidWZmZXJlZFswXVswXSwgMyk7XG4gICAgICAgICAgYnVmZmVyZWRbMF1bMV0gPSB0b0RlY2ltYWxQbGFjZXMoYnVmZmVyZWRbMF1bMV0sIDMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfdmlkZW9KczJbJ2RlZmF1bHQnXS5jcmVhdGVUaW1lUmFuZ2VzKGJ1ZmZlcmVkKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIE9uIGEgc2VlayB3ZSByZW1vdmUgYWxsIHRleHQgdHJhY2sgZGF0YSBzaW5jZSBmbGFzaCBoYXMgbm8gY29uY2VwdFxuICAgIC8vIG9mIGEgYnVmZmVyZWQtcmFuZ2UgYW5kIGV2ZXJ5dGhpbmcgZWxzZSBpcyByZXNldCBvbiBzZWVrXG4gICAgdGhpcy5tZWRpYVNvdXJjZV8ucGxheWVyXy5vbignc2Vla2VkJywgZnVuY3Rpb24gKCkge1xuICAgICAgKDAsIF9yZW1vdmVDdWVzRnJvbVRyYWNrMlsnZGVmYXVsdCddKSgwLCBJbmZpbml0eSwgX3RoaXMubWV0YWRhdGFUcmFja18pO1xuICAgICAgaWYgKF90aGlzLmluYmFuZFRleHRUcmFja3NfKSB7XG4gICAgICAgIGZvciAodmFyIHRyYWNrIGluIF90aGlzLmluYmFuZFRleHRUcmFja3NfKSB7XG4gICAgICAgICAgKDAsIF9yZW1vdmVDdWVzRnJvbVRyYWNrMlsnZGVmYXVsdCddKSgwLCBJbmZpbml0eSwgX3RoaXMuaW5iYW5kVGV4dFRyYWNrc19bdHJhY2tdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdmFyIG9uSGxzUmVzZXQgPSB0aGlzLm9uSGxzUmVzZXRfLmJpbmQodGhpcyk7XG5cbiAgICAvLyBobHMtcmVzZXQgaXMgZmlyZWQgYnkgdmlkZW9qcy5IbHMgb24gdG8gdGhlIHRlY2ggYWZ0ZXIgdGhlIG1haW4gU2VnbWVudExvYWRlclxuICAgIC8vIHJlc2V0cyBpdHMgc3RhdGUgYW5kIGZsdXNoZXMgdGhlIGJ1ZmZlclxuICAgIHRoaXMubWVkaWFTb3VyY2VfLnBsYXllcl8udGVjaF8ub24oJ2hscy1yZXNldCcsIG9uSGxzUmVzZXQpO1xuXG4gICAgdGhpcy5tZWRpYVNvdXJjZV8ucGxheWVyXy50ZWNoXy5obHMub24oJ2Rpc3Bvc2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpcy50cmFuc211eGVyXy50ZXJtaW5hdGUoKTtcbiAgICAgIF90aGlzLm1lZGlhU291cmNlXy5wbGF5ZXJfLnRlY2hfLm9mZignaGxzLXJlc2V0Jywgb25IbHNSZXNldCk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQXBwZW5kIGJ5dGVzIHRvIHRoZSBzb3VyY2VidWZmZXJzIGJ1ZmZlciwgaW4gdGhpcyBjYXNlIHdlXG4gICAqIGhhdmUgdG8gYXBwZW5kIGl0IHRvIHN3ZiBvYmplY3QuXG4gICAqXG4gICAqIEBsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9Tb3VyY2VCdWZmZXIvYXBwZW5kQnVmZmVyXG4gICAqIEBwYXJhbSB7QXJyYXl9IGJ5dGVzXG4gICAqL1xuXG4gIF9jcmVhdGVDbGFzcyhGbGFzaFNvdXJjZUJ1ZmZlciwgW3tcbiAgICBrZXk6ICdhcHBlbmRCdWZmZXInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhcHBlbmRCdWZmZXIoYnl0ZXMpIHtcbiAgICAgIHZhciBlcnJvciA9IHVuZGVmaW5lZDtcblxuICAgICAgaWYgKHRoaXMudXBkYXRpbmcpIHtcbiAgICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoJ1NvdXJjZUJ1ZmZlci5hcHBlbmQoKSBjYW5ub3QgYmUgY2FsbGVkICcgKyAnd2hpbGUgYW4gdXBkYXRlIGlzIGluIHByb2dyZXNzJyk7XG4gICAgICAgIGVycm9yLm5hbWUgPSAnSW52YWxpZFN0YXRlRXJyb3InO1xuICAgICAgICBlcnJvci5jb2RlID0gMTE7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgICAgdGhpcy51cGRhdGluZyA9IHRydWU7XG4gICAgICB0aGlzLm1lZGlhU291cmNlXy5yZWFkeVN0YXRlID0gJ29wZW4nO1xuICAgICAgdGhpcy50cmlnZ2VyKHsgdHlwZTogJ3VwZGF0ZScgfSk7XG5cbiAgICAgIHRoaXMudHJhbnNtdXhlcl8ucG9zdE1lc3NhZ2Uoe1xuICAgICAgICBhY3Rpb246ICdwdXNoJyxcbiAgICAgICAgZGF0YTogYnl0ZXMuYnVmZmVyLFxuICAgICAgICBieXRlT2Zmc2V0OiBieXRlcy5ieXRlT2Zmc2V0LFxuICAgICAgICBieXRlTGVuZ3RoOiBieXRlcy5ieXRlTGVuZ3RoXG4gICAgICB9LCBbYnl0ZXMuYnVmZmVyXSk7XG4gICAgICB0aGlzLnRyYW5zbXV4ZXJfLnBvc3RNZXNzYWdlKHsgYWN0aW9uOiAnZmx1c2gnIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlc2V0IHRoZSBwYXJzZXIgYW5kIHJlbW92ZSBhbnkgZGF0YSBxdWV1ZWQgdG8gYmUgc2VudCB0byB0aGUgU1dGLlxuICAgICAqXG4gICAgICogQGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1NvdXJjZUJ1ZmZlci9hYm9ydFxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnYWJvcnQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhYm9ydCgpIHtcbiAgICAgIHRoaXMuYnVmZmVyXyA9IFtdO1xuICAgICAgdGhpcy5idWZmZXJTaXplXyA9IDA7XG4gICAgICB0aGlzLm1lZGlhU291cmNlXy5zd2ZPYmoudmpzX2Fib3J0KCk7XG5cbiAgICAgIC8vIHJlcG9ydCBhbnkgb3V0c3RhbmRpbmcgdXBkYXRlcyBoYXZlIGVuZGVkXG4gICAgICBpZiAodGhpcy51cGRhdGluZykge1xuICAgICAgICB0aGlzLnVwZGF0aW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMudHJpZ2dlcih7IHR5cGU6ICd1cGRhdGVlbmQnIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZsYXNoIGNhbm5vdCByZW1vdmUgcmFuZ2VzIGFscmVhZHkgYnVmZmVyZWQgaW4gdGhlIE5ldFN0cmVhbVxuICAgICAqIGJ1dCBzZWVraW5nIGNsZWFycyB0aGUgYnVmZmVyIGVudGlyZWx5LiBGb3IgbW9zdCBwdXJwb3NlcyxcbiAgICAgKiBoYXZpbmcgdGhpcyBvcGVyYXRpb24gYWN0IGFzIGEgbm8tb3AgaXMgYWNjZXB0YWJsZS5cbiAgICAgKlxuICAgICAqIEBsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9Tb3VyY2VCdWZmZXIvcmVtb3ZlXG4gICAgICogQHBhcmFtIHtEb3VibGV9IHN0YXJ0IHN0YXJ0IG9mIHRoZSBzZWN0aW9uIHRvIHJlbW92ZVxuICAgICAqIEBwYXJhbSB7RG91YmxlfSBlbmQgZW5kIG9mIHRoZSBzZWN0aW9uIHRvIHJlbW92ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAncmVtb3ZlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlKHN0YXJ0LCBlbmQpIHtcbiAgICAgICgwLCBfcmVtb3ZlQ3Vlc0Zyb21UcmFjazJbJ2RlZmF1bHQnXSkoc3RhcnQsIGVuZCwgdGhpcy5tZXRhZGF0YVRyYWNrXyk7XG4gICAgICBpZiAodGhpcy5pbmJhbmRUZXh0VHJhY2tzXykge1xuICAgICAgICBmb3IgKHZhciB0cmFjayBpbiB0aGlzLmluYmFuZFRleHRUcmFja3NfKSB7XG4gICAgICAgICAgKDAsIF9yZW1vdmVDdWVzRnJvbVRyYWNrMlsnZGVmYXVsdCddKShzdGFydCwgZW5kLCB0aGlzLmluYmFuZFRleHRUcmFja3NfW3RyYWNrXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMudHJpZ2dlcih7IHR5cGU6ICd1cGRhdGUnIH0pO1xuICAgICAgdGhpcy50cmlnZ2VyKHsgdHlwZTogJ3VwZGF0ZWVuZCcgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVjZWl2ZSBhIGJ1ZmZlciBmcm9tIHRoZSBmbHYuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc2VnbWVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdyZWNlaXZlQnVmZmVyXycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlY2VpdmVCdWZmZXJfKHNlZ21lbnQpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICAvLyBjcmVhdGUgYW4gaW4tYmFuZCBjYXB0aW9uIHRyYWNrIGlmIG9uZSBpcyBwcmVzZW50IGluIHRoZSBzZWdtZW50XG4gICAgICAoMCwgX2NyZWF0ZVRleHRUcmFja3NJZk5lY2Vzc2FyeTJbJ2RlZmF1bHQnXSkodGhpcywgdGhpcy5tZWRpYVNvdXJjZV8sIHNlZ21lbnQpO1xuICAgICAgKDAsIF9hZGRUZXh0VHJhY2tEYXRhLmFkZFRleHRUcmFja0RhdGEpKHRoaXMsIHNlZ21lbnQuY2FwdGlvbnMsIHNlZ21lbnQubWV0YWRhdGEpO1xuXG4gICAgICAvLyBEbyB0aGlzIGFzeW5jaHJvbm91c2x5IHNpbmNlIGNvbnZlcnRUYWdzVG9EYXRhXyBjYW4gYmUgdGltZSBjb25zdW1pbmdcbiAgICAgIHNjaGVkdWxlVGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBmbHZCeXRlcyA9IF90aGlzMi5jb252ZXJ0VGFnc1RvRGF0YV8oc2VnbWVudCk7XG5cbiAgICAgICAgaWYgKF90aGlzMi5idWZmZXJfLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHNjaGVkdWxlVGljayhfdGhpczIucHJvY2Vzc0J1ZmZlcl8uYmluZChfdGhpczIpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmbHZCeXRlcykge1xuICAgICAgICAgIF90aGlzMi5idWZmZXJfLnB1c2goZmx2Qnl0ZXMpO1xuICAgICAgICAgIF90aGlzMi5idWZmZXJTaXplXyArPSBmbHZCeXRlcy5ieXRlTGVuZ3RoO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBcHBlbmQgYSBwb3J0aW9uIG9mIHRoZSBjdXJyZW50IGJ1ZmZlciB0byB0aGUgU1dGLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ3Byb2Nlc3NCdWZmZXJfJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJvY2Vzc0J1ZmZlcl8oKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgdmFyIGNodW5rU2l6ZSA9IF9mbGFzaENvbnN0YW50czJbJ2RlZmF1bHQnXS5CWVRFU19QRVJfQ0hVTks7XG5cbiAgICAgIGlmICghdGhpcy5idWZmZXJfLmxlbmd0aCkge1xuICAgICAgICBpZiAodGhpcy51cGRhdGluZyAhPT0gZmFsc2UpIHtcbiAgICAgICAgICB0aGlzLnVwZGF0aW5nID0gZmFsc2U7XG4gICAgICAgICAgdGhpcy50cmlnZ2VyKHsgdHlwZTogJ3VwZGF0ZWVuZCcgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZG8gbm90aGluZyBpZiB0aGUgYnVmZmVyIGlzIGVtcHR5XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gY29uY2F0ZW5hdGUgYXBwZW5kcyB1cCB0byB0aGUgbWF4IGFwcGVuZCBzaXplXG4gICAgICB2YXIgY2h1bmsgPSB0aGlzLmJ1ZmZlcl9bMF0uc3ViYXJyYXkoMCwgY2h1bmtTaXplKTtcblxuICAgICAgLy8gcmVxdWV1ZSBhbnkgYnl0ZXMgdGhhdCB3b24ndCBtYWtlIGl0IHRoaXMgcm91bmRcbiAgICAgIGlmIChjaHVuay5ieXRlTGVuZ3RoIDwgY2h1bmtTaXplIHx8IHRoaXMuYnVmZmVyX1swXS5ieXRlTGVuZ3RoID09PSBjaHVua1NpemUpIHtcbiAgICAgICAgdGhpcy5idWZmZXJfLnNoaWZ0KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmJ1ZmZlcl9bMF0gPSB0aGlzLmJ1ZmZlcl9bMF0uc3ViYXJyYXkoY2h1bmtTaXplKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5idWZmZXJTaXplXyAtPSBjaHVuay5ieXRlTGVuZ3RoO1xuXG4gICAgICAvLyBiYXNlNjQgZW5jb2RlIHRoZSBieXRlc1xuICAgICAgdmFyIGJpbmFyeSA9IFtdO1xuICAgICAgdmFyIGxlbmd0aCA9IGNodW5rLmJ5dGVMZW5ndGg7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYmluYXJ5LnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShjaHVua1tpXSkpO1xuICAgICAgfVxuICAgICAgdmFyIGI2NHN0ciA9IF9nbG9iYWxXaW5kb3cyWydkZWZhdWx0J10uYnRvYShiaW5hcnkuam9pbignJykpO1xuXG4gICAgICBfZ2xvYmFsV2luZG93MlsnZGVmYXVsdCddW3RoaXMuZmxhc2hFbmNvZGVkRGF0YU5hbWVfXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gc2NoZWR1bGUgYW5vdGhlciBwcm9jZXNzQnVmZmVyIHRvIHByb2Nlc3MgYW55IGxlZnQgb3ZlciBkYXRhIG9yIHRvXG4gICAgICAgIC8vIHRyaWdnZXIgdXBkYXRlZW5kXG4gICAgICAgIHNjaGVkdWxlVGljayhfdGhpczMucHJvY2Vzc0J1ZmZlcl8uYmluZChfdGhpczMpKTtcbiAgICAgICAgZGVsZXRlIF9nbG9iYWxXaW5kb3cyWydkZWZhdWx0J11bX3RoaXMzLmZsYXNoRW5jb2RlZERhdGFOYW1lX107XG4gICAgICAgIHJldHVybiBiNjRzdHI7XG4gICAgICB9O1xuXG4gICAgICAvLyBOb3RpZnkgdGhlIHN3ZiB0aGF0IHNlZ21lbnQgZGF0YSBpcyByZWFkeSB0byBiZSBhcHBlbmRlZFxuICAgICAgdGhpcy5tZWRpYVNvdXJjZV8uc3dmT2JqLnZqc19hcHBlbmRDaHVua1JlYWR5KHRoaXMuZmxhc2hFbmNvZGVkRGF0YU5hbWVfKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUdXJucyBhbiBhcnJheSBvZiBmbHYgdGFncyBpbnRvIGEgVWludDhBcnJheSByZXByZXNlbnRpbmcgdGhlXG4gICAgICogZmx2IGRhdGEuIEFsc28gcmVtb3ZlcyBhbnkgdGFncyB0aGF0IGFyZSBiZWZvcmUgdGhlIGN1cnJlbnRcbiAgICAgKiB0aW1lIHNvIHRoYXQgcGxheWJhY2sgYmVnaW5zIGF0IG9yIHNsaWdodGx5IGFmdGVyIHRoZSByaWdodFxuICAgICAqIHBsYWNlIG9uIGEgc2Vla1xuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc2VnbWVudERhdGEgb2JqZWN0IG9mIHNlZ21lbnQgZGF0YVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnY29udmVydFRhZ3NUb0RhdGFfJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29udmVydFRhZ3NUb0RhdGFfKHNlZ21lbnREYXRhKSB7XG4gICAgICB2YXIgc2VnbWVudEJ5dGVMZW5ndGggPSAwO1xuICAgICAgdmFyIHRlY2ggPSB0aGlzLm1lZGlhU291cmNlXy50ZWNoXztcbiAgICAgIHZhciB2aWRlb1RhcmdldFB0cyA9IDA7XG4gICAgICB2YXIgc2VnbWVudCA9IHVuZGVmaW5lZDtcbiAgICAgIHZhciB2aWRlb1RhZ3MgPSBzZWdtZW50RGF0YS50YWdzLnZpZGVvVGFncztcbiAgICAgIHZhciBhdWRpb1RhZ3MgPSBzZWdtZW50RGF0YS50YWdzLmF1ZGlvVGFncztcblxuICAgICAgLy8gRXN0YWJsaXNoIHRoZSBtZWRpYSB0aW1lbGluZSB0byBQVFMgdHJhbnNsYXRpb24gaWYgd2UgZG9uJ3RcbiAgICAgIC8vIGhhdmUgb25lIGFscmVhZHlcbiAgICAgIGlmIChpc05hTih0aGlzLmJhc2VQdHNPZmZzZXRfKSAmJiAodmlkZW9UYWdzLmxlbmd0aCB8fCBhdWRpb1RhZ3MubGVuZ3RoKSkge1xuICAgICAgICAvLyBXZSBrbm93IHRoZXJlIGlzIGF0IGxlYXN0IG9uZSB2aWRlbyBvciBhdWRpbyB0YWcsIGJ1dCBzaW5jZSB3ZSBtYXkgbm90IGhhdmUgYm90aCxcbiAgICAgICAgLy8gd2UgdXNlIHB0czogSW5maW5pdHkgZm9yIHRoZSBtaXNzaW5nIHRhZy4gVGhlIHdpbGwgZm9yY2UgdGhlIGZvbGxvd2luZyBNYXRoLm1pblxuICAgICAgICAvLyBjYWxsIHdpbGwgdG8gdXNlIHRoZSBwcm9wZXIgcHRzIHZhbHVlIHNpbmNlIGl0IHdpbGwgYWx3YXlzIGJlIGxlc3MgdGhhbiBJbmZpbml0eVxuICAgICAgICB2YXIgZmlyc3RWaWRlb1RhZyA9IHZpZGVvVGFnc1swXSB8fCB7IHB0czogSW5maW5pdHkgfTtcbiAgICAgICAgdmFyIGZpcnN0QXVkaW9UYWcgPSBhdWRpb1RhZ3NbMF0gfHwgeyBwdHM6IEluZmluaXR5IH07XG5cbiAgICAgICAgdGhpcy5iYXNlUHRzT2Zmc2V0XyA9IE1hdGgubWluKGZpcnN0QXVkaW9UYWcucHRzLCBmaXJzdFZpZGVvVGFnLnB0cyk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0ZWNoLnNlZWtpbmcoKSkge1xuICAgICAgICAvLyBEbyBub3QgdXNlIHByZXZpb3VzbHkgc2F2ZWQgYnVmZmVyIGVuZCB2YWx1ZXMgd2hpbGUgc2Vla2luZyBzaW5jZSBidWZmZXJcbiAgICAgICAgLy8gaXMgY2xlYXJlZCBvbiBhbGwgc2Vla3NcbiAgICAgICAgdGhpcy52aWRlb0J1ZmZlckVuZF8gPSBOYU47XG4gICAgICAgIHRoaXMuYXVkaW9CdWZmZXJFbmRfID0gTmFOO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNOYU4odGhpcy52aWRlb0J1ZmZlckVuZF8pKSB7XG4gICAgICAgIGlmICh0ZWNoLmJ1ZmZlcmVkKCkubGVuZ3RoKSB7XG4gICAgICAgICAgdmlkZW9UYXJnZXRQdHMgPSB0ZWNoLmJ1ZmZlcmVkKCkuZW5kKDApIC0gdGhpcy50aW1lc3RhbXBPZmZzZXQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUcmltIHRvIGN1cnJlbnRUaW1lIGlmIHNlZWtpbmdcbiAgICAgICAgaWYgKHRlY2guc2Vla2luZygpKSB7XG4gICAgICAgICAgdmlkZW9UYXJnZXRQdHMgPSBNYXRoLm1heCh2aWRlb1RhcmdldFB0cywgdGVjaC5jdXJyZW50VGltZSgpIC0gdGhpcy50aW1lc3RhbXBPZmZzZXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUFRTIHZhbHVlcyBhcmUgcmVwcmVzZW50ZWQgaW4gbWlsbGlzZWNvbmRzXG4gICAgICAgIHZpZGVvVGFyZ2V0UHRzICo9IDFlMztcbiAgICAgICAgdmlkZW9UYXJnZXRQdHMgKz0gdGhpcy5iYXNlUHRzT2Zmc2V0XztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEFkZCBhIGZ1ZGdlIGZhY3RvciBvZiAwLjEgdG8gdGhlIGxhc3QgdmlkZW8gcHRzIGFwcGVuZGVkIHNpbmNlIGEgcmVuZGl0aW9uIGNoYW5nZVxuICAgICAgICAvLyBjb3VsZCBhcHBlbmQgYW4gb3ZlcmxhcHBpbmcgc2VnbWVudCwgaW4gd2hpY2ggY2FzZSB0aGVyZSBpcyBhIGhpZ2ggbGlrZWx5aG9vZFxuICAgICAgICAvLyBhIHRhZyBjb3VsZCBoYXZlIGEgbWF0Y2hpbmcgcHRzIHRvIHZpZGVvQnVmZmVyRW5kXywgd2hpY2ggd291bGQgY2F1c2VcbiAgICAgICAgLy8gdGhhdCB0YWcgdG8gZ2V0IGFwcGVuZGVkIGJ5IHRoZSB0YWcucHRzID49IHRhcmdldFB0cyBjaGVjayBiZWxvdyBldmVuIHRob3VnaCBpdFxuICAgICAgICAvLyBpcyBhIGR1cGxpY2F0ZSBvZiB3aGF0IHdhcyBwcmV2aW91c2x5IGFwcGVuZGVkXG4gICAgICAgIHZpZGVvVGFyZ2V0UHRzID0gdGhpcy52aWRlb0J1ZmZlckVuZF8gKyAwLjE7XG4gICAgICB9XG5cbiAgICAgIC8vIGZpbHRlciBjb21wbGV0ZSBHT1BzIHdpdGggYSBwcmVzZW50YXRpb24gdGltZSBsZXNzIHRoYW4gdGhlIHNlZWsgdGFyZ2V0L2VuZCBvZiBidWZmZXJcbiAgICAgIHZhciBjdXJyZW50SW5kZXggPSB2aWRlb1RhZ3MubGVuZ3RoO1xuXG4gICAgICAvLyBpZiB0aGUgbGFzdCB0YWcgaXMgYmV5b25kIHZpZGVvVGFyZ2V0UHRzLCB0aGVuIGRvIG5vdCBzZWFyY2ggdGhlIGxpc3QgZm9yIGEgR09QXG4gICAgICAvLyBzaW5jZSBvdXIgdmlkZW9UYXJnZXRQdHMgbGllcyBpbiBhIGZ1dHVyZSBzZWdtZW50XG4gICAgICBpZiAoY3VycmVudEluZGV4ICYmIHZpZGVvVGFnc1tjdXJyZW50SW5kZXggLSAxXS5wdHMgPj0gdmlkZW9UYXJnZXRQdHMpIHtcbiAgICAgICAgLy8gU3RhcnQgYnkgd2Fsa2luZyBiYWNrd2FyZHMgZnJvbSB0aGUgZW5kIG9mIHRoZSBsaXN0IHVudGlsIHdlIHJlYWNoIGEgdGFnIHRoYXRcbiAgICAgICAgLy8gaXMgZXF1YWwgdG8gb3IgbGVzcyB0aGFuIHZpZGVvVGFyZ2V0UHRzXG4gICAgICAgIHdoaWxlICgtLWN1cnJlbnRJbmRleCkge1xuICAgICAgICAgIHZhciBjdXJyZW50VGFnID0gdmlkZW9UYWdzW2N1cnJlbnRJbmRleF07XG5cbiAgICAgICAgICBpZiAoY3VycmVudFRhZy5wdHMgPiB2aWRlb1RhcmdldFB0cykge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gaWYgd2Ugc2VlIGEga2V5RnJhbWUgb3IgbWV0YWRhdGEgdGFnIG9uY2Ugd2UndmUgZ29uZSBiZWxvdyB2aWRlb1RhcmdldFB0cyxcbiAgICAgICAgICAvLyBleGl0IHRoZSBsb29wIGFzIHRoaXMgaXMgdGhlIHN0YXJ0IG9mIHRoZSBHT1AgdGhhdCB3ZSB3YW50IHRvIGFwcGVuZFxuICAgICAgICAgIGlmIChjdXJyZW50VGFnLmtleUZyYW1lIHx8IGN1cnJlbnRUYWcubWV0YURhdGFUYWcpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFdlIG5lZWQgdG8gY2hlY2sgaWYgdGhlcmUgYXJlIGFueSBtZXRhZGF0YSB0YWdzIHRoYXQgY29tZSBiZWZvcmUgY3VycmVudEluZGV4XG4gICAgICAgIC8vIGFzIHRob3NlIHdpbGwgYmUgbWV0YWRhdGEgdGFncyBhc3NvY2lhdGVkIHdpdGggdGhlIEdPUCB3ZSBhcmUgYXBwZW5kaW5nXG4gICAgICAgIC8vIFRoZXJlIGNvdWxkIGJlIDAgdG8gMiBtZXRhZGF0YSB0YWdzIHRoYXQgY29tZSBiZWZvcmUgdGhlIGN1cnJlbnRJbmRleCBkZXBlbmRpbmdcbiAgICAgICAgLy8gb24gd2hhdCB2aWRlb1RhcmdldFB0cyBpcyBhbmQgd2hldGhlciB0aGUgdHJhbnNtdXhlciBwcmVwZW5kZWQgbWV0YWRhdGEgdGFncyB0byB0aGlzXG4gICAgICAgIC8vIGtleSBmcmFtZVxuICAgICAgICB3aGlsZSAoY3VycmVudEluZGV4KSB7XG4gICAgICAgICAgdmFyIG5leHRUYWcgPSB2aWRlb1RhZ3NbY3VycmVudEluZGV4IC0gMV07XG5cbiAgICAgICAgICBpZiAoIW5leHRUYWcubWV0YURhdGFUYWcpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGN1cnJlbnRJbmRleC0tO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBmaWx0ZXJlZFZpZGVvVGFncyA9IHZpZGVvVGFncy5zbGljZShjdXJyZW50SW5kZXgpO1xuXG4gICAgICB2YXIgYXVkaW9UYXJnZXRQdHMgPSB1bmRlZmluZWQ7XG5cbiAgICAgIGlmIChpc05hTih0aGlzLmF1ZGlvQnVmZmVyRW5kXykpIHtcbiAgICAgICAgYXVkaW9UYXJnZXRQdHMgPSB2aWRlb1RhcmdldFB0cztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEFkZCBhIGZ1ZGdlIGZhY3RvciBvZiAwLjEgdG8gdGhlIGxhc3QgdmlkZW8gcHRzIGFwcGVuZGVkIHNpbmNlIGEgcmVuZGl0aW9uIGNoYW5nZVxuICAgICAgICAvLyBjb3VsZCBhcHBlbmQgYW4gb3ZlcmxhcHBpbmcgc2VnbWVudCwgaW4gd2hpY2ggY2FzZSB0aGVyZSBpcyBhIGhpZ2ggbGlrZWx5aG9vZFxuICAgICAgICAvLyBhIHRhZyBjb3VsZCBoYXZlIGEgbWF0Y2hpbmcgcHRzIHRvIHZpZGVvQnVmZmVyRW5kXywgd2hpY2ggd291bGQgY2F1c2VcbiAgICAgICAgLy8gdGhhdCB0YWcgdG8gZ2V0IGFwcGVuZGVkIGJ5IHRoZSB0YWcucHRzID49IHRhcmdldFB0cyBjaGVjayBiZWxvdyBldmVuIHRob3VnaCBpdFxuICAgICAgICAvLyBpcyBhIGR1cGxpY2F0ZSBvZiB3aGF0IHdhcyBwcmV2aW91c2x5IGFwcGVuZGVkXG4gICAgICAgIGF1ZGlvVGFyZ2V0UHRzID0gdGhpcy5hdWRpb0J1ZmZlckVuZF8gKyAwLjE7XG4gICAgICB9XG5cbiAgICAgIGlmIChmaWx0ZXJlZFZpZGVvVGFncy5sZW5ndGgpIHtcbiAgICAgICAgLy8gSWYgdGFyZ2V0UHRzIGludGVyc2VjdHMgYSBHT1AgYW5kIHdlIGFwcGVuZGVkIHRoZSB0YWdzIGZvciB0aGUgR09QIHRoYXQgY2FtZVxuICAgICAgICAvLyBiZWZvcmUgdGFyZ2V0UHRzLCB3ZSB3YW50IHRvIG1ha2Ugc3VyZSB0byB0cmltIGF1ZGlvIHRhZ3MgYXQgdGhlIHB0c1xuICAgICAgICAvLyBvZiB0aGUgZmlyc3QgdmlkZW8gdGFnIHRvIGF2b2lkIGJyaWVmIG1vbWVudHMgb2Ygc2lsZW5jZVxuICAgICAgICBhdWRpb1RhcmdldFB0cyA9IE1hdGgubWluKGF1ZGlvVGFyZ2V0UHRzLCBmaWx0ZXJlZFZpZGVvVGFnc1swXS5wdHMpO1xuICAgICAgfVxuXG4gICAgICAvLyBza2lwIHRhZ3Mgd2l0aCBhIHByZXNlbnRhdGlvbiB0aW1lIGxlc3MgdGhhbiB0aGUgc2VlayB0YXJnZXQvZW5kIG9mIGJ1ZmZlclxuICAgICAgY3VycmVudEluZGV4ID0gMDtcblxuICAgICAgd2hpbGUgKGN1cnJlbnRJbmRleCA8IGF1ZGlvVGFncy5sZW5ndGgpIHtcbiAgICAgICAgaWYgKGF1ZGlvVGFnc1tjdXJyZW50SW5kZXhdLnB0cyA+PSBhdWRpb1RhcmdldFB0cykge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgY3VycmVudEluZGV4Kys7XG4gICAgICB9XG5cbiAgICAgIHZhciBmaWx0ZXJlZEF1ZGlvVGFncyA9IGF1ZGlvVGFncy5zbGljZShjdXJyZW50SW5kZXgpO1xuXG4gICAgICAvLyB1cGRhdGUgdGhlIGF1ZGlvIGFuZCB2aWRlbyBidWZmZXIgZW5kc1xuICAgICAgaWYgKGZpbHRlcmVkQXVkaW9UYWdzLmxlbmd0aCkge1xuICAgICAgICB0aGlzLmF1ZGlvQnVmZmVyRW5kXyA9IGZpbHRlcmVkQXVkaW9UYWdzW2ZpbHRlcmVkQXVkaW9UYWdzLmxlbmd0aCAtIDFdLnB0cztcbiAgICAgIH1cbiAgICAgIGlmIChmaWx0ZXJlZFZpZGVvVGFncy5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy52aWRlb0J1ZmZlckVuZF8gPSBmaWx0ZXJlZFZpZGVvVGFnc1tmaWx0ZXJlZFZpZGVvVGFncy5sZW5ndGggLSAxXS5wdHM7XG4gICAgICB9XG5cbiAgICAgIHZhciB0YWdzID0gdGhpcy5nZXRPcmRlcmVkVGFnc18oZmlsdGVyZWRWaWRlb1RhZ3MsIGZpbHRlcmVkQXVkaW9UYWdzKTtcblxuICAgICAgaWYgKHRhZ3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gSWYgd2UgYXJlIGFwcGVuZGluZyBkYXRhIHRoYXQgY29tZXMgYmVmb3JlIG91ciB0YXJnZXQgcHRzLCB3ZSB3YW50IHRvIHRlbGxcbiAgICAgIC8vIHRoZSBzd2YgdG8gYWRqdXN0IGl0cyBub3Rpb24gb2YgY3VycmVudCB0aW1lIHRvIGFjY291bnQgZm9yIHRoZSBleHRyYSB0YWdzXG4gICAgICAvLyB3ZSBhcmUgYXBwZW5kaW5nIHRvIGNvbXBsZXRlIHRoZSBHT1AgdGhhdCBpbnRlcnNlY3RzIHdpdGggdGFyZ2V0UHRzXG4gICAgICBpZiAodGFnc1swXS5wdHMgPCB2aWRlb1RhcmdldFB0cyAmJiB0ZWNoLnNlZWtpbmcoKSkge1xuICAgICAgICB2YXIgZnVkZ2VGYWN0b3IgPSAxIC8gMzA7XG4gICAgICAgIHZhciBjdXJyZW50VGltZSA9IHRlY2guY3VycmVudFRpbWUoKTtcbiAgICAgICAgdmFyIGRpZmYgPSAodmlkZW9UYXJnZXRQdHMgLSB0YWdzWzBdLnB0cykgLyAxZTM7XG4gICAgICAgIHZhciBhZGp1c3RlZFRpbWUgPSBjdXJyZW50VGltZSAtIGRpZmY7XG5cbiAgICAgICAgaWYgKGFkanVzdGVkVGltZSA8IGZ1ZGdlRmFjdG9yKSB7XG4gICAgICAgICAgYWRqdXN0ZWRUaW1lID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGhpcy5tZWRpYVNvdXJjZV8uc3dmT2JqLnZqc19hZGp1c3RDdXJyZW50VGltZShhZGp1c3RlZFRpbWUpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgLy8gbm8tb3AgZm9yIGJhY2t3YXJkcyBjb21wYXRhYmlsaXR5IG9mIHN3Zi4gSWYgYWRqdXN0Q3VycmVudFRpbWUgZmFpbHMsXG4gICAgICAgICAgLy8gdGhlIHN3ZiBtYXkgaW5jb3JyZWN0bHkgcmVwb3J0IGN1cnJlbnRUaW1lIGFuZCBidWZmZXJlZCByYW5nZXNcbiAgICAgICAgICAvLyBidXQgc2hvdWxkIG5vdCBhZmZlY3QgcGxheWJhY2sgb3ZlciB0aGFuIHRoZSB0aW1lIGRpc3BsYXllZCBvbiB0aGVcbiAgICAgICAgICAvLyBwcm9ncmVzcyBiYXIgaXMgaW5hY2N1cmF0ZVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIGNvbmNhdGVuYXRlIHRoZSBieXRlcyBpbnRvIGEgc2luZ2xlIHNlZ21lbnRcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGFncy5sZW5ndGg7IGkrKykge1xuICAgICAgICBzZWdtZW50Qnl0ZUxlbmd0aCArPSB0YWdzW2ldLmJ5dGVzLmJ5dGVMZW5ndGg7XG4gICAgICB9XG4gICAgICBzZWdtZW50ID0gbmV3IFVpbnQ4QXJyYXkoc2VnbWVudEJ5dGVMZW5ndGgpO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGogPSAwOyBpIDwgdGFncy5sZW5ndGg7IGkrKykge1xuICAgICAgICBzZWdtZW50LnNldCh0YWdzW2ldLmJ5dGVzLCBqKTtcbiAgICAgICAgaiArPSB0YWdzW2ldLmJ5dGVzLmJ5dGVMZW5ndGg7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWdtZW50O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFzc2VtYmxlIHRoZSBGTFYgdGFncyBpbiBkZWNvZGVyIG9yZGVyLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSB2aWRlb1RhZ3MgbGlzdCBvZiB2aWRlbyB0YWdzXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXVkaW9UYWdzIGxpc3Qgb2YgYXVkaW8gdGFnc1xuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnZ2V0T3JkZXJlZFRhZ3NfJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0T3JkZXJlZFRhZ3NfKHZpZGVvVGFncywgYXVkaW9UYWdzKSB7XG4gICAgICB2YXIgdGFnID0gdW5kZWZpbmVkO1xuICAgICAgdmFyIHRhZ3MgPSBbXTtcblxuICAgICAgd2hpbGUgKHZpZGVvVGFncy5sZW5ndGggfHwgYXVkaW9UYWdzLmxlbmd0aCkge1xuICAgICAgICBpZiAoIXZpZGVvVGFncy5sZW5ndGgpIHtcbiAgICAgICAgICAvLyBvbmx5IGF1ZGlvIHRhZ3MgcmVtYWluXG4gICAgICAgICAgdGFnID0gYXVkaW9UYWdzLnNoaWZ0KCk7XG4gICAgICAgIH0gZWxzZSBpZiAoIWF1ZGlvVGFncy5sZW5ndGgpIHtcbiAgICAgICAgICAvLyBvbmx5IHZpZGVvIHRhZ3MgcmVtYWluXG4gICAgICAgICAgdGFnID0gdmlkZW9UYWdzLnNoaWZ0KCk7XG4gICAgICAgIH0gZWxzZSBpZiAoYXVkaW9UYWdzWzBdLmR0cyA8IHZpZGVvVGFnc1swXS5kdHMpIHtcbiAgICAgICAgICAvLyBhdWRpbyBzaG91bGQgYmUgZGVjb2RlZCBuZXh0XG4gICAgICAgICAgdGFnID0gYXVkaW9UYWdzLnNoaWZ0KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gdmlkZW8gc2hvdWxkIGJlIGRlY29kZWQgbmV4dFxuICAgICAgICAgIHRhZyA9IHZpZGVvVGFncy5zaGlmdCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGFncy5wdXNoKHRhZyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0YWdzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ29uSGxzUmVzZXRfJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25IbHNSZXNldF8oKSB7XG4gICAgICB0aGlzLnRyYW5zbXV4ZXJfLnBvc3RNZXNzYWdlKHsgYWN0aW9uOiAncmVzZXRDYXB0aW9ucycgfSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEZsYXNoU291cmNlQnVmZmVyO1xufSkoX3ZpZGVvSnMyWydkZWZhdWx0J10uRXZlbnRUYXJnZXQpO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBGbGFzaFNvdXJjZUJ1ZmZlcjtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/videojs-contrib-media-sources/es5/flash-source-buffer.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/videojs-contrib-media-sources/es5/flash-transmuxer-worker.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/videojs-contrib-media-sources/es5/flash-transmuxer-worker.js ***!
  \***********************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("/**\n * @file flash-transmuxer-worker.js\n */\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nvar _globalWindow = __webpack_require__(/*! global/window */ \"(ssr)/./node_modules/videojs-contrib-media-sources/node_modules/global/window.js\");\n\nvar _globalWindow2 = _interopRequireDefault(_globalWindow);\n\nvar _muxJsLibFlv = __webpack_require__(/*! mux.js/lib/flv */ \"(ssr)/./node_modules/videojs-contrib-media-sources/node_modules/mux.js/lib/flv/index.js\");\n\nvar _muxJsLibFlv2 = _interopRequireDefault(_muxJsLibFlv);\n\n/**\n * Re-emits transmuxer events by converting them into messages to the\n * world outside the worker.\n *\n * @param {Object} transmuxer the transmuxer to wire events on\n * @private\n */\nvar wireTransmuxerEvents = function wireTransmuxerEvents(transmuxer) {\n  transmuxer.on('data', function (segment) {\n    _globalWindow2['default'].postMessage({\n      action: 'data',\n      segment: segment\n    });\n  });\n\n  transmuxer.on('done', function (data) {\n    _globalWindow2['default'].postMessage({ action: 'done' });\n  });\n};\n\n/**\n * All incoming messages route through this hash. If no function exists\n * to handle an incoming message, then we ignore the message.\n *\n * @class MessageHandlers\n * @param {Object} options the options to initialize with\n */\n\nvar MessageHandlers = (function () {\n  function MessageHandlers(options) {\n    _classCallCheck(this, MessageHandlers);\n\n    this.options = options || {};\n    this.init();\n  }\n\n  /**\n   * Our web wroker interface so that things can talk to mux.js\n   * that will be running in a web worker. The scope is passed to this by\n   * webworkify.\n   *\n   * @param {Object} self the scope for the web worker\n   */\n\n  /**\n   * initialize our web worker and wire all the events.\n   */\n\n  _createClass(MessageHandlers, [{\n    key: 'init',\n    value: function init() {\n      if (this.transmuxer) {\n        this.transmuxer.dispose();\n      }\n      this.transmuxer = new _muxJsLibFlv2['default'].Transmuxer(this.options);\n      wireTransmuxerEvents(this.transmuxer);\n    }\n\n    /**\n     * Adds data (a ts segment) to the start of the transmuxer pipeline for\n     * processing.\n     *\n     * @param {ArrayBuffer} data data to push into the muxer\n     */\n  }, {\n    key: 'push',\n    value: function push(data) {\n      // Cast array buffer to correct type for transmuxer\n      var segment = new Uint8Array(data.data, data.byteOffset, data.byteLength);\n\n      this.transmuxer.push(segment);\n    }\n\n    /**\n     * Recreate the transmuxer so that the next segment added via `push`\n     * start with a fresh transmuxer.\n     */\n  }, {\n    key: 'reset',\n    value: function reset() {\n      this.init();\n    }\n\n    /**\n     * Forces the pipeline to finish processing the last segment and emit its\n     * results.\n     */\n  }, {\n    key: 'flush',\n    value: function flush() {\n      this.transmuxer.flush();\n    }\n  }, {\n    key: 'resetCaptions',\n    value: function resetCaptions() {\n      this.transmuxer.resetCaptions();\n    }\n  }]);\n\n  return MessageHandlers;\n})();\n\nvar FlashTransmuxerWorker = function FlashTransmuxerWorker(self) {\n  self.onmessage = function (event) {\n    if (event.data.action === 'init' && event.data.options) {\n      this.messageHandlers = new MessageHandlers(event.data.options);\n      return;\n    }\n\n    if (!this.messageHandlers) {\n      this.messageHandlers = new MessageHandlers();\n    }\n\n    if (event.data && event.data.action && event.data.action !== 'init') {\n      if (this.messageHandlers[event.data.action]) {\n        this.messageHandlers[event.data.action](event.data);\n      }\n    }\n  };\n};\n\nexports[\"default\"] = function (self) {\n  return new FlashTransmuxerWorker(self);\n};\n\nmodule.exports = exports['default'];//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdmlkZW9qcy1jb250cmliLW1lZGlhLXNvdXJjZXMvZXM1L2ZsYXNoLXRyYW5zbXV4ZXItd29ya2VyLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNhOztBQUViLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQzs7QUFFRixrQ0FBa0MsMkNBQTJDLGdCQUFnQixrQkFBa0IsT0FBTywyQkFBMkIsd0RBQXdELGdDQUFnQyx1REFBdUQsK0RBQStELHlEQUF5RCxxRUFBcUUsNkRBQTZELHdCQUF3Qjs7QUFFbGpCLHVDQUF1Qyx1Q0FBdUM7O0FBRTlFLGtEQUFrRCwwQ0FBMEM7O0FBRTVGLG9CQUFvQixtQkFBTyxDQUFDLHVHQUFlOztBQUUzQzs7QUFFQSxtQkFBbUIsbUJBQU8sQ0FBQywrR0FBZ0I7O0FBRTNDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQSw0Q0FBNEMsZ0JBQWdCO0FBQzVELEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25COztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxhQUFhO0FBQzVCO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktdjAtcHJvamVjdC8uL25vZGVfbW9kdWxlcy92aWRlb2pzLWNvbnRyaWItbWVkaWEtc291cmNlcy9lczUvZmxhc2gtdHJhbnNtdXhlci13b3JrZXIuanM/YzU1OCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBmaWxlIGZsYXNoLXRyYW5zbXV4ZXItd29ya2VyLmpzXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSAoZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKCd2YWx1ZScgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0pKCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb24nKTsgfSB9XG5cbnZhciBfZ2xvYmFsV2luZG93ID0gcmVxdWlyZSgnZ2xvYmFsL3dpbmRvdycpO1xuXG52YXIgX2dsb2JhbFdpbmRvdzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9nbG9iYWxXaW5kb3cpO1xuXG52YXIgX211eEpzTGliRmx2ID0gcmVxdWlyZSgnbXV4LmpzL2xpYi9mbHYnKTtcblxudmFyIF9tdXhKc0xpYkZsdjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9tdXhKc0xpYkZsdik7XG5cbi8qKlxuICogUmUtZW1pdHMgdHJhbnNtdXhlciBldmVudHMgYnkgY29udmVydGluZyB0aGVtIGludG8gbWVzc2FnZXMgdG8gdGhlXG4gKiB3b3JsZCBvdXRzaWRlIHRoZSB3b3JrZXIuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHRyYW5zbXV4ZXIgdGhlIHRyYW5zbXV4ZXIgdG8gd2lyZSBldmVudHMgb25cbiAqIEBwcml2YXRlXG4gKi9cbnZhciB3aXJlVHJhbnNtdXhlckV2ZW50cyA9IGZ1bmN0aW9uIHdpcmVUcmFuc211eGVyRXZlbnRzKHRyYW5zbXV4ZXIpIHtcbiAgdHJhbnNtdXhlci5vbignZGF0YScsIGZ1bmN0aW9uIChzZWdtZW50KSB7XG4gICAgX2dsb2JhbFdpbmRvdzJbJ2RlZmF1bHQnXS5wb3N0TWVzc2FnZSh7XG4gICAgICBhY3Rpb246ICdkYXRhJyxcbiAgICAgIHNlZ21lbnQ6IHNlZ21lbnRcbiAgICB9KTtcbiAgfSk7XG5cbiAgdHJhbnNtdXhlci5vbignZG9uZScsIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgX2dsb2JhbFdpbmRvdzJbJ2RlZmF1bHQnXS5wb3N0TWVzc2FnZSh7IGFjdGlvbjogJ2RvbmUnIH0pO1xuICB9KTtcbn07XG5cbi8qKlxuICogQWxsIGluY29taW5nIG1lc3NhZ2VzIHJvdXRlIHRocm91Z2ggdGhpcyBoYXNoLiBJZiBubyBmdW5jdGlvbiBleGlzdHNcbiAqIHRvIGhhbmRsZSBhbiBpbmNvbWluZyBtZXNzYWdlLCB0aGVuIHdlIGlnbm9yZSB0aGUgbWVzc2FnZS5cbiAqXG4gKiBAY2xhc3MgTWVzc2FnZUhhbmRsZXJzXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyB0aGUgb3B0aW9ucyB0byBpbml0aWFsaXplIHdpdGhcbiAqL1xuXG52YXIgTWVzc2FnZUhhbmRsZXJzID0gKGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gTWVzc2FnZUhhbmRsZXJzKG9wdGlvbnMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTWVzc2FnZUhhbmRsZXJzKTtcblxuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgdGhpcy5pbml0KCk7XG4gIH1cblxuICAvKipcbiAgICogT3VyIHdlYiB3cm9rZXIgaW50ZXJmYWNlIHNvIHRoYXQgdGhpbmdzIGNhbiB0YWxrIHRvIG11eC5qc1xuICAgKiB0aGF0IHdpbGwgYmUgcnVubmluZyBpbiBhIHdlYiB3b3JrZXIuIFRoZSBzY29wZSBpcyBwYXNzZWQgdG8gdGhpcyBieVxuICAgKiB3ZWJ3b3JraWZ5LlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gc2VsZiB0aGUgc2NvcGUgZm9yIHRoZSB3ZWIgd29ya2VyXG4gICAqL1xuXG4gIC8qKlxuICAgKiBpbml0aWFsaXplIG91ciB3ZWIgd29ya2VyIGFuZCB3aXJlIGFsbCB0aGUgZXZlbnRzLlxuICAgKi9cblxuICBfY3JlYXRlQ2xhc3MoTWVzc2FnZUhhbmRsZXJzLCBbe1xuICAgIGtleTogJ2luaXQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0KCkge1xuICAgICAgaWYgKHRoaXMudHJhbnNtdXhlcikge1xuICAgICAgICB0aGlzLnRyYW5zbXV4ZXIuZGlzcG9zZSgpO1xuICAgICAgfVxuICAgICAgdGhpcy50cmFuc211eGVyID0gbmV3IF9tdXhKc0xpYkZsdjJbJ2RlZmF1bHQnXS5UcmFuc211eGVyKHRoaXMub3B0aW9ucyk7XG4gICAgICB3aXJlVHJhbnNtdXhlckV2ZW50cyh0aGlzLnRyYW5zbXV4ZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZHMgZGF0YSAoYSB0cyBzZWdtZW50KSB0byB0aGUgc3RhcnQgb2YgdGhlIHRyYW5zbXV4ZXIgcGlwZWxpbmUgZm9yXG4gICAgICogcHJvY2Vzc2luZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGRhdGEgZGF0YSB0byBwdXNoIGludG8gdGhlIG11eGVyXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdwdXNoJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHVzaChkYXRhKSB7XG4gICAgICAvLyBDYXN0IGFycmF5IGJ1ZmZlciB0byBjb3JyZWN0IHR5cGUgZm9yIHRyYW5zbXV4ZXJcbiAgICAgIHZhciBzZWdtZW50ID0gbmV3IFVpbnQ4QXJyYXkoZGF0YS5kYXRhLCBkYXRhLmJ5dGVPZmZzZXQsIGRhdGEuYnl0ZUxlbmd0aCk7XG5cbiAgICAgIHRoaXMudHJhbnNtdXhlci5wdXNoKHNlZ21lbnQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlY3JlYXRlIHRoZSB0cmFuc211eGVyIHNvIHRoYXQgdGhlIG5leHQgc2VnbWVudCBhZGRlZCB2aWEgYHB1c2hgXG4gICAgICogc3RhcnQgd2l0aCBhIGZyZXNoIHRyYW5zbXV4ZXIuXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdyZXNldCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgICAgdGhpcy5pbml0KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRm9yY2VzIHRoZSBwaXBlbGluZSB0byBmaW5pc2ggcHJvY2Vzc2luZyB0aGUgbGFzdCBzZWdtZW50IGFuZCBlbWl0IGl0c1xuICAgICAqIHJlc3VsdHMuXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdmbHVzaCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZsdXNoKCkge1xuICAgICAgdGhpcy50cmFuc211eGVyLmZsdXNoKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAncmVzZXRDYXB0aW9ucycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlc2V0Q2FwdGlvbnMoKSB7XG4gICAgICB0aGlzLnRyYW5zbXV4ZXIucmVzZXRDYXB0aW9ucygpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBNZXNzYWdlSGFuZGxlcnM7XG59KSgpO1xuXG52YXIgRmxhc2hUcmFuc211eGVyV29ya2VyID0gZnVuY3Rpb24gRmxhc2hUcmFuc211eGVyV29ya2VyKHNlbGYpIHtcbiAgc2VsZi5vbm1lc3NhZ2UgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQuZGF0YS5hY3Rpb24gPT09ICdpbml0JyAmJiBldmVudC5kYXRhLm9wdGlvbnMpIHtcbiAgICAgIHRoaXMubWVzc2FnZUhhbmRsZXJzID0gbmV3IE1lc3NhZ2VIYW5kbGVycyhldmVudC5kYXRhLm9wdGlvbnMpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5tZXNzYWdlSGFuZGxlcnMpIHtcbiAgICAgIHRoaXMubWVzc2FnZUhhbmRsZXJzID0gbmV3IE1lc3NhZ2VIYW5kbGVycygpO1xuICAgIH1cblxuICAgIGlmIChldmVudC5kYXRhICYmIGV2ZW50LmRhdGEuYWN0aW9uICYmIGV2ZW50LmRhdGEuYWN0aW9uICE9PSAnaW5pdCcpIHtcbiAgICAgIGlmICh0aGlzLm1lc3NhZ2VIYW5kbGVyc1tldmVudC5kYXRhLmFjdGlvbl0pIHtcbiAgICAgICAgdGhpcy5tZXNzYWdlSGFuZGxlcnNbZXZlbnQuZGF0YS5hY3Rpb25dKGV2ZW50LmRhdGEpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn07XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IGZ1bmN0aW9uIChzZWxmKSB7XG4gIHJldHVybiBuZXcgRmxhc2hUcmFuc211eGVyV29ya2VyKHNlbGYpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/videojs-contrib-media-sources/es5/flash-transmuxer-worker.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/videojs-contrib-media-sources/es5/html-media-source.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/videojs-contrib-media-sources/es5/html-media-source.js ***!
  \*****************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("/**\n * @file html-media-source.js\n */\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nvar _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar _globalWindow = __webpack_require__(/*! global/window */ \"(ssr)/./node_modules/videojs-contrib-media-sources/node_modules/global/window.js\");\n\nvar _globalWindow2 = _interopRequireDefault(_globalWindow);\n\nvar _globalDocument = __webpack_require__(/*! global/document */ \"(ssr)/./node_modules/videojs-contrib-media-sources/node_modules/global/document.js\");\n\nvar _globalDocument2 = _interopRequireDefault(_globalDocument);\n\nvar _videoJs = __webpack_require__(/*! video.js */ \"(ssr)/./node_modules/videojs-contrib-media-sources/node_modules/video.js/dist/video.cjs.js\");\n\nvar _videoJs2 = _interopRequireDefault(_videoJs);\n\nvar _virtualSourceBuffer = __webpack_require__(/*! ./virtual-source-buffer */ \"(ssr)/./node_modules/videojs-contrib-media-sources/es5/virtual-source-buffer.js\");\n\nvar _virtualSourceBuffer2 = _interopRequireDefault(_virtualSourceBuffer);\n\nvar _addTextTrackData = __webpack_require__(/*! ./add-text-track-data */ \"(ssr)/./node_modules/videojs-contrib-media-sources/es5/add-text-track-data.js\");\n\nvar _codecUtils = __webpack_require__(/*! ./codec-utils */ \"(ssr)/./node_modules/videojs-contrib-media-sources/es5/codec-utils.js\");\n\n/**\n * Our MediaSource implementation in HTML, mimics native\n * MediaSource where/if possible.\n *\n * @link https://developer.mozilla.org/en-US/docs/Web/API/MediaSource\n * @class HtmlMediaSource\n * @extends videojs.EventTarget\n */\n\nvar HtmlMediaSource = (function (_videojs$EventTarget) {\n  _inherits(HtmlMediaSource, _videojs$EventTarget);\n\n  function HtmlMediaSource() {\n    var _this = this;\n\n    _classCallCheck(this, HtmlMediaSource);\n\n    _get(Object.getPrototypeOf(HtmlMediaSource.prototype), 'constructor', this).call(this);\n    var property = undefined;\n\n    this.nativeMediaSource_ = new _globalWindow2['default'].MediaSource();\n    // delegate to the native MediaSource's methods by default\n    for (property in this.nativeMediaSource_) {\n      if (!(property in HtmlMediaSource.prototype) && typeof this.nativeMediaSource_[property] === 'function') {\n        this[property] = this.nativeMediaSource_[property].bind(this.nativeMediaSource_);\n      }\n    }\n\n    // emulate `duration` and `seekable` until seeking can be\n    // handled uniformly for live streams\n    // see https://github.com/w3c/media-source/issues/5\n    this.duration_ = NaN;\n    Object.defineProperty(this, 'duration', {\n      get: function get() {\n        if (this.duration_ === Infinity) {\n          return this.duration_;\n        }\n        return this.nativeMediaSource_.duration;\n      },\n      set: function set(duration) {\n        this.duration_ = duration;\n        if (duration !== Infinity) {\n          this.nativeMediaSource_.duration = duration;\n          return;\n        }\n      }\n    });\n    Object.defineProperty(this, 'seekable', {\n      get: function get() {\n        if (this.duration_ === Infinity) {\n          return _videoJs2['default'].createTimeRanges([[0, this.nativeMediaSource_.duration]]);\n        }\n        return this.nativeMediaSource_.seekable;\n      }\n    });\n\n    Object.defineProperty(this, 'readyState', {\n      get: function get() {\n        return this.nativeMediaSource_.readyState;\n      }\n    });\n\n    Object.defineProperty(this, 'activeSourceBuffers', {\n      get: function get() {\n        return this.activeSourceBuffers_;\n      }\n    });\n\n    // the list of virtual and native SourceBuffers created by this\n    // MediaSource\n    this.sourceBuffers = [];\n\n    this.activeSourceBuffers_ = [];\n\n    /**\n     * update the list of active source buffers based upon various\n     * imformation from HLS and video.js\n     *\n     * @private\n     */\n    this.updateActiveSourceBuffers_ = function () {\n      // Retain the reference but empty the array\n      _this.activeSourceBuffers_.length = 0;\n\n      // If there is only one source buffer, then it will always be active and audio will\n      // be disabled based on the codec of the source buffer\n      if (_this.sourceBuffers.length === 1) {\n        var sourceBuffer = _this.sourceBuffers[0];\n\n        sourceBuffer.appendAudioInitSegment_ = true;\n        sourceBuffer.audioDisabled_ = !sourceBuffer.audioCodec_;\n        _this.activeSourceBuffers_.push(sourceBuffer);\n        return;\n      }\n\n      // There are 2 source buffers, a combined (possibly video only) source buffer and\n      // and an audio only source buffer.\n      // By default, the audio in the combined virtual source buffer is enabled\n      // and the audio-only source buffer (if it exists) is disabled.\n      var disableCombined = false;\n      var disableAudioOnly = true;\n\n      // TODO: maybe we can store the sourcebuffers on the track objects?\n      // safari may do something like this\n      for (var i = 0; i < _this.player_.audioTracks().length; i++) {\n        var track = _this.player_.audioTracks()[i];\n\n        if (track.enabled && track.kind !== 'main') {\n          // The enabled track is an alternate audio track so disable the audio in\n          // the combined source buffer and enable the audio-only source buffer.\n          disableCombined = true;\n          disableAudioOnly = false;\n          break;\n        }\n      }\n\n      _this.sourceBuffers.forEach(function (sourceBuffer) {\n        /* eslinst-disable */\n        // TODO once codecs are required, we can switch to using the codecs to determine\n        //      what stream is the video stream, rather than relying on videoTracks\n        /* eslinst-enable */\n\n        sourceBuffer.appendAudioInitSegment_ = true;\n\n        if (sourceBuffer.videoCodec_ && sourceBuffer.audioCodec_) {\n          // combined\n          sourceBuffer.audioDisabled_ = disableCombined;\n        } else if (sourceBuffer.videoCodec_ && !sourceBuffer.audioCodec_) {\n          // If the \"combined\" source buffer is video only, then we do not want\n          // disable the audio-only source buffer (this is mostly for demuxed\n          // audio and video hls)\n          sourceBuffer.audioDisabled_ = true;\n          disableAudioOnly = false;\n        } else if (!sourceBuffer.videoCodec_ && sourceBuffer.audioCodec_) {\n          // audio only\n          sourceBuffer.audioDisabled_ = disableAudioOnly;\n          if (disableAudioOnly) {\n            return;\n          }\n        }\n\n        _this.activeSourceBuffers_.push(sourceBuffer);\n      });\n    };\n\n    this.onPlayerMediachange_ = function () {\n      _this.sourceBuffers.forEach(function (sourceBuffer) {\n        sourceBuffer.appendAudioInitSegment_ = true;\n      });\n    };\n\n    this.onHlsReset_ = function () {\n      _this.sourceBuffers.forEach(function (sourceBuffer) {\n        if (sourceBuffer.transmuxer_) {\n          sourceBuffer.transmuxer_.postMessage({ action: 'resetCaptions' });\n        }\n      });\n    };\n\n    this.onHlsSegmentTimeMapping_ = function (event) {\n      _this.sourceBuffers.forEach(function (buffer) {\n        return buffer.timeMapping_ = event.mapping;\n      });\n    };\n\n    // Re-emit MediaSource events on the polyfill\n    ['sourceopen', 'sourceclose', 'sourceended'].forEach(function (eventName) {\n      this.nativeMediaSource_.addEventListener(eventName, this.trigger.bind(this));\n    }, this);\n\n    // capture the associated player when the MediaSource is\n    // successfully attached\n    this.on('sourceopen', function (event) {\n      // Get the player this MediaSource is attached to\n      var video = _globalDocument2['default'].querySelector('[src=\"' + _this.url_ + '\"]');\n\n      if (!video) {\n        return;\n      }\n\n      _this.player_ = (0, _videoJs2['default'])(video.parentNode);\n\n      // hls-reset is fired by videojs.Hls on to the tech after the main SegmentLoader\n      // resets its state and flushes the buffer\n      _this.player_.tech_.on('hls-reset', _this.onHlsReset_);\n      // hls-segment-time-mapping is fired by videojs.Hls on to the tech after the main\n      // SegmentLoader inspects an MTS segment and has an accurate stream to display\n      // time mapping\n      _this.player_.tech_.on('hls-segment-time-mapping', _this.onHlsSegmentTimeMapping_);\n\n      if (_this.player_.audioTracks && _this.player_.audioTracks()) {\n        _this.player_.audioTracks().on('change', _this.updateActiveSourceBuffers_);\n        _this.player_.audioTracks().on('addtrack', _this.updateActiveSourceBuffers_);\n        _this.player_.audioTracks().on('removetrack', _this.updateActiveSourceBuffers_);\n      }\n\n      _this.player_.on('mediachange', _this.onPlayerMediachange_);\n    });\n\n    this.on('sourceended', function (event) {\n      var duration = (0, _addTextTrackData.durationOfVideo)(_this.duration);\n\n      for (var i = 0; i < _this.sourceBuffers.length; i++) {\n        var sourcebuffer = _this.sourceBuffers[i];\n        var cues = sourcebuffer.metadataTrack_ && sourcebuffer.metadataTrack_.cues;\n\n        if (cues && cues.length) {\n          cues[cues.length - 1].endTime = duration;\n        }\n      }\n    });\n\n    // explicitly terminate any WebWorkers that were created\n    // by SourceHandlers\n    this.on('sourceclose', function (event) {\n      this.sourceBuffers.forEach(function (sourceBuffer) {\n        if (sourceBuffer.transmuxer_) {\n          sourceBuffer.transmuxer_.terminate();\n        }\n      });\n\n      this.sourceBuffers.length = 0;\n      if (!this.player_) {\n        return;\n      }\n\n      if (this.player_.audioTracks && this.player_.audioTracks()) {\n        this.player_.audioTracks().off('change', this.updateActiveSourceBuffers_);\n        this.player_.audioTracks().off('addtrack', this.updateActiveSourceBuffers_);\n        this.player_.audioTracks().off('removetrack', this.updateActiveSourceBuffers_);\n      }\n\n      // We can only change this if the player hasn't been disposed of yet\n      // because `off` eventually tries to use the el_ property. If it has\n      // been disposed of, then don't worry about it because there are no\n      // event handlers left to unbind anyway\n      if (this.player_.el_) {\n        this.player_.off('mediachange', this.onPlayerMediachange_);\n        this.player_.tech_.off('hls-reset', this.onHlsReset_);\n        this.player_.tech_.off('hls-segment-time-mapping', this.onHlsSegmentTimeMapping_);\n      }\n    });\n  }\n\n  /**\n   * Add a range that that can now be seeked to.\n   *\n   * @param {Double} start where to start the addition\n   * @param {Double} end where to end the addition\n   * @private\n   */\n\n  _createClass(HtmlMediaSource, [{\n    key: 'addSeekableRange_',\n    value: function addSeekableRange_(start, end) {\n      var error = undefined;\n\n      if (this.duration !== Infinity) {\n        error = new Error('MediaSource.addSeekableRange() can only be invoked ' + 'when the duration is Infinity');\n        error.name = 'InvalidStateError';\n        error.code = 11;\n        throw error;\n      }\n\n      if (end > this.nativeMediaSource_.duration || isNaN(this.nativeMediaSource_.duration)) {\n        this.nativeMediaSource_.duration = end;\n      }\n    }\n\n    /**\n     * Add a source buffer to the media source.\n     *\n     * @link https://developer.mozilla.org/en-US/docs/Web/API/MediaSource/addSourceBuffer\n     * @param {String} type the content-type of the content\n     * @return {Object} the created source buffer\n     */\n  }, {\n    key: 'addSourceBuffer',\n    value: function addSourceBuffer(type) {\n      var buffer = undefined;\n      var parsedType = (0, _codecUtils.parseContentType)(type);\n\n      // Create a VirtualSourceBuffer to transmux MPEG-2 transport\n      // stream segments into fragmented MP4s\n      if (/^(video|audio)\\/mp2t$/i.test(parsedType.type)) {\n        var codecs = [];\n\n        if (parsedType.parameters && parsedType.parameters.codecs) {\n          codecs = parsedType.parameters.codecs.split(',');\n          codecs = (0, _codecUtils.translateLegacyCodecs)(codecs);\n          codecs = codecs.filter(function (codec) {\n            return (0, _codecUtils.isAudioCodec)(codec) || (0, _codecUtils.isVideoCodec)(codec);\n          });\n        }\n\n        if (codecs.length === 0) {\n          codecs = ['avc1.4d400d', 'mp4a.40.2'];\n        }\n\n        buffer = new _virtualSourceBuffer2['default'](this, codecs);\n\n        if (this.sourceBuffers.length !== 0) {\n          // If another VirtualSourceBuffer already exists, then we are creating a\n          // SourceBuffer for an alternate audio track and therefore we know that\n          // the source has both an audio and video track.\n          // That means we should trigger the manual creation of the real\n          // SourceBuffers instead of waiting for the transmuxer to return data\n          this.sourceBuffers[0].createRealSourceBuffers_();\n          buffer.createRealSourceBuffers_();\n\n          // Automatically disable the audio on the first source buffer if\n          // a second source buffer is ever created\n          this.sourceBuffers[0].audioDisabled_ = true;\n        }\n      } else {\n        // delegate to the native implementation\n        buffer = this.nativeMediaSource_.addSourceBuffer(type);\n      }\n\n      this.sourceBuffers.push(buffer);\n      return buffer;\n    }\n  }]);\n\n  return HtmlMediaSource;\n})(_videoJs2['default'].EventTarget);\n\nexports[\"default\"] = HtmlMediaSource;\nmodule.exports = exports['default'];//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdmlkZW9qcy1jb250cmliLW1lZGlhLXNvdXJjZXMvZXM1L2h0bWwtbWVkaWEtc291cmNlLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNhOztBQUViLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQzs7QUFFRixrQ0FBa0MsMkNBQTJDLGdCQUFnQixrQkFBa0IsT0FBTywyQkFBMkIsd0RBQXdELGdDQUFnQyx1REFBdUQsK0RBQStELHlEQUF5RCxxRUFBcUUsNkRBQTZELHdCQUF3Qjs7QUFFbGpCLHdDQUF3QyxtQkFBbUIsNEJBQTRCLGlEQUFpRCxnQkFBZ0Isa0RBQWtELDhEQUE4RCwwQkFBMEIsNENBQTRDLHVCQUF1QixvQkFBb0IsT0FBTyxhQUFhLGdCQUFnQixnQkFBZ0IsZUFBZSwyQkFBMkIsd0JBQXdCLDRCQUE0QixxQkFBcUIsT0FBTyx1QkFBdUIsNEJBQTRCLG9CQUFvQjs7QUFFOW1CLHVDQUF1Qyx1Q0FBdUM7O0FBRTlFLGtEQUFrRCwwQ0FBMEM7O0FBRTVGLDJDQUEyQywrREFBK0QsdUdBQXVHLHlFQUF5RSxlQUFlLDBFQUEwRSxHQUFHOztBQUV0WCxvQkFBb0IsbUJBQU8sQ0FBQyx1R0FBZTs7QUFFM0M7O0FBRUEsc0JBQXNCLG1CQUFPLENBQUMsMkdBQWlCOztBQUUvQzs7QUFFQSxlQUFlLG1CQUFPLENBQUMsNEdBQVU7O0FBRWpDOztBQUVBLDJCQUEyQixtQkFBTyxDQUFDLGdIQUF5Qjs7QUFFNUQ7O0FBRUEsd0JBQXdCLG1CQUFPLENBQUMsNEdBQXVCOztBQUV2RCxrQkFBa0IsbUJBQU8sQ0FBQyw0RkFBZTs7QUFFekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQkFBc0Isd0NBQXdDO0FBQzlEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCx5QkFBeUI7QUFDMUU7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQSxzQkFBc0IsZ0NBQWdDO0FBQ3REO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVELGtCQUFrQjtBQUNsQiIsInNvdXJjZXMiOlsid2VicGFjazovL215LXYwLXByb2plY3QvLi9ub2RlX21vZHVsZXMvdmlkZW9qcy1jb250cmliLW1lZGlhLXNvdXJjZXMvZXM1L2h0bWwtbWVkaWEtc291cmNlLmpzP2YxNGUiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAZmlsZSBodG1sLW1lZGlhLXNvdXJjZS5qc1xuICovXG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gKGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmICgndmFsdWUnIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KSgpO1xuXG52YXIgX2dldCA9IGZ1bmN0aW9uIGdldChfeCwgX3gyLCBfeDMpIHsgdmFyIF9hZ2FpbiA9IHRydWU7IF9mdW5jdGlvbjogd2hpbGUgKF9hZ2FpbikgeyB2YXIgb2JqZWN0ID0gX3gsIHByb3BlcnR5ID0gX3gyLCByZWNlaXZlciA9IF94MzsgX2FnYWluID0gZmFsc2U7IGlmIChvYmplY3QgPT09IG51bGwpIG9iamVjdCA9IEZ1bmN0aW9uLnByb3RvdHlwZTsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgcHJvcGVydHkpOyBpZiAoZGVzYyA9PT0gdW5kZWZpbmVkKSB7IHZhciBwYXJlbnQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgaWYgKHBhcmVudCA9PT0gbnVsbCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IGVsc2UgeyBfeCA9IHBhcmVudDsgX3gyID0gcHJvcGVydHk7IF94MyA9IHJlY2VpdmVyOyBfYWdhaW4gPSB0cnVlOyBkZXNjID0gcGFyZW50ID0gdW5kZWZpbmVkOyBjb250aW51ZSBfZnVuY3Rpb247IH0gfSBlbHNlIGlmICgndmFsdWUnIGluIGRlc2MpIHsgcmV0dXJuIGRlc2MudmFsdWU7IH0gZWxzZSB7IHZhciBnZXR0ZXIgPSBkZXNjLmdldDsgaWYgKGdldHRlciA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gcmV0dXJuIGdldHRlci5jYWxsKHJlY2VpdmVyKTsgfSB9IH07XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb24nKTsgfSB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09ICdmdW5jdGlvbicgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90ICcgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBfZ2xvYmFsV2luZG93ID0gcmVxdWlyZSgnZ2xvYmFsL3dpbmRvdycpO1xuXG52YXIgX2dsb2JhbFdpbmRvdzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9nbG9iYWxXaW5kb3cpO1xuXG52YXIgX2dsb2JhbERvY3VtZW50ID0gcmVxdWlyZSgnZ2xvYmFsL2RvY3VtZW50Jyk7XG5cbnZhciBfZ2xvYmFsRG9jdW1lbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2xvYmFsRG9jdW1lbnQpO1xuXG52YXIgX3ZpZGVvSnMgPSByZXF1aXJlKCd2aWRlby5qcycpO1xuXG52YXIgX3ZpZGVvSnMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdmlkZW9Kcyk7XG5cbnZhciBfdmlydHVhbFNvdXJjZUJ1ZmZlciA9IHJlcXVpcmUoJy4vdmlydHVhbC1zb3VyY2UtYnVmZmVyJyk7XG5cbnZhciBfdmlydHVhbFNvdXJjZUJ1ZmZlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF92aXJ0dWFsU291cmNlQnVmZmVyKTtcblxudmFyIF9hZGRUZXh0VHJhY2tEYXRhID0gcmVxdWlyZSgnLi9hZGQtdGV4dC10cmFjay1kYXRhJyk7XG5cbnZhciBfY29kZWNVdGlscyA9IHJlcXVpcmUoJy4vY29kZWMtdXRpbHMnKTtcblxuLyoqXG4gKiBPdXIgTWVkaWFTb3VyY2UgaW1wbGVtZW50YXRpb24gaW4gSFRNTCwgbWltaWNzIG5hdGl2ZVxuICogTWVkaWFTb3VyY2Ugd2hlcmUvaWYgcG9zc2libGUuXG4gKlxuICogQGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL01lZGlhU291cmNlXG4gKiBAY2xhc3MgSHRtbE1lZGlhU291cmNlXG4gKiBAZXh0ZW5kcyB2aWRlb2pzLkV2ZW50VGFyZ2V0XG4gKi9cblxudmFyIEh0bWxNZWRpYVNvdXJjZSA9IChmdW5jdGlvbiAoX3ZpZGVvanMkRXZlbnRUYXJnZXQpIHtcbiAgX2luaGVyaXRzKEh0bWxNZWRpYVNvdXJjZSwgX3ZpZGVvanMkRXZlbnRUYXJnZXQpO1xuXG4gIGZ1bmN0aW9uIEh0bWxNZWRpYVNvdXJjZSgpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEh0bWxNZWRpYVNvdXJjZSk7XG5cbiAgICBfZ2V0KE9iamVjdC5nZXRQcm90b3R5cGVPZihIdG1sTWVkaWFTb3VyY2UucHJvdG90eXBlKSwgJ2NvbnN0cnVjdG9yJywgdGhpcykuY2FsbCh0aGlzKTtcbiAgICB2YXIgcHJvcGVydHkgPSB1bmRlZmluZWQ7XG5cbiAgICB0aGlzLm5hdGl2ZU1lZGlhU291cmNlXyA9IG5ldyBfZ2xvYmFsV2luZG93MlsnZGVmYXVsdCddLk1lZGlhU291cmNlKCk7XG4gICAgLy8gZGVsZWdhdGUgdG8gdGhlIG5hdGl2ZSBNZWRpYVNvdXJjZSdzIG1ldGhvZHMgYnkgZGVmYXVsdFxuICAgIGZvciAocHJvcGVydHkgaW4gdGhpcy5uYXRpdmVNZWRpYVNvdXJjZV8pIHtcbiAgICAgIGlmICghKHByb3BlcnR5IGluIEh0bWxNZWRpYVNvdXJjZS5wcm90b3R5cGUpICYmIHR5cGVvZiB0aGlzLm5hdGl2ZU1lZGlhU291cmNlX1twcm9wZXJ0eV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhpc1twcm9wZXJ0eV0gPSB0aGlzLm5hdGl2ZU1lZGlhU291cmNlX1twcm9wZXJ0eV0uYmluZCh0aGlzLm5hdGl2ZU1lZGlhU291cmNlXyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gZW11bGF0ZSBgZHVyYXRpb25gIGFuZCBgc2Vla2FibGVgIHVudGlsIHNlZWtpbmcgY2FuIGJlXG4gICAgLy8gaGFuZGxlZCB1bmlmb3JtbHkgZm9yIGxpdmUgc3RyZWFtc1xuICAgIC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vdzNjL21lZGlhLXNvdXJjZS9pc3N1ZXMvNVxuICAgIHRoaXMuZHVyYXRpb25fID0gTmFOO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnZHVyYXRpb24nLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgaWYgKHRoaXMuZHVyYXRpb25fID09PSBJbmZpbml0eSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmR1cmF0aW9uXztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5uYXRpdmVNZWRpYVNvdXJjZV8uZHVyYXRpb247XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQoZHVyYXRpb24pIHtcbiAgICAgICAgdGhpcy5kdXJhdGlvbl8gPSBkdXJhdGlvbjtcbiAgICAgICAgaWYgKGR1cmF0aW9uICE9PSBJbmZpbml0eSkge1xuICAgICAgICAgIHRoaXMubmF0aXZlTWVkaWFTb3VyY2VfLmR1cmF0aW9uID0gZHVyYXRpb247XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdzZWVrYWJsZScsIHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICBpZiAodGhpcy5kdXJhdGlvbl8gPT09IEluZmluaXR5KSB7XG4gICAgICAgICAgcmV0dXJuIF92aWRlb0pzMlsnZGVmYXVsdCddLmNyZWF0ZVRpbWVSYW5nZXMoW1swLCB0aGlzLm5hdGl2ZU1lZGlhU291cmNlXy5kdXJhdGlvbl1dKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5uYXRpdmVNZWRpYVNvdXJjZV8uc2Vla2FibGU7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3JlYWR5U3RhdGUnLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmF0aXZlTWVkaWFTb3VyY2VfLnJlYWR5U3RhdGU7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2FjdGl2ZVNvdXJjZUJ1ZmZlcnMnLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWN0aXZlU291cmNlQnVmZmVyc187XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyB0aGUgbGlzdCBvZiB2aXJ0dWFsIGFuZCBuYXRpdmUgU291cmNlQnVmZmVycyBjcmVhdGVkIGJ5IHRoaXNcbiAgICAvLyBNZWRpYVNvdXJjZVxuICAgIHRoaXMuc291cmNlQnVmZmVycyA9IFtdO1xuXG4gICAgdGhpcy5hY3RpdmVTb3VyY2VCdWZmZXJzXyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogdXBkYXRlIHRoZSBsaXN0IG9mIGFjdGl2ZSBzb3VyY2UgYnVmZmVycyBiYXNlZCB1cG9uIHZhcmlvdXNcbiAgICAgKiBpbWZvcm1hdGlvbiBmcm9tIEhMUyBhbmQgdmlkZW8uanNcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy51cGRhdGVBY3RpdmVTb3VyY2VCdWZmZXJzXyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIFJldGFpbiB0aGUgcmVmZXJlbmNlIGJ1dCBlbXB0eSB0aGUgYXJyYXlcbiAgICAgIF90aGlzLmFjdGl2ZVNvdXJjZUJ1ZmZlcnNfLmxlbmd0aCA9IDA7XG5cbiAgICAgIC8vIElmIHRoZXJlIGlzIG9ubHkgb25lIHNvdXJjZSBidWZmZXIsIHRoZW4gaXQgd2lsbCBhbHdheXMgYmUgYWN0aXZlIGFuZCBhdWRpbyB3aWxsXG4gICAgICAvLyBiZSBkaXNhYmxlZCBiYXNlZCBvbiB0aGUgY29kZWMgb2YgdGhlIHNvdXJjZSBidWZmZXJcbiAgICAgIGlmIChfdGhpcy5zb3VyY2VCdWZmZXJzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICB2YXIgc291cmNlQnVmZmVyID0gX3RoaXMuc291cmNlQnVmZmVyc1swXTtcblxuICAgICAgICBzb3VyY2VCdWZmZXIuYXBwZW5kQXVkaW9Jbml0U2VnbWVudF8gPSB0cnVlO1xuICAgICAgICBzb3VyY2VCdWZmZXIuYXVkaW9EaXNhYmxlZF8gPSAhc291cmNlQnVmZmVyLmF1ZGlvQ29kZWNfO1xuICAgICAgICBfdGhpcy5hY3RpdmVTb3VyY2VCdWZmZXJzXy5wdXNoKHNvdXJjZUJ1ZmZlcik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gVGhlcmUgYXJlIDIgc291cmNlIGJ1ZmZlcnMsIGEgY29tYmluZWQgKHBvc3NpYmx5IHZpZGVvIG9ubHkpIHNvdXJjZSBidWZmZXIgYW5kXG4gICAgICAvLyBhbmQgYW4gYXVkaW8gb25seSBzb3VyY2UgYnVmZmVyLlxuICAgICAgLy8gQnkgZGVmYXVsdCwgdGhlIGF1ZGlvIGluIHRoZSBjb21iaW5lZCB2aXJ0dWFsIHNvdXJjZSBidWZmZXIgaXMgZW5hYmxlZFxuICAgICAgLy8gYW5kIHRoZSBhdWRpby1vbmx5IHNvdXJjZSBidWZmZXIgKGlmIGl0IGV4aXN0cykgaXMgZGlzYWJsZWQuXG4gICAgICB2YXIgZGlzYWJsZUNvbWJpbmVkID0gZmFsc2U7XG4gICAgICB2YXIgZGlzYWJsZUF1ZGlvT25seSA9IHRydWU7XG5cbiAgICAgIC8vIFRPRE86IG1heWJlIHdlIGNhbiBzdG9yZSB0aGUgc291cmNlYnVmZmVycyBvbiB0aGUgdHJhY2sgb2JqZWN0cz9cbiAgICAgIC8vIHNhZmFyaSBtYXkgZG8gc29tZXRoaW5nIGxpa2UgdGhpc1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBfdGhpcy5wbGF5ZXJfLmF1ZGlvVHJhY2tzKCkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHRyYWNrID0gX3RoaXMucGxheWVyXy5hdWRpb1RyYWNrcygpW2ldO1xuXG4gICAgICAgIGlmICh0cmFjay5lbmFibGVkICYmIHRyYWNrLmtpbmQgIT09ICdtYWluJykge1xuICAgICAgICAgIC8vIFRoZSBlbmFibGVkIHRyYWNrIGlzIGFuIGFsdGVybmF0ZSBhdWRpbyB0cmFjayBzbyBkaXNhYmxlIHRoZSBhdWRpbyBpblxuICAgICAgICAgIC8vIHRoZSBjb21iaW5lZCBzb3VyY2UgYnVmZmVyIGFuZCBlbmFibGUgdGhlIGF1ZGlvLW9ubHkgc291cmNlIGJ1ZmZlci5cbiAgICAgICAgICBkaXNhYmxlQ29tYmluZWQgPSB0cnVlO1xuICAgICAgICAgIGRpc2FibGVBdWRpb09ubHkgPSBmYWxzZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBfdGhpcy5zb3VyY2VCdWZmZXJzLmZvckVhY2goZnVuY3Rpb24gKHNvdXJjZUJ1ZmZlcikge1xuICAgICAgICAvKiBlc2xpbnN0LWRpc2FibGUgKi9cbiAgICAgICAgLy8gVE9ETyBvbmNlIGNvZGVjcyBhcmUgcmVxdWlyZWQsIHdlIGNhbiBzd2l0Y2ggdG8gdXNpbmcgdGhlIGNvZGVjcyB0byBkZXRlcm1pbmVcbiAgICAgICAgLy8gICAgICB3aGF0IHN0cmVhbSBpcyB0aGUgdmlkZW8gc3RyZWFtLCByYXRoZXIgdGhhbiByZWx5aW5nIG9uIHZpZGVvVHJhY2tzXG4gICAgICAgIC8qIGVzbGluc3QtZW5hYmxlICovXG5cbiAgICAgICAgc291cmNlQnVmZmVyLmFwcGVuZEF1ZGlvSW5pdFNlZ21lbnRfID0gdHJ1ZTtcblxuICAgICAgICBpZiAoc291cmNlQnVmZmVyLnZpZGVvQ29kZWNfICYmIHNvdXJjZUJ1ZmZlci5hdWRpb0NvZGVjXykge1xuICAgICAgICAgIC8vIGNvbWJpbmVkXG4gICAgICAgICAgc291cmNlQnVmZmVyLmF1ZGlvRGlzYWJsZWRfID0gZGlzYWJsZUNvbWJpbmVkO1xuICAgICAgICB9IGVsc2UgaWYgKHNvdXJjZUJ1ZmZlci52aWRlb0NvZGVjXyAmJiAhc291cmNlQnVmZmVyLmF1ZGlvQ29kZWNfKSB7XG4gICAgICAgICAgLy8gSWYgdGhlIFwiY29tYmluZWRcIiBzb3VyY2UgYnVmZmVyIGlzIHZpZGVvIG9ubHksIHRoZW4gd2UgZG8gbm90IHdhbnRcbiAgICAgICAgICAvLyBkaXNhYmxlIHRoZSBhdWRpby1vbmx5IHNvdXJjZSBidWZmZXIgKHRoaXMgaXMgbW9zdGx5IGZvciBkZW11eGVkXG4gICAgICAgICAgLy8gYXVkaW8gYW5kIHZpZGVvIGhscylcbiAgICAgICAgICBzb3VyY2VCdWZmZXIuYXVkaW9EaXNhYmxlZF8gPSB0cnVlO1xuICAgICAgICAgIGRpc2FibGVBdWRpb09ubHkgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIGlmICghc291cmNlQnVmZmVyLnZpZGVvQ29kZWNfICYmIHNvdXJjZUJ1ZmZlci5hdWRpb0NvZGVjXykge1xuICAgICAgICAgIC8vIGF1ZGlvIG9ubHlcbiAgICAgICAgICBzb3VyY2VCdWZmZXIuYXVkaW9EaXNhYmxlZF8gPSBkaXNhYmxlQXVkaW9Pbmx5O1xuICAgICAgICAgIGlmIChkaXNhYmxlQXVkaW9Pbmx5KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgX3RoaXMuYWN0aXZlU291cmNlQnVmZmVyc18ucHVzaChzb3VyY2VCdWZmZXIpO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIHRoaXMub25QbGF5ZXJNZWRpYWNoYW5nZV8gPSBmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpcy5zb3VyY2VCdWZmZXJzLmZvckVhY2goZnVuY3Rpb24gKHNvdXJjZUJ1ZmZlcikge1xuICAgICAgICBzb3VyY2VCdWZmZXIuYXBwZW5kQXVkaW9Jbml0U2VnbWVudF8gPSB0cnVlO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIHRoaXMub25IbHNSZXNldF8gPSBmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpcy5zb3VyY2VCdWZmZXJzLmZvckVhY2goZnVuY3Rpb24gKHNvdXJjZUJ1ZmZlcikge1xuICAgICAgICBpZiAoc291cmNlQnVmZmVyLnRyYW5zbXV4ZXJfKSB7XG4gICAgICAgICAgc291cmNlQnVmZmVyLnRyYW5zbXV4ZXJfLnBvc3RNZXNzYWdlKHsgYWN0aW9uOiAncmVzZXRDYXB0aW9ucycgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICB0aGlzLm9uSGxzU2VnbWVudFRpbWVNYXBwaW5nXyA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgX3RoaXMuc291cmNlQnVmZmVycy5mb3JFYWNoKGZ1bmN0aW9uIChidWZmZXIpIHtcbiAgICAgICAgcmV0dXJuIGJ1ZmZlci50aW1lTWFwcGluZ18gPSBldmVudC5tYXBwaW5nO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8vIFJlLWVtaXQgTWVkaWFTb3VyY2UgZXZlbnRzIG9uIHRoZSBwb2x5ZmlsbFxuICAgIFsnc291cmNlb3BlbicsICdzb3VyY2VjbG9zZScsICdzb3VyY2VlbmRlZCddLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50TmFtZSkge1xuICAgICAgdGhpcy5uYXRpdmVNZWRpYVNvdXJjZV8uYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIHRoaXMudHJpZ2dlci5iaW5kKHRoaXMpKTtcbiAgICB9LCB0aGlzKTtcblxuICAgIC8vIGNhcHR1cmUgdGhlIGFzc29jaWF0ZWQgcGxheWVyIHdoZW4gdGhlIE1lZGlhU291cmNlIGlzXG4gICAgLy8gc3VjY2Vzc2Z1bGx5IGF0dGFjaGVkXG4gICAgdGhpcy5vbignc291cmNlb3BlbicsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgLy8gR2V0IHRoZSBwbGF5ZXIgdGhpcyBNZWRpYVNvdXJjZSBpcyBhdHRhY2hlZCB0b1xuICAgICAgdmFyIHZpZGVvID0gX2dsb2JhbERvY3VtZW50MlsnZGVmYXVsdCddLnF1ZXJ5U2VsZWN0b3IoJ1tzcmM9XCInICsgX3RoaXMudXJsXyArICdcIl0nKTtcblxuICAgICAgaWYgKCF2aWRlbykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIF90aGlzLnBsYXllcl8gPSAoMCwgX3ZpZGVvSnMyWydkZWZhdWx0J10pKHZpZGVvLnBhcmVudE5vZGUpO1xuXG4gICAgICAvLyBobHMtcmVzZXQgaXMgZmlyZWQgYnkgdmlkZW9qcy5IbHMgb24gdG8gdGhlIHRlY2ggYWZ0ZXIgdGhlIG1haW4gU2VnbWVudExvYWRlclxuICAgICAgLy8gcmVzZXRzIGl0cyBzdGF0ZSBhbmQgZmx1c2hlcyB0aGUgYnVmZmVyXG4gICAgICBfdGhpcy5wbGF5ZXJfLnRlY2hfLm9uKCdobHMtcmVzZXQnLCBfdGhpcy5vbkhsc1Jlc2V0Xyk7XG4gICAgICAvLyBobHMtc2VnbWVudC10aW1lLW1hcHBpbmcgaXMgZmlyZWQgYnkgdmlkZW9qcy5IbHMgb24gdG8gdGhlIHRlY2ggYWZ0ZXIgdGhlIG1haW5cbiAgICAgIC8vIFNlZ21lbnRMb2FkZXIgaW5zcGVjdHMgYW4gTVRTIHNlZ21lbnQgYW5kIGhhcyBhbiBhY2N1cmF0ZSBzdHJlYW0gdG8gZGlzcGxheVxuICAgICAgLy8gdGltZSBtYXBwaW5nXG4gICAgICBfdGhpcy5wbGF5ZXJfLnRlY2hfLm9uKCdobHMtc2VnbWVudC10aW1lLW1hcHBpbmcnLCBfdGhpcy5vbkhsc1NlZ21lbnRUaW1lTWFwcGluZ18pO1xuXG4gICAgICBpZiAoX3RoaXMucGxheWVyXy5hdWRpb1RyYWNrcyAmJiBfdGhpcy5wbGF5ZXJfLmF1ZGlvVHJhY2tzKCkpIHtcbiAgICAgICAgX3RoaXMucGxheWVyXy5hdWRpb1RyYWNrcygpLm9uKCdjaGFuZ2UnLCBfdGhpcy51cGRhdGVBY3RpdmVTb3VyY2VCdWZmZXJzXyk7XG4gICAgICAgIF90aGlzLnBsYXllcl8uYXVkaW9UcmFja3MoKS5vbignYWRkdHJhY2snLCBfdGhpcy51cGRhdGVBY3RpdmVTb3VyY2VCdWZmZXJzXyk7XG4gICAgICAgIF90aGlzLnBsYXllcl8uYXVkaW9UcmFja3MoKS5vbigncmVtb3ZldHJhY2snLCBfdGhpcy51cGRhdGVBY3RpdmVTb3VyY2VCdWZmZXJzXyk7XG4gICAgICB9XG5cbiAgICAgIF90aGlzLnBsYXllcl8ub24oJ21lZGlhY2hhbmdlJywgX3RoaXMub25QbGF5ZXJNZWRpYWNoYW5nZV8pO1xuICAgIH0pO1xuXG4gICAgdGhpcy5vbignc291cmNlZW5kZWQnLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIHZhciBkdXJhdGlvbiA9ICgwLCBfYWRkVGV4dFRyYWNrRGF0YS5kdXJhdGlvbk9mVmlkZW8pKF90aGlzLmR1cmF0aW9uKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBfdGhpcy5zb3VyY2VCdWZmZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBzb3VyY2VidWZmZXIgPSBfdGhpcy5zb3VyY2VCdWZmZXJzW2ldO1xuICAgICAgICB2YXIgY3VlcyA9IHNvdXJjZWJ1ZmZlci5tZXRhZGF0YVRyYWNrXyAmJiBzb3VyY2VidWZmZXIubWV0YWRhdGFUcmFja18uY3VlcztcblxuICAgICAgICBpZiAoY3VlcyAmJiBjdWVzLmxlbmd0aCkge1xuICAgICAgICAgIGN1ZXNbY3Vlcy5sZW5ndGggLSAxXS5lbmRUaW1lID0gZHVyYXRpb247XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIGV4cGxpY2l0bHkgdGVybWluYXRlIGFueSBXZWJXb3JrZXJzIHRoYXQgd2VyZSBjcmVhdGVkXG4gICAgLy8gYnkgU291cmNlSGFuZGxlcnNcbiAgICB0aGlzLm9uKCdzb3VyY2VjbG9zZScsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgdGhpcy5zb3VyY2VCdWZmZXJzLmZvckVhY2goZnVuY3Rpb24gKHNvdXJjZUJ1ZmZlcikge1xuICAgICAgICBpZiAoc291cmNlQnVmZmVyLnRyYW5zbXV4ZXJfKSB7XG4gICAgICAgICAgc291cmNlQnVmZmVyLnRyYW5zbXV4ZXJfLnRlcm1pbmF0ZSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgdGhpcy5zb3VyY2VCdWZmZXJzLmxlbmd0aCA9IDA7XG4gICAgICBpZiAoIXRoaXMucGxheWVyXykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnBsYXllcl8uYXVkaW9UcmFja3MgJiYgdGhpcy5wbGF5ZXJfLmF1ZGlvVHJhY2tzKCkpIHtcbiAgICAgICAgdGhpcy5wbGF5ZXJfLmF1ZGlvVHJhY2tzKCkub2ZmKCdjaGFuZ2UnLCB0aGlzLnVwZGF0ZUFjdGl2ZVNvdXJjZUJ1ZmZlcnNfKTtcbiAgICAgICAgdGhpcy5wbGF5ZXJfLmF1ZGlvVHJhY2tzKCkub2ZmKCdhZGR0cmFjaycsIHRoaXMudXBkYXRlQWN0aXZlU291cmNlQnVmZmVyc18pO1xuICAgICAgICB0aGlzLnBsYXllcl8uYXVkaW9UcmFja3MoKS5vZmYoJ3JlbW92ZXRyYWNrJywgdGhpcy51cGRhdGVBY3RpdmVTb3VyY2VCdWZmZXJzXyk7XG4gICAgICB9XG5cbiAgICAgIC8vIFdlIGNhbiBvbmx5IGNoYW5nZSB0aGlzIGlmIHRoZSBwbGF5ZXIgaGFzbid0IGJlZW4gZGlzcG9zZWQgb2YgeWV0XG4gICAgICAvLyBiZWNhdXNlIGBvZmZgIGV2ZW50dWFsbHkgdHJpZXMgdG8gdXNlIHRoZSBlbF8gcHJvcGVydHkuIElmIGl0IGhhc1xuICAgICAgLy8gYmVlbiBkaXNwb3NlZCBvZiwgdGhlbiBkb24ndCB3b3JyeSBhYm91dCBpdCBiZWNhdXNlIHRoZXJlIGFyZSBub1xuICAgICAgLy8gZXZlbnQgaGFuZGxlcnMgbGVmdCB0byB1bmJpbmQgYW55d2F5XG4gICAgICBpZiAodGhpcy5wbGF5ZXJfLmVsXykge1xuICAgICAgICB0aGlzLnBsYXllcl8ub2ZmKCdtZWRpYWNoYW5nZScsIHRoaXMub25QbGF5ZXJNZWRpYWNoYW5nZV8pO1xuICAgICAgICB0aGlzLnBsYXllcl8udGVjaF8ub2ZmKCdobHMtcmVzZXQnLCB0aGlzLm9uSGxzUmVzZXRfKTtcbiAgICAgICAgdGhpcy5wbGF5ZXJfLnRlY2hfLm9mZignaGxzLXNlZ21lbnQtdGltZS1tYXBwaW5nJywgdGhpcy5vbkhsc1NlZ21lbnRUaW1lTWFwcGluZ18pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhIHJhbmdlIHRoYXQgdGhhdCBjYW4gbm93IGJlIHNlZWtlZCB0by5cbiAgICpcbiAgICogQHBhcmFtIHtEb3VibGV9IHN0YXJ0IHdoZXJlIHRvIHN0YXJ0IHRoZSBhZGRpdGlvblxuICAgKiBAcGFyYW0ge0RvdWJsZX0gZW5kIHdoZXJlIHRvIGVuZCB0aGUgYWRkaXRpb25cbiAgICogQHByaXZhdGVcbiAgICovXG5cbiAgX2NyZWF0ZUNsYXNzKEh0bWxNZWRpYVNvdXJjZSwgW3tcbiAgICBrZXk6ICdhZGRTZWVrYWJsZVJhbmdlXycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZFNlZWthYmxlUmFuZ2VfKHN0YXJ0LCBlbmQpIHtcbiAgICAgIHZhciBlcnJvciA9IHVuZGVmaW5lZDtcblxuICAgICAgaWYgKHRoaXMuZHVyYXRpb24gIT09IEluZmluaXR5KSB7XG4gICAgICAgIGVycm9yID0gbmV3IEVycm9yKCdNZWRpYVNvdXJjZS5hZGRTZWVrYWJsZVJhbmdlKCkgY2FuIG9ubHkgYmUgaW52b2tlZCAnICsgJ3doZW4gdGhlIGR1cmF0aW9uIGlzIEluZmluaXR5Jyk7XG4gICAgICAgIGVycm9yLm5hbWUgPSAnSW52YWxpZFN0YXRlRXJyb3InO1xuICAgICAgICBlcnJvci5jb2RlID0gMTE7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuXG4gICAgICBpZiAoZW5kID4gdGhpcy5uYXRpdmVNZWRpYVNvdXJjZV8uZHVyYXRpb24gfHwgaXNOYU4odGhpcy5uYXRpdmVNZWRpYVNvdXJjZV8uZHVyYXRpb24pKSB7XG4gICAgICAgIHRoaXMubmF0aXZlTWVkaWFTb3VyY2VfLmR1cmF0aW9uID0gZW5kO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZCBhIHNvdXJjZSBidWZmZXIgdG8gdGhlIG1lZGlhIHNvdXJjZS5cbiAgICAgKlxuICAgICAqIEBsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9NZWRpYVNvdXJjZS9hZGRTb3VyY2VCdWZmZXJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSB0aGUgY29udGVudC10eXBlIG9mIHRoZSBjb250ZW50XG4gICAgICogQHJldHVybiB7T2JqZWN0fSB0aGUgY3JlYXRlZCBzb3VyY2UgYnVmZmVyXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdhZGRTb3VyY2VCdWZmZXInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRTb3VyY2VCdWZmZXIodHlwZSkge1xuICAgICAgdmFyIGJ1ZmZlciA9IHVuZGVmaW5lZDtcbiAgICAgIHZhciBwYXJzZWRUeXBlID0gKDAsIF9jb2RlY1V0aWxzLnBhcnNlQ29udGVudFR5cGUpKHR5cGUpO1xuXG4gICAgICAvLyBDcmVhdGUgYSBWaXJ0dWFsU291cmNlQnVmZmVyIHRvIHRyYW5zbXV4IE1QRUctMiB0cmFuc3BvcnRcbiAgICAgIC8vIHN0cmVhbSBzZWdtZW50cyBpbnRvIGZyYWdtZW50ZWQgTVA0c1xuICAgICAgaWYgKC9eKHZpZGVvfGF1ZGlvKVxcL21wMnQkL2kudGVzdChwYXJzZWRUeXBlLnR5cGUpKSB7XG4gICAgICAgIHZhciBjb2RlY3MgPSBbXTtcblxuICAgICAgICBpZiAocGFyc2VkVHlwZS5wYXJhbWV0ZXJzICYmIHBhcnNlZFR5cGUucGFyYW1ldGVycy5jb2RlY3MpIHtcbiAgICAgICAgICBjb2RlY3MgPSBwYXJzZWRUeXBlLnBhcmFtZXRlcnMuY29kZWNzLnNwbGl0KCcsJyk7XG4gICAgICAgICAgY29kZWNzID0gKDAsIF9jb2RlY1V0aWxzLnRyYW5zbGF0ZUxlZ2FjeUNvZGVjcykoY29kZWNzKTtcbiAgICAgICAgICBjb2RlY3MgPSBjb2RlY3MuZmlsdGVyKGZ1bmN0aW9uIChjb2RlYykge1xuICAgICAgICAgICAgcmV0dXJuICgwLCBfY29kZWNVdGlscy5pc0F1ZGlvQ29kZWMpKGNvZGVjKSB8fCAoMCwgX2NvZGVjVXRpbHMuaXNWaWRlb0NvZGVjKShjb2RlYyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29kZWNzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIGNvZGVjcyA9IFsnYXZjMS40ZDQwMGQnLCAnbXA0YS40MC4yJ107XG4gICAgICAgIH1cblxuICAgICAgICBidWZmZXIgPSBuZXcgX3ZpcnR1YWxTb3VyY2VCdWZmZXIyWydkZWZhdWx0J10odGhpcywgY29kZWNzKTtcblxuICAgICAgICBpZiAodGhpcy5zb3VyY2VCdWZmZXJzLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgIC8vIElmIGFub3RoZXIgVmlydHVhbFNvdXJjZUJ1ZmZlciBhbHJlYWR5IGV4aXN0cywgdGhlbiB3ZSBhcmUgY3JlYXRpbmcgYVxuICAgICAgICAgIC8vIFNvdXJjZUJ1ZmZlciBmb3IgYW4gYWx0ZXJuYXRlIGF1ZGlvIHRyYWNrIGFuZCB0aGVyZWZvcmUgd2Uga25vdyB0aGF0XG4gICAgICAgICAgLy8gdGhlIHNvdXJjZSBoYXMgYm90aCBhbiBhdWRpbyBhbmQgdmlkZW8gdHJhY2suXG4gICAgICAgICAgLy8gVGhhdCBtZWFucyB3ZSBzaG91bGQgdHJpZ2dlciB0aGUgbWFudWFsIGNyZWF0aW9uIG9mIHRoZSByZWFsXG4gICAgICAgICAgLy8gU291cmNlQnVmZmVycyBpbnN0ZWFkIG9mIHdhaXRpbmcgZm9yIHRoZSB0cmFuc211eGVyIHRvIHJldHVybiBkYXRhXG4gICAgICAgICAgdGhpcy5zb3VyY2VCdWZmZXJzWzBdLmNyZWF0ZVJlYWxTb3VyY2VCdWZmZXJzXygpO1xuICAgICAgICAgIGJ1ZmZlci5jcmVhdGVSZWFsU291cmNlQnVmZmVyc18oKTtcblxuICAgICAgICAgIC8vIEF1dG9tYXRpY2FsbHkgZGlzYWJsZSB0aGUgYXVkaW8gb24gdGhlIGZpcnN0IHNvdXJjZSBidWZmZXIgaWZcbiAgICAgICAgICAvLyBhIHNlY29uZCBzb3VyY2UgYnVmZmVyIGlzIGV2ZXIgY3JlYXRlZFxuICAgICAgICAgIHRoaXMuc291cmNlQnVmZmVyc1swXS5hdWRpb0Rpc2FibGVkXyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGRlbGVnYXRlIHRvIHRoZSBuYXRpdmUgaW1wbGVtZW50YXRpb25cbiAgICAgICAgYnVmZmVyID0gdGhpcy5uYXRpdmVNZWRpYVNvdXJjZV8uYWRkU291cmNlQnVmZmVyKHR5cGUpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnNvdXJjZUJ1ZmZlcnMucHVzaChidWZmZXIpO1xuICAgICAgcmV0dXJuIGJ1ZmZlcjtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gSHRtbE1lZGlhU291cmNlO1xufSkoX3ZpZGVvSnMyWydkZWZhdWx0J10uRXZlbnRUYXJnZXQpO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBIdG1sTWVkaWFTb3VyY2U7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/videojs-contrib-media-sources/es5/html-media-source.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/videojs-contrib-media-sources/es5/remove-cues-from-track.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/videojs-contrib-media-sources/es5/remove-cues-from-track.js ***!
  \**********************************************************************************/
/***/ ((module, exports) => {

"use strict";
eval("/**\n * @file remove-cues-from-track.js\n */\n\n/**\n * Remove cues from a track on video.js.\n *\n * @param {Double} start start of where we should remove the cue\n * @param {Double} end end of where the we should remove the cue\n * @param {Object} track the text track to remove the cues from\n * @private\n */\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nvar removeCuesFromTrack = function removeCuesFromTrack(start, end, track) {\n  var i = undefined;\n  var cue = undefined;\n\n  if (!track) {\n    return;\n  }\n\n  if (!track.cues) {\n    return;\n  }\n\n  i = track.cues.length;\n\n  while (i--) {\n    cue = track.cues[i];\n\n    // Remove any overlapping cue\n    if (cue.startTime <= end && cue.endTime >= start) {\n      track.removeCue(cue);\n    }\n  }\n};\n\nexports[\"default\"] = removeCuesFromTrack;\nmodule.exports = exports[\"default\"];//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdmlkZW9qcy1jb250cmliLW1lZGlhLXNvdXJjZXMvZXM1L3JlbW92ZS1jdWVzLWZyb20tdHJhY2suanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDYTs7QUFFYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0I7QUFDbEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS12MC1wcm9qZWN0Ly4vbm9kZV9tb2R1bGVzL3ZpZGVvanMtY29udHJpYi1tZWRpYS1zb3VyY2VzL2VzNS9yZW1vdmUtY3Vlcy1mcm9tLXRyYWNrLmpzP2U0N2YiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAZmlsZSByZW1vdmUtY3Vlcy1mcm9tLXRyYWNrLmpzXG4gKi9cblxuLyoqXG4gKiBSZW1vdmUgY3VlcyBmcm9tIGEgdHJhY2sgb24gdmlkZW8uanMuXG4gKlxuICogQHBhcmFtIHtEb3VibGV9IHN0YXJ0IHN0YXJ0IG9mIHdoZXJlIHdlIHNob3VsZCByZW1vdmUgdGhlIGN1ZVxuICogQHBhcmFtIHtEb3VibGV9IGVuZCBlbmQgb2Ygd2hlcmUgdGhlIHdlIHNob3VsZCByZW1vdmUgdGhlIGN1ZVxuICogQHBhcmFtIHtPYmplY3R9IHRyYWNrIHRoZSB0ZXh0IHRyYWNrIHRvIHJlbW92ZSB0aGUgY3VlcyBmcm9tXG4gKiBAcHJpdmF0ZVxuICovXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbnZhciByZW1vdmVDdWVzRnJvbVRyYWNrID0gZnVuY3Rpb24gcmVtb3ZlQ3Vlc0Zyb21UcmFjayhzdGFydCwgZW5kLCB0cmFjaykge1xuICB2YXIgaSA9IHVuZGVmaW5lZDtcbiAgdmFyIGN1ZSA9IHVuZGVmaW5lZDtcblxuICBpZiAoIXRyYWNrKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKCF0cmFjay5jdWVzKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaSA9IHRyYWNrLmN1ZXMubGVuZ3RoO1xuXG4gIHdoaWxlIChpLS0pIHtcbiAgICBjdWUgPSB0cmFjay5jdWVzW2ldO1xuXG4gICAgLy8gUmVtb3ZlIGFueSBvdmVybGFwcGluZyBjdWVcbiAgICBpZiAoY3VlLnN0YXJ0VGltZSA8PSBlbmQgJiYgY3VlLmVuZFRpbWUgPj0gc3RhcnQpIHtcbiAgICAgIHRyYWNrLnJlbW92ZUN1ZShjdWUpO1xuICAgIH1cbiAgfVxufTtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSByZW1vdmVDdWVzRnJvbVRyYWNrO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzW1wiZGVmYXVsdFwiXTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/videojs-contrib-media-sources/es5/remove-cues-from-track.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/videojs-contrib-media-sources/es5/transmuxer-worker.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/videojs-contrib-media-sources/es5/transmuxer-worker.js ***!
  \*****************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("/**\n * @file transmuxer-worker.js\n */\n\n/**\n * videojs-contrib-media-sources\n *\n * Copyright (c) 2015 Brightcove\n * All rights reserved.\n *\n * Handles communication between the browser-world and the mux.js\n * transmuxer running inside of a WebWorker by exposing a simple\n * message-based interface to a Transmuxer object.\n */\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nvar _globalWindow = __webpack_require__(/*! global/window */ \"(ssr)/./node_modules/videojs-contrib-media-sources/node_modules/global/window.js\");\n\nvar _globalWindow2 = _interopRequireDefault(_globalWindow);\n\nvar _muxJsLibMp4 = __webpack_require__(/*! mux.js/lib/mp4 */ \"(ssr)/./node_modules/videojs-contrib-media-sources/node_modules/mux.js/lib/mp4/index.js\");\n\nvar _muxJsLibMp42 = _interopRequireDefault(_muxJsLibMp4);\n\n/**\n * Re-emits transmuxer events by converting them into messages to the\n * world outside the worker.\n *\n * @param {Object} transmuxer the transmuxer to wire events on\n * @private\n */\nvar wireTransmuxerEvents = function wireTransmuxerEvents(transmuxer) {\n  transmuxer.on('data', function (segment) {\n    // transfer ownership of the underlying ArrayBuffer\n    // instead of doing a copy to save memory\n    // ArrayBuffers are transferable but generic TypedArrays are not\n    // @link https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers#Passing_data_by_transferring_ownership_(transferable_objects)\n    var initArray = segment.initSegment;\n\n    segment.initSegment = {\n      data: initArray.buffer,\n      byteOffset: initArray.byteOffset,\n      byteLength: initArray.byteLength\n    };\n\n    var typedArray = segment.data;\n\n    segment.data = typedArray.buffer;\n    _globalWindow2['default'].postMessage({\n      action: 'data',\n      segment: segment,\n      byteOffset: typedArray.byteOffset,\n      byteLength: typedArray.byteLength\n    }, [segment.data]);\n  });\n\n  if (transmuxer.captionStream) {\n    transmuxer.captionStream.on('data', function (caption) {\n      _globalWindow2['default'].postMessage({\n        action: 'caption',\n        data: caption\n      });\n    });\n  }\n\n  transmuxer.on('done', function (data) {\n    _globalWindow2['default'].postMessage({ action: 'done' });\n  });\n\n  transmuxer.on('gopInfo', function (gopInfo) {\n    _globalWindow2['default'].postMessage({\n      action: 'gopInfo',\n      gopInfo: gopInfo\n    });\n  });\n};\n\n/**\n * All incoming messages route through this hash. If no function exists\n * to handle an incoming message, then we ignore the message.\n *\n * @class MessageHandlers\n * @param {Object} options the options to initialize with\n */\n\nvar MessageHandlers = (function () {\n  function MessageHandlers(options) {\n    _classCallCheck(this, MessageHandlers);\n\n    this.options = options || {};\n    this.init();\n  }\n\n  /**\n   * Our web wroker interface so that things can talk to mux.js\n   * that will be running in a web worker. the scope is passed to this by\n   * webworkify.\n   *\n   * @param {Object} self the scope for the web worker\n   */\n\n  /**\n   * initialize our web worker and wire all the events.\n   */\n\n  _createClass(MessageHandlers, [{\n    key: 'init',\n    value: function init() {\n      if (this.transmuxer) {\n        this.transmuxer.dispose();\n      }\n      this.transmuxer = new _muxJsLibMp42['default'].Transmuxer(this.options);\n      wireTransmuxerEvents(this.transmuxer);\n    }\n\n    /**\n     * Adds data (a ts segment) to the start of the transmuxer pipeline for\n     * processing.\n     *\n     * @param {ArrayBuffer} data data to push into the muxer\n     */\n  }, {\n    key: 'push',\n    value: function push(data) {\n      // Cast array buffer to correct type for transmuxer\n      var segment = new Uint8Array(data.data, data.byteOffset, data.byteLength);\n\n      this.transmuxer.push(segment);\n    }\n\n    /**\n     * Recreate the transmuxer so that the next segment added via `push`\n     * start with a fresh transmuxer.\n     */\n  }, {\n    key: 'reset',\n    value: function reset() {\n      this.init();\n    }\n\n    /**\n     * Set the value that will be used as the `baseMediaDecodeTime` time for the\n     * next segment pushed in. Subsequent segments will have their `baseMediaDecodeTime`\n     * set relative to the first based on the PTS values.\n     *\n     * @param {Object} data used to set the timestamp offset in the muxer\n     */\n  }, {\n    key: 'setTimestampOffset',\n    value: function setTimestampOffset(data) {\n      var timestampOffset = data.timestampOffset || 0;\n\n      this.transmuxer.setBaseMediaDecodeTime(Math.round(timestampOffset * 90000));\n    }\n  }, {\n    key: 'setAudioAppendStart',\n    value: function setAudioAppendStart(data) {\n      this.transmuxer.setAudioAppendStart(Math.ceil(data.appendStart * 90000));\n    }\n\n    /**\n     * Forces the pipeline to finish processing the last segment and emit it's\n     * results.\n     *\n     * @param {Object} data event data, not really used\n     */\n  }, {\n    key: 'flush',\n    value: function flush(data) {\n      this.transmuxer.flush();\n    }\n  }, {\n    key: 'resetCaptions',\n    value: function resetCaptions() {\n      this.transmuxer.resetCaptions();\n    }\n  }, {\n    key: 'alignGopsWith',\n    value: function alignGopsWith(data) {\n      this.transmuxer.alignGopsWith(data.gopsToAlignWith.slice());\n    }\n  }]);\n\n  return MessageHandlers;\n})();\n\nvar TransmuxerWorker = function TransmuxerWorker(self) {\n  self.onmessage = function (event) {\n    if (event.data.action === 'init' && event.data.options) {\n      this.messageHandlers = new MessageHandlers(event.data.options);\n      return;\n    }\n\n    if (!this.messageHandlers) {\n      this.messageHandlers = new MessageHandlers();\n    }\n\n    if (event.data && event.data.action && event.data.action !== 'init') {\n      if (this.messageHandlers[event.data.action]) {\n        this.messageHandlers[event.data.action](event.data);\n      }\n    }\n  };\n};\n\nexports[\"default\"] = function (self) {\n  return new TransmuxerWorker(self);\n};\n\nmodule.exports = exports['default'];//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdmlkZW9qcy1jb250cmliLW1lZGlhLXNvdXJjZXMvZXM1L3RyYW5zbXV4ZXItd29ya2VyLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNhOztBQUViLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQzs7QUFFRixrQ0FBa0MsMkNBQTJDLGdCQUFnQixrQkFBa0IsT0FBTywyQkFBMkIsd0RBQXdELGdDQUFnQyx1REFBdUQsK0RBQStELHlEQUF5RCxxRUFBcUUsNkRBQTZELHdCQUF3Qjs7QUFFbGpCLHVDQUF1Qyx1Q0FBdUM7O0FBRTlFLGtEQUFrRCwwQ0FBMEM7O0FBRTVGLG9CQUFvQixtQkFBTyxDQUFDLHVHQUFlOztBQUUzQzs7QUFFQSxtQkFBbUIsbUJBQU8sQ0FBQywrR0FBZ0I7O0FBRTNDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMOztBQUVBO0FBQ0EsNENBQTRDLGdCQUFnQjtBQUM1RCxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25COztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxhQUFhO0FBQzVCO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS12MC1wcm9qZWN0Ly4vbm9kZV9tb2R1bGVzL3ZpZGVvanMtY29udHJpYi1tZWRpYS1zb3VyY2VzL2VzNS90cmFuc211eGVyLXdvcmtlci5qcz8wMGM2Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGZpbGUgdHJhbnNtdXhlci13b3JrZXIuanNcbiAqL1xuXG4vKipcbiAqIHZpZGVvanMtY29udHJpYi1tZWRpYS1zb3VyY2VzXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE1IEJyaWdodGNvdmVcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogSGFuZGxlcyBjb21tdW5pY2F0aW9uIGJldHdlZW4gdGhlIGJyb3dzZXItd29ybGQgYW5kIHRoZSBtdXguanNcbiAqIHRyYW5zbXV4ZXIgcnVubmluZyBpbnNpZGUgb2YgYSBXZWJXb3JrZXIgYnkgZXhwb3NpbmcgYSBzaW1wbGVcbiAqIG1lc3NhZ2UtYmFzZWQgaW50ZXJmYWNlIHRvIGEgVHJhbnNtdXhlciBvYmplY3QuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSAoZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKCd2YWx1ZScgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0pKCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb24nKTsgfSB9XG5cbnZhciBfZ2xvYmFsV2luZG93ID0gcmVxdWlyZSgnZ2xvYmFsL3dpbmRvdycpO1xuXG52YXIgX2dsb2JhbFdpbmRvdzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9nbG9iYWxXaW5kb3cpO1xuXG52YXIgX211eEpzTGliTXA0ID0gcmVxdWlyZSgnbXV4LmpzL2xpYi9tcDQnKTtcblxudmFyIF9tdXhKc0xpYk1wNDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9tdXhKc0xpYk1wNCk7XG5cbi8qKlxuICogUmUtZW1pdHMgdHJhbnNtdXhlciBldmVudHMgYnkgY29udmVydGluZyB0aGVtIGludG8gbWVzc2FnZXMgdG8gdGhlXG4gKiB3b3JsZCBvdXRzaWRlIHRoZSB3b3JrZXIuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHRyYW5zbXV4ZXIgdGhlIHRyYW5zbXV4ZXIgdG8gd2lyZSBldmVudHMgb25cbiAqIEBwcml2YXRlXG4gKi9cbnZhciB3aXJlVHJhbnNtdXhlckV2ZW50cyA9IGZ1bmN0aW9uIHdpcmVUcmFuc211eGVyRXZlbnRzKHRyYW5zbXV4ZXIpIHtcbiAgdHJhbnNtdXhlci5vbignZGF0YScsIGZ1bmN0aW9uIChzZWdtZW50KSB7XG4gICAgLy8gdHJhbnNmZXIgb3duZXJzaGlwIG9mIHRoZSB1bmRlcmx5aW5nIEFycmF5QnVmZmVyXG4gICAgLy8gaW5zdGVhZCBvZiBkb2luZyBhIGNvcHkgdG8gc2F2ZSBtZW1vcnlcbiAgICAvLyBBcnJheUJ1ZmZlcnMgYXJlIHRyYW5zZmVyYWJsZSBidXQgZ2VuZXJpYyBUeXBlZEFycmF5cyBhcmUgbm90XG4gICAgLy8gQGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1dlYl9Xb3JrZXJzX0FQSS9Vc2luZ193ZWJfd29ya2VycyNQYXNzaW5nX2RhdGFfYnlfdHJhbnNmZXJyaW5nX293bmVyc2hpcF8odHJhbnNmZXJhYmxlX29iamVjdHMpXG4gICAgdmFyIGluaXRBcnJheSA9IHNlZ21lbnQuaW5pdFNlZ21lbnQ7XG5cbiAgICBzZWdtZW50LmluaXRTZWdtZW50ID0ge1xuICAgICAgZGF0YTogaW5pdEFycmF5LmJ1ZmZlcixcbiAgICAgIGJ5dGVPZmZzZXQ6IGluaXRBcnJheS5ieXRlT2Zmc2V0LFxuICAgICAgYnl0ZUxlbmd0aDogaW5pdEFycmF5LmJ5dGVMZW5ndGhcbiAgICB9O1xuXG4gICAgdmFyIHR5cGVkQXJyYXkgPSBzZWdtZW50LmRhdGE7XG5cbiAgICBzZWdtZW50LmRhdGEgPSB0eXBlZEFycmF5LmJ1ZmZlcjtcbiAgICBfZ2xvYmFsV2luZG93MlsnZGVmYXVsdCddLnBvc3RNZXNzYWdlKHtcbiAgICAgIGFjdGlvbjogJ2RhdGEnLFxuICAgICAgc2VnbWVudDogc2VnbWVudCxcbiAgICAgIGJ5dGVPZmZzZXQ6IHR5cGVkQXJyYXkuYnl0ZU9mZnNldCxcbiAgICAgIGJ5dGVMZW5ndGg6IHR5cGVkQXJyYXkuYnl0ZUxlbmd0aFxuICAgIH0sIFtzZWdtZW50LmRhdGFdKTtcbiAgfSk7XG5cbiAgaWYgKHRyYW5zbXV4ZXIuY2FwdGlvblN0cmVhbSkge1xuICAgIHRyYW5zbXV4ZXIuY2FwdGlvblN0cmVhbS5vbignZGF0YScsIGZ1bmN0aW9uIChjYXB0aW9uKSB7XG4gICAgICBfZ2xvYmFsV2luZG93MlsnZGVmYXVsdCddLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgYWN0aW9uOiAnY2FwdGlvbicsXG4gICAgICAgIGRhdGE6IGNhcHRpb25cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgdHJhbnNtdXhlci5vbignZG9uZScsIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgX2dsb2JhbFdpbmRvdzJbJ2RlZmF1bHQnXS5wb3N0TWVzc2FnZSh7IGFjdGlvbjogJ2RvbmUnIH0pO1xuICB9KTtcblxuICB0cmFuc211eGVyLm9uKCdnb3BJbmZvJywgZnVuY3Rpb24gKGdvcEluZm8pIHtcbiAgICBfZ2xvYmFsV2luZG93MlsnZGVmYXVsdCddLnBvc3RNZXNzYWdlKHtcbiAgICAgIGFjdGlvbjogJ2dvcEluZm8nLFxuICAgICAgZ29wSW5mbzogZ29wSW5mb1xuICAgIH0pO1xuICB9KTtcbn07XG5cbi8qKlxuICogQWxsIGluY29taW5nIG1lc3NhZ2VzIHJvdXRlIHRocm91Z2ggdGhpcyBoYXNoLiBJZiBubyBmdW5jdGlvbiBleGlzdHNcbiAqIHRvIGhhbmRsZSBhbiBpbmNvbWluZyBtZXNzYWdlLCB0aGVuIHdlIGlnbm9yZSB0aGUgbWVzc2FnZS5cbiAqXG4gKiBAY2xhc3MgTWVzc2FnZUhhbmRsZXJzXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyB0aGUgb3B0aW9ucyB0byBpbml0aWFsaXplIHdpdGhcbiAqL1xuXG52YXIgTWVzc2FnZUhhbmRsZXJzID0gKGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gTWVzc2FnZUhhbmRsZXJzKG9wdGlvbnMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTWVzc2FnZUhhbmRsZXJzKTtcblxuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgdGhpcy5pbml0KCk7XG4gIH1cblxuICAvKipcbiAgICogT3VyIHdlYiB3cm9rZXIgaW50ZXJmYWNlIHNvIHRoYXQgdGhpbmdzIGNhbiB0YWxrIHRvIG11eC5qc1xuICAgKiB0aGF0IHdpbGwgYmUgcnVubmluZyBpbiBhIHdlYiB3b3JrZXIuIHRoZSBzY29wZSBpcyBwYXNzZWQgdG8gdGhpcyBieVxuICAgKiB3ZWJ3b3JraWZ5LlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gc2VsZiB0aGUgc2NvcGUgZm9yIHRoZSB3ZWIgd29ya2VyXG4gICAqL1xuXG4gIC8qKlxuICAgKiBpbml0aWFsaXplIG91ciB3ZWIgd29ya2VyIGFuZCB3aXJlIGFsbCB0aGUgZXZlbnRzLlxuICAgKi9cblxuICBfY3JlYXRlQ2xhc3MoTWVzc2FnZUhhbmRsZXJzLCBbe1xuICAgIGtleTogJ2luaXQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0KCkge1xuICAgICAgaWYgKHRoaXMudHJhbnNtdXhlcikge1xuICAgICAgICB0aGlzLnRyYW5zbXV4ZXIuZGlzcG9zZSgpO1xuICAgICAgfVxuICAgICAgdGhpcy50cmFuc211eGVyID0gbmV3IF9tdXhKc0xpYk1wNDJbJ2RlZmF1bHQnXS5UcmFuc211eGVyKHRoaXMub3B0aW9ucyk7XG4gICAgICB3aXJlVHJhbnNtdXhlckV2ZW50cyh0aGlzLnRyYW5zbXV4ZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZHMgZGF0YSAoYSB0cyBzZWdtZW50KSB0byB0aGUgc3RhcnQgb2YgdGhlIHRyYW5zbXV4ZXIgcGlwZWxpbmUgZm9yXG4gICAgICogcHJvY2Vzc2luZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGRhdGEgZGF0YSB0byBwdXNoIGludG8gdGhlIG11eGVyXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdwdXNoJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHVzaChkYXRhKSB7XG4gICAgICAvLyBDYXN0IGFycmF5IGJ1ZmZlciB0byBjb3JyZWN0IHR5cGUgZm9yIHRyYW5zbXV4ZXJcbiAgICAgIHZhciBzZWdtZW50ID0gbmV3IFVpbnQ4QXJyYXkoZGF0YS5kYXRhLCBkYXRhLmJ5dGVPZmZzZXQsIGRhdGEuYnl0ZUxlbmd0aCk7XG5cbiAgICAgIHRoaXMudHJhbnNtdXhlci5wdXNoKHNlZ21lbnQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlY3JlYXRlIHRoZSB0cmFuc211eGVyIHNvIHRoYXQgdGhlIG5leHQgc2VnbWVudCBhZGRlZCB2aWEgYHB1c2hgXG4gICAgICogc3RhcnQgd2l0aCBhIGZyZXNoIHRyYW5zbXV4ZXIuXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdyZXNldCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgICAgdGhpcy5pbml0KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IHRoZSB2YWx1ZSB0aGF0IHdpbGwgYmUgdXNlZCBhcyB0aGUgYGJhc2VNZWRpYURlY29kZVRpbWVgIHRpbWUgZm9yIHRoZVxuICAgICAqIG5leHQgc2VnbWVudCBwdXNoZWQgaW4uIFN1YnNlcXVlbnQgc2VnbWVudHMgd2lsbCBoYXZlIHRoZWlyIGBiYXNlTWVkaWFEZWNvZGVUaW1lYFxuICAgICAqIHNldCByZWxhdGl2ZSB0byB0aGUgZmlyc3QgYmFzZWQgb24gdGhlIFBUUyB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSB1c2VkIHRvIHNldCB0aGUgdGltZXN0YW1wIG9mZnNldCBpbiB0aGUgbXV4ZXJcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ3NldFRpbWVzdGFtcE9mZnNldCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFRpbWVzdGFtcE9mZnNldChkYXRhKSB7XG4gICAgICB2YXIgdGltZXN0YW1wT2Zmc2V0ID0gZGF0YS50aW1lc3RhbXBPZmZzZXQgfHwgMDtcblxuICAgICAgdGhpcy50cmFuc211eGVyLnNldEJhc2VNZWRpYURlY29kZVRpbWUoTWF0aC5yb3VuZCh0aW1lc3RhbXBPZmZzZXQgKiA5MDAwMCkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3NldEF1ZGlvQXBwZW5kU3RhcnQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRBdWRpb0FwcGVuZFN0YXJ0KGRhdGEpIHtcbiAgICAgIHRoaXMudHJhbnNtdXhlci5zZXRBdWRpb0FwcGVuZFN0YXJ0KE1hdGguY2VpbChkYXRhLmFwcGVuZFN0YXJ0ICogOTAwMDApKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGb3JjZXMgdGhlIHBpcGVsaW5lIHRvIGZpbmlzaCBwcm9jZXNzaW5nIHRoZSBsYXN0IHNlZ21lbnQgYW5kIGVtaXQgaXQnc1xuICAgICAqIHJlc3VsdHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSBldmVudCBkYXRhLCBub3QgcmVhbGx5IHVzZWRcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ2ZsdXNoJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZmx1c2goZGF0YSkge1xuICAgICAgdGhpcy50cmFuc211eGVyLmZsdXNoKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAncmVzZXRDYXB0aW9ucycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlc2V0Q2FwdGlvbnMoKSB7XG4gICAgICB0aGlzLnRyYW5zbXV4ZXIucmVzZXRDYXB0aW9ucygpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2FsaWduR29wc1dpdGgnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhbGlnbkdvcHNXaXRoKGRhdGEpIHtcbiAgICAgIHRoaXMudHJhbnNtdXhlci5hbGlnbkdvcHNXaXRoKGRhdGEuZ29wc1RvQWxpZ25XaXRoLnNsaWNlKCkpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBNZXNzYWdlSGFuZGxlcnM7XG59KSgpO1xuXG52YXIgVHJhbnNtdXhlcldvcmtlciA9IGZ1bmN0aW9uIFRyYW5zbXV4ZXJXb3JrZXIoc2VsZikge1xuICBzZWxmLm9ubWVzc2FnZSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIGlmIChldmVudC5kYXRhLmFjdGlvbiA9PT0gJ2luaXQnICYmIGV2ZW50LmRhdGEub3B0aW9ucykge1xuICAgICAgdGhpcy5tZXNzYWdlSGFuZGxlcnMgPSBuZXcgTWVzc2FnZUhhbmRsZXJzKGV2ZW50LmRhdGEub3B0aW9ucyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLm1lc3NhZ2VIYW5kbGVycykge1xuICAgICAgdGhpcy5tZXNzYWdlSGFuZGxlcnMgPSBuZXcgTWVzc2FnZUhhbmRsZXJzKCk7XG4gICAgfVxuXG4gICAgaWYgKGV2ZW50LmRhdGEgJiYgZXZlbnQuZGF0YS5hY3Rpb24gJiYgZXZlbnQuZGF0YS5hY3Rpb24gIT09ICdpbml0Jykge1xuICAgICAgaWYgKHRoaXMubWVzc2FnZUhhbmRsZXJzW2V2ZW50LmRhdGEuYWN0aW9uXSkge1xuICAgICAgICB0aGlzLm1lc3NhZ2VIYW5kbGVyc1tldmVudC5kYXRhLmFjdGlvbl0oZXZlbnQuZGF0YSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xufTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gZnVuY3Rpb24gKHNlbGYpIHtcbiAgcmV0dXJuIG5ldyBUcmFuc211eGVyV29ya2VyKHNlbGYpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/videojs-contrib-media-sources/es5/transmuxer-worker.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/videojs-contrib-media-sources/es5/videojs-contrib-media-sources.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/videojs-contrib-media-sources/es5/videojs-contrib-media-sources.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("/**\n * @file videojs-contrib-media-sources.js\n */\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nvar _globalWindow = __webpack_require__(/*! global/window */ \"(ssr)/./node_modules/videojs-contrib-media-sources/node_modules/global/window.js\");\n\nvar _globalWindow2 = _interopRequireDefault(_globalWindow);\n\nvar _flashMediaSource = __webpack_require__(/*! ./flash-media-source */ \"(ssr)/./node_modules/videojs-contrib-media-sources/es5/flash-media-source.js\");\n\nvar _flashMediaSource2 = _interopRequireDefault(_flashMediaSource);\n\nvar _htmlMediaSource = __webpack_require__(/*! ./html-media-source */ \"(ssr)/./node_modules/videojs-contrib-media-sources/es5/html-media-source.js\");\n\nvar _htmlMediaSource2 = _interopRequireDefault(_htmlMediaSource);\n\nvar _videoJs = __webpack_require__(/*! video.js */ \"(ssr)/./node_modules/videojs-contrib-media-sources/node_modules/video.js/dist/video.cjs.js\");\n\nvar _videoJs2 = _interopRequireDefault(_videoJs);\n\nvar urlCount = 0;\n\n// ------------\n// Media Source\n// ------------\n\nvar defaults = {\n  // how to determine the MediaSource implementation to use. There\n  // are three available modes:\n  // - auto: use native MediaSources where available and Flash\n  //   everywhere else\n  // - html5: always use native MediaSources\n  // - flash: always use the Flash MediaSource polyfill\n  mode: 'auto'\n};\n\n// store references to the media sources so they can be connected\n// to a video element (a swf object)\n// TODO: can we store this somewhere local to this module?\n_videoJs2['default'].mediaSources = {};\n\n/**\n * Provide a method for a swf object to notify JS that a\n * media source is now open.\n *\n * @param {String} msObjectURL string referencing the MSE Object URL\n * @param {String} swfId the swf id\n */\nvar open = function open(msObjectURL, swfId) {\n  var mediaSource = _videoJs2['default'].mediaSources[msObjectURL];\n\n  if (mediaSource) {\n    mediaSource.trigger({ type: 'sourceopen', swfId: swfId });\n  } else {\n    throw new Error('Media Source not found (Video.js)');\n  }\n};\n\n/**\n * Check to see if the native MediaSource object exists and supports\n * an MP4 container with both H.264 video and AAC-LC audio.\n *\n * @return {Boolean} if  native media sources are supported\n */\nvar supportsNativeMediaSources = function supportsNativeMediaSources() {\n  return !!_globalWindow2['default'].MediaSource && !!_globalWindow2['default'].MediaSource.isTypeSupported && _globalWindow2['default'].MediaSource.isTypeSupported('video/mp4;codecs=\"avc1.4d400d,mp4a.40.2\"');\n};\n\n/**\n * An emulation of the MediaSource API so that we can support\n * native and non-native functionality such as flash and\n * video/mp2t videos. returns an instance of HtmlMediaSource or\n * FlashMediaSource depending on what is supported and what options\n * are passed in.\n *\n * @link https://developer.mozilla.org/en-US/docs/Web/API/MediaSource/MediaSource\n * @param {Object} options options to use during setup.\n */\nvar MediaSource = function MediaSource(options) {\n  var settings = _videoJs2['default'].mergeOptions(defaults, options);\n\n  this.MediaSource = {\n    open: open,\n    supportsNativeMediaSources: supportsNativeMediaSources\n  };\n\n  // determine whether HTML MediaSources should be used\n  if (settings.mode === 'html5' || settings.mode === 'auto' && supportsNativeMediaSources()) {\n    return new _htmlMediaSource2['default']();\n  } else if (_videoJs2['default'].getTech('Flash')) {\n    return new _flashMediaSource2['default']();\n  }\n\n  throw new Error('Cannot use Flash or Html5 to create a MediaSource for this video');\n};\n\nexports.MediaSource = MediaSource;\nMediaSource.open = open;\nMediaSource.supportsNativeMediaSources = supportsNativeMediaSources;\n\n/**\n * A wrapper around the native URL for our MSE object\n * implementation, this object is exposed under videojs.URL\n *\n * @link https://developer.mozilla.org/en-US/docs/Web/API/URL/URL\n */\nvar URL = {\n  /**\n   * A wrapper around the native createObjectURL for our objects.\n   * This function maps a native or emulated mediaSource to a blob\n   * url so that it can be loaded into video.js\n   *\n   * @link https://developer.mozilla.org/en-US/docs/Web/API/URL/createObjectURL\n   * @param {MediaSource} object the object to create a blob url to\n   */\n  createObjectURL: function createObjectURL(object) {\n    var objectUrlPrefix = 'blob:vjs-media-source/';\n    var url = undefined;\n\n    // use the native MediaSource to generate an object URL\n    if (object instanceof _htmlMediaSource2['default']) {\n      url = _globalWindow2['default'].URL.createObjectURL(object.nativeMediaSource_);\n      object.url_ = url;\n      return url;\n    }\n    // if the object isn't an emulated MediaSource, delegate to the\n    // native implementation\n    if (!(object instanceof _flashMediaSource2['default'])) {\n      url = _globalWindow2['default'].URL.createObjectURL(object);\n      object.url_ = url;\n      return url;\n    }\n\n    // build a URL that can be used to map back to the emulated\n    // MediaSource\n    url = objectUrlPrefix + urlCount;\n\n    urlCount++;\n\n    // setup the mapping back to object\n    _videoJs2['default'].mediaSources[url] = object;\n\n    return url;\n  }\n};\n\nexports.URL = URL;\n_videoJs2['default'].MediaSource = MediaSource;\n_videoJs2['default'].URL = URL;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdmlkZW9qcy1jb250cmliLW1lZGlhLXNvdXJjZXMvZXM1L3ZpZGVvanMtY29udHJpYi1tZWRpYS1zb3VyY2VzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNhOztBQUViLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQzs7QUFFRix1Q0FBdUMsdUNBQXVDOztBQUU5RSxvQkFBb0IsbUJBQU8sQ0FBQyx1R0FBZTs7QUFFM0M7O0FBRUEsd0JBQXdCLG1CQUFPLENBQUMsMEdBQXNCOztBQUV0RDs7QUFFQSx1QkFBdUIsbUJBQU8sQ0FBQyx3R0FBcUI7O0FBRXBEOztBQUVBLGVBQWUsbUJBQU8sQ0FBQyw0R0FBVTs7QUFFakM7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCLGtDQUFrQztBQUM1RCxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQSxnTEFBZ0w7QUFDaEw7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxtQkFBbUI7QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsYUFBYTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsV0FBVztBQUNYO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS12MC1wcm9qZWN0Ly4vbm9kZV9tb2R1bGVzL3ZpZGVvanMtY29udHJpYi1tZWRpYS1zb3VyY2VzL2VzNS92aWRlb2pzLWNvbnRyaWItbWVkaWEtc291cmNlcy5qcz81MThhIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGZpbGUgdmlkZW9qcy1jb250cmliLW1lZGlhLXNvdXJjZXMuanNcbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG52YXIgX2dsb2JhbFdpbmRvdyA9IHJlcXVpcmUoJ2dsb2JhbC93aW5kb3cnKTtcblxudmFyIF9nbG9iYWxXaW5kb3cyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2xvYmFsV2luZG93KTtcblxudmFyIF9mbGFzaE1lZGlhU291cmNlID0gcmVxdWlyZSgnLi9mbGFzaC1tZWRpYS1zb3VyY2UnKTtcblxudmFyIF9mbGFzaE1lZGlhU291cmNlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ZsYXNoTWVkaWFTb3VyY2UpO1xuXG52YXIgX2h0bWxNZWRpYVNvdXJjZSA9IHJlcXVpcmUoJy4vaHRtbC1tZWRpYS1zb3VyY2UnKTtcblxudmFyIF9odG1sTWVkaWFTb3VyY2UyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaHRtbE1lZGlhU291cmNlKTtcblxudmFyIF92aWRlb0pzID0gcmVxdWlyZSgndmlkZW8uanMnKTtcblxudmFyIF92aWRlb0pzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3ZpZGVvSnMpO1xuXG52YXIgdXJsQ291bnQgPSAwO1xuXG4vLyAtLS0tLS0tLS0tLS1cbi8vIE1lZGlhIFNvdXJjZVxuLy8gLS0tLS0tLS0tLS0tXG5cbnZhciBkZWZhdWx0cyA9IHtcbiAgLy8gaG93IHRvIGRldGVybWluZSB0aGUgTWVkaWFTb3VyY2UgaW1wbGVtZW50YXRpb24gdG8gdXNlLiBUaGVyZVxuICAvLyBhcmUgdGhyZWUgYXZhaWxhYmxlIG1vZGVzOlxuICAvLyAtIGF1dG86IHVzZSBuYXRpdmUgTWVkaWFTb3VyY2VzIHdoZXJlIGF2YWlsYWJsZSBhbmQgRmxhc2hcbiAgLy8gICBldmVyeXdoZXJlIGVsc2VcbiAgLy8gLSBodG1sNTogYWx3YXlzIHVzZSBuYXRpdmUgTWVkaWFTb3VyY2VzXG4gIC8vIC0gZmxhc2g6IGFsd2F5cyB1c2UgdGhlIEZsYXNoIE1lZGlhU291cmNlIHBvbHlmaWxsXG4gIG1vZGU6ICdhdXRvJ1xufTtcblxuLy8gc3RvcmUgcmVmZXJlbmNlcyB0byB0aGUgbWVkaWEgc291cmNlcyBzbyB0aGV5IGNhbiBiZSBjb25uZWN0ZWRcbi8vIHRvIGEgdmlkZW8gZWxlbWVudCAoYSBzd2Ygb2JqZWN0KVxuLy8gVE9ETzogY2FuIHdlIHN0b3JlIHRoaXMgc29tZXdoZXJlIGxvY2FsIHRvIHRoaXMgbW9kdWxlP1xuX3ZpZGVvSnMyWydkZWZhdWx0J10ubWVkaWFTb3VyY2VzID0ge307XG5cbi8qKlxuICogUHJvdmlkZSBhIG1ldGhvZCBmb3IgYSBzd2Ygb2JqZWN0IHRvIG5vdGlmeSBKUyB0aGF0IGFcbiAqIG1lZGlhIHNvdXJjZSBpcyBub3cgb3Blbi5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbXNPYmplY3RVUkwgc3RyaW5nIHJlZmVyZW5jaW5nIHRoZSBNU0UgT2JqZWN0IFVSTFxuICogQHBhcmFtIHtTdHJpbmd9IHN3ZklkIHRoZSBzd2YgaWRcbiAqL1xudmFyIG9wZW4gPSBmdW5jdGlvbiBvcGVuKG1zT2JqZWN0VVJMLCBzd2ZJZCkge1xuICB2YXIgbWVkaWFTb3VyY2UgPSBfdmlkZW9KczJbJ2RlZmF1bHQnXS5tZWRpYVNvdXJjZXNbbXNPYmplY3RVUkxdO1xuXG4gIGlmIChtZWRpYVNvdXJjZSkge1xuICAgIG1lZGlhU291cmNlLnRyaWdnZXIoeyB0eXBlOiAnc291cmNlb3BlbicsIHN3ZklkOiBzd2ZJZCB9KTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ01lZGlhIFNvdXJjZSBub3QgZm91bmQgKFZpZGVvLmpzKScpO1xuICB9XG59O1xuXG4vKipcbiAqIENoZWNrIHRvIHNlZSBpZiB0aGUgbmF0aXZlIE1lZGlhU291cmNlIG9iamVjdCBleGlzdHMgYW5kIHN1cHBvcnRzXG4gKiBhbiBNUDQgY29udGFpbmVyIHdpdGggYm90aCBILjI2NCB2aWRlbyBhbmQgQUFDLUxDIGF1ZGlvLlxuICpcbiAqIEByZXR1cm4ge0Jvb2xlYW59IGlmICBuYXRpdmUgbWVkaWEgc291cmNlcyBhcmUgc3VwcG9ydGVkXG4gKi9cbnZhciBzdXBwb3J0c05hdGl2ZU1lZGlhU291cmNlcyA9IGZ1bmN0aW9uIHN1cHBvcnRzTmF0aXZlTWVkaWFTb3VyY2VzKCkge1xuICByZXR1cm4gISFfZ2xvYmFsV2luZG93MlsnZGVmYXVsdCddLk1lZGlhU291cmNlICYmICEhX2dsb2JhbFdpbmRvdzJbJ2RlZmF1bHQnXS5NZWRpYVNvdXJjZS5pc1R5cGVTdXBwb3J0ZWQgJiYgX2dsb2JhbFdpbmRvdzJbJ2RlZmF1bHQnXS5NZWRpYVNvdXJjZS5pc1R5cGVTdXBwb3J0ZWQoJ3ZpZGVvL21wNDtjb2RlY3M9XCJhdmMxLjRkNDAwZCxtcDRhLjQwLjJcIicpO1xufTtcblxuLyoqXG4gKiBBbiBlbXVsYXRpb24gb2YgdGhlIE1lZGlhU291cmNlIEFQSSBzbyB0aGF0IHdlIGNhbiBzdXBwb3J0XG4gKiBuYXRpdmUgYW5kIG5vbi1uYXRpdmUgZnVuY3Rpb25hbGl0eSBzdWNoIGFzIGZsYXNoIGFuZFxuICogdmlkZW8vbXAydCB2aWRlb3MuIHJldHVybnMgYW4gaW5zdGFuY2Ugb2YgSHRtbE1lZGlhU291cmNlIG9yXG4gKiBGbGFzaE1lZGlhU291cmNlIGRlcGVuZGluZyBvbiB3aGF0IGlzIHN1cHBvcnRlZCBhbmQgd2hhdCBvcHRpb25zXG4gKiBhcmUgcGFzc2VkIGluLlxuICpcbiAqIEBsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9NZWRpYVNvdXJjZS9NZWRpYVNvdXJjZVxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgb3B0aW9ucyB0byB1c2UgZHVyaW5nIHNldHVwLlxuICovXG52YXIgTWVkaWFTb3VyY2UgPSBmdW5jdGlvbiBNZWRpYVNvdXJjZShvcHRpb25zKSB7XG4gIHZhciBzZXR0aW5ncyA9IF92aWRlb0pzMlsnZGVmYXVsdCddLm1lcmdlT3B0aW9ucyhkZWZhdWx0cywgb3B0aW9ucyk7XG5cbiAgdGhpcy5NZWRpYVNvdXJjZSA9IHtcbiAgICBvcGVuOiBvcGVuLFxuICAgIHN1cHBvcnRzTmF0aXZlTWVkaWFTb3VyY2VzOiBzdXBwb3J0c05hdGl2ZU1lZGlhU291cmNlc1xuICB9O1xuXG4gIC8vIGRldGVybWluZSB3aGV0aGVyIEhUTUwgTWVkaWFTb3VyY2VzIHNob3VsZCBiZSB1c2VkXG4gIGlmIChzZXR0aW5ncy5tb2RlID09PSAnaHRtbDUnIHx8IHNldHRpbmdzLm1vZGUgPT09ICdhdXRvJyAmJiBzdXBwb3J0c05hdGl2ZU1lZGlhU291cmNlcygpKSB7XG4gICAgcmV0dXJuIG5ldyBfaHRtbE1lZGlhU291cmNlMlsnZGVmYXVsdCddKCk7XG4gIH0gZWxzZSBpZiAoX3ZpZGVvSnMyWydkZWZhdWx0J10uZ2V0VGVjaCgnRmxhc2gnKSkge1xuICAgIHJldHVybiBuZXcgX2ZsYXNoTWVkaWFTb3VyY2UyWydkZWZhdWx0J10oKTtcbiAgfVxuXG4gIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHVzZSBGbGFzaCBvciBIdG1sNSB0byBjcmVhdGUgYSBNZWRpYVNvdXJjZSBmb3IgdGhpcyB2aWRlbycpO1xufTtcblxuZXhwb3J0cy5NZWRpYVNvdXJjZSA9IE1lZGlhU291cmNlO1xuTWVkaWFTb3VyY2Uub3BlbiA9IG9wZW47XG5NZWRpYVNvdXJjZS5zdXBwb3J0c05hdGl2ZU1lZGlhU291cmNlcyA9IHN1cHBvcnRzTmF0aXZlTWVkaWFTb3VyY2VzO1xuXG4vKipcbiAqIEEgd3JhcHBlciBhcm91bmQgdGhlIG5hdGl2ZSBVUkwgZm9yIG91ciBNU0Ugb2JqZWN0XG4gKiBpbXBsZW1lbnRhdGlvbiwgdGhpcyBvYmplY3QgaXMgZXhwb3NlZCB1bmRlciB2aWRlb2pzLlVSTFxuICpcbiAqIEBsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9VUkwvVVJMXG4gKi9cbnZhciBVUkwgPSB7XG4gIC8qKlxuICAgKiBBIHdyYXBwZXIgYXJvdW5kIHRoZSBuYXRpdmUgY3JlYXRlT2JqZWN0VVJMIGZvciBvdXIgb2JqZWN0cy5cbiAgICogVGhpcyBmdW5jdGlvbiBtYXBzIGEgbmF0aXZlIG9yIGVtdWxhdGVkIG1lZGlhU291cmNlIHRvIGEgYmxvYlxuICAgKiB1cmwgc28gdGhhdCBpdCBjYW4gYmUgbG9hZGVkIGludG8gdmlkZW8uanNcbiAgICpcbiAgICogQGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1VSTC9jcmVhdGVPYmplY3RVUkxcbiAgICogQHBhcmFtIHtNZWRpYVNvdXJjZX0gb2JqZWN0IHRoZSBvYmplY3QgdG8gY3JlYXRlIGEgYmxvYiB1cmwgdG9cbiAgICovXG4gIGNyZWF0ZU9iamVjdFVSTDogZnVuY3Rpb24gY3JlYXRlT2JqZWN0VVJMKG9iamVjdCkge1xuICAgIHZhciBvYmplY3RVcmxQcmVmaXggPSAnYmxvYjp2anMtbWVkaWEtc291cmNlLyc7XG4gICAgdmFyIHVybCA9IHVuZGVmaW5lZDtcblxuICAgIC8vIHVzZSB0aGUgbmF0aXZlIE1lZGlhU291cmNlIHRvIGdlbmVyYXRlIGFuIG9iamVjdCBVUkxcbiAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgX2h0bWxNZWRpYVNvdXJjZTJbJ2RlZmF1bHQnXSkge1xuICAgICAgdXJsID0gX2dsb2JhbFdpbmRvdzJbJ2RlZmF1bHQnXS5VUkwuY3JlYXRlT2JqZWN0VVJMKG9iamVjdC5uYXRpdmVNZWRpYVNvdXJjZV8pO1xuICAgICAgb2JqZWN0LnVybF8gPSB1cmw7XG4gICAgICByZXR1cm4gdXJsO1xuICAgIH1cbiAgICAvLyBpZiB0aGUgb2JqZWN0IGlzbid0IGFuIGVtdWxhdGVkIE1lZGlhU291cmNlLCBkZWxlZ2F0ZSB0byB0aGVcbiAgICAvLyBuYXRpdmUgaW1wbGVtZW50YXRpb25cbiAgICBpZiAoIShvYmplY3QgaW5zdGFuY2VvZiBfZmxhc2hNZWRpYVNvdXJjZTJbJ2RlZmF1bHQnXSkpIHtcbiAgICAgIHVybCA9IF9nbG9iYWxXaW5kb3cyWydkZWZhdWx0J10uVVJMLmNyZWF0ZU9iamVjdFVSTChvYmplY3QpO1xuICAgICAgb2JqZWN0LnVybF8gPSB1cmw7XG4gICAgICByZXR1cm4gdXJsO1xuICAgIH1cblxuICAgIC8vIGJ1aWxkIGEgVVJMIHRoYXQgY2FuIGJlIHVzZWQgdG8gbWFwIGJhY2sgdG8gdGhlIGVtdWxhdGVkXG4gICAgLy8gTWVkaWFTb3VyY2VcbiAgICB1cmwgPSBvYmplY3RVcmxQcmVmaXggKyB1cmxDb3VudDtcblxuICAgIHVybENvdW50Kys7XG5cbiAgICAvLyBzZXR1cCB0aGUgbWFwcGluZyBiYWNrIHRvIG9iamVjdFxuICAgIF92aWRlb0pzMlsnZGVmYXVsdCddLm1lZGlhU291cmNlc1t1cmxdID0gb2JqZWN0O1xuXG4gICAgcmV0dXJuIHVybDtcbiAgfVxufTtcblxuZXhwb3J0cy5VUkwgPSBVUkw7XG5fdmlkZW9KczJbJ2RlZmF1bHQnXS5NZWRpYVNvdXJjZSA9IE1lZGlhU291cmNlO1xuX3ZpZGVvSnMyWydkZWZhdWx0J10uVVJMID0gVVJMOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/videojs-contrib-media-sources/es5/videojs-contrib-media-sources.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/videojs-contrib-media-sources/es5/virtual-source-buffer.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/videojs-contrib-media-sources/es5/virtual-source-buffer.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("/**\n * @file virtual-source-buffer.js\n */\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nvar _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar _videoJs = __webpack_require__(/*! video.js */ \"(ssr)/./node_modules/videojs-contrib-media-sources/node_modules/video.js/dist/video.cjs.js\");\n\nvar _videoJs2 = _interopRequireDefault(_videoJs);\n\nvar _createTextTracksIfNecessary = __webpack_require__(/*! ./create-text-tracks-if-necessary */ \"(ssr)/./node_modules/videojs-contrib-media-sources/es5/create-text-tracks-if-necessary.js\");\n\nvar _createTextTracksIfNecessary2 = _interopRequireDefault(_createTextTracksIfNecessary);\n\nvar _removeCuesFromTrack = __webpack_require__(/*! ./remove-cues-from-track */ \"(ssr)/./node_modules/videojs-contrib-media-sources/es5/remove-cues-from-track.js\");\n\nvar _removeCuesFromTrack2 = _interopRequireDefault(_removeCuesFromTrack);\n\nvar _addTextTrackData = __webpack_require__(/*! ./add-text-track-data */ \"(ssr)/./node_modules/videojs-contrib-media-sources/es5/add-text-track-data.js\");\n\nvar _webwackify = __webpack_require__(/*! webwackify */ \"(ssr)/./node_modules/webwackify/index.js\");\n\nvar _webwackify2 = _interopRequireDefault(_webwackify);\n\nvar _transmuxerWorker = __webpack_require__(/*! ./transmuxer-worker */ \"(ssr)/./node_modules/videojs-contrib-media-sources/es5/transmuxer-worker.js\");\n\nvar _transmuxerWorker2 = _interopRequireDefault(_transmuxerWorker);\n\nvar _codecUtils = __webpack_require__(/*! ./codec-utils */ \"(ssr)/./node_modules/videojs-contrib-media-sources/es5/codec-utils.js\");\n\nvar resolveTransmuxWorker = function resolveTransmuxWorker() {\n  var result = undefined;\n\n  try {\n    result = /*require.resolve*/(/*! ./transmuxer-worker */ \"(ssr)/./node_modules/videojs-contrib-media-sources/es5/transmuxer-worker.js\");\n  } catch (e) {\n    // no result\n  }\n\n  return result;\n};\n\n// We create a wrapper around the SourceBuffer so that we can manage the\n// state of the `updating` property manually. We have to do this because\n// Firefox changes `updating` to false long before triggering `updateend`\n// events and that was causing strange problems in videojs-contrib-hls\nvar makeWrappedSourceBuffer = function makeWrappedSourceBuffer(mediaSource, mimeType) {\n  var sourceBuffer = mediaSource.addSourceBuffer(mimeType);\n  var wrapper = Object.create(null);\n\n  wrapper.updating = false;\n  wrapper.realBuffer_ = sourceBuffer;\n\n  var _loop = function (key) {\n    if (typeof sourceBuffer[key] === 'function') {\n      wrapper[key] = function () {\n        return sourceBuffer[key].apply(sourceBuffer, arguments);\n      };\n    } else if (typeof wrapper[key] === 'undefined') {\n      Object.defineProperty(wrapper, key, {\n        get: function get() {\n          return sourceBuffer[key];\n        },\n        set: function set(v) {\n          return sourceBuffer[key] = v;\n        }\n      });\n    }\n  };\n\n  for (var key in sourceBuffer) {\n    _loop(key);\n  }\n\n  return wrapper;\n};\n\n/**\n * Returns a list of gops in the buffer that have a pts value of 3 seconds or more in\n * front of current time.\n *\n * @param {Array} buffer\n *        The current buffer of gop information\n * @param {Player} player\n *        The player instance\n * @param {Double} mapping\n *        Offset to map display time to stream presentation time\n * @return {Array}\n *         List of gops considered safe to append over\n */\nvar gopsSafeToAlignWith = function gopsSafeToAlignWith(buffer, player, mapping) {\n  if (!player || !buffer.length) {\n    return [];\n  }\n\n  // pts value for current time + 3 seconds to give a bit more wiggle room\n  var currentTimePts = Math.ceil((player.currentTime() - mapping + 3) * 90000);\n\n  var i = undefined;\n\n  for (i = 0; i < buffer.length; i++) {\n    if (buffer[i].pts > currentTimePts) {\n      break;\n    }\n  }\n\n  return buffer.slice(i);\n};\n\nexports.gopsSafeToAlignWith = gopsSafeToAlignWith;\n/**\n * Appends gop information (timing and byteLength) received by the transmuxer for the\n * gops appended in the last call to appendBuffer\n *\n * @param {Array} buffer\n *        The current buffer of gop information\n * @param {Array} gops\n *        List of new gop information\n * @param {boolean} replace\n *        If true, replace the buffer with the new gop information. If false, append the\n *        new gop information to the buffer in the right location of time.\n * @return {Array}\n *         Updated list of gop information\n */\nvar updateGopBuffer = function updateGopBuffer(buffer, gops, replace) {\n  if (!gops.length) {\n    return buffer;\n  }\n\n  if (replace) {\n    // If we are in safe append mode, then completely overwrite the gop buffer\n    // with the most recent appeneded data. This will make sure that when appending\n    // future segments, we only try to align with gops that are both ahead of current\n    // time and in the last segment appended.\n    return gops.slice();\n  }\n\n  var start = gops[0].pts;\n\n  var i = 0;\n\n  for (i; i < buffer.length; i++) {\n    if (buffer[i].pts >= start) {\n      break;\n    }\n  }\n\n  return buffer.slice(0, i).concat(gops);\n};\n\nexports.updateGopBuffer = updateGopBuffer;\n/**\n * Removes gop information in buffer that overlaps with provided start and end\n *\n * @param {Array} buffer\n *        The current buffer of gop information\n * @param {Double} start\n *        position to start the remove at\n * @param {Double} end\n *        position to end the remove at\n * @param {Double} mapping\n *        Offset to map display time to stream presentation time\n */\nvar removeGopBuffer = function removeGopBuffer(buffer, start, end, mapping) {\n  var startPts = Math.ceil((start - mapping) * 90000);\n  var endPts = Math.ceil((end - mapping) * 90000);\n  var updatedBuffer = buffer.slice();\n\n  var i = buffer.length;\n\n  while (i--) {\n    if (buffer[i].pts <= endPts) {\n      break;\n    }\n  }\n\n  if (i === -1) {\n    // no removal because end of remove range is before start of buffer\n    return updatedBuffer;\n  }\n\n  var j = i + 1;\n\n  while (j--) {\n    if (buffer[j].pts <= startPts) {\n      break;\n    }\n  }\n\n  // clamp remove range start to 0 index\n  j = Math.max(j, 0);\n\n  updatedBuffer.splice(j, i - j + 1);\n\n  return updatedBuffer;\n};\n\nexports.removeGopBuffer = removeGopBuffer;\n/**\n * VirtualSourceBuffers exist so that we can transmux non native formats\n * into a native format, but keep the same api as a native source buffer.\n * It creates a transmuxer, that works in its own thread (a web worker) and\n * that transmuxer muxes the data into a native format. VirtualSourceBuffer will\n * then send all of that data to the naive sourcebuffer so that it is\n * indestinguishable from a natively supported format.\n *\n * @param {HtmlMediaSource} mediaSource the parent mediaSource\n * @param {Array} codecs array of codecs that we will be dealing with\n * @class VirtualSourceBuffer\n * @extends video.js.EventTarget\n */\n\nvar VirtualSourceBuffer = (function (_videojs$EventTarget) {\n  _inherits(VirtualSourceBuffer, _videojs$EventTarget);\n\n  function VirtualSourceBuffer(mediaSource, codecs) {\n    var _this = this;\n\n    _classCallCheck(this, VirtualSourceBuffer);\n\n    _get(Object.getPrototypeOf(VirtualSourceBuffer.prototype), 'constructor', this).call(this, _videoJs2['default'].EventTarget);\n    this.timestampOffset_ = 0;\n    this.pendingBuffers_ = [];\n    this.bufferUpdating_ = false;\n\n    this.mediaSource_ = mediaSource;\n    this.codecs_ = codecs;\n    this.audioCodec_ = null;\n    this.videoCodec_ = null;\n    this.audioDisabled_ = false;\n    this.appendAudioInitSegment_ = true;\n    this.gopBuffer_ = [];\n    this.timeMapping_ = 0;\n    this.safeAppend_ = _videoJs2['default'].browser.IE_VERSION >= 11;\n\n    var options = {\n      remux: false,\n      alignGopsAtEnd: this.safeAppend_\n    };\n\n    this.codecs_.forEach(function (codec) {\n      if ((0, _codecUtils.isAudioCodec)(codec)) {\n        _this.audioCodec_ = codec;\n      } else if ((0, _codecUtils.isVideoCodec)(codec)) {\n        _this.videoCodec_ = codec;\n      }\n    });\n\n    // append muxed segments to their respective native buffers as\n    // soon as they are available\n    this.transmuxer_ = (0, _webwackify2['default'])(_transmuxerWorker2['default'], resolveTransmuxWorker());\n    this.transmuxer_.postMessage({ action: 'init', options: options });\n\n    this.transmuxer_.onmessage = function (event) {\n      if (event.data.action === 'data') {\n        return _this.data_(event);\n      }\n\n      if (event.data.action === 'done') {\n        return _this.done_(event);\n      }\n\n      if (event.data.action === 'gopInfo') {\n        return _this.appendGopInfo_(event);\n      }\n    };\n\n    // this timestampOffset is a property with the side-effect of resetting\n    // baseMediaDecodeTime in the transmuxer on the setter\n    Object.defineProperty(this, 'timestampOffset', {\n      get: function get() {\n        return this.timestampOffset_;\n      },\n      set: function set(val) {\n        if (typeof val === 'number' && val >= 0) {\n          this.timestampOffset_ = val;\n          this.appendAudioInitSegment_ = true;\n\n          // reset gop buffer on timestampoffset as this signals a change in timeline\n          this.gopBuffer_.length = 0;\n          this.timeMapping_ = 0;\n\n          // We have to tell the transmuxer to set the baseMediaDecodeTime to\n          // the desired timestampOffset for the next segment\n          this.transmuxer_.postMessage({\n            action: 'setTimestampOffset',\n            timestampOffset: val\n          });\n        }\n      }\n    });\n\n    // setting the append window affects both source buffers\n    Object.defineProperty(this, 'appendWindowStart', {\n      get: function get() {\n        return (this.videoBuffer_ || this.audioBuffer_).appendWindowStart;\n      },\n      set: function set(start) {\n        if (this.videoBuffer_) {\n          this.videoBuffer_.appendWindowStart = start;\n        }\n        if (this.audioBuffer_) {\n          this.audioBuffer_.appendWindowStart = start;\n        }\n      }\n    });\n\n    // this buffer is \"updating\" if either of its native buffers are\n    Object.defineProperty(this, 'updating', {\n      get: function get() {\n        return !!(this.bufferUpdating_ || !this.audioDisabled_ && this.audioBuffer_ && this.audioBuffer_.updating || this.videoBuffer_ && this.videoBuffer_.updating);\n      }\n    });\n\n    // the buffered property is the intersection of the buffered\n    // ranges of the native source buffers\n    Object.defineProperty(this, 'buffered', {\n      get: function get() {\n        var start = null;\n        var end = null;\n        var arity = 0;\n        var extents = [];\n        var ranges = [];\n\n        // neither buffer has been created yet\n        if (!this.videoBuffer_ && !this.audioBuffer_) {\n          return _videoJs2['default'].createTimeRange();\n        }\n\n        // only one buffer is configured\n        if (!this.videoBuffer_) {\n          return this.audioBuffer_.buffered;\n        }\n        if (!this.audioBuffer_) {\n          return this.videoBuffer_.buffered;\n        }\n\n        // both buffers are configured\n        if (this.audioDisabled_) {\n          return this.videoBuffer_.buffered;\n        }\n\n        // both buffers are empty\n        if (this.videoBuffer_.buffered.length === 0 && this.audioBuffer_.buffered.length === 0) {\n          return _videoJs2['default'].createTimeRange();\n        }\n\n        // Handle the case where we have both buffers and create an\n        // intersection of the two\n        var videoBuffered = this.videoBuffer_.buffered;\n        var audioBuffered = this.audioBuffer_.buffered;\n        var count = videoBuffered.length;\n\n        // A) Gather up all start and end times\n        while (count--) {\n          extents.push({ time: videoBuffered.start(count), type: 'start' });\n          extents.push({ time: videoBuffered.end(count), type: 'end' });\n        }\n        count = audioBuffered.length;\n        while (count--) {\n          extents.push({ time: audioBuffered.start(count), type: 'start' });\n          extents.push({ time: audioBuffered.end(count), type: 'end' });\n        }\n        // B) Sort them by time\n        extents.sort(function (a, b) {\n          return a.time - b.time;\n        });\n\n        // C) Go along one by one incrementing arity for start and decrementing\n        //    arity for ends\n        for (count = 0; count < extents.length; count++) {\n          if (extents[count].type === 'start') {\n            arity++;\n\n            // D) If arity is ever incremented to 2 we are entering an\n            //    overlapping range\n            if (arity === 2) {\n              start = extents[count].time;\n            }\n          } else if (extents[count].type === 'end') {\n            arity--;\n\n            // E) If arity is ever decremented to 1 we leaving an\n            //    overlapping range\n            if (arity === 1) {\n              end = extents[count].time;\n            }\n          }\n\n          // F) Record overlapping ranges\n          if (start !== null && end !== null) {\n            ranges.push([start, end]);\n            start = null;\n            end = null;\n          }\n        }\n\n        return _videoJs2['default'].createTimeRanges(ranges);\n      }\n    });\n  }\n\n  /**\n   * When we get a data event from the transmuxer\n   * we call this function and handle the data that\n   * was sent to us\n   *\n   * @private\n   * @param {Event} event the data event from the transmuxer\n   */\n\n  _createClass(VirtualSourceBuffer, [{\n    key: 'data_',\n    value: function data_(event) {\n      var segment = event.data.segment;\n\n      // Cast ArrayBuffer to TypedArray\n      segment.data = new Uint8Array(segment.data, event.data.byteOffset, event.data.byteLength);\n\n      segment.initSegment = new Uint8Array(segment.initSegment.data, segment.initSegment.byteOffset, segment.initSegment.byteLength);\n\n      (0, _createTextTracksIfNecessary2['default'])(this, this.mediaSource_, segment);\n\n      // Add the segments to the pendingBuffers array\n      this.pendingBuffers_.push(segment);\n      return;\n    }\n\n    /**\n     * When we get a done event from the transmuxer\n     * we call this function and we process all\n     * of the pending data that we have been saving in the\n     * data_ function\n     *\n     * @private\n     * @param {Event} event the done event from the transmuxer\n     */\n  }, {\n    key: 'done_',\n    value: function done_(event) {\n      // Don't process and append data if the mediaSource is closed\n      if (this.mediaSource_.readyState === 'closed') {\n        this.pendingBuffers_.length = 0;\n        return;\n      }\n\n      // All buffers should have been flushed from the muxer\n      // start processing anything we have received\n      this.processPendingSegments_();\n      return;\n    }\n\n    /**\n     * Create our internal native audio/video source buffers and add\n     * event handlers to them with the following conditions:\n     * 1. they do not already exist on the mediaSource\n     * 2. this VSB has a codec for them\n     *\n     * @private\n     */\n  }, {\n    key: 'createRealSourceBuffers_',\n    value: function createRealSourceBuffers_() {\n      var _this2 = this;\n\n      var types = ['audio', 'video'];\n\n      types.forEach(function (type) {\n        // Don't create a SourceBuffer of this type if we don't have a\n        // codec for it\n        if (!_this2[type + 'Codec_']) {\n          return;\n        }\n\n        // Do nothing if a SourceBuffer of this type already exists\n        if (_this2[type + 'Buffer_']) {\n          return;\n        }\n\n        var buffer = null;\n\n        // If the mediasource already has a SourceBuffer for the codec\n        // use that\n        if (_this2.mediaSource_[type + 'Buffer_']) {\n          buffer = _this2.mediaSource_[type + 'Buffer_'];\n          // In multiple audio track cases, the audio source buffer is disabled\n          // on the main VirtualSourceBuffer by the HTMLMediaSource much earlier\n          // than createRealSourceBuffers_ is called to create the second\n          // VirtualSourceBuffer because that happens as a side-effect of\n          // videojs-contrib-hls starting the audioSegmentLoader. As a result,\n          // the audioBuffer is essentially \"ownerless\" and no one will toggle\n          // the `updating` state back to false once the `updateend` event is received\n          //\n          // Setting `updating` to false manually will work around this\n          // situation and allow work to continue\n          buffer.updating = false;\n        } else {\n          var codecProperty = type + 'Codec_';\n          var mimeType = type + '/mp4;codecs=\"' + _this2[codecProperty] + '\"';\n\n          buffer = makeWrappedSourceBuffer(_this2.mediaSource_.nativeMediaSource_, mimeType);\n\n          _this2.mediaSource_[type + 'Buffer_'] = buffer;\n        }\n\n        _this2[type + 'Buffer_'] = buffer;\n\n        // Wire up the events to the SourceBuffer\n        ['update', 'updatestart', 'updateend'].forEach(function (event) {\n          buffer.addEventListener(event, function () {\n            // if audio is disabled\n            if (type === 'audio' && _this2.audioDisabled_) {\n              return;\n            }\n\n            if (event === 'updateend') {\n              _this2[type + 'Buffer_'].updating = false;\n            }\n\n            var shouldTrigger = types.every(function (t) {\n              // skip checking audio's updating status if audio\n              // is not enabled\n              if (t === 'audio' && _this2.audioDisabled_) {\n                return true;\n              }\n              // if the other type if updating we don't trigger\n              if (type !== t && _this2[t + 'Buffer_'] && _this2[t + 'Buffer_'].updating) {\n                return false;\n              }\n              return true;\n            });\n\n            if (shouldTrigger) {\n              return _this2.trigger(event);\n            }\n          });\n        });\n      });\n    }\n\n    /**\n     * Emulate the native mediasource function, but our function will\n     * send all of the proposed segments to the transmuxer so that we\n     * can transmux them before we append them to our internal\n     * native source buffers in the correct format.\n     *\n     * @link https://developer.mozilla.org/en-US/docs/Web/API/SourceBuffer/appendBuffer\n     * @param {Uint8Array} segment the segment to append to the buffer\n     */\n  }, {\n    key: 'appendBuffer',\n    value: function appendBuffer(segment) {\n      // Start the internal \"updating\" state\n      this.bufferUpdating_ = true;\n\n      if (this.audioBuffer_ && this.audioBuffer_.buffered.length) {\n        var audioBuffered = this.audioBuffer_.buffered;\n\n        this.transmuxer_.postMessage({\n          action: 'setAudioAppendStart',\n          appendStart: audioBuffered.end(audioBuffered.length - 1)\n        });\n      }\n\n      if (this.videoBuffer_) {\n        this.transmuxer_.postMessage({\n          action: 'alignGopsWith',\n          gopsToAlignWith: gopsSafeToAlignWith(this.gopBuffer_, this.mediaSource_.player_, this.timeMapping_)\n        });\n      }\n\n      this.transmuxer_.postMessage({\n        action: 'push',\n        // Send the typed-array of data as an ArrayBuffer so that\n        // it can be sent as a \"Transferable\" and avoid the costly\n        // memory copy\n        data: segment.buffer,\n\n        // To recreate the original typed-array, we need information\n        // about what portion of the ArrayBuffer it was a view into\n        byteOffset: segment.byteOffset,\n        byteLength: segment.byteLength\n      }, [segment.buffer]);\n      this.transmuxer_.postMessage({ action: 'flush' });\n    }\n\n    /**\n     * Appends gop information (timing and byteLength) received by the transmuxer for the\n     * gops appended in the last call to appendBuffer\n     *\n     * @param {Event} event\n     *        The gopInfo event from the transmuxer\n     * @param {Array} event.data.gopInfo\n     *        List of gop info to append\n     */\n  }, {\n    key: 'appendGopInfo_',\n    value: function appendGopInfo_(event) {\n      this.gopBuffer_ = updateGopBuffer(this.gopBuffer_, event.data.gopInfo, this.safeAppend_);\n    }\n\n    /**\n     * Emulate the native mediasource function and remove parts\n     * of the buffer from any of our internal buffers that exist\n     *\n     * @link https://developer.mozilla.org/en-US/docs/Web/API/SourceBuffer/remove\n     * @param {Double} start position to start the remove at\n     * @param {Double} end position to end the remove at\n     */\n  }, {\n    key: 'remove',\n    value: function remove(start, end) {\n      if (this.videoBuffer_) {\n        this.videoBuffer_.updating = true;\n        this.videoBuffer_.remove(start, end);\n        this.gopBuffer_ = removeGopBuffer(this.gopBuffer_, start, end, this.timeMapping_);\n      }\n      if (!this.audioDisabled_ && this.audioBuffer_) {\n        this.audioBuffer_.updating = true;\n        this.audioBuffer_.remove(start, end);\n      }\n\n      // Remove Metadata Cues (id3)\n      (0, _removeCuesFromTrack2['default'])(start, end, this.metadataTrack_);\n\n      // Remove Any Captions\n      if (this.inbandTextTracks_) {\n        for (var track in this.inbandTextTracks_) {\n          (0, _removeCuesFromTrack2['default'])(start, end, this.inbandTextTracks_[track]);\n        }\n      }\n    }\n\n    /**\n     * Process any segments that the muxer has output\n     * Concatenate segments together based on type and append them into\n     * their respective sourceBuffers\n     *\n     * @private\n     */\n  }, {\n    key: 'processPendingSegments_',\n    value: function processPendingSegments_() {\n      var sortedSegments = {\n        video: {\n          segments: [],\n          bytes: 0\n        },\n        audio: {\n          segments: [],\n          bytes: 0\n        },\n        captions: [],\n        metadata: []\n      };\n\n      // Sort segments into separate video/audio arrays and\n      // keep track of their total byte lengths\n      sortedSegments = this.pendingBuffers_.reduce(function (segmentObj, segment) {\n        var type = segment.type;\n        var data = segment.data;\n        var initSegment = segment.initSegment;\n\n        segmentObj[type].segments.push(data);\n        segmentObj[type].bytes += data.byteLength;\n\n        segmentObj[type].initSegment = initSegment;\n\n        // Gather any captions into a single array\n        if (segment.captions) {\n          segmentObj.captions = segmentObj.captions.concat(segment.captions);\n        }\n\n        if (segment.info) {\n          segmentObj[type].info = segment.info;\n        }\n\n        // Gather any metadata into a single array\n        if (segment.metadata) {\n          segmentObj.metadata = segmentObj.metadata.concat(segment.metadata);\n        }\n\n        return segmentObj;\n      }, sortedSegments);\n\n      // Create the real source buffers if they don't exist by now since we\n      // finally are sure what tracks are contained in the source\n      if (!this.videoBuffer_ && !this.audioBuffer_) {\n        // Remove any codecs that may have been specified by default but\n        // are no longer applicable now\n        if (sortedSegments.video.bytes === 0) {\n          this.videoCodec_ = null;\n        }\n        if (sortedSegments.audio.bytes === 0) {\n          this.audioCodec_ = null;\n        }\n\n        this.createRealSourceBuffers_();\n      }\n\n      if (sortedSegments.audio.info) {\n        this.mediaSource_.trigger({ type: 'audioinfo', info: sortedSegments.audio.info });\n      }\n      if (sortedSegments.video.info) {\n        this.mediaSource_.trigger({ type: 'videoinfo', info: sortedSegments.video.info });\n      }\n\n      if (this.appendAudioInitSegment_) {\n        if (!this.audioDisabled_ && this.audioBuffer_) {\n          sortedSegments.audio.segments.unshift(sortedSegments.audio.initSegment);\n          sortedSegments.audio.bytes += sortedSegments.audio.initSegment.byteLength;\n        }\n        this.appendAudioInitSegment_ = false;\n      }\n\n      var triggerUpdateend = false;\n\n      // Merge multiple video and audio segments into one and append\n      if (this.videoBuffer_ && sortedSegments.video.bytes) {\n        sortedSegments.video.segments.unshift(sortedSegments.video.initSegment);\n        sortedSegments.video.bytes += sortedSegments.video.initSegment.byteLength;\n        this.concatAndAppendSegments_(sortedSegments.video, this.videoBuffer_);\n        // TODO: are video tracks the only ones with text tracks?\n        (0, _addTextTrackData.addTextTrackData)(this, sortedSegments.captions, sortedSegments.metadata);\n      } else if (this.videoBuffer_ && (this.audioDisabled_ || !this.audioBuffer_)) {\n        // The transmuxer did not return any bytes of video, meaning it was all trimmed\n        // for gop alignment. Since we have a video buffer and audio is disabled, updateend\n        // will never be triggered by this source buffer, which will cause contrib-hls\n        // to be stuck forever waiting for updateend. If audio is not disabled, updateend\n        // will be triggered by the audio buffer, which will be sent upwards since the video\n        // buffer will not be in an updating state.\n        triggerUpdateend = true;\n      }\n\n      if (!this.audioDisabled_ && this.audioBuffer_) {\n        this.concatAndAppendSegments_(sortedSegments.audio, this.audioBuffer_);\n      }\n\n      this.pendingBuffers_.length = 0;\n\n      if (triggerUpdateend) {\n        this.trigger('updateend');\n      }\n\n      // We are no longer in the internal \"updating\" state\n      this.bufferUpdating_ = false;\n    }\n\n    /**\n     * Combine all segments into a single Uint8Array and then append them\n     * to the destination buffer\n     *\n     * @param {Object} segmentObj\n     * @param {SourceBuffer} destinationBuffer native source buffer to append data to\n     * @private\n     */\n  }, {\n    key: 'concatAndAppendSegments_',\n    value: function concatAndAppendSegments_(segmentObj, destinationBuffer) {\n      var offset = 0;\n      var tempBuffer = undefined;\n\n      if (segmentObj.bytes) {\n        tempBuffer = new Uint8Array(segmentObj.bytes);\n\n        // Combine the individual segments into one large typed-array\n        segmentObj.segments.forEach(function (segment) {\n          tempBuffer.set(segment, offset);\n          offset += segment.byteLength;\n        });\n\n        try {\n          destinationBuffer.updating = true;\n          destinationBuffer.appendBuffer(tempBuffer);\n        } catch (error) {\n          if (this.mediaSource_.player_) {\n            this.mediaSource_.player_.error({\n              code: -3,\n              type: 'APPEND_BUFFER_ERR',\n              message: error.message,\n              originalError: error\n            });\n          }\n        }\n      }\n    }\n\n    /**\n     * Emulate the native mediasource function. abort any soureBuffer\n     * actions and throw out any un-appended data.\n     *\n     * @link https://developer.mozilla.org/en-US/docs/Web/API/SourceBuffer/abort\n     */\n  }, {\n    key: 'abort',\n    value: function abort() {\n      if (this.videoBuffer_) {\n        this.videoBuffer_.abort();\n      }\n      if (!this.audioDisabled_ && this.audioBuffer_) {\n        this.audioBuffer_.abort();\n      }\n      if (this.transmuxer_) {\n        this.transmuxer_.postMessage({ action: 'reset' });\n      }\n      this.pendingBuffers_.length = 0;\n      this.bufferUpdating_ = false;\n    }\n  }]);\n\n  return VirtualSourceBuffer;\n})(_videoJs2['default'].EventTarget);\n\nexports[\"default\"] = VirtualSourceBuffer;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdmlkZW9qcy1jb250cmliLW1lZGlhLXNvdXJjZXMvZXM1L3ZpcnR1YWwtc291cmNlLWJ1ZmZlci5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDYTs7QUFFYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7O0FBRUYsa0NBQWtDLDJDQUEyQyxnQkFBZ0Isa0JBQWtCLE9BQU8sMkJBQTJCLHdEQUF3RCxnQ0FBZ0MsdURBQXVELCtEQUErRCx5REFBeUQscUVBQXFFLDZEQUE2RCx3QkFBd0I7O0FBRWxqQix3Q0FBd0MsbUJBQW1CLDRCQUE0QixpREFBaUQsZ0JBQWdCLGtEQUFrRCw4REFBOEQsMEJBQTBCLDRDQUE0Qyx1QkFBdUIsb0JBQW9CLE9BQU8sYUFBYSxnQkFBZ0IsZ0JBQWdCLGVBQWUsMkJBQTJCLHdCQUF3Qiw0QkFBNEIscUJBQXFCLE9BQU8sdUJBQXVCLDRCQUE0QixvQkFBb0I7O0FBRTltQix1Q0FBdUMsdUNBQXVDOztBQUU5RSxrREFBa0QsMENBQTBDOztBQUU1RiwyQ0FBMkMsK0RBQStELHVHQUF1Ryx5RUFBeUUsZUFBZSwwRUFBMEUsR0FBRzs7QUFFdFgsZUFBZSxtQkFBTyxDQUFDLDRHQUFVOztBQUVqQzs7QUFFQSxtQ0FBbUMsbUJBQU8sQ0FBQyxvSUFBbUM7O0FBRTlFOztBQUVBLDJCQUEyQixtQkFBTyxDQUFDLGtIQUEwQjs7QUFFN0Q7O0FBRUEsd0JBQXdCLG1CQUFPLENBQUMsNEdBQXVCOztBQUV2RCxrQkFBa0IsbUJBQU8sQ0FBQyw0REFBWTs7QUFFdEM7O0FBRUEsd0JBQXdCLG1CQUFPLENBQUMsd0dBQXFCOztBQUVyRDs7QUFFQSxrQkFBa0IsbUJBQU8sQ0FBQyw0RkFBZTs7QUFFekM7QUFDQTs7QUFFQTtBQUNBLGFBQWEsbUJBQWUsQ0FBQyx3R0FBcUI7QUFDbEQsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFF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QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxzQ0FBc0M7O0FBRXRDOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1QsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxxQ0FBcUMsaUJBQWlCO0FBQ3REOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esb0NBQW9DLG9EQUFvRDtBQUN4RjtBQUNBO0FBQ0Esb0NBQW9DLG9EQUFvRDtBQUN4Rjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsY0FBYztBQUM3QjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxpQkFBaUI7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRCxrQkFBa0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS12MC1wcm9qZWN0Ly4vbm9kZV9tb2R1bGVzL3ZpZGVvanMtY29udHJpYi1tZWRpYS1zb3VyY2VzL2VzNS92aXJ0dWFsLXNvdXJjZS1idWZmZXIuanM/Zjc3MCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBmaWxlIHZpcnR1YWwtc291cmNlLWJ1ZmZlci5qc1xuICovXG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gKGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmICgndmFsdWUnIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KSgpO1xuXG52YXIgX2dldCA9IGZ1bmN0aW9uIGdldChfeCwgX3gyLCBfeDMpIHsgdmFyIF9hZ2FpbiA9IHRydWU7IF9mdW5jdGlvbjogd2hpbGUgKF9hZ2FpbikgeyB2YXIgb2JqZWN0ID0gX3gsIHByb3BlcnR5ID0gX3gyLCByZWNlaXZlciA9IF94MzsgX2FnYWluID0gZmFsc2U7IGlmIChvYmplY3QgPT09IG51bGwpIG9iamVjdCA9IEZ1bmN0aW9uLnByb3RvdHlwZTsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgcHJvcGVydHkpOyBpZiAoZGVzYyA9PT0gdW5kZWZpbmVkKSB7IHZhciBwYXJlbnQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgaWYgKHBhcmVudCA9PT0gbnVsbCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IGVsc2UgeyBfeCA9IHBhcmVudDsgX3gyID0gcHJvcGVydHk7IF94MyA9IHJlY2VpdmVyOyBfYWdhaW4gPSB0cnVlOyBkZXNjID0gcGFyZW50ID0gdW5kZWZpbmVkOyBjb250aW51ZSBfZnVuY3Rpb247IH0gfSBlbHNlIGlmICgndmFsdWUnIGluIGRlc2MpIHsgcmV0dXJuIGRlc2MudmFsdWU7IH0gZWxzZSB7IHZhciBnZXR0ZXIgPSBkZXNjLmdldDsgaWYgKGdldHRlciA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gcmV0dXJuIGdldHRlci5jYWxsKHJlY2VpdmVyKTsgfSB9IH07XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb24nKTsgfSB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09ICdmdW5jdGlvbicgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90ICcgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBfdmlkZW9KcyA9IHJlcXVpcmUoJ3ZpZGVvLmpzJyk7XG5cbnZhciBfdmlkZW9KczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF92aWRlb0pzKTtcblxudmFyIF9jcmVhdGVUZXh0VHJhY2tzSWZOZWNlc3NhcnkgPSByZXF1aXJlKCcuL2NyZWF0ZS10ZXh0LXRyYWNrcy1pZi1uZWNlc3NhcnknKTtcblxudmFyIF9jcmVhdGVUZXh0VHJhY2tzSWZOZWNlc3NhcnkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlVGV4dFRyYWNrc0lmTmVjZXNzYXJ5KTtcblxudmFyIF9yZW1vdmVDdWVzRnJvbVRyYWNrID0gcmVxdWlyZSgnLi9yZW1vdmUtY3Vlcy1mcm9tLXRyYWNrJyk7XG5cbnZhciBfcmVtb3ZlQ3Vlc0Zyb21UcmFjazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZW1vdmVDdWVzRnJvbVRyYWNrKTtcblxudmFyIF9hZGRUZXh0VHJhY2tEYXRhID0gcmVxdWlyZSgnLi9hZGQtdGV4dC10cmFjay1kYXRhJyk7XG5cbnZhciBfd2Vid2Fja2lmeSA9IHJlcXVpcmUoJ3dlYndhY2tpZnknKTtcblxudmFyIF93ZWJ3YWNraWZ5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3dlYndhY2tpZnkpO1xuXG52YXIgX3RyYW5zbXV4ZXJXb3JrZXIgPSByZXF1aXJlKCcuL3RyYW5zbXV4ZXItd29ya2VyJyk7XG5cbnZhciBfdHJhbnNtdXhlcldvcmtlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90cmFuc211eGVyV29ya2VyKTtcblxudmFyIF9jb2RlY1V0aWxzID0gcmVxdWlyZSgnLi9jb2RlYy11dGlscycpO1xuXG52YXIgcmVzb2x2ZVRyYW5zbXV4V29ya2VyID0gZnVuY3Rpb24gcmVzb2x2ZVRyYW5zbXV4V29ya2VyKCkge1xuICB2YXIgcmVzdWx0ID0gdW5kZWZpbmVkO1xuXG4gIHRyeSB7XG4gICAgcmVzdWx0ID0gcmVxdWlyZS5yZXNvbHZlKCcuL3RyYW5zbXV4ZXItd29ya2VyJyk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBubyByZXN1bHRcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vLyBXZSBjcmVhdGUgYSB3cmFwcGVyIGFyb3VuZCB0aGUgU291cmNlQnVmZmVyIHNvIHRoYXQgd2UgY2FuIG1hbmFnZSB0aGVcbi8vIHN0YXRlIG9mIHRoZSBgdXBkYXRpbmdgIHByb3BlcnR5IG1hbnVhbGx5LiBXZSBoYXZlIHRvIGRvIHRoaXMgYmVjYXVzZVxuLy8gRmlyZWZveCBjaGFuZ2VzIGB1cGRhdGluZ2AgdG8gZmFsc2UgbG9uZyBiZWZvcmUgdHJpZ2dlcmluZyBgdXBkYXRlZW5kYFxuLy8gZXZlbnRzIGFuZCB0aGF0IHdhcyBjYXVzaW5nIHN0cmFuZ2UgcHJvYmxlbXMgaW4gdmlkZW9qcy1jb250cmliLWhsc1xudmFyIG1ha2VXcmFwcGVkU291cmNlQnVmZmVyID0gZnVuY3Rpb24gbWFrZVdyYXBwZWRTb3VyY2VCdWZmZXIobWVkaWFTb3VyY2UsIG1pbWVUeXBlKSB7XG4gIHZhciBzb3VyY2VCdWZmZXIgPSBtZWRpYVNvdXJjZS5hZGRTb3VyY2VCdWZmZXIobWltZVR5cGUpO1xuICB2YXIgd3JhcHBlciA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgd3JhcHBlci51cGRhdGluZyA9IGZhbHNlO1xuICB3cmFwcGVyLnJlYWxCdWZmZXJfID0gc291cmNlQnVmZmVyO1xuXG4gIHZhciBfbG9vcCA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICBpZiAodHlwZW9mIHNvdXJjZUJ1ZmZlcltrZXldID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB3cmFwcGVyW2tleV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2VCdWZmZXJba2V5XS5hcHBseShzb3VyY2VCdWZmZXIsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHdyYXBwZXJba2V5XSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3cmFwcGVyLCBrZXksIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgcmV0dXJuIHNvdXJjZUJ1ZmZlcltrZXldO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2KSB7XG4gICAgICAgICAgcmV0dXJuIHNvdXJjZUJ1ZmZlcltrZXldID0gdjtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIGZvciAodmFyIGtleSBpbiBzb3VyY2VCdWZmZXIpIHtcbiAgICBfbG9vcChrZXkpO1xuICB9XG5cbiAgcmV0dXJuIHdyYXBwZXI7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYSBsaXN0IG9mIGdvcHMgaW4gdGhlIGJ1ZmZlciB0aGF0IGhhdmUgYSBwdHMgdmFsdWUgb2YgMyBzZWNvbmRzIG9yIG1vcmUgaW5cbiAqIGZyb250IG9mIGN1cnJlbnQgdGltZS5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBidWZmZXJcbiAqICAgICAgICBUaGUgY3VycmVudCBidWZmZXIgb2YgZ29wIGluZm9ybWF0aW9uXG4gKiBAcGFyYW0ge1BsYXllcn0gcGxheWVyXG4gKiAgICAgICAgVGhlIHBsYXllciBpbnN0YW5jZVxuICogQHBhcmFtIHtEb3VibGV9IG1hcHBpbmdcbiAqICAgICAgICBPZmZzZXQgdG8gbWFwIGRpc3BsYXkgdGltZSB0byBzdHJlYW0gcHJlc2VudGF0aW9uIHRpbWVcbiAqIEByZXR1cm4ge0FycmF5fVxuICogICAgICAgICBMaXN0IG9mIGdvcHMgY29uc2lkZXJlZCBzYWZlIHRvIGFwcGVuZCBvdmVyXG4gKi9cbnZhciBnb3BzU2FmZVRvQWxpZ25XaXRoID0gZnVuY3Rpb24gZ29wc1NhZmVUb0FsaWduV2l0aChidWZmZXIsIHBsYXllciwgbWFwcGluZykge1xuICBpZiAoIXBsYXllciB8fCAhYnVmZmVyLmxlbmd0aCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIC8vIHB0cyB2YWx1ZSBmb3IgY3VycmVudCB0aW1lICsgMyBzZWNvbmRzIHRvIGdpdmUgYSBiaXQgbW9yZSB3aWdnbGUgcm9vbVxuICB2YXIgY3VycmVudFRpbWVQdHMgPSBNYXRoLmNlaWwoKHBsYXllci5jdXJyZW50VGltZSgpIC0gbWFwcGluZyArIDMpICogOTAwMDApO1xuXG4gIHZhciBpID0gdW5kZWZpbmVkO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBidWZmZXIubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoYnVmZmVyW2ldLnB0cyA+IGN1cnJlbnRUaW1lUHRzKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnVmZmVyLnNsaWNlKGkpO1xufTtcblxuZXhwb3J0cy5nb3BzU2FmZVRvQWxpZ25XaXRoID0gZ29wc1NhZmVUb0FsaWduV2l0aDtcbi8qKlxuICogQXBwZW5kcyBnb3AgaW5mb3JtYXRpb24gKHRpbWluZyBhbmQgYnl0ZUxlbmd0aCkgcmVjZWl2ZWQgYnkgdGhlIHRyYW5zbXV4ZXIgZm9yIHRoZVxuICogZ29wcyBhcHBlbmRlZCBpbiB0aGUgbGFzdCBjYWxsIHRvIGFwcGVuZEJ1ZmZlclxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGJ1ZmZlclxuICogICAgICAgIFRoZSBjdXJyZW50IGJ1ZmZlciBvZiBnb3AgaW5mb3JtYXRpb25cbiAqIEBwYXJhbSB7QXJyYXl9IGdvcHNcbiAqICAgICAgICBMaXN0IG9mIG5ldyBnb3AgaW5mb3JtYXRpb25cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gcmVwbGFjZVxuICogICAgICAgIElmIHRydWUsIHJlcGxhY2UgdGhlIGJ1ZmZlciB3aXRoIHRoZSBuZXcgZ29wIGluZm9ybWF0aW9uLiBJZiBmYWxzZSwgYXBwZW5kIHRoZVxuICogICAgICAgIG5ldyBnb3AgaW5mb3JtYXRpb24gdG8gdGhlIGJ1ZmZlciBpbiB0aGUgcmlnaHQgbG9jYXRpb24gb2YgdGltZS5cbiAqIEByZXR1cm4ge0FycmF5fVxuICogICAgICAgICBVcGRhdGVkIGxpc3Qgb2YgZ29wIGluZm9ybWF0aW9uXG4gKi9cbnZhciB1cGRhdGVHb3BCdWZmZXIgPSBmdW5jdGlvbiB1cGRhdGVHb3BCdWZmZXIoYnVmZmVyLCBnb3BzLCByZXBsYWNlKSB7XG4gIGlmICghZ29wcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gYnVmZmVyO1xuICB9XG5cbiAgaWYgKHJlcGxhY2UpIHtcbiAgICAvLyBJZiB3ZSBhcmUgaW4gc2FmZSBhcHBlbmQgbW9kZSwgdGhlbiBjb21wbGV0ZWx5IG92ZXJ3cml0ZSB0aGUgZ29wIGJ1ZmZlclxuICAgIC8vIHdpdGggdGhlIG1vc3QgcmVjZW50IGFwcGVuZWRlZCBkYXRhLiBUaGlzIHdpbGwgbWFrZSBzdXJlIHRoYXQgd2hlbiBhcHBlbmRpbmdcbiAgICAvLyBmdXR1cmUgc2VnbWVudHMsIHdlIG9ubHkgdHJ5IHRvIGFsaWduIHdpdGggZ29wcyB0aGF0IGFyZSBib3RoIGFoZWFkIG9mIGN1cnJlbnRcbiAgICAvLyB0aW1lIGFuZCBpbiB0aGUgbGFzdCBzZWdtZW50IGFwcGVuZGVkLlxuICAgIHJldHVybiBnb3BzLnNsaWNlKCk7XG4gIH1cblxuICB2YXIgc3RhcnQgPSBnb3BzWzBdLnB0cztcblxuICB2YXIgaSA9IDA7XG5cbiAgZm9yIChpOyBpIDwgYnVmZmVyLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGJ1ZmZlcltpXS5wdHMgPj0gc3RhcnQpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBidWZmZXIuc2xpY2UoMCwgaSkuY29uY2F0KGdvcHMpO1xufTtcblxuZXhwb3J0cy51cGRhdGVHb3BCdWZmZXIgPSB1cGRhdGVHb3BCdWZmZXI7XG4vKipcbiAqIFJlbW92ZXMgZ29wIGluZm9ybWF0aW9uIGluIGJ1ZmZlciB0aGF0IG92ZXJsYXBzIHdpdGggcHJvdmlkZWQgc3RhcnQgYW5kIGVuZFxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGJ1ZmZlclxuICogICAgICAgIFRoZSBjdXJyZW50IGJ1ZmZlciBvZiBnb3AgaW5mb3JtYXRpb25cbiAqIEBwYXJhbSB7RG91YmxlfSBzdGFydFxuICogICAgICAgIHBvc2l0aW9uIHRvIHN0YXJ0IHRoZSByZW1vdmUgYXRcbiAqIEBwYXJhbSB7RG91YmxlfSBlbmRcbiAqICAgICAgICBwb3NpdGlvbiB0byBlbmQgdGhlIHJlbW92ZSBhdFxuICogQHBhcmFtIHtEb3VibGV9IG1hcHBpbmdcbiAqICAgICAgICBPZmZzZXQgdG8gbWFwIGRpc3BsYXkgdGltZSB0byBzdHJlYW0gcHJlc2VudGF0aW9uIHRpbWVcbiAqL1xudmFyIHJlbW92ZUdvcEJ1ZmZlciA9IGZ1bmN0aW9uIHJlbW92ZUdvcEJ1ZmZlcihidWZmZXIsIHN0YXJ0LCBlbmQsIG1hcHBpbmcpIHtcbiAgdmFyIHN0YXJ0UHRzID0gTWF0aC5jZWlsKChzdGFydCAtIG1hcHBpbmcpICogOTAwMDApO1xuICB2YXIgZW5kUHRzID0gTWF0aC5jZWlsKChlbmQgLSBtYXBwaW5nKSAqIDkwMDAwKTtcbiAgdmFyIHVwZGF0ZWRCdWZmZXIgPSBidWZmZXIuc2xpY2UoKTtcblxuICB2YXIgaSA9IGJ1ZmZlci5sZW5ndGg7XG5cbiAgd2hpbGUgKGktLSkge1xuICAgIGlmIChidWZmZXJbaV0ucHRzIDw9IGVuZFB0cykge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgaWYgKGkgPT09IC0xKSB7XG4gICAgLy8gbm8gcmVtb3ZhbCBiZWNhdXNlIGVuZCBvZiByZW1vdmUgcmFuZ2UgaXMgYmVmb3JlIHN0YXJ0IG9mIGJ1ZmZlclxuICAgIHJldHVybiB1cGRhdGVkQnVmZmVyO1xuICB9XG5cbiAgdmFyIGogPSBpICsgMTtcblxuICB3aGlsZSAoai0tKSB7XG4gICAgaWYgKGJ1ZmZlcltqXS5wdHMgPD0gc3RhcnRQdHMpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIC8vIGNsYW1wIHJlbW92ZSByYW5nZSBzdGFydCB0byAwIGluZGV4XG4gIGogPSBNYXRoLm1heChqLCAwKTtcblxuICB1cGRhdGVkQnVmZmVyLnNwbGljZShqLCBpIC0gaiArIDEpO1xuXG4gIHJldHVybiB1cGRhdGVkQnVmZmVyO1xufTtcblxuZXhwb3J0cy5yZW1vdmVHb3BCdWZmZXIgPSByZW1vdmVHb3BCdWZmZXI7XG4vKipcbiAqIFZpcnR1YWxTb3VyY2VCdWZmZXJzIGV4aXN0IHNvIHRoYXQgd2UgY2FuIHRyYW5zbXV4IG5vbiBuYXRpdmUgZm9ybWF0c1xuICogaW50byBhIG5hdGl2ZSBmb3JtYXQsIGJ1dCBrZWVwIHRoZSBzYW1lIGFwaSBhcyBhIG5hdGl2ZSBzb3VyY2UgYnVmZmVyLlxuICogSXQgY3JlYXRlcyBhIHRyYW5zbXV4ZXIsIHRoYXQgd29ya3MgaW4gaXRzIG93biB0aHJlYWQgKGEgd2ViIHdvcmtlcikgYW5kXG4gKiB0aGF0IHRyYW5zbXV4ZXIgbXV4ZXMgdGhlIGRhdGEgaW50byBhIG5hdGl2ZSBmb3JtYXQuIFZpcnR1YWxTb3VyY2VCdWZmZXIgd2lsbFxuICogdGhlbiBzZW5kIGFsbCBvZiB0aGF0IGRhdGEgdG8gdGhlIG5haXZlIHNvdXJjZWJ1ZmZlciBzbyB0aGF0IGl0IGlzXG4gKiBpbmRlc3Rpbmd1aXNoYWJsZSBmcm9tIGEgbmF0aXZlbHkgc3VwcG9ydGVkIGZvcm1hdC5cbiAqXG4gKiBAcGFyYW0ge0h0bWxNZWRpYVNvdXJjZX0gbWVkaWFTb3VyY2UgdGhlIHBhcmVudCBtZWRpYVNvdXJjZVxuICogQHBhcmFtIHtBcnJheX0gY29kZWNzIGFycmF5IG9mIGNvZGVjcyB0aGF0IHdlIHdpbGwgYmUgZGVhbGluZyB3aXRoXG4gKiBAY2xhc3MgVmlydHVhbFNvdXJjZUJ1ZmZlclxuICogQGV4dGVuZHMgdmlkZW8uanMuRXZlbnRUYXJnZXRcbiAqL1xuXG52YXIgVmlydHVhbFNvdXJjZUJ1ZmZlciA9IChmdW5jdGlvbiAoX3ZpZGVvanMkRXZlbnRUYXJnZXQpIHtcbiAgX2luaGVyaXRzKFZpcnR1YWxTb3VyY2VCdWZmZXIsIF92aWRlb2pzJEV2ZW50VGFyZ2V0KTtcblxuICBmdW5jdGlvbiBWaXJ0dWFsU291cmNlQnVmZmVyKG1lZGlhU291cmNlLCBjb2RlY3MpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFZpcnR1YWxTb3VyY2VCdWZmZXIpO1xuXG4gICAgX2dldChPYmplY3QuZ2V0UHJvdG90eXBlT2YoVmlydHVhbFNvdXJjZUJ1ZmZlci5wcm90b3R5cGUpLCAnY29uc3RydWN0b3InLCB0aGlzKS5jYWxsKHRoaXMsIF92aWRlb0pzMlsnZGVmYXVsdCddLkV2ZW50VGFyZ2V0KTtcbiAgICB0aGlzLnRpbWVzdGFtcE9mZnNldF8gPSAwO1xuICAgIHRoaXMucGVuZGluZ0J1ZmZlcnNfID0gW107XG4gICAgdGhpcy5idWZmZXJVcGRhdGluZ18gPSBmYWxzZTtcblxuICAgIHRoaXMubWVkaWFTb3VyY2VfID0gbWVkaWFTb3VyY2U7XG4gICAgdGhpcy5jb2RlY3NfID0gY29kZWNzO1xuICAgIHRoaXMuYXVkaW9Db2RlY18gPSBudWxsO1xuICAgIHRoaXMudmlkZW9Db2RlY18gPSBudWxsO1xuICAgIHRoaXMuYXVkaW9EaXNhYmxlZF8gPSBmYWxzZTtcbiAgICB0aGlzLmFwcGVuZEF1ZGlvSW5pdFNlZ21lbnRfID0gdHJ1ZTtcbiAgICB0aGlzLmdvcEJ1ZmZlcl8gPSBbXTtcbiAgICB0aGlzLnRpbWVNYXBwaW5nXyA9IDA7XG4gICAgdGhpcy5zYWZlQXBwZW5kXyA9IF92aWRlb0pzMlsnZGVmYXVsdCddLmJyb3dzZXIuSUVfVkVSU0lPTiA+PSAxMTtcblxuICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgcmVtdXg6IGZhbHNlLFxuICAgICAgYWxpZ25Hb3BzQXRFbmQ6IHRoaXMuc2FmZUFwcGVuZF9cbiAgICB9O1xuXG4gICAgdGhpcy5jb2RlY3NfLmZvckVhY2goZnVuY3Rpb24gKGNvZGVjKSB7XG4gICAgICBpZiAoKDAsIF9jb2RlY1V0aWxzLmlzQXVkaW9Db2RlYykoY29kZWMpKSB7XG4gICAgICAgIF90aGlzLmF1ZGlvQ29kZWNfID0gY29kZWM7XG4gICAgICB9IGVsc2UgaWYgKCgwLCBfY29kZWNVdGlscy5pc1ZpZGVvQ29kZWMpKGNvZGVjKSkge1xuICAgICAgICBfdGhpcy52aWRlb0NvZGVjXyA9IGNvZGVjO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gYXBwZW5kIG11eGVkIHNlZ21lbnRzIHRvIHRoZWlyIHJlc3BlY3RpdmUgbmF0aXZlIGJ1ZmZlcnMgYXNcbiAgICAvLyBzb29uIGFzIHRoZXkgYXJlIGF2YWlsYWJsZVxuICAgIHRoaXMudHJhbnNtdXhlcl8gPSAoMCwgX3dlYndhY2tpZnkyWydkZWZhdWx0J10pKF90cmFuc211eGVyV29ya2VyMlsnZGVmYXVsdCddLCByZXNvbHZlVHJhbnNtdXhXb3JrZXIoKSk7XG4gICAgdGhpcy50cmFuc211eGVyXy5wb3N0TWVzc2FnZSh7IGFjdGlvbjogJ2luaXQnLCBvcHRpb25zOiBvcHRpb25zIH0pO1xuXG4gICAgdGhpcy50cmFuc211eGVyXy5vbm1lc3NhZ2UgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIGlmIChldmVudC5kYXRhLmFjdGlvbiA9PT0gJ2RhdGEnKSB7XG4gICAgICAgIHJldHVybiBfdGhpcy5kYXRhXyhldmVudCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChldmVudC5kYXRhLmFjdGlvbiA9PT0gJ2RvbmUnKSB7XG4gICAgICAgIHJldHVybiBfdGhpcy5kb25lXyhldmVudCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChldmVudC5kYXRhLmFjdGlvbiA9PT0gJ2dvcEluZm8nKSB7XG4gICAgICAgIHJldHVybiBfdGhpcy5hcHBlbmRHb3BJbmZvXyhldmVudCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8vIHRoaXMgdGltZXN0YW1wT2Zmc2V0IGlzIGEgcHJvcGVydHkgd2l0aCB0aGUgc2lkZS1lZmZlY3Qgb2YgcmVzZXR0aW5nXG4gICAgLy8gYmFzZU1lZGlhRGVjb2RlVGltZSBpbiB0aGUgdHJhbnNtdXhlciBvbiB0aGUgc2V0dGVyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICd0aW1lc3RhbXBPZmZzZXQnLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGltZXN0YW1wT2Zmc2V0XztcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWwpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInICYmIHZhbCA+PSAwKSB7XG4gICAgICAgICAgdGhpcy50aW1lc3RhbXBPZmZzZXRfID0gdmFsO1xuICAgICAgICAgIHRoaXMuYXBwZW5kQXVkaW9Jbml0U2VnbWVudF8gPSB0cnVlO1xuXG4gICAgICAgICAgLy8gcmVzZXQgZ29wIGJ1ZmZlciBvbiB0aW1lc3RhbXBvZmZzZXQgYXMgdGhpcyBzaWduYWxzIGEgY2hhbmdlIGluIHRpbWVsaW5lXG4gICAgICAgICAgdGhpcy5nb3BCdWZmZXJfLmxlbmd0aCA9IDA7XG4gICAgICAgICAgdGhpcy50aW1lTWFwcGluZ18gPSAwO1xuXG4gICAgICAgICAgLy8gV2UgaGF2ZSB0byB0ZWxsIHRoZSB0cmFuc211eGVyIHRvIHNldCB0aGUgYmFzZU1lZGlhRGVjb2RlVGltZSB0b1xuICAgICAgICAgIC8vIHRoZSBkZXNpcmVkIHRpbWVzdGFtcE9mZnNldCBmb3IgdGhlIG5leHQgc2VnbWVudFxuICAgICAgICAgIHRoaXMudHJhbnNtdXhlcl8ucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgYWN0aW9uOiAnc2V0VGltZXN0YW1wT2Zmc2V0JyxcbiAgICAgICAgICAgIHRpbWVzdGFtcE9mZnNldDogdmFsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIHNldHRpbmcgdGhlIGFwcGVuZCB3aW5kb3cgYWZmZWN0cyBib3RoIHNvdXJjZSBidWZmZXJzXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdhcHBlbmRXaW5kb3dTdGFydCcsIHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gKHRoaXMudmlkZW9CdWZmZXJfIHx8IHRoaXMuYXVkaW9CdWZmZXJfKS5hcHBlbmRXaW5kb3dTdGFydDtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldChzdGFydCkge1xuICAgICAgICBpZiAodGhpcy52aWRlb0J1ZmZlcl8pIHtcbiAgICAgICAgICB0aGlzLnZpZGVvQnVmZmVyXy5hcHBlbmRXaW5kb3dTdGFydCA9IHN0YXJ0O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmF1ZGlvQnVmZmVyXykge1xuICAgICAgICAgIHRoaXMuYXVkaW9CdWZmZXJfLmFwcGVuZFdpbmRvd1N0YXJ0ID0gc3RhcnQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIHRoaXMgYnVmZmVyIGlzIFwidXBkYXRpbmdcIiBpZiBlaXRoZXIgb2YgaXRzIG5hdGl2ZSBidWZmZXJzIGFyZVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAndXBkYXRpbmcnLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuICEhKHRoaXMuYnVmZmVyVXBkYXRpbmdfIHx8ICF0aGlzLmF1ZGlvRGlzYWJsZWRfICYmIHRoaXMuYXVkaW9CdWZmZXJfICYmIHRoaXMuYXVkaW9CdWZmZXJfLnVwZGF0aW5nIHx8IHRoaXMudmlkZW9CdWZmZXJfICYmIHRoaXMudmlkZW9CdWZmZXJfLnVwZGF0aW5nKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIHRoZSBidWZmZXJlZCBwcm9wZXJ0eSBpcyB0aGUgaW50ZXJzZWN0aW9uIG9mIHRoZSBidWZmZXJlZFxuICAgIC8vIHJhbmdlcyBvZiB0aGUgbmF0aXZlIHNvdXJjZSBidWZmZXJzXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdidWZmZXJlZCcsIHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICB2YXIgc3RhcnQgPSBudWxsO1xuICAgICAgICB2YXIgZW5kID0gbnVsbDtcbiAgICAgICAgdmFyIGFyaXR5ID0gMDtcbiAgICAgICAgdmFyIGV4dGVudHMgPSBbXTtcbiAgICAgICAgdmFyIHJhbmdlcyA9IFtdO1xuXG4gICAgICAgIC8vIG5laXRoZXIgYnVmZmVyIGhhcyBiZWVuIGNyZWF0ZWQgeWV0XG4gICAgICAgIGlmICghdGhpcy52aWRlb0J1ZmZlcl8gJiYgIXRoaXMuYXVkaW9CdWZmZXJfKSB7XG4gICAgICAgICAgcmV0dXJuIF92aWRlb0pzMlsnZGVmYXVsdCddLmNyZWF0ZVRpbWVSYW5nZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gb25seSBvbmUgYnVmZmVyIGlzIGNvbmZpZ3VyZWRcbiAgICAgICAgaWYgKCF0aGlzLnZpZGVvQnVmZmVyXykge1xuICAgICAgICAgIHJldHVybiB0aGlzLmF1ZGlvQnVmZmVyXy5idWZmZXJlZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuYXVkaW9CdWZmZXJfKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudmlkZW9CdWZmZXJfLmJ1ZmZlcmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYm90aCBidWZmZXJzIGFyZSBjb25maWd1cmVkXG4gICAgICAgIGlmICh0aGlzLmF1ZGlvRGlzYWJsZWRfKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudmlkZW9CdWZmZXJfLmJ1ZmZlcmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYm90aCBidWZmZXJzIGFyZSBlbXB0eVxuICAgICAgICBpZiAodGhpcy52aWRlb0J1ZmZlcl8uYnVmZmVyZWQubGVuZ3RoID09PSAwICYmIHRoaXMuYXVkaW9CdWZmZXJfLmJ1ZmZlcmVkLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiBfdmlkZW9KczJbJ2RlZmF1bHQnXS5jcmVhdGVUaW1lUmFuZ2UoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEhhbmRsZSB0aGUgY2FzZSB3aGVyZSB3ZSBoYXZlIGJvdGggYnVmZmVycyBhbmQgY3JlYXRlIGFuXG4gICAgICAgIC8vIGludGVyc2VjdGlvbiBvZiB0aGUgdHdvXG4gICAgICAgIHZhciB2aWRlb0J1ZmZlcmVkID0gdGhpcy52aWRlb0J1ZmZlcl8uYnVmZmVyZWQ7XG4gICAgICAgIHZhciBhdWRpb0J1ZmZlcmVkID0gdGhpcy5hdWRpb0J1ZmZlcl8uYnVmZmVyZWQ7XG4gICAgICAgIHZhciBjb3VudCA9IHZpZGVvQnVmZmVyZWQubGVuZ3RoO1xuXG4gICAgICAgIC8vIEEpIEdhdGhlciB1cCBhbGwgc3RhcnQgYW5kIGVuZCB0aW1lc1xuICAgICAgICB3aGlsZSAoY291bnQtLSkge1xuICAgICAgICAgIGV4dGVudHMucHVzaCh7IHRpbWU6IHZpZGVvQnVmZmVyZWQuc3RhcnQoY291bnQpLCB0eXBlOiAnc3RhcnQnIH0pO1xuICAgICAgICAgIGV4dGVudHMucHVzaCh7IHRpbWU6IHZpZGVvQnVmZmVyZWQuZW5kKGNvdW50KSwgdHlwZTogJ2VuZCcgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY291bnQgPSBhdWRpb0J1ZmZlcmVkLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGNvdW50LS0pIHtcbiAgICAgICAgICBleHRlbnRzLnB1c2goeyB0aW1lOiBhdWRpb0J1ZmZlcmVkLnN0YXJ0KGNvdW50KSwgdHlwZTogJ3N0YXJ0JyB9KTtcbiAgICAgICAgICBleHRlbnRzLnB1c2goeyB0aW1lOiBhdWRpb0J1ZmZlcmVkLmVuZChjb3VudCksIHR5cGU6ICdlbmQnIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIEIpIFNvcnQgdGhlbSBieSB0aW1lXG4gICAgICAgIGV4dGVudHMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgIHJldHVybiBhLnRpbWUgLSBiLnRpbWU7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIEMpIEdvIGFsb25nIG9uZSBieSBvbmUgaW5jcmVtZW50aW5nIGFyaXR5IGZvciBzdGFydCBhbmQgZGVjcmVtZW50aW5nXG4gICAgICAgIC8vICAgIGFyaXR5IGZvciBlbmRzXG4gICAgICAgIGZvciAoY291bnQgPSAwOyBjb3VudCA8IGV4dGVudHMubGVuZ3RoOyBjb3VudCsrKSB7XG4gICAgICAgICAgaWYgKGV4dGVudHNbY291bnRdLnR5cGUgPT09ICdzdGFydCcpIHtcbiAgICAgICAgICAgIGFyaXR5Kys7XG5cbiAgICAgICAgICAgIC8vIEQpIElmIGFyaXR5IGlzIGV2ZXIgaW5jcmVtZW50ZWQgdG8gMiB3ZSBhcmUgZW50ZXJpbmcgYW5cbiAgICAgICAgICAgIC8vICAgIG92ZXJsYXBwaW5nIHJhbmdlXG4gICAgICAgICAgICBpZiAoYXJpdHkgPT09IDIpIHtcbiAgICAgICAgICAgICAgc3RhcnQgPSBleHRlbnRzW2NvdW50XS50aW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoZXh0ZW50c1tjb3VudF0udHlwZSA9PT0gJ2VuZCcpIHtcbiAgICAgICAgICAgIGFyaXR5LS07XG5cbiAgICAgICAgICAgIC8vIEUpIElmIGFyaXR5IGlzIGV2ZXIgZGVjcmVtZW50ZWQgdG8gMSB3ZSBsZWF2aW5nIGFuXG4gICAgICAgICAgICAvLyAgICBvdmVybGFwcGluZyByYW5nZVxuICAgICAgICAgICAgaWYgKGFyaXR5ID09PSAxKSB7XG4gICAgICAgICAgICAgIGVuZCA9IGV4dGVudHNbY291bnRdLnRpbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gRikgUmVjb3JkIG92ZXJsYXBwaW5nIHJhbmdlc1xuICAgICAgICAgIGlmIChzdGFydCAhPT0gbnVsbCAmJiBlbmQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJhbmdlcy5wdXNoKFtzdGFydCwgZW5kXSk7XG4gICAgICAgICAgICBzdGFydCA9IG51bGw7XG4gICAgICAgICAgICBlbmQgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBfdmlkZW9KczJbJ2RlZmF1bHQnXS5jcmVhdGVUaW1lUmFuZ2VzKHJhbmdlcyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogV2hlbiB3ZSBnZXQgYSBkYXRhIGV2ZW50IGZyb20gdGhlIHRyYW5zbXV4ZXJcbiAgICogd2UgY2FsbCB0aGlzIGZ1bmN0aW9uIGFuZCBoYW5kbGUgdGhlIGRhdGEgdGhhdFxuICAgKiB3YXMgc2VudCB0byB1c1xuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudCB0aGUgZGF0YSBldmVudCBmcm9tIHRoZSB0cmFuc211eGVyXG4gICAqL1xuXG4gIF9jcmVhdGVDbGFzcyhWaXJ0dWFsU291cmNlQnVmZmVyLCBbe1xuICAgIGtleTogJ2RhdGFfJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGF0YV8oZXZlbnQpIHtcbiAgICAgIHZhciBzZWdtZW50ID0gZXZlbnQuZGF0YS5zZWdtZW50O1xuXG4gICAgICAvLyBDYXN0IEFycmF5QnVmZmVyIHRvIFR5cGVkQXJyYXlcbiAgICAgIHNlZ21lbnQuZGF0YSA9IG5ldyBVaW50OEFycmF5KHNlZ21lbnQuZGF0YSwgZXZlbnQuZGF0YS5ieXRlT2Zmc2V0LCBldmVudC5kYXRhLmJ5dGVMZW5ndGgpO1xuXG4gICAgICBzZWdtZW50LmluaXRTZWdtZW50ID0gbmV3IFVpbnQ4QXJyYXkoc2VnbWVudC5pbml0U2VnbWVudC5kYXRhLCBzZWdtZW50LmluaXRTZWdtZW50LmJ5dGVPZmZzZXQsIHNlZ21lbnQuaW5pdFNlZ21lbnQuYnl0ZUxlbmd0aCk7XG5cbiAgICAgICgwLCBfY3JlYXRlVGV4dFRyYWNrc0lmTmVjZXNzYXJ5MlsnZGVmYXVsdCddKSh0aGlzLCB0aGlzLm1lZGlhU291cmNlXywgc2VnbWVudCk7XG5cbiAgICAgIC8vIEFkZCB0aGUgc2VnbWVudHMgdG8gdGhlIHBlbmRpbmdCdWZmZXJzIGFycmF5XG4gICAgICB0aGlzLnBlbmRpbmdCdWZmZXJzXy5wdXNoKHNlZ21lbnQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFdoZW4gd2UgZ2V0IGEgZG9uZSBldmVudCBmcm9tIHRoZSB0cmFuc211eGVyXG4gICAgICogd2UgY2FsbCB0aGlzIGZ1bmN0aW9uIGFuZCB3ZSBwcm9jZXNzIGFsbFxuICAgICAqIG9mIHRoZSBwZW5kaW5nIGRhdGEgdGhhdCB3ZSBoYXZlIGJlZW4gc2F2aW5nIGluIHRoZVxuICAgICAqIGRhdGFfIGZ1bmN0aW9uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IHRoZSBkb25lIGV2ZW50IGZyb20gdGhlIHRyYW5zbXV4ZXJcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ2RvbmVfJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZG9uZV8oZXZlbnQpIHtcbiAgICAgIC8vIERvbid0IHByb2Nlc3MgYW5kIGFwcGVuZCBkYXRhIGlmIHRoZSBtZWRpYVNvdXJjZSBpcyBjbG9zZWRcbiAgICAgIGlmICh0aGlzLm1lZGlhU291cmNlXy5yZWFkeVN0YXRlID09PSAnY2xvc2VkJykge1xuICAgICAgICB0aGlzLnBlbmRpbmdCdWZmZXJzXy5sZW5ndGggPSAwO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIEFsbCBidWZmZXJzIHNob3VsZCBoYXZlIGJlZW4gZmx1c2hlZCBmcm9tIHRoZSBtdXhlclxuICAgICAgLy8gc3RhcnQgcHJvY2Vzc2luZyBhbnl0aGluZyB3ZSBoYXZlIHJlY2VpdmVkXG4gICAgICB0aGlzLnByb2Nlc3NQZW5kaW5nU2VnbWVudHNfKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIG91ciBpbnRlcm5hbCBuYXRpdmUgYXVkaW8vdmlkZW8gc291cmNlIGJ1ZmZlcnMgYW5kIGFkZFxuICAgICAqIGV2ZW50IGhhbmRsZXJzIHRvIHRoZW0gd2l0aCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gICAgICogMS4gdGhleSBkbyBub3QgYWxyZWFkeSBleGlzdCBvbiB0aGUgbWVkaWFTb3VyY2VcbiAgICAgKiAyLiB0aGlzIFZTQiBoYXMgYSBjb2RlYyBmb3IgdGhlbVxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ2NyZWF0ZVJlYWxTb3VyY2VCdWZmZXJzXycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZVJlYWxTb3VyY2VCdWZmZXJzXygpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICB2YXIgdHlwZXMgPSBbJ2F1ZGlvJywgJ3ZpZGVvJ107XG5cbiAgICAgIHR5cGVzLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgLy8gRG9uJ3QgY3JlYXRlIGEgU291cmNlQnVmZmVyIG9mIHRoaXMgdHlwZSBpZiB3ZSBkb24ndCBoYXZlIGFcbiAgICAgICAgLy8gY29kZWMgZm9yIGl0XG4gICAgICAgIGlmICghX3RoaXMyW3R5cGUgKyAnQ29kZWNfJ10pIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEbyBub3RoaW5nIGlmIGEgU291cmNlQnVmZmVyIG9mIHRoaXMgdHlwZSBhbHJlYWR5IGV4aXN0c1xuICAgICAgICBpZiAoX3RoaXMyW3R5cGUgKyAnQnVmZmVyXyddKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGJ1ZmZlciA9IG51bGw7XG5cbiAgICAgICAgLy8gSWYgdGhlIG1lZGlhc291cmNlIGFscmVhZHkgaGFzIGEgU291cmNlQnVmZmVyIGZvciB0aGUgY29kZWNcbiAgICAgICAgLy8gdXNlIHRoYXRcbiAgICAgICAgaWYgKF90aGlzMi5tZWRpYVNvdXJjZV9bdHlwZSArICdCdWZmZXJfJ10pIHtcbiAgICAgICAgICBidWZmZXIgPSBfdGhpczIubWVkaWFTb3VyY2VfW3R5cGUgKyAnQnVmZmVyXyddO1xuICAgICAgICAgIC8vIEluIG11bHRpcGxlIGF1ZGlvIHRyYWNrIGNhc2VzLCB0aGUgYXVkaW8gc291cmNlIGJ1ZmZlciBpcyBkaXNhYmxlZFxuICAgICAgICAgIC8vIG9uIHRoZSBtYWluIFZpcnR1YWxTb3VyY2VCdWZmZXIgYnkgdGhlIEhUTUxNZWRpYVNvdXJjZSBtdWNoIGVhcmxpZXJcbiAgICAgICAgICAvLyB0aGFuIGNyZWF0ZVJlYWxTb3VyY2VCdWZmZXJzXyBpcyBjYWxsZWQgdG8gY3JlYXRlIHRoZSBzZWNvbmRcbiAgICAgICAgICAvLyBWaXJ0dWFsU291cmNlQnVmZmVyIGJlY2F1c2UgdGhhdCBoYXBwZW5zIGFzIGEgc2lkZS1lZmZlY3Qgb2ZcbiAgICAgICAgICAvLyB2aWRlb2pzLWNvbnRyaWItaGxzIHN0YXJ0aW5nIHRoZSBhdWRpb1NlZ21lbnRMb2FkZXIuIEFzIGEgcmVzdWx0LFxuICAgICAgICAgIC8vIHRoZSBhdWRpb0J1ZmZlciBpcyBlc3NlbnRpYWxseSBcIm93bmVybGVzc1wiIGFuZCBubyBvbmUgd2lsbCB0b2dnbGVcbiAgICAgICAgICAvLyB0aGUgYHVwZGF0aW5nYCBzdGF0ZSBiYWNrIHRvIGZhbHNlIG9uY2UgdGhlIGB1cGRhdGVlbmRgIGV2ZW50IGlzIHJlY2VpdmVkXG4gICAgICAgICAgLy9cbiAgICAgICAgICAvLyBTZXR0aW5nIGB1cGRhdGluZ2AgdG8gZmFsc2UgbWFudWFsbHkgd2lsbCB3b3JrIGFyb3VuZCB0aGlzXG4gICAgICAgICAgLy8gc2l0dWF0aW9uIGFuZCBhbGxvdyB3b3JrIHRvIGNvbnRpbnVlXG4gICAgICAgICAgYnVmZmVyLnVwZGF0aW5nID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGNvZGVjUHJvcGVydHkgPSB0eXBlICsgJ0NvZGVjXyc7XG4gICAgICAgICAgdmFyIG1pbWVUeXBlID0gdHlwZSArICcvbXA0O2NvZGVjcz1cIicgKyBfdGhpczJbY29kZWNQcm9wZXJ0eV0gKyAnXCInO1xuXG4gICAgICAgICAgYnVmZmVyID0gbWFrZVdyYXBwZWRTb3VyY2VCdWZmZXIoX3RoaXMyLm1lZGlhU291cmNlXy5uYXRpdmVNZWRpYVNvdXJjZV8sIG1pbWVUeXBlKTtcblxuICAgICAgICAgIF90aGlzMi5tZWRpYVNvdXJjZV9bdHlwZSArICdCdWZmZXJfJ10gPSBidWZmZXI7XG4gICAgICAgIH1cblxuICAgICAgICBfdGhpczJbdHlwZSArICdCdWZmZXJfJ10gPSBidWZmZXI7XG5cbiAgICAgICAgLy8gV2lyZSB1cCB0aGUgZXZlbnRzIHRvIHRoZSBTb3VyY2VCdWZmZXJcbiAgICAgICAgWyd1cGRhdGUnLCAndXBkYXRlc3RhcnQnLCAndXBkYXRlZW5kJ10uZm9yRWFjaChmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICBidWZmZXIuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gaWYgYXVkaW8gaXMgZGlzYWJsZWRcbiAgICAgICAgICAgIGlmICh0eXBlID09PSAnYXVkaW8nICYmIF90aGlzMi5hdWRpb0Rpc2FibGVkXykge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChldmVudCA9PT0gJ3VwZGF0ZWVuZCcpIHtcbiAgICAgICAgICAgICAgX3RoaXMyW3R5cGUgKyAnQnVmZmVyXyddLnVwZGF0aW5nID0gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBzaG91bGRUcmlnZ2VyID0gdHlwZXMuZXZlcnkoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgICAgLy8gc2tpcCBjaGVja2luZyBhdWRpbydzIHVwZGF0aW5nIHN0YXR1cyBpZiBhdWRpb1xuICAgICAgICAgICAgICAvLyBpcyBub3QgZW5hYmxlZFxuICAgICAgICAgICAgICBpZiAodCA9PT0gJ2F1ZGlvJyAmJiBfdGhpczIuYXVkaW9EaXNhYmxlZF8pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLyBpZiB0aGUgb3RoZXIgdHlwZSBpZiB1cGRhdGluZyB3ZSBkb24ndCB0cmlnZ2VyXG4gICAgICAgICAgICAgIGlmICh0eXBlICE9PSB0ICYmIF90aGlzMlt0ICsgJ0J1ZmZlcl8nXSAmJiBfdGhpczJbdCArICdCdWZmZXJfJ10udXBkYXRpbmcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKHNob3VsZFRyaWdnZXIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIF90aGlzMi50cmlnZ2VyKGV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFbXVsYXRlIHRoZSBuYXRpdmUgbWVkaWFzb3VyY2UgZnVuY3Rpb24sIGJ1dCBvdXIgZnVuY3Rpb24gd2lsbFxuICAgICAqIHNlbmQgYWxsIG9mIHRoZSBwcm9wb3NlZCBzZWdtZW50cyB0byB0aGUgdHJhbnNtdXhlciBzbyB0aGF0IHdlXG4gICAgICogY2FuIHRyYW5zbXV4IHRoZW0gYmVmb3JlIHdlIGFwcGVuZCB0aGVtIHRvIG91ciBpbnRlcm5hbFxuICAgICAqIG5hdGl2ZSBzb3VyY2UgYnVmZmVycyBpbiB0aGUgY29ycmVjdCBmb3JtYXQuXG4gICAgICpcbiAgICAgKiBAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvU291cmNlQnVmZmVyL2FwcGVuZEJ1ZmZlclxuICAgICAqIEBwYXJhbSB7VWludDhBcnJheX0gc2VnbWVudCB0aGUgc2VnbWVudCB0byBhcHBlbmQgdG8gdGhlIGJ1ZmZlclxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnYXBwZW5kQnVmZmVyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXBwZW5kQnVmZmVyKHNlZ21lbnQpIHtcbiAgICAgIC8vIFN0YXJ0IHRoZSBpbnRlcm5hbCBcInVwZGF0aW5nXCIgc3RhdGVcbiAgICAgIHRoaXMuYnVmZmVyVXBkYXRpbmdfID0gdHJ1ZTtcblxuICAgICAgaWYgKHRoaXMuYXVkaW9CdWZmZXJfICYmIHRoaXMuYXVkaW9CdWZmZXJfLmJ1ZmZlcmVkLmxlbmd0aCkge1xuICAgICAgICB2YXIgYXVkaW9CdWZmZXJlZCA9IHRoaXMuYXVkaW9CdWZmZXJfLmJ1ZmZlcmVkO1xuXG4gICAgICAgIHRoaXMudHJhbnNtdXhlcl8ucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgIGFjdGlvbjogJ3NldEF1ZGlvQXBwZW5kU3RhcnQnLFxuICAgICAgICAgIGFwcGVuZFN0YXJ0OiBhdWRpb0J1ZmZlcmVkLmVuZChhdWRpb0J1ZmZlcmVkLmxlbmd0aCAtIDEpXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy52aWRlb0J1ZmZlcl8pIHtcbiAgICAgICAgdGhpcy50cmFuc211eGVyXy5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgYWN0aW9uOiAnYWxpZ25Hb3BzV2l0aCcsXG4gICAgICAgICAgZ29wc1RvQWxpZ25XaXRoOiBnb3BzU2FmZVRvQWxpZ25XaXRoKHRoaXMuZ29wQnVmZmVyXywgdGhpcy5tZWRpYVNvdXJjZV8ucGxheWVyXywgdGhpcy50aW1lTWFwcGluZ18pXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnRyYW5zbXV4ZXJfLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgYWN0aW9uOiAncHVzaCcsXG4gICAgICAgIC8vIFNlbmQgdGhlIHR5cGVkLWFycmF5IG9mIGRhdGEgYXMgYW4gQXJyYXlCdWZmZXIgc28gdGhhdFxuICAgICAgICAvLyBpdCBjYW4gYmUgc2VudCBhcyBhIFwiVHJhbnNmZXJhYmxlXCIgYW5kIGF2b2lkIHRoZSBjb3N0bHlcbiAgICAgICAgLy8gbWVtb3J5IGNvcHlcbiAgICAgICAgZGF0YTogc2VnbWVudC5idWZmZXIsXG5cbiAgICAgICAgLy8gVG8gcmVjcmVhdGUgdGhlIG9yaWdpbmFsIHR5cGVkLWFycmF5LCB3ZSBuZWVkIGluZm9ybWF0aW9uXG4gICAgICAgIC8vIGFib3V0IHdoYXQgcG9ydGlvbiBvZiB0aGUgQXJyYXlCdWZmZXIgaXQgd2FzIGEgdmlldyBpbnRvXG4gICAgICAgIGJ5dGVPZmZzZXQ6IHNlZ21lbnQuYnl0ZU9mZnNldCxcbiAgICAgICAgYnl0ZUxlbmd0aDogc2VnbWVudC5ieXRlTGVuZ3RoXG4gICAgICB9LCBbc2VnbWVudC5idWZmZXJdKTtcbiAgICAgIHRoaXMudHJhbnNtdXhlcl8ucG9zdE1lc3NhZ2UoeyBhY3Rpb246ICdmbHVzaCcgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXBwZW5kcyBnb3AgaW5mb3JtYXRpb24gKHRpbWluZyBhbmQgYnl0ZUxlbmd0aCkgcmVjZWl2ZWQgYnkgdGhlIHRyYW5zbXV4ZXIgZm9yIHRoZVxuICAgICAqIGdvcHMgYXBwZW5kZWQgaW4gdGhlIGxhc3QgY2FsbCB0byBhcHBlbmRCdWZmZXJcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gICAgICogICAgICAgIFRoZSBnb3BJbmZvIGV2ZW50IGZyb20gdGhlIHRyYW5zbXV4ZXJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBldmVudC5kYXRhLmdvcEluZm9cbiAgICAgKiAgICAgICAgTGlzdCBvZiBnb3AgaW5mbyB0byBhcHBlbmRcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ2FwcGVuZEdvcEluZm9fJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXBwZW5kR29wSW5mb18oZXZlbnQpIHtcbiAgICAgIHRoaXMuZ29wQnVmZmVyXyA9IHVwZGF0ZUdvcEJ1ZmZlcih0aGlzLmdvcEJ1ZmZlcl8sIGV2ZW50LmRhdGEuZ29wSW5mbywgdGhpcy5zYWZlQXBwZW5kXyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRW11bGF0ZSB0aGUgbmF0aXZlIG1lZGlhc291cmNlIGZ1bmN0aW9uIGFuZCByZW1vdmUgcGFydHNcbiAgICAgKiBvZiB0aGUgYnVmZmVyIGZyb20gYW55IG9mIG91ciBpbnRlcm5hbCBidWZmZXJzIHRoYXQgZXhpc3RcbiAgICAgKlxuICAgICAqIEBsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9Tb3VyY2VCdWZmZXIvcmVtb3ZlXG4gICAgICogQHBhcmFtIHtEb3VibGV9IHN0YXJ0IHBvc2l0aW9uIHRvIHN0YXJ0IHRoZSByZW1vdmUgYXRcbiAgICAgKiBAcGFyYW0ge0RvdWJsZX0gZW5kIHBvc2l0aW9uIHRvIGVuZCB0aGUgcmVtb3ZlIGF0XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdyZW1vdmUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmUoc3RhcnQsIGVuZCkge1xuICAgICAgaWYgKHRoaXMudmlkZW9CdWZmZXJfKSB7XG4gICAgICAgIHRoaXMudmlkZW9CdWZmZXJfLnVwZGF0aW5nID0gdHJ1ZTtcbiAgICAgICAgdGhpcy52aWRlb0J1ZmZlcl8ucmVtb3ZlKHN0YXJ0LCBlbmQpO1xuICAgICAgICB0aGlzLmdvcEJ1ZmZlcl8gPSByZW1vdmVHb3BCdWZmZXIodGhpcy5nb3BCdWZmZXJfLCBzdGFydCwgZW5kLCB0aGlzLnRpbWVNYXBwaW5nXyk7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuYXVkaW9EaXNhYmxlZF8gJiYgdGhpcy5hdWRpb0J1ZmZlcl8pIHtcbiAgICAgICAgdGhpcy5hdWRpb0J1ZmZlcl8udXBkYXRpbmcgPSB0cnVlO1xuICAgICAgICB0aGlzLmF1ZGlvQnVmZmVyXy5yZW1vdmUoc3RhcnQsIGVuZCk7XG4gICAgICB9XG5cbiAgICAgIC8vIFJlbW92ZSBNZXRhZGF0YSBDdWVzIChpZDMpXG4gICAgICAoMCwgX3JlbW92ZUN1ZXNGcm9tVHJhY2syWydkZWZhdWx0J10pKHN0YXJ0LCBlbmQsIHRoaXMubWV0YWRhdGFUcmFja18pO1xuXG4gICAgICAvLyBSZW1vdmUgQW55IENhcHRpb25zXG4gICAgICBpZiAodGhpcy5pbmJhbmRUZXh0VHJhY2tzXykge1xuICAgICAgICBmb3IgKHZhciB0cmFjayBpbiB0aGlzLmluYmFuZFRleHRUcmFja3NfKSB7XG4gICAgICAgICAgKDAsIF9yZW1vdmVDdWVzRnJvbVRyYWNrMlsnZGVmYXVsdCddKShzdGFydCwgZW5kLCB0aGlzLmluYmFuZFRleHRUcmFja3NfW3RyYWNrXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQcm9jZXNzIGFueSBzZWdtZW50cyB0aGF0IHRoZSBtdXhlciBoYXMgb3V0cHV0XG4gICAgICogQ29uY2F0ZW5hdGUgc2VnbWVudHMgdG9nZXRoZXIgYmFzZWQgb24gdHlwZSBhbmQgYXBwZW5kIHRoZW0gaW50b1xuICAgICAqIHRoZWlyIHJlc3BlY3RpdmUgc291cmNlQnVmZmVyc1xuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ3Byb2Nlc3NQZW5kaW5nU2VnbWVudHNfJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJvY2Vzc1BlbmRpbmdTZWdtZW50c18oKSB7XG4gICAgICB2YXIgc29ydGVkU2VnbWVudHMgPSB7XG4gICAgICAgIHZpZGVvOiB7XG4gICAgICAgICAgc2VnbWVudHM6IFtdLFxuICAgICAgICAgIGJ5dGVzOiAwXG4gICAgICAgIH0sXG4gICAgICAgIGF1ZGlvOiB7XG4gICAgICAgICAgc2VnbWVudHM6IFtdLFxuICAgICAgICAgIGJ5dGVzOiAwXG4gICAgICAgIH0sXG4gICAgICAgIGNhcHRpb25zOiBbXSxcbiAgICAgICAgbWV0YWRhdGE6IFtdXG4gICAgICB9O1xuXG4gICAgICAvLyBTb3J0IHNlZ21lbnRzIGludG8gc2VwYXJhdGUgdmlkZW8vYXVkaW8gYXJyYXlzIGFuZFxuICAgICAgLy8ga2VlcCB0cmFjayBvZiB0aGVpciB0b3RhbCBieXRlIGxlbmd0aHNcbiAgICAgIHNvcnRlZFNlZ21lbnRzID0gdGhpcy5wZW5kaW5nQnVmZmVyc18ucmVkdWNlKGZ1bmN0aW9uIChzZWdtZW50T2JqLCBzZWdtZW50KSB7XG4gICAgICAgIHZhciB0eXBlID0gc2VnbWVudC50eXBlO1xuICAgICAgICB2YXIgZGF0YSA9IHNlZ21lbnQuZGF0YTtcbiAgICAgICAgdmFyIGluaXRTZWdtZW50ID0gc2VnbWVudC5pbml0U2VnbWVudDtcblxuICAgICAgICBzZWdtZW50T2JqW3R5cGVdLnNlZ21lbnRzLnB1c2goZGF0YSk7XG4gICAgICAgIHNlZ21lbnRPYmpbdHlwZV0uYnl0ZXMgKz0gZGF0YS5ieXRlTGVuZ3RoO1xuXG4gICAgICAgIHNlZ21lbnRPYmpbdHlwZV0uaW5pdFNlZ21lbnQgPSBpbml0U2VnbWVudDtcblxuICAgICAgICAvLyBHYXRoZXIgYW55IGNhcHRpb25zIGludG8gYSBzaW5nbGUgYXJyYXlcbiAgICAgICAgaWYgKHNlZ21lbnQuY2FwdGlvbnMpIHtcbiAgICAgICAgICBzZWdtZW50T2JqLmNhcHRpb25zID0gc2VnbWVudE9iai5jYXB0aW9ucy5jb25jYXQoc2VnbWVudC5jYXB0aW9ucyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2VnbWVudC5pbmZvKSB7XG4gICAgICAgICAgc2VnbWVudE9ialt0eXBlXS5pbmZvID0gc2VnbWVudC5pbmZvO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gR2F0aGVyIGFueSBtZXRhZGF0YSBpbnRvIGEgc2luZ2xlIGFycmF5XG4gICAgICAgIGlmIChzZWdtZW50Lm1ldGFkYXRhKSB7XG4gICAgICAgICAgc2VnbWVudE9iai5tZXRhZGF0YSA9IHNlZ21lbnRPYmoubWV0YWRhdGEuY29uY2F0KHNlZ21lbnQubWV0YWRhdGEpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHNlZ21lbnRPYmo7XG4gICAgICB9LCBzb3J0ZWRTZWdtZW50cyk7XG5cbiAgICAgIC8vIENyZWF0ZSB0aGUgcmVhbCBzb3VyY2UgYnVmZmVycyBpZiB0aGV5IGRvbid0IGV4aXN0IGJ5IG5vdyBzaW5jZSB3ZVxuICAgICAgLy8gZmluYWxseSBhcmUgc3VyZSB3aGF0IHRyYWNrcyBhcmUgY29udGFpbmVkIGluIHRoZSBzb3VyY2VcbiAgICAgIGlmICghdGhpcy52aWRlb0J1ZmZlcl8gJiYgIXRoaXMuYXVkaW9CdWZmZXJfKSB7XG4gICAgICAgIC8vIFJlbW92ZSBhbnkgY29kZWNzIHRoYXQgbWF5IGhhdmUgYmVlbiBzcGVjaWZpZWQgYnkgZGVmYXVsdCBidXRcbiAgICAgICAgLy8gYXJlIG5vIGxvbmdlciBhcHBsaWNhYmxlIG5vd1xuICAgICAgICBpZiAoc29ydGVkU2VnbWVudHMudmlkZW8uYnl0ZXMgPT09IDApIHtcbiAgICAgICAgICB0aGlzLnZpZGVvQ29kZWNfID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc29ydGVkU2VnbWVudHMuYXVkaW8uYnl0ZXMgPT09IDApIHtcbiAgICAgICAgICB0aGlzLmF1ZGlvQ29kZWNfID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY3JlYXRlUmVhbFNvdXJjZUJ1ZmZlcnNfKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzb3J0ZWRTZWdtZW50cy5hdWRpby5pbmZvKSB7XG4gICAgICAgIHRoaXMubWVkaWFTb3VyY2VfLnRyaWdnZXIoeyB0eXBlOiAnYXVkaW9pbmZvJywgaW5mbzogc29ydGVkU2VnbWVudHMuYXVkaW8uaW5mbyB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChzb3J0ZWRTZWdtZW50cy52aWRlby5pbmZvKSB7XG4gICAgICAgIHRoaXMubWVkaWFTb3VyY2VfLnRyaWdnZXIoeyB0eXBlOiAndmlkZW9pbmZvJywgaW5mbzogc29ydGVkU2VnbWVudHMudmlkZW8uaW5mbyB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuYXBwZW5kQXVkaW9Jbml0U2VnbWVudF8pIHtcbiAgICAgICAgaWYgKCF0aGlzLmF1ZGlvRGlzYWJsZWRfICYmIHRoaXMuYXVkaW9CdWZmZXJfKSB7XG4gICAgICAgICAgc29ydGVkU2VnbWVudHMuYXVkaW8uc2VnbWVudHMudW5zaGlmdChzb3J0ZWRTZWdtZW50cy5hdWRpby5pbml0U2VnbWVudCk7XG4gICAgICAgICAgc29ydGVkU2VnbWVudHMuYXVkaW8uYnl0ZXMgKz0gc29ydGVkU2VnbWVudHMuYXVkaW8uaW5pdFNlZ21lbnQuYnl0ZUxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFwcGVuZEF1ZGlvSW5pdFNlZ21lbnRfID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHZhciB0cmlnZ2VyVXBkYXRlZW5kID0gZmFsc2U7XG5cbiAgICAgIC8vIE1lcmdlIG11bHRpcGxlIHZpZGVvIGFuZCBhdWRpbyBzZWdtZW50cyBpbnRvIG9uZSBhbmQgYXBwZW5kXG4gICAgICBpZiAodGhpcy52aWRlb0J1ZmZlcl8gJiYgc29ydGVkU2VnbWVudHMudmlkZW8uYnl0ZXMpIHtcbiAgICAgICAgc29ydGVkU2VnbWVudHMudmlkZW8uc2VnbWVudHMudW5zaGlmdChzb3J0ZWRTZWdtZW50cy52aWRlby5pbml0U2VnbWVudCk7XG4gICAgICAgIHNvcnRlZFNlZ21lbnRzLnZpZGVvLmJ5dGVzICs9IHNvcnRlZFNlZ21lbnRzLnZpZGVvLmluaXRTZWdtZW50LmJ5dGVMZW5ndGg7XG4gICAgICAgIHRoaXMuY29uY2F0QW5kQXBwZW5kU2VnbWVudHNfKHNvcnRlZFNlZ21lbnRzLnZpZGVvLCB0aGlzLnZpZGVvQnVmZmVyXyk7XG4gICAgICAgIC8vIFRPRE86IGFyZSB2aWRlbyB0cmFja3MgdGhlIG9ubHkgb25lcyB3aXRoIHRleHQgdHJhY2tzP1xuICAgICAgICAoMCwgX2FkZFRleHRUcmFja0RhdGEuYWRkVGV4dFRyYWNrRGF0YSkodGhpcywgc29ydGVkU2VnbWVudHMuY2FwdGlvbnMsIHNvcnRlZFNlZ21lbnRzLm1ldGFkYXRhKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy52aWRlb0J1ZmZlcl8gJiYgKHRoaXMuYXVkaW9EaXNhYmxlZF8gfHwgIXRoaXMuYXVkaW9CdWZmZXJfKSkge1xuICAgICAgICAvLyBUaGUgdHJhbnNtdXhlciBkaWQgbm90IHJldHVybiBhbnkgYnl0ZXMgb2YgdmlkZW8sIG1lYW5pbmcgaXQgd2FzIGFsbCB0cmltbWVkXG4gICAgICAgIC8vIGZvciBnb3AgYWxpZ25tZW50LiBTaW5jZSB3ZSBoYXZlIGEgdmlkZW8gYnVmZmVyIGFuZCBhdWRpbyBpcyBkaXNhYmxlZCwgdXBkYXRlZW5kXG4gICAgICAgIC8vIHdpbGwgbmV2ZXIgYmUgdHJpZ2dlcmVkIGJ5IHRoaXMgc291cmNlIGJ1ZmZlciwgd2hpY2ggd2lsbCBjYXVzZSBjb250cmliLWhsc1xuICAgICAgICAvLyB0byBiZSBzdHVjayBmb3JldmVyIHdhaXRpbmcgZm9yIHVwZGF0ZWVuZC4gSWYgYXVkaW8gaXMgbm90IGRpc2FibGVkLCB1cGRhdGVlbmRcbiAgICAgICAgLy8gd2lsbCBiZSB0cmlnZ2VyZWQgYnkgdGhlIGF1ZGlvIGJ1ZmZlciwgd2hpY2ggd2lsbCBiZSBzZW50IHVwd2FyZHMgc2luY2UgdGhlIHZpZGVvXG4gICAgICAgIC8vIGJ1ZmZlciB3aWxsIG5vdCBiZSBpbiBhbiB1cGRhdGluZyBzdGF0ZS5cbiAgICAgICAgdHJpZ2dlclVwZGF0ZWVuZCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5hdWRpb0Rpc2FibGVkXyAmJiB0aGlzLmF1ZGlvQnVmZmVyXykge1xuICAgICAgICB0aGlzLmNvbmNhdEFuZEFwcGVuZFNlZ21lbnRzXyhzb3J0ZWRTZWdtZW50cy5hdWRpbywgdGhpcy5hdWRpb0J1ZmZlcl8pO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnBlbmRpbmdCdWZmZXJzXy5sZW5ndGggPSAwO1xuXG4gICAgICBpZiAodHJpZ2dlclVwZGF0ZWVuZCkge1xuICAgICAgICB0aGlzLnRyaWdnZXIoJ3VwZGF0ZWVuZCcpO1xuICAgICAgfVxuXG4gICAgICAvLyBXZSBhcmUgbm8gbG9uZ2VyIGluIHRoZSBpbnRlcm5hbCBcInVwZGF0aW5nXCIgc3RhdGVcbiAgICAgIHRoaXMuYnVmZmVyVXBkYXRpbmdfID0gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29tYmluZSBhbGwgc2VnbWVudHMgaW50byBhIHNpbmdsZSBVaW50OEFycmF5IGFuZCB0aGVuIGFwcGVuZCB0aGVtXG4gICAgICogdG8gdGhlIGRlc3RpbmF0aW9uIGJ1ZmZlclxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNlZ21lbnRPYmpcbiAgICAgKiBAcGFyYW0ge1NvdXJjZUJ1ZmZlcn0gZGVzdGluYXRpb25CdWZmZXIgbmF0aXZlIHNvdXJjZSBidWZmZXIgdG8gYXBwZW5kIGRhdGEgdG9cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnY29uY2F0QW5kQXBwZW5kU2VnbWVudHNfJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29uY2F0QW5kQXBwZW5kU2VnbWVudHNfKHNlZ21lbnRPYmosIGRlc3RpbmF0aW9uQnVmZmVyKSB7XG4gICAgICB2YXIgb2Zmc2V0ID0gMDtcbiAgICAgIHZhciB0ZW1wQnVmZmVyID0gdW5kZWZpbmVkO1xuXG4gICAgICBpZiAoc2VnbWVudE9iai5ieXRlcykge1xuICAgICAgICB0ZW1wQnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoc2VnbWVudE9iai5ieXRlcyk7XG5cbiAgICAgICAgLy8gQ29tYmluZSB0aGUgaW5kaXZpZHVhbCBzZWdtZW50cyBpbnRvIG9uZSBsYXJnZSB0eXBlZC1hcnJheVxuICAgICAgICBzZWdtZW50T2JqLnNlZ21lbnRzLmZvckVhY2goZnVuY3Rpb24gKHNlZ21lbnQpIHtcbiAgICAgICAgICB0ZW1wQnVmZmVyLnNldChzZWdtZW50LCBvZmZzZXQpO1xuICAgICAgICAgIG9mZnNldCArPSBzZWdtZW50LmJ5dGVMZW5ndGg7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZGVzdGluYXRpb25CdWZmZXIudXBkYXRpbmcgPSB0cnVlO1xuICAgICAgICAgIGRlc3RpbmF0aW9uQnVmZmVyLmFwcGVuZEJ1ZmZlcih0ZW1wQnVmZmVyKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBpZiAodGhpcy5tZWRpYVNvdXJjZV8ucGxheWVyXykge1xuICAgICAgICAgICAgdGhpcy5tZWRpYVNvdXJjZV8ucGxheWVyXy5lcnJvcih7XG4gICAgICAgICAgICAgIGNvZGU6IC0zLFxuICAgICAgICAgICAgICB0eXBlOiAnQVBQRU5EX0JVRkZFUl9FUlInLFxuICAgICAgICAgICAgICBtZXNzYWdlOiBlcnJvci5tZXNzYWdlLFxuICAgICAgICAgICAgICBvcmlnaW5hbEVycm9yOiBlcnJvclxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRW11bGF0ZSB0aGUgbmF0aXZlIG1lZGlhc291cmNlIGZ1bmN0aW9uLiBhYm9ydCBhbnkgc291cmVCdWZmZXJcbiAgICAgKiBhY3Rpb25zIGFuZCB0aHJvdyBvdXQgYW55IHVuLWFwcGVuZGVkIGRhdGEuXG4gICAgICpcbiAgICAgKiBAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvU291cmNlQnVmZmVyL2Fib3J0XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdhYm9ydCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFib3J0KCkge1xuICAgICAgaWYgKHRoaXMudmlkZW9CdWZmZXJfKSB7XG4gICAgICAgIHRoaXMudmlkZW9CdWZmZXJfLmFib3J0KCk7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuYXVkaW9EaXNhYmxlZF8gJiYgdGhpcy5hdWRpb0J1ZmZlcl8pIHtcbiAgICAgICAgdGhpcy5hdWRpb0J1ZmZlcl8uYWJvcnQoKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnRyYW5zbXV4ZXJfKSB7XG4gICAgICAgIHRoaXMudHJhbnNtdXhlcl8ucG9zdE1lc3NhZ2UoeyBhY3Rpb246ICdyZXNldCcgfSk7XG4gICAgICB9XG4gICAgICB0aGlzLnBlbmRpbmdCdWZmZXJzXy5sZW5ndGggPSAwO1xuICAgICAgdGhpcy5idWZmZXJVcGRhdGluZ18gPSBmYWxzZTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gVmlydHVhbFNvdXJjZUJ1ZmZlcjtcbn0pKF92aWRlb0pzMlsnZGVmYXVsdCddLkV2ZW50VGFyZ2V0KTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gVmlydHVhbFNvdXJjZUJ1ZmZlcjsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/videojs-contrib-media-sources/es5/virtual-source-buffer.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/videojs-contrib-media-sources/node_modules/global/document.js":
/*!************************************************************************************!*\
  !*** ./node_modules/videojs-contrib-media-sources/node_modules/global/document.js ***!
  \************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var topLevel = typeof global !== 'undefined' ? global :\n    typeof window !== 'undefined' ? window : {}\nvar minDoc = __webpack_require__(/*! min-document */ \"(ssr)/./node_modules/min-document/index.js\");\n\nvar doccy;\n\nif (typeof document !== 'undefined') {\n    doccy = document;\n} else {\n    doccy = topLevel['__GLOBAL_DOCUMENT_CACHE@4'];\n\n    if (!doccy) {\n        doccy = topLevel['__GLOBAL_DOCUMENT_CACHE@4'] = minDoc;\n    }\n}\n\nmodule.exports = doccy;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdmlkZW9qcy1jb250cmliLW1lZGlhLXNvdXJjZXMvbm9kZV9tb2R1bGVzL2dsb2JhbC9kb2N1bWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0EsYUFBYSxtQkFBTyxDQUFDLGdFQUFjOztBQUVuQzs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktdjAtcHJvamVjdC8uL25vZGVfbW9kdWxlcy92aWRlb2pzLWNvbnRyaWItbWVkaWEtc291cmNlcy9ub2RlX21vZHVsZXMvZ2xvYmFsL2RvY3VtZW50LmpzPzA5Y2UiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIHRvcExldmVsID0gdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwgOlxuICAgIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDoge31cbnZhciBtaW5Eb2MgPSByZXF1aXJlKCdtaW4tZG9jdW1lbnQnKTtcblxudmFyIGRvY2N5O1xuXG5pZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgIGRvY2N5ID0gZG9jdW1lbnQ7XG59IGVsc2Uge1xuICAgIGRvY2N5ID0gdG9wTGV2ZWxbJ19fR0xPQkFMX0RPQ1VNRU5UX0NBQ0hFQDQnXTtcblxuICAgIGlmICghZG9jY3kpIHtcbiAgICAgICAgZG9jY3kgPSB0b3BMZXZlbFsnX19HTE9CQUxfRE9DVU1FTlRfQ0FDSEVANCddID0gbWluRG9jO1xuICAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBkb2NjeTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/videojs-contrib-media-sources/node_modules/global/document.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/videojs-contrib-media-sources/node_modules/global/window.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/videojs-contrib-media-sources/node_modules/global/window.js ***!
  \**********************************************************************************/
/***/ ((module) => {

eval("var win;\n\nif (typeof window !== \"undefined\") {\n    win = window;\n} else if (typeof global !== \"undefined\") {\n    win = global;\n} else if (typeof self !== \"undefined\"){\n    win = self;\n} else {\n    win = {};\n}\n\nmodule.exports = win;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdmlkZW9qcy1jb250cmliLW1lZGlhLXNvdXJjZXMvbm9kZV9tb2R1bGVzL2dsb2JhbC93aW5kb3cuanMiLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBLEVBQUU7QUFDRjtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktdjAtcHJvamVjdC8uL25vZGVfbW9kdWxlcy92aWRlb2pzLWNvbnRyaWItbWVkaWEtc291cmNlcy9ub2RlX21vZHVsZXMvZ2xvYmFsL3dpbmRvdy5qcz8zNWNhIl0sInNvdXJjZXNDb250ZW50IjpbInZhciB3aW47XG5cbmlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgd2luID0gd2luZG93O1xufSBlbHNlIGlmICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgd2luID0gZ2xvYmFsO1xufSBlbHNlIGlmICh0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIil7XG4gICAgd2luID0gc2VsZjtcbn0gZWxzZSB7XG4gICAgd2luID0ge307XG59XG5cbm1vZHVsZS5leHBvcnRzID0gd2luO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/videojs-contrib-media-sources/node_modules/global/window.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/videojs-contrib-media-sources/node_modules/mux.js/lib/aac/index.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/videojs-contrib-media-sources/node_modules/mux.js/lib/aac/index.js ***!
  \*****************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/**\n * mux.js\n *\n * Copyright (c) 2016 Brightcove\n * All rights reserved.\n *\n * A stream-based aac to mp4 converter. This utility can be used to\n * deliver mp4s to a SourceBuffer on platforms that support native\n * Media Source Extensions.\n */\n\nvar Stream = __webpack_require__(/*! ../utils/stream.js */ \"(ssr)/./node_modules/videojs-contrib-media-sources/node_modules/mux.js/lib/utils/stream.js\");\n\n// Constants\nvar AacStream;\n\n/**\n * Splits an incoming stream of binary data into ADTS and ID3 Frames.\n */\n\nAacStream = function() {\n  var\n    everything = new Uint8Array(),\n    timeStamp = 0;\n\n  AacStream.prototype.init.call(this);\n\n  this.setTimestamp = function(timestamp) {\n    timeStamp = timestamp;\n  };\n\n  this.parseId3TagSize = function(header, byteIndex) {\n    var\n      returnSize = (header[byteIndex + 6] << 21) |\n                   (header[byteIndex + 7] << 14) |\n                   (header[byteIndex + 8] << 7) |\n                   (header[byteIndex + 9]),\n      flags = header[byteIndex + 5],\n      footerPresent = (flags & 16) >> 4;\n\n    if (footerPresent) {\n      return returnSize + 20;\n    }\n    return returnSize + 10;\n  };\n\n  this.parseAdtsSize = function(header, byteIndex) {\n    var\n      lowThree = (header[byteIndex + 5] & 0xE0) >> 5,\n      middle = header[byteIndex + 4] << 3,\n      highTwo = header[byteIndex + 3] & 0x3 << 11;\n\n    return (highTwo | middle) | lowThree;\n  };\n\n  this.push = function(bytes) {\n    var\n      frameSize = 0,\n      byteIndex = 0,\n      bytesLeft,\n      chunk,\n      packet,\n      tempLength;\n\n    // If there are bytes remaining from the last segment, prepend them to the\n    // bytes that were pushed in\n    if (everything.length) {\n      tempLength = everything.length;\n      everything = new Uint8Array(bytes.byteLength + tempLength);\n      everything.set(everything.subarray(0, tempLength));\n      everything.set(bytes, tempLength);\n    } else {\n      everything = bytes;\n    }\n\n    while (everything.length - byteIndex >= 3) {\n      if ((everything[byteIndex] === 'I'.charCodeAt(0)) &&\n          (everything[byteIndex + 1] === 'D'.charCodeAt(0)) &&\n          (everything[byteIndex + 2] === '3'.charCodeAt(0))) {\n\n        // Exit early because we don't have enough to parse\n        // the ID3 tag header\n        if (everything.length - byteIndex < 10) {\n          break;\n        }\n\n        // check framesize\n        frameSize = this.parseId3TagSize(everything, byteIndex);\n\n        // Exit early if we don't have enough in the buffer\n        // to emit a full packet\n        if (frameSize > everything.length) {\n          break;\n        }\n        chunk = {\n          type: 'timed-metadata',\n          data: everything.subarray(byteIndex, byteIndex + frameSize)\n        };\n        this.trigger('data', chunk);\n        byteIndex += frameSize;\n        continue;\n      } else if ((everything[byteIndex] & 0xff === 0xff) &&\n                 ((everything[byteIndex + 1] & 0xf0) === 0xf0)) {\n\n        // Exit early because we don't have enough to parse\n        // the ADTS frame header\n        if (everything.length - byteIndex < 7) {\n          break;\n        }\n\n        frameSize = this.parseAdtsSize(everything, byteIndex);\n\n        // Exit early if we don't have enough in the buffer\n        // to emit a full packet\n        if (frameSize > everything.length) {\n          break;\n        }\n\n        packet = {\n          type: 'audio',\n          data: everything.subarray(byteIndex, byteIndex + frameSize),\n          pts: timeStamp,\n          dts: timeStamp\n        };\n        this.trigger('data', packet);\n        byteIndex += frameSize;\n        continue;\n      }\n      byteIndex++;\n    }\n    bytesLeft = everything.length - byteIndex;\n\n    if (bytesLeft > 0) {\n      everything = everything.subarray(byteIndex);\n    } else {\n      everything = new Uint8Array();\n    }\n  };\n};\n\nAacStream.prototype = new Stream();\n\nmodule.exports = AacStream;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdmlkZW9qcy1jb250cmliLW1lZGlhLXNvdXJjZXMvbm9kZV9tb2R1bGVzL211eC5qcy9saWIvYWFjL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7QUFDYixhQUFhLG1CQUFPLENBQUMsc0hBQW9COztBQUV6QztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL215LXYwLXByb2plY3QvLi9ub2RlX21vZHVsZXMvdmlkZW9qcy1jb250cmliLW1lZGlhLXNvdXJjZXMvbm9kZV9tb2R1bGVzL211eC5qcy9saWIvYWFjL2luZGV4LmpzP2EwMmEiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBtdXguanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYgQnJpZ2h0Y292ZVxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBBIHN0cmVhbS1iYXNlZCBhYWMgdG8gbXA0IGNvbnZlcnRlci4gVGhpcyB1dGlsaXR5IGNhbiBiZSB1c2VkIHRvXG4gKiBkZWxpdmVyIG1wNHMgdG8gYSBTb3VyY2VCdWZmZXIgb24gcGxhdGZvcm1zIHRoYXQgc3VwcG9ydCBuYXRpdmVcbiAqIE1lZGlhIFNvdXJjZSBFeHRlbnNpb25zLlxuICovXG4ndXNlIHN0cmljdCc7XG52YXIgU3RyZWFtID0gcmVxdWlyZSgnLi4vdXRpbHMvc3RyZWFtLmpzJyk7XG5cbi8vIENvbnN0YW50c1xudmFyIEFhY1N0cmVhbTtcblxuLyoqXG4gKiBTcGxpdHMgYW4gaW5jb21pbmcgc3RyZWFtIG9mIGJpbmFyeSBkYXRhIGludG8gQURUUyBhbmQgSUQzIEZyYW1lcy5cbiAqL1xuXG5BYWNTdHJlYW0gPSBmdW5jdGlvbigpIHtcbiAgdmFyXG4gICAgZXZlcnl0aGluZyA9IG5ldyBVaW50OEFycmF5KCksXG4gICAgdGltZVN0YW1wID0gMDtcblxuICBBYWNTdHJlYW0ucHJvdG90eXBlLmluaXQuY2FsbCh0aGlzKTtcblxuICB0aGlzLnNldFRpbWVzdGFtcCA9IGZ1bmN0aW9uKHRpbWVzdGFtcCkge1xuICAgIHRpbWVTdGFtcCA9IHRpbWVzdGFtcDtcbiAgfTtcblxuICB0aGlzLnBhcnNlSWQzVGFnU2l6ZSA9IGZ1bmN0aW9uKGhlYWRlciwgYnl0ZUluZGV4KSB7XG4gICAgdmFyXG4gICAgICByZXR1cm5TaXplID0gKGhlYWRlcltieXRlSW5kZXggKyA2XSA8PCAyMSkgfFxuICAgICAgICAgICAgICAgICAgIChoZWFkZXJbYnl0ZUluZGV4ICsgN10gPDwgMTQpIHxcbiAgICAgICAgICAgICAgICAgICAoaGVhZGVyW2J5dGVJbmRleCArIDhdIDw8IDcpIHxcbiAgICAgICAgICAgICAgICAgICAoaGVhZGVyW2J5dGVJbmRleCArIDldKSxcbiAgICAgIGZsYWdzID0gaGVhZGVyW2J5dGVJbmRleCArIDVdLFxuICAgICAgZm9vdGVyUHJlc2VudCA9IChmbGFncyAmIDE2KSA+PiA0O1xuXG4gICAgaWYgKGZvb3RlclByZXNlbnQpIHtcbiAgICAgIHJldHVybiByZXR1cm5TaXplICsgMjA7XG4gICAgfVxuICAgIHJldHVybiByZXR1cm5TaXplICsgMTA7XG4gIH07XG5cbiAgdGhpcy5wYXJzZUFkdHNTaXplID0gZnVuY3Rpb24oaGVhZGVyLCBieXRlSW5kZXgpIHtcbiAgICB2YXJcbiAgICAgIGxvd1RocmVlID0gKGhlYWRlcltieXRlSW5kZXggKyA1XSAmIDB4RTApID4+IDUsXG4gICAgICBtaWRkbGUgPSBoZWFkZXJbYnl0ZUluZGV4ICsgNF0gPDwgMyxcbiAgICAgIGhpZ2hUd28gPSBoZWFkZXJbYnl0ZUluZGV4ICsgM10gJiAweDMgPDwgMTE7XG5cbiAgICByZXR1cm4gKGhpZ2hUd28gfCBtaWRkbGUpIHwgbG93VGhyZWU7XG4gIH07XG5cbiAgdGhpcy5wdXNoID0gZnVuY3Rpb24oYnl0ZXMpIHtcbiAgICB2YXJcbiAgICAgIGZyYW1lU2l6ZSA9IDAsXG4gICAgICBieXRlSW5kZXggPSAwLFxuICAgICAgYnl0ZXNMZWZ0LFxuICAgICAgY2h1bmssXG4gICAgICBwYWNrZXQsXG4gICAgICB0ZW1wTGVuZ3RoO1xuXG4gICAgLy8gSWYgdGhlcmUgYXJlIGJ5dGVzIHJlbWFpbmluZyBmcm9tIHRoZSBsYXN0IHNlZ21lbnQsIHByZXBlbmQgdGhlbSB0byB0aGVcbiAgICAvLyBieXRlcyB0aGF0IHdlcmUgcHVzaGVkIGluXG4gICAgaWYgKGV2ZXJ5dGhpbmcubGVuZ3RoKSB7XG4gICAgICB0ZW1wTGVuZ3RoID0gZXZlcnl0aGluZy5sZW5ndGg7XG4gICAgICBldmVyeXRoaW5nID0gbmV3IFVpbnQ4QXJyYXkoYnl0ZXMuYnl0ZUxlbmd0aCArIHRlbXBMZW5ndGgpO1xuICAgICAgZXZlcnl0aGluZy5zZXQoZXZlcnl0aGluZy5zdWJhcnJheSgwLCB0ZW1wTGVuZ3RoKSk7XG4gICAgICBldmVyeXRoaW5nLnNldChieXRlcywgdGVtcExlbmd0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV2ZXJ5dGhpbmcgPSBieXRlcztcbiAgICB9XG5cbiAgICB3aGlsZSAoZXZlcnl0aGluZy5sZW5ndGggLSBieXRlSW5kZXggPj0gMykge1xuICAgICAgaWYgKChldmVyeXRoaW5nW2J5dGVJbmRleF0gPT09ICdJJy5jaGFyQ29kZUF0KDApKSAmJlxuICAgICAgICAgIChldmVyeXRoaW5nW2J5dGVJbmRleCArIDFdID09PSAnRCcuY2hhckNvZGVBdCgwKSkgJiZcbiAgICAgICAgICAoZXZlcnl0aGluZ1tieXRlSW5kZXggKyAyXSA9PT0gJzMnLmNoYXJDb2RlQXQoMCkpKSB7XG5cbiAgICAgICAgLy8gRXhpdCBlYXJseSBiZWNhdXNlIHdlIGRvbid0IGhhdmUgZW5vdWdoIHRvIHBhcnNlXG4gICAgICAgIC8vIHRoZSBJRDMgdGFnIGhlYWRlclxuICAgICAgICBpZiAoZXZlcnl0aGluZy5sZW5ndGggLSBieXRlSW5kZXggPCAxMCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY2hlY2sgZnJhbWVzaXplXG4gICAgICAgIGZyYW1lU2l6ZSA9IHRoaXMucGFyc2VJZDNUYWdTaXplKGV2ZXJ5dGhpbmcsIGJ5dGVJbmRleCk7XG5cbiAgICAgICAgLy8gRXhpdCBlYXJseSBpZiB3ZSBkb24ndCBoYXZlIGVub3VnaCBpbiB0aGUgYnVmZmVyXG4gICAgICAgIC8vIHRvIGVtaXQgYSBmdWxsIHBhY2tldFxuICAgICAgICBpZiAoZnJhbWVTaXplID4gZXZlcnl0aGluZy5sZW5ndGgpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjaHVuayA9IHtcbiAgICAgICAgICB0eXBlOiAndGltZWQtbWV0YWRhdGEnLFxuICAgICAgICAgIGRhdGE6IGV2ZXJ5dGhpbmcuc3ViYXJyYXkoYnl0ZUluZGV4LCBieXRlSW5kZXggKyBmcmFtZVNpemUpXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMudHJpZ2dlcignZGF0YScsIGNodW5rKTtcbiAgICAgICAgYnl0ZUluZGV4ICs9IGZyYW1lU2l6ZTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IGVsc2UgaWYgKChldmVyeXRoaW5nW2J5dGVJbmRleF0gJiAweGZmID09PSAweGZmKSAmJlxuICAgICAgICAgICAgICAgICAoKGV2ZXJ5dGhpbmdbYnl0ZUluZGV4ICsgMV0gJiAweGYwKSA9PT0gMHhmMCkpIHtcblxuICAgICAgICAvLyBFeGl0IGVhcmx5IGJlY2F1c2Ugd2UgZG9uJ3QgaGF2ZSBlbm91Z2ggdG8gcGFyc2VcbiAgICAgICAgLy8gdGhlIEFEVFMgZnJhbWUgaGVhZGVyXG4gICAgICAgIGlmIChldmVyeXRoaW5nLmxlbmd0aCAtIGJ5dGVJbmRleCA8IDcpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGZyYW1lU2l6ZSA9IHRoaXMucGFyc2VBZHRzU2l6ZShldmVyeXRoaW5nLCBieXRlSW5kZXgpO1xuXG4gICAgICAgIC8vIEV4aXQgZWFybHkgaWYgd2UgZG9uJ3QgaGF2ZSBlbm91Z2ggaW4gdGhlIGJ1ZmZlclxuICAgICAgICAvLyB0byBlbWl0IGEgZnVsbCBwYWNrZXRcbiAgICAgICAgaWYgKGZyYW1lU2l6ZSA+IGV2ZXJ5dGhpbmcubGVuZ3RoKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBwYWNrZXQgPSB7XG4gICAgICAgICAgdHlwZTogJ2F1ZGlvJyxcbiAgICAgICAgICBkYXRhOiBldmVyeXRoaW5nLnN1YmFycmF5KGJ5dGVJbmRleCwgYnl0ZUluZGV4ICsgZnJhbWVTaXplKSxcbiAgICAgICAgICBwdHM6IHRpbWVTdGFtcCxcbiAgICAgICAgICBkdHM6IHRpbWVTdGFtcFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnRyaWdnZXIoJ2RhdGEnLCBwYWNrZXQpO1xuICAgICAgICBieXRlSW5kZXggKz0gZnJhbWVTaXplO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGJ5dGVJbmRleCsrO1xuICAgIH1cbiAgICBieXRlc0xlZnQgPSBldmVyeXRoaW5nLmxlbmd0aCAtIGJ5dGVJbmRleDtcblxuICAgIGlmIChieXRlc0xlZnQgPiAwKSB7XG4gICAgICBldmVyeXRoaW5nID0gZXZlcnl0aGluZy5zdWJhcnJheShieXRlSW5kZXgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBldmVyeXRoaW5nID0gbmV3IFVpbnQ4QXJyYXkoKTtcbiAgICB9XG4gIH07XG59O1xuXG5BYWNTdHJlYW0ucHJvdG90eXBlID0gbmV3IFN0cmVhbSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFhY1N0cmVhbTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/videojs-contrib-media-sources/node_modules/mux.js/lib/aac/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/videojs-contrib-media-sources/node_modules/mux.js/lib/codecs/adts.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/videojs-contrib-media-sources/node_modules/mux.js/lib/codecs/adts.js ***!
  \*******************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Stream = __webpack_require__(/*! ../utils/stream.js */ \"(ssr)/./node_modules/videojs-contrib-media-sources/node_modules/mux.js/lib/utils/stream.js\");\n\nvar AdtsStream;\n\nvar\n  ADTS_SAMPLING_FREQUENCIES = [\n    96000,\n    88200,\n    64000,\n    48000,\n    44100,\n    32000,\n    24000,\n    22050,\n    16000,\n    12000,\n    11025,\n    8000,\n    7350\n  ];\n\n/*\n * Accepts a ElementaryStream and emits data events with parsed\n * AAC Audio Frames of the individual packets. Input audio in ADTS\n * format is unpacked and re-emitted as AAC frames.\n *\n * @see http://wiki.multimedia.cx/index.php?title=ADTS\n * @see http://wiki.multimedia.cx/?title=Understanding_AAC\n */\nAdtsStream = function() {\n  var buffer;\n\n  AdtsStream.prototype.init.call(this);\n\n  this.push = function(packet) {\n    var\n      i = 0,\n      frameNum = 0,\n      frameLength,\n      protectionSkipBytes,\n      frameEnd,\n      oldBuffer,\n      sampleCount,\n      adtsFrameDuration;\n\n    if (packet.type !== 'audio') {\n      // ignore non-audio data\n      return;\n    }\n\n    // Prepend any data in the buffer to the input data so that we can parse\n    // aac frames the cross a PES packet boundary\n    if (buffer) {\n      oldBuffer = buffer;\n      buffer = new Uint8Array(oldBuffer.byteLength + packet.data.byteLength);\n      buffer.set(oldBuffer);\n      buffer.set(packet.data, oldBuffer.byteLength);\n    } else {\n      buffer = packet.data;\n    }\n\n    // unpack any ADTS frames which have been fully received\n    // for details on the ADTS header, see http://wiki.multimedia.cx/index.php?title=ADTS\n    while (i + 5 < buffer.length) {\n\n      // Loook for the start of an ADTS header..\n      if (buffer[i] !== 0xFF || (buffer[i + 1] & 0xF6) !== 0xF0) {\n        // If a valid header was not found,  jump one forward and attempt to\n        // find a valid ADTS header starting at the next byte\n        i++;\n        continue;\n      }\n\n      // The protection skip bit tells us if we have 2 bytes of CRC data at the\n      // end of the ADTS header\n      protectionSkipBytes = (~buffer[i + 1] & 0x01) * 2;\n\n      // Frame length is a 13 bit integer starting 16 bits from the\n      // end of the sync sequence\n      frameLength = ((buffer[i + 3] & 0x03) << 11) |\n        (buffer[i + 4] << 3) |\n        ((buffer[i + 5] & 0xe0) >> 5);\n\n      sampleCount = ((buffer[i + 6] & 0x03) + 1) * 1024;\n      adtsFrameDuration = (sampleCount * 90000) /\n        ADTS_SAMPLING_FREQUENCIES[(buffer[i + 2] & 0x3c) >>> 2];\n\n      frameEnd = i + frameLength;\n\n      // If we don't have enough data to actually finish this ADTS frame, return\n      // and wait for more data\n      if (buffer.byteLength < frameEnd) {\n        return;\n      }\n\n      // Otherwise, deliver the complete AAC frame\n      this.trigger('data', {\n        pts: packet.pts + (frameNum * adtsFrameDuration),\n        dts: packet.dts + (frameNum * adtsFrameDuration),\n        sampleCount: sampleCount,\n        audioobjecttype: ((buffer[i + 2] >>> 6) & 0x03) + 1,\n        channelcount: ((buffer[i + 2] & 1) << 2) |\n          ((buffer[i + 3] & 0xc0) >>> 6),\n        samplerate: ADTS_SAMPLING_FREQUENCIES[(buffer[i + 2] & 0x3c) >>> 2],\n        samplingfrequencyindex: (buffer[i + 2] & 0x3c) >>> 2,\n        // assume ISO/IEC 14496-12 AudioSampleEntry default of 16\n        samplesize: 16,\n        data: buffer.subarray(i + 7 + protectionSkipBytes, frameEnd)\n      });\n\n      // If the buffer is empty, clear it and return\n      if (buffer.byteLength === frameEnd) {\n        buffer = undefined;\n        return;\n      }\n\n      frameNum++;\n\n      // Remove the finished frame from the buffer and start the process again\n      buffer = buffer.subarray(frameEnd);\n    }\n  };\n  this.flush = function() {\n    this.trigger('done');\n  };\n};\n\nAdtsStream.prototype = new Stream();\n\nmodule.exports = AdtsStream;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdmlkZW9qcy1jb250cmliLW1lZGlhLXNvdXJjZXMvbm9kZV9tb2R1bGVzL211eC5qcy9saWIvY29kZWNzL2FkdHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsYUFBYSxtQkFBTyxDQUFDLHNIQUFvQjs7QUFFekM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL215LXYwLXByb2plY3QvLi9ub2RlX21vZHVsZXMvdmlkZW9qcy1jb250cmliLW1lZGlhLXNvdXJjZXMvbm9kZV9tb2R1bGVzL211eC5qcy9saWIvY29kZWNzL2FkdHMuanM/N2NhNiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBTdHJlYW0gPSByZXF1aXJlKCcuLi91dGlscy9zdHJlYW0uanMnKTtcblxudmFyIEFkdHNTdHJlYW07XG5cbnZhclxuICBBRFRTX1NBTVBMSU5HX0ZSRVFVRU5DSUVTID0gW1xuICAgIDk2MDAwLFxuICAgIDg4MjAwLFxuICAgIDY0MDAwLFxuICAgIDQ4MDAwLFxuICAgIDQ0MTAwLFxuICAgIDMyMDAwLFxuICAgIDI0MDAwLFxuICAgIDIyMDUwLFxuICAgIDE2MDAwLFxuICAgIDEyMDAwLFxuICAgIDExMDI1LFxuICAgIDgwMDAsXG4gICAgNzM1MFxuICBdO1xuXG4vKlxuICogQWNjZXB0cyBhIEVsZW1lbnRhcnlTdHJlYW0gYW5kIGVtaXRzIGRhdGEgZXZlbnRzIHdpdGggcGFyc2VkXG4gKiBBQUMgQXVkaW8gRnJhbWVzIG9mIHRoZSBpbmRpdmlkdWFsIHBhY2tldHMuIElucHV0IGF1ZGlvIGluIEFEVFNcbiAqIGZvcm1hdCBpcyB1bnBhY2tlZCBhbmQgcmUtZW1pdHRlZCBhcyBBQUMgZnJhbWVzLlxuICpcbiAqIEBzZWUgaHR0cDovL3dpa2kubXVsdGltZWRpYS5jeC9pbmRleC5waHA/dGl0bGU9QURUU1xuICogQHNlZSBodHRwOi8vd2lraS5tdWx0aW1lZGlhLmN4Lz90aXRsZT1VbmRlcnN0YW5kaW5nX0FBQ1xuICovXG5BZHRzU3RyZWFtID0gZnVuY3Rpb24oKSB7XG4gIHZhciBidWZmZXI7XG5cbiAgQWR0c1N0cmVhbS5wcm90b3R5cGUuaW5pdC5jYWxsKHRoaXMpO1xuXG4gIHRoaXMucHVzaCA9IGZ1bmN0aW9uKHBhY2tldCkge1xuICAgIHZhclxuICAgICAgaSA9IDAsXG4gICAgICBmcmFtZU51bSA9IDAsXG4gICAgICBmcmFtZUxlbmd0aCxcbiAgICAgIHByb3RlY3Rpb25Ta2lwQnl0ZXMsXG4gICAgICBmcmFtZUVuZCxcbiAgICAgIG9sZEJ1ZmZlcixcbiAgICAgIHNhbXBsZUNvdW50LFxuICAgICAgYWR0c0ZyYW1lRHVyYXRpb247XG5cbiAgICBpZiAocGFja2V0LnR5cGUgIT09ICdhdWRpbycpIHtcbiAgICAgIC8vIGlnbm9yZSBub24tYXVkaW8gZGF0YVxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFByZXBlbmQgYW55IGRhdGEgaW4gdGhlIGJ1ZmZlciB0byB0aGUgaW5wdXQgZGF0YSBzbyB0aGF0IHdlIGNhbiBwYXJzZVxuICAgIC8vIGFhYyBmcmFtZXMgdGhlIGNyb3NzIGEgUEVTIHBhY2tldCBib3VuZGFyeVxuICAgIGlmIChidWZmZXIpIHtcbiAgICAgIG9sZEJ1ZmZlciA9IGJ1ZmZlcjtcbiAgICAgIGJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KG9sZEJ1ZmZlci5ieXRlTGVuZ3RoICsgcGFja2V0LmRhdGEuYnl0ZUxlbmd0aCk7XG4gICAgICBidWZmZXIuc2V0KG9sZEJ1ZmZlcik7XG4gICAgICBidWZmZXIuc2V0KHBhY2tldC5kYXRhLCBvbGRCdWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJ1ZmZlciA9IHBhY2tldC5kYXRhO1xuICAgIH1cblxuICAgIC8vIHVucGFjayBhbnkgQURUUyBmcmFtZXMgd2hpY2ggaGF2ZSBiZWVuIGZ1bGx5IHJlY2VpdmVkXG4gICAgLy8gZm9yIGRldGFpbHMgb24gdGhlIEFEVFMgaGVhZGVyLCBzZWUgaHR0cDovL3dpa2kubXVsdGltZWRpYS5jeC9pbmRleC5waHA/dGl0bGU9QURUU1xuICAgIHdoaWxlIChpICsgNSA8IGJ1ZmZlci5sZW5ndGgpIHtcblxuICAgICAgLy8gTG9vb2sgZm9yIHRoZSBzdGFydCBvZiBhbiBBRFRTIGhlYWRlci4uXG4gICAgICBpZiAoYnVmZmVyW2ldICE9PSAweEZGIHx8IChidWZmZXJbaSArIDFdICYgMHhGNikgIT09IDB4RjApIHtcbiAgICAgICAgLy8gSWYgYSB2YWxpZCBoZWFkZXIgd2FzIG5vdCBmb3VuZCwgIGp1bXAgb25lIGZvcndhcmQgYW5kIGF0dGVtcHQgdG9cbiAgICAgICAgLy8gZmluZCBhIHZhbGlkIEFEVFMgaGVhZGVyIHN0YXJ0aW5nIGF0IHRoZSBuZXh0IGJ5dGVcbiAgICAgICAgaSsrO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gVGhlIHByb3RlY3Rpb24gc2tpcCBiaXQgdGVsbHMgdXMgaWYgd2UgaGF2ZSAyIGJ5dGVzIG9mIENSQyBkYXRhIGF0IHRoZVxuICAgICAgLy8gZW5kIG9mIHRoZSBBRFRTIGhlYWRlclxuICAgICAgcHJvdGVjdGlvblNraXBCeXRlcyA9ICh+YnVmZmVyW2kgKyAxXSAmIDB4MDEpICogMjtcblxuICAgICAgLy8gRnJhbWUgbGVuZ3RoIGlzIGEgMTMgYml0IGludGVnZXIgc3RhcnRpbmcgMTYgYml0cyBmcm9tIHRoZVxuICAgICAgLy8gZW5kIG9mIHRoZSBzeW5jIHNlcXVlbmNlXG4gICAgICBmcmFtZUxlbmd0aCA9ICgoYnVmZmVyW2kgKyAzXSAmIDB4MDMpIDw8IDExKSB8XG4gICAgICAgIChidWZmZXJbaSArIDRdIDw8IDMpIHxcbiAgICAgICAgKChidWZmZXJbaSArIDVdICYgMHhlMCkgPj4gNSk7XG5cbiAgICAgIHNhbXBsZUNvdW50ID0gKChidWZmZXJbaSArIDZdICYgMHgwMykgKyAxKSAqIDEwMjQ7XG4gICAgICBhZHRzRnJhbWVEdXJhdGlvbiA9IChzYW1wbGVDb3VudCAqIDkwMDAwKSAvXG4gICAgICAgIEFEVFNfU0FNUExJTkdfRlJFUVVFTkNJRVNbKGJ1ZmZlcltpICsgMl0gJiAweDNjKSA+Pj4gMl07XG5cbiAgICAgIGZyYW1lRW5kID0gaSArIGZyYW1lTGVuZ3RoO1xuXG4gICAgICAvLyBJZiB3ZSBkb24ndCBoYXZlIGVub3VnaCBkYXRhIHRvIGFjdHVhbGx5IGZpbmlzaCB0aGlzIEFEVFMgZnJhbWUsIHJldHVyblxuICAgICAgLy8gYW5kIHdhaXQgZm9yIG1vcmUgZGF0YVxuICAgICAgaWYgKGJ1ZmZlci5ieXRlTGVuZ3RoIDwgZnJhbWVFbmQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBPdGhlcndpc2UsIGRlbGl2ZXIgdGhlIGNvbXBsZXRlIEFBQyBmcmFtZVxuICAgICAgdGhpcy50cmlnZ2VyKCdkYXRhJywge1xuICAgICAgICBwdHM6IHBhY2tldC5wdHMgKyAoZnJhbWVOdW0gKiBhZHRzRnJhbWVEdXJhdGlvbiksXG4gICAgICAgIGR0czogcGFja2V0LmR0cyArIChmcmFtZU51bSAqIGFkdHNGcmFtZUR1cmF0aW9uKSxcbiAgICAgICAgc2FtcGxlQ291bnQ6IHNhbXBsZUNvdW50LFxuICAgICAgICBhdWRpb29iamVjdHR5cGU6ICgoYnVmZmVyW2kgKyAyXSA+Pj4gNikgJiAweDAzKSArIDEsXG4gICAgICAgIGNoYW5uZWxjb3VudDogKChidWZmZXJbaSArIDJdICYgMSkgPDwgMikgfFxuICAgICAgICAgICgoYnVmZmVyW2kgKyAzXSAmIDB4YzApID4+PiA2KSxcbiAgICAgICAgc2FtcGxlcmF0ZTogQURUU19TQU1QTElOR19GUkVRVUVOQ0lFU1soYnVmZmVyW2kgKyAyXSAmIDB4M2MpID4+PiAyXSxcbiAgICAgICAgc2FtcGxpbmdmcmVxdWVuY3lpbmRleDogKGJ1ZmZlcltpICsgMl0gJiAweDNjKSA+Pj4gMixcbiAgICAgICAgLy8gYXNzdW1lIElTTy9JRUMgMTQ0OTYtMTIgQXVkaW9TYW1wbGVFbnRyeSBkZWZhdWx0IG9mIDE2XG4gICAgICAgIHNhbXBsZXNpemU6IDE2LFxuICAgICAgICBkYXRhOiBidWZmZXIuc3ViYXJyYXkoaSArIDcgKyBwcm90ZWN0aW9uU2tpcEJ5dGVzLCBmcmFtZUVuZClcbiAgICAgIH0pO1xuXG4gICAgICAvLyBJZiB0aGUgYnVmZmVyIGlzIGVtcHR5LCBjbGVhciBpdCBhbmQgcmV0dXJuXG4gICAgICBpZiAoYnVmZmVyLmJ5dGVMZW5ndGggPT09IGZyYW1lRW5kKSB7XG4gICAgICAgIGJ1ZmZlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBmcmFtZU51bSsrO1xuXG4gICAgICAvLyBSZW1vdmUgdGhlIGZpbmlzaGVkIGZyYW1lIGZyb20gdGhlIGJ1ZmZlciBhbmQgc3RhcnQgdGhlIHByb2Nlc3MgYWdhaW5cbiAgICAgIGJ1ZmZlciA9IGJ1ZmZlci5zdWJhcnJheShmcmFtZUVuZCk7XG4gICAgfVxuICB9O1xuICB0aGlzLmZsdXNoID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy50cmlnZ2VyKCdkb25lJyk7XG4gIH07XG59O1xuXG5BZHRzU3RyZWFtLnByb3RvdHlwZSA9IG5ldyBTdHJlYW0oKTtcblxubW9kdWxlLmV4cG9ydHMgPSBBZHRzU3RyZWFtO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/videojs-contrib-media-sources/node_modules/mux.js/lib/codecs/adts.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/videojs-contrib-media-sources/node_modules/mux.js/lib/codecs/h264.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/videojs-contrib-media-sources/node_modules/mux.js/lib/codecs/h264.js ***!
  \*******************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Stream = __webpack_require__(/*! ../utils/stream.js */ \"(ssr)/./node_modules/videojs-contrib-media-sources/node_modules/mux.js/lib/utils/stream.js\");\nvar ExpGolomb = __webpack_require__(/*! ../utils/exp-golomb.js */ \"(ssr)/./node_modules/videojs-contrib-media-sources/node_modules/mux.js/lib/utils/exp-golomb.js\");\n\nvar H264Stream, NalByteStream;\nvar PROFILES_WITH_OPTIONAL_SPS_DATA;\n\n/**\n * Accepts a NAL unit byte stream and unpacks the embedded NAL units.\n */\nNalByteStream = function() {\n  var\n    syncPoint = 0,\n    i,\n    buffer;\n  NalByteStream.prototype.init.call(this);\n\n  this.push = function(data) {\n    var swapBuffer;\n\n    if (!buffer) {\n      buffer = data.data;\n    } else {\n      swapBuffer = new Uint8Array(buffer.byteLength + data.data.byteLength);\n      swapBuffer.set(buffer);\n      swapBuffer.set(data.data, buffer.byteLength);\n      buffer = swapBuffer;\n    }\n\n    // Rec. ITU-T H.264, Annex B\n    // scan for NAL unit boundaries\n\n    // a match looks like this:\n    // 0 0 1 .. NAL .. 0 0 1\n    // ^ sync point        ^ i\n    // or this:\n    // 0 0 1 .. NAL .. 0 0 0\n    // ^ sync point        ^ i\n\n    // advance the sync point to a NAL start, if necessary\n    for (; syncPoint < buffer.byteLength - 3; syncPoint++) {\n      if (buffer[syncPoint + 2] === 1) {\n        // the sync point is properly aligned\n        i = syncPoint + 5;\n        break;\n      }\n    }\n\n    while (i < buffer.byteLength) {\n      // look at the current byte to determine if we've hit the end of\n      // a NAL unit boundary\n      switch (buffer[i]) {\n      case 0:\n        // skip past non-sync sequences\n        if (buffer[i - 1] !== 0) {\n          i += 2;\n          break;\n        } else if (buffer[i - 2] !== 0) {\n          i++;\n          break;\n        }\n\n        // deliver the NAL unit if it isn't empty\n        if (syncPoint + 3 !== i - 2) {\n          this.trigger('data', buffer.subarray(syncPoint + 3, i - 2));\n        }\n\n        // drop trailing zeroes\n        do {\n          i++;\n        } while (buffer[i] !== 1 && i < buffer.length);\n        syncPoint = i - 2;\n        i += 3;\n        break;\n      case 1:\n        // skip past non-sync sequences\n        if (buffer[i - 1] !== 0 ||\n            buffer[i - 2] !== 0) {\n          i += 3;\n          break;\n        }\n\n        // deliver the NAL unit\n        this.trigger('data', buffer.subarray(syncPoint + 3, i - 2));\n        syncPoint = i - 2;\n        i += 3;\n        break;\n      default:\n        // the current byte isn't a one or zero, so it cannot be part\n        // of a sync sequence\n        i += 3;\n        break;\n      }\n    }\n    // filter out the NAL units that were delivered\n    buffer = buffer.subarray(syncPoint);\n    i -= syncPoint;\n    syncPoint = 0;\n  };\n\n  this.flush = function() {\n    // deliver the last buffered NAL unit\n    if (buffer && buffer.byteLength > 3) {\n      this.trigger('data', buffer.subarray(syncPoint + 3));\n    }\n    // reset the stream state\n    buffer = null;\n    syncPoint = 0;\n    this.trigger('done');\n  };\n};\nNalByteStream.prototype = new Stream();\n\n// values of profile_idc that indicate additional fields are included in the SPS\n// see Recommendation ITU-T H.264 (4/2013),\n// 7.3.2.1.1 Sequence parameter set data syntax\nPROFILES_WITH_OPTIONAL_SPS_DATA = {\n  100: true,\n  110: true,\n  122: true,\n  244: true,\n  44: true,\n  83: true,\n  86: true,\n  118: true,\n  128: true,\n  138: true,\n  139: true,\n  134: true\n};\n\n/**\n * Accepts input from a ElementaryStream and produces H.264 NAL unit data\n * events.\n */\nH264Stream = function() {\n  var\n    nalByteStream = new NalByteStream(),\n    self,\n    trackId,\n    currentPts,\n    currentDts,\n\n    discardEmulationPreventionBytes,\n    readSequenceParameterSet,\n    skipScalingList;\n\n  H264Stream.prototype.init.call(this);\n  self = this;\n\n  this.push = function(packet) {\n    if (packet.type !== 'video') {\n      return;\n    }\n    trackId = packet.trackId;\n    currentPts = packet.pts;\n    currentDts = packet.dts;\n\n    nalByteStream.push(packet);\n  };\n\n  nalByteStream.on('data', function(data) {\n    var\n      event = {\n        trackId: trackId,\n        pts: currentPts,\n        dts: currentDts,\n        data: data\n      };\n\n    switch (data[0] & 0x1f) {\n    case 0x05:\n      event.nalUnitType = 'slice_layer_without_partitioning_rbsp_idr';\n      break;\n    case 0x06:\n      event.nalUnitType = 'sei_rbsp';\n      event.escapedRBSP = discardEmulationPreventionBytes(data.subarray(1));\n      break;\n    case 0x07:\n      event.nalUnitType = 'seq_parameter_set_rbsp';\n      event.escapedRBSP = discardEmulationPreventionBytes(data.subarray(1));\n      event.config = readSequenceParameterSet(event.escapedRBSP);\n      break;\n    case 0x08:\n      event.nalUnitType = 'pic_parameter_set_rbsp';\n      break;\n    case 0x09:\n      event.nalUnitType = 'access_unit_delimiter_rbsp';\n      break;\n\n    default:\n      break;\n    }\n    self.trigger('data', event);\n  });\n  nalByteStream.on('done', function() {\n    self.trigger('done');\n  });\n\n  this.flush = function() {\n    nalByteStream.flush();\n  };\n\n  /**\n   * Advance the ExpGolomb decoder past a scaling list. The scaling\n   * list is optionally transmitted as part of a sequence parameter\n   * set and is not relevant to transmuxing.\n   * @param count {number} the number of entries in this scaling list\n   * @param expGolombDecoder {object} an ExpGolomb pointed to the\n   * start of a scaling list\n   * @see Recommendation ITU-T H.264, Section 7.3.2.1.1.1\n   */\n  skipScalingList = function(count, expGolombDecoder) {\n    var\n      lastScale = 8,\n      nextScale = 8,\n      j,\n      deltaScale;\n\n    for (j = 0; j < count; j++) {\n      if (nextScale !== 0) {\n        deltaScale = expGolombDecoder.readExpGolomb();\n        nextScale = (lastScale + deltaScale + 256) % 256;\n      }\n\n      lastScale = (nextScale === 0) ? lastScale : nextScale;\n    }\n  };\n\n  /**\n   * Expunge any \"Emulation Prevention\" bytes from a \"Raw Byte\n   * Sequence Payload\"\n   * @param data {Uint8Array} the bytes of a RBSP from a NAL\n   * unit\n   * @return {Uint8Array} the RBSP without any Emulation\n   * Prevention Bytes\n   */\n  discardEmulationPreventionBytes = function(data) {\n    var\n      length = data.byteLength,\n      emulationPreventionBytesPositions = [],\n      i = 1,\n      newLength, newData;\n\n    // Find all `Emulation Prevention Bytes`\n    while (i < length - 2) {\n      if (data[i] === 0 && data[i + 1] === 0 && data[i + 2] === 0x03) {\n        emulationPreventionBytesPositions.push(i + 2);\n        i += 2;\n      } else {\n        i++;\n      }\n    }\n\n    // If no Emulation Prevention Bytes were found just return the original\n    // array\n    if (emulationPreventionBytesPositions.length === 0) {\n      return data;\n    }\n\n    // Create a new array to hold the NAL unit data\n    newLength = length - emulationPreventionBytesPositions.length;\n    newData = new Uint8Array(newLength);\n    var sourceIndex = 0;\n\n    for (i = 0; i < newLength; sourceIndex++, i++) {\n      if (sourceIndex === emulationPreventionBytesPositions[0]) {\n        // Skip this byte\n        sourceIndex++;\n        // Remove this position index\n        emulationPreventionBytesPositions.shift();\n      }\n      newData[i] = data[sourceIndex];\n    }\n\n    return newData;\n  };\n\n  /**\n   * Read a sequence parameter set and return some interesting video\n   * properties. A sequence parameter set is the H264 metadata that\n   * describes the properties of upcoming video frames.\n   * @param data {Uint8Array} the bytes of a sequence parameter set\n   * @return {object} an object with configuration parsed from the\n   * sequence parameter set, including the dimensions of the\n   * associated video frames.\n   */\n  readSequenceParameterSet = function(data) {\n    var\n      frameCropLeftOffset = 0,\n      frameCropRightOffset = 0,\n      frameCropTopOffset = 0,\n      frameCropBottomOffset = 0,\n      sarScale = 1,\n      expGolombDecoder, profileIdc, levelIdc, profileCompatibility,\n      chromaFormatIdc, picOrderCntType,\n      numRefFramesInPicOrderCntCycle, picWidthInMbsMinus1,\n      picHeightInMapUnitsMinus1,\n      frameMbsOnlyFlag,\n      scalingListCount,\n      sarRatio,\n      aspectRatioIdc,\n      i;\n\n    expGolombDecoder = new ExpGolomb(data);\n    profileIdc = expGolombDecoder.readUnsignedByte(); // profile_idc\n    profileCompatibility = expGolombDecoder.readUnsignedByte(); // constraint_set[0-5]_flag\n    levelIdc = expGolombDecoder.readUnsignedByte(); // level_idc u(8)\n    expGolombDecoder.skipUnsignedExpGolomb(); // seq_parameter_set_id\n\n    // some profiles have more optional data we don't need\n    if (PROFILES_WITH_OPTIONAL_SPS_DATA[profileIdc]) {\n      chromaFormatIdc = expGolombDecoder.readUnsignedExpGolomb();\n      if (chromaFormatIdc === 3) {\n        expGolombDecoder.skipBits(1); // separate_colour_plane_flag\n      }\n      expGolombDecoder.skipUnsignedExpGolomb(); // bit_depth_luma_minus8\n      expGolombDecoder.skipUnsignedExpGolomb(); // bit_depth_chroma_minus8\n      expGolombDecoder.skipBits(1); // qpprime_y_zero_transform_bypass_flag\n      if (expGolombDecoder.readBoolean()) { // seq_scaling_matrix_present_flag\n        scalingListCount = (chromaFormatIdc !== 3) ? 8 : 12;\n        for (i = 0; i < scalingListCount; i++) {\n          if (expGolombDecoder.readBoolean()) { // seq_scaling_list_present_flag[ i ]\n            if (i < 6) {\n              skipScalingList(16, expGolombDecoder);\n            } else {\n              skipScalingList(64, expGolombDecoder);\n            }\n          }\n        }\n      }\n    }\n\n    expGolombDecoder.skipUnsignedExpGolomb(); // log2_max_frame_num_minus4\n    picOrderCntType = expGolombDecoder.readUnsignedExpGolomb();\n\n    if (picOrderCntType === 0) {\n      expGolombDecoder.readUnsignedExpGolomb(); // log2_max_pic_order_cnt_lsb_minus4\n    } else if (picOrderCntType === 1) {\n      expGolombDecoder.skipBits(1); // delta_pic_order_always_zero_flag\n      expGolombDecoder.skipExpGolomb(); // offset_for_non_ref_pic\n      expGolombDecoder.skipExpGolomb(); // offset_for_top_to_bottom_field\n      numRefFramesInPicOrderCntCycle = expGolombDecoder.readUnsignedExpGolomb();\n      for (i = 0; i < numRefFramesInPicOrderCntCycle; i++) {\n        expGolombDecoder.skipExpGolomb(); // offset_for_ref_frame[ i ]\n      }\n    }\n\n    expGolombDecoder.skipUnsignedExpGolomb(); // max_num_ref_frames\n    expGolombDecoder.skipBits(1); // gaps_in_frame_num_value_allowed_flag\n\n    picWidthInMbsMinus1 = expGolombDecoder.readUnsignedExpGolomb();\n    picHeightInMapUnitsMinus1 = expGolombDecoder.readUnsignedExpGolomb();\n\n    frameMbsOnlyFlag = expGolombDecoder.readBits(1);\n    if (frameMbsOnlyFlag === 0) {\n      expGolombDecoder.skipBits(1); // mb_adaptive_frame_field_flag\n    }\n\n    expGolombDecoder.skipBits(1); // direct_8x8_inference_flag\n    if (expGolombDecoder.readBoolean()) { // frame_cropping_flag\n      frameCropLeftOffset = expGolombDecoder.readUnsignedExpGolomb();\n      frameCropRightOffset = expGolombDecoder.readUnsignedExpGolomb();\n      frameCropTopOffset = expGolombDecoder.readUnsignedExpGolomb();\n      frameCropBottomOffset = expGolombDecoder.readUnsignedExpGolomb();\n    }\n    if (expGolombDecoder.readBoolean()) {\n      // vui_parameters_present_flag\n      if (expGolombDecoder.readBoolean()) {\n        // aspect_ratio_info_present_flag\n        aspectRatioIdc = expGolombDecoder.readUnsignedByte();\n        switch (aspectRatioIdc) {\n          case 1: sarRatio = [1, 1]; break;\n          case 2: sarRatio = [12, 11]; break;\n          case 3: sarRatio = [10, 11]; break;\n          case 4: sarRatio = [16, 11]; break;\n          case 5: sarRatio = [40, 33]; break;\n          case 6: sarRatio = [24, 11]; break;\n          case 7: sarRatio = [20, 11]; break;\n          case 8: sarRatio = [32, 11]; break;\n          case 9: sarRatio = [80, 33]; break;\n          case 10: sarRatio = [18, 11]; break;\n          case 11: sarRatio = [15, 11]; break;\n          case 12: sarRatio = [64, 33]; break;\n          case 13: sarRatio = [160, 99]; break;\n          case 14: sarRatio = [4, 3]; break;\n          case 15: sarRatio = [3, 2]; break;\n          case 16: sarRatio = [2, 1]; break;\n          case 255: {\n            sarRatio = [expGolombDecoder.readUnsignedByte() << 8 |\n                        expGolombDecoder.readUnsignedByte(),\n                        expGolombDecoder.readUnsignedByte() << 8 |\n                        expGolombDecoder.readUnsignedByte() ];\n            break;\n          }\n        }\n        if (sarRatio) {\n          sarScale = sarRatio[0] / sarRatio[1];\n        }\n      }\n    }\n    return {\n      profileIdc: profileIdc,\n      levelIdc: levelIdc,\n      profileCompatibility: profileCompatibility,\n      width: Math.ceil((((picWidthInMbsMinus1 + 1) * 16) - frameCropLeftOffset * 2 - frameCropRightOffset * 2) * sarScale),\n      height: ((2 - frameMbsOnlyFlag) * (picHeightInMapUnitsMinus1 + 1) * 16) - (frameCropTopOffset * 2) - (frameCropBottomOffset * 2)\n    };\n  };\n\n};\nH264Stream.prototype = new Stream();\n\nmodule.exports = {\n  H264Stream: H264Stream,\n  NalByteStream: NalByteStream\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdmlkZW9qcy1jb250cmliLW1lZGlhLXNvdXJjZXMvbm9kZV9tb2R1bGVzL211eC5qcy9saWIvY29kZWNzL2gyNjQuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsYUFBYSxtQkFBTyxDQUFDLHNIQUFvQjtBQUN6QyxnQkFBZ0IsbUJBQU8sQ0FBQyw4SEFBd0I7O0FBRWhEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxtQ0FBbUM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsOEJBQThCLFFBQVE7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdCQUFnQixXQUFXO0FBQzNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsWUFBWTtBQUM5QjtBQUNBLGNBQWMsWUFBWTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCLGVBQWU7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFlBQVk7QUFDOUIsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0RBQXNEO0FBQ3RELGdFQUFnRTtBQUNoRSxvREFBb0Q7QUFDcEQsOENBQThDOztBQUU5QztBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBLGdEQUFnRDtBQUNoRCxnREFBZ0Q7QUFDaEQsb0NBQW9DO0FBQ3BDLDRDQUE0QztBQUM1QztBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUMsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhDQUE4QztBQUM5Qzs7QUFFQTtBQUNBLGdEQUFnRDtBQUNoRCxNQUFNO0FBQ04sb0NBQW9DO0FBQ3BDLHdDQUF3QztBQUN4Qyx3Q0FBd0M7QUFDeEM7QUFDQSxrQkFBa0Isb0NBQW9DO0FBQ3RELDBDQUEwQztBQUMxQztBQUNBOztBQUVBLDhDQUE4QztBQUM5QyxrQ0FBa0M7O0FBRWxDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9DQUFvQztBQUNwQzs7QUFFQSxrQ0FBa0M7QUFDbEMsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckMsdUNBQXVDO0FBQ3ZDLHVDQUF1QztBQUN2Qyx1Q0FBdUM7QUFDdkMsdUNBQXVDO0FBQ3ZDLHVDQUF1QztBQUN2Qyx1Q0FBdUM7QUFDdkMsdUNBQXVDO0FBQ3ZDLHVDQUF1QztBQUN2Qyx3Q0FBd0M7QUFDeEMsd0NBQXdDO0FBQ3hDLHdDQUF3QztBQUN4Qyx5Q0FBeUM7QUFDekMsc0NBQXNDO0FBQ3RDLHNDQUFzQztBQUN0QyxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS12MC1wcm9qZWN0Ly4vbm9kZV9tb2R1bGVzL3ZpZGVvanMtY29udHJpYi1tZWRpYS1zb3VyY2VzL25vZGVfbW9kdWxlcy9tdXguanMvbGliL2NvZGVjcy9oMjY0LmpzPzU2OTIiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgU3RyZWFtID0gcmVxdWlyZSgnLi4vdXRpbHMvc3RyZWFtLmpzJyk7XG52YXIgRXhwR29sb21iID0gcmVxdWlyZSgnLi4vdXRpbHMvZXhwLWdvbG9tYi5qcycpO1xuXG52YXIgSDI2NFN0cmVhbSwgTmFsQnl0ZVN0cmVhbTtcbnZhciBQUk9GSUxFU19XSVRIX09QVElPTkFMX1NQU19EQVRBO1xuXG4vKipcbiAqIEFjY2VwdHMgYSBOQUwgdW5pdCBieXRlIHN0cmVhbSBhbmQgdW5wYWNrcyB0aGUgZW1iZWRkZWQgTkFMIHVuaXRzLlxuICovXG5OYWxCeXRlU3RyZWFtID0gZnVuY3Rpb24oKSB7XG4gIHZhclxuICAgIHN5bmNQb2ludCA9IDAsXG4gICAgaSxcbiAgICBidWZmZXI7XG4gIE5hbEJ5dGVTdHJlYW0ucHJvdG90eXBlLmluaXQuY2FsbCh0aGlzKTtcblxuICB0aGlzLnB1c2ggPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgdmFyIHN3YXBCdWZmZXI7XG5cbiAgICBpZiAoIWJ1ZmZlcikge1xuICAgICAgYnVmZmVyID0gZGF0YS5kYXRhO1xuICAgIH0gZWxzZSB7XG4gICAgICBzd2FwQnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyLmJ5dGVMZW5ndGggKyBkYXRhLmRhdGEuYnl0ZUxlbmd0aCk7XG4gICAgICBzd2FwQnVmZmVyLnNldChidWZmZXIpO1xuICAgICAgc3dhcEJ1ZmZlci5zZXQoZGF0YS5kYXRhLCBidWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICBidWZmZXIgPSBzd2FwQnVmZmVyO1xuICAgIH1cblxuICAgIC8vIFJlYy4gSVRVLVQgSC4yNjQsIEFubmV4IEJcbiAgICAvLyBzY2FuIGZvciBOQUwgdW5pdCBib3VuZGFyaWVzXG5cbiAgICAvLyBhIG1hdGNoIGxvb2tzIGxpa2UgdGhpczpcbiAgICAvLyAwIDAgMSAuLiBOQUwgLi4gMCAwIDFcbiAgICAvLyBeIHN5bmMgcG9pbnQgICAgICAgIF4gaVxuICAgIC8vIG9yIHRoaXM6XG4gICAgLy8gMCAwIDEgLi4gTkFMIC4uIDAgMCAwXG4gICAgLy8gXiBzeW5jIHBvaW50ICAgICAgICBeIGlcblxuICAgIC8vIGFkdmFuY2UgdGhlIHN5bmMgcG9pbnQgdG8gYSBOQUwgc3RhcnQsIGlmIG5lY2Vzc2FyeVxuICAgIGZvciAoOyBzeW5jUG9pbnQgPCBidWZmZXIuYnl0ZUxlbmd0aCAtIDM7IHN5bmNQb2ludCsrKSB7XG4gICAgICBpZiAoYnVmZmVyW3N5bmNQb2ludCArIDJdID09PSAxKSB7XG4gICAgICAgIC8vIHRoZSBzeW5jIHBvaW50IGlzIHByb3Blcmx5IGFsaWduZWRcbiAgICAgICAgaSA9IHN5bmNQb2ludCArIDU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHdoaWxlIChpIDwgYnVmZmVyLmJ5dGVMZW5ndGgpIHtcbiAgICAgIC8vIGxvb2sgYXQgdGhlIGN1cnJlbnQgYnl0ZSB0byBkZXRlcm1pbmUgaWYgd2UndmUgaGl0IHRoZSBlbmQgb2ZcbiAgICAgIC8vIGEgTkFMIHVuaXQgYm91bmRhcnlcbiAgICAgIHN3aXRjaCAoYnVmZmVyW2ldKSB7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIC8vIHNraXAgcGFzdCBub24tc3luYyBzZXF1ZW5jZXNcbiAgICAgICAgaWYgKGJ1ZmZlcltpIC0gMV0gIT09IDApIHtcbiAgICAgICAgICBpICs9IDI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH0gZWxzZSBpZiAoYnVmZmVyW2kgLSAyXSAhPT0gMCkge1xuICAgICAgICAgIGkrKztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGRlbGl2ZXIgdGhlIE5BTCB1bml0IGlmIGl0IGlzbid0IGVtcHR5XG4gICAgICAgIGlmIChzeW5jUG9pbnQgKyAzICE9PSBpIC0gMikge1xuICAgICAgICAgIHRoaXMudHJpZ2dlcignZGF0YScsIGJ1ZmZlci5zdWJhcnJheShzeW5jUG9pbnQgKyAzLCBpIC0gMikpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZHJvcCB0cmFpbGluZyB6ZXJvZXNcbiAgICAgICAgZG8ge1xuICAgICAgICAgIGkrKztcbiAgICAgICAgfSB3aGlsZSAoYnVmZmVyW2ldICE9PSAxICYmIGkgPCBidWZmZXIubGVuZ3RoKTtcbiAgICAgICAgc3luY1BvaW50ID0gaSAtIDI7XG4gICAgICAgIGkgKz0gMztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIC8vIHNraXAgcGFzdCBub24tc3luYyBzZXF1ZW5jZXNcbiAgICAgICAgaWYgKGJ1ZmZlcltpIC0gMV0gIT09IDAgfHxcbiAgICAgICAgICAgIGJ1ZmZlcltpIC0gMl0gIT09IDApIHtcbiAgICAgICAgICBpICs9IDM7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBkZWxpdmVyIHRoZSBOQUwgdW5pdFxuICAgICAgICB0aGlzLnRyaWdnZXIoJ2RhdGEnLCBidWZmZXIuc3ViYXJyYXkoc3luY1BvaW50ICsgMywgaSAtIDIpKTtcbiAgICAgICAgc3luY1BvaW50ID0gaSAtIDI7XG4gICAgICAgIGkgKz0gMztcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICAvLyB0aGUgY3VycmVudCBieXRlIGlzbid0IGEgb25lIG9yIHplcm8sIHNvIGl0IGNhbm5vdCBiZSBwYXJ0XG4gICAgICAgIC8vIG9mIGEgc3luYyBzZXF1ZW5jZVxuICAgICAgICBpICs9IDM7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBmaWx0ZXIgb3V0IHRoZSBOQUwgdW5pdHMgdGhhdCB3ZXJlIGRlbGl2ZXJlZFxuICAgIGJ1ZmZlciA9IGJ1ZmZlci5zdWJhcnJheShzeW5jUG9pbnQpO1xuICAgIGkgLT0gc3luY1BvaW50O1xuICAgIHN5bmNQb2ludCA9IDA7XG4gIH07XG5cbiAgdGhpcy5mbHVzaCA9IGZ1bmN0aW9uKCkge1xuICAgIC8vIGRlbGl2ZXIgdGhlIGxhc3QgYnVmZmVyZWQgTkFMIHVuaXRcbiAgICBpZiAoYnVmZmVyICYmIGJ1ZmZlci5ieXRlTGVuZ3RoID4gMykge1xuICAgICAgdGhpcy50cmlnZ2VyKCdkYXRhJywgYnVmZmVyLnN1YmFycmF5KHN5bmNQb2ludCArIDMpKTtcbiAgICB9XG4gICAgLy8gcmVzZXQgdGhlIHN0cmVhbSBzdGF0ZVxuICAgIGJ1ZmZlciA9IG51bGw7XG4gICAgc3luY1BvaW50ID0gMDtcbiAgICB0aGlzLnRyaWdnZXIoJ2RvbmUnKTtcbiAgfTtcbn07XG5OYWxCeXRlU3RyZWFtLnByb3RvdHlwZSA9IG5ldyBTdHJlYW0oKTtcblxuLy8gdmFsdWVzIG9mIHByb2ZpbGVfaWRjIHRoYXQgaW5kaWNhdGUgYWRkaXRpb25hbCBmaWVsZHMgYXJlIGluY2x1ZGVkIGluIHRoZSBTUFNcbi8vIHNlZSBSZWNvbW1lbmRhdGlvbiBJVFUtVCBILjI2NCAoNC8yMDEzKSxcbi8vIDcuMy4yLjEuMSBTZXF1ZW5jZSBwYXJhbWV0ZXIgc2V0IGRhdGEgc3ludGF4XG5QUk9GSUxFU19XSVRIX09QVElPTkFMX1NQU19EQVRBID0ge1xuICAxMDA6IHRydWUsXG4gIDExMDogdHJ1ZSxcbiAgMTIyOiB0cnVlLFxuICAyNDQ6IHRydWUsXG4gIDQ0OiB0cnVlLFxuICA4MzogdHJ1ZSxcbiAgODY6IHRydWUsXG4gIDExODogdHJ1ZSxcbiAgMTI4OiB0cnVlLFxuICAxMzg6IHRydWUsXG4gIDEzOTogdHJ1ZSxcbiAgMTM0OiB0cnVlXG59O1xuXG4vKipcbiAqIEFjY2VwdHMgaW5wdXQgZnJvbSBhIEVsZW1lbnRhcnlTdHJlYW0gYW5kIHByb2R1Y2VzIEguMjY0IE5BTCB1bml0IGRhdGFcbiAqIGV2ZW50cy5cbiAqL1xuSDI2NFN0cmVhbSA9IGZ1bmN0aW9uKCkge1xuICB2YXJcbiAgICBuYWxCeXRlU3RyZWFtID0gbmV3IE5hbEJ5dGVTdHJlYW0oKSxcbiAgICBzZWxmLFxuICAgIHRyYWNrSWQsXG4gICAgY3VycmVudFB0cyxcbiAgICBjdXJyZW50RHRzLFxuXG4gICAgZGlzY2FyZEVtdWxhdGlvblByZXZlbnRpb25CeXRlcyxcbiAgICByZWFkU2VxdWVuY2VQYXJhbWV0ZXJTZXQsXG4gICAgc2tpcFNjYWxpbmdMaXN0O1xuXG4gIEgyNjRTdHJlYW0ucHJvdG90eXBlLmluaXQuY2FsbCh0aGlzKTtcbiAgc2VsZiA9IHRoaXM7XG5cbiAgdGhpcy5wdXNoID0gZnVuY3Rpb24ocGFja2V0KSB7XG4gICAgaWYgKHBhY2tldC50eXBlICE9PSAndmlkZW8nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRyYWNrSWQgPSBwYWNrZXQudHJhY2tJZDtcbiAgICBjdXJyZW50UHRzID0gcGFja2V0LnB0cztcbiAgICBjdXJyZW50RHRzID0gcGFja2V0LmR0cztcblxuICAgIG5hbEJ5dGVTdHJlYW0ucHVzaChwYWNrZXQpO1xuICB9O1xuXG4gIG5hbEJ5dGVTdHJlYW0ub24oJ2RhdGEnLCBmdW5jdGlvbihkYXRhKSB7XG4gICAgdmFyXG4gICAgICBldmVudCA9IHtcbiAgICAgICAgdHJhY2tJZDogdHJhY2tJZCxcbiAgICAgICAgcHRzOiBjdXJyZW50UHRzLFxuICAgICAgICBkdHM6IGN1cnJlbnREdHMsXG4gICAgICAgIGRhdGE6IGRhdGFcbiAgICAgIH07XG5cbiAgICBzd2l0Y2ggKGRhdGFbMF0gJiAweDFmKSB7XG4gICAgY2FzZSAweDA1OlxuICAgICAgZXZlbnQubmFsVW5pdFR5cGUgPSAnc2xpY2VfbGF5ZXJfd2l0aG91dF9wYXJ0aXRpb25pbmdfcmJzcF9pZHInO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAweDA2OlxuICAgICAgZXZlbnQubmFsVW5pdFR5cGUgPSAnc2VpX3Jic3AnO1xuICAgICAgZXZlbnQuZXNjYXBlZFJCU1AgPSBkaXNjYXJkRW11bGF0aW9uUHJldmVudGlvbkJ5dGVzKGRhdGEuc3ViYXJyYXkoMSkpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAweDA3OlxuICAgICAgZXZlbnQubmFsVW5pdFR5cGUgPSAnc2VxX3BhcmFtZXRlcl9zZXRfcmJzcCc7XG4gICAgICBldmVudC5lc2NhcGVkUkJTUCA9IGRpc2NhcmRFbXVsYXRpb25QcmV2ZW50aW9uQnl0ZXMoZGF0YS5zdWJhcnJheSgxKSk7XG4gICAgICBldmVudC5jb25maWcgPSByZWFkU2VxdWVuY2VQYXJhbWV0ZXJTZXQoZXZlbnQuZXNjYXBlZFJCU1ApO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAweDA4OlxuICAgICAgZXZlbnQubmFsVW5pdFR5cGUgPSAncGljX3BhcmFtZXRlcl9zZXRfcmJzcCc7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDB4MDk6XG4gICAgICBldmVudC5uYWxVbml0VHlwZSA9ICdhY2Nlc3NfdW5pdF9kZWxpbWl0ZXJfcmJzcCc7XG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgc2VsZi50cmlnZ2VyKCdkYXRhJywgZXZlbnQpO1xuICB9KTtcbiAgbmFsQnl0ZVN0cmVhbS5vbignZG9uZScsIGZ1bmN0aW9uKCkge1xuICAgIHNlbGYudHJpZ2dlcignZG9uZScpO1xuICB9KTtcblxuICB0aGlzLmZsdXNoID0gZnVuY3Rpb24oKSB7XG4gICAgbmFsQnl0ZVN0cmVhbS5mbHVzaCgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBZHZhbmNlIHRoZSBFeHBHb2xvbWIgZGVjb2RlciBwYXN0IGEgc2NhbGluZyBsaXN0LiBUaGUgc2NhbGluZ1xuICAgKiBsaXN0IGlzIG9wdGlvbmFsbHkgdHJhbnNtaXR0ZWQgYXMgcGFydCBvZiBhIHNlcXVlbmNlIHBhcmFtZXRlclxuICAgKiBzZXQgYW5kIGlzIG5vdCByZWxldmFudCB0byB0cmFuc211eGluZy5cbiAgICogQHBhcmFtIGNvdW50IHtudW1iZXJ9IHRoZSBudW1iZXIgb2YgZW50cmllcyBpbiB0aGlzIHNjYWxpbmcgbGlzdFxuICAgKiBAcGFyYW0gZXhwR29sb21iRGVjb2RlciB7b2JqZWN0fSBhbiBFeHBHb2xvbWIgcG9pbnRlZCB0byB0aGVcbiAgICogc3RhcnQgb2YgYSBzY2FsaW5nIGxpc3RcbiAgICogQHNlZSBSZWNvbW1lbmRhdGlvbiBJVFUtVCBILjI2NCwgU2VjdGlvbiA3LjMuMi4xLjEuMVxuICAgKi9cbiAgc2tpcFNjYWxpbmdMaXN0ID0gZnVuY3Rpb24oY291bnQsIGV4cEdvbG9tYkRlY29kZXIpIHtcbiAgICB2YXJcbiAgICAgIGxhc3RTY2FsZSA9IDgsXG4gICAgICBuZXh0U2NhbGUgPSA4LFxuICAgICAgaixcbiAgICAgIGRlbHRhU2NhbGU7XG5cbiAgICBmb3IgKGogPSAwOyBqIDwgY291bnQ7IGorKykge1xuICAgICAgaWYgKG5leHRTY2FsZSAhPT0gMCkge1xuICAgICAgICBkZWx0YVNjYWxlID0gZXhwR29sb21iRGVjb2Rlci5yZWFkRXhwR29sb21iKCk7XG4gICAgICAgIG5leHRTY2FsZSA9IChsYXN0U2NhbGUgKyBkZWx0YVNjYWxlICsgMjU2KSAlIDI1NjtcbiAgICAgIH1cblxuICAgICAgbGFzdFNjYWxlID0gKG5leHRTY2FsZSA9PT0gMCkgPyBsYXN0U2NhbGUgOiBuZXh0U2NhbGU7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBFeHB1bmdlIGFueSBcIkVtdWxhdGlvbiBQcmV2ZW50aW9uXCIgYnl0ZXMgZnJvbSBhIFwiUmF3IEJ5dGVcbiAgICogU2VxdWVuY2UgUGF5bG9hZFwiXG4gICAqIEBwYXJhbSBkYXRhIHtVaW50OEFycmF5fSB0aGUgYnl0ZXMgb2YgYSBSQlNQIGZyb20gYSBOQUxcbiAgICogdW5pdFxuICAgKiBAcmV0dXJuIHtVaW50OEFycmF5fSB0aGUgUkJTUCB3aXRob3V0IGFueSBFbXVsYXRpb25cbiAgICogUHJldmVudGlvbiBCeXRlc1xuICAgKi9cbiAgZGlzY2FyZEVtdWxhdGlvblByZXZlbnRpb25CeXRlcyA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICB2YXJcbiAgICAgIGxlbmd0aCA9IGRhdGEuYnl0ZUxlbmd0aCxcbiAgICAgIGVtdWxhdGlvblByZXZlbnRpb25CeXRlc1Bvc2l0aW9ucyA9IFtdLFxuICAgICAgaSA9IDEsXG4gICAgICBuZXdMZW5ndGgsIG5ld0RhdGE7XG5cbiAgICAvLyBGaW5kIGFsbCBgRW11bGF0aW9uIFByZXZlbnRpb24gQnl0ZXNgXG4gICAgd2hpbGUgKGkgPCBsZW5ndGggLSAyKSB7XG4gICAgICBpZiAoZGF0YVtpXSA9PT0gMCAmJiBkYXRhW2kgKyAxXSA9PT0gMCAmJiBkYXRhW2kgKyAyXSA9PT0gMHgwMykge1xuICAgICAgICBlbXVsYXRpb25QcmV2ZW50aW9uQnl0ZXNQb3NpdGlvbnMucHVzaChpICsgMik7XG4gICAgICAgIGkgKz0gMjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGkrKztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJZiBubyBFbXVsYXRpb24gUHJldmVudGlvbiBCeXRlcyB3ZXJlIGZvdW5kIGp1c3QgcmV0dXJuIHRoZSBvcmlnaW5hbFxuICAgIC8vIGFycmF5XG4gICAgaWYgKGVtdWxhdGlvblByZXZlbnRpb25CeXRlc1Bvc2l0aW9ucy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cblxuICAgIC8vIENyZWF0ZSBhIG5ldyBhcnJheSB0byBob2xkIHRoZSBOQUwgdW5pdCBkYXRhXG4gICAgbmV3TGVuZ3RoID0gbGVuZ3RoIC0gZW11bGF0aW9uUHJldmVudGlvbkJ5dGVzUG9zaXRpb25zLmxlbmd0aDtcbiAgICBuZXdEYXRhID0gbmV3IFVpbnQ4QXJyYXkobmV3TGVuZ3RoKTtcbiAgICB2YXIgc291cmNlSW5kZXggPSAwO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IG5ld0xlbmd0aDsgc291cmNlSW5kZXgrKywgaSsrKSB7XG4gICAgICBpZiAoc291cmNlSW5kZXggPT09IGVtdWxhdGlvblByZXZlbnRpb25CeXRlc1Bvc2l0aW9uc1swXSkge1xuICAgICAgICAvLyBTa2lwIHRoaXMgYnl0ZVxuICAgICAgICBzb3VyY2VJbmRleCsrO1xuICAgICAgICAvLyBSZW1vdmUgdGhpcyBwb3NpdGlvbiBpbmRleFxuICAgICAgICBlbXVsYXRpb25QcmV2ZW50aW9uQnl0ZXNQb3NpdGlvbnMuc2hpZnQoKTtcbiAgICAgIH1cbiAgICAgIG5ld0RhdGFbaV0gPSBkYXRhW3NvdXJjZUluZGV4XTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3RGF0YTtcbiAgfTtcblxuICAvKipcbiAgICogUmVhZCBhIHNlcXVlbmNlIHBhcmFtZXRlciBzZXQgYW5kIHJldHVybiBzb21lIGludGVyZXN0aW5nIHZpZGVvXG4gICAqIHByb3BlcnRpZXMuIEEgc2VxdWVuY2UgcGFyYW1ldGVyIHNldCBpcyB0aGUgSDI2NCBtZXRhZGF0YSB0aGF0XG4gICAqIGRlc2NyaWJlcyB0aGUgcHJvcGVydGllcyBvZiB1cGNvbWluZyB2aWRlbyBmcmFtZXMuXG4gICAqIEBwYXJhbSBkYXRhIHtVaW50OEFycmF5fSB0aGUgYnl0ZXMgb2YgYSBzZXF1ZW5jZSBwYXJhbWV0ZXIgc2V0XG4gICAqIEByZXR1cm4ge29iamVjdH0gYW4gb2JqZWN0IHdpdGggY29uZmlndXJhdGlvbiBwYXJzZWQgZnJvbSB0aGVcbiAgICogc2VxdWVuY2UgcGFyYW1ldGVyIHNldCwgaW5jbHVkaW5nIHRoZSBkaW1lbnNpb25zIG9mIHRoZVxuICAgKiBhc3NvY2lhdGVkIHZpZGVvIGZyYW1lcy5cbiAgICovXG4gIHJlYWRTZXF1ZW5jZVBhcmFtZXRlclNldCA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICB2YXJcbiAgICAgIGZyYW1lQ3JvcExlZnRPZmZzZXQgPSAwLFxuICAgICAgZnJhbWVDcm9wUmlnaHRPZmZzZXQgPSAwLFxuICAgICAgZnJhbWVDcm9wVG9wT2Zmc2V0ID0gMCxcbiAgICAgIGZyYW1lQ3JvcEJvdHRvbU9mZnNldCA9IDAsXG4gICAgICBzYXJTY2FsZSA9IDEsXG4gICAgICBleHBHb2xvbWJEZWNvZGVyLCBwcm9maWxlSWRjLCBsZXZlbElkYywgcHJvZmlsZUNvbXBhdGliaWxpdHksXG4gICAgICBjaHJvbWFGb3JtYXRJZGMsIHBpY09yZGVyQ250VHlwZSxcbiAgICAgIG51bVJlZkZyYW1lc0luUGljT3JkZXJDbnRDeWNsZSwgcGljV2lkdGhJbk1ic01pbnVzMSxcbiAgICAgIHBpY0hlaWdodEluTWFwVW5pdHNNaW51czEsXG4gICAgICBmcmFtZU1ic09ubHlGbGFnLFxuICAgICAgc2NhbGluZ0xpc3RDb3VudCxcbiAgICAgIHNhclJhdGlvLFxuICAgICAgYXNwZWN0UmF0aW9JZGMsXG4gICAgICBpO1xuXG4gICAgZXhwR29sb21iRGVjb2RlciA9IG5ldyBFeHBHb2xvbWIoZGF0YSk7XG4gICAgcHJvZmlsZUlkYyA9IGV4cEdvbG9tYkRlY29kZXIucmVhZFVuc2lnbmVkQnl0ZSgpOyAvLyBwcm9maWxlX2lkY1xuICAgIHByb2ZpbGVDb21wYXRpYmlsaXR5ID0gZXhwR29sb21iRGVjb2Rlci5yZWFkVW5zaWduZWRCeXRlKCk7IC8vIGNvbnN0cmFpbnRfc2V0WzAtNV1fZmxhZ1xuICAgIGxldmVsSWRjID0gZXhwR29sb21iRGVjb2Rlci5yZWFkVW5zaWduZWRCeXRlKCk7IC8vIGxldmVsX2lkYyB1KDgpXG4gICAgZXhwR29sb21iRGVjb2Rlci5za2lwVW5zaWduZWRFeHBHb2xvbWIoKTsgLy8gc2VxX3BhcmFtZXRlcl9zZXRfaWRcblxuICAgIC8vIHNvbWUgcHJvZmlsZXMgaGF2ZSBtb3JlIG9wdGlvbmFsIGRhdGEgd2UgZG9uJ3QgbmVlZFxuICAgIGlmIChQUk9GSUxFU19XSVRIX09QVElPTkFMX1NQU19EQVRBW3Byb2ZpbGVJZGNdKSB7XG4gICAgICBjaHJvbWFGb3JtYXRJZGMgPSBleHBHb2xvbWJEZWNvZGVyLnJlYWRVbnNpZ25lZEV4cEdvbG9tYigpO1xuICAgICAgaWYgKGNocm9tYUZvcm1hdElkYyA9PT0gMykge1xuICAgICAgICBleHBHb2xvbWJEZWNvZGVyLnNraXBCaXRzKDEpOyAvLyBzZXBhcmF0ZV9jb2xvdXJfcGxhbmVfZmxhZ1xuICAgICAgfVxuICAgICAgZXhwR29sb21iRGVjb2Rlci5za2lwVW5zaWduZWRFeHBHb2xvbWIoKTsgLy8gYml0X2RlcHRoX2x1bWFfbWludXM4XG4gICAgICBleHBHb2xvbWJEZWNvZGVyLnNraXBVbnNpZ25lZEV4cEdvbG9tYigpOyAvLyBiaXRfZGVwdGhfY2hyb21hX21pbnVzOFxuICAgICAgZXhwR29sb21iRGVjb2Rlci5za2lwQml0cygxKTsgLy8gcXBwcmltZV95X3plcm9fdHJhbnNmb3JtX2J5cGFzc19mbGFnXG4gICAgICBpZiAoZXhwR29sb21iRGVjb2Rlci5yZWFkQm9vbGVhbigpKSB7IC8vIHNlcV9zY2FsaW5nX21hdHJpeF9wcmVzZW50X2ZsYWdcbiAgICAgICAgc2NhbGluZ0xpc3RDb3VudCA9IChjaHJvbWFGb3JtYXRJZGMgIT09IDMpID8gOCA6IDEyO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc2NhbGluZ0xpc3RDb3VudDsgaSsrKSB7XG4gICAgICAgICAgaWYgKGV4cEdvbG9tYkRlY29kZXIucmVhZEJvb2xlYW4oKSkgeyAvLyBzZXFfc2NhbGluZ19saXN0X3ByZXNlbnRfZmxhZ1sgaSBdXG4gICAgICAgICAgICBpZiAoaSA8IDYpIHtcbiAgICAgICAgICAgICAgc2tpcFNjYWxpbmdMaXN0KDE2LCBleHBHb2xvbWJEZWNvZGVyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHNraXBTY2FsaW5nTGlzdCg2NCwgZXhwR29sb21iRGVjb2Rlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZXhwR29sb21iRGVjb2Rlci5za2lwVW5zaWduZWRFeHBHb2xvbWIoKTsgLy8gbG9nMl9tYXhfZnJhbWVfbnVtX21pbnVzNFxuICAgIHBpY09yZGVyQ250VHlwZSA9IGV4cEdvbG9tYkRlY29kZXIucmVhZFVuc2lnbmVkRXhwR29sb21iKCk7XG5cbiAgICBpZiAocGljT3JkZXJDbnRUeXBlID09PSAwKSB7XG4gICAgICBleHBHb2xvbWJEZWNvZGVyLnJlYWRVbnNpZ25lZEV4cEdvbG9tYigpOyAvLyBsb2cyX21heF9waWNfb3JkZXJfY250X2xzYl9taW51czRcbiAgICB9IGVsc2UgaWYgKHBpY09yZGVyQ250VHlwZSA9PT0gMSkge1xuICAgICAgZXhwR29sb21iRGVjb2Rlci5za2lwQml0cygxKTsgLy8gZGVsdGFfcGljX29yZGVyX2Fsd2F5c196ZXJvX2ZsYWdcbiAgICAgIGV4cEdvbG9tYkRlY29kZXIuc2tpcEV4cEdvbG9tYigpOyAvLyBvZmZzZXRfZm9yX25vbl9yZWZfcGljXG4gICAgICBleHBHb2xvbWJEZWNvZGVyLnNraXBFeHBHb2xvbWIoKTsgLy8gb2Zmc2V0X2Zvcl90b3BfdG9fYm90dG9tX2ZpZWxkXG4gICAgICBudW1SZWZGcmFtZXNJblBpY09yZGVyQ250Q3ljbGUgPSBleHBHb2xvbWJEZWNvZGVyLnJlYWRVbnNpZ25lZEV4cEdvbG9tYigpO1xuICAgICAgZm9yIChpID0gMDsgaSA8IG51bVJlZkZyYW1lc0luUGljT3JkZXJDbnRDeWNsZTsgaSsrKSB7XG4gICAgICAgIGV4cEdvbG9tYkRlY29kZXIuc2tpcEV4cEdvbG9tYigpOyAvLyBvZmZzZXRfZm9yX3JlZl9mcmFtZVsgaSBdXG4gICAgICB9XG4gICAgfVxuXG4gICAgZXhwR29sb21iRGVjb2Rlci5za2lwVW5zaWduZWRFeHBHb2xvbWIoKTsgLy8gbWF4X251bV9yZWZfZnJhbWVzXG4gICAgZXhwR29sb21iRGVjb2Rlci5za2lwQml0cygxKTsgLy8gZ2Fwc19pbl9mcmFtZV9udW1fdmFsdWVfYWxsb3dlZF9mbGFnXG5cbiAgICBwaWNXaWR0aEluTWJzTWludXMxID0gZXhwR29sb21iRGVjb2Rlci5yZWFkVW5zaWduZWRFeHBHb2xvbWIoKTtcbiAgICBwaWNIZWlnaHRJbk1hcFVuaXRzTWludXMxID0gZXhwR29sb21iRGVjb2Rlci5yZWFkVW5zaWduZWRFeHBHb2xvbWIoKTtcblxuICAgIGZyYW1lTWJzT25seUZsYWcgPSBleHBHb2xvbWJEZWNvZGVyLnJlYWRCaXRzKDEpO1xuICAgIGlmIChmcmFtZU1ic09ubHlGbGFnID09PSAwKSB7XG4gICAgICBleHBHb2xvbWJEZWNvZGVyLnNraXBCaXRzKDEpOyAvLyBtYl9hZGFwdGl2ZV9mcmFtZV9maWVsZF9mbGFnXG4gICAgfVxuXG4gICAgZXhwR29sb21iRGVjb2Rlci5za2lwQml0cygxKTsgLy8gZGlyZWN0Xzh4OF9pbmZlcmVuY2VfZmxhZ1xuICAgIGlmIChleHBHb2xvbWJEZWNvZGVyLnJlYWRCb29sZWFuKCkpIHsgLy8gZnJhbWVfY3JvcHBpbmdfZmxhZ1xuICAgICAgZnJhbWVDcm9wTGVmdE9mZnNldCA9IGV4cEdvbG9tYkRlY29kZXIucmVhZFVuc2lnbmVkRXhwR29sb21iKCk7XG4gICAgICBmcmFtZUNyb3BSaWdodE9mZnNldCA9IGV4cEdvbG9tYkRlY29kZXIucmVhZFVuc2lnbmVkRXhwR29sb21iKCk7XG4gICAgICBmcmFtZUNyb3BUb3BPZmZzZXQgPSBleHBHb2xvbWJEZWNvZGVyLnJlYWRVbnNpZ25lZEV4cEdvbG9tYigpO1xuICAgICAgZnJhbWVDcm9wQm90dG9tT2Zmc2V0ID0gZXhwR29sb21iRGVjb2Rlci5yZWFkVW5zaWduZWRFeHBHb2xvbWIoKTtcbiAgICB9XG4gICAgaWYgKGV4cEdvbG9tYkRlY29kZXIucmVhZEJvb2xlYW4oKSkge1xuICAgICAgLy8gdnVpX3BhcmFtZXRlcnNfcHJlc2VudF9mbGFnXG4gICAgICBpZiAoZXhwR29sb21iRGVjb2Rlci5yZWFkQm9vbGVhbigpKSB7XG4gICAgICAgIC8vIGFzcGVjdF9yYXRpb19pbmZvX3ByZXNlbnRfZmxhZ1xuICAgICAgICBhc3BlY3RSYXRpb0lkYyA9IGV4cEdvbG9tYkRlY29kZXIucmVhZFVuc2lnbmVkQnl0ZSgpO1xuICAgICAgICBzd2l0Y2ggKGFzcGVjdFJhdGlvSWRjKSB7XG4gICAgICAgICAgY2FzZSAxOiBzYXJSYXRpbyA9IFsxLCAxXTsgYnJlYWs7XG4gICAgICAgICAgY2FzZSAyOiBzYXJSYXRpbyA9IFsxMiwgMTFdOyBicmVhaztcbiAgICAgICAgICBjYXNlIDM6IHNhclJhdGlvID0gWzEwLCAxMV07IGJyZWFrO1xuICAgICAgICAgIGNhc2UgNDogc2FyUmF0aW8gPSBbMTYsIDExXTsgYnJlYWs7XG4gICAgICAgICAgY2FzZSA1OiBzYXJSYXRpbyA9IFs0MCwgMzNdOyBicmVhaztcbiAgICAgICAgICBjYXNlIDY6IHNhclJhdGlvID0gWzI0LCAxMV07IGJyZWFrO1xuICAgICAgICAgIGNhc2UgNzogc2FyUmF0aW8gPSBbMjAsIDExXTsgYnJlYWs7XG4gICAgICAgICAgY2FzZSA4OiBzYXJSYXRpbyA9IFszMiwgMTFdOyBicmVhaztcbiAgICAgICAgICBjYXNlIDk6IHNhclJhdGlvID0gWzgwLCAzM107IGJyZWFrO1xuICAgICAgICAgIGNhc2UgMTA6IHNhclJhdGlvID0gWzE4LCAxMV07IGJyZWFrO1xuICAgICAgICAgIGNhc2UgMTE6IHNhclJhdGlvID0gWzE1LCAxMV07IGJyZWFrO1xuICAgICAgICAgIGNhc2UgMTI6IHNhclJhdGlvID0gWzY0LCAzM107IGJyZWFrO1xuICAgICAgICAgIGNhc2UgMTM6IHNhclJhdGlvID0gWzE2MCwgOTldOyBicmVhaztcbiAgICAgICAgICBjYXNlIDE0OiBzYXJSYXRpbyA9IFs0LCAzXTsgYnJlYWs7XG4gICAgICAgICAgY2FzZSAxNTogc2FyUmF0aW8gPSBbMywgMl07IGJyZWFrO1xuICAgICAgICAgIGNhc2UgMTY6IHNhclJhdGlvID0gWzIsIDFdOyBicmVhaztcbiAgICAgICAgICBjYXNlIDI1NToge1xuICAgICAgICAgICAgc2FyUmF0aW8gPSBbZXhwR29sb21iRGVjb2Rlci5yZWFkVW5zaWduZWRCeXRlKCkgPDwgOCB8XG4gICAgICAgICAgICAgICAgICAgICAgICBleHBHb2xvbWJEZWNvZGVyLnJlYWRVbnNpZ25lZEJ5dGUoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cEdvbG9tYkRlY29kZXIucmVhZFVuc2lnbmVkQnl0ZSgpIDw8IDggfFxuICAgICAgICAgICAgICAgICAgICAgICAgZXhwR29sb21iRGVjb2Rlci5yZWFkVW5zaWduZWRCeXRlKCkgXTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc2FyUmF0aW8pIHtcbiAgICAgICAgICBzYXJTY2FsZSA9IHNhclJhdGlvWzBdIC8gc2FyUmF0aW9bMV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHByb2ZpbGVJZGM6IHByb2ZpbGVJZGMsXG4gICAgICBsZXZlbElkYzogbGV2ZWxJZGMsXG4gICAgICBwcm9maWxlQ29tcGF0aWJpbGl0eTogcHJvZmlsZUNvbXBhdGliaWxpdHksXG4gICAgICB3aWR0aDogTWF0aC5jZWlsKCgoKHBpY1dpZHRoSW5NYnNNaW51czEgKyAxKSAqIDE2KSAtIGZyYW1lQ3JvcExlZnRPZmZzZXQgKiAyIC0gZnJhbWVDcm9wUmlnaHRPZmZzZXQgKiAyKSAqIHNhclNjYWxlKSxcbiAgICAgIGhlaWdodDogKCgyIC0gZnJhbWVNYnNPbmx5RmxhZykgKiAocGljSGVpZ2h0SW5NYXBVbml0c01pbnVzMSArIDEpICogMTYpIC0gKGZyYW1lQ3JvcFRvcE9mZnNldCAqIDIpIC0gKGZyYW1lQ3JvcEJvdHRvbU9mZnNldCAqIDIpXG4gICAgfTtcbiAgfTtcblxufTtcbkgyNjRTdHJlYW0ucHJvdG90eXBlID0gbmV3IFN0cmVhbSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgSDI2NFN0cmVhbTogSDI2NFN0cmVhbSxcbiAgTmFsQnl0ZVN0cmVhbTogTmFsQnl0ZVN0cmVhbVxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/videojs-contrib-media-sources/node_modules/mux.js/lib/codecs/h264.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/videojs-contrib-media-sources/node_modules/mux.js/lib/data/silence.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/videojs-contrib-media-sources/node_modules/mux.js/lib/data/silence.js ***!
  \********************************************************************************************/
/***/ ((module) => {

eval("var highPrefix = [33, 16, 5, 32, 164, 27];\nvar lowPrefix = [33, 65, 108, 84, 1, 2, 4, 8, 168, 2, 4, 8, 17, 191, 252];\nvar zeroFill = function(count) {\n  var a = [];\n  while (count--) {\n    a.push(0);\n  }\n  return a;\n};\n\nvar makeTable = function(metaTable) {\n  return Object.keys(metaTable).reduce(function(obj, key) {\n    obj[key] = new Uint8Array(metaTable[key].reduce(function(arr, part) {\n      return arr.concat(part);\n    }, []));\n    return obj;\n  }, {});\n};\n\n// Frames-of-silence to use for filling in missing AAC frames\nvar coneOfSilence = {\n  96000: [highPrefix, [227, 64], zeroFill(154), [56]],\n  88200: [highPrefix, [231], zeroFill(170), [56]],\n  64000: [highPrefix, [248, 192], zeroFill(240), [56]],\n  48000: [highPrefix, [255, 192], zeroFill(268), [55, 148, 128], zeroFill(54), [112]],\n  44100: [highPrefix, [255, 192], zeroFill(268), [55, 163, 128], zeroFill(84), [112]],\n  32000: [highPrefix, [255, 192], zeroFill(268), [55, 234], zeroFill(226), [112]],\n  24000: [highPrefix, [255, 192], zeroFill(268), [55, 255, 128], zeroFill(268), [111, 112], zeroFill(126), [224]],\n  16000: [highPrefix, [255, 192], zeroFill(268), [55, 255, 128], zeroFill(268), [111, 255], zeroFill(269), [223, 108], zeroFill(195), [1, 192]],\n  12000: [lowPrefix, zeroFill(268), [3, 127, 248], zeroFill(268), [6, 255, 240], zeroFill(268), [13, 255, 224], zeroFill(268), [27, 253, 128], zeroFill(259), [56]],\n  11025: [lowPrefix, zeroFill(268), [3, 127, 248], zeroFill(268), [6, 255, 240], zeroFill(268), [13, 255, 224], zeroFill(268), [27, 255, 192], zeroFill(268), [55, 175, 128], zeroFill(108), [112]],\n  8000: [lowPrefix, zeroFill(268), [3, 121, 16], zeroFill(47), [7]]\n};\n\nmodule.exports = makeTable(coneOfSilence);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdmlkZW9qcy1jb250cmliLW1lZGlhLXNvdXJjZXMvbm9kZV9tb2R1bGVzL211eC5qcy9saWIvZGF0YS9zaWxlbmNlLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUcsSUFBSTtBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS12MC1wcm9qZWN0Ly4vbm9kZV9tb2R1bGVzL3ZpZGVvanMtY29udHJpYi1tZWRpYS1zb3VyY2VzL25vZGVfbW9kdWxlcy9tdXguanMvbGliL2RhdGEvc2lsZW5jZS5qcz9lYTI3Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBoaWdoUHJlZml4ID0gWzMzLCAxNiwgNSwgMzIsIDE2NCwgMjddO1xudmFyIGxvd1ByZWZpeCA9IFszMywgNjUsIDEwOCwgODQsIDEsIDIsIDQsIDgsIDE2OCwgMiwgNCwgOCwgMTcsIDE5MSwgMjUyXTtcbnZhciB6ZXJvRmlsbCA9IGZ1bmN0aW9uKGNvdW50KSB7XG4gIHZhciBhID0gW107XG4gIHdoaWxlIChjb3VudC0tKSB7XG4gICAgYS5wdXNoKDApO1xuICB9XG4gIHJldHVybiBhO1xufTtcblxudmFyIG1ha2VUYWJsZSA9IGZ1bmN0aW9uKG1ldGFUYWJsZSkge1xuICByZXR1cm4gT2JqZWN0LmtleXMobWV0YVRhYmxlKS5yZWR1Y2UoZnVuY3Rpb24ob2JqLCBrZXkpIHtcbiAgICBvYmpba2V5XSA9IG5ldyBVaW50OEFycmF5KG1ldGFUYWJsZVtrZXldLnJlZHVjZShmdW5jdGlvbihhcnIsIHBhcnQpIHtcbiAgICAgIHJldHVybiBhcnIuY29uY2F0KHBhcnQpO1xuICAgIH0sIFtdKSk7XG4gICAgcmV0dXJuIG9iajtcbiAgfSwge30pO1xufTtcblxuLy8gRnJhbWVzLW9mLXNpbGVuY2UgdG8gdXNlIGZvciBmaWxsaW5nIGluIG1pc3NpbmcgQUFDIGZyYW1lc1xudmFyIGNvbmVPZlNpbGVuY2UgPSB7XG4gIDk2MDAwOiBbaGlnaFByZWZpeCwgWzIyNywgNjRdLCB6ZXJvRmlsbCgxNTQpLCBbNTZdXSxcbiAgODgyMDA6IFtoaWdoUHJlZml4LCBbMjMxXSwgemVyb0ZpbGwoMTcwKSwgWzU2XV0sXG4gIDY0MDAwOiBbaGlnaFByZWZpeCwgWzI0OCwgMTkyXSwgemVyb0ZpbGwoMjQwKSwgWzU2XV0sXG4gIDQ4MDAwOiBbaGlnaFByZWZpeCwgWzI1NSwgMTkyXSwgemVyb0ZpbGwoMjY4KSwgWzU1LCAxNDgsIDEyOF0sIHplcm9GaWxsKDU0KSwgWzExMl1dLFxuICA0NDEwMDogW2hpZ2hQcmVmaXgsIFsyNTUsIDE5Ml0sIHplcm9GaWxsKDI2OCksIFs1NSwgMTYzLCAxMjhdLCB6ZXJvRmlsbCg4NCksIFsxMTJdXSxcbiAgMzIwMDA6IFtoaWdoUHJlZml4LCBbMjU1LCAxOTJdLCB6ZXJvRmlsbCgyNjgpLCBbNTUsIDIzNF0sIHplcm9GaWxsKDIyNiksIFsxMTJdXSxcbiAgMjQwMDA6IFtoaWdoUHJlZml4LCBbMjU1LCAxOTJdLCB6ZXJvRmlsbCgyNjgpLCBbNTUsIDI1NSwgMTI4XSwgemVyb0ZpbGwoMjY4KSwgWzExMSwgMTEyXSwgemVyb0ZpbGwoMTI2KSwgWzIyNF1dLFxuICAxNjAwMDogW2hpZ2hQcmVmaXgsIFsyNTUsIDE5Ml0sIHplcm9GaWxsKDI2OCksIFs1NSwgMjU1LCAxMjhdLCB6ZXJvRmlsbCgyNjgpLCBbMTExLCAyNTVdLCB6ZXJvRmlsbCgyNjkpLCBbMjIzLCAxMDhdLCB6ZXJvRmlsbCgxOTUpLCBbMSwgMTkyXV0sXG4gIDEyMDAwOiBbbG93UHJlZml4LCB6ZXJvRmlsbCgyNjgpLCBbMywgMTI3LCAyNDhdLCB6ZXJvRmlsbCgyNjgpLCBbNiwgMjU1LCAyNDBdLCB6ZXJvRmlsbCgyNjgpLCBbMTMsIDI1NSwgMjI0XSwgemVyb0ZpbGwoMjY4KSwgWzI3LCAyNTMsIDEyOF0sIHplcm9GaWxsKDI1OSksIFs1Nl1dLFxuICAxMTAyNTogW2xvd1ByZWZpeCwgemVyb0ZpbGwoMjY4KSwgWzMsIDEyNywgMjQ4XSwgemVyb0ZpbGwoMjY4KSwgWzYsIDI1NSwgMjQwXSwgemVyb0ZpbGwoMjY4KSwgWzEzLCAyNTUsIDIyNF0sIHplcm9GaWxsKDI2OCksIFsyNywgMjU1LCAxOTJdLCB6ZXJvRmlsbCgyNjgpLCBbNTUsIDE3NSwgMTI4XSwgemVyb0ZpbGwoMTA4KSwgWzExMl1dLFxuICA4MDAwOiBbbG93UHJlZml4LCB6ZXJvRmlsbCgyNjgpLCBbMywgMTIxLCAxNl0sIHplcm9GaWxsKDQ3KSwgWzddXVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBtYWtlVGFibGUoY29uZU9mU2lsZW5jZSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/videojs-contrib-media-sources/node_modules/mux.js/lib/data/silence.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/videojs-contrib-media-sources/node_modules/mux.js/lib/flv/coalesce-stream.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/videojs-contrib-media-sources/node_modules/mux.js/lib/flv/coalesce-stream.js ***!
  \***************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Stream = __webpack_require__(/*! ../utils/stream.js */ \"(ssr)/./node_modules/videojs-contrib-media-sources/node_modules/mux.js/lib/utils/stream.js\");\n\n/**\n * The final stage of the transmuxer that emits the flv tags\n * for audio, video, and metadata. Also tranlates in time and\n * outputs caption data and id3 cues.\n */\nvar CoalesceStream = function(options) {\n  // Number of Tracks per output segment\n  // If greater than 1, we combine multiple\n  // tracks into a single segment\n  this.numberOfTracks = 0;\n  this.metadataStream = options.metadataStream;\n\n  this.videoTags = [];\n  this.audioTags = [];\n  this.videoTrack = null;\n  this.audioTrack = null;\n  this.pendingCaptions = [];\n  this.pendingMetadata = [];\n  this.pendingTracks = 0;\n  this.processedTracks = 0;\n\n  CoalesceStream.prototype.init.call(this);\n\n  // Take output from multiple\n  this.push = function(output) {\n    // buffer incoming captions until the associated video segment\n    // finishes\n    if (output.text) {\n      return this.pendingCaptions.push(output);\n    }\n    // buffer incoming id3 tags until the final flush\n    if (output.frames) {\n      return this.pendingMetadata.push(output);\n    }\n\n    if (output.track.type === 'video') {\n      this.videoTrack = output.track;\n      this.videoTags = output.tags;\n      this.pendingTracks++;\n    }\n    if (output.track.type === 'audio') {\n      this.audioTrack = output.track;\n      this.audioTags = output.tags;\n      this.pendingTracks++;\n    }\n  };\n};\n\nCoalesceStream.prototype = new Stream();\nCoalesceStream.prototype.flush = function(flushSource) {\n  var\n    id3,\n    caption,\n    i,\n    timelineStartPts,\n    event = {\n      tags: {},\n      captions: [],\n      captionStreams: {},\n      metadata: []\n    };\n\n  if (this.pendingTracks < this.numberOfTracks) {\n    if (flushSource !== 'VideoSegmentStream' &&\n        flushSource !== 'AudioSegmentStream') {\n      // Return because we haven't received a flush from a data-generating\n      // portion of the segment (meaning that we have only recieved meta-data\n      // or captions.)\n      return;\n    } else if (this.pendingTracks === 0) {\n      // In the case where we receive a flush without any data having been\n      // received we consider it an emitted track for the purposes of coalescing\n      // `done` events.\n      // We do this for the case where there is an audio and video track in the\n      // segment but no audio data. (seen in several playlists with alternate\n      // audio tracks and no audio present in the main TS segments.)\n      this.processedTracks++;\n\n      if (this.processedTracks < this.numberOfTracks) {\n        return;\n      }\n    }\n  }\n\n  this.processedTracks += this.pendingTracks;\n  this.pendingTracks = 0;\n\n  if (this.processedTracks < this.numberOfTracks) {\n    return;\n  }\n\n  if (this.videoTrack) {\n    timelineStartPts = this.videoTrack.timelineStartInfo.pts;\n  } else if (this.audioTrack) {\n    timelineStartPts = this.audioTrack.timelineStartInfo.pts;\n  }\n\n  event.tags.videoTags = this.videoTags;\n  event.tags.audioTags = this.audioTags;\n\n  // Translate caption PTS times into second offsets into the\n  // video timeline for the segment, and add track info\n  for (i = 0; i < this.pendingCaptions.length; i++) {\n    caption = this.pendingCaptions[i];\n    caption.startTime = caption.startPts - timelineStartPts;\n    caption.startTime /= 90e3;\n    caption.endTime = caption.endPts - timelineStartPts;\n    caption.endTime /= 90e3;\n    event.captionStreams[caption.stream] = true;\n    event.captions.push(caption);\n  }\n\n  // Translate ID3 frame PTS times into second offsets into the\n  // video timeline for the segment\n  for (i = 0; i < this.pendingMetadata.length; i++) {\n    id3 = this.pendingMetadata[i];\n    id3.cueTime = id3.pts - timelineStartPts;\n    id3.cueTime /= 90e3;\n    event.metadata.push(id3);\n  }\n  // We add this to every single emitted segment even though we only need\n  // it for the first\n  event.metadata.dispatchType = this.metadataStream.dispatchType;\n\n  // Reset stream state\n  this.videoTrack = null;\n  this.audioTrack = null;\n  this.videoTags = [];\n  this.audioTags = [];\n  this.pendingCaptions.length = 0;\n  this.pendingMetadata.length = 0;\n  this.pendingTracks = 0;\n  this.processedTracks = 0;\n\n  // Emit the final segment\n  this.trigger('data', event);\n\n  this.trigger('done');\n};\n\nmodule.exports = CoalesceStream;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdmlkZW9qcy1jb250cmliLW1lZGlhLXNvdXJjZXMvbm9kZV9tb2R1bGVzL211eC5qcy9saWIvZmx2L2NvYWxlc2NlLXN0cmVhbS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixhQUFhLG1CQUFPLENBQUMsc0hBQW9COztBQUV6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsaUNBQWlDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsaUNBQWlDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL215LXYwLXByb2plY3QvLi9ub2RlX21vZHVsZXMvdmlkZW9qcy1jb250cmliLW1lZGlhLXNvdXJjZXMvbm9kZV9tb2R1bGVzL211eC5qcy9saWIvZmx2L2NvYWxlc2NlLXN0cmVhbS5qcz9lYjM3Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIFN0cmVhbSA9IHJlcXVpcmUoJy4uL3V0aWxzL3N0cmVhbS5qcycpO1xuXG4vKipcbiAqIFRoZSBmaW5hbCBzdGFnZSBvZiB0aGUgdHJhbnNtdXhlciB0aGF0IGVtaXRzIHRoZSBmbHYgdGFnc1xuICogZm9yIGF1ZGlvLCB2aWRlbywgYW5kIG1ldGFkYXRhLiBBbHNvIHRyYW5sYXRlcyBpbiB0aW1lIGFuZFxuICogb3V0cHV0cyBjYXB0aW9uIGRhdGEgYW5kIGlkMyBjdWVzLlxuICovXG52YXIgQ29hbGVzY2VTdHJlYW0gPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIC8vIE51bWJlciBvZiBUcmFja3MgcGVyIG91dHB1dCBzZWdtZW50XG4gIC8vIElmIGdyZWF0ZXIgdGhhbiAxLCB3ZSBjb21iaW5lIG11bHRpcGxlXG4gIC8vIHRyYWNrcyBpbnRvIGEgc2luZ2xlIHNlZ21lbnRcbiAgdGhpcy5udW1iZXJPZlRyYWNrcyA9IDA7XG4gIHRoaXMubWV0YWRhdGFTdHJlYW0gPSBvcHRpb25zLm1ldGFkYXRhU3RyZWFtO1xuXG4gIHRoaXMudmlkZW9UYWdzID0gW107XG4gIHRoaXMuYXVkaW9UYWdzID0gW107XG4gIHRoaXMudmlkZW9UcmFjayA9IG51bGw7XG4gIHRoaXMuYXVkaW9UcmFjayA9IG51bGw7XG4gIHRoaXMucGVuZGluZ0NhcHRpb25zID0gW107XG4gIHRoaXMucGVuZGluZ01ldGFkYXRhID0gW107XG4gIHRoaXMucGVuZGluZ1RyYWNrcyA9IDA7XG4gIHRoaXMucHJvY2Vzc2VkVHJhY2tzID0gMDtcblxuICBDb2FsZXNjZVN0cmVhbS5wcm90b3R5cGUuaW5pdC5jYWxsKHRoaXMpO1xuXG4gIC8vIFRha2Ugb3V0cHV0IGZyb20gbXVsdGlwbGVcbiAgdGhpcy5wdXNoID0gZnVuY3Rpb24ob3V0cHV0KSB7XG4gICAgLy8gYnVmZmVyIGluY29taW5nIGNhcHRpb25zIHVudGlsIHRoZSBhc3NvY2lhdGVkIHZpZGVvIHNlZ21lbnRcbiAgICAvLyBmaW5pc2hlc1xuICAgIGlmIChvdXRwdXQudGV4dCkge1xuICAgICAgcmV0dXJuIHRoaXMucGVuZGluZ0NhcHRpb25zLnB1c2gob3V0cHV0KTtcbiAgICB9XG4gICAgLy8gYnVmZmVyIGluY29taW5nIGlkMyB0YWdzIHVudGlsIHRoZSBmaW5hbCBmbHVzaFxuICAgIGlmIChvdXRwdXQuZnJhbWVzKSB7XG4gICAgICByZXR1cm4gdGhpcy5wZW5kaW5nTWV0YWRhdGEucHVzaChvdXRwdXQpO1xuICAgIH1cblxuICAgIGlmIChvdXRwdXQudHJhY2sudHlwZSA9PT0gJ3ZpZGVvJykge1xuICAgICAgdGhpcy52aWRlb1RyYWNrID0gb3V0cHV0LnRyYWNrO1xuICAgICAgdGhpcy52aWRlb1RhZ3MgPSBvdXRwdXQudGFncztcbiAgICAgIHRoaXMucGVuZGluZ1RyYWNrcysrO1xuICAgIH1cbiAgICBpZiAob3V0cHV0LnRyYWNrLnR5cGUgPT09ICdhdWRpbycpIHtcbiAgICAgIHRoaXMuYXVkaW9UcmFjayA9IG91dHB1dC50cmFjaztcbiAgICAgIHRoaXMuYXVkaW9UYWdzID0gb3V0cHV0LnRhZ3M7XG4gICAgICB0aGlzLnBlbmRpbmdUcmFja3MrKztcbiAgICB9XG4gIH07XG59O1xuXG5Db2FsZXNjZVN0cmVhbS5wcm90b3R5cGUgPSBuZXcgU3RyZWFtKCk7XG5Db2FsZXNjZVN0cmVhbS5wcm90b3R5cGUuZmx1c2ggPSBmdW5jdGlvbihmbHVzaFNvdXJjZSkge1xuICB2YXJcbiAgICBpZDMsXG4gICAgY2FwdGlvbixcbiAgICBpLFxuICAgIHRpbWVsaW5lU3RhcnRQdHMsXG4gICAgZXZlbnQgPSB7XG4gICAgICB0YWdzOiB7fSxcbiAgICAgIGNhcHRpb25zOiBbXSxcbiAgICAgIGNhcHRpb25TdHJlYW1zOiB7fSxcbiAgICAgIG1ldGFkYXRhOiBbXVxuICAgIH07XG5cbiAgaWYgKHRoaXMucGVuZGluZ1RyYWNrcyA8IHRoaXMubnVtYmVyT2ZUcmFja3MpIHtcbiAgICBpZiAoZmx1c2hTb3VyY2UgIT09ICdWaWRlb1NlZ21lbnRTdHJlYW0nICYmXG4gICAgICAgIGZsdXNoU291cmNlICE9PSAnQXVkaW9TZWdtZW50U3RyZWFtJykge1xuICAgICAgLy8gUmV0dXJuIGJlY2F1c2Ugd2UgaGF2ZW4ndCByZWNlaXZlZCBhIGZsdXNoIGZyb20gYSBkYXRhLWdlbmVyYXRpbmdcbiAgICAgIC8vIHBvcnRpb24gb2YgdGhlIHNlZ21lbnQgKG1lYW5pbmcgdGhhdCB3ZSBoYXZlIG9ubHkgcmVjaWV2ZWQgbWV0YS1kYXRhXG4gICAgICAvLyBvciBjYXB0aW9ucy4pXG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIGlmICh0aGlzLnBlbmRpbmdUcmFja3MgPT09IDApIHtcbiAgICAgIC8vIEluIHRoZSBjYXNlIHdoZXJlIHdlIHJlY2VpdmUgYSBmbHVzaCB3aXRob3V0IGFueSBkYXRhIGhhdmluZyBiZWVuXG4gICAgICAvLyByZWNlaXZlZCB3ZSBjb25zaWRlciBpdCBhbiBlbWl0dGVkIHRyYWNrIGZvciB0aGUgcHVycG9zZXMgb2YgY29hbGVzY2luZ1xuICAgICAgLy8gYGRvbmVgIGV2ZW50cy5cbiAgICAgIC8vIFdlIGRvIHRoaXMgZm9yIHRoZSBjYXNlIHdoZXJlIHRoZXJlIGlzIGFuIGF1ZGlvIGFuZCB2aWRlbyB0cmFjayBpbiB0aGVcbiAgICAgIC8vIHNlZ21lbnQgYnV0IG5vIGF1ZGlvIGRhdGEuIChzZWVuIGluIHNldmVyYWwgcGxheWxpc3RzIHdpdGggYWx0ZXJuYXRlXG4gICAgICAvLyBhdWRpbyB0cmFja3MgYW5kIG5vIGF1ZGlvIHByZXNlbnQgaW4gdGhlIG1haW4gVFMgc2VnbWVudHMuKVxuICAgICAgdGhpcy5wcm9jZXNzZWRUcmFja3MrKztcblxuICAgICAgaWYgKHRoaXMucHJvY2Vzc2VkVHJhY2tzIDwgdGhpcy5udW1iZXJPZlRyYWNrcykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdGhpcy5wcm9jZXNzZWRUcmFja3MgKz0gdGhpcy5wZW5kaW5nVHJhY2tzO1xuICB0aGlzLnBlbmRpbmdUcmFja3MgPSAwO1xuXG4gIGlmICh0aGlzLnByb2Nlc3NlZFRyYWNrcyA8IHRoaXMubnVtYmVyT2ZUcmFja3MpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAodGhpcy52aWRlb1RyYWNrKSB7XG4gICAgdGltZWxpbmVTdGFydFB0cyA9IHRoaXMudmlkZW9UcmFjay50aW1lbGluZVN0YXJ0SW5mby5wdHM7XG4gIH0gZWxzZSBpZiAodGhpcy5hdWRpb1RyYWNrKSB7XG4gICAgdGltZWxpbmVTdGFydFB0cyA9IHRoaXMuYXVkaW9UcmFjay50aW1lbGluZVN0YXJ0SW5mby5wdHM7XG4gIH1cblxuICBldmVudC50YWdzLnZpZGVvVGFncyA9IHRoaXMudmlkZW9UYWdzO1xuICBldmVudC50YWdzLmF1ZGlvVGFncyA9IHRoaXMuYXVkaW9UYWdzO1xuXG4gIC8vIFRyYW5zbGF0ZSBjYXB0aW9uIFBUUyB0aW1lcyBpbnRvIHNlY29uZCBvZmZzZXRzIGludG8gdGhlXG4gIC8vIHZpZGVvIHRpbWVsaW5lIGZvciB0aGUgc2VnbWVudCwgYW5kIGFkZCB0cmFjayBpbmZvXG4gIGZvciAoaSA9IDA7IGkgPCB0aGlzLnBlbmRpbmdDYXB0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgIGNhcHRpb24gPSB0aGlzLnBlbmRpbmdDYXB0aW9uc1tpXTtcbiAgICBjYXB0aW9uLnN0YXJ0VGltZSA9IGNhcHRpb24uc3RhcnRQdHMgLSB0aW1lbGluZVN0YXJ0UHRzO1xuICAgIGNhcHRpb24uc3RhcnRUaW1lIC89IDkwZTM7XG4gICAgY2FwdGlvbi5lbmRUaW1lID0gY2FwdGlvbi5lbmRQdHMgLSB0aW1lbGluZVN0YXJ0UHRzO1xuICAgIGNhcHRpb24uZW5kVGltZSAvPSA5MGUzO1xuICAgIGV2ZW50LmNhcHRpb25TdHJlYW1zW2NhcHRpb24uc3RyZWFtXSA9IHRydWU7XG4gICAgZXZlbnQuY2FwdGlvbnMucHVzaChjYXB0aW9uKTtcbiAgfVxuXG4gIC8vIFRyYW5zbGF0ZSBJRDMgZnJhbWUgUFRTIHRpbWVzIGludG8gc2Vjb25kIG9mZnNldHMgaW50byB0aGVcbiAgLy8gdmlkZW8gdGltZWxpbmUgZm9yIHRoZSBzZWdtZW50XG4gIGZvciAoaSA9IDA7IGkgPCB0aGlzLnBlbmRpbmdNZXRhZGF0YS5sZW5ndGg7IGkrKykge1xuICAgIGlkMyA9IHRoaXMucGVuZGluZ01ldGFkYXRhW2ldO1xuICAgIGlkMy5jdWVUaW1lID0gaWQzLnB0cyAtIHRpbWVsaW5lU3RhcnRQdHM7XG4gICAgaWQzLmN1ZVRpbWUgLz0gOTBlMztcbiAgICBldmVudC5tZXRhZGF0YS5wdXNoKGlkMyk7XG4gIH1cbiAgLy8gV2UgYWRkIHRoaXMgdG8gZXZlcnkgc2luZ2xlIGVtaXR0ZWQgc2VnbWVudCBldmVuIHRob3VnaCB3ZSBvbmx5IG5lZWRcbiAgLy8gaXQgZm9yIHRoZSBmaXJzdFxuICBldmVudC5tZXRhZGF0YS5kaXNwYXRjaFR5cGUgPSB0aGlzLm1ldGFkYXRhU3RyZWFtLmRpc3BhdGNoVHlwZTtcblxuICAvLyBSZXNldCBzdHJlYW0gc3RhdGVcbiAgdGhpcy52aWRlb1RyYWNrID0gbnVsbDtcbiAgdGhpcy5hdWRpb1RyYWNrID0gbnVsbDtcbiAgdGhpcy52aWRlb1RhZ3MgPSBbXTtcbiAgdGhpcy5hdWRpb1RhZ3MgPSBbXTtcbiAgdGhpcy5wZW5kaW5nQ2FwdGlvbnMubGVuZ3RoID0gMDtcbiAgdGhpcy5wZW5kaW5nTWV0YWRhdGEubGVuZ3RoID0gMDtcbiAgdGhpcy5wZW5kaW5nVHJhY2tzID0gMDtcbiAgdGhpcy5wcm9jZXNzZWRUcmFja3MgPSAwO1xuXG4gIC8vIEVtaXQgdGhlIGZpbmFsIHNlZ21lbnRcbiAgdGhpcy50cmlnZ2VyKCdkYXRhJywgZXZlbnQpO1xuXG4gIHRoaXMudHJpZ2dlcignZG9uZScpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDb2FsZXNjZVN0cmVhbTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/videojs-contrib-media-sources/node_modules/mux.js/lib/flv/coalesce-stream.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/videojs-contrib-media-sources/node_modules/mux.js/lib/flv/flv-header.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/videojs-contrib-media-sources/node_modules/mux.js/lib/flv/flv-header.js ***!
  \**********************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar FlvTag = __webpack_require__(/*! ./flv-tag.js */ \"(ssr)/./node_modules/videojs-contrib-media-sources/node_modules/mux.js/lib/flv/flv-tag.js\");\n\n// For information on the FLV format, see\n// http://download.macromedia.com/f4v/video_file_format_spec_v10_1.pdf.\n// Technically, this function returns the header and a metadata FLV tag\n// if duration is greater than zero\n// duration in seconds\n// @return {object} the bytes of the FLV header as a Uint8Array\nvar getFlvHeader = function(duration, audio, video) { // :ByteArray {\n  var\n    headBytes = new Uint8Array(3 + 1 + 1 + 4),\n    head = new DataView(headBytes.buffer),\n    metadata,\n    result,\n    metadataLength;\n\n  // default arguments\n  duration = duration || 0;\n  audio = audio === undefined ? true : audio;\n  video = video === undefined ? true : video;\n\n  // signature\n  head.setUint8(0, 0x46); // 'F'\n  head.setUint8(1, 0x4c); // 'L'\n  head.setUint8(2, 0x56); // 'V'\n\n  // version\n  head.setUint8(3, 0x01);\n\n  // flags\n  head.setUint8(4, (audio ? 0x04 : 0x00) | (video ? 0x01 : 0x00));\n\n  // data offset, should be 9 for FLV v1\n  head.setUint32(5, headBytes.byteLength);\n\n  // init the first FLV tag\n  if (duration <= 0) {\n    // no duration available so just write the first field of the first\n    // FLV tag\n    result = new Uint8Array(headBytes.byteLength + 4);\n    result.set(headBytes);\n    result.set([0, 0, 0, 0], headBytes.byteLength);\n    return result;\n  }\n\n  // write out the duration metadata tag\n  metadata = new FlvTag(FlvTag.METADATA_TAG);\n  metadata.pts = metadata.dts = 0;\n  metadata.writeMetaDataDouble('duration', duration);\n  metadataLength = metadata.finalize().length;\n  result = new Uint8Array(headBytes.byteLength + metadataLength);\n  result.set(headBytes);\n  result.set(head.byteLength, metadataLength);\n\n  return result;\n};\n\nmodule.exports = getFlvHeader;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdmlkZW9qcy1jb250cmliLW1lZGlhLXNvdXJjZXMvbm9kZV9tb2R1bGVzL211eC5qcy9saWIvZmx2L2Zsdi1oZWFkZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsYUFBYSxtQkFBTyxDQUFDLCtHQUFjOztBQUVuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQkFBMEI7QUFDMUIsMEJBQTBCO0FBQzFCLDBCQUEwQjs7QUFFMUI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL215LXYwLXByb2plY3QvLi9ub2RlX21vZHVsZXMvdmlkZW9qcy1jb250cmliLW1lZGlhLXNvdXJjZXMvbm9kZV9tb2R1bGVzL211eC5qcy9saWIvZmx2L2Zsdi1oZWFkZXIuanM/MTJlNSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBGbHZUYWcgPSByZXF1aXJlKCcuL2Zsdi10YWcuanMnKTtcblxuLy8gRm9yIGluZm9ybWF0aW9uIG9uIHRoZSBGTFYgZm9ybWF0LCBzZWVcbi8vIGh0dHA6Ly9kb3dubG9hZC5tYWNyb21lZGlhLmNvbS9mNHYvdmlkZW9fZmlsZV9mb3JtYXRfc3BlY192MTBfMS5wZGYuXG4vLyBUZWNobmljYWxseSwgdGhpcyBmdW5jdGlvbiByZXR1cm5zIHRoZSBoZWFkZXIgYW5kIGEgbWV0YWRhdGEgRkxWIHRhZ1xuLy8gaWYgZHVyYXRpb24gaXMgZ3JlYXRlciB0aGFuIHplcm9cbi8vIGR1cmF0aW9uIGluIHNlY29uZHNcbi8vIEByZXR1cm4ge29iamVjdH0gdGhlIGJ5dGVzIG9mIHRoZSBGTFYgaGVhZGVyIGFzIGEgVWludDhBcnJheVxudmFyIGdldEZsdkhlYWRlciA9IGZ1bmN0aW9uKGR1cmF0aW9uLCBhdWRpbywgdmlkZW8pIHsgLy8gOkJ5dGVBcnJheSB7XG4gIHZhclxuICAgIGhlYWRCeXRlcyA9IG5ldyBVaW50OEFycmF5KDMgKyAxICsgMSArIDQpLFxuICAgIGhlYWQgPSBuZXcgRGF0YVZpZXcoaGVhZEJ5dGVzLmJ1ZmZlciksXG4gICAgbWV0YWRhdGEsXG4gICAgcmVzdWx0LFxuICAgIG1ldGFkYXRhTGVuZ3RoO1xuXG4gIC8vIGRlZmF1bHQgYXJndW1lbnRzXG4gIGR1cmF0aW9uID0gZHVyYXRpb24gfHwgMDtcbiAgYXVkaW8gPSBhdWRpbyA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IGF1ZGlvO1xuICB2aWRlbyA9IHZpZGVvID09PSB1bmRlZmluZWQgPyB0cnVlIDogdmlkZW87XG5cbiAgLy8gc2lnbmF0dXJlXG4gIGhlYWQuc2V0VWludDgoMCwgMHg0Nik7IC8vICdGJ1xuICBoZWFkLnNldFVpbnQ4KDEsIDB4NGMpOyAvLyAnTCdcbiAgaGVhZC5zZXRVaW50OCgyLCAweDU2KTsgLy8gJ1YnXG5cbiAgLy8gdmVyc2lvblxuICBoZWFkLnNldFVpbnQ4KDMsIDB4MDEpO1xuXG4gIC8vIGZsYWdzXG4gIGhlYWQuc2V0VWludDgoNCwgKGF1ZGlvID8gMHgwNCA6IDB4MDApIHwgKHZpZGVvID8gMHgwMSA6IDB4MDApKTtcblxuICAvLyBkYXRhIG9mZnNldCwgc2hvdWxkIGJlIDkgZm9yIEZMViB2MVxuICBoZWFkLnNldFVpbnQzMig1LCBoZWFkQnl0ZXMuYnl0ZUxlbmd0aCk7XG5cbiAgLy8gaW5pdCB0aGUgZmlyc3QgRkxWIHRhZ1xuICBpZiAoZHVyYXRpb24gPD0gMCkge1xuICAgIC8vIG5vIGR1cmF0aW9uIGF2YWlsYWJsZSBzbyBqdXN0IHdyaXRlIHRoZSBmaXJzdCBmaWVsZCBvZiB0aGUgZmlyc3RcbiAgICAvLyBGTFYgdGFnXG4gICAgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkoaGVhZEJ5dGVzLmJ5dGVMZW5ndGggKyA0KTtcbiAgICByZXN1bHQuc2V0KGhlYWRCeXRlcyk7XG4gICAgcmVzdWx0LnNldChbMCwgMCwgMCwgMF0sIGhlYWRCeXRlcy5ieXRlTGVuZ3RoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLy8gd3JpdGUgb3V0IHRoZSBkdXJhdGlvbiBtZXRhZGF0YSB0YWdcbiAgbWV0YWRhdGEgPSBuZXcgRmx2VGFnKEZsdlRhZy5NRVRBREFUQV9UQUcpO1xuICBtZXRhZGF0YS5wdHMgPSBtZXRhZGF0YS5kdHMgPSAwO1xuICBtZXRhZGF0YS53cml0ZU1ldGFEYXRhRG91YmxlKCdkdXJhdGlvbicsIGR1cmF0aW9uKTtcbiAgbWV0YWRhdGFMZW5ndGggPSBtZXRhZGF0YS5maW5hbGl6ZSgpLmxlbmd0aDtcbiAgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkoaGVhZEJ5dGVzLmJ5dGVMZW5ndGggKyBtZXRhZGF0YUxlbmd0aCk7XG4gIHJlc3VsdC5zZXQoaGVhZEJ5dGVzKTtcbiAgcmVzdWx0LnNldChoZWFkLmJ5dGVMZW5ndGgsIG1ldGFkYXRhTGVuZ3RoKTtcblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBnZXRGbHZIZWFkZXI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/videojs-contrib-media-sources/node_modules/mux.js/lib/flv/flv-header.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/videojs-contrib-media-sources/node_modules/mux.js/lib/flv/flv-tag.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/videojs-contrib-media-sources/node_modules/mux.js/lib/flv/flv-tag.js ***!
  \*******************************************************************************************/
/***/ ((module) => {

"use strict";
eval("/**\n * An object that stores the bytes of an FLV tag and methods for\n * querying and manipulating that data.\n * @see http://download.macromedia.com/f4v/video_file_format_spec_v10_1.pdf\n */\n\n\nvar FlvTag;\n\n// (type:uint, extraData:Boolean = false) extends ByteArray\nFlvTag = function(type, extraData) {\n  var\n    // Counter if this is a metadata tag, nal start marker if this is a video\n    // tag. unused if this is an audio tag\n    adHoc = 0, // :uint\n\n    // The default size is 16kb but this is not enough to hold iframe\n    // data and the resizing algorithm costs a bit so we create a larger\n    // starting buffer for video tags\n    bufferStartSize = 16384,\n\n    // checks whether the FLV tag has enough capacity to accept the proposed\n    // write and re-allocates the internal buffers if necessary\n    prepareWrite = function(flv, count) {\n      var\n        bytes,\n        minLength = flv.position + count;\n      if (minLength < flv.bytes.byteLength) {\n        // there's enough capacity so do nothing\n        return;\n      }\n\n      // allocate a new buffer and copy over the data that will not be modified\n      bytes = new Uint8Array(minLength * 2);\n      bytes.set(flv.bytes.subarray(0, flv.position), 0);\n      flv.bytes = bytes;\n      flv.view = new DataView(flv.bytes.buffer);\n    },\n\n    // commonly used metadata properties\n    widthBytes = FlvTag.widthBytes || new Uint8Array('width'.length),\n    heightBytes = FlvTag.heightBytes || new Uint8Array('height'.length),\n    videocodecidBytes = FlvTag.videocodecidBytes || new Uint8Array('videocodecid'.length),\n    i;\n\n  if (!FlvTag.widthBytes) {\n    // calculating the bytes of common metadata names ahead of time makes the\n    // corresponding writes faster because we don't have to loop over the\n    // characters\n    // re-test with test/perf.html if you're planning on changing this\n    for (i = 0; i < 'width'.length; i++) {\n      widthBytes[i] = 'width'.charCodeAt(i);\n    }\n    for (i = 0; i < 'height'.length; i++) {\n      heightBytes[i] = 'height'.charCodeAt(i);\n    }\n    for (i = 0; i < 'videocodecid'.length; i++) {\n      videocodecidBytes[i] = 'videocodecid'.charCodeAt(i);\n    }\n\n    FlvTag.widthBytes = widthBytes;\n    FlvTag.heightBytes = heightBytes;\n    FlvTag.videocodecidBytes = videocodecidBytes;\n  }\n\n  this.keyFrame = false; // :Boolean\n\n  switch (type) {\n  case FlvTag.VIDEO_TAG:\n    this.length = 16;\n    // Start the buffer at 256k\n    bufferStartSize *= 6;\n    break;\n  case FlvTag.AUDIO_TAG:\n    this.length = 13;\n    this.keyFrame = true;\n    break;\n  case FlvTag.METADATA_TAG:\n    this.length = 29;\n    this.keyFrame = true;\n    break;\n  default:\n    throw new Error('Unknown FLV tag type');\n  }\n\n  this.bytes = new Uint8Array(bufferStartSize);\n  this.view = new DataView(this.bytes.buffer);\n  this.bytes[0] = type;\n  this.position = this.length;\n  this.keyFrame = extraData; // Defaults to false\n\n  // presentation timestamp\n  this.pts = 0;\n  // decoder timestamp\n  this.dts = 0;\n\n  // ByteArray#writeBytes(bytes:ByteArray, offset:uint = 0, length:uint = 0)\n  this.writeBytes = function(bytes, offset, length) {\n    var\n      start = offset || 0,\n      end;\n    length = length || bytes.byteLength;\n    end = start + length;\n\n    prepareWrite(this, length);\n    this.bytes.set(bytes.subarray(start, end), this.position);\n\n    this.position += length;\n    this.length = Math.max(this.length, this.position);\n  };\n\n  // ByteArray#writeByte(value:int):void\n  this.writeByte = function(byte) {\n    prepareWrite(this, 1);\n    this.bytes[this.position] = byte;\n    this.position++;\n    this.length = Math.max(this.length, this.position);\n  };\n\n  // ByteArray#writeShort(value:int):void\n  this.writeShort = function(short) {\n    prepareWrite(this, 2);\n    this.view.setUint16(this.position, short);\n    this.position += 2;\n    this.length = Math.max(this.length, this.position);\n  };\n\n  // Negative index into array\n  // (pos:uint):int\n  this.negIndex = function(pos) {\n    return this.bytes[this.length - pos];\n  };\n\n  // The functions below ONLY work when this[0] == VIDEO_TAG.\n  // We are not going to check for that because we dont want the overhead\n  // (nal:ByteArray = null):int\n  this.nalUnitSize = function() {\n    if (adHoc === 0) {\n      return 0;\n    }\n\n    return this.length - (adHoc + 4);\n  };\n\n  this.startNalUnit = function() {\n    // remember position and add 4 bytes\n    if (adHoc > 0) {\n      throw new Error('Attempted to create new NAL wihout closing the old one');\n    }\n\n    // reserve 4 bytes for nal unit size\n    adHoc = this.length;\n    this.length += 4;\n    this.position = this.length;\n  };\n\n  // (nal:ByteArray = null):void\n  this.endNalUnit = function(nalContainer) {\n    var\n      nalStart, // :uint\n      nalLength; // :uint\n\n    // Rewind to the marker and write the size\n    if (this.length === adHoc + 4) {\n      // we started a nal unit, but didnt write one, so roll back the 4 byte size value\n      this.length -= 4;\n    } else if (adHoc > 0) {\n      nalStart = adHoc + 4;\n      nalLength = this.length - nalStart;\n\n      this.position = adHoc;\n      this.view.setUint32(this.position, nalLength);\n      this.position = this.length;\n\n      if (nalContainer) {\n        // Add the tag to the NAL unit\n        nalContainer.push(this.bytes.subarray(nalStart, nalStart + nalLength));\n      }\n    }\n\n    adHoc = 0;\n  };\n\n  /**\n   * Write out a 64-bit floating point valued metadata property. This method is\n   * called frequently during a typical parse and needs to be fast.\n   */\n  // (key:String, val:Number):void\n  this.writeMetaDataDouble = function(key, val) {\n    var i;\n    prepareWrite(this, 2 + key.length + 9);\n\n    // write size of property name\n    this.view.setUint16(this.position, key.length);\n    this.position += 2;\n\n    // this next part looks terrible but it improves parser throughput by\n    // 10kB/s in my testing\n\n    // write property name\n    if (key === 'width') {\n      this.bytes.set(widthBytes, this.position);\n      this.position += 5;\n    } else if (key === 'height') {\n      this.bytes.set(heightBytes, this.position);\n      this.position += 6;\n    } else if (key === 'videocodecid') {\n      this.bytes.set(videocodecidBytes, this.position);\n      this.position += 12;\n    } else {\n      for (i = 0; i < key.length; i++) {\n        this.bytes[this.position] = key.charCodeAt(i);\n        this.position++;\n      }\n    }\n\n    // skip null byte\n    this.position++;\n\n    // write property value\n    this.view.setFloat64(this.position, val);\n    this.position += 8;\n\n    // update flv tag length\n    this.length = Math.max(this.length, this.position);\n    ++adHoc;\n  };\n\n  // (key:String, val:Boolean):void\n  this.writeMetaDataBoolean = function(key, val) {\n    var i;\n    prepareWrite(this, 2);\n    this.view.setUint16(this.position, key.length);\n    this.position += 2;\n    for (i = 0; i < key.length; i++) {\n      // if key.charCodeAt(i) >= 255, handle error\n      prepareWrite(this, 1);\n      this.bytes[this.position] = key.charCodeAt(i);\n      this.position++;\n    }\n    prepareWrite(this, 2);\n    this.view.setUint8(this.position, 0x01);\n    this.position++;\n    this.view.setUint8(this.position, val ? 0x01 : 0x00);\n    this.position++;\n    this.length = Math.max(this.length, this.position);\n    ++adHoc;\n  };\n\n  // ():ByteArray\n  this.finalize = function() {\n    var\n      dtsDelta, // :int\n      len; // :int\n\n    switch (this.bytes[0]) {\n      // Video Data\n    case FlvTag.VIDEO_TAG:\n       // We only support AVC, 1 = key frame (for AVC, a seekable\n       // frame), 2 = inter frame (for AVC, a non-seekable frame)\n      this.bytes[11] = ((this.keyFrame || extraData) ? 0x10 : 0x20) | 0x07;\n      this.bytes[12] = extraData ?  0x00 : 0x01;\n\n      dtsDelta = this.pts - this.dts;\n      this.bytes[13] = (dtsDelta & 0x00FF0000) >>> 16;\n      this.bytes[14] = (dtsDelta & 0x0000FF00) >>>  8;\n      this.bytes[15] = (dtsDelta & 0x000000FF) >>>  0;\n      break;\n\n    case FlvTag.AUDIO_TAG:\n      this.bytes[11] = 0xAF; // 44 kHz, 16-bit stereo\n      this.bytes[12] = extraData ? 0x00 : 0x01;\n      break;\n\n    case FlvTag.METADATA_TAG:\n      this.position = 11;\n      this.view.setUint8(this.position, 0x02); // String type\n      this.position++;\n      this.view.setUint16(this.position, 0x0A); // 10 Bytes\n      this.position += 2;\n      // set \"onMetaData\"\n      this.bytes.set([0x6f, 0x6e, 0x4d, 0x65,\n                      0x74, 0x61, 0x44, 0x61,\n                      0x74, 0x61], this.position);\n      this.position += 10;\n      this.bytes[this.position] = 0x08; // Array type\n      this.position++;\n      this.view.setUint32(this.position, adHoc);\n      this.position = this.length;\n      this.bytes.set([0, 0, 9], this.position);\n      this.position += 3; // End Data Tag\n      this.length = this.position;\n      break;\n    }\n\n    len = this.length - 11;\n\n    // write the DataSize field\n    this.bytes[ 1] = (len & 0x00FF0000) >>> 16;\n    this.bytes[ 2] = (len & 0x0000FF00) >>>  8;\n    this.bytes[ 3] = (len & 0x000000FF) >>>  0;\n    // write the Timestamp\n    this.bytes[ 4] = (this.dts & 0x00FF0000) >>> 16;\n    this.bytes[ 5] = (this.dts & 0x0000FF00) >>>  8;\n    this.bytes[ 6] = (this.dts & 0x000000FF) >>>  0;\n    this.bytes[ 7] = (this.dts & 0xFF000000) >>> 24;\n    // write the StreamID\n    this.bytes[ 8] = 0;\n    this.bytes[ 9] = 0;\n    this.bytes[10] = 0;\n\n    // Sometimes we're at the end of the view and have one slot to write a\n    // uint32, so, prepareWrite of count 4, since, view is uint8\n    prepareWrite(this, 4);\n    this.view.setUint32(this.length, this.length);\n    this.length += 4;\n    this.position += 4;\n\n    // trim down the byte buffer to what is actually being used\n    this.bytes = this.bytes.subarray(0, this.length);\n    this.frameTime = FlvTag.frameTime(this.bytes);\n    // if bytes.bytelength isn't equal to this.length, handle error\n    return this;\n  };\n};\n\nFlvTag.AUDIO_TAG = 0x08; // == 8, :uint\nFlvTag.VIDEO_TAG = 0x09; // == 9, :uint\nFlvTag.METADATA_TAG = 0x12; // == 18, :uint\n\n// (tag:ByteArray):Boolean {\nFlvTag.isAudioFrame = function(tag) {\n  return FlvTag.AUDIO_TAG === tag[0];\n};\n\n// (tag:ByteArray):Boolean {\nFlvTag.isVideoFrame = function(tag) {\n  return FlvTag.VIDEO_TAG === tag[0];\n};\n\n// (tag:ByteArray):Boolean {\nFlvTag.isMetaData = function(tag) {\n  return FlvTag.METADATA_TAG === tag[0];\n};\n\n// (tag:ByteArray):Boolean {\nFlvTag.isKeyFrame = function(tag) {\n  if (FlvTag.isVideoFrame(tag)) {\n    return tag[11] === 0x17;\n  }\n\n  if (FlvTag.isAudioFrame(tag)) {\n    return true;\n  }\n\n  if (FlvTag.isMetaData(tag)) {\n    return true;\n  }\n\n  return false;\n};\n\n// (tag:ByteArray):uint {\nFlvTag.frameTime = function(tag) {\n  var pts = tag[ 4] << 16; // :uint\n  pts |= tag[ 5] <<  8;\n  pts |= tag[ 6] <<  0;\n  pts |= tag[ 7] << 24;\n  return pts;\n};\n\nmodule.exports = FlvTag;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdmlkZW9qcy1jb250cmliLW1lZGlhLXNvdXJjZXMvbm9kZV9tb2R1bGVzL211eC5qcy9saWIvZmx2L2Zsdi10YWcuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNhOztBQUViOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isb0JBQW9CO0FBQ3BDO0FBQ0E7QUFDQSxnQkFBZ0IscUJBQXFCO0FBQ3JDO0FBQ0E7QUFDQSxnQkFBZ0IsMkJBQTJCO0FBQzNDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCOztBQUV6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCOztBQUU3QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ04sa0JBQWtCLGdCQUFnQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZ0JBQWdCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUI7QUFDekIseUJBQXlCO0FBQ3pCLDRCQUE0Qjs7QUFFNUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktdjAtcHJvamVjdC8uL25vZGVfbW9kdWxlcy92aWRlb2pzLWNvbnRyaWItbWVkaWEtc291cmNlcy9ub2RlX21vZHVsZXMvbXV4LmpzL2xpYi9mbHYvZmx2LXRhZy5qcz81YWI5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQW4gb2JqZWN0IHRoYXQgc3RvcmVzIHRoZSBieXRlcyBvZiBhbiBGTFYgdGFnIGFuZCBtZXRob2RzIGZvclxuICogcXVlcnlpbmcgYW5kIG1hbmlwdWxhdGluZyB0aGF0IGRhdGEuXG4gKiBAc2VlIGh0dHA6Ly9kb3dubG9hZC5tYWNyb21lZGlhLmNvbS9mNHYvdmlkZW9fZmlsZV9mb3JtYXRfc3BlY192MTBfMS5wZGZcbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRmx2VGFnO1xuXG4vLyAodHlwZTp1aW50LCBleHRyYURhdGE6Qm9vbGVhbiA9IGZhbHNlKSBleHRlbmRzIEJ5dGVBcnJheVxuRmx2VGFnID0gZnVuY3Rpb24odHlwZSwgZXh0cmFEYXRhKSB7XG4gIHZhclxuICAgIC8vIENvdW50ZXIgaWYgdGhpcyBpcyBhIG1ldGFkYXRhIHRhZywgbmFsIHN0YXJ0IG1hcmtlciBpZiB0aGlzIGlzIGEgdmlkZW9cbiAgICAvLyB0YWcuIHVudXNlZCBpZiB0aGlzIGlzIGFuIGF1ZGlvIHRhZ1xuICAgIGFkSG9jID0gMCwgLy8gOnVpbnRcblxuICAgIC8vIFRoZSBkZWZhdWx0IHNpemUgaXMgMTZrYiBidXQgdGhpcyBpcyBub3QgZW5vdWdoIHRvIGhvbGQgaWZyYW1lXG4gICAgLy8gZGF0YSBhbmQgdGhlIHJlc2l6aW5nIGFsZ29yaXRobSBjb3N0cyBhIGJpdCBzbyB3ZSBjcmVhdGUgYSBsYXJnZXJcbiAgICAvLyBzdGFydGluZyBidWZmZXIgZm9yIHZpZGVvIHRhZ3NcbiAgICBidWZmZXJTdGFydFNpemUgPSAxNjM4NCxcblxuICAgIC8vIGNoZWNrcyB3aGV0aGVyIHRoZSBGTFYgdGFnIGhhcyBlbm91Z2ggY2FwYWNpdHkgdG8gYWNjZXB0IHRoZSBwcm9wb3NlZFxuICAgIC8vIHdyaXRlIGFuZCByZS1hbGxvY2F0ZXMgdGhlIGludGVybmFsIGJ1ZmZlcnMgaWYgbmVjZXNzYXJ5XG4gICAgcHJlcGFyZVdyaXRlID0gZnVuY3Rpb24oZmx2LCBjb3VudCkge1xuICAgICAgdmFyXG4gICAgICAgIGJ5dGVzLFxuICAgICAgICBtaW5MZW5ndGggPSBmbHYucG9zaXRpb24gKyBjb3VudDtcbiAgICAgIGlmIChtaW5MZW5ndGggPCBmbHYuYnl0ZXMuYnl0ZUxlbmd0aCkge1xuICAgICAgICAvLyB0aGVyZSdzIGVub3VnaCBjYXBhY2l0eSBzbyBkbyBub3RoaW5nXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gYWxsb2NhdGUgYSBuZXcgYnVmZmVyIGFuZCBjb3B5IG92ZXIgdGhlIGRhdGEgdGhhdCB3aWxsIG5vdCBiZSBtb2RpZmllZFxuICAgICAgYnl0ZXMgPSBuZXcgVWludDhBcnJheShtaW5MZW5ndGggKiAyKTtcbiAgICAgIGJ5dGVzLnNldChmbHYuYnl0ZXMuc3ViYXJyYXkoMCwgZmx2LnBvc2l0aW9uKSwgMCk7XG4gICAgICBmbHYuYnl0ZXMgPSBieXRlcztcbiAgICAgIGZsdi52aWV3ID0gbmV3IERhdGFWaWV3KGZsdi5ieXRlcy5idWZmZXIpO1xuICAgIH0sXG5cbiAgICAvLyBjb21tb25seSB1c2VkIG1ldGFkYXRhIHByb3BlcnRpZXNcbiAgICB3aWR0aEJ5dGVzID0gRmx2VGFnLndpZHRoQnl0ZXMgfHwgbmV3IFVpbnQ4QXJyYXkoJ3dpZHRoJy5sZW5ndGgpLFxuICAgIGhlaWdodEJ5dGVzID0gRmx2VGFnLmhlaWdodEJ5dGVzIHx8IG5ldyBVaW50OEFycmF5KCdoZWlnaHQnLmxlbmd0aCksXG4gICAgdmlkZW9jb2RlY2lkQnl0ZXMgPSBGbHZUYWcudmlkZW9jb2RlY2lkQnl0ZXMgfHwgbmV3IFVpbnQ4QXJyYXkoJ3ZpZGVvY29kZWNpZCcubGVuZ3RoKSxcbiAgICBpO1xuXG4gIGlmICghRmx2VGFnLndpZHRoQnl0ZXMpIHtcbiAgICAvLyBjYWxjdWxhdGluZyB0aGUgYnl0ZXMgb2YgY29tbW9uIG1ldGFkYXRhIG5hbWVzIGFoZWFkIG9mIHRpbWUgbWFrZXMgdGhlXG4gICAgLy8gY29ycmVzcG9uZGluZyB3cml0ZXMgZmFzdGVyIGJlY2F1c2Ugd2UgZG9uJ3QgaGF2ZSB0byBsb29wIG92ZXIgdGhlXG4gICAgLy8gY2hhcmFjdGVyc1xuICAgIC8vIHJlLXRlc3Qgd2l0aCB0ZXN0L3BlcmYuaHRtbCBpZiB5b3UncmUgcGxhbm5pbmcgb24gY2hhbmdpbmcgdGhpc1xuICAgIGZvciAoaSA9IDA7IGkgPCAnd2lkdGgnLmxlbmd0aDsgaSsrKSB7XG4gICAgICB3aWR0aEJ5dGVzW2ldID0gJ3dpZHRoJy5jaGFyQ29kZUF0KGkpO1xuICAgIH1cbiAgICBmb3IgKGkgPSAwOyBpIDwgJ2hlaWdodCcubGVuZ3RoOyBpKyspIHtcbiAgICAgIGhlaWdodEJ5dGVzW2ldID0gJ2hlaWdodCcuY2hhckNvZGVBdChpKTtcbiAgICB9XG4gICAgZm9yIChpID0gMDsgaSA8ICd2aWRlb2NvZGVjaWQnLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2aWRlb2NvZGVjaWRCeXRlc1tpXSA9ICd2aWRlb2NvZGVjaWQnLmNoYXJDb2RlQXQoaSk7XG4gICAgfVxuXG4gICAgRmx2VGFnLndpZHRoQnl0ZXMgPSB3aWR0aEJ5dGVzO1xuICAgIEZsdlRhZy5oZWlnaHRCeXRlcyA9IGhlaWdodEJ5dGVzO1xuICAgIEZsdlRhZy52aWRlb2NvZGVjaWRCeXRlcyA9IHZpZGVvY29kZWNpZEJ5dGVzO1xuICB9XG5cbiAgdGhpcy5rZXlGcmFtZSA9IGZhbHNlOyAvLyA6Qm9vbGVhblxuXG4gIHN3aXRjaCAodHlwZSkge1xuICBjYXNlIEZsdlRhZy5WSURFT19UQUc6XG4gICAgdGhpcy5sZW5ndGggPSAxNjtcbiAgICAvLyBTdGFydCB0aGUgYnVmZmVyIGF0IDI1NmtcbiAgICBidWZmZXJTdGFydFNpemUgKj0gNjtcbiAgICBicmVhaztcbiAgY2FzZSBGbHZUYWcuQVVESU9fVEFHOlxuICAgIHRoaXMubGVuZ3RoID0gMTM7XG4gICAgdGhpcy5rZXlGcmFtZSA9IHRydWU7XG4gICAgYnJlYWs7XG4gIGNhc2UgRmx2VGFnLk1FVEFEQVRBX1RBRzpcbiAgICB0aGlzLmxlbmd0aCA9IDI5O1xuICAgIHRoaXMua2V5RnJhbWUgPSB0cnVlO1xuICAgIGJyZWFrO1xuICBkZWZhdWx0OlxuICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBGTFYgdGFnIHR5cGUnKTtcbiAgfVxuXG4gIHRoaXMuYnl0ZXMgPSBuZXcgVWludDhBcnJheShidWZmZXJTdGFydFNpemUpO1xuICB0aGlzLnZpZXcgPSBuZXcgRGF0YVZpZXcodGhpcy5ieXRlcy5idWZmZXIpO1xuICB0aGlzLmJ5dGVzWzBdID0gdHlwZTtcbiAgdGhpcy5wb3NpdGlvbiA9IHRoaXMubGVuZ3RoO1xuICB0aGlzLmtleUZyYW1lID0gZXh0cmFEYXRhOyAvLyBEZWZhdWx0cyB0byBmYWxzZVxuXG4gIC8vIHByZXNlbnRhdGlvbiB0aW1lc3RhbXBcbiAgdGhpcy5wdHMgPSAwO1xuICAvLyBkZWNvZGVyIHRpbWVzdGFtcFxuICB0aGlzLmR0cyA9IDA7XG5cbiAgLy8gQnl0ZUFycmF5I3dyaXRlQnl0ZXMoYnl0ZXM6Qnl0ZUFycmF5LCBvZmZzZXQ6dWludCA9IDAsIGxlbmd0aDp1aW50ID0gMClcbiAgdGhpcy53cml0ZUJ5dGVzID0gZnVuY3Rpb24oYnl0ZXMsIG9mZnNldCwgbGVuZ3RoKSB7XG4gICAgdmFyXG4gICAgICBzdGFydCA9IG9mZnNldCB8fCAwLFxuICAgICAgZW5kO1xuICAgIGxlbmd0aCA9IGxlbmd0aCB8fCBieXRlcy5ieXRlTGVuZ3RoO1xuICAgIGVuZCA9IHN0YXJ0ICsgbGVuZ3RoO1xuXG4gICAgcHJlcGFyZVdyaXRlKHRoaXMsIGxlbmd0aCk7XG4gICAgdGhpcy5ieXRlcy5zZXQoYnl0ZXMuc3ViYXJyYXkoc3RhcnQsIGVuZCksIHRoaXMucG9zaXRpb24pO1xuXG4gICAgdGhpcy5wb3NpdGlvbiArPSBsZW5ndGg7XG4gICAgdGhpcy5sZW5ndGggPSBNYXRoLm1heCh0aGlzLmxlbmd0aCwgdGhpcy5wb3NpdGlvbik7XG4gIH07XG5cbiAgLy8gQnl0ZUFycmF5I3dyaXRlQnl0ZSh2YWx1ZTppbnQpOnZvaWRcbiAgdGhpcy53cml0ZUJ5dGUgPSBmdW5jdGlvbihieXRlKSB7XG4gICAgcHJlcGFyZVdyaXRlKHRoaXMsIDEpO1xuICAgIHRoaXMuYnl0ZXNbdGhpcy5wb3NpdGlvbl0gPSBieXRlO1xuICAgIHRoaXMucG9zaXRpb24rKztcbiAgICB0aGlzLmxlbmd0aCA9IE1hdGgubWF4KHRoaXMubGVuZ3RoLCB0aGlzLnBvc2l0aW9uKTtcbiAgfTtcblxuICAvLyBCeXRlQXJyYXkjd3JpdGVTaG9ydCh2YWx1ZTppbnQpOnZvaWRcbiAgdGhpcy53cml0ZVNob3J0ID0gZnVuY3Rpb24oc2hvcnQpIHtcbiAgICBwcmVwYXJlV3JpdGUodGhpcywgMik7XG4gICAgdGhpcy52aWV3LnNldFVpbnQxNih0aGlzLnBvc2l0aW9uLCBzaG9ydCk7XG4gICAgdGhpcy5wb3NpdGlvbiArPSAyO1xuICAgIHRoaXMubGVuZ3RoID0gTWF0aC5tYXgodGhpcy5sZW5ndGgsIHRoaXMucG9zaXRpb24pO1xuICB9O1xuXG4gIC8vIE5lZ2F0aXZlIGluZGV4IGludG8gYXJyYXlcbiAgLy8gKHBvczp1aW50KTppbnRcbiAgdGhpcy5uZWdJbmRleCA9IGZ1bmN0aW9uKHBvcykge1xuICAgIHJldHVybiB0aGlzLmJ5dGVzW3RoaXMubGVuZ3RoIC0gcG9zXTtcbiAgfTtcblxuICAvLyBUaGUgZnVuY3Rpb25zIGJlbG93IE9OTFkgd29yayB3aGVuIHRoaXNbMF0gPT0gVklERU9fVEFHLlxuICAvLyBXZSBhcmUgbm90IGdvaW5nIHRvIGNoZWNrIGZvciB0aGF0IGJlY2F1c2Ugd2UgZG9udCB3YW50IHRoZSBvdmVyaGVhZFxuICAvLyAobmFsOkJ5dGVBcnJheSA9IG51bGwpOmludFxuICB0aGlzLm5hbFVuaXRTaXplID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKGFkSG9jID09PSAwKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5sZW5ndGggLSAoYWRIb2MgKyA0KTtcbiAgfTtcblxuICB0aGlzLnN0YXJ0TmFsVW5pdCA9IGZ1bmN0aW9uKCkge1xuICAgIC8vIHJlbWVtYmVyIHBvc2l0aW9uIGFuZCBhZGQgNCBieXRlc1xuICAgIGlmIChhZEhvYyA+IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQXR0ZW1wdGVkIHRvIGNyZWF0ZSBuZXcgTkFMIHdpaG91dCBjbG9zaW5nIHRoZSBvbGQgb25lJyk7XG4gICAgfVxuXG4gICAgLy8gcmVzZXJ2ZSA0IGJ5dGVzIGZvciBuYWwgdW5pdCBzaXplXG4gICAgYWRIb2MgPSB0aGlzLmxlbmd0aDtcbiAgICB0aGlzLmxlbmd0aCArPSA0O1xuICAgIHRoaXMucG9zaXRpb24gPSB0aGlzLmxlbmd0aDtcbiAgfTtcblxuICAvLyAobmFsOkJ5dGVBcnJheSA9IG51bGwpOnZvaWRcbiAgdGhpcy5lbmROYWxVbml0ID0gZnVuY3Rpb24obmFsQ29udGFpbmVyKSB7XG4gICAgdmFyXG4gICAgICBuYWxTdGFydCwgLy8gOnVpbnRcbiAgICAgIG5hbExlbmd0aDsgLy8gOnVpbnRcblxuICAgIC8vIFJld2luZCB0byB0aGUgbWFya2VyIGFuZCB3cml0ZSB0aGUgc2l6ZVxuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gYWRIb2MgKyA0KSB7XG4gICAgICAvLyB3ZSBzdGFydGVkIGEgbmFsIHVuaXQsIGJ1dCBkaWRudCB3cml0ZSBvbmUsIHNvIHJvbGwgYmFjayB0aGUgNCBieXRlIHNpemUgdmFsdWVcbiAgICAgIHRoaXMubGVuZ3RoIC09IDQ7XG4gICAgfSBlbHNlIGlmIChhZEhvYyA+IDApIHtcbiAgICAgIG5hbFN0YXJ0ID0gYWRIb2MgKyA0O1xuICAgICAgbmFsTGVuZ3RoID0gdGhpcy5sZW5ndGggLSBuYWxTdGFydDtcblxuICAgICAgdGhpcy5wb3NpdGlvbiA9IGFkSG9jO1xuICAgICAgdGhpcy52aWV3LnNldFVpbnQzMih0aGlzLnBvc2l0aW9uLCBuYWxMZW5ndGgpO1xuICAgICAgdGhpcy5wb3NpdGlvbiA9IHRoaXMubGVuZ3RoO1xuXG4gICAgICBpZiAobmFsQ29udGFpbmVyKSB7XG4gICAgICAgIC8vIEFkZCB0aGUgdGFnIHRvIHRoZSBOQUwgdW5pdFxuICAgICAgICBuYWxDb250YWluZXIucHVzaCh0aGlzLmJ5dGVzLnN1YmFycmF5KG5hbFN0YXJ0LCBuYWxTdGFydCArIG5hbExlbmd0aCkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGFkSG9jID0gMDtcbiAgfTtcblxuICAvKipcbiAgICogV3JpdGUgb3V0IGEgNjQtYml0IGZsb2F0aW5nIHBvaW50IHZhbHVlZCBtZXRhZGF0YSBwcm9wZXJ0eS4gVGhpcyBtZXRob2QgaXNcbiAgICogY2FsbGVkIGZyZXF1ZW50bHkgZHVyaW5nIGEgdHlwaWNhbCBwYXJzZSBhbmQgbmVlZHMgdG8gYmUgZmFzdC5cbiAgICovXG4gIC8vIChrZXk6U3RyaW5nLCB2YWw6TnVtYmVyKTp2b2lkXG4gIHRoaXMud3JpdGVNZXRhRGF0YURvdWJsZSA9IGZ1bmN0aW9uKGtleSwgdmFsKSB7XG4gICAgdmFyIGk7XG4gICAgcHJlcGFyZVdyaXRlKHRoaXMsIDIgKyBrZXkubGVuZ3RoICsgOSk7XG5cbiAgICAvLyB3cml0ZSBzaXplIG9mIHByb3BlcnR5IG5hbWVcbiAgICB0aGlzLnZpZXcuc2V0VWludDE2KHRoaXMucG9zaXRpb24sIGtleS5sZW5ndGgpO1xuICAgIHRoaXMucG9zaXRpb24gKz0gMjtcblxuICAgIC8vIHRoaXMgbmV4dCBwYXJ0IGxvb2tzIHRlcnJpYmxlIGJ1dCBpdCBpbXByb3ZlcyBwYXJzZXIgdGhyb3VnaHB1dCBieVxuICAgIC8vIDEwa0IvcyBpbiBteSB0ZXN0aW5nXG5cbiAgICAvLyB3cml0ZSBwcm9wZXJ0eSBuYW1lXG4gICAgaWYgKGtleSA9PT0gJ3dpZHRoJykge1xuICAgICAgdGhpcy5ieXRlcy5zZXQod2lkdGhCeXRlcywgdGhpcy5wb3NpdGlvbik7XG4gICAgICB0aGlzLnBvc2l0aW9uICs9IDU7XG4gICAgfSBlbHNlIGlmIChrZXkgPT09ICdoZWlnaHQnKSB7XG4gICAgICB0aGlzLmJ5dGVzLnNldChoZWlnaHRCeXRlcywgdGhpcy5wb3NpdGlvbik7XG4gICAgICB0aGlzLnBvc2l0aW9uICs9IDY7XG4gICAgfSBlbHNlIGlmIChrZXkgPT09ICd2aWRlb2NvZGVjaWQnKSB7XG4gICAgICB0aGlzLmJ5dGVzLnNldCh2aWRlb2NvZGVjaWRCeXRlcywgdGhpcy5wb3NpdGlvbik7XG4gICAgICB0aGlzLnBvc2l0aW9uICs9IDEyO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwga2V5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMuYnl0ZXNbdGhpcy5wb3NpdGlvbl0gPSBrZXkuY2hhckNvZGVBdChpKTtcbiAgICAgICAgdGhpcy5wb3NpdGlvbisrO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHNraXAgbnVsbCBieXRlXG4gICAgdGhpcy5wb3NpdGlvbisrO1xuXG4gICAgLy8gd3JpdGUgcHJvcGVydHkgdmFsdWVcbiAgICB0aGlzLnZpZXcuc2V0RmxvYXQ2NCh0aGlzLnBvc2l0aW9uLCB2YWwpO1xuICAgIHRoaXMucG9zaXRpb24gKz0gODtcblxuICAgIC8vIHVwZGF0ZSBmbHYgdGFnIGxlbmd0aFxuICAgIHRoaXMubGVuZ3RoID0gTWF0aC5tYXgodGhpcy5sZW5ndGgsIHRoaXMucG9zaXRpb24pO1xuICAgICsrYWRIb2M7XG4gIH07XG5cbiAgLy8gKGtleTpTdHJpbmcsIHZhbDpCb29sZWFuKTp2b2lkXG4gIHRoaXMud3JpdGVNZXRhRGF0YUJvb2xlYW4gPSBmdW5jdGlvbihrZXksIHZhbCkge1xuICAgIHZhciBpO1xuICAgIHByZXBhcmVXcml0ZSh0aGlzLCAyKTtcbiAgICB0aGlzLnZpZXcuc2V0VWludDE2KHRoaXMucG9zaXRpb24sIGtleS5sZW5ndGgpO1xuICAgIHRoaXMucG9zaXRpb24gKz0gMjtcbiAgICBmb3IgKGkgPSAwOyBpIDwga2V5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAvLyBpZiBrZXkuY2hhckNvZGVBdChpKSA+PSAyNTUsIGhhbmRsZSBlcnJvclxuICAgICAgcHJlcGFyZVdyaXRlKHRoaXMsIDEpO1xuICAgICAgdGhpcy5ieXRlc1t0aGlzLnBvc2l0aW9uXSA9IGtleS5jaGFyQ29kZUF0KGkpO1xuICAgICAgdGhpcy5wb3NpdGlvbisrO1xuICAgIH1cbiAgICBwcmVwYXJlV3JpdGUodGhpcywgMik7XG4gICAgdGhpcy52aWV3LnNldFVpbnQ4KHRoaXMucG9zaXRpb24sIDB4MDEpO1xuICAgIHRoaXMucG9zaXRpb24rKztcbiAgICB0aGlzLnZpZXcuc2V0VWludDgodGhpcy5wb3NpdGlvbiwgdmFsID8gMHgwMSA6IDB4MDApO1xuICAgIHRoaXMucG9zaXRpb24rKztcbiAgICB0aGlzLmxlbmd0aCA9IE1hdGgubWF4KHRoaXMubGVuZ3RoLCB0aGlzLnBvc2l0aW9uKTtcbiAgICArK2FkSG9jO1xuICB9O1xuXG4gIC8vICgpOkJ5dGVBcnJheVxuICB0aGlzLmZpbmFsaXplID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyXG4gICAgICBkdHNEZWx0YSwgLy8gOmludFxuICAgICAgbGVuOyAvLyA6aW50XG5cbiAgICBzd2l0Y2ggKHRoaXMuYnl0ZXNbMF0pIHtcbiAgICAgIC8vIFZpZGVvIERhdGFcbiAgICBjYXNlIEZsdlRhZy5WSURFT19UQUc6XG4gICAgICAgLy8gV2Ugb25seSBzdXBwb3J0IEFWQywgMSA9IGtleSBmcmFtZSAoZm9yIEFWQywgYSBzZWVrYWJsZVxuICAgICAgIC8vIGZyYW1lKSwgMiA9IGludGVyIGZyYW1lIChmb3IgQVZDLCBhIG5vbi1zZWVrYWJsZSBmcmFtZSlcbiAgICAgIHRoaXMuYnl0ZXNbMTFdID0gKCh0aGlzLmtleUZyYW1lIHx8IGV4dHJhRGF0YSkgPyAweDEwIDogMHgyMCkgfCAweDA3O1xuICAgICAgdGhpcy5ieXRlc1sxMl0gPSBleHRyYURhdGEgPyAgMHgwMCA6IDB4MDE7XG5cbiAgICAgIGR0c0RlbHRhID0gdGhpcy5wdHMgLSB0aGlzLmR0cztcbiAgICAgIHRoaXMuYnl0ZXNbMTNdID0gKGR0c0RlbHRhICYgMHgwMEZGMDAwMCkgPj4+IDE2O1xuICAgICAgdGhpcy5ieXRlc1sxNF0gPSAoZHRzRGVsdGEgJiAweDAwMDBGRjAwKSA+Pj4gIDg7XG4gICAgICB0aGlzLmJ5dGVzWzE1XSA9IChkdHNEZWx0YSAmIDB4MDAwMDAwRkYpID4+PiAgMDtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBGbHZUYWcuQVVESU9fVEFHOlxuICAgICAgdGhpcy5ieXRlc1sxMV0gPSAweEFGOyAvLyA0NCBrSHosIDE2LWJpdCBzdGVyZW9cbiAgICAgIHRoaXMuYnl0ZXNbMTJdID0gZXh0cmFEYXRhID8gMHgwMCA6IDB4MDE7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgRmx2VGFnLk1FVEFEQVRBX1RBRzpcbiAgICAgIHRoaXMucG9zaXRpb24gPSAxMTtcbiAgICAgIHRoaXMudmlldy5zZXRVaW50OCh0aGlzLnBvc2l0aW9uLCAweDAyKTsgLy8gU3RyaW5nIHR5cGVcbiAgICAgIHRoaXMucG9zaXRpb24rKztcbiAgICAgIHRoaXMudmlldy5zZXRVaW50MTYodGhpcy5wb3NpdGlvbiwgMHgwQSk7IC8vIDEwIEJ5dGVzXG4gICAgICB0aGlzLnBvc2l0aW9uICs9IDI7XG4gICAgICAvLyBzZXQgXCJvbk1ldGFEYXRhXCJcbiAgICAgIHRoaXMuYnl0ZXMuc2V0KFsweDZmLCAweDZlLCAweDRkLCAweDY1LFxuICAgICAgICAgICAgICAgICAgICAgIDB4NzQsIDB4NjEsIDB4NDQsIDB4NjEsXG4gICAgICAgICAgICAgICAgICAgICAgMHg3NCwgMHg2MV0sIHRoaXMucG9zaXRpb24pO1xuICAgICAgdGhpcy5wb3NpdGlvbiArPSAxMDtcbiAgICAgIHRoaXMuYnl0ZXNbdGhpcy5wb3NpdGlvbl0gPSAweDA4OyAvLyBBcnJheSB0eXBlXG4gICAgICB0aGlzLnBvc2l0aW9uKys7XG4gICAgICB0aGlzLnZpZXcuc2V0VWludDMyKHRoaXMucG9zaXRpb24sIGFkSG9jKTtcbiAgICAgIHRoaXMucG9zaXRpb24gPSB0aGlzLmxlbmd0aDtcbiAgICAgIHRoaXMuYnl0ZXMuc2V0KFswLCAwLCA5XSwgdGhpcy5wb3NpdGlvbik7XG4gICAgICB0aGlzLnBvc2l0aW9uICs9IDM7IC8vIEVuZCBEYXRhIFRhZ1xuICAgICAgdGhpcy5sZW5ndGggPSB0aGlzLnBvc2l0aW9uO1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgbGVuID0gdGhpcy5sZW5ndGggLSAxMTtcblxuICAgIC8vIHdyaXRlIHRoZSBEYXRhU2l6ZSBmaWVsZFxuICAgIHRoaXMuYnl0ZXNbIDFdID0gKGxlbiAmIDB4MDBGRjAwMDApID4+PiAxNjtcbiAgICB0aGlzLmJ5dGVzWyAyXSA9IChsZW4gJiAweDAwMDBGRjAwKSA+Pj4gIDg7XG4gICAgdGhpcy5ieXRlc1sgM10gPSAobGVuICYgMHgwMDAwMDBGRikgPj4+ICAwO1xuICAgIC8vIHdyaXRlIHRoZSBUaW1lc3RhbXBcbiAgICB0aGlzLmJ5dGVzWyA0XSA9ICh0aGlzLmR0cyAmIDB4MDBGRjAwMDApID4+PiAxNjtcbiAgICB0aGlzLmJ5dGVzWyA1XSA9ICh0aGlzLmR0cyAmIDB4MDAwMEZGMDApID4+PiAgODtcbiAgICB0aGlzLmJ5dGVzWyA2XSA9ICh0aGlzLmR0cyAmIDB4MDAwMDAwRkYpID4+PiAgMDtcbiAgICB0aGlzLmJ5dGVzWyA3XSA9ICh0aGlzLmR0cyAmIDB4RkYwMDAwMDApID4+PiAyNDtcbiAgICAvLyB3cml0ZSB0aGUgU3RyZWFtSURcbiAgICB0aGlzLmJ5dGVzWyA4XSA9IDA7XG4gICAgdGhpcy5ieXRlc1sgOV0gPSAwO1xuICAgIHRoaXMuYnl0ZXNbMTBdID0gMDtcblxuICAgIC8vIFNvbWV0aW1lcyB3ZSdyZSBhdCB0aGUgZW5kIG9mIHRoZSB2aWV3IGFuZCBoYXZlIG9uZSBzbG90IHRvIHdyaXRlIGFcbiAgICAvLyB1aW50MzIsIHNvLCBwcmVwYXJlV3JpdGUgb2YgY291bnQgNCwgc2luY2UsIHZpZXcgaXMgdWludDhcbiAgICBwcmVwYXJlV3JpdGUodGhpcywgNCk7XG4gICAgdGhpcy52aWV3LnNldFVpbnQzMih0aGlzLmxlbmd0aCwgdGhpcy5sZW5ndGgpO1xuICAgIHRoaXMubGVuZ3RoICs9IDQ7XG4gICAgdGhpcy5wb3NpdGlvbiArPSA0O1xuXG4gICAgLy8gdHJpbSBkb3duIHRoZSBieXRlIGJ1ZmZlciB0byB3aGF0IGlzIGFjdHVhbGx5IGJlaW5nIHVzZWRcbiAgICB0aGlzLmJ5dGVzID0gdGhpcy5ieXRlcy5zdWJhcnJheSgwLCB0aGlzLmxlbmd0aCk7XG4gICAgdGhpcy5mcmFtZVRpbWUgPSBGbHZUYWcuZnJhbWVUaW1lKHRoaXMuYnl0ZXMpO1xuICAgIC8vIGlmIGJ5dGVzLmJ5dGVsZW5ndGggaXNuJ3QgZXF1YWwgdG8gdGhpcy5sZW5ndGgsIGhhbmRsZSBlcnJvclxuICAgIHJldHVybiB0aGlzO1xuICB9O1xufTtcblxuRmx2VGFnLkFVRElPX1RBRyA9IDB4MDg7IC8vID09IDgsIDp1aW50XG5GbHZUYWcuVklERU9fVEFHID0gMHgwOTsgLy8gPT0gOSwgOnVpbnRcbkZsdlRhZy5NRVRBREFUQV9UQUcgPSAweDEyOyAvLyA9PSAxOCwgOnVpbnRcblxuLy8gKHRhZzpCeXRlQXJyYXkpOkJvb2xlYW4ge1xuRmx2VGFnLmlzQXVkaW9GcmFtZSA9IGZ1bmN0aW9uKHRhZykge1xuICByZXR1cm4gRmx2VGFnLkFVRElPX1RBRyA9PT0gdGFnWzBdO1xufTtcblxuLy8gKHRhZzpCeXRlQXJyYXkpOkJvb2xlYW4ge1xuRmx2VGFnLmlzVmlkZW9GcmFtZSA9IGZ1bmN0aW9uKHRhZykge1xuICByZXR1cm4gRmx2VGFnLlZJREVPX1RBRyA9PT0gdGFnWzBdO1xufTtcblxuLy8gKHRhZzpCeXRlQXJyYXkpOkJvb2xlYW4ge1xuRmx2VGFnLmlzTWV0YURhdGEgPSBmdW5jdGlvbih0YWcpIHtcbiAgcmV0dXJuIEZsdlRhZy5NRVRBREFUQV9UQUcgPT09IHRhZ1swXTtcbn07XG5cbi8vICh0YWc6Qnl0ZUFycmF5KTpCb29sZWFuIHtcbkZsdlRhZy5pc0tleUZyYW1lID0gZnVuY3Rpb24odGFnKSB7XG4gIGlmIChGbHZUYWcuaXNWaWRlb0ZyYW1lKHRhZykpIHtcbiAgICByZXR1cm4gdGFnWzExXSA9PT0gMHgxNztcbiAgfVxuXG4gIGlmIChGbHZUYWcuaXNBdWRpb0ZyYW1lKHRhZykpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmIChGbHZUYWcuaXNNZXRhRGF0YSh0YWcpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vLyAodGFnOkJ5dGVBcnJheSk6dWludCB7XG5GbHZUYWcuZnJhbWVUaW1lID0gZnVuY3Rpb24odGFnKSB7XG4gIHZhciBwdHMgPSB0YWdbIDRdIDw8IDE2OyAvLyA6dWludFxuICBwdHMgfD0gdGFnWyA1XSA8PCAgODtcbiAgcHRzIHw9IHRhZ1sgNl0gPDwgIDA7XG4gIHB0cyB8PSB0YWdbIDddIDw8IDI0O1xuICByZXR1cm4gcHRzO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBGbHZUYWc7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/videojs-contrib-media-sources/node_modules/mux.js/lib/flv/flv-tag.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/videojs-contrib-media-sources/node_modules/mux.js/lib/flv/index.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/videojs-contrib-media-sources/node_modules/mux.js/lib/flv/index.js ***!
  \*****************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = {\n  tag: __webpack_require__(/*! ./flv-tag */ \"(ssr)/./node_modules/videojs-contrib-media-sources/node_modules/mux.js/lib/flv/flv-tag.js\"),\n  Transmuxer: __webpack_require__(/*! ./transmuxer */ \"(ssr)/./node_modules/videojs-contrib-media-sources/node_modules/mux.js/lib/flv/transmuxer.js\"),\n  getFlvHeader: __webpack_require__(/*! ./flv-header */ \"(ssr)/./node_modules/videojs-contrib-media-sources/node_modules/mux.js/lib/flv/flv-header.js\")\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdmlkZW9qcy1jb250cmliLW1lZGlhLXNvdXJjZXMvbm9kZV9tb2R1bGVzL211eC5qcy9saWIvZmx2L2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0EsT0FBTyxtQkFBTyxDQUFDLDRHQUFXO0FBQzFCLGNBQWMsbUJBQU8sQ0FBQyxrSEFBYztBQUNwQyxnQkFBZ0IsbUJBQU8sQ0FBQyxrSEFBYztBQUN0QyIsInNvdXJjZXMiOlsid2VicGFjazovL215LXYwLXByb2plY3QvLi9ub2RlX21vZHVsZXMvdmlkZW9qcy1jb250cmliLW1lZGlhLXNvdXJjZXMvbm9kZV9tb2R1bGVzL211eC5qcy9saWIvZmx2L2luZGV4LmpzP2MwODEiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSB7XG4gIHRhZzogcmVxdWlyZSgnLi9mbHYtdGFnJyksXG4gIFRyYW5zbXV4ZXI6IHJlcXVpcmUoJy4vdHJhbnNtdXhlcicpLFxuICBnZXRGbHZIZWFkZXI6IHJlcXVpcmUoJy4vZmx2LWhlYWRlcicpXG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/videojs-contrib-media-sources/node_modules/mux.js/lib/flv/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/videojs-contrib-media-sources/node_modules/mux.js/lib/flv/tag-list.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/videojs-contrib-media-sources/node_modules/mux.js/lib/flv/tag-list.js ***!
  \********************************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nvar TagList = function() {\n  var self = this;\n\n  this.list = [];\n\n  this.push = function(tag) {\n    this.list.push({\n      bytes: tag.bytes,\n      dts: tag.dts,\n      pts: tag.pts,\n      keyFrame: tag.keyFrame,\n      metaDataTag: tag.metaDataTag\n    });\n  };\n\n  Object.defineProperty(this, 'length', {\n    get: function() {\n      return self.list.length;\n    }\n  });\n};\n\nmodule.exports = TagList;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdmlkZW9qcy1jb250cmliLW1lZGlhLXNvdXJjZXMvbm9kZV9tb2R1bGVzL211eC5qcy9saWIvZmx2L3RhZy1saXN0LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS12MC1wcm9qZWN0Ly4vbm9kZV9tb2R1bGVzL3ZpZGVvanMtY29udHJpYi1tZWRpYS1zb3VyY2VzL25vZGVfbW9kdWxlcy9tdXguanMvbGliL2Zsdi90YWctbGlzdC5qcz80ZjI0Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIFRhZ0xpc3QgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIHRoaXMubGlzdCA9IFtdO1xuXG4gIHRoaXMucHVzaCA9IGZ1bmN0aW9uKHRhZykge1xuICAgIHRoaXMubGlzdC5wdXNoKHtcbiAgICAgIGJ5dGVzOiB0YWcuYnl0ZXMsXG4gICAgICBkdHM6IHRhZy5kdHMsXG4gICAgICBwdHM6IHRhZy5wdHMsXG4gICAgICBrZXlGcmFtZTogdGFnLmtleUZyYW1lLFxuICAgICAgbWV0YURhdGFUYWc6IHRhZy5tZXRhRGF0YVRhZ1xuICAgIH0pO1xuICB9O1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnbGVuZ3RoJywge1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gc2VsZi5saXN0Lmxlbmd0aDtcbiAgICB9XG4gIH0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBUYWdMaXN0O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/videojs-contrib-media-sources/node_modules/mux.js/lib/flv/tag-list.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/videojs-contrib-media-sources/node_modules/mux.js/lib/flv/transmuxer.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/videojs-contrib-media-sources/node_modules/mux.js/lib/flv/transmuxer.js ***!
  \**********************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Stream = __webpack_require__(/*! ../utils/stream.js */ \"(ssr)/./node_modules/videojs-contrib-media-sources/node_modules/mux.js/lib/utils/stream.js\");\nvar FlvTag = __webpack_require__(/*! ./flv-tag.js */ \"(ssr)/./node_modules/videojs-contrib-media-sources/node_modules/mux.js/lib/flv/flv-tag.js\");\nvar m2ts = __webpack_require__(/*! ../m2ts/m2ts.js */ \"(ssr)/./node_modules/videojs-contrib-media-sources/node_modules/mux.js/lib/m2ts/m2ts.js\");\nvar AdtsStream = __webpack_require__(/*! ../codecs/adts.js */ \"(ssr)/./node_modules/videojs-contrib-media-sources/node_modules/mux.js/lib/codecs/adts.js\");\nvar H264Stream = (__webpack_require__(/*! ../codecs/h264 */ \"(ssr)/./node_modules/videojs-contrib-media-sources/node_modules/mux.js/lib/codecs/h264.js\").H264Stream);\nvar CoalesceStream = __webpack_require__(/*! ./coalesce-stream.js */ \"(ssr)/./node_modules/videojs-contrib-media-sources/node_modules/mux.js/lib/flv/coalesce-stream.js\");\nvar TagList = __webpack_require__(/*! ./tag-list.js */ \"(ssr)/./node_modules/videojs-contrib-media-sources/node_modules/mux.js/lib/flv/tag-list.js\");\n\nvar\n  Transmuxer,\n  VideoSegmentStream,\n  AudioSegmentStream,\n  collectTimelineInfo,\n  metaDataTag,\n  extraDataTag;\n\n/**\n * Store information about the start and end of the tracka and the\n * duration for each frame/sample we process in order to calculate\n * the baseMediaDecodeTime\n */\ncollectTimelineInfo = function(track, data) {\n  if (typeof data.pts === 'number') {\n    if (track.timelineStartInfo.pts === undefined) {\n      track.timelineStartInfo.pts = data.pts;\n    } else {\n      track.timelineStartInfo.pts =\n        Math.min(track.timelineStartInfo.pts, data.pts);\n    }\n  }\n\n  if (typeof data.dts === 'number') {\n    if (track.timelineStartInfo.dts === undefined) {\n      track.timelineStartInfo.dts = data.dts;\n    } else {\n      track.timelineStartInfo.dts =\n        Math.min(track.timelineStartInfo.dts, data.dts);\n    }\n  }\n};\n\nmetaDataTag = function(track, pts) {\n  var\n    tag = new FlvTag(FlvTag.METADATA_TAG); // :FlvTag\n\n  tag.dts = pts;\n  tag.pts = pts;\n\n  tag.writeMetaDataDouble('videocodecid', 7);\n  tag.writeMetaDataDouble('width', track.width);\n  tag.writeMetaDataDouble('height', track.height);\n\n  return tag;\n};\n\nextraDataTag = function(track, pts) {\n  var\n    i,\n    tag = new FlvTag(FlvTag.VIDEO_TAG, true);\n\n  tag.dts = pts;\n  tag.pts = pts;\n\n  tag.writeByte(0x01);// version\n  tag.writeByte(track.profileIdc);// profile\n  tag.writeByte(track.profileCompatibility);// compatibility\n  tag.writeByte(track.levelIdc);// level\n  tag.writeByte(0xFC | 0x03); // reserved (6 bits), NULA length size - 1 (2 bits)\n  tag.writeByte(0xE0 | 0x01); // reserved (3 bits), num of SPS (5 bits)\n  tag.writeShort(track.sps[0].length); // data of SPS\n  tag.writeBytes(track.sps[0]); // SPS\n\n  tag.writeByte(track.pps.length); // num of PPS (will there ever be more that 1 PPS?)\n  for (i = 0; i < track.pps.length; ++i) {\n    tag.writeShort(track.pps[i].length); // 2 bytes for length of PPS\n    tag.writeBytes(track.pps[i]); // data of PPS\n  }\n\n  return tag;\n};\n\n/**\n * Constructs a single-track, media segment from AAC data\n * events. The output of this stream can be fed to flash.\n */\nAudioSegmentStream = function(track) {\n  var\n    adtsFrames = [],\n    videoKeyFrames = [],\n    oldExtraData;\n\n  AudioSegmentStream.prototype.init.call(this);\n\n  this.push = function(data) {\n    collectTimelineInfo(track, data);\n\n    if (track) {\n      track.audioobjecttype = data.audioobjecttype;\n      track.channelcount = data.channelcount;\n      track.samplerate = data.samplerate;\n      track.samplingfrequencyindex = data.samplingfrequencyindex;\n      track.samplesize = data.samplesize;\n      track.extraData = (track.audioobjecttype << 11) |\n                        (track.samplingfrequencyindex << 7) |\n                        (track.channelcount << 3);\n    }\n\n    data.pts = Math.round(data.pts / 90);\n    data.dts = Math.round(data.dts / 90);\n\n    // buffer audio data until end() is called\n    adtsFrames.push(data);\n  };\n\n  this.flush = function() {\n    var currentFrame, adtsFrame, lastMetaPts, tags = new TagList();\n    // return early if no audio data has been observed\n    if (adtsFrames.length === 0) {\n      this.trigger('done', 'AudioSegmentStream');\n      return;\n    }\n\n    lastMetaPts = -Infinity;\n\n    while (adtsFrames.length) {\n      currentFrame = adtsFrames.shift();\n\n      // write out a metadata frame at every video key frame\n      if (videoKeyFrames.length && currentFrame.pts >= videoKeyFrames[0]) {\n        lastMetaPts = videoKeyFrames.shift();\n        this.writeMetaDataTags(tags, lastMetaPts);\n      }\n\n      // also write out metadata tags every 1 second so that the decoder\n      // is re-initialized quickly after seeking into a different\n      // audio configuration.\n      if (track.extraData !== oldExtraData || currentFrame.pts - lastMetaPts >= 1000) {\n        this.writeMetaDataTags(tags, currentFrame.pts);\n        oldExtraData = track.extraData;\n        lastMetaPts = currentFrame.pts;\n      }\n\n      adtsFrame = new FlvTag(FlvTag.AUDIO_TAG);\n      adtsFrame.pts = currentFrame.pts;\n      adtsFrame.dts = currentFrame.dts;\n\n      adtsFrame.writeBytes(currentFrame.data);\n\n      tags.push(adtsFrame.finalize());\n    }\n\n    videoKeyFrames.length = 0;\n    oldExtraData = null;\n    this.trigger('data', {track: track, tags: tags.list});\n\n    this.trigger('done', 'AudioSegmentStream');\n  };\n\n  this.writeMetaDataTags = function(tags, pts) {\n    var adtsFrame;\n\n    adtsFrame = new FlvTag(FlvTag.METADATA_TAG);\n    // For audio, DTS is always the same as PTS. We want to set the DTS\n    // however so we can compare with video DTS to determine approximate\n    // packet order\n    adtsFrame.pts = pts;\n    adtsFrame.dts = pts;\n\n    // AAC is always 10\n    adtsFrame.writeMetaDataDouble('audiocodecid', 10);\n    adtsFrame.writeMetaDataBoolean('stereo', track.channelcount === 2);\n    adtsFrame.writeMetaDataDouble('audiosamplerate', track.samplerate);\n    // Is AAC always 16 bit?\n    adtsFrame.writeMetaDataDouble('audiosamplesize', 16);\n\n    tags.push(adtsFrame.finalize());\n\n    adtsFrame = new FlvTag(FlvTag.AUDIO_TAG, true);\n    // For audio, DTS is always the same as PTS. We want to set the DTS\n    // however so we can compare with video DTS to determine approximate\n    // packet order\n    adtsFrame.pts = pts;\n    adtsFrame.dts = pts;\n\n    adtsFrame.view.setUint16(adtsFrame.position, track.extraData);\n    adtsFrame.position += 2;\n    adtsFrame.length = Math.max(adtsFrame.length, adtsFrame.position);\n\n    tags.push(adtsFrame.finalize());\n  };\n\n  this.onVideoKeyFrame = function(pts) {\n    videoKeyFrames.push(pts);\n  };\n};\nAudioSegmentStream.prototype = new Stream();\n\n/**\n * Store FlvTags for the h264 stream\n * @param track {object} track metadata configuration\n */\nVideoSegmentStream = function(track) {\n  var\n    nalUnits = [],\n    config,\n    h264Frame;\n  VideoSegmentStream.prototype.init.call(this);\n\n  this.finishFrame = function(tags, frame) {\n    if (!frame) {\n      return;\n    }\n    // Check if keyframe and the length of tags.\n    // This makes sure we write metadata on the first frame of a segment.\n    if (config && track && track.newMetadata &&\n        (frame.keyFrame || tags.length === 0)) {\n      // Push extra data on every IDR frame in case we did a stream change + seek\n      var metaTag = metaDataTag(config, frame.dts).finalize();\n      var extraTag = extraDataTag(track, frame.dts).finalize();\n\n      metaTag.metaDataTag = extraTag.metaDataTag = true;\n\n      tags.push(metaTag);\n      tags.push(extraTag);\n      track.newMetadata = false;\n\n      this.trigger('keyframe', frame.dts);\n    }\n\n    frame.endNalUnit();\n    tags.push(frame.finalize());\n    h264Frame = null;\n  };\n\n  this.push = function(data) {\n    collectTimelineInfo(track, data);\n\n    data.pts = Math.round(data.pts / 90);\n    data.dts = Math.round(data.dts / 90);\n\n    // buffer video until flush() is called\n    nalUnits.push(data);\n  };\n\n  this.flush = function() {\n    var\n      currentNal,\n      tags = new TagList();\n\n    // Throw away nalUnits at the start of the byte stream until we find\n    // the first AUD\n    while (nalUnits.length) {\n      if (nalUnits[0].nalUnitType === 'access_unit_delimiter_rbsp') {\n        break;\n      }\n      nalUnits.shift();\n    }\n\n    // return early if no video data has been observed\n    if (nalUnits.length === 0) {\n      this.trigger('done', 'VideoSegmentStream');\n      return;\n    }\n\n    while (nalUnits.length) {\n      currentNal = nalUnits.shift();\n\n      // record the track config\n      if (currentNal.nalUnitType === 'seq_parameter_set_rbsp') {\n        track.newMetadata = true;\n        config = currentNal.config;\n        track.width = config.width;\n        track.height = config.height;\n        track.sps = [currentNal.data];\n        track.profileIdc = config.profileIdc;\n        track.levelIdc = config.levelIdc;\n        track.profileCompatibility = config.profileCompatibility;\n        h264Frame.endNalUnit();\n      } else if (currentNal.nalUnitType === 'pic_parameter_set_rbsp') {\n        track.newMetadata = true;\n        track.pps = [currentNal.data];\n        h264Frame.endNalUnit();\n      } else if (currentNal.nalUnitType === 'access_unit_delimiter_rbsp') {\n        if (h264Frame) {\n          this.finishFrame(tags, h264Frame);\n        }\n        h264Frame = new FlvTag(FlvTag.VIDEO_TAG);\n        h264Frame.pts = currentNal.pts;\n        h264Frame.dts = currentNal.dts;\n      } else {\n        if (currentNal.nalUnitType === 'slice_layer_without_partitioning_rbsp_idr') {\n          // the current sample is a key frame\n          h264Frame.keyFrame = true;\n        }\n        h264Frame.endNalUnit();\n      }\n      h264Frame.startNalUnit();\n      h264Frame.writeBytes(currentNal.data);\n    }\n    if (h264Frame) {\n      this.finishFrame(tags, h264Frame);\n    }\n\n    this.trigger('data', {track: track, tags: tags.list});\n\n    // Continue with the flush process now\n    this.trigger('done', 'VideoSegmentStream');\n  };\n};\n\nVideoSegmentStream.prototype = new Stream();\n\n/**\n * An object that incrementally transmuxes MPEG2 Trasport Stream\n * chunks into an FLV.\n */\nTransmuxer = function(options) {\n  var\n    self = this,\n\n    packetStream, parseStream, elementaryStream,\n    videoTimestampRolloverStream, audioTimestampRolloverStream,\n    timedMetadataTimestampRolloverStream,\n    adtsStream, h264Stream,\n    videoSegmentStream, audioSegmentStream, captionStream,\n    coalesceStream;\n\n  Transmuxer.prototype.init.call(this);\n\n  options = options || {};\n\n  // expose the metadata stream\n  this.metadataStream = new m2ts.MetadataStream();\n\n  options.metadataStream = this.metadataStream;\n\n  // set up the parsing pipeline\n  packetStream = new m2ts.TransportPacketStream();\n  parseStream = new m2ts.TransportParseStream();\n  elementaryStream = new m2ts.ElementaryStream();\n  videoTimestampRolloverStream = new m2ts.TimestampRolloverStream('video');\n  audioTimestampRolloverStream = new m2ts.TimestampRolloverStream('audio');\n  timedMetadataTimestampRolloverStream = new m2ts.TimestampRolloverStream('timed-metadata');\n\n  adtsStream = new AdtsStream();\n  h264Stream = new H264Stream();\n  coalesceStream = new CoalesceStream(options);\n\n  // disassemble MPEG2-TS packets into elementary streams\n  packetStream\n    .pipe(parseStream)\n    .pipe(elementaryStream);\n\n  // !!THIS ORDER IS IMPORTANT!!\n  // demux the streams\n  elementaryStream\n    .pipe(videoTimestampRolloverStream)\n    .pipe(h264Stream);\n  elementaryStream\n    .pipe(audioTimestampRolloverStream)\n    .pipe(adtsStream);\n\n  elementaryStream\n    .pipe(timedMetadataTimestampRolloverStream)\n    .pipe(this.metadataStream)\n    .pipe(coalesceStream);\n  // if CEA-708 parsing is available, hook up a caption stream\n  captionStream = new m2ts.CaptionStream();\n  h264Stream.pipe(captionStream)\n    .pipe(coalesceStream);\n\n  // hook up the segment streams once track metadata is delivered\n  elementaryStream.on('data', function(data) {\n    var i, videoTrack, audioTrack;\n\n    if (data.type === 'metadata') {\n      i = data.tracks.length;\n\n      // scan the tracks listed in the metadata\n      while (i--) {\n        if (data.tracks[i].type === 'video') {\n          videoTrack = data.tracks[i];\n        } else if (data.tracks[i].type === 'audio') {\n          audioTrack = data.tracks[i];\n        }\n      }\n\n      // hook up the video segment stream to the first track with h264 data\n      if (videoTrack && !videoSegmentStream) {\n        coalesceStream.numberOfTracks++;\n        videoSegmentStream = new VideoSegmentStream(videoTrack);\n\n        // Set up the final part of the video pipeline\n        h264Stream\n          .pipe(videoSegmentStream)\n          .pipe(coalesceStream);\n      }\n\n      if (audioTrack && !audioSegmentStream) {\n        // hook up the audio segment stream to the first track with aac data\n        coalesceStream.numberOfTracks++;\n        audioSegmentStream = new AudioSegmentStream(audioTrack);\n\n        // Set up the final part of the audio pipeline\n        adtsStream\n          .pipe(audioSegmentStream)\n          .pipe(coalesceStream);\n\n        if (videoSegmentStream) {\n          videoSegmentStream.on('keyframe', audioSegmentStream.onVideoKeyFrame);\n        }\n      }\n    }\n  });\n\n  // feed incoming data to the front of the parsing pipeline\n  this.push = function(data) {\n    packetStream.push(data);\n  };\n\n  // flush any buffered data\n  this.flush = function() {\n    // Start at the top of the pipeline and flush all pending work\n    packetStream.flush();\n  };\n\n  // Caption data has to be reset when seeking outside buffered range\n  this.resetCaptions = function() {\n    captionStream.reset();\n  };\n\n  // Re-emit any data coming from the coalesce stream to the outside world\n  coalesceStream.on('data', function(event) {\n    self.trigger('data', event);\n  });\n\n  // Let the consumer know we have finished flushing the entire pipeline\n  coalesceStream.on('done', function() {\n    self.trigger('done');\n  });\n};\nTransmuxer.prototype = new Stream();\n\n// forward compatibility\nmodule.exports = Transmuxer;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdmlkZW9qcy1jb250cmliLW1lZGlhLXNvdXJjZXMvbm9kZV9tb2R1bGVzL211eC5qcy9saWIvZmx2L3RyYW5zbXV4ZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsYUFBYSxtQkFBTyxDQUFDLHNIQUFvQjtBQUN6QyxhQUFhLG1CQUFPLENBQUMsK0dBQWM7QUFDbkMsV0FBVyxtQkFBTyxDQUFDLGdIQUFpQjtBQUNwQyxpQkFBaUIsbUJBQU8sQ0FBQyxvSEFBbUI7QUFDNUMsaUJBQWlCLG1KQUFvQztBQUNyRCxxQkFBcUIsbUJBQU8sQ0FBQywrSEFBc0I7QUFDbkQsY0FBYyxtQkFBTyxDQUFDLGlIQUFlOztBQUVyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJDQUEyQzs7QUFFM0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHNCQUFzQjtBQUN0QixrQ0FBa0M7QUFDbEMsNENBQTRDO0FBQzVDLGdDQUFnQztBQUNoQyw4QkFBOEI7QUFDOUIsOEJBQThCO0FBQzlCLHVDQUF1QztBQUN2QyxnQ0FBZ0M7O0FBRWhDLG1DQUFtQztBQUNuQyxjQUFjLHNCQUFzQjtBQUNwQyx5Q0FBeUM7QUFDekMsa0NBQWtDO0FBQ2xDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBCQUEwQiw4QkFBOEI7O0FBRXhEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEIsOEJBQThCOztBQUV4RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktdjAtcHJvamVjdC8uL25vZGVfbW9kdWxlcy92aWRlb2pzLWNvbnRyaWItbWVkaWEtc291cmNlcy9ub2RlX21vZHVsZXMvbXV4LmpzL2xpYi9mbHYvdHJhbnNtdXhlci5qcz8xMWE3Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIFN0cmVhbSA9IHJlcXVpcmUoJy4uL3V0aWxzL3N0cmVhbS5qcycpO1xudmFyIEZsdlRhZyA9IHJlcXVpcmUoJy4vZmx2LXRhZy5qcycpO1xudmFyIG0ydHMgPSByZXF1aXJlKCcuLi9tMnRzL20ydHMuanMnKTtcbnZhciBBZHRzU3RyZWFtID0gcmVxdWlyZSgnLi4vY29kZWNzL2FkdHMuanMnKTtcbnZhciBIMjY0U3RyZWFtID0gcmVxdWlyZSgnLi4vY29kZWNzL2gyNjQnKS5IMjY0U3RyZWFtO1xudmFyIENvYWxlc2NlU3RyZWFtID0gcmVxdWlyZSgnLi9jb2FsZXNjZS1zdHJlYW0uanMnKTtcbnZhciBUYWdMaXN0ID0gcmVxdWlyZSgnLi90YWctbGlzdC5qcycpO1xuXG52YXJcbiAgVHJhbnNtdXhlcixcbiAgVmlkZW9TZWdtZW50U3RyZWFtLFxuICBBdWRpb1NlZ21lbnRTdHJlYW0sXG4gIGNvbGxlY3RUaW1lbGluZUluZm8sXG4gIG1ldGFEYXRhVGFnLFxuICBleHRyYURhdGFUYWc7XG5cbi8qKlxuICogU3RvcmUgaW5mb3JtYXRpb24gYWJvdXQgdGhlIHN0YXJ0IGFuZCBlbmQgb2YgdGhlIHRyYWNrYSBhbmQgdGhlXG4gKiBkdXJhdGlvbiBmb3IgZWFjaCBmcmFtZS9zYW1wbGUgd2UgcHJvY2VzcyBpbiBvcmRlciB0byBjYWxjdWxhdGVcbiAqIHRoZSBiYXNlTWVkaWFEZWNvZGVUaW1lXG4gKi9cbmNvbGxlY3RUaW1lbGluZUluZm8gPSBmdW5jdGlvbih0cmFjaywgZGF0YSkge1xuICBpZiAodHlwZW9mIGRhdGEucHRzID09PSAnbnVtYmVyJykge1xuICAgIGlmICh0cmFjay50aW1lbGluZVN0YXJ0SW5mby5wdHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdHJhY2sudGltZWxpbmVTdGFydEluZm8ucHRzID0gZGF0YS5wdHM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyYWNrLnRpbWVsaW5lU3RhcnRJbmZvLnB0cyA9XG4gICAgICAgIE1hdGgubWluKHRyYWNrLnRpbWVsaW5lU3RhcnRJbmZvLnB0cywgZGF0YS5wdHMpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgZGF0YS5kdHMgPT09ICdudW1iZXInKSB7XG4gICAgaWYgKHRyYWNrLnRpbWVsaW5lU3RhcnRJbmZvLmR0cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0cmFjay50aW1lbGluZVN0YXJ0SW5mby5kdHMgPSBkYXRhLmR0cztcbiAgICB9IGVsc2Uge1xuICAgICAgdHJhY2sudGltZWxpbmVTdGFydEluZm8uZHRzID1cbiAgICAgICAgTWF0aC5taW4odHJhY2sudGltZWxpbmVTdGFydEluZm8uZHRzLCBkYXRhLmR0cyk7XG4gICAgfVxuICB9XG59O1xuXG5tZXRhRGF0YVRhZyA9IGZ1bmN0aW9uKHRyYWNrLCBwdHMpIHtcbiAgdmFyXG4gICAgdGFnID0gbmV3IEZsdlRhZyhGbHZUYWcuTUVUQURBVEFfVEFHKTsgLy8gOkZsdlRhZ1xuXG4gIHRhZy5kdHMgPSBwdHM7XG4gIHRhZy5wdHMgPSBwdHM7XG5cbiAgdGFnLndyaXRlTWV0YURhdGFEb3VibGUoJ3ZpZGVvY29kZWNpZCcsIDcpO1xuICB0YWcud3JpdGVNZXRhRGF0YURvdWJsZSgnd2lkdGgnLCB0cmFjay53aWR0aCk7XG4gIHRhZy53cml0ZU1ldGFEYXRhRG91YmxlKCdoZWlnaHQnLCB0cmFjay5oZWlnaHQpO1xuXG4gIHJldHVybiB0YWc7XG59O1xuXG5leHRyYURhdGFUYWcgPSBmdW5jdGlvbih0cmFjaywgcHRzKSB7XG4gIHZhclxuICAgIGksXG4gICAgdGFnID0gbmV3IEZsdlRhZyhGbHZUYWcuVklERU9fVEFHLCB0cnVlKTtcblxuICB0YWcuZHRzID0gcHRzO1xuICB0YWcucHRzID0gcHRzO1xuXG4gIHRhZy53cml0ZUJ5dGUoMHgwMSk7Ly8gdmVyc2lvblxuICB0YWcud3JpdGVCeXRlKHRyYWNrLnByb2ZpbGVJZGMpOy8vIHByb2ZpbGVcbiAgdGFnLndyaXRlQnl0ZSh0cmFjay5wcm9maWxlQ29tcGF0aWJpbGl0eSk7Ly8gY29tcGF0aWJpbGl0eVxuICB0YWcud3JpdGVCeXRlKHRyYWNrLmxldmVsSWRjKTsvLyBsZXZlbFxuICB0YWcud3JpdGVCeXRlKDB4RkMgfCAweDAzKTsgLy8gcmVzZXJ2ZWQgKDYgYml0cyksIE5VTEEgbGVuZ3RoIHNpemUgLSAxICgyIGJpdHMpXG4gIHRhZy53cml0ZUJ5dGUoMHhFMCB8IDB4MDEpOyAvLyByZXNlcnZlZCAoMyBiaXRzKSwgbnVtIG9mIFNQUyAoNSBiaXRzKVxuICB0YWcud3JpdGVTaG9ydCh0cmFjay5zcHNbMF0ubGVuZ3RoKTsgLy8gZGF0YSBvZiBTUFNcbiAgdGFnLndyaXRlQnl0ZXModHJhY2suc3BzWzBdKTsgLy8gU1BTXG5cbiAgdGFnLndyaXRlQnl0ZSh0cmFjay5wcHMubGVuZ3RoKTsgLy8gbnVtIG9mIFBQUyAod2lsbCB0aGVyZSBldmVyIGJlIG1vcmUgdGhhdCAxIFBQUz8pXG4gIGZvciAoaSA9IDA7IGkgPCB0cmFjay5wcHMubGVuZ3RoOyArK2kpIHtcbiAgICB0YWcud3JpdGVTaG9ydCh0cmFjay5wcHNbaV0ubGVuZ3RoKTsgLy8gMiBieXRlcyBmb3IgbGVuZ3RoIG9mIFBQU1xuICAgIHRhZy53cml0ZUJ5dGVzKHRyYWNrLnBwc1tpXSk7IC8vIGRhdGEgb2YgUFBTXG4gIH1cblxuICByZXR1cm4gdGFnO1xufTtcblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgc2luZ2xlLXRyYWNrLCBtZWRpYSBzZWdtZW50IGZyb20gQUFDIGRhdGFcbiAqIGV2ZW50cy4gVGhlIG91dHB1dCBvZiB0aGlzIHN0cmVhbSBjYW4gYmUgZmVkIHRvIGZsYXNoLlxuICovXG5BdWRpb1NlZ21lbnRTdHJlYW0gPSBmdW5jdGlvbih0cmFjaykge1xuICB2YXJcbiAgICBhZHRzRnJhbWVzID0gW10sXG4gICAgdmlkZW9LZXlGcmFtZXMgPSBbXSxcbiAgICBvbGRFeHRyYURhdGE7XG5cbiAgQXVkaW9TZWdtZW50U3RyZWFtLnByb3RvdHlwZS5pbml0LmNhbGwodGhpcyk7XG5cbiAgdGhpcy5wdXNoID0gZnVuY3Rpb24oZGF0YSkge1xuICAgIGNvbGxlY3RUaW1lbGluZUluZm8odHJhY2ssIGRhdGEpO1xuXG4gICAgaWYgKHRyYWNrKSB7XG4gICAgICB0cmFjay5hdWRpb29iamVjdHR5cGUgPSBkYXRhLmF1ZGlvb2JqZWN0dHlwZTtcbiAgICAgIHRyYWNrLmNoYW5uZWxjb3VudCA9IGRhdGEuY2hhbm5lbGNvdW50O1xuICAgICAgdHJhY2suc2FtcGxlcmF0ZSA9IGRhdGEuc2FtcGxlcmF0ZTtcbiAgICAgIHRyYWNrLnNhbXBsaW5nZnJlcXVlbmN5aW5kZXggPSBkYXRhLnNhbXBsaW5nZnJlcXVlbmN5aW5kZXg7XG4gICAgICB0cmFjay5zYW1wbGVzaXplID0gZGF0YS5zYW1wbGVzaXplO1xuICAgICAgdHJhY2suZXh0cmFEYXRhID0gKHRyYWNrLmF1ZGlvb2JqZWN0dHlwZSA8PCAxMSkgfFxuICAgICAgICAgICAgICAgICAgICAgICAgKHRyYWNrLnNhbXBsaW5nZnJlcXVlbmN5aW5kZXggPDwgNykgfFxuICAgICAgICAgICAgICAgICAgICAgICAgKHRyYWNrLmNoYW5uZWxjb3VudCA8PCAzKTtcbiAgICB9XG5cbiAgICBkYXRhLnB0cyA9IE1hdGgucm91bmQoZGF0YS5wdHMgLyA5MCk7XG4gICAgZGF0YS5kdHMgPSBNYXRoLnJvdW5kKGRhdGEuZHRzIC8gOTApO1xuXG4gICAgLy8gYnVmZmVyIGF1ZGlvIGRhdGEgdW50aWwgZW5kKCkgaXMgY2FsbGVkXG4gICAgYWR0c0ZyYW1lcy5wdXNoKGRhdGEpO1xuICB9O1xuXG4gIHRoaXMuZmx1c2ggPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgY3VycmVudEZyYW1lLCBhZHRzRnJhbWUsIGxhc3RNZXRhUHRzLCB0YWdzID0gbmV3IFRhZ0xpc3QoKTtcbiAgICAvLyByZXR1cm4gZWFybHkgaWYgbm8gYXVkaW8gZGF0YSBoYXMgYmVlbiBvYnNlcnZlZFxuICAgIGlmIChhZHRzRnJhbWVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpcy50cmlnZ2VyKCdkb25lJywgJ0F1ZGlvU2VnbWVudFN0cmVhbScpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxhc3RNZXRhUHRzID0gLUluZmluaXR5O1xuXG4gICAgd2hpbGUgKGFkdHNGcmFtZXMubGVuZ3RoKSB7XG4gICAgICBjdXJyZW50RnJhbWUgPSBhZHRzRnJhbWVzLnNoaWZ0KCk7XG5cbiAgICAgIC8vIHdyaXRlIG91dCBhIG1ldGFkYXRhIGZyYW1lIGF0IGV2ZXJ5IHZpZGVvIGtleSBmcmFtZVxuICAgICAgaWYgKHZpZGVvS2V5RnJhbWVzLmxlbmd0aCAmJiBjdXJyZW50RnJhbWUucHRzID49IHZpZGVvS2V5RnJhbWVzWzBdKSB7XG4gICAgICAgIGxhc3RNZXRhUHRzID0gdmlkZW9LZXlGcmFtZXMuc2hpZnQoKTtcbiAgICAgICAgdGhpcy53cml0ZU1ldGFEYXRhVGFncyh0YWdzLCBsYXN0TWV0YVB0cyk7XG4gICAgICB9XG5cbiAgICAgIC8vIGFsc28gd3JpdGUgb3V0IG1ldGFkYXRhIHRhZ3MgZXZlcnkgMSBzZWNvbmQgc28gdGhhdCB0aGUgZGVjb2RlclxuICAgICAgLy8gaXMgcmUtaW5pdGlhbGl6ZWQgcXVpY2tseSBhZnRlciBzZWVraW5nIGludG8gYSBkaWZmZXJlbnRcbiAgICAgIC8vIGF1ZGlvIGNvbmZpZ3VyYXRpb24uXG4gICAgICBpZiAodHJhY2suZXh0cmFEYXRhICE9PSBvbGRFeHRyYURhdGEgfHwgY3VycmVudEZyYW1lLnB0cyAtIGxhc3RNZXRhUHRzID49IDEwMDApIHtcbiAgICAgICAgdGhpcy53cml0ZU1ldGFEYXRhVGFncyh0YWdzLCBjdXJyZW50RnJhbWUucHRzKTtcbiAgICAgICAgb2xkRXh0cmFEYXRhID0gdHJhY2suZXh0cmFEYXRhO1xuICAgICAgICBsYXN0TWV0YVB0cyA9IGN1cnJlbnRGcmFtZS5wdHM7XG4gICAgICB9XG5cbiAgICAgIGFkdHNGcmFtZSA9IG5ldyBGbHZUYWcoRmx2VGFnLkFVRElPX1RBRyk7XG4gICAgICBhZHRzRnJhbWUucHRzID0gY3VycmVudEZyYW1lLnB0cztcbiAgICAgIGFkdHNGcmFtZS5kdHMgPSBjdXJyZW50RnJhbWUuZHRzO1xuXG4gICAgICBhZHRzRnJhbWUud3JpdGVCeXRlcyhjdXJyZW50RnJhbWUuZGF0YSk7XG5cbiAgICAgIHRhZ3MucHVzaChhZHRzRnJhbWUuZmluYWxpemUoKSk7XG4gICAgfVxuXG4gICAgdmlkZW9LZXlGcmFtZXMubGVuZ3RoID0gMDtcbiAgICBvbGRFeHRyYURhdGEgPSBudWxsO1xuICAgIHRoaXMudHJpZ2dlcignZGF0YScsIHt0cmFjazogdHJhY2ssIHRhZ3M6IHRhZ3MubGlzdH0pO1xuXG4gICAgdGhpcy50cmlnZ2VyKCdkb25lJywgJ0F1ZGlvU2VnbWVudFN0cmVhbScpO1xuICB9O1xuXG4gIHRoaXMud3JpdGVNZXRhRGF0YVRhZ3MgPSBmdW5jdGlvbih0YWdzLCBwdHMpIHtcbiAgICB2YXIgYWR0c0ZyYW1lO1xuXG4gICAgYWR0c0ZyYW1lID0gbmV3IEZsdlRhZyhGbHZUYWcuTUVUQURBVEFfVEFHKTtcbiAgICAvLyBGb3IgYXVkaW8sIERUUyBpcyBhbHdheXMgdGhlIHNhbWUgYXMgUFRTLiBXZSB3YW50IHRvIHNldCB0aGUgRFRTXG4gICAgLy8gaG93ZXZlciBzbyB3ZSBjYW4gY29tcGFyZSB3aXRoIHZpZGVvIERUUyB0byBkZXRlcm1pbmUgYXBwcm94aW1hdGVcbiAgICAvLyBwYWNrZXQgb3JkZXJcbiAgICBhZHRzRnJhbWUucHRzID0gcHRzO1xuICAgIGFkdHNGcmFtZS5kdHMgPSBwdHM7XG5cbiAgICAvLyBBQUMgaXMgYWx3YXlzIDEwXG4gICAgYWR0c0ZyYW1lLndyaXRlTWV0YURhdGFEb3VibGUoJ2F1ZGlvY29kZWNpZCcsIDEwKTtcbiAgICBhZHRzRnJhbWUud3JpdGVNZXRhRGF0YUJvb2xlYW4oJ3N0ZXJlbycsIHRyYWNrLmNoYW5uZWxjb3VudCA9PT0gMik7XG4gICAgYWR0c0ZyYW1lLndyaXRlTWV0YURhdGFEb3VibGUoJ2F1ZGlvc2FtcGxlcmF0ZScsIHRyYWNrLnNhbXBsZXJhdGUpO1xuICAgIC8vIElzIEFBQyBhbHdheXMgMTYgYml0P1xuICAgIGFkdHNGcmFtZS53cml0ZU1ldGFEYXRhRG91YmxlKCdhdWRpb3NhbXBsZXNpemUnLCAxNik7XG5cbiAgICB0YWdzLnB1c2goYWR0c0ZyYW1lLmZpbmFsaXplKCkpO1xuXG4gICAgYWR0c0ZyYW1lID0gbmV3IEZsdlRhZyhGbHZUYWcuQVVESU9fVEFHLCB0cnVlKTtcbiAgICAvLyBGb3IgYXVkaW8sIERUUyBpcyBhbHdheXMgdGhlIHNhbWUgYXMgUFRTLiBXZSB3YW50IHRvIHNldCB0aGUgRFRTXG4gICAgLy8gaG93ZXZlciBzbyB3ZSBjYW4gY29tcGFyZSB3aXRoIHZpZGVvIERUUyB0byBkZXRlcm1pbmUgYXBwcm94aW1hdGVcbiAgICAvLyBwYWNrZXQgb3JkZXJcbiAgICBhZHRzRnJhbWUucHRzID0gcHRzO1xuICAgIGFkdHNGcmFtZS5kdHMgPSBwdHM7XG5cbiAgICBhZHRzRnJhbWUudmlldy5zZXRVaW50MTYoYWR0c0ZyYW1lLnBvc2l0aW9uLCB0cmFjay5leHRyYURhdGEpO1xuICAgIGFkdHNGcmFtZS5wb3NpdGlvbiArPSAyO1xuICAgIGFkdHNGcmFtZS5sZW5ndGggPSBNYXRoLm1heChhZHRzRnJhbWUubGVuZ3RoLCBhZHRzRnJhbWUucG9zaXRpb24pO1xuXG4gICAgdGFncy5wdXNoKGFkdHNGcmFtZS5maW5hbGl6ZSgpKTtcbiAgfTtcblxuICB0aGlzLm9uVmlkZW9LZXlGcmFtZSA9IGZ1bmN0aW9uKHB0cykge1xuICAgIHZpZGVvS2V5RnJhbWVzLnB1c2gocHRzKTtcbiAgfTtcbn07XG5BdWRpb1NlZ21lbnRTdHJlYW0ucHJvdG90eXBlID0gbmV3IFN0cmVhbSgpO1xuXG4vKipcbiAqIFN0b3JlIEZsdlRhZ3MgZm9yIHRoZSBoMjY0IHN0cmVhbVxuICogQHBhcmFtIHRyYWNrIHtvYmplY3R9IHRyYWNrIG1ldGFkYXRhIGNvbmZpZ3VyYXRpb25cbiAqL1xuVmlkZW9TZWdtZW50U3RyZWFtID0gZnVuY3Rpb24odHJhY2spIHtcbiAgdmFyXG4gICAgbmFsVW5pdHMgPSBbXSxcbiAgICBjb25maWcsXG4gICAgaDI2NEZyYW1lO1xuICBWaWRlb1NlZ21lbnRTdHJlYW0ucHJvdG90eXBlLmluaXQuY2FsbCh0aGlzKTtcblxuICB0aGlzLmZpbmlzaEZyYW1lID0gZnVuY3Rpb24odGFncywgZnJhbWUpIHtcbiAgICBpZiAoIWZyYW1lKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIENoZWNrIGlmIGtleWZyYW1lIGFuZCB0aGUgbGVuZ3RoIG9mIHRhZ3MuXG4gICAgLy8gVGhpcyBtYWtlcyBzdXJlIHdlIHdyaXRlIG1ldGFkYXRhIG9uIHRoZSBmaXJzdCBmcmFtZSBvZiBhIHNlZ21lbnQuXG4gICAgaWYgKGNvbmZpZyAmJiB0cmFjayAmJiB0cmFjay5uZXdNZXRhZGF0YSAmJlxuICAgICAgICAoZnJhbWUua2V5RnJhbWUgfHwgdGFncy5sZW5ndGggPT09IDApKSB7XG4gICAgICAvLyBQdXNoIGV4dHJhIGRhdGEgb24gZXZlcnkgSURSIGZyYW1lIGluIGNhc2Ugd2UgZGlkIGEgc3RyZWFtIGNoYW5nZSArIHNlZWtcbiAgICAgIHZhciBtZXRhVGFnID0gbWV0YURhdGFUYWcoY29uZmlnLCBmcmFtZS5kdHMpLmZpbmFsaXplKCk7XG4gICAgICB2YXIgZXh0cmFUYWcgPSBleHRyYURhdGFUYWcodHJhY2ssIGZyYW1lLmR0cykuZmluYWxpemUoKTtcblxuICAgICAgbWV0YVRhZy5tZXRhRGF0YVRhZyA9IGV4dHJhVGFnLm1ldGFEYXRhVGFnID0gdHJ1ZTtcblxuICAgICAgdGFncy5wdXNoKG1ldGFUYWcpO1xuICAgICAgdGFncy5wdXNoKGV4dHJhVGFnKTtcbiAgICAgIHRyYWNrLm5ld01ldGFkYXRhID0gZmFsc2U7XG5cbiAgICAgIHRoaXMudHJpZ2dlcigna2V5ZnJhbWUnLCBmcmFtZS5kdHMpO1xuICAgIH1cblxuICAgIGZyYW1lLmVuZE5hbFVuaXQoKTtcbiAgICB0YWdzLnB1c2goZnJhbWUuZmluYWxpemUoKSk7XG4gICAgaDI2NEZyYW1lID0gbnVsbDtcbiAgfTtcblxuICB0aGlzLnB1c2ggPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgY29sbGVjdFRpbWVsaW5lSW5mbyh0cmFjaywgZGF0YSk7XG5cbiAgICBkYXRhLnB0cyA9IE1hdGgucm91bmQoZGF0YS5wdHMgLyA5MCk7XG4gICAgZGF0YS5kdHMgPSBNYXRoLnJvdW5kKGRhdGEuZHRzIC8gOTApO1xuXG4gICAgLy8gYnVmZmVyIHZpZGVvIHVudGlsIGZsdXNoKCkgaXMgY2FsbGVkXG4gICAgbmFsVW5pdHMucHVzaChkYXRhKTtcbiAgfTtcblxuICB0aGlzLmZsdXNoID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyXG4gICAgICBjdXJyZW50TmFsLFxuICAgICAgdGFncyA9IG5ldyBUYWdMaXN0KCk7XG5cbiAgICAvLyBUaHJvdyBhd2F5IG5hbFVuaXRzIGF0IHRoZSBzdGFydCBvZiB0aGUgYnl0ZSBzdHJlYW0gdW50aWwgd2UgZmluZFxuICAgIC8vIHRoZSBmaXJzdCBBVURcbiAgICB3aGlsZSAobmFsVW5pdHMubGVuZ3RoKSB7XG4gICAgICBpZiAobmFsVW5pdHNbMF0ubmFsVW5pdFR5cGUgPT09ICdhY2Nlc3NfdW5pdF9kZWxpbWl0ZXJfcmJzcCcpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBuYWxVbml0cy5zaGlmdCgpO1xuICAgIH1cblxuICAgIC8vIHJldHVybiBlYXJseSBpZiBubyB2aWRlbyBkYXRhIGhhcyBiZWVuIG9ic2VydmVkXG4gICAgaWYgKG5hbFVuaXRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpcy50cmlnZ2VyKCdkb25lJywgJ1ZpZGVvU2VnbWVudFN0cmVhbScpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHdoaWxlIChuYWxVbml0cy5sZW5ndGgpIHtcbiAgICAgIGN1cnJlbnROYWwgPSBuYWxVbml0cy5zaGlmdCgpO1xuXG4gICAgICAvLyByZWNvcmQgdGhlIHRyYWNrIGNvbmZpZ1xuICAgICAgaWYgKGN1cnJlbnROYWwubmFsVW5pdFR5cGUgPT09ICdzZXFfcGFyYW1ldGVyX3NldF9yYnNwJykge1xuICAgICAgICB0cmFjay5uZXdNZXRhZGF0YSA9IHRydWU7XG4gICAgICAgIGNvbmZpZyA9IGN1cnJlbnROYWwuY29uZmlnO1xuICAgICAgICB0cmFjay53aWR0aCA9IGNvbmZpZy53aWR0aDtcbiAgICAgICAgdHJhY2suaGVpZ2h0ID0gY29uZmlnLmhlaWdodDtcbiAgICAgICAgdHJhY2suc3BzID0gW2N1cnJlbnROYWwuZGF0YV07XG4gICAgICAgIHRyYWNrLnByb2ZpbGVJZGMgPSBjb25maWcucHJvZmlsZUlkYztcbiAgICAgICAgdHJhY2subGV2ZWxJZGMgPSBjb25maWcubGV2ZWxJZGM7XG4gICAgICAgIHRyYWNrLnByb2ZpbGVDb21wYXRpYmlsaXR5ID0gY29uZmlnLnByb2ZpbGVDb21wYXRpYmlsaXR5O1xuICAgICAgICBoMjY0RnJhbWUuZW5kTmFsVW5pdCgpO1xuICAgICAgfSBlbHNlIGlmIChjdXJyZW50TmFsLm5hbFVuaXRUeXBlID09PSAncGljX3BhcmFtZXRlcl9zZXRfcmJzcCcpIHtcbiAgICAgICAgdHJhY2submV3TWV0YWRhdGEgPSB0cnVlO1xuICAgICAgICB0cmFjay5wcHMgPSBbY3VycmVudE5hbC5kYXRhXTtcbiAgICAgICAgaDI2NEZyYW1lLmVuZE5hbFVuaXQoKTtcbiAgICAgIH0gZWxzZSBpZiAoY3VycmVudE5hbC5uYWxVbml0VHlwZSA9PT0gJ2FjY2Vzc191bml0X2RlbGltaXRlcl9yYnNwJykge1xuICAgICAgICBpZiAoaDI2NEZyYW1lKSB7XG4gICAgICAgICAgdGhpcy5maW5pc2hGcmFtZSh0YWdzLCBoMjY0RnJhbWUpO1xuICAgICAgICB9XG4gICAgICAgIGgyNjRGcmFtZSA9IG5ldyBGbHZUYWcoRmx2VGFnLlZJREVPX1RBRyk7XG4gICAgICAgIGgyNjRGcmFtZS5wdHMgPSBjdXJyZW50TmFsLnB0cztcbiAgICAgICAgaDI2NEZyYW1lLmR0cyA9IGN1cnJlbnROYWwuZHRzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGN1cnJlbnROYWwubmFsVW5pdFR5cGUgPT09ICdzbGljZV9sYXllcl93aXRob3V0X3BhcnRpdGlvbmluZ19yYnNwX2lkcicpIHtcbiAgICAgICAgICAvLyB0aGUgY3VycmVudCBzYW1wbGUgaXMgYSBrZXkgZnJhbWVcbiAgICAgICAgICBoMjY0RnJhbWUua2V5RnJhbWUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGgyNjRGcmFtZS5lbmROYWxVbml0KCk7XG4gICAgICB9XG4gICAgICBoMjY0RnJhbWUuc3RhcnROYWxVbml0KCk7XG4gICAgICBoMjY0RnJhbWUud3JpdGVCeXRlcyhjdXJyZW50TmFsLmRhdGEpO1xuICAgIH1cbiAgICBpZiAoaDI2NEZyYW1lKSB7XG4gICAgICB0aGlzLmZpbmlzaEZyYW1lKHRhZ3MsIGgyNjRGcmFtZSk7XG4gICAgfVxuXG4gICAgdGhpcy50cmlnZ2VyKCdkYXRhJywge3RyYWNrOiB0cmFjaywgdGFnczogdGFncy5saXN0fSk7XG5cbiAgICAvLyBDb250aW51ZSB3aXRoIHRoZSBmbHVzaCBwcm9jZXNzIG5vd1xuICAgIHRoaXMudHJpZ2dlcignZG9uZScsICdWaWRlb1NlZ21lbnRTdHJlYW0nKTtcbiAgfTtcbn07XG5cblZpZGVvU2VnbWVudFN0cmVhbS5wcm90b3R5cGUgPSBuZXcgU3RyZWFtKCk7XG5cbi8qKlxuICogQW4gb2JqZWN0IHRoYXQgaW5jcmVtZW50YWxseSB0cmFuc211eGVzIE1QRUcyIFRyYXNwb3J0IFN0cmVhbVxuICogY2h1bmtzIGludG8gYW4gRkxWLlxuICovXG5UcmFuc211eGVyID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICB2YXJcbiAgICBzZWxmID0gdGhpcyxcblxuICAgIHBhY2tldFN0cmVhbSwgcGFyc2VTdHJlYW0sIGVsZW1lbnRhcnlTdHJlYW0sXG4gICAgdmlkZW9UaW1lc3RhbXBSb2xsb3ZlclN0cmVhbSwgYXVkaW9UaW1lc3RhbXBSb2xsb3ZlclN0cmVhbSxcbiAgICB0aW1lZE1ldGFkYXRhVGltZXN0YW1wUm9sbG92ZXJTdHJlYW0sXG4gICAgYWR0c1N0cmVhbSwgaDI2NFN0cmVhbSxcbiAgICB2aWRlb1NlZ21lbnRTdHJlYW0sIGF1ZGlvU2VnbWVudFN0cmVhbSwgY2FwdGlvblN0cmVhbSxcbiAgICBjb2FsZXNjZVN0cmVhbTtcblxuICBUcmFuc211eGVyLnByb3RvdHlwZS5pbml0LmNhbGwodGhpcyk7XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgLy8gZXhwb3NlIHRoZSBtZXRhZGF0YSBzdHJlYW1cbiAgdGhpcy5tZXRhZGF0YVN0cmVhbSA9IG5ldyBtMnRzLk1ldGFkYXRhU3RyZWFtKCk7XG5cbiAgb3B0aW9ucy5tZXRhZGF0YVN0cmVhbSA9IHRoaXMubWV0YWRhdGFTdHJlYW07XG5cbiAgLy8gc2V0IHVwIHRoZSBwYXJzaW5nIHBpcGVsaW5lXG4gIHBhY2tldFN0cmVhbSA9IG5ldyBtMnRzLlRyYW5zcG9ydFBhY2tldFN0cmVhbSgpO1xuICBwYXJzZVN0cmVhbSA9IG5ldyBtMnRzLlRyYW5zcG9ydFBhcnNlU3RyZWFtKCk7XG4gIGVsZW1lbnRhcnlTdHJlYW0gPSBuZXcgbTJ0cy5FbGVtZW50YXJ5U3RyZWFtKCk7XG4gIHZpZGVvVGltZXN0YW1wUm9sbG92ZXJTdHJlYW0gPSBuZXcgbTJ0cy5UaW1lc3RhbXBSb2xsb3ZlclN0cmVhbSgndmlkZW8nKTtcbiAgYXVkaW9UaW1lc3RhbXBSb2xsb3ZlclN0cmVhbSA9IG5ldyBtMnRzLlRpbWVzdGFtcFJvbGxvdmVyU3RyZWFtKCdhdWRpbycpO1xuICB0aW1lZE1ldGFkYXRhVGltZXN0YW1wUm9sbG92ZXJTdHJlYW0gPSBuZXcgbTJ0cy5UaW1lc3RhbXBSb2xsb3ZlclN0cmVhbSgndGltZWQtbWV0YWRhdGEnKTtcblxuICBhZHRzU3RyZWFtID0gbmV3IEFkdHNTdHJlYW0oKTtcbiAgaDI2NFN0cmVhbSA9IG5ldyBIMjY0U3RyZWFtKCk7XG4gIGNvYWxlc2NlU3RyZWFtID0gbmV3IENvYWxlc2NlU3RyZWFtKG9wdGlvbnMpO1xuXG4gIC8vIGRpc2Fzc2VtYmxlIE1QRUcyLVRTIHBhY2tldHMgaW50byBlbGVtZW50YXJ5IHN0cmVhbXNcbiAgcGFja2V0U3RyZWFtXG4gICAgLnBpcGUocGFyc2VTdHJlYW0pXG4gICAgLnBpcGUoZWxlbWVudGFyeVN0cmVhbSk7XG5cbiAgLy8gISFUSElTIE9SREVSIElTIElNUE9SVEFOVCEhXG4gIC8vIGRlbXV4IHRoZSBzdHJlYW1zXG4gIGVsZW1lbnRhcnlTdHJlYW1cbiAgICAucGlwZSh2aWRlb1RpbWVzdGFtcFJvbGxvdmVyU3RyZWFtKVxuICAgIC5waXBlKGgyNjRTdHJlYW0pO1xuICBlbGVtZW50YXJ5U3RyZWFtXG4gICAgLnBpcGUoYXVkaW9UaW1lc3RhbXBSb2xsb3ZlclN0cmVhbSlcbiAgICAucGlwZShhZHRzU3RyZWFtKTtcblxuICBlbGVtZW50YXJ5U3RyZWFtXG4gICAgLnBpcGUodGltZWRNZXRhZGF0YVRpbWVzdGFtcFJvbGxvdmVyU3RyZWFtKVxuICAgIC5waXBlKHRoaXMubWV0YWRhdGFTdHJlYW0pXG4gICAgLnBpcGUoY29hbGVzY2VTdHJlYW0pO1xuICAvLyBpZiBDRUEtNzA4IHBhcnNpbmcgaXMgYXZhaWxhYmxlLCBob29rIHVwIGEgY2FwdGlvbiBzdHJlYW1cbiAgY2FwdGlvblN0cmVhbSA9IG5ldyBtMnRzLkNhcHRpb25TdHJlYW0oKTtcbiAgaDI2NFN0cmVhbS5waXBlKGNhcHRpb25TdHJlYW0pXG4gICAgLnBpcGUoY29hbGVzY2VTdHJlYW0pO1xuXG4gIC8vIGhvb2sgdXAgdGhlIHNlZ21lbnQgc3RyZWFtcyBvbmNlIHRyYWNrIG1ldGFkYXRhIGlzIGRlbGl2ZXJlZFxuICBlbGVtZW50YXJ5U3RyZWFtLm9uKCdkYXRhJywgZnVuY3Rpb24oZGF0YSkge1xuICAgIHZhciBpLCB2aWRlb1RyYWNrLCBhdWRpb1RyYWNrO1xuXG4gICAgaWYgKGRhdGEudHlwZSA9PT0gJ21ldGFkYXRhJykge1xuICAgICAgaSA9IGRhdGEudHJhY2tzLmxlbmd0aDtcblxuICAgICAgLy8gc2NhbiB0aGUgdHJhY2tzIGxpc3RlZCBpbiB0aGUgbWV0YWRhdGFcbiAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgaWYgKGRhdGEudHJhY2tzW2ldLnR5cGUgPT09ICd2aWRlbycpIHtcbiAgICAgICAgICB2aWRlb1RyYWNrID0gZGF0YS50cmFja3NbaV07XG4gICAgICAgIH0gZWxzZSBpZiAoZGF0YS50cmFja3NbaV0udHlwZSA9PT0gJ2F1ZGlvJykge1xuICAgICAgICAgIGF1ZGlvVHJhY2sgPSBkYXRhLnRyYWNrc1tpXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBob29rIHVwIHRoZSB2aWRlbyBzZWdtZW50IHN0cmVhbSB0byB0aGUgZmlyc3QgdHJhY2sgd2l0aCBoMjY0IGRhdGFcbiAgICAgIGlmICh2aWRlb1RyYWNrICYmICF2aWRlb1NlZ21lbnRTdHJlYW0pIHtcbiAgICAgICAgY29hbGVzY2VTdHJlYW0ubnVtYmVyT2ZUcmFja3MrKztcbiAgICAgICAgdmlkZW9TZWdtZW50U3RyZWFtID0gbmV3IFZpZGVvU2VnbWVudFN0cmVhbSh2aWRlb1RyYWNrKTtcblxuICAgICAgICAvLyBTZXQgdXAgdGhlIGZpbmFsIHBhcnQgb2YgdGhlIHZpZGVvIHBpcGVsaW5lXG4gICAgICAgIGgyNjRTdHJlYW1cbiAgICAgICAgICAucGlwZSh2aWRlb1NlZ21lbnRTdHJlYW0pXG4gICAgICAgICAgLnBpcGUoY29hbGVzY2VTdHJlYW0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoYXVkaW9UcmFjayAmJiAhYXVkaW9TZWdtZW50U3RyZWFtKSB7XG4gICAgICAgIC8vIGhvb2sgdXAgdGhlIGF1ZGlvIHNlZ21lbnQgc3RyZWFtIHRvIHRoZSBmaXJzdCB0cmFjayB3aXRoIGFhYyBkYXRhXG4gICAgICAgIGNvYWxlc2NlU3RyZWFtLm51bWJlck9mVHJhY2tzKys7XG4gICAgICAgIGF1ZGlvU2VnbWVudFN0cmVhbSA9IG5ldyBBdWRpb1NlZ21lbnRTdHJlYW0oYXVkaW9UcmFjayk7XG5cbiAgICAgICAgLy8gU2V0IHVwIHRoZSBmaW5hbCBwYXJ0IG9mIHRoZSBhdWRpbyBwaXBlbGluZVxuICAgICAgICBhZHRzU3RyZWFtXG4gICAgICAgICAgLnBpcGUoYXVkaW9TZWdtZW50U3RyZWFtKVxuICAgICAgICAgIC5waXBlKGNvYWxlc2NlU3RyZWFtKTtcblxuICAgICAgICBpZiAodmlkZW9TZWdtZW50U3RyZWFtKSB7XG4gICAgICAgICAgdmlkZW9TZWdtZW50U3RyZWFtLm9uKCdrZXlmcmFtZScsIGF1ZGlvU2VnbWVudFN0cmVhbS5vblZpZGVvS2V5RnJhbWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICAvLyBmZWVkIGluY29taW5nIGRhdGEgdG8gdGhlIGZyb250IG9mIHRoZSBwYXJzaW5nIHBpcGVsaW5lXG4gIHRoaXMucHVzaCA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICBwYWNrZXRTdHJlYW0ucHVzaChkYXRhKTtcbiAgfTtcblxuICAvLyBmbHVzaCBhbnkgYnVmZmVyZWQgZGF0YVxuICB0aGlzLmZsdXNoID0gZnVuY3Rpb24oKSB7XG4gICAgLy8gU3RhcnQgYXQgdGhlIHRvcCBvZiB0aGUgcGlwZWxpbmUgYW5kIGZsdXNoIGFsbCBwZW5kaW5nIHdvcmtcbiAgICBwYWNrZXRTdHJlYW0uZmx1c2goKTtcbiAgfTtcblxuICAvLyBDYXB0aW9uIGRhdGEgaGFzIHRvIGJlIHJlc2V0IHdoZW4gc2Vla2luZyBvdXRzaWRlIGJ1ZmZlcmVkIHJhbmdlXG4gIHRoaXMucmVzZXRDYXB0aW9ucyA9IGZ1bmN0aW9uKCkge1xuICAgIGNhcHRpb25TdHJlYW0ucmVzZXQoKTtcbiAgfTtcblxuICAvLyBSZS1lbWl0IGFueSBkYXRhIGNvbWluZyBmcm9tIHRoZSBjb2FsZXNjZSBzdHJlYW0gdG8gdGhlIG91dHNpZGUgd29ybGRcbiAgY29hbGVzY2VTdHJlYW0ub24oJ2RhdGEnLCBmdW5jdGlvbihldmVudCkge1xuICAgIHNlbGYudHJpZ2dlcignZGF0YScsIGV2ZW50KTtcbiAgfSk7XG5cbiAgLy8gTGV0IHRoZSBjb25zdW1lciBrbm93IHdlIGhhdmUgZmluaXNoZWQgZmx1c2hpbmcgdGhlIGVudGlyZSBwaXBlbGluZVxuICBjb2FsZXNjZVN0cmVhbS5vbignZG9uZScsIGZ1bmN0aW9uKCkge1xuICAgIHNlbGYudHJpZ2dlcignZG9uZScpO1xuICB9KTtcbn07XG5UcmFuc211eGVyLnByb3RvdHlwZSA9IG5ldyBTdHJlYW0oKTtcblxuLy8gZm9yd2FyZCBjb21wYXRpYmlsaXR5XG5tb2R1bGUuZXhwb3J0cyA9IFRyYW5zbXV4ZXI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/videojs-contrib-media-sources/node_modules/mux.js/lib/flv/transmuxer.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/videojs-contrib-media-sources/node_modules/mux.js/lib/m2ts/caption-stream.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/videojs-contrib-media-sources/node_modules/mux.js/lib/m2ts/caption-stream.js ***!
  \***************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/**\n * mux.js\n *\n * Copyright (c) 2015 Brightcove\n * All rights reserved.\n *\n * Reads in-band caption information from a video elementary\n * stream. Captions must follow the CEA-708 standard for injection\n * into an MPEG-2 transport streams.\n * @see https://en.wikipedia.org/wiki/CEA-708\n * @see https://www.gpo.gov/fdsys/pkg/CFR-2007-title47-vol1/pdf/CFR-2007-title47-vol1-sec15-119.pdf\n */\n\n\n\n// -----------------\n// Link To Transport\n// -----------------\n\n// Supplemental enhancement information (SEI) NAL units have a\n// payload type field to indicate how they are to be\n// interpreted. CEAS-708 caption content is always transmitted with\n// payload type 0x04.\nvar USER_DATA_REGISTERED_ITU_T_T35 = 4,\n    RBSP_TRAILING_BITS = 128,\n    Stream = __webpack_require__(/*! ../utils/stream */ \"(ssr)/./node_modules/videojs-contrib-media-sources/node_modules/mux.js/lib/utils/stream.js\");\n\n/**\n  * Parse a supplemental enhancement information (SEI) NAL unit.\n  * Stops parsing once a message of type ITU T T35 has been found.\n  *\n  * @param bytes {Uint8Array} the bytes of a SEI NAL unit\n  * @return {object} the parsed SEI payload\n  * @see Rec. ITU-T H.264, 7.3.2.3.1\n  */\nvar parseSei = function(bytes) {\n  var\n    i = 0,\n    result = {\n      payloadType: -1,\n      payloadSize: 0\n    },\n    payloadType = 0,\n    payloadSize = 0;\n\n  // go through the sei_rbsp parsing each each individual sei_message\n  while (i < bytes.byteLength) {\n    // stop once we have hit the end of the sei_rbsp\n    if (bytes[i] === RBSP_TRAILING_BITS) {\n      break;\n    }\n\n    // Parse payload type\n    while (bytes[i] === 0xFF) {\n      payloadType += 255;\n      i++;\n    }\n    payloadType += bytes[i++];\n\n    // Parse payload size\n    while (bytes[i] === 0xFF) {\n      payloadSize += 255;\n      i++;\n    }\n    payloadSize += bytes[i++];\n\n    // this sei_message is a 608/708 caption so save it and break\n    // there can only ever be one caption message in a frame's sei\n    if (!result.payload && payloadType === USER_DATA_REGISTERED_ITU_T_T35) {\n      result.payloadType = payloadType;\n      result.payloadSize = payloadSize;\n      result.payload = bytes.subarray(i, i + payloadSize);\n      break;\n    }\n\n    // skip the payload and parse the next message\n    i += payloadSize;\n    payloadType = 0;\n    payloadSize = 0;\n  }\n\n  return result;\n};\n\n// see ANSI/SCTE 128-1 (2013), section 8.1\nvar parseUserData = function(sei) {\n  // itu_t_t35_contry_code must be 181 (United States) for\n  // captions\n  if (sei.payload[0] !== 181) {\n    return null;\n  }\n\n  // itu_t_t35_provider_code should be 49 (ATSC) for captions\n  if (((sei.payload[1] << 8) | sei.payload[2]) !== 49) {\n    return null;\n  }\n\n  // the user_identifier should be \"GA94\" to indicate ATSC1 data\n  if (String.fromCharCode(sei.payload[3],\n                          sei.payload[4],\n                          sei.payload[5],\n                          sei.payload[6]) !== 'GA94') {\n    return null;\n  }\n\n  // finally, user_data_type_code should be 0x03 for caption data\n  if (sei.payload[7] !== 0x03) {\n    return null;\n  }\n\n  // return the user_data_type_structure and strip the trailing\n  // marker bits\n  return sei.payload.subarray(8, sei.payload.length - 1);\n};\n\n// see CEA-708-D, section 4.4\nvar parseCaptionPackets = function(pts, userData) {\n  var results = [], i, count, offset, data;\n\n  // if this is just filler, return immediately\n  if (!(userData[0] & 0x40)) {\n    return results;\n  }\n\n  // parse out the cc_data_1 and cc_data_2 fields\n  count = userData[0] & 0x1f;\n  for (i = 0; i < count; i++) {\n    offset = i * 3;\n    data = {\n      type: userData[offset + 2] & 0x03,\n      pts: pts\n    };\n\n    // capture cc data when cc_valid is 1\n    if (userData[offset + 2] & 0x04) {\n      data.ccData = (userData[offset + 3] << 8) | userData[offset + 4];\n      results.push(data);\n    }\n  }\n  return results;\n};\n\nvar CaptionStream = function() {\n\n  CaptionStream.prototype.init.call(this);\n\n  this.captionPackets_ = [];\n\n  this.ccStreams_ = [\n    new Cea608Stream(0, 0), // eslint-disable-line no-use-before-define\n    new Cea608Stream(0, 1), // eslint-disable-line no-use-before-define\n    new Cea608Stream(1, 0), // eslint-disable-line no-use-before-define\n    new Cea608Stream(1, 1) // eslint-disable-line no-use-before-define\n  ];\n\n  this.reset();\n\n  // forward data and done events from CCs to this CaptionStream\n  this.ccStreams_.forEach(function(cc) {\n    cc.on('data', this.trigger.bind(this, 'data'));\n    cc.on('done', this.trigger.bind(this, 'done'));\n  }, this);\n\n};\n\nCaptionStream.prototype = new Stream();\nCaptionStream.prototype.push = function(event) {\n  var sei, userData;\n\n  // only examine SEI NALs\n  if (event.nalUnitType !== 'sei_rbsp') {\n    return;\n  }\n\n  // parse the sei\n  sei = parseSei(event.escapedRBSP);\n\n  // ignore everything but user_data_registered_itu_t_t35\n  if (sei.payloadType !== USER_DATA_REGISTERED_ITU_T_T35) {\n    return;\n  }\n\n  // parse out the user data payload\n  userData = parseUserData(sei);\n\n  // ignore unrecognized userData\n  if (!userData) {\n    return;\n  }\n\n  // Sometimes, the same segment # will be downloaded twice. To stop the\n  // caption data from being processed twice, we track the latest dts we've\n  // received and ignore everything with a dts before that. However, since\n  // data for a specific dts can be split across 2 packets on either side of\n  // a segment boundary, we need to make sure we *don't* ignore the second\n  // dts packet we receive that has dts === this.latestDts_. And thus, the\n  // ignoreNextEqualDts_ flag was born.\n  if (event.dts < this.latestDts_) {\n    // We've started getting older data, so set the flag.\n    this.ignoreNextEqualDts_ = true;\n    return;\n  } else if ((event.dts === this.latestDts_) && (this.ignoreNextEqualDts_)) {\n    // We've received the last duplicate packet, time to start processing again\n    this.ignoreNextEqualDts_ = false;\n    return;\n  }\n\n  // parse out CC data packets and save them for later\n  this.captionPackets_ = this.captionPackets_.concat(parseCaptionPackets(event.pts, userData));\n  this.latestDts_ = event.dts;\n};\n\nCaptionStream.prototype.flush = function() {\n  // make sure we actually parsed captions before proceeding\n  if (!this.captionPackets_.length) {\n    this.ccStreams_.forEach(function(cc) {\n      cc.flush();\n    }, this);\n    return;\n  }\n\n  // In Chrome, the Array#sort function is not stable so add a\n  // presortIndex that we can use to ensure we get a stable-sort\n  this.captionPackets_.forEach(function(elem, idx) {\n    elem.presortIndex = idx;\n  });\n\n  // sort caption byte-pairs based on their PTS values\n  this.captionPackets_.sort(function(a, b) {\n    if (a.pts === b.pts) {\n      return a.presortIndex - b.presortIndex;\n    }\n    return a.pts - b.pts;\n  });\n\n  this.captionPackets_.forEach(function(packet) {\n    if (packet.type < 2) {\n      // Dispatch packet to the right Cea608Stream\n      this.dispatchCea608Packet(packet);\n    }\n    // this is where an 'else' would go for a dispatching packets\n    // to a theoretical Cea708Stream that handles SERVICEn data\n  }, this);\n\n  this.captionPackets_.length = 0;\n  this.ccStreams_.forEach(function(cc) {\n    cc.flush();\n  }, this);\n  return;\n};\n\nCaptionStream.prototype.reset = function() {\n  this.latestDts_ = null;\n  this.ignoreNextEqualDts_ = false;\n  this.activeCea608Channel_ = [null, null];\n  this.ccStreams_.forEach(function(ccStream) {\n    ccStream.reset();\n  });\n};\n\nCaptionStream.prototype.dispatchCea608Packet = function(packet) {\n  // NOTE: packet.type is the CEA608 field\n  if (this.setsChannel1Active(packet)) {\n    this.activeCea608Channel_[packet.type] = 0;\n  } else if (this.setsChannel2Active(packet)) {\n    this.activeCea608Channel_[packet.type] = 1;\n  }\n  if (this.activeCea608Channel_[packet.type] === null) {\n    // If we haven't received anything to set the active channel, discard the\n    // data; we don't want jumbled captions\n    return;\n  }\n  this.ccStreams_[(packet.type << 1) + this.activeCea608Channel_[packet.type]].push(packet);\n};\n\nCaptionStream.prototype.setsChannel1Active = function(packet) {\n  return ((packet.ccData & 0x7800) === 0x1000);\n};\nCaptionStream.prototype.setsChannel2Active = function(packet) {\n  return ((packet.ccData & 0x7800) === 0x1800);\n};\n\n// ----------------------\n// Session to Application\n// ----------------------\n\nvar CHARACTER_TRANSLATION = {\n  0x2a: 0xe1,     // \n  0x5c: 0xe9,     // \n  0x5e: 0xed,     // \n  0x5f: 0xf3,     // \n  0x60: 0xfa,     // \n  0x7b: 0xe7,     // \n  0x7c: 0xf7,     // \n  0x7d: 0xd1,     // \n  0x7e: 0xf1,     // \n  0x7f: 0x2588,   // \n  0x0130: 0xae,   // \n  0x0131: 0xb0,   // \n  0x0132: 0xbd,   // \n  0x0133: 0xbf,   // \n  0x0134: 0x2122, // \n  0x0135: 0xa2,   // \n  0x0136: 0xa3,   // \n  0x0137: 0x266a, // \n  0x0138: 0xe0,   // \n  0x0139: 0xa0,   //\n  0x013a: 0xe8,   // \n  0x013b: 0xe2,   // \n  0x013c: 0xea,   // \n  0x013d: 0xee,   // \n  0x013e: 0xf4,   // \n  0x013f: 0xfb,   // \n  0x0220: 0xc1,   // \n  0x0221: 0xc9,   // \n  0x0222: 0xd3,   // \n  0x0223: 0xda,   // \n  0x0224: 0xdc,   // \n  0x0225: 0xfc,   // \n  0x0226: 0x2018, // \n  0x0227: 0xa1,   // \n  0x0228: 0x2a,   // *\n  0x0229: 0x27,   // '\n  0x022a: 0x2014, // \n  0x022b: 0xa9,   // \n  0x022c: 0x2120, // \n  0x022d: 0x2022, // \n  0x022e: 0x201c, // \n  0x022f: 0x201d, // \n  0x0230: 0xc0,   // \n  0x0231: 0xc2,   // \n  0x0232: 0xc7,   // \n  0x0233: 0xc8,   // \n  0x0234: 0xca,   // \n  0x0235: 0xcb,   // \n  0x0236: 0xeb,   // \n  0x0237: 0xce,   // \n  0x0238: 0xcf,   // \n  0x0239: 0xef,   // \n  0x023a: 0xd4,   // \n  0x023b: 0xd9,   // \n  0x023c: 0xf9,   // \n  0x023d: 0xdb,   // \n  0x023e: 0xab,   // \n  0x023f: 0xbb,   // \n  0x0320: 0xc3,   // \n  0x0321: 0xe3,   // \n  0x0322: 0xcd,   // \n  0x0323: 0xcc,   // \n  0x0324: 0xec,   // \n  0x0325: 0xd2,   // \n  0x0326: 0xf2,   // \n  0x0327: 0xd5,   // \n  0x0328: 0xf5,   // \n  0x0329: 0x7b,   // {\n  0x032a: 0x7d,   // }\n  0x032b: 0x5c,   // \\\n  0x032c: 0x5e,   // ^\n  0x032d: 0x5f,   // _\n  0x032e: 0x7c,   // |\n  0x032f: 0x7e,   // ~\n  0x0330: 0xc4,   // \n  0x0331: 0xe4,   // \n  0x0332: 0xd6,   // \n  0x0333: 0xf6,   // \n  0x0334: 0xdf,   // \n  0x0335: 0xa5,   // \n  0x0336: 0xa4,   // \n  0x0337: 0x2502, // \n  0x0338: 0xc5,   // \n  0x0339: 0xe5,   // \n  0x033a: 0xd8,   // \n  0x033b: 0xf8,   // \n  0x033c: 0x250c, // \n  0x033d: 0x2510, // \n  0x033e: 0x2514, // \n  0x033f: 0x2518  // \n};\n\nvar getCharFromCode = function(code) {\n  if (code === null) {\n    return '';\n  }\n  code = CHARACTER_TRANSLATION[code] || code;\n  return String.fromCharCode(code);\n};\n\n// the index of the last row in a CEA-608 display buffer\nvar BOTTOM_ROW = 14;\n\n// This array is used for mapping PACs -> row #, since there's no way of\n// getting it through bit logic.\nvar ROWS = [0x1100, 0x1120, 0x1200, 0x1220, 0x1500, 0x1520, 0x1600, 0x1620,\n            0x1700, 0x1720, 0x1000, 0x1300, 0x1320, 0x1400, 0x1420];\n\n// CEA-608 captions are rendered onto a 34x15 matrix of character\n// cells. The \"bottom\" row is the last element in the outer array.\nvar createDisplayBuffer = function() {\n  var result = [], i = BOTTOM_ROW + 1;\n  while (i--) {\n    result.push('');\n  }\n  return result;\n};\n\nvar Cea608Stream = function(field, dataChannel) {\n  Cea608Stream.prototype.init.call(this);\n\n  this.field_ = field || 0;\n  this.dataChannel_ = dataChannel || 0;\n\n  this.name_ = 'CC' + (((this.field_ << 1) | this.dataChannel_) + 1);\n\n  this.setConstants();\n  this.reset();\n\n  this.push = function(packet) {\n    var data, swap, char0, char1, text;\n    // remove the parity bits\n    data = packet.ccData & 0x7f7f;\n\n    // ignore duplicate control codes; the spec demands they're sent twice\n    if (data === this.lastControlCode_) {\n      this.lastControlCode_ = null;\n      return;\n    }\n\n    // Store control codes\n    if ((data & 0xf000) === 0x1000) {\n      this.lastControlCode_ = data;\n    } else if (data !== this.PADDING_) {\n      this.lastControlCode_ = null;\n    }\n\n    char0 = data >>> 8;\n    char1 = data & 0xff;\n\n    if (data === this.PADDING_) {\n      return;\n\n    } else if (data === this.RESUME_CAPTION_LOADING_) {\n      this.mode_ = 'popOn';\n\n    } else if (data === this.END_OF_CAPTION_) {\n      this.clearFormatting(packet.pts);\n      // if a caption was being displayed, it's gone now\n      this.flushDisplayed(packet.pts);\n\n      // flip memory\n      swap = this.displayed_;\n      this.displayed_ = this.nonDisplayed_;\n      this.nonDisplayed_ = swap;\n\n      // start measuring the time to display the caption\n      this.startPts_ = packet.pts;\n\n    } else if (data === this.ROLL_UP_2_ROWS_) {\n      this.topRow_ = BOTTOM_ROW - 1;\n      this.mode_ = 'rollUp';\n    } else if (data === this.ROLL_UP_3_ROWS_) {\n      this.topRow_ = BOTTOM_ROW - 2;\n      this.mode_ = 'rollUp';\n    } else if (data === this.ROLL_UP_4_ROWS_) {\n      this.topRow_ = BOTTOM_ROW - 3;\n      this.mode_ = 'rollUp';\n    } else if (data === this.CARRIAGE_RETURN_) {\n      this.clearFormatting(packet.pts);\n      this.flushDisplayed(packet.pts);\n      this.shiftRowsUp_();\n      this.startPts_ = packet.pts;\n\n    } else if (data === this.BACKSPACE_) {\n      if (this.mode_ === 'popOn') {\n        this.nonDisplayed_[BOTTOM_ROW] = this.nonDisplayed_[BOTTOM_ROW].slice(0, -1);\n      } else {\n        this.displayed_[BOTTOM_ROW] = this.displayed_[BOTTOM_ROW].slice(0, -1);\n      }\n    } else if (data === this.ERASE_DISPLAYED_MEMORY_) {\n      this.flushDisplayed(packet.pts);\n      this.displayed_ = createDisplayBuffer();\n    } else if (data === this.ERASE_NON_DISPLAYED_MEMORY_) {\n      this.nonDisplayed_ = createDisplayBuffer();\n\n    } else if (data === this.RESUME_DIRECT_CAPTIONING_) {\n      this.mode_ = 'paintOn';\n\n    // Append special characters to caption text\n    } else if (this.isSpecialCharacter(char0, char1)) {\n      // Bitmask char0 so that we can apply character transformations\n      // regardless of field and data channel.\n      // Then byte-shift to the left and OR with char1 so we can pass the\n      // entire character code to `getCharFromCode`.\n      char0 = (char0 & 0x03) << 8;\n      text = getCharFromCode(char0 | char1);\n      this[this.mode_](packet.pts, text);\n      this.column_++;\n\n    // Append extended characters to caption text\n    } else if (this.isExtCharacter(char0, char1)) {\n      // Extended characters always follow their \"non-extended\" equivalents.\n      // IE if a \"\" is desired, you'll always receive \"e\"; non-compliant\n      // decoders are supposed to drop the \"\", while compliant decoders\n      // backspace the \"e\" and insert \"\".\n\n      // Delete the previous character\n      if (this.mode_ === 'popOn') {\n        this.nonDisplayed_[this.row_] = this.nonDisplayed_[this.row_].slice(0, -1);\n      } else {\n        this.displayed_[BOTTOM_ROW] = this.displayed_[BOTTOM_ROW].slice(0, -1);\n      }\n\n      // Bitmask char0 so that we can apply character transformations\n      // regardless of field and data channel.\n      // Then byte-shift to the left and OR with char1 so we can pass the\n      // entire character code to `getCharFromCode`.\n      char0 = (char0 & 0x03) << 8;\n      text = getCharFromCode(char0 | char1);\n      this[this.mode_](packet.pts, text);\n      this.column_++;\n\n    // Process mid-row codes\n    } else if (this.isMidRowCode(char0, char1)) {\n      // Attributes are not additive, so clear all formatting\n      this.clearFormatting(packet.pts);\n\n      // According to the standard, mid-row codes\n      // should be replaced with spaces, so add one now\n      this[this.mode_](packet.pts, ' ');\n      this.column_++;\n\n      if ((char1 & 0xe) === 0xe) {\n        this.addFormatting(packet.pts, ['i']);\n      }\n\n      if ((char1 & 0x1) === 0x1) {\n        this.addFormatting(packet.pts, ['u']);\n      }\n\n    // Detect offset control codes and adjust cursor\n    } else if (this.isOffsetControlCode(char0, char1)) {\n      // Cursor position is set by indent PAC (see below) in 4-column\n      // increments, with an additional offset code of 1-3 to reach any\n      // of the 32 columns specified by CEA-608. So all we need to do\n      // here is increment the column cursor by the given offset.\n      this.column_ += (char1 & 0x03);\n\n    // Detect PACs (Preamble Address Codes)\n    } else if (this.isPAC(char0, char1)) {\n\n      // There's no logic for PAC -> row mapping, so we have to just\n      // find the row code in an array and use its index :(\n      var row = ROWS.indexOf(data & 0x1f20);\n\n      if (row !== this.row_) {\n        // formatting is only persistent for current row\n        this.clearFormatting(packet.pts);\n        this.row_ = row;\n      }\n      // All PACs can apply underline, so detect and apply\n      // (All odd-numbered second bytes set underline)\n      if ((char1 & 0x1) && (this.formatting_.indexOf('u') === -1)) {\n          this.addFormatting(packet.pts, ['u']);\n      }\n\n      if ((data & 0x10) === 0x10) {\n        // We've got an indent level code. Each successive even number\n        // increments the column cursor by 4, so we can get the desired\n        // column position by bit-shifting to the right (to get n/2)\n        // and multiplying by 4.\n        this.column_ = ((data & 0xe) >> 1) * 4;\n      }\n\n      if (this.isColorPAC(char1)) {\n        // it's a color code, though we only support white, which\n        // can be either normal or italicized. white italics can be\n        // either 0x4e or 0x6e depending on the row, so we just\n        // bitwise-and with 0xe to see if italics should be turned on\n        if ((char1 & 0xe) === 0xe) {\n          this.addFormatting(packet.pts, ['i']);\n        }\n      }\n\n    // We have a normal character in char0, and possibly one in char1\n    } else if (this.isNormalChar(char0)) {\n      if (char1 === 0x00) {\n        char1 = null;\n      }\n      text = getCharFromCode(char0);\n      text += getCharFromCode(char1);\n      this[this.mode_](packet.pts, text);\n      this.column_ += text.length;\n\n    } // finish data processing\n\n  };\n};\nCea608Stream.prototype = new Stream();\n// Trigger a cue point that captures the current state of the\n// display buffer\nCea608Stream.prototype.flushDisplayed = function(pts) {\n  var content = this.displayed_\n    // remove spaces from the start and end of the string\n    .map(function(row) {\n      return row.trim();\n    })\n    // combine all text rows to display in one cue\n    .join('\\n')\n    // and remove blank rows from the start and end, but not the middle\n    .replace(/^\\n+|\\n+$/g, '');\n\n  if (content.length) {\n    this.trigger('data', {\n      startPts: this.startPts_,\n      endPts: pts,\n      text: content,\n      stream: this.name_\n    });\n  }\n};\n\n/**\n * Zero out the data, used for startup and on seek\n */\nCea608Stream.prototype.reset = function() {\n  this.mode_ = 'popOn';\n  // When in roll-up mode, the index of the last row that will\n  // actually display captions. If a caption is shifted to a row\n  // with a lower index than this, it is cleared from the display\n  // buffer\n  this.topRow_ = 0;\n  this.startPts_ = 0;\n  this.displayed_ = createDisplayBuffer();\n  this.nonDisplayed_ = createDisplayBuffer();\n  this.lastControlCode_ = null;\n\n  // Track row and column for proper line-breaking and spacing\n  this.column_ = 0;\n  this.row_ = BOTTOM_ROW;\n\n  // This variable holds currently-applied formatting\n  this.formatting_ = [];\n};\n\n/**\n * Sets up control code and related constants for this instance\n */\nCea608Stream.prototype.setConstants = function() {\n  // The following attributes have these uses:\n  // ext_ :    char0 for mid-row codes, and the base for extended\n  //           chars (ext_+0, ext_+1, and ext_+2 are char0s for\n  //           extended codes)\n  // control_: char0 for control codes, except byte-shifted to the\n  //           left so that we can do this.control_ | CONTROL_CODE\n  // offset_:  char0 for tab offset codes\n  //\n  // It's also worth noting that control codes, and _only_ control codes,\n  // differ between field 1 and field2. Field 2 control codes are always\n  // their field 1 value plus 1. That's why there's the \"| field\" on the\n  // control value.\n  if (this.dataChannel_ === 0) {\n    this.BASE_     = 0x10;\n    this.EXT_      = 0x11;\n    this.CONTROL_  = (0x14 | this.field_) << 8;\n    this.OFFSET_   = 0x17;\n  } else if (this.dataChannel_ === 1) {\n    this.BASE_     = 0x18;\n    this.EXT_      = 0x19;\n    this.CONTROL_  = (0x1c | this.field_) << 8;\n    this.OFFSET_   = 0x1f;\n  }\n\n  // Constants for the LSByte command codes recognized by Cea608Stream. This\n  // list is not exhaustive. For a more comprehensive listing and semantics see\n  // http://www.gpo.gov/fdsys/pkg/CFR-2010-title47-vol1/pdf/CFR-2010-title47-vol1-sec15-119.pdf\n  // Padding\n  this.PADDING_                    = 0x0000;\n  // Pop-on Mode\n  this.RESUME_CAPTION_LOADING_     = this.CONTROL_ | 0x20;\n  this.END_OF_CAPTION_             = this.CONTROL_ | 0x2f;\n  // Roll-up Mode\n  this.ROLL_UP_2_ROWS_             = this.CONTROL_ | 0x25;\n  this.ROLL_UP_3_ROWS_             = this.CONTROL_ | 0x26;\n  this.ROLL_UP_4_ROWS_             = this.CONTROL_ | 0x27;\n  this.CARRIAGE_RETURN_            = this.CONTROL_ | 0x2d;\n  // paint-on mode (not supported)\n  this.RESUME_DIRECT_CAPTIONING_   = this.CONTROL_ | 0x29;\n  // Erasure\n  this.BACKSPACE_                  = this.CONTROL_ | 0x21;\n  this.ERASE_DISPLAYED_MEMORY_     = this.CONTROL_ | 0x2c;\n  this.ERASE_NON_DISPLAYED_MEMORY_ = this.CONTROL_ | 0x2e;\n};\n\n/**\n * Detects if the 2-byte packet data is a special character\n *\n * Special characters have a second byte in the range 0x30 to 0x3f,\n * with the first byte being 0x11 (for data channel 1) or 0x19 (for\n * data channel 2).\n *\n * @param  {Integer} char0 The first byte\n * @param  {Integer} char1 The second byte\n * @return {Boolean}       Whether the 2 bytes are an special character\n */\nCea608Stream.prototype.isSpecialCharacter = function(char0, char1) {\n  return (char0 === this.EXT_ && char1 >= 0x30 && char1 <= 0x3f);\n};\n\n/**\n * Detects if the 2-byte packet data is an extended character\n *\n * Extended characters have a second byte in the range 0x20 to 0x3f,\n * with the first byte being 0x12 or 0x13 (for data channel 1) or\n * 0x1a or 0x1b (for data channel 2).\n *\n * @param  {Integer} char0 The first byte\n * @param  {Integer} char1 The second byte\n * @return {Boolean}       Whether the 2 bytes are an extended character\n */\nCea608Stream.prototype.isExtCharacter = function(char0, char1) {\n  return ((char0 === (this.EXT_ + 1) || char0 === (this.EXT_ + 2)) &&\n    (char1 >= 0x20 && char1 <= 0x3f));\n};\n\n/**\n * Detects if the 2-byte packet is a mid-row code\n *\n * Mid-row codes have a second byte in the range 0x20 to 0x2f, with\n * the first byte being 0x11 (for data channel 1) or 0x19 (for data\n * channel 2).\n *\n * @param  {Integer} char0 The first byte\n * @param  {Integer} char1 The second byte\n * @return {Boolean}       Whether the 2 bytes are a mid-row code\n */\nCea608Stream.prototype.isMidRowCode = function(char0, char1) {\n  return (char0 === this.EXT_ && (char1 >= 0x20 && char1 <= 0x2f));\n};\n\n/**\n * Detects if the 2-byte packet is an offset control code\n *\n * Offset control codes have a second byte in the range 0x21 to 0x23,\n * with the first byte being 0x17 (for data channel 1) or 0x1f (for\n * data channel 2).\n *\n * @param  {Integer} char0 The first byte\n * @param  {Integer} char1 The second byte\n * @return {Boolean}       Whether the 2 bytes are an offset control code\n */\nCea608Stream.prototype.isOffsetControlCode = function(char0, char1) {\n  return (char0 === this.OFFSET_ && (char1 >= 0x21 && char1 <= 0x23));\n};\n\n/**\n * Detects if the 2-byte packet is a Preamble Address Code\n *\n * PACs have a first byte in the range 0x10 to 0x17 (for data channel 1)\n * or 0x18 to 0x1f (for data channel 2), with the second byte in the\n * range 0x40 to 0x7f.\n *\n * @param  {Integer} char0 The first byte\n * @param  {Integer} char1 The second byte\n * @return {Boolean}       Whether the 2 bytes are a PAC\n */\nCea608Stream.prototype.isPAC = function(char0, char1) {\n  return (char0 >= this.BASE_ && char0 < (this.BASE_ + 8) &&\n    (char1 >= 0x40 && char1 <= 0x7f));\n};\n\n/**\n * Detects if a packet's second byte is in the range of a PAC color code\n *\n * PAC color codes have the second byte be in the range 0x40 to 0x4f, or\n * 0x60 to 0x6f.\n *\n * @param  {Integer} char1 The second byte\n * @return {Boolean}       Whether the byte is a color PAC\n */\nCea608Stream.prototype.isColorPAC = function(char1) {\n  return ((char1 >= 0x40 && char1 <= 0x4f) || (char1 >= 0x60 && char1 <= 0x7f));\n};\n\n/**\n * Detects if a single byte is in the range of a normal character\n *\n * Normal text bytes are in the range 0x20 to 0x7f.\n *\n * @param  {Integer} char  The byte\n * @return {Boolean}       Whether the byte is a normal character\n */\nCea608Stream.prototype.isNormalChar = function(char) {\n  return (char >= 0x20 && char <= 0x7f);\n};\n\n// Adds the opening HTML tag for the passed character to the caption text,\n// and keeps track of it for later closing\nCea608Stream.prototype.addFormatting = function(pts, format) {\n  this.formatting_ = this.formatting_.concat(format);\n  var text = format.reduce(function(text, format) {\n    return text + '<' + format + '>';\n  }, '');\n  this[this.mode_](pts, text);\n};\n\n// Adds HTML closing tags for current formatting to caption text and\n// clears remembered formatting\nCea608Stream.prototype.clearFormatting = function(pts) {\n  if (!this.formatting_.length) {\n    return;\n  }\n  var text = this.formatting_.reverse().reduce(function(text, format) {\n    return text + '</' + format + '>';\n  }, '');\n  this.formatting_ = [];\n  this[this.mode_](pts, text);\n};\n\n// Mode Implementations\nCea608Stream.prototype.popOn = function(pts, text) {\n  var baseRow = this.nonDisplayed_[this.row_];\n\n  // buffer characters\n  baseRow += text;\n  this.nonDisplayed_[this.row_] = baseRow;\n};\n\nCea608Stream.prototype.rollUp = function(pts, text) {\n  var baseRow = this.displayed_[BOTTOM_ROW];\n\n  baseRow += text;\n  this.displayed_[BOTTOM_ROW] = baseRow;\n\n};\n\nCea608Stream.prototype.shiftRowsUp_ = function() {\n  var i;\n  // clear out inactive rows\n  for (i = 0; i < this.topRow_; i++) {\n    this.displayed_[i] = '';\n  }\n  // shift displayed rows up\n  for (i = this.topRow_; i < BOTTOM_ROW; i++) {\n    this.displayed_[i] = this.displayed_[i + 1];\n  }\n  // clear out the bottom row\n  this.displayed_[BOTTOM_ROW] = '';\n};\n\n// paintOn mode is not implemented\nCea608Stream.prototype.paintOn = function() {};\n\n// exports\nmodule.exports = {\n  CaptionStream: CaptionStream,\n  Cea608Stream: Cea608Stream\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdmlkZW9qcy1jb250cmliLW1lZGlhLXNvdXJjZXMvbm9kZV9tb2R1bGVzL211eC5qcy9saWIvbTJ0cy9jYXB0aW9uLXN0cmVhbS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsbUJBQU8sQ0FBQyxtSEFBaUI7O0FBRXRDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFlBQVk7QUFDOUIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsV0FBVztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsTUFBTTtBQUNOOztBQUVBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUEsTUFBTTtBQUNOO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBLE1BQU07QUFDTjs7QUFFQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCLFlBQVksU0FBUztBQUNyQixZQUFZLGVBQWU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFNBQVM7QUFDckIsWUFBWSxTQUFTO0FBQ3JCLFlBQVksZUFBZTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCLFlBQVksU0FBUztBQUNyQixZQUFZLGVBQWU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFNBQVM7QUFDckIsWUFBWSxTQUFTO0FBQ3JCLFlBQVksZUFBZTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksU0FBUztBQUNyQixZQUFZLFNBQVM7QUFDckIsWUFBWSxlQUFlO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCLFlBQVksZUFBZTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCLFlBQVksZUFBZTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsa0JBQWtCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixnQkFBZ0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS12MC1wcm9qZWN0Ly4vbm9kZV9tb2R1bGVzL3ZpZGVvanMtY29udHJpYi1tZWRpYS1zb3VyY2VzL25vZGVfbW9kdWxlcy9tdXguanMvbGliL20ydHMvY2FwdGlvbi1zdHJlYW0uanM/YTE4OCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIG11eC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNSBCcmlnaHRjb3ZlXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlYWRzIGluLWJhbmQgY2FwdGlvbiBpbmZvcm1hdGlvbiBmcm9tIGEgdmlkZW8gZWxlbWVudGFyeVxuICogc3RyZWFtLiBDYXB0aW9ucyBtdXN0IGZvbGxvdyB0aGUgQ0VBLTcwOCBzdGFuZGFyZCBmb3IgaW5qZWN0aW9uXG4gKiBpbnRvIGFuIE1QRUctMiB0cmFuc3BvcnQgc3RyZWFtcy5cbiAqIEBzZWUgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ0VBLTcwOFxuICogQHNlZSBodHRwczovL3d3dy5ncG8uZ292L2Zkc3lzL3BrZy9DRlItMjAwNy10aXRsZTQ3LXZvbDEvcGRmL0NGUi0yMDA3LXRpdGxlNDctdm9sMS1zZWMxNS0xMTkucGRmXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLVxuLy8gTGluayBUbyBUcmFuc3BvcnRcbi8vIC0tLS0tLS0tLS0tLS0tLS0tXG5cbi8vIFN1cHBsZW1lbnRhbCBlbmhhbmNlbWVudCBpbmZvcm1hdGlvbiAoU0VJKSBOQUwgdW5pdHMgaGF2ZSBhXG4vLyBwYXlsb2FkIHR5cGUgZmllbGQgdG8gaW5kaWNhdGUgaG93IHRoZXkgYXJlIHRvIGJlXG4vLyBpbnRlcnByZXRlZC4gQ0VBUy03MDggY2FwdGlvbiBjb250ZW50IGlzIGFsd2F5cyB0cmFuc21pdHRlZCB3aXRoXG4vLyBwYXlsb2FkIHR5cGUgMHgwNC5cbnZhciBVU0VSX0RBVEFfUkVHSVNURVJFRF9JVFVfVF9UMzUgPSA0LFxuICAgIFJCU1BfVFJBSUxJTkdfQklUUyA9IDEyOCxcbiAgICBTdHJlYW0gPSByZXF1aXJlKCcuLi91dGlscy9zdHJlYW0nKTtcblxuLyoqXG4gICogUGFyc2UgYSBzdXBwbGVtZW50YWwgZW5oYW5jZW1lbnQgaW5mb3JtYXRpb24gKFNFSSkgTkFMIHVuaXQuXG4gICogU3RvcHMgcGFyc2luZyBvbmNlIGEgbWVzc2FnZSBvZiB0eXBlIElUVSBUIFQzNSBoYXMgYmVlbiBmb3VuZC5cbiAgKlxuICAqIEBwYXJhbSBieXRlcyB7VWludDhBcnJheX0gdGhlIGJ5dGVzIG9mIGEgU0VJIE5BTCB1bml0XG4gICogQHJldHVybiB7b2JqZWN0fSB0aGUgcGFyc2VkIFNFSSBwYXlsb2FkXG4gICogQHNlZSBSZWMuIElUVS1UIEguMjY0LCA3LjMuMi4zLjFcbiAgKi9cbnZhciBwYXJzZVNlaSA9IGZ1bmN0aW9uKGJ5dGVzKSB7XG4gIHZhclxuICAgIGkgPSAwLFxuICAgIHJlc3VsdCA9IHtcbiAgICAgIHBheWxvYWRUeXBlOiAtMSxcbiAgICAgIHBheWxvYWRTaXplOiAwXG4gICAgfSxcbiAgICBwYXlsb2FkVHlwZSA9IDAsXG4gICAgcGF5bG9hZFNpemUgPSAwO1xuXG4gIC8vIGdvIHRocm91Z2ggdGhlIHNlaV9yYnNwIHBhcnNpbmcgZWFjaCBlYWNoIGluZGl2aWR1YWwgc2VpX21lc3NhZ2VcbiAgd2hpbGUgKGkgPCBieXRlcy5ieXRlTGVuZ3RoKSB7XG4gICAgLy8gc3RvcCBvbmNlIHdlIGhhdmUgaGl0IHRoZSBlbmQgb2YgdGhlIHNlaV9yYnNwXG4gICAgaWYgKGJ5dGVzW2ldID09PSBSQlNQX1RSQUlMSU5HX0JJVFMpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8vIFBhcnNlIHBheWxvYWQgdHlwZVxuICAgIHdoaWxlIChieXRlc1tpXSA9PT0gMHhGRikge1xuICAgICAgcGF5bG9hZFR5cGUgKz0gMjU1O1xuICAgICAgaSsrO1xuICAgIH1cbiAgICBwYXlsb2FkVHlwZSArPSBieXRlc1tpKytdO1xuXG4gICAgLy8gUGFyc2UgcGF5bG9hZCBzaXplXG4gICAgd2hpbGUgKGJ5dGVzW2ldID09PSAweEZGKSB7XG4gICAgICBwYXlsb2FkU2l6ZSArPSAyNTU7XG4gICAgICBpKys7XG4gICAgfVxuICAgIHBheWxvYWRTaXplICs9IGJ5dGVzW2krK107XG5cbiAgICAvLyB0aGlzIHNlaV9tZXNzYWdlIGlzIGEgNjA4LzcwOCBjYXB0aW9uIHNvIHNhdmUgaXQgYW5kIGJyZWFrXG4gICAgLy8gdGhlcmUgY2FuIG9ubHkgZXZlciBiZSBvbmUgY2FwdGlvbiBtZXNzYWdlIGluIGEgZnJhbWUncyBzZWlcbiAgICBpZiAoIXJlc3VsdC5wYXlsb2FkICYmIHBheWxvYWRUeXBlID09PSBVU0VSX0RBVEFfUkVHSVNURVJFRF9JVFVfVF9UMzUpIHtcbiAgICAgIHJlc3VsdC5wYXlsb2FkVHlwZSA9IHBheWxvYWRUeXBlO1xuICAgICAgcmVzdWx0LnBheWxvYWRTaXplID0gcGF5bG9hZFNpemU7XG4gICAgICByZXN1bHQucGF5bG9hZCA9IGJ5dGVzLnN1YmFycmF5KGksIGkgKyBwYXlsb2FkU2l6ZSk7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvLyBza2lwIHRoZSBwYXlsb2FkIGFuZCBwYXJzZSB0aGUgbmV4dCBtZXNzYWdlXG4gICAgaSArPSBwYXlsb2FkU2l6ZTtcbiAgICBwYXlsb2FkVHlwZSA9IDA7XG4gICAgcGF5bG9hZFNpemUgPSAwO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8vIHNlZSBBTlNJL1NDVEUgMTI4LTEgKDIwMTMpLCBzZWN0aW9uIDguMVxudmFyIHBhcnNlVXNlckRhdGEgPSBmdW5jdGlvbihzZWkpIHtcbiAgLy8gaXR1X3RfdDM1X2NvbnRyeV9jb2RlIG11c3QgYmUgMTgxIChVbml0ZWQgU3RhdGVzKSBmb3JcbiAgLy8gY2FwdGlvbnNcbiAgaWYgKHNlaS5wYXlsb2FkWzBdICE9PSAxODEpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIGl0dV90X3QzNV9wcm92aWRlcl9jb2RlIHNob3VsZCBiZSA0OSAoQVRTQykgZm9yIGNhcHRpb25zXG4gIGlmICgoKHNlaS5wYXlsb2FkWzFdIDw8IDgpIHwgc2VpLnBheWxvYWRbMl0pICE9PSA0OSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gdGhlIHVzZXJfaWRlbnRpZmllciBzaG91bGQgYmUgXCJHQTk0XCIgdG8gaW5kaWNhdGUgQVRTQzEgZGF0YVxuICBpZiAoU3RyaW5nLmZyb21DaGFyQ29kZShzZWkucGF5bG9hZFszXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgc2VpLnBheWxvYWRbNF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHNlaS5wYXlsb2FkWzVdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBzZWkucGF5bG9hZFs2XSkgIT09ICdHQTk0Jykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gZmluYWxseSwgdXNlcl9kYXRhX3R5cGVfY29kZSBzaG91bGQgYmUgMHgwMyBmb3IgY2FwdGlvbiBkYXRhXG4gIGlmIChzZWkucGF5bG9hZFs3XSAhPT0gMHgwMykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gcmV0dXJuIHRoZSB1c2VyX2RhdGFfdHlwZV9zdHJ1Y3R1cmUgYW5kIHN0cmlwIHRoZSB0cmFpbGluZ1xuICAvLyBtYXJrZXIgYml0c1xuICByZXR1cm4gc2VpLnBheWxvYWQuc3ViYXJyYXkoOCwgc2VpLnBheWxvYWQubGVuZ3RoIC0gMSk7XG59O1xuXG4vLyBzZWUgQ0VBLTcwOC1ELCBzZWN0aW9uIDQuNFxudmFyIHBhcnNlQ2FwdGlvblBhY2tldHMgPSBmdW5jdGlvbihwdHMsIHVzZXJEYXRhKSB7XG4gIHZhciByZXN1bHRzID0gW10sIGksIGNvdW50LCBvZmZzZXQsIGRhdGE7XG5cbiAgLy8gaWYgdGhpcyBpcyBqdXN0IGZpbGxlciwgcmV0dXJuIGltbWVkaWF0ZWx5XG4gIGlmICghKHVzZXJEYXRhWzBdICYgMHg0MCkpIHtcbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfVxuXG4gIC8vIHBhcnNlIG91dCB0aGUgY2NfZGF0YV8xIGFuZCBjY19kYXRhXzIgZmllbGRzXG4gIGNvdW50ID0gdXNlckRhdGFbMF0gJiAweDFmO1xuICBmb3IgKGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgIG9mZnNldCA9IGkgKiAzO1xuICAgIGRhdGEgPSB7XG4gICAgICB0eXBlOiB1c2VyRGF0YVtvZmZzZXQgKyAyXSAmIDB4MDMsXG4gICAgICBwdHM6IHB0c1xuICAgIH07XG5cbiAgICAvLyBjYXB0dXJlIGNjIGRhdGEgd2hlbiBjY192YWxpZCBpcyAxXG4gICAgaWYgKHVzZXJEYXRhW29mZnNldCArIDJdICYgMHgwNCkge1xuICAgICAgZGF0YS5jY0RhdGEgPSAodXNlckRhdGFbb2Zmc2V0ICsgM10gPDwgOCkgfCB1c2VyRGF0YVtvZmZzZXQgKyA0XTtcbiAgICAgIHJlc3VsdHMucHVzaChkYXRhKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdHM7XG59O1xuXG52YXIgQ2FwdGlvblN0cmVhbSA9IGZ1bmN0aW9uKCkge1xuXG4gIENhcHRpb25TdHJlYW0ucHJvdG90eXBlLmluaXQuY2FsbCh0aGlzKTtcblxuICB0aGlzLmNhcHRpb25QYWNrZXRzXyA9IFtdO1xuXG4gIHRoaXMuY2NTdHJlYW1zXyA9IFtcbiAgICBuZXcgQ2VhNjA4U3RyZWFtKDAsIDApLCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVzZS1iZWZvcmUtZGVmaW5lXG4gICAgbmV3IENlYTYwOFN0cmVhbSgwLCAxKSwgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11c2UtYmVmb3JlLWRlZmluZVxuICAgIG5ldyBDZWE2MDhTdHJlYW0oMSwgMCksIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdXNlLWJlZm9yZS1kZWZpbmVcbiAgICBuZXcgQ2VhNjA4U3RyZWFtKDEsIDEpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdXNlLWJlZm9yZS1kZWZpbmVcbiAgXTtcblxuICB0aGlzLnJlc2V0KCk7XG5cbiAgLy8gZm9yd2FyZCBkYXRhIGFuZCBkb25lIGV2ZW50cyBmcm9tIENDcyB0byB0aGlzIENhcHRpb25TdHJlYW1cbiAgdGhpcy5jY1N0cmVhbXNfLmZvckVhY2goZnVuY3Rpb24oY2MpIHtcbiAgICBjYy5vbignZGF0YScsIHRoaXMudHJpZ2dlci5iaW5kKHRoaXMsICdkYXRhJykpO1xuICAgIGNjLm9uKCdkb25lJywgdGhpcy50cmlnZ2VyLmJpbmQodGhpcywgJ2RvbmUnKSk7XG4gIH0sIHRoaXMpO1xuXG59O1xuXG5DYXB0aW9uU3RyZWFtLnByb3RvdHlwZSA9IG5ldyBTdHJlYW0oKTtcbkNhcHRpb25TdHJlYW0ucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbihldmVudCkge1xuICB2YXIgc2VpLCB1c2VyRGF0YTtcblxuICAvLyBvbmx5IGV4YW1pbmUgU0VJIE5BTHNcbiAgaWYgKGV2ZW50Lm5hbFVuaXRUeXBlICE9PSAnc2VpX3Jic3AnKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gcGFyc2UgdGhlIHNlaVxuICBzZWkgPSBwYXJzZVNlaShldmVudC5lc2NhcGVkUkJTUCk7XG5cbiAgLy8gaWdub3JlIGV2ZXJ5dGhpbmcgYnV0IHVzZXJfZGF0YV9yZWdpc3RlcmVkX2l0dV90X3QzNVxuICBpZiAoc2VpLnBheWxvYWRUeXBlICE9PSBVU0VSX0RBVEFfUkVHSVNURVJFRF9JVFVfVF9UMzUpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBwYXJzZSBvdXQgdGhlIHVzZXIgZGF0YSBwYXlsb2FkXG4gIHVzZXJEYXRhID0gcGFyc2VVc2VyRGF0YShzZWkpO1xuXG4gIC8vIGlnbm9yZSB1bnJlY29nbml6ZWQgdXNlckRhdGFcbiAgaWYgKCF1c2VyRGF0YSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIFNvbWV0aW1lcywgdGhlIHNhbWUgc2VnbWVudCAjIHdpbGwgYmUgZG93bmxvYWRlZCB0d2ljZS4gVG8gc3RvcCB0aGVcbiAgLy8gY2FwdGlvbiBkYXRhIGZyb20gYmVpbmcgcHJvY2Vzc2VkIHR3aWNlLCB3ZSB0cmFjayB0aGUgbGF0ZXN0IGR0cyB3ZSd2ZVxuICAvLyByZWNlaXZlZCBhbmQgaWdub3JlIGV2ZXJ5dGhpbmcgd2l0aCBhIGR0cyBiZWZvcmUgdGhhdC4gSG93ZXZlciwgc2luY2VcbiAgLy8gZGF0YSBmb3IgYSBzcGVjaWZpYyBkdHMgY2FuIGJlIHNwbGl0IGFjcm9zcyAyIHBhY2tldHMgb24gZWl0aGVyIHNpZGUgb2ZcbiAgLy8gYSBzZWdtZW50IGJvdW5kYXJ5LCB3ZSBuZWVkIHRvIG1ha2Ugc3VyZSB3ZSAqZG9uJ3QqIGlnbm9yZSB0aGUgc2Vjb25kXG4gIC8vIGR0cyBwYWNrZXQgd2UgcmVjZWl2ZSB0aGF0IGhhcyBkdHMgPT09IHRoaXMubGF0ZXN0RHRzXy4gQW5kIHRodXMsIHRoZVxuICAvLyBpZ25vcmVOZXh0RXF1YWxEdHNfIGZsYWcgd2FzIGJvcm4uXG4gIGlmIChldmVudC5kdHMgPCB0aGlzLmxhdGVzdER0c18pIHtcbiAgICAvLyBXZSd2ZSBzdGFydGVkIGdldHRpbmcgb2xkZXIgZGF0YSwgc28gc2V0IHRoZSBmbGFnLlxuICAgIHRoaXMuaWdub3JlTmV4dEVxdWFsRHRzXyA9IHRydWU7XG4gICAgcmV0dXJuO1xuICB9IGVsc2UgaWYgKChldmVudC5kdHMgPT09IHRoaXMubGF0ZXN0RHRzXykgJiYgKHRoaXMuaWdub3JlTmV4dEVxdWFsRHRzXykpIHtcbiAgICAvLyBXZSd2ZSByZWNlaXZlZCB0aGUgbGFzdCBkdXBsaWNhdGUgcGFja2V0LCB0aW1lIHRvIHN0YXJ0IHByb2Nlc3NpbmcgYWdhaW5cbiAgICB0aGlzLmlnbm9yZU5leHRFcXVhbER0c18gPSBmYWxzZTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBwYXJzZSBvdXQgQ0MgZGF0YSBwYWNrZXRzIGFuZCBzYXZlIHRoZW0gZm9yIGxhdGVyXG4gIHRoaXMuY2FwdGlvblBhY2tldHNfID0gdGhpcy5jYXB0aW9uUGFja2V0c18uY29uY2F0KHBhcnNlQ2FwdGlvblBhY2tldHMoZXZlbnQucHRzLCB1c2VyRGF0YSkpO1xuICB0aGlzLmxhdGVzdER0c18gPSBldmVudC5kdHM7XG59O1xuXG5DYXB0aW9uU3RyZWFtLnByb3RvdHlwZS5mbHVzaCA9IGZ1bmN0aW9uKCkge1xuICAvLyBtYWtlIHN1cmUgd2UgYWN0dWFsbHkgcGFyc2VkIGNhcHRpb25zIGJlZm9yZSBwcm9jZWVkaW5nXG4gIGlmICghdGhpcy5jYXB0aW9uUGFja2V0c18ubGVuZ3RoKSB7XG4gICAgdGhpcy5jY1N0cmVhbXNfLmZvckVhY2goZnVuY3Rpb24oY2MpIHtcbiAgICAgIGNjLmZsdXNoKCk7XG4gICAgfSwgdGhpcyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gSW4gQ2hyb21lLCB0aGUgQXJyYXkjc29ydCBmdW5jdGlvbiBpcyBub3Qgc3RhYmxlIHNvIGFkZCBhXG4gIC8vIHByZXNvcnRJbmRleCB0aGF0IHdlIGNhbiB1c2UgdG8gZW5zdXJlIHdlIGdldCBhIHN0YWJsZS1zb3J0XG4gIHRoaXMuY2FwdGlvblBhY2tldHNfLmZvckVhY2goZnVuY3Rpb24oZWxlbSwgaWR4KSB7XG4gICAgZWxlbS5wcmVzb3J0SW5kZXggPSBpZHg7XG4gIH0pO1xuXG4gIC8vIHNvcnQgY2FwdGlvbiBieXRlLXBhaXJzIGJhc2VkIG9uIHRoZWlyIFBUUyB2YWx1ZXNcbiAgdGhpcy5jYXB0aW9uUGFja2V0c18uc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgaWYgKGEucHRzID09PSBiLnB0cykge1xuICAgICAgcmV0dXJuIGEucHJlc29ydEluZGV4IC0gYi5wcmVzb3J0SW5kZXg7XG4gICAgfVxuICAgIHJldHVybiBhLnB0cyAtIGIucHRzO1xuICB9KTtcblxuICB0aGlzLmNhcHRpb25QYWNrZXRzXy5mb3JFYWNoKGZ1bmN0aW9uKHBhY2tldCkge1xuICAgIGlmIChwYWNrZXQudHlwZSA8IDIpIHtcbiAgICAgIC8vIERpc3BhdGNoIHBhY2tldCB0byB0aGUgcmlnaHQgQ2VhNjA4U3RyZWFtXG4gICAgICB0aGlzLmRpc3BhdGNoQ2VhNjA4UGFja2V0KHBhY2tldCk7XG4gICAgfVxuICAgIC8vIHRoaXMgaXMgd2hlcmUgYW4gJ2Vsc2UnIHdvdWxkIGdvIGZvciBhIGRpc3BhdGNoaW5nIHBhY2tldHNcbiAgICAvLyB0byBhIHRoZW9yZXRpY2FsIENlYTcwOFN0cmVhbSB0aGF0IGhhbmRsZXMgU0VSVklDRW4gZGF0YVxuICB9LCB0aGlzKTtcblxuICB0aGlzLmNhcHRpb25QYWNrZXRzXy5sZW5ndGggPSAwO1xuICB0aGlzLmNjU3RyZWFtc18uZm9yRWFjaChmdW5jdGlvbihjYykge1xuICAgIGNjLmZsdXNoKCk7XG4gIH0sIHRoaXMpO1xuICByZXR1cm47XG59O1xuXG5DYXB0aW9uU3RyZWFtLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmxhdGVzdER0c18gPSBudWxsO1xuICB0aGlzLmlnbm9yZU5leHRFcXVhbER0c18gPSBmYWxzZTtcbiAgdGhpcy5hY3RpdmVDZWE2MDhDaGFubmVsXyA9IFtudWxsLCBudWxsXTtcbiAgdGhpcy5jY1N0cmVhbXNfLmZvckVhY2goZnVuY3Rpb24oY2NTdHJlYW0pIHtcbiAgICBjY1N0cmVhbS5yZXNldCgpO1xuICB9KTtcbn07XG5cbkNhcHRpb25TdHJlYW0ucHJvdG90eXBlLmRpc3BhdGNoQ2VhNjA4UGFja2V0ID0gZnVuY3Rpb24ocGFja2V0KSB7XG4gIC8vIE5PVEU6IHBhY2tldC50eXBlIGlzIHRoZSBDRUE2MDggZmllbGRcbiAgaWYgKHRoaXMuc2V0c0NoYW5uZWwxQWN0aXZlKHBhY2tldCkpIHtcbiAgICB0aGlzLmFjdGl2ZUNlYTYwOENoYW5uZWxfW3BhY2tldC50eXBlXSA9IDA7XG4gIH0gZWxzZSBpZiAodGhpcy5zZXRzQ2hhbm5lbDJBY3RpdmUocGFja2V0KSkge1xuICAgIHRoaXMuYWN0aXZlQ2VhNjA4Q2hhbm5lbF9bcGFja2V0LnR5cGVdID0gMTtcbiAgfVxuICBpZiAodGhpcy5hY3RpdmVDZWE2MDhDaGFubmVsX1twYWNrZXQudHlwZV0gPT09IG51bGwpIHtcbiAgICAvLyBJZiB3ZSBoYXZlbid0IHJlY2VpdmVkIGFueXRoaW5nIHRvIHNldCB0aGUgYWN0aXZlIGNoYW5uZWwsIGRpc2NhcmQgdGhlXG4gICAgLy8gZGF0YTsgd2UgZG9uJ3Qgd2FudCBqdW1ibGVkIGNhcHRpb25zXG4gICAgcmV0dXJuO1xuICB9XG4gIHRoaXMuY2NTdHJlYW1zX1socGFja2V0LnR5cGUgPDwgMSkgKyB0aGlzLmFjdGl2ZUNlYTYwOENoYW5uZWxfW3BhY2tldC50eXBlXV0ucHVzaChwYWNrZXQpO1xufTtcblxuQ2FwdGlvblN0cmVhbS5wcm90b3R5cGUuc2V0c0NoYW5uZWwxQWN0aXZlID0gZnVuY3Rpb24ocGFja2V0KSB7XG4gIHJldHVybiAoKHBhY2tldC5jY0RhdGEgJiAweDc4MDApID09PSAweDEwMDApO1xufTtcbkNhcHRpb25TdHJlYW0ucHJvdG90eXBlLnNldHNDaGFubmVsMkFjdGl2ZSA9IGZ1bmN0aW9uKHBhY2tldCkge1xuICByZXR1cm4gKChwYWNrZXQuY2NEYXRhICYgMHg3ODAwKSA9PT0gMHgxODAwKTtcbn07XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFNlc3Npb24gdG8gQXBwbGljYXRpb25cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxudmFyIENIQVJBQ1RFUl9UUkFOU0xBVElPTiA9IHtcbiAgMHgyYTogMHhlMSwgICAgIC8vIMOhXG4gIDB4NWM6IDB4ZTksICAgICAvLyDDqVxuICAweDVlOiAweGVkLCAgICAgLy8gw61cbiAgMHg1ZjogMHhmMywgICAgIC8vIMOzXG4gIDB4NjA6IDB4ZmEsICAgICAvLyDDulxuICAweDdiOiAweGU3LCAgICAgLy8gw6dcbiAgMHg3YzogMHhmNywgICAgIC8vIMO3XG4gIDB4N2Q6IDB4ZDEsICAgICAvLyDDkVxuICAweDdlOiAweGYxLCAgICAgLy8gw7FcbiAgMHg3ZjogMHgyNTg4LCAgIC8vIOKWiFxuICAweDAxMzA6IDB4YWUsICAgLy8gwq5cbiAgMHgwMTMxOiAweGIwLCAgIC8vIMKwXG4gIDB4MDEzMjogMHhiZCwgICAvLyDCvVxuICAweDAxMzM6IDB4YmYsICAgLy8gwr9cbiAgMHgwMTM0OiAweDIxMjIsIC8vIOKEolxuICAweDAxMzU6IDB4YTIsICAgLy8gwqJcbiAgMHgwMTM2OiAweGEzLCAgIC8vIMKjXG4gIDB4MDEzNzogMHgyNjZhLCAvLyDimapcbiAgMHgwMTM4OiAweGUwLCAgIC8vIMOgXG4gIDB4MDEzOTogMHhhMCwgICAvL1xuICAweDAxM2E6IDB4ZTgsICAgLy8gw6hcbiAgMHgwMTNiOiAweGUyLCAgIC8vIMOiXG4gIDB4MDEzYzogMHhlYSwgICAvLyDDqlxuICAweDAxM2Q6IDB4ZWUsICAgLy8gw65cbiAgMHgwMTNlOiAweGY0LCAgIC8vIMO0XG4gIDB4MDEzZjogMHhmYiwgICAvLyDDu1xuICAweDAyMjA6IDB4YzEsICAgLy8gw4FcbiAgMHgwMjIxOiAweGM5LCAgIC8vIMOJXG4gIDB4MDIyMjogMHhkMywgICAvLyDDk1xuICAweDAyMjM6IDB4ZGEsICAgLy8gw5pcbiAgMHgwMjI0OiAweGRjLCAgIC8vIMOcXG4gIDB4MDIyNTogMHhmYywgICAvLyDDvFxuICAweDAyMjY6IDB4MjAxOCwgLy8g4oCYXG4gIDB4MDIyNzogMHhhMSwgICAvLyDCoVxuICAweDAyMjg6IDB4MmEsICAgLy8gKlxuICAweDAyMjk6IDB4MjcsICAgLy8gJ1xuICAweDAyMmE6IDB4MjAxNCwgLy8g4oCUXG4gIDB4MDIyYjogMHhhOSwgICAvLyDCqVxuICAweDAyMmM6IDB4MjEyMCwgLy8g4oSgXG4gIDB4MDIyZDogMHgyMDIyLCAvLyDigKJcbiAgMHgwMjJlOiAweDIwMWMsIC8vIOKAnFxuICAweDAyMmY6IDB4MjAxZCwgLy8g4oCdXG4gIDB4MDIzMDogMHhjMCwgICAvLyDDgFxuICAweDAyMzE6IDB4YzIsICAgLy8gw4JcbiAgMHgwMjMyOiAweGM3LCAgIC8vIMOHXG4gIDB4MDIzMzogMHhjOCwgICAvLyDDiFxuICAweDAyMzQ6IDB4Y2EsICAgLy8gw4pcbiAgMHgwMjM1OiAweGNiLCAgIC8vIMOLXG4gIDB4MDIzNjogMHhlYiwgICAvLyDDq1xuICAweDAyMzc6IDB4Y2UsICAgLy8gw45cbiAgMHgwMjM4OiAweGNmLCAgIC8vIMOPXG4gIDB4MDIzOTogMHhlZiwgICAvLyDDr1xuICAweDAyM2E6IDB4ZDQsICAgLy8gw5RcbiAgMHgwMjNiOiAweGQ5LCAgIC8vIMOZXG4gIDB4MDIzYzogMHhmOSwgICAvLyDDuVxuICAweDAyM2Q6IDB4ZGIsICAgLy8gw5tcbiAgMHgwMjNlOiAweGFiLCAgIC8vIMKrXG4gIDB4MDIzZjogMHhiYiwgICAvLyDCu1xuICAweDAzMjA6IDB4YzMsICAgLy8gw4NcbiAgMHgwMzIxOiAweGUzLCAgIC8vIMOjXG4gIDB4MDMyMjogMHhjZCwgICAvLyDDjVxuICAweDAzMjM6IDB4Y2MsICAgLy8gw4xcbiAgMHgwMzI0OiAweGVjLCAgIC8vIMOsXG4gIDB4MDMyNTogMHhkMiwgICAvLyDDklxuICAweDAzMjY6IDB4ZjIsICAgLy8gw7JcbiAgMHgwMzI3OiAweGQ1LCAgIC8vIMOVXG4gIDB4MDMyODogMHhmNSwgICAvLyDDtVxuICAweDAzMjk6IDB4N2IsICAgLy8ge1xuICAweDAzMmE6IDB4N2QsICAgLy8gfVxuICAweDAzMmI6IDB4NWMsICAgLy8gXFxcbiAgMHgwMzJjOiAweDVlLCAgIC8vIF5cbiAgMHgwMzJkOiAweDVmLCAgIC8vIF9cbiAgMHgwMzJlOiAweDdjLCAgIC8vIHxcbiAgMHgwMzJmOiAweDdlLCAgIC8vIH5cbiAgMHgwMzMwOiAweGM0LCAgIC8vIMOEXG4gIDB4MDMzMTogMHhlNCwgICAvLyDDpFxuICAweDAzMzI6IDB4ZDYsICAgLy8gw5ZcbiAgMHgwMzMzOiAweGY2LCAgIC8vIMO2XG4gIDB4MDMzNDogMHhkZiwgICAvLyDDn1xuICAweDAzMzU6IDB4YTUsICAgLy8gwqVcbiAgMHgwMzM2OiAweGE0LCAgIC8vIMKkXG4gIDB4MDMzNzogMHgyNTAyLCAvLyDilIJcbiAgMHgwMzM4OiAweGM1LCAgIC8vIMOFXG4gIDB4MDMzOTogMHhlNSwgICAvLyDDpVxuICAweDAzM2E6IDB4ZDgsICAgLy8gw5hcbiAgMHgwMzNiOiAweGY4LCAgIC8vIMO4XG4gIDB4MDMzYzogMHgyNTBjLCAvLyDilIxcbiAgMHgwMzNkOiAweDI1MTAsIC8vIOKUkFxuICAweDAzM2U6IDB4MjUxNCwgLy8g4pSUXG4gIDB4MDMzZjogMHgyNTE4ICAvLyDilJhcbn07XG5cbnZhciBnZXRDaGFyRnJvbUNvZGUgPSBmdW5jdGlvbihjb2RlKSB7XG4gIGlmIChjb2RlID09PSBudWxsKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG4gIGNvZGUgPSBDSEFSQUNURVJfVFJBTlNMQVRJT05bY29kZV0gfHwgY29kZTtcbiAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSk7XG59O1xuXG4vLyB0aGUgaW5kZXggb2YgdGhlIGxhc3Qgcm93IGluIGEgQ0VBLTYwOCBkaXNwbGF5IGJ1ZmZlclxudmFyIEJPVFRPTV9ST1cgPSAxNDtcblxuLy8gVGhpcyBhcnJheSBpcyB1c2VkIGZvciBtYXBwaW5nIFBBQ3MgLT4gcm93ICMsIHNpbmNlIHRoZXJlJ3Mgbm8gd2F5IG9mXG4vLyBnZXR0aW5nIGl0IHRocm91Z2ggYml0IGxvZ2ljLlxudmFyIFJPV1MgPSBbMHgxMTAwLCAweDExMjAsIDB4MTIwMCwgMHgxMjIwLCAweDE1MDAsIDB4MTUyMCwgMHgxNjAwLCAweDE2MjAsXG4gICAgICAgICAgICAweDE3MDAsIDB4MTcyMCwgMHgxMDAwLCAweDEzMDAsIDB4MTMyMCwgMHgxNDAwLCAweDE0MjBdO1xuXG4vLyBDRUEtNjA4IGNhcHRpb25zIGFyZSByZW5kZXJlZCBvbnRvIGEgMzR4MTUgbWF0cml4IG9mIGNoYXJhY3RlclxuLy8gY2VsbHMuIFRoZSBcImJvdHRvbVwiIHJvdyBpcyB0aGUgbGFzdCBlbGVtZW50IGluIHRoZSBvdXRlciBhcnJheS5cbnZhciBjcmVhdGVEaXNwbGF5QnVmZmVyID0gZnVuY3Rpb24oKSB7XG4gIHZhciByZXN1bHQgPSBbXSwgaSA9IEJPVFRPTV9ST1cgKyAxO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgcmVzdWx0LnB1c2goJycpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG52YXIgQ2VhNjA4U3RyZWFtID0gZnVuY3Rpb24oZmllbGQsIGRhdGFDaGFubmVsKSB7XG4gIENlYTYwOFN0cmVhbS5wcm90b3R5cGUuaW5pdC5jYWxsKHRoaXMpO1xuXG4gIHRoaXMuZmllbGRfID0gZmllbGQgfHwgMDtcbiAgdGhpcy5kYXRhQ2hhbm5lbF8gPSBkYXRhQ2hhbm5lbCB8fCAwO1xuXG4gIHRoaXMubmFtZV8gPSAnQ0MnICsgKCgodGhpcy5maWVsZF8gPDwgMSkgfCB0aGlzLmRhdGFDaGFubmVsXykgKyAxKTtcblxuICB0aGlzLnNldENvbnN0YW50cygpO1xuICB0aGlzLnJlc2V0KCk7XG5cbiAgdGhpcy5wdXNoID0gZnVuY3Rpb24ocGFja2V0KSB7XG4gICAgdmFyIGRhdGEsIHN3YXAsIGNoYXIwLCBjaGFyMSwgdGV4dDtcbiAgICAvLyByZW1vdmUgdGhlIHBhcml0eSBiaXRzXG4gICAgZGF0YSA9IHBhY2tldC5jY0RhdGEgJiAweDdmN2Y7XG5cbiAgICAvLyBpZ25vcmUgZHVwbGljYXRlIGNvbnRyb2wgY29kZXM7IHRoZSBzcGVjIGRlbWFuZHMgdGhleSdyZSBzZW50IHR3aWNlXG4gICAgaWYgKGRhdGEgPT09IHRoaXMubGFzdENvbnRyb2xDb2RlXykge1xuICAgICAgdGhpcy5sYXN0Q29udHJvbENvZGVfID0gbnVsbDtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBTdG9yZSBjb250cm9sIGNvZGVzXG4gICAgaWYgKChkYXRhICYgMHhmMDAwKSA9PT0gMHgxMDAwKSB7XG4gICAgICB0aGlzLmxhc3RDb250cm9sQ29kZV8gPSBkYXRhO1xuICAgIH0gZWxzZSBpZiAoZGF0YSAhPT0gdGhpcy5QQURESU5HXykge1xuICAgICAgdGhpcy5sYXN0Q29udHJvbENvZGVfID0gbnVsbDtcbiAgICB9XG5cbiAgICBjaGFyMCA9IGRhdGEgPj4+IDg7XG4gICAgY2hhcjEgPSBkYXRhICYgMHhmZjtcblxuICAgIGlmIChkYXRhID09PSB0aGlzLlBBRERJTkdfKSB7XG4gICAgICByZXR1cm47XG5cbiAgICB9IGVsc2UgaWYgKGRhdGEgPT09IHRoaXMuUkVTVU1FX0NBUFRJT05fTE9BRElOR18pIHtcbiAgICAgIHRoaXMubW9kZV8gPSAncG9wT24nO1xuXG4gICAgfSBlbHNlIGlmIChkYXRhID09PSB0aGlzLkVORF9PRl9DQVBUSU9OXykge1xuICAgICAgdGhpcy5jbGVhckZvcm1hdHRpbmcocGFja2V0LnB0cyk7XG4gICAgICAvLyBpZiBhIGNhcHRpb24gd2FzIGJlaW5nIGRpc3BsYXllZCwgaXQncyBnb25lIG5vd1xuICAgICAgdGhpcy5mbHVzaERpc3BsYXllZChwYWNrZXQucHRzKTtcblxuICAgICAgLy8gZmxpcCBtZW1vcnlcbiAgICAgIHN3YXAgPSB0aGlzLmRpc3BsYXllZF87XG4gICAgICB0aGlzLmRpc3BsYXllZF8gPSB0aGlzLm5vbkRpc3BsYXllZF87XG4gICAgICB0aGlzLm5vbkRpc3BsYXllZF8gPSBzd2FwO1xuXG4gICAgICAvLyBzdGFydCBtZWFzdXJpbmcgdGhlIHRpbWUgdG8gZGlzcGxheSB0aGUgY2FwdGlvblxuICAgICAgdGhpcy5zdGFydFB0c18gPSBwYWNrZXQucHRzO1xuXG4gICAgfSBlbHNlIGlmIChkYXRhID09PSB0aGlzLlJPTExfVVBfMl9ST1dTXykge1xuICAgICAgdGhpcy50b3BSb3dfID0gQk9UVE9NX1JPVyAtIDE7XG4gICAgICB0aGlzLm1vZGVfID0gJ3JvbGxVcCc7XG4gICAgfSBlbHNlIGlmIChkYXRhID09PSB0aGlzLlJPTExfVVBfM19ST1dTXykge1xuICAgICAgdGhpcy50b3BSb3dfID0gQk9UVE9NX1JPVyAtIDI7XG4gICAgICB0aGlzLm1vZGVfID0gJ3JvbGxVcCc7XG4gICAgfSBlbHNlIGlmIChkYXRhID09PSB0aGlzLlJPTExfVVBfNF9ST1dTXykge1xuICAgICAgdGhpcy50b3BSb3dfID0gQk9UVE9NX1JPVyAtIDM7XG4gICAgICB0aGlzLm1vZGVfID0gJ3JvbGxVcCc7XG4gICAgfSBlbHNlIGlmIChkYXRhID09PSB0aGlzLkNBUlJJQUdFX1JFVFVSTl8pIHtcbiAgICAgIHRoaXMuY2xlYXJGb3JtYXR0aW5nKHBhY2tldC5wdHMpO1xuICAgICAgdGhpcy5mbHVzaERpc3BsYXllZChwYWNrZXQucHRzKTtcbiAgICAgIHRoaXMuc2hpZnRSb3dzVXBfKCk7XG4gICAgICB0aGlzLnN0YXJ0UHRzXyA9IHBhY2tldC5wdHM7XG5cbiAgICB9IGVsc2UgaWYgKGRhdGEgPT09IHRoaXMuQkFDS1NQQUNFXykge1xuICAgICAgaWYgKHRoaXMubW9kZV8gPT09ICdwb3BPbicpIHtcbiAgICAgICAgdGhpcy5ub25EaXNwbGF5ZWRfW0JPVFRPTV9ST1ddID0gdGhpcy5ub25EaXNwbGF5ZWRfW0JPVFRPTV9ST1ddLnNsaWNlKDAsIC0xKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZGlzcGxheWVkX1tCT1RUT01fUk9XXSA9IHRoaXMuZGlzcGxheWVkX1tCT1RUT01fUk9XXS5zbGljZSgwLCAtMSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChkYXRhID09PSB0aGlzLkVSQVNFX0RJU1BMQVlFRF9NRU1PUllfKSB7XG4gICAgICB0aGlzLmZsdXNoRGlzcGxheWVkKHBhY2tldC5wdHMpO1xuICAgICAgdGhpcy5kaXNwbGF5ZWRfID0gY3JlYXRlRGlzcGxheUJ1ZmZlcigpO1xuICAgIH0gZWxzZSBpZiAoZGF0YSA9PT0gdGhpcy5FUkFTRV9OT05fRElTUExBWUVEX01FTU9SWV8pIHtcbiAgICAgIHRoaXMubm9uRGlzcGxheWVkXyA9IGNyZWF0ZURpc3BsYXlCdWZmZXIoKTtcblxuICAgIH0gZWxzZSBpZiAoZGF0YSA9PT0gdGhpcy5SRVNVTUVfRElSRUNUX0NBUFRJT05JTkdfKSB7XG4gICAgICB0aGlzLm1vZGVfID0gJ3BhaW50T24nO1xuXG4gICAgLy8gQXBwZW5kIHNwZWNpYWwgY2hhcmFjdGVycyB0byBjYXB0aW9uIHRleHRcbiAgICB9IGVsc2UgaWYgKHRoaXMuaXNTcGVjaWFsQ2hhcmFjdGVyKGNoYXIwLCBjaGFyMSkpIHtcbiAgICAgIC8vIEJpdG1hc2sgY2hhcjAgc28gdGhhdCB3ZSBjYW4gYXBwbHkgY2hhcmFjdGVyIHRyYW5zZm9ybWF0aW9uc1xuICAgICAgLy8gcmVnYXJkbGVzcyBvZiBmaWVsZCBhbmQgZGF0YSBjaGFubmVsLlxuICAgICAgLy8gVGhlbiBieXRlLXNoaWZ0IHRvIHRoZSBsZWZ0IGFuZCBPUiB3aXRoIGNoYXIxIHNvIHdlIGNhbiBwYXNzIHRoZVxuICAgICAgLy8gZW50aXJlIGNoYXJhY3RlciBjb2RlIHRvIGBnZXRDaGFyRnJvbUNvZGVgLlxuICAgICAgY2hhcjAgPSAoY2hhcjAgJiAweDAzKSA8PCA4O1xuICAgICAgdGV4dCA9IGdldENoYXJGcm9tQ29kZShjaGFyMCB8IGNoYXIxKTtcbiAgICAgIHRoaXNbdGhpcy5tb2RlX10ocGFja2V0LnB0cywgdGV4dCk7XG4gICAgICB0aGlzLmNvbHVtbl8rKztcblxuICAgIC8vIEFwcGVuZCBleHRlbmRlZCBjaGFyYWN0ZXJzIHRvIGNhcHRpb24gdGV4dFxuICAgIH0gZWxzZSBpZiAodGhpcy5pc0V4dENoYXJhY3RlcihjaGFyMCwgY2hhcjEpKSB7XG4gICAgICAvLyBFeHRlbmRlZCBjaGFyYWN0ZXJzIGFsd2F5cyBmb2xsb3cgdGhlaXIgXCJub24tZXh0ZW5kZWRcIiBlcXVpdmFsZW50cy5cbiAgICAgIC8vIElFIGlmIGEgXCLDqFwiIGlzIGRlc2lyZWQsIHlvdSdsbCBhbHdheXMgcmVjZWl2ZSBcImXDqFwiOyBub24tY29tcGxpYW50XG4gICAgICAvLyBkZWNvZGVycyBhcmUgc3VwcG9zZWQgdG8gZHJvcCB0aGUgXCLDqFwiLCB3aGlsZSBjb21wbGlhbnQgZGVjb2RlcnNcbiAgICAgIC8vIGJhY2tzcGFjZSB0aGUgXCJlXCIgYW5kIGluc2VydCBcIsOoXCIuXG5cbiAgICAgIC8vIERlbGV0ZSB0aGUgcHJldmlvdXMgY2hhcmFjdGVyXG4gICAgICBpZiAodGhpcy5tb2RlXyA9PT0gJ3BvcE9uJykge1xuICAgICAgICB0aGlzLm5vbkRpc3BsYXllZF9bdGhpcy5yb3dfXSA9IHRoaXMubm9uRGlzcGxheWVkX1t0aGlzLnJvd19dLnNsaWNlKDAsIC0xKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZGlzcGxheWVkX1tCT1RUT01fUk9XXSA9IHRoaXMuZGlzcGxheWVkX1tCT1RUT01fUk9XXS5zbGljZSgwLCAtMSk7XG4gICAgICB9XG5cbiAgICAgIC8vIEJpdG1hc2sgY2hhcjAgc28gdGhhdCB3ZSBjYW4gYXBwbHkgY2hhcmFjdGVyIHRyYW5zZm9ybWF0aW9uc1xuICAgICAgLy8gcmVnYXJkbGVzcyBvZiBmaWVsZCBhbmQgZGF0YSBjaGFubmVsLlxuICAgICAgLy8gVGhlbiBieXRlLXNoaWZ0IHRvIHRoZSBsZWZ0IGFuZCBPUiB3aXRoIGNoYXIxIHNvIHdlIGNhbiBwYXNzIHRoZVxuICAgICAgLy8gZW50aXJlIGNoYXJhY3RlciBjb2RlIHRvIGBnZXRDaGFyRnJvbUNvZGVgLlxuICAgICAgY2hhcjAgPSAoY2hhcjAgJiAweDAzKSA8PCA4O1xuICAgICAgdGV4dCA9IGdldENoYXJGcm9tQ29kZShjaGFyMCB8IGNoYXIxKTtcbiAgICAgIHRoaXNbdGhpcy5tb2RlX10ocGFja2V0LnB0cywgdGV4dCk7XG4gICAgICB0aGlzLmNvbHVtbl8rKztcblxuICAgIC8vIFByb2Nlc3MgbWlkLXJvdyBjb2Rlc1xuICAgIH0gZWxzZSBpZiAodGhpcy5pc01pZFJvd0NvZGUoY2hhcjAsIGNoYXIxKSkge1xuICAgICAgLy8gQXR0cmlidXRlcyBhcmUgbm90IGFkZGl0aXZlLCBzbyBjbGVhciBhbGwgZm9ybWF0dGluZ1xuICAgICAgdGhpcy5jbGVhckZvcm1hdHRpbmcocGFja2V0LnB0cyk7XG5cbiAgICAgIC8vIEFjY29yZGluZyB0byB0aGUgc3RhbmRhcmQsIG1pZC1yb3cgY29kZXNcbiAgICAgIC8vIHNob3VsZCBiZSByZXBsYWNlZCB3aXRoIHNwYWNlcywgc28gYWRkIG9uZSBub3dcbiAgICAgIHRoaXNbdGhpcy5tb2RlX10ocGFja2V0LnB0cywgJyAnKTtcbiAgICAgIHRoaXMuY29sdW1uXysrO1xuXG4gICAgICBpZiAoKGNoYXIxICYgMHhlKSA9PT0gMHhlKSB7XG4gICAgICAgIHRoaXMuYWRkRm9ybWF0dGluZyhwYWNrZXQucHRzLCBbJ2knXSk7XG4gICAgICB9XG5cbiAgICAgIGlmICgoY2hhcjEgJiAweDEpID09PSAweDEpIHtcbiAgICAgICAgdGhpcy5hZGRGb3JtYXR0aW5nKHBhY2tldC5wdHMsIFsndSddKTtcbiAgICAgIH1cblxuICAgIC8vIERldGVjdCBvZmZzZXQgY29udHJvbCBjb2RlcyBhbmQgYWRqdXN0IGN1cnNvclxuICAgIH0gZWxzZSBpZiAodGhpcy5pc09mZnNldENvbnRyb2xDb2RlKGNoYXIwLCBjaGFyMSkpIHtcbiAgICAgIC8vIEN1cnNvciBwb3NpdGlvbiBpcyBzZXQgYnkgaW5kZW50IFBBQyAoc2VlIGJlbG93KSBpbiA0LWNvbHVtblxuICAgICAgLy8gaW5jcmVtZW50cywgd2l0aCBhbiBhZGRpdGlvbmFsIG9mZnNldCBjb2RlIG9mIDEtMyB0byByZWFjaCBhbnlcbiAgICAgIC8vIG9mIHRoZSAzMiBjb2x1bW5zIHNwZWNpZmllZCBieSBDRUEtNjA4LiBTbyBhbGwgd2UgbmVlZCB0byBkb1xuICAgICAgLy8gaGVyZSBpcyBpbmNyZW1lbnQgdGhlIGNvbHVtbiBjdXJzb3IgYnkgdGhlIGdpdmVuIG9mZnNldC5cbiAgICAgIHRoaXMuY29sdW1uXyArPSAoY2hhcjEgJiAweDAzKTtcblxuICAgIC8vIERldGVjdCBQQUNzIChQcmVhbWJsZSBBZGRyZXNzIENvZGVzKVxuICAgIH0gZWxzZSBpZiAodGhpcy5pc1BBQyhjaGFyMCwgY2hhcjEpKSB7XG5cbiAgICAgIC8vIFRoZXJlJ3Mgbm8gbG9naWMgZm9yIFBBQyAtPiByb3cgbWFwcGluZywgc28gd2UgaGF2ZSB0byBqdXN0XG4gICAgICAvLyBmaW5kIHRoZSByb3cgY29kZSBpbiBhbiBhcnJheSBhbmQgdXNlIGl0cyBpbmRleCA6KFxuICAgICAgdmFyIHJvdyA9IFJPV1MuaW5kZXhPZihkYXRhICYgMHgxZjIwKTtcblxuICAgICAgaWYgKHJvdyAhPT0gdGhpcy5yb3dfKSB7XG4gICAgICAgIC8vIGZvcm1hdHRpbmcgaXMgb25seSBwZXJzaXN0ZW50IGZvciBjdXJyZW50IHJvd1xuICAgICAgICB0aGlzLmNsZWFyRm9ybWF0dGluZyhwYWNrZXQucHRzKTtcbiAgICAgICAgdGhpcy5yb3dfID0gcm93O1xuICAgICAgfVxuICAgICAgLy8gQWxsIFBBQ3MgY2FuIGFwcGx5IHVuZGVybGluZSwgc28gZGV0ZWN0IGFuZCBhcHBseVxuICAgICAgLy8gKEFsbCBvZGQtbnVtYmVyZWQgc2Vjb25kIGJ5dGVzIHNldCB1bmRlcmxpbmUpXG4gICAgICBpZiAoKGNoYXIxICYgMHgxKSAmJiAodGhpcy5mb3JtYXR0aW5nXy5pbmRleE9mKCd1JykgPT09IC0xKSkge1xuICAgICAgICAgIHRoaXMuYWRkRm9ybWF0dGluZyhwYWNrZXQucHRzLCBbJ3UnXSk7XG4gICAgICB9XG5cbiAgICAgIGlmICgoZGF0YSAmIDB4MTApID09PSAweDEwKSB7XG4gICAgICAgIC8vIFdlJ3ZlIGdvdCBhbiBpbmRlbnQgbGV2ZWwgY29kZS4gRWFjaCBzdWNjZXNzaXZlIGV2ZW4gbnVtYmVyXG4gICAgICAgIC8vIGluY3JlbWVudHMgdGhlIGNvbHVtbiBjdXJzb3IgYnkgNCwgc28gd2UgY2FuIGdldCB0aGUgZGVzaXJlZFxuICAgICAgICAvLyBjb2x1bW4gcG9zaXRpb24gYnkgYml0LXNoaWZ0aW5nIHRvIHRoZSByaWdodCAodG8gZ2V0IG4vMilcbiAgICAgICAgLy8gYW5kIG11bHRpcGx5aW5nIGJ5IDQuXG4gICAgICAgIHRoaXMuY29sdW1uXyA9ICgoZGF0YSAmIDB4ZSkgPj4gMSkgKiA0O1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5pc0NvbG9yUEFDKGNoYXIxKSkge1xuICAgICAgICAvLyBpdCdzIGEgY29sb3IgY29kZSwgdGhvdWdoIHdlIG9ubHkgc3VwcG9ydCB3aGl0ZSwgd2hpY2hcbiAgICAgICAgLy8gY2FuIGJlIGVpdGhlciBub3JtYWwgb3IgaXRhbGljaXplZC4gd2hpdGUgaXRhbGljcyBjYW4gYmVcbiAgICAgICAgLy8gZWl0aGVyIDB4NGUgb3IgMHg2ZSBkZXBlbmRpbmcgb24gdGhlIHJvdywgc28gd2UganVzdFxuICAgICAgICAvLyBiaXR3aXNlLWFuZCB3aXRoIDB4ZSB0byBzZWUgaWYgaXRhbGljcyBzaG91bGQgYmUgdHVybmVkIG9uXG4gICAgICAgIGlmICgoY2hhcjEgJiAweGUpID09PSAweGUpIHtcbiAgICAgICAgICB0aGlzLmFkZEZvcm1hdHRpbmcocGFja2V0LnB0cywgWydpJ10pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAvLyBXZSBoYXZlIGEgbm9ybWFsIGNoYXJhY3RlciBpbiBjaGFyMCwgYW5kIHBvc3NpYmx5IG9uZSBpbiBjaGFyMVxuICAgIH0gZWxzZSBpZiAodGhpcy5pc05vcm1hbENoYXIoY2hhcjApKSB7XG4gICAgICBpZiAoY2hhcjEgPT09IDB4MDApIHtcbiAgICAgICAgY2hhcjEgPSBudWxsO1xuICAgICAgfVxuICAgICAgdGV4dCA9IGdldENoYXJGcm9tQ29kZShjaGFyMCk7XG4gICAgICB0ZXh0ICs9IGdldENoYXJGcm9tQ29kZShjaGFyMSk7XG4gICAgICB0aGlzW3RoaXMubW9kZV9dKHBhY2tldC5wdHMsIHRleHQpO1xuICAgICAgdGhpcy5jb2x1bW5fICs9IHRleHQubGVuZ3RoO1xuXG4gICAgfSAvLyBmaW5pc2ggZGF0YSBwcm9jZXNzaW5nXG5cbiAgfTtcbn07XG5DZWE2MDhTdHJlYW0ucHJvdG90eXBlID0gbmV3IFN0cmVhbSgpO1xuLy8gVHJpZ2dlciBhIGN1ZSBwb2ludCB0aGF0IGNhcHR1cmVzIHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZVxuLy8gZGlzcGxheSBidWZmZXJcbkNlYTYwOFN0cmVhbS5wcm90b3R5cGUuZmx1c2hEaXNwbGF5ZWQgPSBmdW5jdGlvbihwdHMpIHtcbiAgdmFyIGNvbnRlbnQgPSB0aGlzLmRpc3BsYXllZF9cbiAgICAvLyByZW1vdmUgc3BhY2VzIGZyb20gdGhlIHN0YXJ0IGFuZCBlbmQgb2YgdGhlIHN0cmluZ1xuICAgIC5tYXAoZnVuY3Rpb24ocm93KSB7XG4gICAgICByZXR1cm4gcm93LnRyaW0oKTtcbiAgICB9KVxuICAgIC8vIGNvbWJpbmUgYWxsIHRleHQgcm93cyB0byBkaXNwbGF5IGluIG9uZSBjdWVcbiAgICAuam9pbignXFxuJylcbiAgICAvLyBhbmQgcmVtb3ZlIGJsYW5rIHJvd3MgZnJvbSB0aGUgc3RhcnQgYW5kIGVuZCwgYnV0IG5vdCB0aGUgbWlkZGxlXG4gICAgLnJlcGxhY2UoL15cXG4rfFxcbiskL2csICcnKTtcblxuICBpZiAoY29udGVudC5sZW5ndGgpIHtcbiAgICB0aGlzLnRyaWdnZXIoJ2RhdGEnLCB7XG4gICAgICBzdGFydFB0czogdGhpcy5zdGFydFB0c18sXG4gICAgICBlbmRQdHM6IHB0cyxcbiAgICAgIHRleHQ6IGNvbnRlbnQsXG4gICAgICBzdHJlYW06IHRoaXMubmFtZV9cbiAgICB9KTtcbiAgfVxufTtcblxuLyoqXG4gKiBaZXJvIG91dCB0aGUgZGF0YSwgdXNlZCBmb3Igc3RhcnR1cCBhbmQgb24gc2Vla1xuICovXG5DZWE2MDhTdHJlYW0ucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMubW9kZV8gPSAncG9wT24nO1xuICAvLyBXaGVuIGluIHJvbGwtdXAgbW9kZSwgdGhlIGluZGV4IG9mIHRoZSBsYXN0IHJvdyB0aGF0IHdpbGxcbiAgLy8gYWN0dWFsbHkgZGlzcGxheSBjYXB0aW9ucy4gSWYgYSBjYXB0aW9uIGlzIHNoaWZ0ZWQgdG8gYSByb3dcbiAgLy8gd2l0aCBhIGxvd2VyIGluZGV4IHRoYW4gdGhpcywgaXQgaXMgY2xlYXJlZCBmcm9tIHRoZSBkaXNwbGF5XG4gIC8vIGJ1ZmZlclxuICB0aGlzLnRvcFJvd18gPSAwO1xuICB0aGlzLnN0YXJ0UHRzXyA9IDA7XG4gIHRoaXMuZGlzcGxheWVkXyA9IGNyZWF0ZURpc3BsYXlCdWZmZXIoKTtcbiAgdGhpcy5ub25EaXNwbGF5ZWRfID0gY3JlYXRlRGlzcGxheUJ1ZmZlcigpO1xuICB0aGlzLmxhc3RDb250cm9sQ29kZV8gPSBudWxsO1xuXG4gIC8vIFRyYWNrIHJvdyBhbmQgY29sdW1uIGZvciBwcm9wZXIgbGluZS1icmVha2luZyBhbmQgc3BhY2luZ1xuICB0aGlzLmNvbHVtbl8gPSAwO1xuICB0aGlzLnJvd18gPSBCT1RUT01fUk9XO1xuXG4gIC8vIFRoaXMgdmFyaWFibGUgaG9sZHMgY3VycmVudGx5LWFwcGxpZWQgZm9ybWF0dGluZ1xuICB0aGlzLmZvcm1hdHRpbmdfID0gW107XG59O1xuXG4vKipcbiAqIFNldHMgdXAgY29udHJvbCBjb2RlIGFuZCByZWxhdGVkIGNvbnN0YW50cyBmb3IgdGhpcyBpbnN0YW5jZVxuICovXG5DZWE2MDhTdHJlYW0ucHJvdG90eXBlLnNldENvbnN0YW50cyA9IGZ1bmN0aW9uKCkge1xuICAvLyBUaGUgZm9sbG93aW5nIGF0dHJpYnV0ZXMgaGF2ZSB0aGVzZSB1c2VzOlxuICAvLyBleHRfIDogICAgY2hhcjAgZm9yIG1pZC1yb3cgY29kZXMsIGFuZCB0aGUgYmFzZSBmb3IgZXh0ZW5kZWRcbiAgLy8gICAgICAgICAgIGNoYXJzIChleHRfKzAsIGV4dF8rMSwgYW5kIGV4dF8rMiBhcmUgY2hhcjBzIGZvclxuICAvLyAgICAgICAgICAgZXh0ZW5kZWQgY29kZXMpXG4gIC8vIGNvbnRyb2xfOiBjaGFyMCBmb3IgY29udHJvbCBjb2RlcywgZXhjZXB0IGJ5dGUtc2hpZnRlZCB0byB0aGVcbiAgLy8gICAgICAgICAgIGxlZnQgc28gdGhhdCB3ZSBjYW4gZG8gdGhpcy5jb250cm9sXyB8IENPTlRST0xfQ09ERVxuICAvLyBvZmZzZXRfOiAgY2hhcjAgZm9yIHRhYiBvZmZzZXQgY29kZXNcbiAgLy9cbiAgLy8gSXQncyBhbHNvIHdvcnRoIG5vdGluZyB0aGF0IGNvbnRyb2wgY29kZXMsIGFuZCBfb25seV8gY29udHJvbCBjb2RlcyxcbiAgLy8gZGlmZmVyIGJldHdlZW4gZmllbGQgMSBhbmQgZmllbGQyLiBGaWVsZCAyIGNvbnRyb2wgY29kZXMgYXJlIGFsd2F5c1xuICAvLyB0aGVpciBmaWVsZCAxIHZhbHVlIHBsdXMgMS4gVGhhdCdzIHdoeSB0aGVyZSdzIHRoZSBcInwgZmllbGRcIiBvbiB0aGVcbiAgLy8gY29udHJvbCB2YWx1ZS5cbiAgaWYgKHRoaXMuZGF0YUNoYW5uZWxfID09PSAwKSB7XG4gICAgdGhpcy5CQVNFXyAgICAgPSAweDEwO1xuICAgIHRoaXMuRVhUXyAgICAgID0gMHgxMTtcbiAgICB0aGlzLkNPTlRST0xfICA9ICgweDE0IHwgdGhpcy5maWVsZF8pIDw8IDg7XG4gICAgdGhpcy5PRkZTRVRfICAgPSAweDE3O1xuICB9IGVsc2UgaWYgKHRoaXMuZGF0YUNoYW5uZWxfID09PSAxKSB7XG4gICAgdGhpcy5CQVNFXyAgICAgPSAweDE4O1xuICAgIHRoaXMuRVhUXyAgICAgID0gMHgxOTtcbiAgICB0aGlzLkNPTlRST0xfICA9ICgweDFjIHwgdGhpcy5maWVsZF8pIDw8IDg7XG4gICAgdGhpcy5PRkZTRVRfICAgPSAweDFmO1xuICB9XG5cbiAgLy8gQ29uc3RhbnRzIGZvciB0aGUgTFNCeXRlIGNvbW1hbmQgY29kZXMgcmVjb2duaXplZCBieSBDZWE2MDhTdHJlYW0uIFRoaXNcbiAgLy8gbGlzdCBpcyBub3QgZXhoYXVzdGl2ZS4gRm9yIGEgbW9yZSBjb21wcmVoZW5zaXZlIGxpc3RpbmcgYW5kIHNlbWFudGljcyBzZWVcbiAgLy8gaHR0cDovL3d3dy5ncG8uZ292L2Zkc3lzL3BrZy9DRlItMjAxMC10aXRsZTQ3LXZvbDEvcGRmL0NGUi0yMDEwLXRpdGxlNDctdm9sMS1zZWMxNS0xMTkucGRmXG4gIC8vIFBhZGRpbmdcbiAgdGhpcy5QQURESU5HXyAgICAgICAgICAgICAgICAgICAgPSAweDAwMDA7XG4gIC8vIFBvcC1vbiBNb2RlXG4gIHRoaXMuUkVTVU1FX0NBUFRJT05fTE9BRElOR18gICAgID0gdGhpcy5DT05UUk9MXyB8IDB4MjA7XG4gIHRoaXMuRU5EX09GX0NBUFRJT05fICAgICAgICAgICAgID0gdGhpcy5DT05UUk9MXyB8IDB4MmY7XG4gIC8vIFJvbGwtdXAgTW9kZVxuICB0aGlzLlJPTExfVVBfMl9ST1dTXyAgICAgICAgICAgICA9IHRoaXMuQ09OVFJPTF8gfCAweDI1O1xuICB0aGlzLlJPTExfVVBfM19ST1dTXyAgICAgICAgICAgICA9IHRoaXMuQ09OVFJPTF8gfCAweDI2O1xuICB0aGlzLlJPTExfVVBfNF9ST1dTXyAgICAgICAgICAgICA9IHRoaXMuQ09OVFJPTF8gfCAweDI3O1xuICB0aGlzLkNBUlJJQUdFX1JFVFVSTl8gICAgICAgICAgICA9IHRoaXMuQ09OVFJPTF8gfCAweDJkO1xuICAvLyBwYWludC1vbiBtb2RlIChub3Qgc3VwcG9ydGVkKVxuICB0aGlzLlJFU1VNRV9ESVJFQ1RfQ0FQVElPTklOR18gICA9IHRoaXMuQ09OVFJPTF8gfCAweDI5O1xuICAvLyBFcmFzdXJlXG4gIHRoaXMuQkFDS1NQQUNFXyAgICAgICAgICAgICAgICAgID0gdGhpcy5DT05UUk9MXyB8IDB4MjE7XG4gIHRoaXMuRVJBU0VfRElTUExBWUVEX01FTU9SWV8gICAgID0gdGhpcy5DT05UUk9MXyB8IDB4MmM7XG4gIHRoaXMuRVJBU0VfTk9OX0RJU1BMQVlFRF9NRU1PUllfID0gdGhpcy5DT05UUk9MXyB8IDB4MmU7XG59O1xuXG4vKipcbiAqIERldGVjdHMgaWYgdGhlIDItYnl0ZSBwYWNrZXQgZGF0YSBpcyBhIHNwZWNpYWwgY2hhcmFjdGVyXG4gKlxuICogU3BlY2lhbCBjaGFyYWN0ZXJzIGhhdmUgYSBzZWNvbmQgYnl0ZSBpbiB0aGUgcmFuZ2UgMHgzMCB0byAweDNmLFxuICogd2l0aCB0aGUgZmlyc3QgYnl0ZSBiZWluZyAweDExIChmb3IgZGF0YSBjaGFubmVsIDEpIG9yIDB4MTkgKGZvclxuICogZGF0YSBjaGFubmVsIDIpLlxuICpcbiAqIEBwYXJhbSAge0ludGVnZXJ9IGNoYXIwIFRoZSBmaXJzdCBieXRlXG4gKiBAcGFyYW0gIHtJbnRlZ2VyfSBjaGFyMSBUaGUgc2Vjb25kIGJ5dGVcbiAqIEByZXR1cm4ge0Jvb2xlYW59ICAgICAgIFdoZXRoZXIgdGhlIDIgYnl0ZXMgYXJlIGFuIHNwZWNpYWwgY2hhcmFjdGVyXG4gKi9cbkNlYTYwOFN0cmVhbS5wcm90b3R5cGUuaXNTcGVjaWFsQ2hhcmFjdGVyID0gZnVuY3Rpb24oY2hhcjAsIGNoYXIxKSB7XG4gIHJldHVybiAoY2hhcjAgPT09IHRoaXMuRVhUXyAmJiBjaGFyMSA+PSAweDMwICYmIGNoYXIxIDw9IDB4M2YpO1xufTtcblxuLyoqXG4gKiBEZXRlY3RzIGlmIHRoZSAyLWJ5dGUgcGFja2V0IGRhdGEgaXMgYW4gZXh0ZW5kZWQgY2hhcmFjdGVyXG4gKlxuICogRXh0ZW5kZWQgY2hhcmFjdGVycyBoYXZlIGEgc2Vjb25kIGJ5dGUgaW4gdGhlIHJhbmdlIDB4MjAgdG8gMHgzZixcbiAqIHdpdGggdGhlIGZpcnN0IGJ5dGUgYmVpbmcgMHgxMiBvciAweDEzIChmb3IgZGF0YSBjaGFubmVsIDEpIG9yXG4gKiAweDFhIG9yIDB4MWIgKGZvciBkYXRhIGNoYW5uZWwgMikuXG4gKlxuICogQHBhcmFtICB7SW50ZWdlcn0gY2hhcjAgVGhlIGZpcnN0IGJ5dGVcbiAqIEBwYXJhbSAge0ludGVnZXJ9IGNoYXIxIFRoZSBzZWNvbmQgYnl0ZVxuICogQHJldHVybiB7Qm9vbGVhbn0gICAgICAgV2hldGhlciB0aGUgMiBieXRlcyBhcmUgYW4gZXh0ZW5kZWQgY2hhcmFjdGVyXG4gKi9cbkNlYTYwOFN0cmVhbS5wcm90b3R5cGUuaXNFeHRDaGFyYWN0ZXIgPSBmdW5jdGlvbihjaGFyMCwgY2hhcjEpIHtcbiAgcmV0dXJuICgoY2hhcjAgPT09ICh0aGlzLkVYVF8gKyAxKSB8fCBjaGFyMCA9PT0gKHRoaXMuRVhUXyArIDIpKSAmJlxuICAgIChjaGFyMSA+PSAweDIwICYmIGNoYXIxIDw9IDB4M2YpKTtcbn07XG5cbi8qKlxuICogRGV0ZWN0cyBpZiB0aGUgMi1ieXRlIHBhY2tldCBpcyBhIG1pZC1yb3cgY29kZVxuICpcbiAqIE1pZC1yb3cgY29kZXMgaGF2ZSBhIHNlY29uZCBieXRlIGluIHRoZSByYW5nZSAweDIwIHRvIDB4MmYsIHdpdGhcbiAqIHRoZSBmaXJzdCBieXRlIGJlaW5nIDB4MTEgKGZvciBkYXRhIGNoYW5uZWwgMSkgb3IgMHgxOSAoZm9yIGRhdGFcbiAqIGNoYW5uZWwgMikuXG4gKlxuICogQHBhcmFtICB7SW50ZWdlcn0gY2hhcjAgVGhlIGZpcnN0IGJ5dGVcbiAqIEBwYXJhbSAge0ludGVnZXJ9IGNoYXIxIFRoZSBzZWNvbmQgYnl0ZVxuICogQHJldHVybiB7Qm9vbGVhbn0gICAgICAgV2hldGhlciB0aGUgMiBieXRlcyBhcmUgYSBtaWQtcm93IGNvZGVcbiAqL1xuQ2VhNjA4U3RyZWFtLnByb3RvdHlwZS5pc01pZFJvd0NvZGUgPSBmdW5jdGlvbihjaGFyMCwgY2hhcjEpIHtcbiAgcmV0dXJuIChjaGFyMCA9PT0gdGhpcy5FWFRfICYmIChjaGFyMSA+PSAweDIwICYmIGNoYXIxIDw9IDB4MmYpKTtcbn07XG5cbi8qKlxuICogRGV0ZWN0cyBpZiB0aGUgMi1ieXRlIHBhY2tldCBpcyBhbiBvZmZzZXQgY29udHJvbCBjb2RlXG4gKlxuICogT2Zmc2V0IGNvbnRyb2wgY29kZXMgaGF2ZSBhIHNlY29uZCBieXRlIGluIHRoZSByYW5nZSAweDIxIHRvIDB4MjMsXG4gKiB3aXRoIHRoZSBmaXJzdCBieXRlIGJlaW5nIDB4MTcgKGZvciBkYXRhIGNoYW5uZWwgMSkgb3IgMHgxZiAoZm9yXG4gKiBkYXRhIGNoYW5uZWwgMikuXG4gKlxuICogQHBhcmFtICB7SW50ZWdlcn0gY2hhcjAgVGhlIGZpcnN0IGJ5dGVcbiAqIEBwYXJhbSAge0ludGVnZXJ9IGNoYXIxIFRoZSBzZWNvbmQgYnl0ZVxuICogQHJldHVybiB7Qm9vbGVhbn0gICAgICAgV2hldGhlciB0aGUgMiBieXRlcyBhcmUgYW4gb2Zmc2V0IGNvbnRyb2wgY29kZVxuICovXG5DZWE2MDhTdHJlYW0ucHJvdG90eXBlLmlzT2Zmc2V0Q29udHJvbENvZGUgPSBmdW5jdGlvbihjaGFyMCwgY2hhcjEpIHtcbiAgcmV0dXJuIChjaGFyMCA9PT0gdGhpcy5PRkZTRVRfICYmIChjaGFyMSA+PSAweDIxICYmIGNoYXIxIDw9IDB4MjMpKTtcbn07XG5cbi8qKlxuICogRGV0ZWN0cyBpZiB0aGUgMi1ieXRlIHBhY2tldCBpcyBhIFByZWFtYmxlIEFkZHJlc3MgQ29kZVxuICpcbiAqIFBBQ3MgaGF2ZSBhIGZpcnN0IGJ5dGUgaW4gdGhlIHJhbmdlIDB4MTAgdG8gMHgxNyAoZm9yIGRhdGEgY2hhbm5lbCAxKVxuICogb3IgMHgxOCB0byAweDFmIChmb3IgZGF0YSBjaGFubmVsIDIpLCB3aXRoIHRoZSBzZWNvbmQgYnl0ZSBpbiB0aGVcbiAqIHJhbmdlIDB4NDAgdG8gMHg3Zi5cbiAqXG4gKiBAcGFyYW0gIHtJbnRlZ2VyfSBjaGFyMCBUaGUgZmlyc3QgYnl0ZVxuICogQHBhcmFtICB7SW50ZWdlcn0gY2hhcjEgVGhlIHNlY29uZCBieXRlXG4gKiBAcmV0dXJuIHtCb29sZWFufSAgICAgICBXaGV0aGVyIHRoZSAyIGJ5dGVzIGFyZSBhIFBBQ1xuICovXG5DZWE2MDhTdHJlYW0ucHJvdG90eXBlLmlzUEFDID0gZnVuY3Rpb24oY2hhcjAsIGNoYXIxKSB7XG4gIHJldHVybiAoY2hhcjAgPj0gdGhpcy5CQVNFXyAmJiBjaGFyMCA8ICh0aGlzLkJBU0VfICsgOCkgJiZcbiAgICAoY2hhcjEgPj0gMHg0MCAmJiBjaGFyMSA8PSAweDdmKSk7XG59O1xuXG4vKipcbiAqIERldGVjdHMgaWYgYSBwYWNrZXQncyBzZWNvbmQgYnl0ZSBpcyBpbiB0aGUgcmFuZ2Ugb2YgYSBQQUMgY29sb3IgY29kZVxuICpcbiAqIFBBQyBjb2xvciBjb2RlcyBoYXZlIHRoZSBzZWNvbmQgYnl0ZSBiZSBpbiB0aGUgcmFuZ2UgMHg0MCB0byAweDRmLCBvclxuICogMHg2MCB0byAweDZmLlxuICpcbiAqIEBwYXJhbSAge0ludGVnZXJ9IGNoYXIxIFRoZSBzZWNvbmQgYnl0ZVxuICogQHJldHVybiB7Qm9vbGVhbn0gICAgICAgV2hldGhlciB0aGUgYnl0ZSBpcyBhIGNvbG9yIFBBQ1xuICovXG5DZWE2MDhTdHJlYW0ucHJvdG90eXBlLmlzQ29sb3JQQUMgPSBmdW5jdGlvbihjaGFyMSkge1xuICByZXR1cm4gKChjaGFyMSA+PSAweDQwICYmIGNoYXIxIDw9IDB4NGYpIHx8IChjaGFyMSA+PSAweDYwICYmIGNoYXIxIDw9IDB4N2YpKTtcbn07XG5cbi8qKlxuICogRGV0ZWN0cyBpZiBhIHNpbmdsZSBieXRlIGlzIGluIHRoZSByYW5nZSBvZiBhIG5vcm1hbCBjaGFyYWN0ZXJcbiAqXG4gKiBOb3JtYWwgdGV4dCBieXRlcyBhcmUgaW4gdGhlIHJhbmdlIDB4MjAgdG8gMHg3Zi5cbiAqXG4gKiBAcGFyYW0gIHtJbnRlZ2VyfSBjaGFyICBUaGUgYnl0ZVxuICogQHJldHVybiB7Qm9vbGVhbn0gICAgICAgV2hldGhlciB0aGUgYnl0ZSBpcyBhIG5vcm1hbCBjaGFyYWN0ZXJcbiAqL1xuQ2VhNjA4U3RyZWFtLnByb3RvdHlwZS5pc05vcm1hbENoYXIgPSBmdW5jdGlvbihjaGFyKSB7XG4gIHJldHVybiAoY2hhciA+PSAweDIwICYmIGNoYXIgPD0gMHg3Zik7XG59O1xuXG4vLyBBZGRzIHRoZSBvcGVuaW5nIEhUTUwgdGFnIGZvciB0aGUgcGFzc2VkIGNoYXJhY3RlciB0byB0aGUgY2FwdGlvbiB0ZXh0LFxuLy8gYW5kIGtlZXBzIHRyYWNrIG9mIGl0IGZvciBsYXRlciBjbG9zaW5nXG5DZWE2MDhTdHJlYW0ucHJvdG90eXBlLmFkZEZvcm1hdHRpbmcgPSBmdW5jdGlvbihwdHMsIGZvcm1hdCkge1xuICB0aGlzLmZvcm1hdHRpbmdfID0gdGhpcy5mb3JtYXR0aW5nXy5jb25jYXQoZm9ybWF0KTtcbiAgdmFyIHRleHQgPSBmb3JtYXQucmVkdWNlKGZ1bmN0aW9uKHRleHQsIGZvcm1hdCkge1xuICAgIHJldHVybiB0ZXh0ICsgJzwnICsgZm9ybWF0ICsgJz4nO1xuICB9LCAnJyk7XG4gIHRoaXNbdGhpcy5tb2RlX10ocHRzLCB0ZXh0KTtcbn07XG5cbi8vIEFkZHMgSFRNTCBjbG9zaW5nIHRhZ3MgZm9yIGN1cnJlbnQgZm9ybWF0dGluZyB0byBjYXB0aW9uIHRleHQgYW5kXG4vLyBjbGVhcnMgcmVtZW1iZXJlZCBmb3JtYXR0aW5nXG5DZWE2MDhTdHJlYW0ucHJvdG90eXBlLmNsZWFyRm9ybWF0dGluZyA9IGZ1bmN0aW9uKHB0cykge1xuICBpZiAoIXRoaXMuZm9ybWF0dGluZ18ubGVuZ3RoKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciB0ZXh0ID0gdGhpcy5mb3JtYXR0aW5nXy5yZXZlcnNlKCkucmVkdWNlKGZ1bmN0aW9uKHRleHQsIGZvcm1hdCkge1xuICAgIHJldHVybiB0ZXh0ICsgJzwvJyArIGZvcm1hdCArICc+JztcbiAgfSwgJycpO1xuICB0aGlzLmZvcm1hdHRpbmdfID0gW107XG4gIHRoaXNbdGhpcy5tb2RlX10ocHRzLCB0ZXh0KTtcbn07XG5cbi8vIE1vZGUgSW1wbGVtZW50YXRpb25zXG5DZWE2MDhTdHJlYW0ucHJvdG90eXBlLnBvcE9uID0gZnVuY3Rpb24ocHRzLCB0ZXh0KSB7XG4gIHZhciBiYXNlUm93ID0gdGhpcy5ub25EaXNwbGF5ZWRfW3RoaXMucm93X107XG5cbiAgLy8gYnVmZmVyIGNoYXJhY3RlcnNcbiAgYmFzZVJvdyArPSB0ZXh0O1xuICB0aGlzLm5vbkRpc3BsYXllZF9bdGhpcy5yb3dfXSA9IGJhc2VSb3c7XG59O1xuXG5DZWE2MDhTdHJlYW0ucHJvdG90eXBlLnJvbGxVcCA9IGZ1bmN0aW9uKHB0cywgdGV4dCkge1xuICB2YXIgYmFzZVJvdyA9IHRoaXMuZGlzcGxheWVkX1tCT1RUT01fUk9XXTtcblxuICBiYXNlUm93ICs9IHRleHQ7XG4gIHRoaXMuZGlzcGxheWVkX1tCT1RUT01fUk9XXSA9IGJhc2VSb3c7XG5cbn07XG5cbkNlYTYwOFN0cmVhbS5wcm90b3R5cGUuc2hpZnRSb3dzVXBfID0gZnVuY3Rpb24oKSB7XG4gIHZhciBpO1xuICAvLyBjbGVhciBvdXQgaW5hY3RpdmUgcm93c1xuICBmb3IgKGkgPSAwOyBpIDwgdGhpcy50b3BSb3dfOyBpKyspIHtcbiAgICB0aGlzLmRpc3BsYXllZF9baV0gPSAnJztcbiAgfVxuICAvLyBzaGlmdCBkaXNwbGF5ZWQgcm93cyB1cFxuICBmb3IgKGkgPSB0aGlzLnRvcFJvd187IGkgPCBCT1RUT01fUk9XOyBpKyspIHtcbiAgICB0aGlzLmRpc3BsYXllZF9baV0gPSB0aGlzLmRpc3BsYXllZF9baSArIDFdO1xuICB9XG4gIC8vIGNsZWFyIG91dCB0aGUgYm90dG9tIHJvd1xuICB0aGlzLmRpc3BsYXllZF9bQk9UVE9NX1JPV10gPSAnJztcbn07XG5cbi8vIHBhaW50T24gbW9kZSBpcyBub3QgaW1wbGVtZW50ZWRcbkNlYTYwOFN0cmVhbS5wcm90b3R5cGUucGFpbnRPbiA9IGZ1bmN0aW9uKCkge307XG5cbi8vIGV4cG9ydHNcbm1vZHVsZS5leHBvcnRzID0ge1xuICBDYXB0aW9uU3RyZWFtOiBDYXB0aW9uU3RyZWFtLFxuICBDZWE2MDhTdHJlYW06IENlYTYwOFN0cmVhbVxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/videojs-contrib-media-sources/node_modules/mux.js/lib/m2ts/caption-stream.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/videojs-contrib-media-sources/node_modules/mux.js/lib/m2ts/m2ts.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/videojs-contrib-media-sources/node_modules/mux.js/lib/m2ts/m2ts.js ***!
  \*****************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/**\n * mux.js\n *\n * Copyright (c) 2015 Brightcove\n * All rights reserved.\n *\n * A stream-based mp2t to mp4 converter. This utility can be used to\n * deliver mp4s to a SourceBuffer on platforms that support native\n * Media Source Extensions.\n */\n\nvar Stream = __webpack_require__(/*! ../utils/stream.js */ \"(ssr)/./node_modules/videojs-contrib-media-sources/node_modules/mux.js/lib/utils/stream.js\"),\n  CaptionStream = __webpack_require__(/*! ./caption-stream */ \"(ssr)/./node_modules/videojs-contrib-media-sources/node_modules/mux.js/lib/m2ts/caption-stream.js\"),\n  StreamTypes = __webpack_require__(/*! ./stream-types */ \"(ssr)/./node_modules/videojs-contrib-media-sources/node_modules/mux.js/lib/m2ts/stream-types.js\"),\n  TimestampRolloverStream = (__webpack_require__(/*! ./timestamp-rollover-stream */ \"(ssr)/./node_modules/videojs-contrib-media-sources/node_modules/mux.js/lib/m2ts/timestamp-rollover-stream.js\").TimestampRolloverStream);\n\nvar m2tsStreamTypes = __webpack_require__(/*! ./stream-types.js */ \"(ssr)/./node_modules/videojs-contrib-media-sources/node_modules/mux.js/lib/m2ts/stream-types.js\");\n\n// object types\nvar TransportPacketStream, TransportParseStream, ElementaryStream;\n\n// constants\nvar\n  MP2T_PACKET_LENGTH = 188, // bytes\n  SYNC_BYTE = 0x47;\n\n/**\n * Splits an incoming stream of binary data into MPEG-2 Transport\n * Stream packets.\n */\nTransportPacketStream = function() {\n  var\n    buffer = new Uint8Array(MP2T_PACKET_LENGTH),\n    bytesInBuffer = 0;\n\n  TransportPacketStream.prototype.init.call(this);\n\n   // Deliver new bytes to the stream.\n\n  this.push = function(bytes) {\n    var\n      startIndex = 0,\n      endIndex = MP2T_PACKET_LENGTH,\n      everything;\n\n    // If there are bytes remaining from the last segment, prepend them to the\n    // bytes that were pushed in\n    if (bytesInBuffer) {\n      everything = new Uint8Array(bytes.byteLength + bytesInBuffer);\n      everything.set(buffer.subarray(0, bytesInBuffer));\n      everything.set(bytes, bytesInBuffer);\n      bytesInBuffer = 0;\n    } else {\n      everything = bytes;\n    }\n\n    // While we have enough data for a packet\n    while (endIndex < everything.byteLength) {\n      // Look for a pair of start and end sync bytes in the data..\n      if (everything[startIndex] === SYNC_BYTE && everything[endIndex] === SYNC_BYTE) {\n        // We found a packet so emit it and jump one whole packet forward in\n        // the stream\n        this.trigger('data', everything.subarray(startIndex, endIndex));\n        startIndex += MP2T_PACKET_LENGTH;\n        endIndex += MP2T_PACKET_LENGTH;\n        continue;\n      }\n      // If we get here, we have somehow become de-synchronized and we need to step\n      // forward one byte at a time until we find a pair of sync bytes that denote\n      // a packet\n      startIndex++;\n      endIndex++;\n    }\n\n    // If there was some data left over at the end of the segment that couldn't\n    // possibly be a whole packet, keep it because it might be the start of a packet\n    // that continues in the next segment\n    if (startIndex < everything.byteLength) {\n      buffer.set(everything.subarray(startIndex), 0);\n      bytesInBuffer = everything.byteLength - startIndex;\n    }\n  };\n\n  this.flush = function() {\n    // If the buffer contains a whole packet when we are being flushed, emit it\n    // and empty the buffer. Otherwise hold onto the data because it may be\n    // important for decoding the next segment\n    if (bytesInBuffer === MP2T_PACKET_LENGTH && buffer[0] === SYNC_BYTE) {\n      this.trigger('data', buffer);\n      bytesInBuffer = 0;\n    }\n    this.trigger('done');\n  };\n};\nTransportPacketStream.prototype = new Stream();\n\n/**\n * Accepts an MP2T TransportPacketStream and emits data events with parsed\n * forms of the individual transport stream packets.\n */\nTransportParseStream = function() {\n  var parsePsi, parsePat, parsePmt, self;\n  TransportParseStream.prototype.init.call(this);\n  self = this;\n\n  this.packetsWaitingForPmt = [];\n  this.programMapTable = undefined;\n\n  parsePsi = function(payload, psi) {\n    var offset = 0;\n\n    // PSI packets may be split into multiple sections and those\n    // sections may be split into multiple packets. If a PSI\n    // section starts in this packet, the payload_unit_start_indicator\n    // will be true and the first byte of the payload will indicate\n    // the offset from the current position to the start of the\n    // section.\n    if (psi.payloadUnitStartIndicator) {\n      offset += payload[offset] + 1;\n    }\n\n    if (psi.type === 'pat') {\n      parsePat(payload.subarray(offset), psi);\n    } else {\n      parsePmt(payload.subarray(offset), psi);\n    }\n  };\n\n  parsePat = function(payload, pat) {\n    pat.section_number = payload[7]; // eslint-disable-line camelcase\n    pat.last_section_number = payload[8]; // eslint-disable-line camelcase\n\n    // skip the PSI header and parse the first PMT entry\n    self.pmtPid = (payload[10] & 0x1F) << 8 | payload[11];\n    pat.pmtPid = self.pmtPid;\n  };\n\n  /**\n   * Parse out the relevant fields of a Program Map Table (PMT).\n   * @param payload {Uint8Array} the PMT-specific portion of an MP2T\n   * packet. The first byte in this array should be the table_id\n   * field.\n   * @param pmt {object} the object that should be decorated with\n   * fields parsed from the PMT.\n   */\n  parsePmt = function(payload, pmt) {\n    var sectionLength, tableEnd, programInfoLength, offset;\n\n    // PMTs can be sent ahead of the time when they should actually\n    // take effect. We don't believe this should ever be the case\n    // for HLS but we'll ignore \"forward\" PMT declarations if we see\n    // them. Future PMT declarations have the current_next_indicator\n    // set to zero.\n    if (!(payload[5] & 0x01)) {\n      return;\n    }\n\n    // overwrite any existing program map table\n    self.programMapTable = {\n      video: null,\n      audio: null,\n      'timed-metadata': {}\n    };\n\n    // the mapping table ends at the end of the current section\n    sectionLength = (payload[1] & 0x0f) << 8 | payload[2];\n    tableEnd = 3 + sectionLength - 4;\n\n    // to determine where the table is, we have to figure out how\n    // long the program info descriptors are\n    programInfoLength = (payload[10] & 0x0f) << 8 | payload[11];\n\n    // advance the offset to the first entry in the mapping table\n    offset = 12 + programInfoLength;\n    while (offset < tableEnd) {\n      var streamType = payload[offset];\n      var pid = (payload[offset + 1] & 0x1F) << 8 | payload[offset + 2];\n\n      // only map a single elementary_pid for audio and video stream types\n      // TODO: should this be done for metadata too? for now maintain behavior of\n      //       multiple metadata streams\n      if (streamType === StreamTypes.H264_STREAM_TYPE &&\n          self.programMapTable.video === null) {\n        self.programMapTable.video = pid;\n      } else if (streamType === StreamTypes.ADTS_STREAM_TYPE &&\n                 self.programMapTable.audio === null) {\n        self.programMapTable.audio = pid;\n      } else if (streamType === StreamTypes.METADATA_STREAM_TYPE) {\n        // map pid to stream type for metadata streams\n        self.programMapTable['timed-metadata'][pid] = streamType;\n      }\n\n      // move to the next table entry\n      // skip past the elementary stream descriptors, if present\n      offset += ((payload[offset + 3] & 0x0F) << 8 | payload[offset + 4]) + 5;\n    }\n\n    // record the map on the packet as well\n    pmt.programMapTable = self.programMapTable;\n  };\n\n  /**\n   * Deliver a new MP2T packet to the stream.\n   */\n  this.push = function(packet) {\n    var\n      result = {},\n      offset = 4;\n\n    result.payloadUnitStartIndicator = !!(packet[1] & 0x40);\n\n    // pid is a 13-bit field starting at the last bit of packet[1]\n    result.pid = packet[1] & 0x1f;\n    result.pid <<= 8;\n    result.pid |= packet[2];\n\n    // if an adaption field is present, its length is specified by the\n    // fifth byte of the TS packet header. The adaptation field is\n    // used to add stuffing to PES packets that don't fill a complete\n    // TS packet, and to specify some forms of timing and control data\n    // that we do not currently use.\n    if (((packet[3] & 0x30) >>> 4) > 0x01) {\n      offset += packet[offset] + 1;\n    }\n\n    // parse the rest of the packet based on the type\n    if (result.pid === 0) {\n      result.type = 'pat';\n      parsePsi(packet.subarray(offset), result);\n      this.trigger('data', result);\n    } else if (result.pid === this.pmtPid) {\n      result.type = 'pmt';\n      parsePsi(packet.subarray(offset), result);\n      this.trigger('data', result);\n\n      // if there are any packets waiting for a PMT to be found, process them now\n      while (this.packetsWaitingForPmt.length) {\n        this.processPes_.apply(this, this.packetsWaitingForPmt.shift());\n      }\n    } else if (this.programMapTable === undefined) {\n      // When we have not seen a PMT yet, defer further processing of\n      // PES packets until one has been parsed\n      this.packetsWaitingForPmt.push([packet, offset, result]);\n    } else {\n      this.processPes_(packet, offset, result);\n    }\n  };\n\n  this.processPes_ = function(packet, offset, result) {\n    // set the appropriate stream type\n    if (result.pid === this.programMapTable.video) {\n      result.streamType = StreamTypes.H264_STREAM_TYPE;\n    } else if (result.pid === this.programMapTable.audio) {\n      result.streamType = StreamTypes.ADTS_STREAM_TYPE;\n    } else {\n      // if not video or audio, it is timed-metadata or unknown\n      // if unknown, streamType will be undefined\n      result.streamType = this.programMapTable['timed-metadata'][result.pid];\n    }\n\n    result.type = 'pes';\n    result.data = packet.subarray(offset);\n\n    this.trigger('data', result);\n  };\n\n};\nTransportParseStream.prototype = new Stream();\nTransportParseStream.STREAM_TYPES  = {\n  h264: 0x1b,\n  adts: 0x0f\n};\n\n/**\n * Reconsistutes program elementary stream (PES) packets from parsed\n * transport stream packets. That is, if you pipe an\n * mp2t.TransportParseStream into a mp2t.ElementaryStream, the output\n * events will be events which capture the bytes for individual PES\n * packets plus relevant metadata that has been extracted from the\n * container.\n */\nElementaryStream = function() {\n  var\n    self = this,\n    // PES packet fragments\n    video = {\n      data: [],\n      size: 0\n    },\n    audio = {\n      data: [],\n      size: 0\n    },\n    timedMetadata = {\n      data: [],\n      size: 0\n    },\n    parsePes = function(payload, pes) {\n      var ptsDtsFlags;\n\n      // get the packet length, this will be 0 for video\n      pes.packetLength = 6 + ((payload[4] << 8) | payload[5]);\n\n      // find out if this packets starts a new keyframe\n      pes.dataAlignmentIndicator = (payload[6] & 0x04) !== 0;\n      // PES packets may be annotated with a PTS value, or a PTS value\n      // and a DTS value. Determine what combination of values is\n      // available to work with.\n      ptsDtsFlags = payload[7];\n\n      // PTS and DTS are normally stored as a 33-bit number.  Javascript\n      // performs all bitwise operations on 32-bit integers but javascript\n      // supports a much greater range (52-bits) of integer using standard\n      // mathematical operations.\n      // We construct a 31-bit value using bitwise operators over the 31\n      // most significant bits and then multiply by 4 (equal to a left-shift\n      // of 2) before we add the final 2 least significant bits of the\n      // timestamp (equal to an OR.)\n      if (ptsDtsFlags & 0xC0) {\n        // the PTS and DTS are not written out directly. For information\n        // on how they are encoded, see\n        // http://dvd.sourceforge.net/dvdinfo/pes-hdr.html\n        pes.pts = (payload[9] & 0x0E) << 27 |\n          (payload[10] & 0xFF) << 20 |\n          (payload[11] & 0xFE) << 12 |\n          (payload[12] & 0xFF) <<  5 |\n          (payload[13] & 0xFE) >>>  3;\n        pes.pts *= 4; // Left shift by 2\n        pes.pts += (payload[13] & 0x06) >>> 1; // OR by the two LSBs\n        pes.dts = pes.pts;\n        if (ptsDtsFlags & 0x40) {\n          pes.dts = (payload[14] & 0x0E) << 27 |\n            (payload[15] & 0xFF) << 20 |\n            (payload[16] & 0xFE) << 12 |\n            (payload[17] & 0xFF) << 5 |\n            (payload[18] & 0xFE) >>> 3;\n          pes.dts *= 4; // Left shift by 2\n          pes.dts += (payload[18] & 0x06) >>> 1; // OR by the two LSBs\n        }\n      }\n      // the data section starts immediately after the PES header.\n      // pes_header_data_length specifies the number of header bytes\n      // that follow the last byte of the field.\n      pes.data = payload.subarray(9 + payload[8]);\n    },\n    flushStream = function(stream, type, forceFlush) {\n      var\n        packetData = new Uint8Array(stream.size),\n        event = {\n          type: type\n        },\n        i = 0,\n        offset = 0,\n        packetFlushable = false,\n        fragment;\n\n      // do nothing if there is not enough buffered data for a complete\n      // PES header\n      if (!stream.data.length || stream.size < 9) {\n        return;\n      }\n      event.trackId = stream.data[0].pid;\n\n      // reassemble the packet\n      for (i = 0; i < stream.data.length; i++) {\n        fragment = stream.data[i];\n\n        packetData.set(fragment.data, offset);\n        offset += fragment.data.byteLength;\n      }\n\n      // parse assembled packet's PES header\n      parsePes(packetData, event);\n\n      // non-video PES packets MUST have a non-zero PES_packet_length\n      // check that there is enough stream data to fill the packet\n      packetFlushable = type === 'video' || event.packetLength <= stream.size;\n\n      // flush pending packets if the conditions are right\n      if (forceFlush || packetFlushable) {\n        stream.size = 0;\n        stream.data.length = 0;\n      }\n\n      // only emit packets that are complete. this is to avoid assembling\n      // incomplete PES packets due to poor segmentation\n      if (packetFlushable) {\n        self.trigger('data', event);\n      }\n    };\n\n  ElementaryStream.prototype.init.call(this);\n\n  this.push = function(data) {\n    ({\n      pat: function() {\n        // we have to wait for the PMT to arrive as well before we\n        // have any meaningful metadata\n      },\n      pes: function() {\n        var stream, streamType;\n\n        switch (data.streamType) {\n        case StreamTypes.H264_STREAM_TYPE:\n        case m2tsStreamTypes.H264_STREAM_TYPE:\n          stream = video;\n          streamType = 'video';\n          break;\n        case StreamTypes.ADTS_STREAM_TYPE:\n          stream = audio;\n          streamType = 'audio';\n          break;\n        case StreamTypes.METADATA_STREAM_TYPE:\n          stream = timedMetadata;\n          streamType = 'timed-metadata';\n          break;\n        default:\n          // ignore unknown stream types\n          return;\n        }\n\n        // if a new packet is starting, we can flush the completed\n        // packet\n        if (data.payloadUnitStartIndicator) {\n          flushStream(stream, streamType, true);\n        }\n\n        // buffer this fragment until we are sure we've received the\n        // complete payload\n        stream.data.push(data);\n        stream.size += data.data.byteLength;\n      },\n      pmt: function() {\n        var\n          event = {\n            type: 'metadata',\n            tracks: []\n          },\n          programMapTable = data.programMapTable;\n\n        // translate audio and video streams to tracks\n        if (programMapTable.video !== null) {\n          event.tracks.push({\n            timelineStartInfo: {\n              baseMediaDecodeTime: 0\n            },\n            id: +programMapTable.video,\n            codec: 'avc',\n            type: 'video'\n          });\n        }\n        if (programMapTable.audio !== null) {\n          event.tracks.push({\n            timelineStartInfo: {\n              baseMediaDecodeTime: 0\n            },\n            id: +programMapTable.audio,\n            codec: 'adts',\n            type: 'audio'\n          });\n        }\n\n        self.trigger('data', event);\n      }\n    })[data.type]();\n  };\n\n  /**\n   * Flush any remaining input. Video PES packets may be of variable\n   * length. Normally, the start of a new video packet can trigger the\n   * finalization of the previous packet. That is not possible if no\n   * more video is forthcoming, however. In that case, some other\n   * mechanism (like the end of the file) has to be employed. When it is\n   * clear that no additional data is forthcoming, calling this method\n   * will flush the buffered packets.\n   */\n  this.flush = function() {\n    // !!THIS ORDER IS IMPORTANT!!\n    // video first then audio\n    flushStream(video, 'video');\n    flushStream(audio, 'audio');\n    flushStream(timedMetadata, 'timed-metadata');\n    this.trigger('done');\n  };\n};\nElementaryStream.prototype = new Stream();\n\nvar m2ts = {\n  PAT_PID: 0x0000,\n  MP2T_PACKET_LENGTH: MP2T_PACKET_LENGTH,\n  TransportPacketStream: TransportPacketStream,\n  TransportParseStream: TransportParseStream,\n  ElementaryStream: ElementaryStream,\n  TimestampRolloverStream: TimestampRolloverStream,\n  CaptionStream: CaptionStream.CaptionStream,\n  Cea608Stream: CaptionStream.Cea608Stream,\n  MetadataStream: __webpack_require__(/*! ./metadata-stream */ \"(ssr)/./node_modules/videojs-contrib-media-sources/node_modules/mux.js/lib/m2ts/metadata-stream.js\")\n};\n\nfor (var type in StreamTypes) {\n  if (StreamTypes.hasOwnProperty(type)) {\n    m2ts[type] = StreamTypes[type];\n  }\n}\n\nmodule.exports = m2ts;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdmlkZW9qcy1jb250cmliLW1lZGlhLXNvdXJjZXMvbm9kZV9tb2R1bGVzL211eC5qcy9saWIvbTJ0cy9tMnRzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7QUFDYixhQUFhLG1CQUFPLENBQUMsc0hBQW9CO0FBQ3pDLGtCQUFrQixtQkFBTyxDQUFDLDJIQUFrQjtBQUM1QyxnQkFBZ0IsbUJBQU8sQ0FBQyx1SEFBZ0I7QUFDeEMsNEJBQTRCLGdNQUE4RDs7QUFFMUYsc0JBQXNCLG1CQUFPLENBQUMsMEhBQW1COztBQUVqRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0EscUNBQXFDO0FBQ3JDLDBDQUEwQzs7QUFFMUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQixZQUFZO0FBQ2pDO0FBQ0E7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QiwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEIsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQix3QkFBd0I7QUFDMUM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG1CQUFPLENBQUMsNkhBQW1CO0FBQzdDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS12MC1wcm9qZWN0Ly4vbm9kZV9tb2R1bGVzL3ZpZGVvanMtY29udHJpYi1tZWRpYS1zb3VyY2VzL25vZGVfbW9kdWxlcy9tdXguanMvbGliL20ydHMvbTJ0cy5qcz9iNDE0Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogbXV4LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE1IEJyaWdodGNvdmVcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogQSBzdHJlYW0tYmFzZWQgbXAydCB0byBtcDQgY29udmVydGVyLiBUaGlzIHV0aWxpdHkgY2FuIGJlIHVzZWQgdG9cbiAqIGRlbGl2ZXIgbXA0cyB0byBhIFNvdXJjZUJ1ZmZlciBvbiBwbGF0Zm9ybXMgdGhhdCBzdXBwb3J0IG5hdGl2ZVxuICogTWVkaWEgU291cmNlIEV4dGVuc2lvbnMuXG4gKi9cbid1c2Ugc3RyaWN0JztcbnZhciBTdHJlYW0gPSByZXF1aXJlKCcuLi91dGlscy9zdHJlYW0uanMnKSxcbiAgQ2FwdGlvblN0cmVhbSA9IHJlcXVpcmUoJy4vY2FwdGlvbi1zdHJlYW0nKSxcbiAgU3RyZWFtVHlwZXMgPSByZXF1aXJlKCcuL3N0cmVhbS10eXBlcycpLFxuICBUaW1lc3RhbXBSb2xsb3ZlclN0cmVhbSA9IHJlcXVpcmUoJy4vdGltZXN0YW1wLXJvbGxvdmVyLXN0cmVhbScpLlRpbWVzdGFtcFJvbGxvdmVyU3RyZWFtO1xuXG52YXIgbTJ0c1N0cmVhbVR5cGVzID0gcmVxdWlyZSgnLi9zdHJlYW0tdHlwZXMuanMnKTtcblxuLy8gb2JqZWN0IHR5cGVzXG52YXIgVHJhbnNwb3J0UGFja2V0U3RyZWFtLCBUcmFuc3BvcnRQYXJzZVN0cmVhbSwgRWxlbWVudGFyeVN0cmVhbTtcblxuLy8gY29uc3RhbnRzXG52YXJcbiAgTVAyVF9QQUNLRVRfTEVOR1RIID0gMTg4LCAvLyBieXRlc1xuICBTWU5DX0JZVEUgPSAweDQ3O1xuXG4vKipcbiAqIFNwbGl0cyBhbiBpbmNvbWluZyBzdHJlYW0gb2YgYmluYXJ5IGRhdGEgaW50byBNUEVHLTIgVHJhbnNwb3J0XG4gKiBTdHJlYW0gcGFja2V0cy5cbiAqL1xuVHJhbnNwb3J0UGFja2V0U3RyZWFtID0gZnVuY3Rpb24oKSB7XG4gIHZhclxuICAgIGJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KE1QMlRfUEFDS0VUX0xFTkdUSCksXG4gICAgYnl0ZXNJbkJ1ZmZlciA9IDA7XG5cbiAgVHJhbnNwb3J0UGFja2V0U3RyZWFtLnByb3RvdHlwZS5pbml0LmNhbGwodGhpcyk7XG5cbiAgIC8vIERlbGl2ZXIgbmV3IGJ5dGVzIHRvIHRoZSBzdHJlYW0uXG5cbiAgdGhpcy5wdXNoID0gZnVuY3Rpb24oYnl0ZXMpIHtcbiAgICB2YXJcbiAgICAgIHN0YXJ0SW5kZXggPSAwLFxuICAgICAgZW5kSW5kZXggPSBNUDJUX1BBQ0tFVF9MRU5HVEgsXG4gICAgICBldmVyeXRoaW5nO1xuXG4gICAgLy8gSWYgdGhlcmUgYXJlIGJ5dGVzIHJlbWFpbmluZyBmcm9tIHRoZSBsYXN0IHNlZ21lbnQsIHByZXBlbmQgdGhlbSB0byB0aGVcbiAgICAvLyBieXRlcyB0aGF0IHdlcmUgcHVzaGVkIGluXG4gICAgaWYgKGJ5dGVzSW5CdWZmZXIpIHtcbiAgICAgIGV2ZXJ5dGhpbmcgPSBuZXcgVWludDhBcnJheShieXRlcy5ieXRlTGVuZ3RoICsgYnl0ZXNJbkJ1ZmZlcik7XG4gICAgICBldmVyeXRoaW5nLnNldChidWZmZXIuc3ViYXJyYXkoMCwgYnl0ZXNJbkJ1ZmZlcikpO1xuICAgICAgZXZlcnl0aGluZy5zZXQoYnl0ZXMsIGJ5dGVzSW5CdWZmZXIpO1xuICAgICAgYnl0ZXNJbkJ1ZmZlciA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV2ZXJ5dGhpbmcgPSBieXRlcztcbiAgICB9XG5cbiAgICAvLyBXaGlsZSB3ZSBoYXZlIGVub3VnaCBkYXRhIGZvciBhIHBhY2tldFxuICAgIHdoaWxlIChlbmRJbmRleCA8IGV2ZXJ5dGhpbmcuYnl0ZUxlbmd0aCkge1xuICAgICAgLy8gTG9vayBmb3IgYSBwYWlyIG9mIHN0YXJ0IGFuZCBlbmQgc3luYyBieXRlcyBpbiB0aGUgZGF0YS4uXG4gICAgICBpZiAoZXZlcnl0aGluZ1tzdGFydEluZGV4XSA9PT0gU1lOQ19CWVRFICYmIGV2ZXJ5dGhpbmdbZW5kSW5kZXhdID09PSBTWU5DX0JZVEUpIHtcbiAgICAgICAgLy8gV2UgZm91bmQgYSBwYWNrZXQgc28gZW1pdCBpdCBhbmQganVtcCBvbmUgd2hvbGUgcGFja2V0IGZvcndhcmQgaW5cbiAgICAgICAgLy8gdGhlIHN0cmVhbVxuICAgICAgICB0aGlzLnRyaWdnZXIoJ2RhdGEnLCBldmVyeXRoaW5nLnN1YmFycmF5KHN0YXJ0SW5kZXgsIGVuZEluZGV4KSk7XG4gICAgICAgIHN0YXJ0SW5kZXggKz0gTVAyVF9QQUNLRVRfTEVOR1RIO1xuICAgICAgICBlbmRJbmRleCArPSBNUDJUX1BBQ0tFVF9MRU5HVEg7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgLy8gSWYgd2UgZ2V0IGhlcmUsIHdlIGhhdmUgc29tZWhvdyBiZWNvbWUgZGUtc3luY2hyb25pemVkIGFuZCB3ZSBuZWVkIHRvIHN0ZXBcbiAgICAgIC8vIGZvcndhcmQgb25lIGJ5dGUgYXQgYSB0aW1lIHVudGlsIHdlIGZpbmQgYSBwYWlyIG9mIHN5bmMgYnl0ZXMgdGhhdCBkZW5vdGVcbiAgICAgIC8vIGEgcGFja2V0XG4gICAgICBzdGFydEluZGV4Kys7XG4gICAgICBlbmRJbmRleCsrO1xuICAgIH1cblxuICAgIC8vIElmIHRoZXJlIHdhcyBzb21lIGRhdGEgbGVmdCBvdmVyIGF0IHRoZSBlbmQgb2YgdGhlIHNlZ21lbnQgdGhhdCBjb3VsZG4ndFxuICAgIC8vIHBvc3NpYmx5IGJlIGEgd2hvbGUgcGFja2V0LCBrZWVwIGl0IGJlY2F1c2UgaXQgbWlnaHQgYmUgdGhlIHN0YXJ0IG9mIGEgcGFja2V0XG4gICAgLy8gdGhhdCBjb250aW51ZXMgaW4gdGhlIG5leHQgc2VnbWVudFxuICAgIGlmIChzdGFydEluZGV4IDwgZXZlcnl0aGluZy5ieXRlTGVuZ3RoKSB7XG4gICAgICBidWZmZXIuc2V0KGV2ZXJ5dGhpbmcuc3ViYXJyYXkoc3RhcnRJbmRleCksIDApO1xuICAgICAgYnl0ZXNJbkJ1ZmZlciA9IGV2ZXJ5dGhpbmcuYnl0ZUxlbmd0aCAtIHN0YXJ0SW5kZXg7XG4gICAgfVxuICB9O1xuXG4gIHRoaXMuZmx1c2ggPSBmdW5jdGlvbigpIHtcbiAgICAvLyBJZiB0aGUgYnVmZmVyIGNvbnRhaW5zIGEgd2hvbGUgcGFja2V0IHdoZW4gd2UgYXJlIGJlaW5nIGZsdXNoZWQsIGVtaXQgaXRcbiAgICAvLyBhbmQgZW1wdHkgdGhlIGJ1ZmZlci4gT3RoZXJ3aXNlIGhvbGQgb250byB0aGUgZGF0YSBiZWNhdXNlIGl0IG1heSBiZVxuICAgIC8vIGltcG9ydGFudCBmb3IgZGVjb2RpbmcgdGhlIG5leHQgc2VnbWVudFxuICAgIGlmIChieXRlc0luQnVmZmVyID09PSBNUDJUX1BBQ0tFVF9MRU5HVEggJiYgYnVmZmVyWzBdID09PSBTWU5DX0JZVEUpIHtcbiAgICAgIHRoaXMudHJpZ2dlcignZGF0YScsIGJ1ZmZlcik7XG4gICAgICBieXRlc0luQnVmZmVyID0gMDtcbiAgICB9XG4gICAgdGhpcy50cmlnZ2VyKCdkb25lJyk7XG4gIH07XG59O1xuVHJhbnNwb3J0UGFja2V0U3RyZWFtLnByb3RvdHlwZSA9IG5ldyBTdHJlYW0oKTtcblxuLyoqXG4gKiBBY2NlcHRzIGFuIE1QMlQgVHJhbnNwb3J0UGFja2V0U3RyZWFtIGFuZCBlbWl0cyBkYXRhIGV2ZW50cyB3aXRoIHBhcnNlZFxuICogZm9ybXMgb2YgdGhlIGluZGl2aWR1YWwgdHJhbnNwb3J0IHN0cmVhbSBwYWNrZXRzLlxuICovXG5UcmFuc3BvcnRQYXJzZVN0cmVhbSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcGFyc2VQc2ksIHBhcnNlUGF0LCBwYXJzZVBtdCwgc2VsZjtcbiAgVHJhbnNwb3J0UGFyc2VTdHJlYW0ucHJvdG90eXBlLmluaXQuY2FsbCh0aGlzKTtcbiAgc2VsZiA9IHRoaXM7XG5cbiAgdGhpcy5wYWNrZXRzV2FpdGluZ0ZvclBtdCA9IFtdO1xuICB0aGlzLnByb2dyYW1NYXBUYWJsZSA9IHVuZGVmaW5lZDtcblxuICBwYXJzZVBzaSA9IGZ1bmN0aW9uKHBheWxvYWQsIHBzaSkge1xuICAgIHZhciBvZmZzZXQgPSAwO1xuXG4gICAgLy8gUFNJIHBhY2tldHMgbWF5IGJlIHNwbGl0IGludG8gbXVsdGlwbGUgc2VjdGlvbnMgYW5kIHRob3NlXG4gICAgLy8gc2VjdGlvbnMgbWF5IGJlIHNwbGl0IGludG8gbXVsdGlwbGUgcGFja2V0cy4gSWYgYSBQU0lcbiAgICAvLyBzZWN0aW9uIHN0YXJ0cyBpbiB0aGlzIHBhY2tldCwgdGhlIHBheWxvYWRfdW5pdF9zdGFydF9pbmRpY2F0b3JcbiAgICAvLyB3aWxsIGJlIHRydWUgYW5kIHRoZSBmaXJzdCBieXRlIG9mIHRoZSBwYXlsb2FkIHdpbGwgaW5kaWNhdGVcbiAgICAvLyB0aGUgb2Zmc2V0IGZyb20gdGhlIGN1cnJlbnQgcG9zaXRpb24gdG8gdGhlIHN0YXJ0IG9mIHRoZVxuICAgIC8vIHNlY3Rpb24uXG4gICAgaWYgKHBzaS5wYXlsb2FkVW5pdFN0YXJ0SW5kaWNhdG9yKSB7XG4gICAgICBvZmZzZXQgKz0gcGF5bG9hZFtvZmZzZXRdICsgMTtcbiAgICB9XG5cbiAgICBpZiAocHNpLnR5cGUgPT09ICdwYXQnKSB7XG4gICAgICBwYXJzZVBhdChwYXlsb2FkLnN1YmFycmF5KG9mZnNldCksIHBzaSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhcnNlUG10KHBheWxvYWQuc3ViYXJyYXkob2Zmc2V0KSwgcHNpKTtcbiAgICB9XG4gIH07XG5cbiAgcGFyc2VQYXQgPSBmdW5jdGlvbihwYXlsb2FkLCBwYXQpIHtcbiAgICBwYXQuc2VjdGlvbl9udW1iZXIgPSBwYXlsb2FkWzddOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGNhbWVsY2FzZVxuICAgIHBhdC5sYXN0X3NlY3Rpb25fbnVtYmVyID0gcGF5bG9hZFs4XTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBjYW1lbGNhc2VcblxuICAgIC8vIHNraXAgdGhlIFBTSSBoZWFkZXIgYW5kIHBhcnNlIHRoZSBmaXJzdCBQTVQgZW50cnlcbiAgICBzZWxmLnBtdFBpZCA9IChwYXlsb2FkWzEwXSAmIDB4MUYpIDw8IDggfCBwYXlsb2FkWzExXTtcbiAgICBwYXQucG10UGlkID0gc2VsZi5wbXRQaWQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIFBhcnNlIG91dCB0aGUgcmVsZXZhbnQgZmllbGRzIG9mIGEgUHJvZ3JhbSBNYXAgVGFibGUgKFBNVCkuXG4gICAqIEBwYXJhbSBwYXlsb2FkIHtVaW50OEFycmF5fSB0aGUgUE1ULXNwZWNpZmljIHBvcnRpb24gb2YgYW4gTVAyVFxuICAgKiBwYWNrZXQuIFRoZSBmaXJzdCBieXRlIGluIHRoaXMgYXJyYXkgc2hvdWxkIGJlIHRoZSB0YWJsZV9pZFxuICAgKiBmaWVsZC5cbiAgICogQHBhcmFtIHBtdCB7b2JqZWN0fSB0aGUgb2JqZWN0IHRoYXQgc2hvdWxkIGJlIGRlY29yYXRlZCB3aXRoXG4gICAqIGZpZWxkcyBwYXJzZWQgZnJvbSB0aGUgUE1ULlxuICAgKi9cbiAgcGFyc2VQbXQgPSBmdW5jdGlvbihwYXlsb2FkLCBwbXQpIHtcbiAgICB2YXIgc2VjdGlvbkxlbmd0aCwgdGFibGVFbmQsIHByb2dyYW1JbmZvTGVuZ3RoLCBvZmZzZXQ7XG5cbiAgICAvLyBQTVRzIGNhbiBiZSBzZW50IGFoZWFkIG9mIHRoZSB0aW1lIHdoZW4gdGhleSBzaG91bGQgYWN0dWFsbHlcbiAgICAvLyB0YWtlIGVmZmVjdC4gV2UgZG9uJ3QgYmVsaWV2ZSB0aGlzIHNob3VsZCBldmVyIGJlIHRoZSBjYXNlXG4gICAgLy8gZm9yIEhMUyBidXQgd2UnbGwgaWdub3JlIFwiZm9yd2FyZFwiIFBNVCBkZWNsYXJhdGlvbnMgaWYgd2Ugc2VlXG4gICAgLy8gdGhlbS4gRnV0dXJlIFBNVCBkZWNsYXJhdGlvbnMgaGF2ZSB0aGUgY3VycmVudF9uZXh0X2luZGljYXRvclxuICAgIC8vIHNldCB0byB6ZXJvLlxuICAgIGlmICghKHBheWxvYWRbNV0gJiAweDAxKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIG92ZXJ3cml0ZSBhbnkgZXhpc3RpbmcgcHJvZ3JhbSBtYXAgdGFibGVcbiAgICBzZWxmLnByb2dyYW1NYXBUYWJsZSA9IHtcbiAgICAgIHZpZGVvOiBudWxsLFxuICAgICAgYXVkaW86IG51bGwsXG4gICAgICAndGltZWQtbWV0YWRhdGEnOiB7fVxuICAgIH07XG5cbiAgICAvLyB0aGUgbWFwcGluZyB0YWJsZSBlbmRzIGF0IHRoZSBlbmQgb2YgdGhlIGN1cnJlbnQgc2VjdGlvblxuICAgIHNlY3Rpb25MZW5ndGggPSAocGF5bG9hZFsxXSAmIDB4MGYpIDw8IDggfCBwYXlsb2FkWzJdO1xuICAgIHRhYmxlRW5kID0gMyArIHNlY3Rpb25MZW5ndGggLSA0O1xuXG4gICAgLy8gdG8gZGV0ZXJtaW5lIHdoZXJlIHRoZSB0YWJsZSBpcywgd2UgaGF2ZSB0byBmaWd1cmUgb3V0IGhvd1xuICAgIC8vIGxvbmcgdGhlIHByb2dyYW0gaW5mbyBkZXNjcmlwdG9ycyBhcmVcbiAgICBwcm9ncmFtSW5mb0xlbmd0aCA9IChwYXlsb2FkWzEwXSAmIDB4MGYpIDw8IDggfCBwYXlsb2FkWzExXTtcblxuICAgIC8vIGFkdmFuY2UgdGhlIG9mZnNldCB0byB0aGUgZmlyc3QgZW50cnkgaW4gdGhlIG1hcHBpbmcgdGFibGVcbiAgICBvZmZzZXQgPSAxMiArIHByb2dyYW1JbmZvTGVuZ3RoO1xuICAgIHdoaWxlIChvZmZzZXQgPCB0YWJsZUVuZCkge1xuICAgICAgdmFyIHN0cmVhbVR5cGUgPSBwYXlsb2FkW29mZnNldF07XG4gICAgICB2YXIgcGlkID0gKHBheWxvYWRbb2Zmc2V0ICsgMV0gJiAweDFGKSA8PCA4IHwgcGF5bG9hZFtvZmZzZXQgKyAyXTtcblxuICAgICAgLy8gb25seSBtYXAgYSBzaW5nbGUgZWxlbWVudGFyeV9waWQgZm9yIGF1ZGlvIGFuZCB2aWRlbyBzdHJlYW0gdHlwZXNcbiAgICAgIC8vIFRPRE86IHNob3VsZCB0aGlzIGJlIGRvbmUgZm9yIG1ldGFkYXRhIHRvbz8gZm9yIG5vdyBtYWludGFpbiBiZWhhdmlvciBvZlxuICAgICAgLy8gICAgICAgbXVsdGlwbGUgbWV0YWRhdGEgc3RyZWFtc1xuICAgICAgaWYgKHN0cmVhbVR5cGUgPT09IFN0cmVhbVR5cGVzLkgyNjRfU1RSRUFNX1RZUEUgJiZcbiAgICAgICAgICBzZWxmLnByb2dyYW1NYXBUYWJsZS52aWRlbyA9PT0gbnVsbCkge1xuICAgICAgICBzZWxmLnByb2dyYW1NYXBUYWJsZS52aWRlbyA9IHBpZDtcbiAgICAgIH0gZWxzZSBpZiAoc3RyZWFtVHlwZSA9PT0gU3RyZWFtVHlwZXMuQURUU19TVFJFQU1fVFlQRSAmJlxuICAgICAgICAgICAgICAgICBzZWxmLnByb2dyYW1NYXBUYWJsZS5hdWRpbyA9PT0gbnVsbCkge1xuICAgICAgICBzZWxmLnByb2dyYW1NYXBUYWJsZS5hdWRpbyA9IHBpZDtcbiAgICAgIH0gZWxzZSBpZiAoc3RyZWFtVHlwZSA9PT0gU3RyZWFtVHlwZXMuTUVUQURBVEFfU1RSRUFNX1RZUEUpIHtcbiAgICAgICAgLy8gbWFwIHBpZCB0byBzdHJlYW0gdHlwZSBmb3IgbWV0YWRhdGEgc3RyZWFtc1xuICAgICAgICBzZWxmLnByb2dyYW1NYXBUYWJsZVsndGltZWQtbWV0YWRhdGEnXVtwaWRdID0gc3RyZWFtVHlwZTtcbiAgICAgIH1cblxuICAgICAgLy8gbW92ZSB0byB0aGUgbmV4dCB0YWJsZSBlbnRyeVxuICAgICAgLy8gc2tpcCBwYXN0IHRoZSBlbGVtZW50YXJ5IHN0cmVhbSBkZXNjcmlwdG9ycywgaWYgcHJlc2VudFxuICAgICAgb2Zmc2V0ICs9ICgocGF5bG9hZFtvZmZzZXQgKyAzXSAmIDB4MEYpIDw8IDggfCBwYXlsb2FkW29mZnNldCArIDRdKSArIDU7XG4gICAgfVxuXG4gICAgLy8gcmVjb3JkIHRoZSBtYXAgb24gdGhlIHBhY2tldCBhcyB3ZWxsXG4gICAgcG10LnByb2dyYW1NYXBUYWJsZSA9IHNlbGYucHJvZ3JhbU1hcFRhYmxlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBEZWxpdmVyIGEgbmV3IE1QMlQgcGFja2V0IHRvIHRoZSBzdHJlYW0uXG4gICAqL1xuICB0aGlzLnB1c2ggPSBmdW5jdGlvbihwYWNrZXQpIHtcbiAgICB2YXJcbiAgICAgIHJlc3VsdCA9IHt9LFxuICAgICAgb2Zmc2V0ID0gNDtcblxuICAgIHJlc3VsdC5wYXlsb2FkVW5pdFN0YXJ0SW5kaWNhdG9yID0gISEocGFja2V0WzFdICYgMHg0MCk7XG5cbiAgICAvLyBwaWQgaXMgYSAxMy1iaXQgZmllbGQgc3RhcnRpbmcgYXQgdGhlIGxhc3QgYml0IG9mIHBhY2tldFsxXVxuICAgIHJlc3VsdC5waWQgPSBwYWNrZXRbMV0gJiAweDFmO1xuICAgIHJlc3VsdC5waWQgPDw9IDg7XG4gICAgcmVzdWx0LnBpZCB8PSBwYWNrZXRbMl07XG5cbiAgICAvLyBpZiBhbiBhZGFwdGlvbiBmaWVsZCBpcyBwcmVzZW50LCBpdHMgbGVuZ3RoIGlzIHNwZWNpZmllZCBieSB0aGVcbiAgICAvLyBmaWZ0aCBieXRlIG9mIHRoZSBUUyBwYWNrZXQgaGVhZGVyLiBUaGUgYWRhcHRhdGlvbiBmaWVsZCBpc1xuICAgIC8vIHVzZWQgdG8gYWRkIHN0dWZmaW5nIHRvIFBFUyBwYWNrZXRzIHRoYXQgZG9uJ3QgZmlsbCBhIGNvbXBsZXRlXG4gICAgLy8gVFMgcGFja2V0LCBhbmQgdG8gc3BlY2lmeSBzb21lIGZvcm1zIG9mIHRpbWluZyBhbmQgY29udHJvbCBkYXRhXG4gICAgLy8gdGhhdCB3ZSBkbyBub3QgY3VycmVudGx5IHVzZS5cbiAgICBpZiAoKChwYWNrZXRbM10gJiAweDMwKSA+Pj4gNCkgPiAweDAxKSB7XG4gICAgICBvZmZzZXQgKz0gcGFja2V0W29mZnNldF0gKyAxO1xuICAgIH1cblxuICAgIC8vIHBhcnNlIHRoZSByZXN0IG9mIHRoZSBwYWNrZXQgYmFzZWQgb24gdGhlIHR5cGVcbiAgICBpZiAocmVzdWx0LnBpZCA9PT0gMCkge1xuICAgICAgcmVzdWx0LnR5cGUgPSAncGF0JztcbiAgICAgIHBhcnNlUHNpKHBhY2tldC5zdWJhcnJheShvZmZzZXQpLCByZXN1bHQpO1xuICAgICAgdGhpcy50cmlnZ2VyKCdkYXRhJywgcmVzdWx0KTtcbiAgICB9IGVsc2UgaWYgKHJlc3VsdC5waWQgPT09IHRoaXMucG10UGlkKSB7XG4gICAgICByZXN1bHQudHlwZSA9ICdwbXQnO1xuICAgICAgcGFyc2VQc2kocGFja2V0LnN1YmFycmF5KG9mZnNldCksIHJlc3VsdCk7XG4gICAgICB0aGlzLnRyaWdnZXIoJ2RhdGEnLCByZXN1bHQpO1xuXG4gICAgICAvLyBpZiB0aGVyZSBhcmUgYW55IHBhY2tldHMgd2FpdGluZyBmb3IgYSBQTVQgdG8gYmUgZm91bmQsIHByb2Nlc3MgdGhlbSBub3dcbiAgICAgIHdoaWxlICh0aGlzLnBhY2tldHNXYWl0aW5nRm9yUG10Lmxlbmd0aCkge1xuICAgICAgICB0aGlzLnByb2Nlc3NQZXNfLmFwcGx5KHRoaXMsIHRoaXMucGFja2V0c1dhaXRpbmdGb3JQbXQuc2hpZnQoKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLnByb2dyYW1NYXBUYWJsZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBXaGVuIHdlIGhhdmUgbm90IHNlZW4gYSBQTVQgeWV0LCBkZWZlciBmdXJ0aGVyIHByb2Nlc3Npbmcgb2ZcbiAgICAgIC8vIFBFUyBwYWNrZXRzIHVudGlsIG9uZSBoYXMgYmVlbiBwYXJzZWRcbiAgICAgIHRoaXMucGFja2V0c1dhaXRpbmdGb3JQbXQucHVzaChbcGFja2V0LCBvZmZzZXQsIHJlc3VsdF0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnByb2Nlc3NQZXNfKHBhY2tldCwgb2Zmc2V0LCByZXN1bHQpO1xuICAgIH1cbiAgfTtcblxuICB0aGlzLnByb2Nlc3NQZXNfID0gZnVuY3Rpb24ocGFja2V0LCBvZmZzZXQsIHJlc3VsdCkge1xuICAgIC8vIHNldCB0aGUgYXBwcm9wcmlhdGUgc3RyZWFtIHR5cGVcbiAgICBpZiAocmVzdWx0LnBpZCA9PT0gdGhpcy5wcm9ncmFtTWFwVGFibGUudmlkZW8pIHtcbiAgICAgIHJlc3VsdC5zdHJlYW1UeXBlID0gU3RyZWFtVHlwZXMuSDI2NF9TVFJFQU1fVFlQRTtcbiAgICB9IGVsc2UgaWYgKHJlc3VsdC5waWQgPT09IHRoaXMucHJvZ3JhbU1hcFRhYmxlLmF1ZGlvKSB7XG4gICAgICByZXN1bHQuc3RyZWFtVHlwZSA9IFN0cmVhbVR5cGVzLkFEVFNfU1RSRUFNX1RZUEU7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGlmIG5vdCB2aWRlbyBvciBhdWRpbywgaXQgaXMgdGltZWQtbWV0YWRhdGEgb3IgdW5rbm93blxuICAgICAgLy8gaWYgdW5rbm93biwgc3RyZWFtVHlwZSB3aWxsIGJlIHVuZGVmaW5lZFxuICAgICAgcmVzdWx0LnN0cmVhbVR5cGUgPSB0aGlzLnByb2dyYW1NYXBUYWJsZVsndGltZWQtbWV0YWRhdGEnXVtyZXN1bHQucGlkXTtcbiAgICB9XG5cbiAgICByZXN1bHQudHlwZSA9ICdwZXMnO1xuICAgIHJlc3VsdC5kYXRhID0gcGFja2V0LnN1YmFycmF5KG9mZnNldCk7XG5cbiAgICB0aGlzLnRyaWdnZXIoJ2RhdGEnLCByZXN1bHQpO1xuICB9O1xuXG59O1xuVHJhbnNwb3J0UGFyc2VTdHJlYW0ucHJvdG90eXBlID0gbmV3IFN0cmVhbSgpO1xuVHJhbnNwb3J0UGFyc2VTdHJlYW0uU1RSRUFNX1RZUEVTICA9IHtcbiAgaDI2NDogMHgxYixcbiAgYWR0czogMHgwZlxufTtcblxuLyoqXG4gKiBSZWNvbnNpc3R1dGVzIHByb2dyYW0gZWxlbWVudGFyeSBzdHJlYW0gKFBFUykgcGFja2V0cyBmcm9tIHBhcnNlZFxuICogdHJhbnNwb3J0IHN0cmVhbSBwYWNrZXRzLiBUaGF0IGlzLCBpZiB5b3UgcGlwZSBhblxuICogbXAydC5UcmFuc3BvcnRQYXJzZVN0cmVhbSBpbnRvIGEgbXAydC5FbGVtZW50YXJ5U3RyZWFtLCB0aGUgb3V0cHV0XG4gKiBldmVudHMgd2lsbCBiZSBldmVudHMgd2hpY2ggY2FwdHVyZSB0aGUgYnl0ZXMgZm9yIGluZGl2aWR1YWwgUEVTXG4gKiBwYWNrZXRzIHBsdXMgcmVsZXZhbnQgbWV0YWRhdGEgdGhhdCBoYXMgYmVlbiBleHRyYWN0ZWQgZnJvbSB0aGVcbiAqIGNvbnRhaW5lci5cbiAqL1xuRWxlbWVudGFyeVN0cmVhbSA9IGZ1bmN0aW9uKCkge1xuICB2YXJcbiAgICBzZWxmID0gdGhpcyxcbiAgICAvLyBQRVMgcGFja2V0IGZyYWdtZW50c1xuICAgIHZpZGVvID0ge1xuICAgICAgZGF0YTogW10sXG4gICAgICBzaXplOiAwXG4gICAgfSxcbiAgICBhdWRpbyA9IHtcbiAgICAgIGRhdGE6IFtdLFxuICAgICAgc2l6ZTogMFxuICAgIH0sXG4gICAgdGltZWRNZXRhZGF0YSA9IHtcbiAgICAgIGRhdGE6IFtdLFxuICAgICAgc2l6ZTogMFxuICAgIH0sXG4gICAgcGFyc2VQZXMgPSBmdW5jdGlvbihwYXlsb2FkLCBwZXMpIHtcbiAgICAgIHZhciBwdHNEdHNGbGFncztcblxuICAgICAgLy8gZ2V0IHRoZSBwYWNrZXQgbGVuZ3RoLCB0aGlzIHdpbGwgYmUgMCBmb3IgdmlkZW9cbiAgICAgIHBlcy5wYWNrZXRMZW5ndGggPSA2ICsgKChwYXlsb2FkWzRdIDw8IDgpIHwgcGF5bG9hZFs1XSk7XG5cbiAgICAgIC8vIGZpbmQgb3V0IGlmIHRoaXMgcGFja2V0cyBzdGFydHMgYSBuZXcga2V5ZnJhbWVcbiAgICAgIHBlcy5kYXRhQWxpZ25tZW50SW5kaWNhdG9yID0gKHBheWxvYWRbNl0gJiAweDA0KSAhPT0gMDtcbiAgICAgIC8vIFBFUyBwYWNrZXRzIG1heSBiZSBhbm5vdGF0ZWQgd2l0aCBhIFBUUyB2YWx1ZSwgb3IgYSBQVFMgdmFsdWVcbiAgICAgIC8vIGFuZCBhIERUUyB2YWx1ZS4gRGV0ZXJtaW5lIHdoYXQgY29tYmluYXRpb24gb2YgdmFsdWVzIGlzXG4gICAgICAvLyBhdmFpbGFibGUgdG8gd29yayB3aXRoLlxuICAgICAgcHRzRHRzRmxhZ3MgPSBwYXlsb2FkWzddO1xuXG4gICAgICAvLyBQVFMgYW5kIERUUyBhcmUgbm9ybWFsbHkgc3RvcmVkIGFzIGEgMzMtYml0IG51bWJlci4gIEphdmFzY3JpcHRcbiAgICAgIC8vIHBlcmZvcm1zIGFsbCBiaXR3aXNlIG9wZXJhdGlvbnMgb24gMzItYml0IGludGVnZXJzIGJ1dCBqYXZhc2NyaXB0XG4gICAgICAvLyBzdXBwb3J0cyBhIG11Y2ggZ3JlYXRlciByYW5nZSAoNTItYml0cykgb2YgaW50ZWdlciB1c2luZyBzdGFuZGFyZFxuICAgICAgLy8gbWF0aGVtYXRpY2FsIG9wZXJhdGlvbnMuXG4gICAgICAvLyBXZSBjb25zdHJ1Y3QgYSAzMS1iaXQgdmFsdWUgdXNpbmcgYml0d2lzZSBvcGVyYXRvcnMgb3ZlciB0aGUgMzFcbiAgICAgIC8vIG1vc3Qgc2lnbmlmaWNhbnQgYml0cyBhbmQgdGhlbiBtdWx0aXBseSBieSA0IChlcXVhbCB0byBhIGxlZnQtc2hpZnRcbiAgICAgIC8vIG9mIDIpIGJlZm9yZSB3ZSBhZGQgdGhlIGZpbmFsIDIgbGVhc3Qgc2lnbmlmaWNhbnQgYml0cyBvZiB0aGVcbiAgICAgIC8vIHRpbWVzdGFtcCAoZXF1YWwgdG8gYW4gT1IuKVxuICAgICAgaWYgKHB0c0R0c0ZsYWdzICYgMHhDMCkge1xuICAgICAgICAvLyB0aGUgUFRTIGFuZCBEVFMgYXJlIG5vdCB3cml0dGVuIG91dCBkaXJlY3RseS4gRm9yIGluZm9ybWF0aW9uXG4gICAgICAgIC8vIG9uIGhvdyB0aGV5IGFyZSBlbmNvZGVkLCBzZWVcbiAgICAgICAgLy8gaHR0cDovL2R2ZC5zb3VyY2Vmb3JnZS5uZXQvZHZkaW5mby9wZXMtaGRyLmh0bWxcbiAgICAgICAgcGVzLnB0cyA9IChwYXlsb2FkWzldICYgMHgwRSkgPDwgMjcgfFxuICAgICAgICAgIChwYXlsb2FkWzEwXSAmIDB4RkYpIDw8IDIwIHxcbiAgICAgICAgICAocGF5bG9hZFsxMV0gJiAweEZFKSA8PCAxMiB8XG4gICAgICAgICAgKHBheWxvYWRbMTJdICYgMHhGRikgPDwgIDUgfFxuICAgICAgICAgIChwYXlsb2FkWzEzXSAmIDB4RkUpID4+PiAgMztcbiAgICAgICAgcGVzLnB0cyAqPSA0OyAvLyBMZWZ0IHNoaWZ0IGJ5IDJcbiAgICAgICAgcGVzLnB0cyArPSAocGF5bG9hZFsxM10gJiAweDA2KSA+Pj4gMTsgLy8gT1IgYnkgdGhlIHR3byBMU0JzXG4gICAgICAgIHBlcy5kdHMgPSBwZXMucHRzO1xuICAgICAgICBpZiAocHRzRHRzRmxhZ3MgJiAweDQwKSB7XG4gICAgICAgICAgcGVzLmR0cyA9IChwYXlsb2FkWzE0XSAmIDB4MEUpIDw8IDI3IHxcbiAgICAgICAgICAgIChwYXlsb2FkWzE1XSAmIDB4RkYpIDw8IDIwIHxcbiAgICAgICAgICAgIChwYXlsb2FkWzE2XSAmIDB4RkUpIDw8IDEyIHxcbiAgICAgICAgICAgIChwYXlsb2FkWzE3XSAmIDB4RkYpIDw8IDUgfFxuICAgICAgICAgICAgKHBheWxvYWRbMThdICYgMHhGRSkgPj4+IDM7XG4gICAgICAgICAgcGVzLmR0cyAqPSA0OyAvLyBMZWZ0IHNoaWZ0IGJ5IDJcbiAgICAgICAgICBwZXMuZHRzICs9IChwYXlsb2FkWzE4XSAmIDB4MDYpID4+PiAxOyAvLyBPUiBieSB0aGUgdHdvIExTQnNcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gdGhlIGRhdGEgc2VjdGlvbiBzdGFydHMgaW1tZWRpYXRlbHkgYWZ0ZXIgdGhlIFBFUyBoZWFkZXIuXG4gICAgICAvLyBwZXNfaGVhZGVyX2RhdGFfbGVuZ3RoIHNwZWNpZmllcyB0aGUgbnVtYmVyIG9mIGhlYWRlciBieXRlc1xuICAgICAgLy8gdGhhdCBmb2xsb3cgdGhlIGxhc3QgYnl0ZSBvZiB0aGUgZmllbGQuXG4gICAgICBwZXMuZGF0YSA9IHBheWxvYWQuc3ViYXJyYXkoOSArIHBheWxvYWRbOF0pO1xuICAgIH0sXG4gICAgZmx1c2hTdHJlYW0gPSBmdW5jdGlvbihzdHJlYW0sIHR5cGUsIGZvcmNlRmx1c2gpIHtcbiAgICAgIHZhclxuICAgICAgICBwYWNrZXREYXRhID0gbmV3IFVpbnQ4QXJyYXkoc3RyZWFtLnNpemUpLFxuICAgICAgICBldmVudCA9IHtcbiAgICAgICAgICB0eXBlOiB0eXBlXG4gICAgICAgIH0sXG4gICAgICAgIGkgPSAwLFxuICAgICAgICBvZmZzZXQgPSAwLFxuICAgICAgICBwYWNrZXRGbHVzaGFibGUgPSBmYWxzZSxcbiAgICAgICAgZnJhZ21lbnQ7XG5cbiAgICAgIC8vIGRvIG5vdGhpbmcgaWYgdGhlcmUgaXMgbm90IGVub3VnaCBidWZmZXJlZCBkYXRhIGZvciBhIGNvbXBsZXRlXG4gICAgICAvLyBQRVMgaGVhZGVyXG4gICAgICBpZiAoIXN0cmVhbS5kYXRhLmxlbmd0aCB8fCBzdHJlYW0uc2l6ZSA8IDkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZXZlbnQudHJhY2tJZCA9IHN0cmVhbS5kYXRhWzBdLnBpZDtcblxuICAgICAgLy8gcmVhc3NlbWJsZSB0aGUgcGFja2V0XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgc3RyZWFtLmRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZnJhZ21lbnQgPSBzdHJlYW0uZGF0YVtpXTtcblxuICAgICAgICBwYWNrZXREYXRhLnNldChmcmFnbWVudC5kYXRhLCBvZmZzZXQpO1xuICAgICAgICBvZmZzZXQgKz0gZnJhZ21lbnQuZGF0YS5ieXRlTGVuZ3RoO1xuICAgICAgfVxuXG4gICAgICAvLyBwYXJzZSBhc3NlbWJsZWQgcGFja2V0J3MgUEVTIGhlYWRlclxuICAgICAgcGFyc2VQZXMocGFja2V0RGF0YSwgZXZlbnQpO1xuXG4gICAgICAvLyBub24tdmlkZW8gUEVTIHBhY2tldHMgTVVTVCBoYXZlIGEgbm9uLXplcm8gUEVTX3BhY2tldF9sZW5ndGhcbiAgICAgIC8vIGNoZWNrIHRoYXQgdGhlcmUgaXMgZW5vdWdoIHN0cmVhbSBkYXRhIHRvIGZpbGwgdGhlIHBhY2tldFxuICAgICAgcGFja2V0Rmx1c2hhYmxlID0gdHlwZSA9PT0gJ3ZpZGVvJyB8fCBldmVudC5wYWNrZXRMZW5ndGggPD0gc3RyZWFtLnNpemU7XG5cbiAgICAgIC8vIGZsdXNoIHBlbmRpbmcgcGFja2V0cyBpZiB0aGUgY29uZGl0aW9ucyBhcmUgcmlnaHRcbiAgICAgIGlmIChmb3JjZUZsdXNoIHx8IHBhY2tldEZsdXNoYWJsZSkge1xuICAgICAgICBzdHJlYW0uc2l6ZSA9IDA7XG4gICAgICAgIHN0cmVhbS5kYXRhLmxlbmd0aCA9IDA7XG4gICAgICB9XG5cbiAgICAgIC8vIG9ubHkgZW1pdCBwYWNrZXRzIHRoYXQgYXJlIGNvbXBsZXRlLiB0aGlzIGlzIHRvIGF2b2lkIGFzc2VtYmxpbmdcbiAgICAgIC8vIGluY29tcGxldGUgUEVTIHBhY2tldHMgZHVlIHRvIHBvb3Igc2VnbWVudGF0aW9uXG4gICAgICBpZiAocGFja2V0Rmx1c2hhYmxlKSB7XG4gICAgICAgIHNlbGYudHJpZ2dlcignZGF0YScsIGV2ZW50KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gIEVsZW1lbnRhcnlTdHJlYW0ucHJvdG90eXBlLmluaXQuY2FsbCh0aGlzKTtcblxuICB0aGlzLnB1c2ggPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgKHtcbiAgICAgIHBhdDogZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIHdlIGhhdmUgdG8gd2FpdCBmb3IgdGhlIFBNVCB0byBhcnJpdmUgYXMgd2VsbCBiZWZvcmUgd2VcbiAgICAgICAgLy8gaGF2ZSBhbnkgbWVhbmluZ2Z1bCBtZXRhZGF0YVxuICAgICAgfSxcbiAgICAgIHBlczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzdHJlYW0sIHN0cmVhbVR5cGU7XG5cbiAgICAgICAgc3dpdGNoIChkYXRhLnN0cmVhbVR5cGUpIHtcbiAgICAgICAgY2FzZSBTdHJlYW1UeXBlcy5IMjY0X1NUUkVBTV9UWVBFOlxuICAgICAgICBjYXNlIG0ydHNTdHJlYW1UeXBlcy5IMjY0X1NUUkVBTV9UWVBFOlxuICAgICAgICAgIHN0cmVhbSA9IHZpZGVvO1xuICAgICAgICAgIHN0cmVhbVR5cGUgPSAndmlkZW8nO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFN0cmVhbVR5cGVzLkFEVFNfU1RSRUFNX1RZUEU6XG4gICAgICAgICAgc3RyZWFtID0gYXVkaW87XG4gICAgICAgICAgc3RyZWFtVHlwZSA9ICdhdWRpbyc7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgU3RyZWFtVHlwZXMuTUVUQURBVEFfU1RSRUFNX1RZUEU6XG4gICAgICAgICAgc3RyZWFtID0gdGltZWRNZXRhZGF0YTtcbiAgICAgICAgICBzdHJlYW1UeXBlID0gJ3RpbWVkLW1ldGFkYXRhJztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAvLyBpZ25vcmUgdW5rbm93biBzdHJlYW0gdHlwZXNcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiBhIG5ldyBwYWNrZXQgaXMgc3RhcnRpbmcsIHdlIGNhbiBmbHVzaCB0aGUgY29tcGxldGVkXG4gICAgICAgIC8vIHBhY2tldFxuICAgICAgICBpZiAoZGF0YS5wYXlsb2FkVW5pdFN0YXJ0SW5kaWNhdG9yKSB7XG4gICAgICAgICAgZmx1c2hTdHJlYW0oc3RyZWFtLCBzdHJlYW1UeXBlLCB0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGJ1ZmZlciB0aGlzIGZyYWdtZW50IHVudGlsIHdlIGFyZSBzdXJlIHdlJ3ZlIHJlY2VpdmVkIHRoZVxuICAgICAgICAvLyBjb21wbGV0ZSBwYXlsb2FkXG4gICAgICAgIHN0cmVhbS5kYXRhLnB1c2goZGF0YSk7XG4gICAgICAgIHN0cmVhbS5zaXplICs9IGRhdGEuZGF0YS5ieXRlTGVuZ3RoO1xuICAgICAgfSxcbiAgICAgIHBtdDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhclxuICAgICAgICAgIGV2ZW50ID0ge1xuICAgICAgICAgICAgdHlwZTogJ21ldGFkYXRhJyxcbiAgICAgICAgICAgIHRyYWNrczogW11cbiAgICAgICAgICB9LFxuICAgICAgICAgIHByb2dyYW1NYXBUYWJsZSA9IGRhdGEucHJvZ3JhbU1hcFRhYmxlO1xuXG4gICAgICAgIC8vIHRyYW5zbGF0ZSBhdWRpbyBhbmQgdmlkZW8gc3RyZWFtcyB0byB0cmFja3NcbiAgICAgICAgaWYgKHByb2dyYW1NYXBUYWJsZS52aWRlbyAhPT0gbnVsbCkge1xuICAgICAgICAgIGV2ZW50LnRyYWNrcy5wdXNoKHtcbiAgICAgICAgICAgIHRpbWVsaW5lU3RhcnRJbmZvOiB7XG4gICAgICAgICAgICAgIGJhc2VNZWRpYURlY29kZVRpbWU6IDBcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpZDogK3Byb2dyYW1NYXBUYWJsZS52aWRlbyxcbiAgICAgICAgICAgIGNvZGVjOiAnYXZjJyxcbiAgICAgICAgICAgIHR5cGU6ICd2aWRlbydcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvZ3JhbU1hcFRhYmxlLmF1ZGlvICE9PSBudWxsKSB7XG4gICAgICAgICAgZXZlbnQudHJhY2tzLnB1c2goe1xuICAgICAgICAgICAgdGltZWxpbmVTdGFydEluZm86IHtcbiAgICAgICAgICAgICAgYmFzZU1lZGlhRGVjb2RlVGltZTogMFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGlkOiArcHJvZ3JhbU1hcFRhYmxlLmF1ZGlvLFxuICAgICAgICAgICAgY29kZWM6ICdhZHRzJyxcbiAgICAgICAgICAgIHR5cGU6ICdhdWRpbydcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNlbGYudHJpZ2dlcignZGF0YScsIGV2ZW50KTtcbiAgICAgIH1cbiAgICB9KVtkYXRhLnR5cGVdKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEZsdXNoIGFueSByZW1haW5pbmcgaW5wdXQuIFZpZGVvIFBFUyBwYWNrZXRzIG1heSBiZSBvZiB2YXJpYWJsZVxuICAgKiBsZW5ndGguIE5vcm1hbGx5LCB0aGUgc3RhcnQgb2YgYSBuZXcgdmlkZW8gcGFja2V0IGNhbiB0cmlnZ2VyIHRoZVxuICAgKiBmaW5hbGl6YXRpb24gb2YgdGhlIHByZXZpb3VzIHBhY2tldC4gVGhhdCBpcyBub3QgcG9zc2libGUgaWYgbm9cbiAgICogbW9yZSB2aWRlbyBpcyBmb3J0aGNvbWluZywgaG93ZXZlci4gSW4gdGhhdCBjYXNlLCBzb21lIG90aGVyXG4gICAqIG1lY2hhbmlzbSAobGlrZSB0aGUgZW5kIG9mIHRoZSBmaWxlKSBoYXMgdG8gYmUgZW1wbG95ZWQuIFdoZW4gaXQgaXNcbiAgICogY2xlYXIgdGhhdCBubyBhZGRpdGlvbmFsIGRhdGEgaXMgZm9ydGhjb21pbmcsIGNhbGxpbmcgdGhpcyBtZXRob2RcbiAgICogd2lsbCBmbHVzaCB0aGUgYnVmZmVyZWQgcGFja2V0cy5cbiAgICovXG4gIHRoaXMuZmx1c2ggPSBmdW5jdGlvbigpIHtcbiAgICAvLyAhIVRISVMgT1JERVIgSVMgSU1QT1JUQU5UISFcbiAgICAvLyB2aWRlbyBmaXJzdCB0aGVuIGF1ZGlvXG4gICAgZmx1c2hTdHJlYW0odmlkZW8sICd2aWRlbycpO1xuICAgIGZsdXNoU3RyZWFtKGF1ZGlvLCAnYXVkaW8nKTtcbiAgICBmbHVzaFN0cmVhbSh0aW1lZE1ldGFkYXRhLCAndGltZWQtbWV0YWRhdGEnKTtcbiAgICB0aGlzLnRyaWdnZXIoJ2RvbmUnKTtcbiAgfTtcbn07XG5FbGVtZW50YXJ5U3RyZWFtLnByb3RvdHlwZSA9IG5ldyBTdHJlYW0oKTtcblxudmFyIG0ydHMgPSB7XG4gIFBBVF9QSUQ6IDB4MDAwMCxcbiAgTVAyVF9QQUNLRVRfTEVOR1RIOiBNUDJUX1BBQ0tFVF9MRU5HVEgsXG4gIFRyYW5zcG9ydFBhY2tldFN0cmVhbTogVHJhbnNwb3J0UGFja2V0U3RyZWFtLFxuICBUcmFuc3BvcnRQYXJzZVN0cmVhbTogVHJhbnNwb3J0UGFyc2VTdHJlYW0sXG4gIEVsZW1lbnRhcnlTdHJlYW06IEVsZW1lbnRhcnlTdHJlYW0sXG4gIFRpbWVzdGFtcFJvbGxvdmVyU3RyZWFtOiBUaW1lc3RhbXBSb2xsb3ZlclN0cmVhbSxcbiAgQ2FwdGlvblN0cmVhbTogQ2FwdGlvblN0cmVhbS5DYXB0aW9uU3RyZWFtLFxuICBDZWE2MDhTdHJlYW06IENhcHRpb25TdHJlYW0uQ2VhNjA4U3RyZWFtLFxuICBNZXRhZGF0YVN0cmVhbTogcmVxdWlyZSgnLi9tZXRhZGF0YS1zdHJlYW0nKVxufTtcblxuZm9yICh2YXIgdHlwZSBpbiBTdHJlYW1UeXBlcykge1xuICBpZiAoU3RyZWFtVHlwZXMuaGFzT3duUHJvcGVydHkodHlwZSkpIHtcbiAgICBtMnRzW3R5cGVdID0gU3RyZWFtVHlwZXNbdHlwZV07XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtMnRzO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/videojs-contrib-media-sources/node_modules/mux.js/lib/m2ts/m2ts.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/videojs-contrib-media-sources/node_modules/mux.js/lib/m2ts/metadata-stream.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/videojs-contrib-media-sources/node_modules/mux.js/lib/m2ts/metadata-stream.js ***!
  \****************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/**\n * Accepts program elementary stream (PES) data events and parses out\n * ID3 metadata from them, if present.\n * @see http://id3.org/id3v2.3.0\n */\n\nvar\n  Stream = __webpack_require__(/*! ../utils/stream */ \"(ssr)/./node_modules/videojs-contrib-media-sources/node_modules/mux.js/lib/utils/stream.js\"),\n  StreamTypes = __webpack_require__(/*! ./stream-types */ \"(ssr)/./node_modules/videojs-contrib-media-sources/node_modules/mux.js/lib/m2ts/stream-types.js\"),\n  // return a percent-encoded representation of the specified byte range\n  // @see http://en.wikipedia.org/wiki/Percent-encoding\n  percentEncode = function(bytes, start, end) {\n    var i, result = '';\n    for (i = start; i < end; i++) {\n      result += '%' + ('00' + bytes[i].toString(16)).slice(-2);\n    }\n    return result;\n  },\n  // return the string representation of the specified byte range,\n  // interpreted as UTf-8.\n  parseUtf8 = function(bytes, start, end) {\n    return decodeURIComponent(percentEncode(bytes, start, end));\n  },\n  // return the string representation of the specified byte range,\n  // interpreted as ISO-8859-1.\n  parseIso88591 = function(bytes, start, end) {\n    return unescape(percentEncode(bytes, start, end)); // jshint ignore:line\n  },\n  parseSyncSafeInteger = function(data) {\n    return (data[0] << 21) |\n            (data[1] << 14) |\n            (data[2] << 7) |\n            (data[3]);\n  },\n  tagParsers = {\n    TXXX: function(tag) {\n      var i;\n      if (tag.data[0] !== 3) {\n        // ignore frames with unrecognized character encodings\n        return;\n      }\n\n      for (i = 1; i < tag.data.length; i++) {\n        if (tag.data[i] === 0) {\n          // parse the text fields\n          tag.description = parseUtf8(tag.data, 1, i);\n          // do not include the null terminator in the tag value\n          tag.value = parseUtf8(tag.data, i + 1, tag.data.length).replace(/\\0*$/, '');\n          break;\n        }\n      }\n      tag.data = tag.value;\n    },\n    WXXX: function(tag) {\n      var i;\n      if (tag.data[0] !== 3) {\n        // ignore frames with unrecognized character encodings\n        return;\n      }\n\n      for (i = 1; i < tag.data.length; i++) {\n        if (tag.data[i] === 0) {\n          // parse the description and URL fields\n          tag.description = parseUtf8(tag.data, 1, i);\n          tag.url = parseUtf8(tag.data, i + 1, tag.data.length);\n          break;\n        }\n      }\n    },\n    PRIV: function(tag) {\n      var i;\n\n      for (i = 0; i < tag.data.length; i++) {\n        if (tag.data[i] === 0) {\n          // parse the description and URL fields\n          tag.owner = parseIso88591(tag.data, 0, i);\n          break;\n        }\n      }\n      tag.privateData = tag.data.subarray(i + 1);\n      tag.data = tag.privateData;\n    }\n  },\n  MetadataStream;\n\nMetadataStream = function(options) {\n  var\n    settings = {\n      debug: !!(options && options.debug),\n\n      // the bytes of the program-level descriptor field in MP2T\n      // see ISO/IEC 13818-1:2013 (E), section 2.6 \"Program and\n      // program element descriptors\"\n      descriptor: options && options.descriptor\n    },\n    // the total size in bytes of the ID3 tag being parsed\n    tagSize = 0,\n    // tag data that is not complete enough to be parsed\n    buffer = [],\n    // the total number of bytes currently in the buffer\n    bufferSize = 0,\n    i;\n\n  MetadataStream.prototype.init.call(this);\n\n  // calculate the text track in-band metadata track dispatch type\n  // https://html.spec.whatwg.org/multipage/embedded-content.html#steps-to-expose-a-media-resource-specific-text-track\n  this.dispatchType = StreamTypes.METADATA_STREAM_TYPE.toString(16);\n  if (settings.descriptor) {\n    for (i = 0; i < settings.descriptor.length; i++) {\n      this.dispatchType += ('00' + settings.descriptor[i].toString(16)).slice(-2);\n    }\n  }\n\n  this.push = function(chunk) {\n    var tag, frameStart, frameSize, frame, i, frameHeader;\n    if (chunk.type !== 'timed-metadata') {\n      return;\n    }\n\n    // if data_alignment_indicator is set in the PES header,\n    // we must have the start of a new ID3 tag. Assume anything\n    // remaining in the buffer was malformed and throw it out\n    if (chunk.dataAlignmentIndicator) {\n      bufferSize = 0;\n      buffer.length = 0;\n    }\n\n    // ignore events that don't look like ID3 data\n    if (buffer.length === 0 &&\n        (chunk.data.length < 10 ||\n          chunk.data[0] !== 'I'.charCodeAt(0) ||\n          chunk.data[1] !== 'D'.charCodeAt(0) ||\n          chunk.data[2] !== '3'.charCodeAt(0))) {\n      if (settings.debug) {\n        // eslint-disable-next-line no-console\n        console.log('Skipping unrecognized metadata packet');\n      }\n      return;\n    }\n\n    // add this chunk to the data we've collected so far\n\n    buffer.push(chunk);\n    bufferSize += chunk.data.byteLength;\n\n    // grab the size of the entire frame from the ID3 header\n    if (buffer.length === 1) {\n      // the frame size is transmitted as a 28-bit integer in the\n      // last four bytes of the ID3 header.\n      // The most significant bit of each byte is dropped and the\n      // results concatenated to recover the actual value.\n      tagSize = parseSyncSafeInteger(chunk.data.subarray(6, 10));\n\n      // ID3 reports the tag size excluding the header but it's more\n      // convenient for our comparisons to include it\n      tagSize += 10;\n    }\n\n    // if the entire frame has not arrived, wait for more data\n    if (bufferSize < tagSize) {\n      return;\n    }\n\n    // collect the entire frame so it can be parsed\n    tag = {\n      data: new Uint8Array(tagSize),\n      frames: [],\n      pts: buffer[0].pts,\n      dts: buffer[0].dts\n    };\n    for (i = 0; i < tagSize;) {\n      tag.data.set(buffer[0].data.subarray(0, tagSize - i), i);\n      i += buffer[0].data.byteLength;\n      bufferSize -= buffer[0].data.byteLength;\n      buffer.shift();\n    }\n\n    // find the start of the first frame and the end of the tag\n    frameStart = 10;\n    if (tag.data[5] & 0x40) {\n      // advance the frame start past the extended header\n      frameStart += 4; // header size field\n      frameStart += parseSyncSafeInteger(tag.data.subarray(10, 14));\n\n      // clip any padding off the end\n      tagSize -= parseSyncSafeInteger(tag.data.subarray(16, 20));\n    }\n\n    // parse one or more ID3 frames\n    // http://id3.org/id3v2.3.0#ID3v2_frame_overview\n    do {\n      // determine the number of bytes in this frame\n      frameSize = parseSyncSafeInteger(tag.data.subarray(frameStart + 4, frameStart + 8));\n      if (frameSize < 1) {\n         // eslint-disable-next-line no-console\n        return console.log('Malformed ID3 frame encountered. Skipping metadata parsing.');\n      }\n      frameHeader = String.fromCharCode(tag.data[frameStart],\n                                        tag.data[frameStart + 1],\n                                        tag.data[frameStart + 2],\n                                        tag.data[frameStart + 3]);\n\n\n      frame = {\n        id: frameHeader,\n        data: tag.data.subarray(frameStart + 10, frameStart + frameSize + 10)\n      };\n      frame.key = frame.id;\n      if (tagParsers[frame.id]) {\n        tagParsers[frame.id](frame);\n\n        // handle the special PRIV frame used to indicate the start\n        // time for raw AAC data\n        if (frame.owner === 'com.apple.streaming.transportStreamTimestamp') {\n          var\n            d = frame.data,\n            size = ((d[3] & 0x01)  << 30) |\n                   (d[4]  << 22) |\n                   (d[5] << 14) |\n                   (d[6] << 6) |\n                   (d[7] >>> 2);\n\n          size *= 4;\n          size += d[7] & 0x03;\n          frame.timeStamp = size;\n          // in raw AAC, all subsequent data will be timestamped based\n          // on the value of this frame\n          // we couldn't have known the appropriate pts and dts before\n          // parsing this ID3 tag so set those values now\n          if (tag.pts === undefined && tag.dts === undefined) {\n            tag.pts = frame.timeStamp;\n            tag.dts = frame.timeStamp;\n          }\n          this.trigger('timestamp', frame);\n        }\n      }\n      tag.frames.push(frame);\n\n      frameStart += 10; // advance past the frame header\n      frameStart += frameSize; // advance past the frame body\n    } while (frameStart < tagSize);\n    this.trigger('data', tag);\n  };\n};\nMetadataStream.prototype = new Stream();\n\nmodule.exports = MetadataStream;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdmlkZW9qcy1jb250cmliLW1lZGlhLXNvdXJjZXMvbm9kZV9tb2R1bGVzL211eC5qcy9saWIvbTJ0cy9tZXRhZGF0YS1zdHJlYW0uanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNhO0FBQ2I7QUFDQSxXQUFXLG1CQUFPLENBQUMsbUhBQWlCO0FBQ3BDLGdCQUFnQixtQkFBTyxDQUFDLHVIQUFnQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLHFCQUFxQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixxQkFBcUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQSxrQkFBa0IscUJBQXFCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixnQ0FBZ0M7QUFDaEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsWUFBWTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdCQUF3QjtBQUN4QiwrQkFBK0I7QUFDL0IsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktdjAtcHJvamVjdC8uL25vZGVfbW9kdWxlcy92aWRlb2pzLWNvbnRyaWItbWVkaWEtc291cmNlcy9ub2RlX21vZHVsZXMvbXV4LmpzL2xpYi9tMnRzL21ldGFkYXRhLXN0cmVhbS5qcz9hMDNiIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQWNjZXB0cyBwcm9ncmFtIGVsZW1lbnRhcnkgc3RyZWFtIChQRVMpIGRhdGEgZXZlbnRzIGFuZCBwYXJzZXMgb3V0XG4gKiBJRDMgbWV0YWRhdGEgZnJvbSB0aGVtLCBpZiBwcmVzZW50LlxuICogQHNlZSBodHRwOi8vaWQzLm9yZy9pZDN2Mi4zLjBcbiAqL1xuJ3VzZSBzdHJpY3QnO1xudmFyXG4gIFN0cmVhbSA9IHJlcXVpcmUoJy4uL3V0aWxzL3N0cmVhbScpLFxuICBTdHJlYW1UeXBlcyA9IHJlcXVpcmUoJy4vc3RyZWFtLXR5cGVzJyksXG4gIC8vIHJldHVybiBhIHBlcmNlbnQtZW5jb2RlZCByZXByZXNlbnRhdGlvbiBvZiB0aGUgc3BlY2lmaWVkIGJ5dGUgcmFuZ2VcbiAgLy8gQHNlZSBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1BlcmNlbnQtZW5jb2RpbmdcbiAgcGVyY2VudEVuY29kZSA9IGZ1bmN0aW9uKGJ5dGVzLCBzdGFydCwgZW5kKSB7XG4gICAgdmFyIGksIHJlc3VsdCA9ICcnO1xuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICAgIHJlc3VsdCArPSAnJScgKyAoJzAwJyArIGJ5dGVzW2ldLnRvU3RyaW5nKDE2KSkuc2xpY2UoLTIpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9LFxuICAvLyByZXR1cm4gdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgc3BlY2lmaWVkIGJ5dGUgcmFuZ2UsXG4gIC8vIGludGVycHJldGVkIGFzIFVUZi04LlxuICBwYXJzZVV0ZjggPSBmdW5jdGlvbihieXRlcywgc3RhcnQsIGVuZCkge1xuICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQocGVyY2VudEVuY29kZShieXRlcywgc3RhcnQsIGVuZCkpO1xuICB9LFxuICAvLyByZXR1cm4gdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgc3BlY2lmaWVkIGJ5dGUgcmFuZ2UsXG4gIC8vIGludGVycHJldGVkIGFzIElTTy04ODU5LTEuXG4gIHBhcnNlSXNvODg1OTEgPSBmdW5jdGlvbihieXRlcywgc3RhcnQsIGVuZCkge1xuICAgIHJldHVybiB1bmVzY2FwZShwZXJjZW50RW5jb2RlKGJ5dGVzLCBzdGFydCwgZW5kKSk7IC8vIGpzaGludCBpZ25vcmU6bGluZVxuICB9LFxuICBwYXJzZVN5bmNTYWZlSW50ZWdlciA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICByZXR1cm4gKGRhdGFbMF0gPDwgMjEpIHxcbiAgICAgICAgICAgIChkYXRhWzFdIDw8IDE0KSB8XG4gICAgICAgICAgICAoZGF0YVsyXSA8PCA3KSB8XG4gICAgICAgICAgICAoZGF0YVszXSk7XG4gIH0sXG4gIHRhZ1BhcnNlcnMgPSB7XG4gICAgVFhYWDogZnVuY3Rpb24odGFnKSB7XG4gICAgICB2YXIgaTtcbiAgICAgIGlmICh0YWcuZGF0YVswXSAhPT0gMykge1xuICAgICAgICAvLyBpZ25vcmUgZnJhbWVzIHdpdGggdW5yZWNvZ25pemVkIGNoYXJhY3RlciBlbmNvZGluZ3NcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGkgPSAxOyBpIDwgdGFnLmRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHRhZy5kYXRhW2ldID09PSAwKSB7XG4gICAgICAgICAgLy8gcGFyc2UgdGhlIHRleHQgZmllbGRzXG4gICAgICAgICAgdGFnLmRlc2NyaXB0aW9uID0gcGFyc2VVdGY4KHRhZy5kYXRhLCAxLCBpKTtcbiAgICAgICAgICAvLyBkbyBub3QgaW5jbHVkZSB0aGUgbnVsbCB0ZXJtaW5hdG9yIGluIHRoZSB0YWcgdmFsdWVcbiAgICAgICAgICB0YWcudmFsdWUgPSBwYXJzZVV0ZjgodGFnLmRhdGEsIGkgKyAxLCB0YWcuZGF0YS5sZW5ndGgpLnJlcGxhY2UoL1xcMCokLywgJycpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0YWcuZGF0YSA9IHRhZy52YWx1ZTtcbiAgICB9LFxuICAgIFdYWFg6IGZ1bmN0aW9uKHRhZykge1xuICAgICAgdmFyIGk7XG4gICAgICBpZiAodGFnLmRhdGFbMF0gIT09IDMpIHtcbiAgICAgICAgLy8gaWdub3JlIGZyYW1lcyB3aXRoIHVucmVjb2duaXplZCBjaGFyYWN0ZXIgZW5jb2RpbmdzXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgZm9yIChpID0gMTsgaSA8IHRhZy5kYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICh0YWcuZGF0YVtpXSA9PT0gMCkge1xuICAgICAgICAgIC8vIHBhcnNlIHRoZSBkZXNjcmlwdGlvbiBhbmQgVVJMIGZpZWxkc1xuICAgICAgICAgIHRhZy5kZXNjcmlwdGlvbiA9IHBhcnNlVXRmOCh0YWcuZGF0YSwgMSwgaSk7XG4gICAgICAgICAgdGFnLnVybCA9IHBhcnNlVXRmOCh0YWcuZGF0YSwgaSArIDEsIHRhZy5kYXRhLmxlbmd0aCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFBSSVY6IGZ1bmN0aW9uKHRhZykge1xuICAgICAgdmFyIGk7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCB0YWcuZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAodGFnLmRhdGFbaV0gPT09IDApIHtcbiAgICAgICAgICAvLyBwYXJzZSB0aGUgZGVzY3JpcHRpb24gYW5kIFVSTCBmaWVsZHNcbiAgICAgICAgICB0YWcub3duZXIgPSBwYXJzZUlzbzg4NTkxKHRhZy5kYXRhLCAwLCBpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGFnLnByaXZhdGVEYXRhID0gdGFnLmRhdGEuc3ViYXJyYXkoaSArIDEpO1xuICAgICAgdGFnLmRhdGEgPSB0YWcucHJpdmF0ZURhdGE7XG4gICAgfVxuICB9LFxuICBNZXRhZGF0YVN0cmVhbTtcblxuTWV0YWRhdGFTdHJlYW0gPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIHZhclxuICAgIHNldHRpbmdzID0ge1xuICAgICAgZGVidWc6ICEhKG9wdGlvbnMgJiYgb3B0aW9ucy5kZWJ1ZyksXG5cbiAgICAgIC8vIHRoZSBieXRlcyBvZiB0aGUgcHJvZ3JhbS1sZXZlbCBkZXNjcmlwdG9yIGZpZWxkIGluIE1QMlRcbiAgICAgIC8vIHNlZSBJU08vSUVDIDEzODE4LTE6MjAxMyAoRSksIHNlY3Rpb24gMi42IFwiUHJvZ3JhbSBhbmRcbiAgICAgIC8vIHByb2dyYW0gZWxlbWVudCBkZXNjcmlwdG9yc1wiXG4gICAgICBkZXNjcmlwdG9yOiBvcHRpb25zICYmIG9wdGlvbnMuZGVzY3JpcHRvclxuICAgIH0sXG4gICAgLy8gdGhlIHRvdGFsIHNpemUgaW4gYnl0ZXMgb2YgdGhlIElEMyB0YWcgYmVpbmcgcGFyc2VkXG4gICAgdGFnU2l6ZSA9IDAsXG4gICAgLy8gdGFnIGRhdGEgdGhhdCBpcyBub3QgY29tcGxldGUgZW5vdWdoIHRvIGJlIHBhcnNlZFxuICAgIGJ1ZmZlciA9IFtdLFxuICAgIC8vIHRoZSB0b3RhbCBudW1iZXIgb2YgYnl0ZXMgY3VycmVudGx5IGluIHRoZSBidWZmZXJcbiAgICBidWZmZXJTaXplID0gMCxcbiAgICBpO1xuXG4gIE1ldGFkYXRhU3RyZWFtLnByb3RvdHlwZS5pbml0LmNhbGwodGhpcyk7XG5cbiAgLy8gY2FsY3VsYXRlIHRoZSB0ZXh0IHRyYWNrIGluLWJhbmQgbWV0YWRhdGEgdHJhY2sgZGlzcGF0Y2ggdHlwZVxuICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9lbWJlZGRlZC1jb250ZW50Lmh0bWwjc3RlcHMtdG8tZXhwb3NlLWEtbWVkaWEtcmVzb3VyY2Utc3BlY2lmaWMtdGV4dC10cmFja1xuICB0aGlzLmRpc3BhdGNoVHlwZSA9IFN0cmVhbVR5cGVzLk1FVEFEQVRBX1NUUkVBTV9UWVBFLnRvU3RyaW5nKDE2KTtcbiAgaWYgKHNldHRpbmdzLmRlc2NyaXB0b3IpIHtcbiAgICBmb3IgKGkgPSAwOyBpIDwgc2V0dGluZ3MuZGVzY3JpcHRvci5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5kaXNwYXRjaFR5cGUgKz0gKCcwMCcgKyBzZXR0aW5ncy5kZXNjcmlwdG9yW2ldLnRvU3RyaW5nKDE2KSkuc2xpY2UoLTIpO1xuICAgIH1cbiAgfVxuXG4gIHRoaXMucHVzaCA9IGZ1bmN0aW9uKGNodW5rKSB7XG4gICAgdmFyIHRhZywgZnJhbWVTdGFydCwgZnJhbWVTaXplLCBmcmFtZSwgaSwgZnJhbWVIZWFkZXI7XG4gICAgaWYgKGNodW5rLnR5cGUgIT09ICd0aW1lZC1tZXRhZGF0YScpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBpZiBkYXRhX2FsaWdubWVudF9pbmRpY2F0b3IgaXMgc2V0IGluIHRoZSBQRVMgaGVhZGVyLFxuICAgIC8vIHdlIG11c3QgaGF2ZSB0aGUgc3RhcnQgb2YgYSBuZXcgSUQzIHRhZy4gQXNzdW1lIGFueXRoaW5nXG4gICAgLy8gcmVtYWluaW5nIGluIHRoZSBidWZmZXIgd2FzIG1hbGZvcm1lZCBhbmQgdGhyb3cgaXQgb3V0XG4gICAgaWYgKGNodW5rLmRhdGFBbGlnbm1lbnRJbmRpY2F0b3IpIHtcbiAgICAgIGJ1ZmZlclNpemUgPSAwO1xuICAgICAgYnVmZmVyLmxlbmd0aCA9IDA7XG4gICAgfVxuXG4gICAgLy8gaWdub3JlIGV2ZW50cyB0aGF0IGRvbid0IGxvb2sgbGlrZSBJRDMgZGF0YVxuICAgIGlmIChidWZmZXIubGVuZ3RoID09PSAwICYmXG4gICAgICAgIChjaHVuay5kYXRhLmxlbmd0aCA8IDEwIHx8XG4gICAgICAgICAgY2h1bmsuZGF0YVswXSAhPT0gJ0knLmNoYXJDb2RlQXQoMCkgfHxcbiAgICAgICAgICBjaHVuay5kYXRhWzFdICE9PSAnRCcuY2hhckNvZGVBdCgwKSB8fFxuICAgICAgICAgIGNodW5rLmRhdGFbMl0gIT09ICczJy5jaGFyQ29kZUF0KDApKSkge1xuICAgICAgaWYgKHNldHRpbmdzLmRlYnVnKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICAgIGNvbnNvbGUubG9nKCdTa2lwcGluZyB1bnJlY29nbml6ZWQgbWV0YWRhdGEgcGFja2V0Jyk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gYWRkIHRoaXMgY2h1bmsgdG8gdGhlIGRhdGEgd2UndmUgY29sbGVjdGVkIHNvIGZhclxuXG4gICAgYnVmZmVyLnB1c2goY2h1bmspO1xuICAgIGJ1ZmZlclNpemUgKz0gY2h1bmsuZGF0YS5ieXRlTGVuZ3RoO1xuXG4gICAgLy8gZ3JhYiB0aGUgc2l6ZSBvZiB0aGUgZW50aXJlIGZyYW1lIGZyb20gdGhlIElEMyBoZWFkZXJcbiAgICBpZiAoYnVmZmVyLmxlbmd0aCA9PT0gMSkge1xuICAgICAgLy8gdGhlIGZyYW1lIHNpemUgaXMgdHJhbnNtaXR0ZWQgYXMgYSAyOC1iaXQgaW50ZWdlciBpbiB0aGVcbiAgICAgIC8vIGxhc3QgZm91ciBieXRlcyBvZiB0aGUgSUQzIGhlYWRlci5cbiAgICAgIC8vIFRoZSBtb3N0IHNpZ25pZmljYW50IGJpdCBvZiBlYWNoIGJ5dGUgaXMgZHJvcHBlZCBhbmQgdGhlXG4gICAgICAvLyByZXN1bHRzIGNvbmNhdGVuYXRlZCB0byByZWNvdmVyIHRoZSBhY3R1YWwgdmFsdWUuXG4gICAgICB0YWdTaXplID0gcGFyc2VTeW5jU2FmZUludGVnZXIoY2h1bmsuZGF0YS5zdWJhcnJheSg2LCAxMCkpO1xuXG4gICAgICAvLyBJRDMgcmVwb3J0cyB0aGUgdGFnIHNpemUgZXhjbHVkaW5nIHRoZSBoZWFkZXIgYnV0IGl0J3MgbW9yZVxuICAgICAgLy8gY29udmVuaWVudCBmb3Igb3VyIGNvbXBhcmlzb25zIHRvIGluY2x1ZGUgaXRcbiAgICAgIHRhZ1NpemUgKz0gMTA7XG4gICAgfVxuXG4gICAgLy8gaWYgdGhlIGVudGlyZSBmcmFtZSBoYXMgbm90IGFycml2ZWQsIHdhaXQgZm9yIG1vcmUgZGF0YVxuICAgIGlmIChidWZmZXJTaXplIDwgdGFnU2l6ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGNvbGxlY3QgdGhlIGVudGlyZSBmcmFtZSBzbyBpdCBjYW4gYmUgcGFyc2VkXG4gICAgdGFnID0ge1xuICAgICAgZGF0YTogbmV3IFVpbnQ4QXJyYXkodGFnU2l6ZSksXG4gICAgICBmcmFtZXM6IFtdLFxuICAgICAgcHRzOiBidWZmZXJbMF0ucHRzLFxuICAgICAgZHRzOiBidWZmZXJbMF0uZHRzXG4gICAgfTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgdGFnU2l6ZTspIHtcbiAgICAgIHRhZy5kYXRhLnNldChidWZmZXJbMF0uZGF0YS5zdWJhcnJheSgwLCB0YWdTaXplIC0gaSksIGkpO1xuICAgICAgaSArPSBidWZmZXJbMF0uZGF0YS5ieXRlTGVuZ3RoO1xuICAgICAgYnVmZmVyU2l6ZSAtPSBidWZmZXJbMF0uZGF0YS5ieXRlTGVuZ3RoO1xuICAgICAgYnVmZmVyLnNoaWZ0KCk7XG4gICAgfVxuXG4gICAgLy8gZmluZCB0aGUgc3RhcnQgb2YgdGhlIGZpcnN0IGZyYW1lIGFuZCB0aGUgZW5kIG9mIHRoZSB0YWdcbiAgICBmcmFtZVN0YXJ0ID0gMTA7XG4gICAgaWYgKHRhZy5kYXRhWzVdICYgMHg0MCkge1xuICAgICAgLy8gYWR2YW5jZSB0aGUgZnJhbWUgc3RhcnQgcGFzdCB0aGUgZXh0ZW5kZWQgaGVhZGVyXG4gICAgICBmcmFtZVN0YXJ0ICs9IDQ7IC8vIGhlYWRlciBzaXplIGZpZWxkXG4gICAgICBmcmFtZVN0YXJ0ICs9IHBhcnNlU3luY1NhZmVJbnRlZ2VyKHRhZy5kYXRhLnN1YmFycmF5KDEwLCAxNCkpO1xuXG4gICAgICAvLyBjbGlwIGFueSBwYWRkaW5nIG9mZiB0aGUgZW5kXG4gICAgICB0YWdTaXplIC09IHBhcnNlU3luY1NhZmVJbnRlZ2VyKHRhZy5kYXRhLnN1YmFycmF5KDE2LCAyMCkpO1xuICAgIH1cblxuICAgIC8vIHBhcnNlIG9uZSBvciBtb3JlIElEMyBmcmFtZXNcbiAgICAvLyBodHRwOi8vaWQzLm9yZy9pZDN2Mi4zLjAjSUQzdjJfZnJhbWVfb3ZlcnZpZXdcbiAgICBkbyB7XG4gICAgICAvLyBkZXRlcm1pbmUgdGhlIG51bWJlciBvZiBieXRlcyBpbiB0aGlzIGZyYW1lXG4gICAgICBmcmFtZVNpemUgPSBwYXJzZVN5bmNTYWZlSW50ZWdlcih0YWcuZGF0YS5zdWJhcnJheShmcmFtZVN0YXJ0ICsgNCwgZnJhbWVTdGFydCArIDgpKTtcbiAgICAgIGlmIChmcmFtZVNpemUgPCAxKSB7XG4gICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgICByZXR1cm4gY29uc29sZS5sb2coJ01hbGZvcm1lZCBJRDMgZnJhbWUgZW5jb3VudGVyZWQuIFNraXBwaW5nIG1ldGFkYXRhIHBhcnNpbmcuJyk7XG4gICAgICB9XG4gICAgICBmcmFtZUhlYWRlciA9IFN0cmluZy5mcm9tQ2hhckNvZGUodGFnLmRhdGFbZnJhbWVTdGFydF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFnLmRhdGFbZnJhbWVTdGFydCArIDFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhZy5kYXRhW2ZyYW1lU3RhcnQgKyAyXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YWcuZGF0YVtmcmFtZVN0YXJ0ICsgM10pO1xuXG5cbiAgICAgIGZyYW1lID0ge1xuICAgICAgICBpZDogZnJhbWVIZWFkZXIsXG4gICAgICAgIGRhdGE6IHRhZy5kYXRhLnN1YmFycmF5KGZyYW1lU3RhcnQgKyAxMCwgZnJhbWVTdGFydCArIGZyYW1lU2l6ZSArIDEwKVxuICAgICAgfTtcbiAgICAgIGZyYW1lLmtleSA9IGZyYW1lLmlkO1xuICAgICAgaWYgKHRhZ1BhcnNlcnNbZnJhbWUuaWRdKSB7XG4gICAgICAgIHRhZ1BhcnNlcnNbZnJhbWUuaWRdKGZyYW1lKTtcblxuICAgICAgICAvLyBoYW5kbGUgdGhlIHNwZWNpYWwgUFJJViBmcmFtZSB1c2VkIHRvIGluZGljYXRlIHRoZSBzdGFydFxuICAgICAgICAvLyB0aW1lIGZvciByYXcgQUFDIGRhdGFcbiAgICAgICAgaWYgKGZyYW1lLm93bmVyID09PSAnY29tLmFwcGxlLnN0cmVhbWluZy50cmFuc3BvcnRTdHJlYW1UaW1lc3RhbXAnKSB7XG4gICAgICAgICAgdmFyXG4gICAgICAgICAgICBkID0gZnJhbWUuZGF0YSxcbiAgICAgICAgICAgIHNpemUgPSAoKGRbM10gJiAweDAxKSAgPDwgMzApIHxcbiAgICAgICAgICAgICAgICAgICAoZFs0XSAgPDwgMjIpIHxcbiAgICAgICAgICAgICAgICAgICAoZFs1XSA8PCAxNCkgfFxuICAgICAgICAgICAgICAgICAgIChkWzZdIDw8IDYpIHxcbiAgICAgICAgICAgICAgICAgICAoZFs3XSA+Pj4gMik7XG5cbiAgICAgICAgICBzaXplICo9IDQ7XG4gICAgICAgICAgc2l6ZSArPSBkWzddICYgMHgwMztcbiAgICAgICAgICBmcmFtZS50aW1lU3RhbXAgPSBzaXplO1xuICAgICAgICAgIC8vIGluIHJhdyBBQUMsIGFsbCBzdWJzZXF1ZW50IGRhdGEgd2lsbCBiZSB0aW1lc3RhbXBlZCBiYXNlZFxuICAgICAgICAgIC8vIG9uIHRoZSB2YWx1ZSBvZiB0aGlzIGZyYW1lXG4gICAgICAgICAgLy8gd2UgY291bGRuJ3QgaGF2ZSBrbm93biB0aGUgYXBwcm9wcmlhdGUgcHRzIGFuZCBkdHMgYmVmb3JlXG4gICAgICAgICAgLy8gcGFyc2luZyB0aGlzIElEMyB0YWcgc28gc2V0IHRob3NlIHZhbHVlcyBub3dcbiAgICAgICAgICBpZiAodGFnLnB0cyA9PT0gdW5kZWZpbmVkICYmIHRhZy5kdHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGFnLnB0cyA9IGZyYW1lLnRpbWVTdGFtcDtcbiAgICAgICAgICAgIHRhZy5kdHMgPSBmcmFtZS50aW1lU3RhbXA7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMudHJpZ2dlcigndGltZXN0YW1wJywgZnJhbWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0YWcuZnJhbWVzLnB1c2goZnJhbWUpO1xuXG4gICAgICBmcmFtZVN0YXJ0ICs9IDEwOyAvLyBhZHZhbmNlIHBhc3QgdGhlIGZyYW1lIGhlYWRlclxuICAgICAgZnJhbWVTdGFydCArPSBmcmFtZVNpemU7IC8vIGFkdmFuY2UgcGFzdCB0aGUgZnJhbWUgYm9keVxuICAgIH0gd2hpbGUgKGZyYW1lU3RhcnQgPCB0YWdTaXplKTtcbiAgICB0aGlzLnRyaWdnZXIoJ2RhdGEnLCB0YWcpO1xuICB9O1xufTtcbk1ldGFkYXRhU3RyZWFtLnByb3RvdHlwZSA9IG5ldyBTdHJlYW0oKTtcblxubW9kdWxlLmV4cG9ydHMgPSBNZXRhZGF0YVN0cmVhbTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/videojs-contrib-media-sources/node_modules/mux.js/lib/m2ts/metadata-stream.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/videojs-contrib-media-sources/node_modules/mux.js/lib/m2ts/stream-types.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/videojs-contrib-media-sources/node_modules/mux.js/lib/m2ts/stream-types.js ***!
  \*************************************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = {\n  H264_STREAM_TYPE: 0x1B,\n  ADTS_STREAM_TYPE: 0x0F,\n  METADATA_STREAM_TYPE: 0x15\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdmlkZW9qcy1jb250cmliLW1lZGlhLXNvdXJjZXMvbm9kZV9tb2R1bGVzL211eC5qcy9saWIvbTJ0cy9zdHJlYW0tdHlwZXMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL215LXYwLXByb2plY3QvLi9ub2RlX21vZHVsZXMvdmlkZW9qcy1jb250cmliLW1lZGlhLXNvdXJjZXMvbm9kZV9tb2R1bGVzL211eC5qcy9saWIvbTJ0cy9zdHJlYW0tdHlwZXMuanM/YWZjNSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBIMjY0X1NUUkVBTV9UWVBFOiAweDFCLFxuICBBRFRTX1NUUkVBTV9UWVBFOiAweDBGLFxuICBNRVRBREFUQV9TVFJFQU1fVFlQRTogMHgxNVxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/videojs-contrib-media-sources/node_modules/mux.js/lib/m2ts/stream-types.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/videojs-contrib-media-sources/node_modules/mux.js/lib/m2ts/timestamp-rollover-stream.js":
/*!**************************************************************************************************************!*\
  !*** ./node_modules/videojs-contrib-media-sources/node_modules/mux.js/lib/m2ts/timestamp-rollover-stream.js ***!
  \**************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/**\n * mux.js\n *\n * Copyright (c) 2016 Brightcove\n * All rights reserved.\n *\n * Accepts program elementary stream (PES) data events and corrects\n * decode and presentation time stamps to account for a rollover\n * of the 33 bit value.\n */\n\n\n\nvar Stream = __webpack_require__(/*! ../utils/stream */ \"(ssr)/./node_modules/videojs-contrib-media-sources/node_modules/mux.js/lib/utils/stream.js\");\n\nvar MAX_TS = 8589934592;\n\nvar RO_THRESH = 4294967296;\n\nvar handleRollover = function(value, reference) {\n  var direction = 1;\n\n  if (value > reference) {\n    // If the current timestamp value is greater than our reference timestamp and we detect a\n    // timestamp rollover, this means the roll over is happening in the opposite direction.\n    // Example scenario: Enter a long stream/video just after a rollover occurred. The reference\n    // point will be set to a small number, e.g. 1. The user then seeks backwards over the\n    // rollover point. In loading this segment, the timestamp values will be very large,\n    // e.g. 2^33 - 1. Since this comes before the data we loaded previously, we want to adjust\n    // the time stamp to be `value - 2^33`.\n    direction = -1;\n  }\n\n  // Note: A seek forwards or back that is greater than the RO_THRESH (2^32, ~13 hours) will\n  // cause an incorrect adjustment.\n  while (Math.abs(reference - value) > RO_THRESH) {\n    value += (direction * MAX_TS);\n  }\n\n  return value;\n};\n\nvar TimestampRolloverStream = function(type) {\n  var lastDTS, referenceDTS;\n\n  TimestampRolloverStream.prototype.init.call(this);\n\n  this.type_ = type;\n\n  this.push = function(data) {\n    if (data.type !== this.type_) {\n      return;\n    }\n\n    if (referenceDTS === undefined) {\n      referenceDTS = data.dts;\n    }\n\n    data.dts = handleRollover(data.dts, referenceDTS);\n    data.pts = handleRollover(data.pts, referenceDTS);\n\n    lastDTS = data.dts;\n\n    this.trigger('data', data);\n  };\n\n  this.flush = function() {\n    referenceDTS = lastDTS;\n    this.trigger('done');\n  };\n\n  this.discontinuity = function() {\n    referenceDTS = void 0;\n    lastDTS = void 0;\n  };\n\n};\n\nTimestampRolloverStream.prototype = new Stream();\n\nmodule.exports = {\n  TimestampRolloverStream: TimestampRolloverStream,\n  handleRollover: handleRollover\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdmlkZW9qcy1jb250cmliLW1lZGlhLXNvdXJjZXMvbm9kZV9tb2R1bGVzL211eC5qcy9saWIvbTJ0cy90aW1lc3RhbXAtcm9sbG92ZXItc3RyZWFtLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVhOztBQUViLGFBQWEsbUJBQU8sQ0FBQyxtSEFBaUI7O0FBRXRDOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL215LXYwLXByb2plY3QvLi9ub2RlX21vZHVsZXMvdmlkZW9qcy1jb250cmliLW1lZGlhLXNvdXJjZXMvbm9kZV9tb2R1bGVzL211eC5qcy9saWIvbTJ0cy90aW1lc3RhbXAtcm9sbG92ZXItc3RyZWFtLmpzP2Y3N2YiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBtdXguanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYgQnJpZ2h0Y292ZVxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBBY2NlcHRzIHByb2dyYW0gZWxlbWVudGFyeSBzdHJlYW0gKFBFUykgZGF0YSBldmVudHMgYW5kIGNvcnJlY3RzXG4gKiBkZWNvZGUgYW5kIHByZXNlbnRhdGlvbiB0aW1lIHN0YW1wcyB0byBhY2NvdW50IGZvciBhIHJvbGxvdmVyXG4gKiBvZiB0aGUgMzMgYml0IHZhbHVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFN0cmVhbSA9IHJlcXVpcmUoJy4uL3V0aWxzL3N0cmVhbScpO1xuXG52YXIgTUFYX1RTID0gODU4OTkzNDU5MjtcblxudmFyIFJPX1RIUkVTSCA9IDQyOTQ5NjcyOTY7XG5cbnZhciBoYW5kbGVSb2xsb3ZlciA9IGZ1bmN0aW9uKHZhbHVlLCByZWZlcmVuY2UpIHtcbiAgdmFyIGRpcmVjdGlvbiA9IDE7XG5cbiAgaWYgKHZhbHVlID4gcmVmZXJlbmNlKSB7XG4gICAgLy8gSWYgdGhlIGN1cnJlbnQgdGltZXN0YW1wIHZhbHVlIGlzIGdyZWF0ZXIgdGhhbiBvdXIgcmVmZXJlbmNlIHRpbWVzdGFtcCBhbmQgd2UgZGV0ZWN0IGFcbiAgICAvLyB0aW1lc3RhbXAgcm9sbG92ZXIsIHRoaXMgbWVhbnMgdGhlIHJvbGwgb3ZlciBpcyBoYXBwZW5pbmcgaW4gdGhlIG9wcG9zaXRlIGRpcmVjdGlvbi5cbiAgICAvLyBFeGFtcGxlIHNjZW5hcmlvOiBFbnRlciBhIGxvbmcgc3RyZWFtL3ZpZGVvIGp1c3QgYWZ0ZXIgYSByb2xsb3ZlciBvY2N1cnJlZC4gVGhlIHJlZmVyZW5jZVxuICAgIC8vIHBvaW50IHdpbGwgYmUgc2V0IHRvIGEgc21hbGwgbnVtYmVyLCBlLmcuIDEuIFRoZSB1c2VyIHRoZW4gc2Vla3MgYmFja3dhcmRzIG92ZXIgdGhlXG4gICAgLy8gcm9sbG92ZXIgcG9pbnQuIEluIGxvYWRpbmcgdGhpcyBzZWdtZW50LCB0aGUgdGltZXN0YW1wIHZhbHVlcyB3aWxsIGJlIHZlcnkgbGFyZ2UsXG4gICAgLy8gZS5nLiAyXjMzIC0gMS4gU2luY2UgdGhpcyBjb21lcyBiZWZvcmUgdGhlIGRhdGEgd2UgbG9hZGVkIHByZXZpb3VzbHksIHdlIHdhbnQgdG8gYWRqdXN0XG4gICAgLy8gdGhlIHRpbWUgc3RhbXAgdG8gYmUgYHZhbHVlIC0gMl4zM2AuXG4gICAgZGlyZWN0aW9uID0gLTE7XG4gIH1cblxuICAvLyBOb3RlOiBBIHNlZWsgZm9yd2FyZHMgb3IgYmFjayB0aGF0IGlzIGdyZWF0ZXIgdGhhbiB0aGUgUk9fVEhSRVNIICgyXjMyLCB+MTMgaG91cnMpIHdpbGxcbiAgLy8gY2F1c2UgYW4gaW5jb3JyZWN0IGFkanVzdG1lbnQuXG4gIHdoaWxlIChNYXRoLmFicyhyZWZlcmVuY2UgLSB2YWx1ZSkgPiBST19USFJFU0gpIHtcbiAgICB2YWx1ZSArPSAoZGlyZWN0aW9uICogTUFYX1RTKTtcbiAgfVxuXG4gIHJldHVybiB2YWx1ZTtcbn07XG5cbnZhciBUaW1lc3RhbXBSb2xsb3ZlclN0cmVhbSA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgdmFyIGxhc3REVFMsIHJlZmVyZW5jZURUUztcblxuICBUaW1lc3RhbXBSb2xsb3ZlclN0cmVhbS5wcm90b3R5cGUuaW5pdC5jYWxsKHRoaXMpO1xuXG4gIHRoaXMudHlwZV8gPSB0eXBlO1xuXG4gIHRoaXMucHVzaCA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICBpZiAoZGF0YS50eXBlICE9PSB0aGlzLnR5cGVfKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHJlZmVyZW5jZURUUyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZWZlcmVuY2VEVFMgPSBkYXRhLmR0cztcbiAgICB9XG5cbiAgICBkYXRhLmR0cyA9IGhhbmRsZVJvbGxvdmVyKGRhdGEuZHRzLCByZWZlcmVuY2VEVFMpO1xuICAgIGRhdGEucHRzID0gaGFuZGxlUm9sbG92ZXIoZGF0YS5wdHMsIHJlZmVyZW5jZURUUyk7XG5cbiAgICBsYXN0RFRTID0gZGF0YS5kdHM7XG5cbiAgICB0aGlzLnRyaWdnZXIoJ2RhdGEnLCBkYXRhKTtcbiAgfTtcblxuICB0aGlzLmZsdXNoID0gZnVuY3Rpb24oKSB7XG4gICAgcmVmZXJlbmNlRFRTID0gbGFzdERUUztcbiAgICB0aGlzLnRyaWdnZXIoJ2RvbmUnKTtcbiAgfTtcblxuICB0aGlzLmRpc2NvbnRpbnVpdHkgPSBmdW5jdGlvbigpIHtcbiAgICByZWZlcmVuY2VEVFMgPSB2b2lkIDA7XG4gICAgbGFzdERUUyA9IHZvaWQgMDtcbiAgfTtcblxufTtcblxuVGltZXN0YW1wUm9sbG92ZXJTdHJlYW0ucHJvdG90eXBlID0gbmV3IFN0cmVhbSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgVGltZXN0YW1wUm9sbG92ZXJTdHJlYW06IFRpbWVzdGFtcFJvbGxvdmVyU3RyZWFtLFxuICBoYW5kbGVSb2xsb3ZlcjogaGFuZGxlUm9sbG92ZXJcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/videojs-contrib-media-sources/node_modules/mux.js/lib/m2ts/timestamp-rollover-stream.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/videojs-contrib-media-sources/node_modules/mux.js/lib/mp4/index.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/videojs-contrib-media-sources/node_modules/mux.js/lib/mp4/index.js ***!
  \*****************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = {\n  generator: __webpack_require__(/*! ./mp4-generator */ \"(ssr)/./node_modules/videojs-contrib-media-sources/node_modules/mux.js/lib/mp4/mp4-generator.js\"),\n  Transmuxer: (__webpack_require__(/*! ./transmuxer */ \"(ssr)/./node_modules/videojs-contrib-media-sources/node_modules/mux.js/lib/mp4/transmuxer.js\").Transmuxer),\n  AudioSegmentStream: (__webpack_require__(/*! ./transmuxer */ \"(ssr)/./node_modules/videojs-contrib-media-sources/node_modules/mux.js/lib/mp4/transmuxer.js\").AudioSegmentStream),\n  VideoSegmentStream: (__webpack_require__(/*! ./transmuxer */ \"(ssr)/./node_modules/videojs-contrib-media-sources/node_modules/mux.js/lib/mp4/transmuxer.js\").VideoSegmentStream)\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdmlkZW9qcy1jb250cmliLW1lZGlhLXNvdXJjZXMvbm9kZV9tb2R1bGVzL211eC5qcy9saWIvbXA0L2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0EsYUFBYSxtQkFBTyxDQUFDLHdIQUFpQjtBQUN0QyxjQUFjLG9KQUFrQztBQUNoRCxzQkFBc0IsNEpBQTBDO0FBQ2hFLHNCQUFzQiw0SkFBMEM7QUFDaEUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS12MC1wcm9qZWN0Ly4vbm9kZV9tb2R1bGVzL3ZpZGVvanMtY29udHJpYi1tZWRpYS1zb3VyY2VzL25vZGVfbW9kdWxlcy9tdXguanMvbGliL21wNC9pbmRleC5qcz83MmE1Il0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0ge1xuICBnZW5lcmF0b3I6IHJlcXVpcmUoJy4vbXA0LWdlbmVyYXRvcicpLFxuICBUcmFuc211eGVyOiByZXF1aXJlKCcuL3RyYW5zbXV4ZXInKS5UcmFuc211eGVyLFxuICBBdWRpb1NlZ21lbnRTdHJlYW06IHJlcXVpcmUoJy4vdHJhbnNtdXhlcicpLkF1ZGlvU2VnbWVudFN0cmVhbSxcbiAgVmlkZW9TZWdtZW50U3RyZWFtOiByZXF1aXJlKCcuL3RyYW5zbXV4ZXInKS5WaWRlb1NlZ21lbnRTdHJlYW1cbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/videojs-contrib-media-sources/node_modules/mux.js/lib/mp4/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/videojs-contrib-media-sources/node_modules/mux.js/lib/mp4/mp4-generator.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/videojs-contrib-media-sources/node_modules/mux.js/lib/mp4/mp4-generator.js ***!
  \*************************************************************************************************/
/***/ ((module) => {

"use strict";
eval("/**\n * mux.js\n *\n * Copyright (c) 2015 Brightcove\n * All rights reserved.\n *\n * Functions that generate fragmented MP4s suitable for use with Media\n * Source Extensions.\n */\n\n\nvar UINT32_MAX = Math.pow(2, 32) - 1;\n\nvar box, dinf, esds, ftyp, mdat, mfhd, minf, moof, moov, mvex, mvhd,\n    trak, tkhd, mdia, mdhd, hdlr, sdtp, stbl, stsd, traf, trex,\n    trun, types, MAJOR_BRAND, MINOR_VERSION, AVC1_BRAND, VIDEO_HDLR,\n    AUDIO_HDLR, HDLR_TYPES, VMHD, SMHD, DREF, STCO, STSC, STSZ, STTS;\n\n// pre-calculate constants\n(function() {\n  var i;\n  types = {\n    avc1: [], // codingname\n    avcC: [],\n    btrt: [],\n    dinf: [],\n    dref: [],\n    esds: [],\n    ftyp: [],\n    hdlr: [],\n    mdat: [],\n    mdhd: [],\n    mdia: [],\n    mfhd: [],\n    minf: [],\n    moof: [],\n    moov: [],\n    mp4a: [], // codingname\n    mvex: [],\n    mvhd: [],\n    sdtp: [],\n    smhd: [],\n    stbl: [],\n    stco: [],\n    stsc: [],\n    stsd: [],\n    stsz: [],\n    stts: [],\n    styp: [],\n    tfdt: [],\n    tfhd: [],\n    traf: [],\n    trak: [],\n    trun: [],\n    trex: [],\n    tkhd: [],\n    vmhd: []\n  };\n\n  // In environments where Uint8Array is undefined (e.g., IE8), skip set up so that we\n  // don't throw an error\n  if (typeof Uint8Array === 'undefined') {\n    return;\n  }\n\n  for (i in types) {\n    if (types.hasOwnProperty(i)) {\n      types[i] = [\n        i.charCodeAt(0),\n        i.charCodeAt(1),\n        i.charCodeAt(2),\n        i.charCodeAt(3)\n      ];\n    }\n  }\n\n  MAJOR_BRAND = new Uint8Array([\n    'i'.charCodeAt(0),\n    's'.charCodeAt(0),\n    'o'.charCodeAt(0),\n    'm'.charCodeAt(0)\n  ]);\n  AVC1_BRAND = new Uint8Array([\n    'a'.charCodeAt(0),\n    'v'.charCodeAt(0),\n    'c'.charCodeAt(0),\n    '1'.charCodeAt(0)\n  ]);\n  MINOR_VERSION = new Uint8Array([0, 0, 0, 1]);\n  VIDEO_HDLR = new Uint8Array([\n    0x00, // version 0\n    0x00, 0x00, 0x00, // flags\n    0x00, 0x00, 0x00, 0x00, // pre_defined\n    0x76, 0x69, 0x64, 0x65, // handler_type: 'vide'\n    0x00, 0x00, 0x00, 0x00, // reserved\n    0x00, 0x00, 0x00, 0x00, // reserved\n    0x00, 0x00, 0x00, 0x00, // reserved\n    0x56, 0x69, 0x64, 0x65,\n    0x6f, 0x48, 0x61, 0x6e,\n    0x64, 0x6c, 0x65, 0x72, 0x00 // name: 'VideoHandler'\n  ]);\n  AUDIO_HDLR = new Uint8Array([\n    0x00, // version 0\n    0x00, 0x00, 0x00, // flags\n    0x00, 0x00, 0x00, 0x00, // pre_defined\n    0x73, 0x6f, 0x75, 0x6e, // handler_type: 'soun'\n    0x00, 0x00, 0x00, 0x00, // reserved\n    0x00, 0x00, 0x00, 0x00, // reserved\n    0x00, 0x00, 0x00, 0x00, // reserved\n    0x53, 0x6f, 0x75, 0x6e,\n    0x64, 0x48, 0x61, 0x6e,\n    0x64, 0x6c, 0x65, 0x72, 0x00 // name: 'SoundHandler'\n  ]);\n  HDLR_TYPES = {\n    video: VIDEO_HDLR,\n    audio: AUDIO_HDLR\n  };\n  DREF = new Uint8Array([\n    0x00, // version 0\n    0x00, 0x00, 0x00, // flags\n    0x00, 0x00, 0x00, 0x01, // entry_count\n    0x00, 0x00, 0x00, 0x0c, // entry_size\n    0x75, 0x72, 0x6c, 0x20, // 'url' type\n    0x00, // version 0\n    0x00, 0x00, 0x01 // entry_flags\n  ]);\n  SMHD = new Uint8Array([\n    0x00,             // version\n    0x00, 0x00, 0x00, // flags\n    0x00, 0x00,       // balance, 0 means centered\n    0x00, 0x00        // reserved\n  ]);\n  STCO = new Uint8Array([\n    0x00, // version\n    0x00, 0x00, 0x00, // flags\n    0x00, 0x00, 0x00, 0x00 // entry_count\n  ]);\n  STSC = STCO;\n  STSZ = new Uint8Array([\n    0x00, // version\n    0x00, 0x00, 0x00, // flags\n    0x00, 0x00, 0x00, 0x00, // sample_size\n    0x00, 0x00, 0x00, 0x00 // sample_count\n  ]);\n  STTS = STCO;\n  VMHD = new Uint8Array([\n    0x00, // version\n    0x00, 0x00, 0x01, // flags\n    0x00, 0x00, // graphicsmode\n    0x00, 0x00,\n    0x00, 0x00,\n    0x00, 0x00 // opcolor\n  ]);\n}());\n\nbox = function(type) {\n  var\n    payload = [],\n    size = 0,\n    i,\n    result,\n    view;\n\n  for (i = 1; i < arguments.length; i++) {\n    payload.push(arguments[i]);\n  }\n\n  i = payload.length;\n\n  // calculate the total size we need to allocate\n  while (i--) {\n    size += payload[i].byteLength;\n  }\n  result = new Uint8Array(size + 8);\n  view = new DataView(result.buffer, result.byteOffset, result.byteLength);\n  view.setUint32(0, result.byteLength);\n  result.set(type, 4);\n\n  // copy the payload into the result\n  for (i = 0, size = 8; i < payload.length; i++) {\n    result.set(payload[i], size);\n    size += payload[i].byteLength;\n  }\n  return result;\n};\n\ndinf = function() {\n  return box(types.dinf, box(types.dref, DREF));\n};\n\nesds = function(track) {\n  return box(types.esds, new Uint8Array([\n    0x00, // version\n    0x00, 0x00, 0x00, // flags\n\n    // ES_Descriptor\n    0x03, // tag, ES_DescrTag\n    0x19, // length\n    0x00, 0x00, // ES_ID\n    0x00, // streamDependenceFlag, URL_flag, reserved, streamPriority\n\n    // DecoderConfigDescriptor\n    0x04, // tag, DecoderConfigDescrTag\n    0x11, // length\n    0x40, // object type\n    0x15,  // streamType\n    0x00, 0x06, 0x00, // bufferSizeDB\n    0x00, 0x00, 0xda, 0xc0, // maxBitrate\n    0x00, 0x00, 0xda, 0xc0, // avgBitrate\n\n    // DecoderSpecificInfo\n    0x05, // tag, DecoderSpecificInfoTag\n    0x02, // length\n    // ISO/IEC 14496-3, AudioSpecificConfig\n    // for samplingFrequencyIndex see ISO/IEC 13818-7:2006, 8.1.3.2.2, Table 35\n    (track.audioobjecttype << 3) | (track.samplingfrequencyindex >>> 1),\n    (track.samplingfrequencyindex << 7) | (track.channelcount << 3),\n    0x06, 0x01, 0x02 // GASpecificConfig\n  ]));\n};\n\nftyp = function() {\n  return box(types.ftyp, MAJOR_BRAND, MINOR_VERSION, MAJOR_BRAND, AVC1_BRAND);\n};\n\nhdlr = function(type) {\n  return box(types.hdlr, HDLR_TYPES[type]);\n};\nmdat = function(data) {\n  return box(types.mdat, data);\n};\nmdhd = function(track) {\n  var result = new Uint8Array([\n    0x00,                   // version 0\n    0x00, 0x00, 0x00,       // flags\n    0x00, 0x00, 0x00, 0x02, // creation_time\n    0x00, 0x00, 0x00, 0x03, // modification_time\n    0x00, 0x01, 0x5f, 0x90, // timescale, 90,000 \"ticks\" per second\n\n    (track.duration >>> 24) & 0xFF,\n    (track.duration >>> 16) & 0xFF,\n    (track.duration >>>  8) & 0xFF,\n    track.duration & 0xFF,  // duration\n    0x55, 0xc4,             // 'und' language (undetermined)\n    0x00, 0x00\n  ]);\n\n  // Use the sample rate from the track metadata, when it is\n  // defined. The sample rate can be parsed out of an ADTS header, for\n  // instance.\n  if (track.samplerate) {\n    result[12] = (track.samplerate >>> 24) & 0xFF;\n    result[13] = (track.samplerate >>> 16) & 0xFF;\n    result[14] = (track.samplerate >>>  8) & 0xFF;\n    result[15] = (track.samplerate)        & 0xFF;\n  }\n\n  return box(types.mdhd, result);\n};\nmdia = function(track) {\n  return box(types.mdia, mdhd(track), hdlr(track.type), minf(track));\n};\nmfhd = function(sequenceNumber) {\n  return box(types.mfhd, new Uint8Array([\n    0x00,\n    0x00, 0x00, 0x00, // flags\n    (sequenceNumber & 0xFF000000) >> 24,\n    (sequenceNumber & 0xFF0000) >> 16,\n    (sequenceNumber & 0xFF00) >> 8,\n    sequenceNumber & 0xFF // sequence_number\n  ]));\n};\nminf = function(track) {\n  return box(types.minf,\n             track.type === 'video' ? box(types.vmhd, VMHD) : box(types.smhd, SMHD),\n             dinf(),\n             stbl(track));\n};\nmoof = function(sequenceNumber, tracks) {\n  var\n    trackFragments = [],\n    i = tracks.length;\n  // build traf boxes for each track fragment\n  while (i--) {\n    trackFragments[i] = traf(tracks[i]);\n  }\n  return box.apply(null, [\n    types.moof,\n    mfhd(sequenceNumber)\n  ].concat(trackFragments));\n};\n/**\n * Returns a movie box.\n * @param tracks {array} the tracks associated with this movie\n * @see ISO/IEC 14496-12:2012(E), section 8.2.1\n */\nmoov = function(tracks) {\n  var\n    i = tracks.length,\n    boxes = [];\n\n  while (i--) {\n    boxes[i] = trak(tracks[i]);\n  }\n\n  return box.apply(null, [types.moov, mvhd(0xffffffff)].concat(boxes).concat(mvex(tracks)));\n};\nmvex = function(tracks) {\n  var\n    i = tracks.length,\n    boxes = [];\n\n  while (i--) {\n    boxes[i] = trex(tracks[i]);\n  }\n  return box.apply(null, [types.mvex].concat(boxes));\n};\nmvhd = function(duration) {\n  var\n    bytes = new Uint8Array([\n      0x00, // version 0\n      0x00, 0x00, 0x00, // flags\n      0x00, 0x00, 0x00, 0x01, // creation_time\n      0x00, 0x00, 0x00, 0x02, // modification_time\n      0x00, 0x01, 0x5f, 0x90, // timescale, 90,000 \"ticks\" per second\n      (duration & 0xFF000000) >> 24,\n      (duration & 0xFF0000) >> 16,\n      (duration & 0xFF00) >> 8,\n      duration & 0xFF, // duration\n      0x00, 0x01, 0x00, 0x00, // 1.0 rate\n      0x01, 0x00, // 1.0 volume\n      0x00, 0x00, // reserved\n      0x00, 0x00, 0x00, 0x00, // reserved\n      0x00, 0x00, 0x00, 0x00, // reserved\n      0x00, 0x01, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x01, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x40, 0x00, 0x00, 0x00, // transformation: unity matrix\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, // pre_defined\n      0xff, 0xff, 0xff, 0xff // next_track_ID\n    ]);\n  return box(types.mvhd, bytes);\n};\n\nsdtp = function(track) {\n  var\n    samples = track.samples || [],\n    bytes = new Uint8Array(4 + samples.length),\n    flags,\n    i;\n\n  // leave the full box header (4 bytes) all zero\n\n  // write the sample table\n  for (i = 0; i < samples.length; i++) {\n    flags = samples[i].flags;\n\n    bytes[i + 4] = (flags.dependsOn << 4) |\n      (flags.isDependedOn << 2) |\n      (flags.hasRedundancy);\n  }\n\n  return box(types.sdtp,\n             bytes);\n};\n\nstbl = function(track) {\n  return box(types.stbl,\n             stsd(track),\n             box(types.stts, STTS),\n             box(types.stsc, STSC),\n             box(types.stsz, STSZ),\n             box(types.stco, STCO));\n};\n\n(function() {\n  var videoSample, audioSample;\n\n  stsd = function(track) {\n\n    return box(types.stsd, new Uint8Array([\n      0x00, // version 0\n      0x00, 0x00, 0x00, // flags\n      0x00, 0x00, 0x00, 0x01\n    ]), track.type === 'video' ? videoSample(track) : audioSample(track));\n  };\n\n  videoSample = function(track) {\n    var\n      sps = track.sps || [],\n      pps = track.pps || [],\n      sequenceParameterSets = [],\n      pictureParameterSets = [],\n      i;\n\n    // assemble the SPSs\n    for (i = 0; i < sps.length; i++) {\n      sequenceParameterSets.push((sps[i].byteLength & 0xFF00) >>> 8);\n      sequenceParameterSets.push((sps[i].byteLength & 0xFF)); // sequenceParameterSetLength\n      sequenceParameterSets = sequenceParameterSets.concat(Array.prototype.slice.call(sps[i])); // SPS\n    }\n\n    // assemble the PPSs\n    for (i = 0; i < pps.length; i++) {\n      pictureParameterSets.push((pps[i].byteLength & 0xFF00) >>> 8);\n      pictureParameterSets.push((pps[i].byteLength & 0xFF));\n      pictureParameterSets = pictureParameterSets.concat(Array.prototype.slice.call(pps[i]));\n    }\n\n    return box(types.avc1, new Uint8Array([\n      0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, // reserved\n      0x00, 0x01, // data_reference_index\n      0x00, 0x00, // pre_defined\n      0x00, 0x00, // reserved\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, // pre_defined\n      (track.width & 0xff00) >> 8,\n      track.width & 0xff, // width\n      (track.height & 0xff00) >> 8,\n      track.height & 0xff, // height\n      0x00, 0x48, 0x00, 0x00, // horizresolution\n      0x00, 0x48, 0x00, 0x00, // vertresolution\n      0x00, 0x00, 0x00, 0x00, // reserved\n      0x00, 0x01, // frame_count\n      0x13,\n      0x76, 0x69, 0x64, 0x65,\n      0x6f, 0x6a, 0x73, 0x2d,\n      0x63, 0x6f, 0x6e, 0x74,\n      0x72, 0x69, 0x62, 0x2d,\n      0x68, 0x6c, 0x73, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, // compressorname\n      0x00, 0x18, // depth = 24\n      0x11, 0x11 // pre_defined = -1\n    ]), box(types.avcC, new Uint8Array([\n      0x01, // configurationVersion\n      track.profileIdc, // AVCProfileIndication\n      track.profileCompatibility, // profile_compatibility\n      track.levelIdc, // AVCLevelIndication\n      0xff // lengthSizeMinusOne, hard-coded to 4 bytes\n    ].concat([\n      sps.length // numOfSequenceParameterSets\n    ]).concat(sequenceParameterSets).concat([\n      pps.length // numOfPictureParameterSets\n    ]).concat(pictureParameterSets))), // \"PPS\"\n            box(types.btrt, new Uint8Array([\n              0x00, 0x1c, 0x9c, 0x80, // bufferSizeDB\n              0x00, 0x2d, 0xc6, 0xc0, // maxBitrate\n              0x00, 0x2d, 0xc6, 0xc0\n            ])) // avgBitrate\n              );\n  };\n\n  audioSample = function(track) {\n    return box(types.mp4a, new Uint8Array([\n\n      // SampleEntry, ISO/IEC 14496-12\n      0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, // reserved\n      0x00, 0x01, // data_reference_index\n\n      // AudioSampleEntry, ISO/IEC 14496-12\n      0x00, 0x00, 0x00, 0x00, // reserved\n      0x00, 0x00, 0x00, 0x00, // reserved\n      (track.channelcount & 0xff00) >> 8,\n      (track.channelcount & 0xff), // channelcount\n\n      (track.samplesize & 0xff00) >> 8,\n      (track.samplesize & 0xff), // samplesize\n      0x00, 0x00, // pre_defined\n      0x00, 0x00, // reserved\n\n      (track.samplerate & 0xff00) >> 8,\n      (track.samplerate & 0xff),\n      0x00, 0x00 // samplerate, 16.16\n\n      // MP4AudioSampleEntry, ISO/IEC 14496-14\n    ]), esds(track));\n  };\n}());\n\ntkhd = function(track) {\n  var result = new Uint8Array([\n    0x00, // version 0\n    0x00, 0x00, 0x07, // flags\n    0x00, 0x00, 0x00, 0x00, // creation_time\n    0x00, 0x00, 0x00, 0x00, // modification_time\n    (track.id & 0xFF000000) >> 24,\n    (track.id & 0xFF0000) >> 16,\n    (track.id & 0xFF00) >> 8,\n    track.id & 0xFF, // track_ID\n    0x00, 0x00, 0x00, 0x00, // reserved\n    (track.duration & 0xFF000000) >> 24,\n    (track.duration & 0xFF0000) >> 16,\n    (track.duration & 0xFF00) >> 8,\n    track.duration & 0xFF, // duration\n    0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, // reserved\n    0x00, 0x00, // layer\n    0x00, 0x00, // alternate_group\n    0x01, 0x00, // non-audio track volume\n    0x00, 0x00, // reserved\n    0x00, 0x01, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00,\n    0x00, 0x01, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00,\n    0x40, 0x00, 0x00, 0x00, // transformation: unity matrix\n    (track.width & 0xFF00) >> 8,\n    track.width & 0xFF,\n    0x00, 0x00, // width\n    (track.height & 0xFF00) >> 8,\n    track.height & 0xFF,\n    0x00, 0x00 // height\n  ]);\n\n  return box(types.tkhd, result);\n};\n\n/**\n * Generate a track fragment (traf) box. A traf box collects metadata\n * about tracks in a movie fragment (moof) box.\n */\ntraf = function(track) {\n  var trackFragmentHeader, trackFragmentDecodeTime, trackFragmentRun,\n      sampleDependencyTable, dataOffset,\n      upperWordBaseMediaDecodeTime, lowerWordBaseMediaDecodeTime;\n\n  trackFragmentHeader = box(types.tfhd, new Uint8Array([\n    0x00, // version 0\n    0x00, 0x00, 0x3a, // flags\n    (track.id & 0xFF000000) >> 24,\n    (track.id & 0xFF0000) >> 16,\n    (track.id & 0xFF00) >> 8,\n    (track.id & 0xFF), // track_ID\n    0x00, 0x00, 0x00, 0x01, // sample_description_index\n    0x00, 0x00, 0x00, 0x00, // default_sample_duration\n    0x00, 0x00, 0x00, 0x00, // default_sample_size\n    0x00, 0x00, 0x00, 0x00  // default_sample_flags\n  ]));\n\n  upperWordBaseMediaDecodeTime = Math.floor(track.baseMediaDecodeTime / (UINT32_MAX + 1));\n  lowerWordBaseMediaDecodeTime = Math.floor(track.baseMediaDecodeTime % (UINT32_MAX + 1));\n\n  trackFragmentDecodeTime = box(types.tfdt, new Uint8Array([\n    0x01, // version 1\n    0x00, 0x00, 0x00, // flags\n    // baseMediaDecodeTime\n    (upperWordBaseMediaDecodeTime >>> 24) & 0xFF,\n    (upperWordBaseMediaDecodeTime >>> 16) & 0xFF,\n    (upperWordBaseMediaDecodeTime >>>  8) & 0xFF,\n    upperWordBaseMediaDecodeTime & 0xFF,\n    (lowerWordBaseMediaDecodeTime >>> 24) & 0xFF,\n    (lowerWordBaseMediaDecodeTime >>> 16) & 0xFF,\n    (lowerWordBaseMediaDecodeTime >>>  8) & 0xFF,\n    lowerWordBaseMediaDecodeTime & 0xFF\n  ]));\n\n  // the data offset specifies the number of bytes from the start of\n  // the containing moof to the first payload byte of the associated\n  // mdat\n  dataOffset = (32 + // tfhd\n                20 + // tfdt\n                8 +  // traf header\n                16 + // mfhd\n                8 +  // moof header\n                8);  // mdat header\n\n  // audio tracks require less metadata\n  if (track.type === 'audio') {\n    trackFragmentRun = trun(track, dataOffset);\n    return box(types.traf,\n               trackFragmentHeader,\n               trackFragmentDecodeTime,\n               trackFragmentRun);\n  }\n\n  // video tracks should contain an independent and disposable samples\n  // box (sdtp)\n  // generate one and adjust offsets to match\n  sampleDependencyTable = sdtp(track);\n  trackFragmentRun = trun(track,\n                          sampleDependencyTable.length + dataOffset);\n  return box(types.traf,\n             trackFragmentHeader,\n             trackFragmentDecodeTime,\n             trackFragmentRun,\n             sampleDependencyTable);\n};\n\n/**\n * Generate a track box.\n * @param track {object} a track definition\n * @return {Uint8Array} the track box\n */\ntrak = function(track) {\n  track.duration = track.duration || 0xffffffff;\n  return box(types.trak,\n             tkhd(track),\n             mdia(track));\n};\n\ntrex = function(track) {\n  var result = new Uint8Array([\n    0x00, // version 0\n    0x00, 0x00, 0x00, // flags\n    (track.id & 0xFF000000) >> 24,\n    (track.id & 0xFF0000) >> 16,\n    (track.id & 0xFF00) >> 8,\n    (track.id & 0xFF), // track_ID\n    0x00, 0x00, 0x00, 0x01, // default_sample_description_index\n    0x00, 0x00, 0x00, 0x00, // default_sample_duration\n    0x00, 0x00, 0x00, 0x00, // default_sample_size\n    0x00, 0x01, 0x00, 0x01 // default_sample_flags\n  ]);\n  // the last two bytes of default_sample_flags is the sample\n  // degradation priority, a hint about the importance of this sample\n  // relative to others. Lower the degradation priority for all sample\n  // types other than video.\n  if (track.type !== 'video') {\n    result[result.length - 1] = 0x00;\n  }\n\n  return box(types.trex, result);\n};\n\n(function() {\n  var audioTrun, videoTrun, trunHeader;\n\n  // This method assumes all samples are uniform. That is, if a\n  // duration is present for the first sample, it will be present for\n  // all subsequent samples.\n  // see ISO/IEC 14496-12:2012, Section 8.8.8.1\n  trunHeader = function(samples, offset) {\n    var durationPresent = 0, sizePresent = 0,\n        flagsPresent = 0, compositionTimeOffset = 0;\n\n    // trun flag constants\n    if (samples.length) {\n      if (samples[0].duration !== undefined) {\n        durationPresent = 0x1;\n      }\n      if (samples[0].size !== undefined) {\n        sizePresent = 0x2;\n      }\n      if (samples[0].flags !== undefined) {\n        flagsPresent = 0x4;\n      }\n      if (samples[0].compositionTimeOffset !== undefined) {\n        compositionTimeOffset = 0x8;\n      }\n    }\n\n    return [\n      0x00, // version 0\n      0x00,\n      durationPresent | sizePresent | flagsPresent | compositionTimeOffset,\n      0x01, // flags\n      (samples.length & 0xFF000000) >>> 24,\n      (samples.length & 0xFF0000) >>> 16,\n      (samples.length & 0xFF00) >>> 8,\n      samples.length & 0xFF, // sample_count\n      (offset & 0xFF000000) >>> 24,\n      (offset & 0xFF0000) >>> 16,\n      (offset & 0xFF00) >>> 8,\n      offset & 0xFF // data_offset\n    ];\n  };\n\n  videoTrun = function(track, offset) {\n    var bytes, samples, sample, i;\n\n    samples = track.samples || [];\n    offset += 8 + 12 + (16 * samples.length);\n\n    bytes = trunHeader(samples, offset);\n\n    for (i = 0; i < samples.length; i++) {\n      sample = samples[i];\n      bytes = bytes.concat([\n        (sample.duration & 0xFF000000) >>> 24,\n        (sample.duration & 0xFF0000) >>> 16,\n        (sample.duration & 0xFF00) >>> 8,\n        sample.duration & 0xFF, // sample_duration\n        (sample.size & 0xFF000000) >>> 24,\n        (sample.size & 0xFF0000) >>> 16,\n        (sample.size & 0xFF00) >>> 8,\n        sample.size & 0xFF, // sample_size\n        (sample.flags.isLeading << 2) | sample.flags.dependsOn,\n        (sample.flags.isDependedOn << 6) |\n          (sample.flags.hasRedundancy << 4) |\n          (sample.flags.paddingValue << 1) |\n          sample.flags.isNonSyncSample,\n        sample.flags.degradationPriority & 0xF0 << 8,\n        sample.flags.degradationPriority & 0x0F, // sample_flags\n        (sample.compositionTimeOffset & 0xFF000000) >>> 24,\n        (sample.compositionTimeOffset & 0xFF0000) >>> 16,\n        (sample.compositionTimeOffset & 0xFF00) >>> 8,\n        sample.compositionTimeOffset & 0xFF // sample_composition_time_offset\n      ]);\n    }\n    return box(types.trun, new Uint8Array(bytes));\n  };\n\n  audioTrun = function(track, offset) {\n    var bytes, samples, sample, i;\n\n    samples = track.samples || [];\n    offset += 8 + 12 + (8 * samples.length);\n\n    bytes = trunHeader(samples, offset);\n\n    for (i = 0; i < samples.length; i++) {\n      sample = samples[i];\n      bytes = bytes.concat([\n        (sample.duration & 0xFF000000) >>> 24,\n        (sample.duration & 0xFF0000) >>> 16,\n        (sample.duration & 0xFF00) >>> 8,\n        sample.duration & 0xFF, // sample_duration\n        (sample.size & 0xFF000000) >>> 24,\n        (sample.size & 0xFF0000) >>> 16,\n        (sample.size & 0xFF00) >>> 8,\n        sample.size & 0xFF]); // sample_size\n    }\n\n    return box(types.trun, new Uint8Array(bytes));\n  };\n\n  trun = function(track, offset) {\n    if (track.type === 'audio') {\n      return audioTrun(track, offset);\n    }\n\n    return videoTrun(track, offset);\n  };\n}());\n\nmodule.exports = {\n  ftyp: ftyp,\n  mdat: mdat,\n  moof: moof,\n  moov: moov,\n  initSegment: function(tracks) {\n    var\n      fileType = ftyp(),\n      movie = moov(tracks),\n      result;\n\n    result = new Uint8Array(fileType.byteLength + movie.byteLength);\n    result.set(fileType);\n    result.set(movie, fileType.byteLength);\n    return result;\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdmlkZW9qcy1jb250cmliLW1lZGlhLXNvdXJjZXMvbm9kZV9tb2R1bGVzL211eC5qcy9saWIvbXA0L21wNC1nZW5lcmF0b3IuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7O0FBRWI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjLHNCQUFzQjtBQUNwQztBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0Isb0JBQW9CO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixPQUFPO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLGdCQUFnQixvQkFBb0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktdjAtcHJvamVjdC8uL25vZGVfbW9kdWxlcy92aWRlb2pzLWNvbnRyaWItbWVkaWEtc291cmNlcy9ub2RlX21vZHVsZXMvbXV4LmpzL2xpYi9tcDQvbXA0LWdlbmVyYXRvci5qcz9iYWUyIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogbXV4LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE1IEJyaWdodGNvdmVcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogRnVuY3Rpb25zIHRoYXQgZ2VuZXJhdGUgZnJhZ21lbnRlZCBNUDRzIHN1aXRhYmxlIGZvciB1c2Ugd2l0aCBNZWRpYVxuICogU291cmNlIEV4dGVuc2lvbnMuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIFVJTlQzMl9NQVggPSBNYXRoLnBvdygyLCAzMikgLSAxO1xuXG52YXIgYm94LCBkaW5mLCBlc2RzLCBmdHlwLCBtZGF0LCBtZmhkLCBtaW5mLCBtb29mLCBtb292LCBtdmV4LCBtdmhkLFxuICAgIHRyYWssIHRraGQsIG1kaWEsIG1kaGQsIGhkbHIsIHNkdHAsIHN0YmwsIHN0c2QsIHRyYWYsIHRyZXgsXG4gICAgdHJ1biwgdHlwZXMsIE1BSk9SX0JSQU5ELCBNSU5PUl9WRVJTSU9OLCBBVkMxX0JSQU5ELCBWSURFT19IRExSLFxuICAgIEFVRElPX0hETFIsIEhETFJfVFlQRVMsIFZNSEQsIFNNSEQsIERSRUYsIFNUQ08sIFNUU0MsIFNUU1osIFNUVFM7XG5cbi8vIHByZS1jYWxjdWxhdGUgY29uc3RhbnRzXG4oZnVuY3Rpb24oKSB7XG4gIHZhciBpO1xuICB0eXBlcyA9IHtcbiAgICBhdmMxOiBbXSwgLy8gY29kaW5nbmFtZVxuICAgIGF2Y0M6IFtdLFxuICAgIGJ0cnQ6IFtdLFxuICAgIGRpbmY6IFtdLFxuICAgIGRyZWY6IFtdLFxuICAgIGVzZHM6IFtdLFxuICAgIGZ0eXA6IFtdLFxuICAgIGhkbHI6IFtdLFxuICAgIG1kYXQ6IFtdLFxuICAgIG1kaGQ6IFtdLFxuICAgIG1kaWE6IFtdLFxuICAgIG1maGQ6IFtdLFxuICAgIG1pbmY6IFtdLFxuICAgIG1vb2Y6IFtdLFxuICAgIG1vb3Y6IFtdLFxuICAgIG1wNGE6IFtdLCAvLyBjb2RpbmduYW1lXG4gICAgbXZleDogW10sXG4gICAgbXZoZDogW10sXG4gICAgc2R0cDogW10sXG4gICAgc21oZDogW10sXG4gICAgc3RibDogW10sXG4gICAgc3RjbzogW10sXG4gICAgc3RzYzogW10sXG4gICAgc3RzZDogW10sXG4gICAgc3RzejogW10sXG4gICAgc3R0czogW10sXG4gICAgc3R5cDogW10sXG4gICAgdGZkdDogW10sXG4gICAgdGZoZDogW10sXG4gICAgdHJhZjogW10sXG4gICAgdHJhazogW10sXG4gICAgdHJ1bjogW10sXG4gICAgdHJleDogW10sXG4gICAgdGtoZDogW10sXG4gICAgdm1oZDogW11cbiAgfTtcblxuICAvLyBJbiBlbnZpcm9ubWVudHMgd2hlcmUgVWludDhBcnJheSBpcyB1bmRlZmluZWQgKGUuZy4sIElFOCksIHNraXAgc2V0IHVwIHNvIHRoYXQgd2VcbiAgLy8gZG9uJ3QgdGhyb3cgYW4gZXJyb3JcbiAgaWYgKHR5cGVvZiBVaW50OEFycmF5ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGZvciAoaSBpbiB0eXBlcykge1xuICAgIGlmICh0eXBlcy5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgdHlwZXNbaV0gPSBbXG4gICAgICAgIGkuY2hhckNvZGVBdCgwKSxcbiAgICAgICAgaS5jaGFyQ29kZUF0KDEpLFxuICAgICAgICBpLmNoYXJDb2RlQXQoMiksXG4gICAgICAgIGkuY2hhckNvZGVBdCgzKVxuICAgICAgXTtcbiAgICB9XG4gIH1cblxuICBNQUpPUl9CUkFORCA9IG5ldyBVaW50OEFycmF5KFtcbiAgICAnaScuY2hhckNvZGVBdCgwKSxcbiAgICAncycuY2hhckNvZGVBdCgwKSxcbiAgICAnbycuY2hhckNvZGVBdCgwKSxcbiAgICAnbScuY2hhckNvZGVBdCgwKVxuICBdKTtcbiAgQVZDMV9CUkFORCA9IG5ldyBVaW50OEFycmF5KFtcbiAgICAnYScuY2hhckNvZGVBdCgwKSxcbiAgICAndicuY2hhckNvZGVBdCgwKSxcbiAgICAnYycuY2hhckNvZGVBdCgwKSxcbiAgICAnMScuY2hhckNvZGVBdCgwKVxuICBdKTtcbiAgTUlOT1JfVkVSU0lPTiA9IG5ldyBVaW50OEFycmF5KFswLCAwLCAwLCAxXSk7XG4gIFZJREVPX0hETFIgPSBuZXcgVWludDhBcnJheShbXG4gICAgMHgwMCwgLy8gdmVyc2lvbiAwXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgLy8gZmxhZ3NcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyBwcmVfZGVmaW5lZFxuICAgIDB4NzYsIDB4NjksIDB4NjQsIDB4NjUsIC8vIGhhbmRsZXJfdHlwZTogJ3ZpZGUnXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWRcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyByZXNlcnZlZFxuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkXG4gICAgMHg1NiwgMHg2OSwgMHg2NCwgMHg2NSxcbiAgICAweDZmLCAweDQ4LCAweDYxLCAweDZlLFxuICAgIDB4NjQsIDB4NmMsIDB4NjUsIDB4NzIsIDB4MDAgLy8gbmFtZTogJ1ZpZGVvSGFuZGxlcidcbiAgXSk7XG4gIEFVRElPX0hETFIgPSBuZXcgVWludDhBcnJheShbXG4gICAgMHgwMCwgLy8gdmVyc2lvbiAwXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgLy8gZmxhZ3NcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyBwcmVfZGVmaW5lZFxuICAgIDB4NzMsIDB4NmYsIDB4NzUsIDB4NmUsIC8vIGhhbmRsZXJfdHlwZTogJ3NvdW4nXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWRcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyByZXNlcnZlZFxuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkXG4gICAgMHg1MywgMHg2ZiwgMHg3NSwgMHg2ZSxcbiAgICAweDY0LCAweDQ4LCAweDYxLCAweDZlLFxuICAgIDB4NjQsIDB4NmMsIDB4NjUsIDB4NzIsIDB4MDAgLy8gbmFtZTogJ1NvdW5kSGFuZGxlcidcbiAgXSk7XG4gIEhETFJfVFlQRVMgPSB7XG4gICAgdmlkZW86IFZJREVPX0hETFIsXG4gICAgYXVkaW86IEFVRElPX0hETFJcbiAgfTtcbiAgRFJFRiA9IG5ldyBVaW50OEFycmF5KFtcbiAgICAweDAwLCAvLyB2ZXJzaW9uIDBcbiAgICAweDAwLCAweDAwLCAweDAwLCAvLyBmbGFnc1xuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDEsIC8vIGVudHJ5X2NvdW50XG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwYywgLy8gZW50cnlfc2l6ZVxuICAgIDB4NzUsIDB4NzIsIDB4NmMsIDB4MjAsIC8vICd1cmwnIHR5cGVcbiAgICAweDAwLCAvLyB2ZXJzaW9uIDBcbiAgICAweDAwLCAweDAwLCAweDAxIC8vIGVudHJ5X2ZsYWdzXG4gIF0pO1xuICBTTUhEID0gbmV3IFVpbnQ4QXJyYXkoW1xuICAgIDB4MDAsICAgICAgICAgICAgIC8vIHZlcnNpb25cbiAgICAweDAwLCAweDAwLCAweDAwLCAvLyBmbGFnc1xuICAgIDB4MDAsIDB4MDAsICAgICAgIC8vIGJhbGFuY2UsIDAgbWVhbnMgY2VudGVyZWRcbiAgICAweDAwLCAweDAwICAgICAgICAvLyByZXNlcnZlZFxuICBdKTtcbiAgU1RDTyA9IG5ldyBVaW50OEFycmF5KFtcbiAgICAweDAwLCAvLyB2ZXJzaW9uXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgLy8gZmxhZ3NcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwIC8vIGVudHJ5X2NvdW50XG4gIF0pO1xuICBTVFNDID0gU1RDTztcbiAgU1RTWiA9IG5ldyBVaW50OEFycmF5KFtcbiAgICAweDAwLCAvLyB2ZXJzaW9uXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgLy8gZmxhZ3NcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyBzYW1wbGVfc2l6ZVxuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAgLy8gc2FtcGxlX2NvdW50XG4gIF0pO1xuICBTVFRTID0gU1RDTztcbiAgVk1IRCA9IG5ldyBVaW50OEFycmF5KFtcbiAgICAweDAwLCAvLyB2ZXJzaW9uXG4gICAgMHgwMCwgMHgwMCwgMHgwMSwgLy8gZmxhZ3NcbiAgICAweDAwLCAweDAwLCAvLyBncmFwaGljc21vZGVcbiAgICAweDAwLCAweDAwLFxuICAgIDB4MDAsIDB4MDAsXG4gICAgMHgwMCwgMHgwMCAvLyBvcGNvbG9yXG4gIF0pO1xufSgpKTtcblxuYm94ID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXJcbiAgICBwYXlsb2FkID0gW10sXG4gICAgc2l6ZSA9IDAsXG4gICAgaSxcbiAgICByZXN1bHQsXG4gICAgdmlldztcblxuICBmb3IgKGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgcGF5bG9hZC5wdXNoKGFyZ3VtZW50c1tpXSk7XG4gIH1cblxuICBpID0gcGF5bG9hZC5sZW5ndGg7XG5cbiAgLy8gY2FsY3VsYXRlIHRoZSB0b3RhbCBzaXplIHdlIG5lZWQgdG8gYWxsb2NhdGVcbiAgd2hpbGUgKGktLSkge1xuICAgIHNpemUgKz0gcGF5bG9hZFtpXS5ieXRlTGVuZ3RoO1xuICB9XG4gIHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KHNpemUgKyA4KTtcbiAgdmlldyA9IG5ldyBEYXRhVmlldyhyZXN1bHQuYnVmZmVyLCByZXN1bHQuYnl0ZU9mZnNldCwgcmVzdWx0LmJ5dGVMZW5ndGgpO1xuICB2aWV3LnNldFVpbnQzMigwLCByZXN1bHQuYnl0ZUxlbmd0aCk7XG4gIHJlc3VsdC5zZXQodHlwZSwgNCk7XG5cbiAgLy8gY29weSB0aGUgcGF5bG9hZCBpbnRvIHRoZSByZXN1bHRcbiAgZm9yIChpID0gMCwgc2l6ZSA9IDg7IGkgPCBwYXlsb2FkLmxlbmd0aDsgaSsrKSB7XG4gICAgcmVzdWx0LnNldChwYXlsb2FkW2ldLCBzaXplKTtcbiAgICBzaXplICs9IHBheWxvYWRbaV0uYnl0ZUxlbmd0aDtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuZGluZiA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gYm94KHR5cGVzLmRpbmYsIGJveCh0eXBlcy5kcmVmLCBEUkVGKSk7XG59O1xuXG5lc2RzID0gZnVuY3Rpb24odHJhY2spIHtcbiAgcmV0dXJuIGJveCh0eXBlcy5lc2RzLCBuZXcgVWludDhBcnJheShbXG4gICAgMHgwMCwgLy8gdmVyc2lvblxuICAgIDB4MDAsIDB4MDAsIDB4MDAsIC8vIGZsYWdzXG5cbiAgICAvLyBFU19EZXNjcmlwdG9yXG4gICAgMHgwMywgLy8gdGFnLCBFU19EZXNjclRhZ1xuICAgIDB4MTksIC8vIGxlbmd0aFxuICAgIDB4MDAsIDB4MDAsIC8vIEVTX0lEXG4gICAgMHgwMCwgLy8gc3RyZWFtRGVwZW5kZW5jZUZsYWcsIFVSTF9mbGFnLCByZXNlcnZlZCwgc3RyZWFtUHJpb3JpdHlcblxuICAgIC8vIERlY29kZXJDb25maWdEZXNjcmlwdG9yXG4gICAgMHgwNCwgLy8gdGFnLCBEZWNvZGVyQ29uZmlnRGVzY3JUYWdcbiAgICAweDExLCAvLyBsZW5ndGhcbiAgICAweDQwLCAvLyBvYmplY3QgdHlwZVxuICAgIDB4MTUsICAvLyBzdHJlYW1UeXBlXG4gICAgMHgwMCwgMHgwNiwgMHgwMCwgLy8gYnVmZmVyU2l6ZURCXG4gICAgMHgwMCwgMHgwMCwgMHhkYSwgMHhjMCwgLy8gbWF4Qml0cmF0ZVxuICAgIDB4MDAsIDB4MDAsIDB4ZGEsIDB4YzAsIC8vIGF2Z0JpdHJhdGVcblxuICAgIC8vIERlY29kZXJTcGVjaWZpY0luZm9cbiAgICAweDA1LCAvLyB0YWcsIERlY29kZXJTcGVjaWZpY0luZm9UYWdcbiAgICAweDAyLCAvLyBsZW5ndGhcbiAgICAvLyBJU08vSUVDIDE0NDk2LTMsIEF1ZGlvU3BlY2lmaWNDb25maWdcbiAgICAvLyBmb3Igc2FtcGxpbmdGcmVxdWVuY3lJbmRleCBzZWUgSVNPL0lFQyAxMzgxOC03OjIwMDYsIDguMS4zLjIuMiwgVGFibGUgMzVcbiAgICAodHJhY2suYXVkaW9vYmplY3R0eXBlIDw8IDMpIHwgKHRyYWNrLnNhbXBsaW5nZnJlcXVlbmN5aW5kZXggPj4+IDEpLFxuICAgICh0cmFjay5zYW1wbGluZ2ZyZXF1ZW5jeWluZGV4IDw8IDcpIHwgKHRyYWNrLmNoYW5uZWxjb3VudCA8PCAzKSxcbiAgICAweDA2LCAweDAxLCAweDAyIC8vIEdBU3BlY2lmaWNDb25maWdcbiAgXSkpO1xufTtcblxuZnR5cCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gYm94KHR5cGVzLmZ0eXAsIE1BSk9SX0JSQU5ELCBNSU5PUl9WRVJTSU9OLCBNQUpPUl9CUkFORCwgQVZDMV9CUkFORCk7XG59O1xuXG5oZGxyID0gZnVuY3Rpb24odHlwZSkge1xuICByZXR1cm4gYm94KHR5cGVzLmhkbHIsIEhETFJfVFlQRVNbdHlwZV0pO1xufTtcbm1kYXQgPSBmdW5jdGlvbihkYXRhKSB7XG4gIHJldHVybiBib3godHlwZXMubWRhdCwgZGF0YSk7XG59O1xubWRoZCA9IGZ1bmN0aW9uKHRyYWNrKSB7XG4gIHZhciByZXN1bHQgPSBuZXcgVWludDhBcnJheShbXG4gICAgMHgwMCwgICAgICAgICAgICAgICAgICAgLy8gdmVyc2lvbiAwXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgICAgICAgLy8gZmxhZ3NcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAyLCAvLyBjcmVhdGlvbl90aW1lXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMywgLy8gbW9kaWZpY2F0aW9uX3RpbWVcbiAgICAweDAwLCAweDAxLCAweDVmLCAweDkwLCAvLyB0aW1lc2NhbGUsIDkwLDAwMCBcInRpY2tzXCIgcGVyIHNlY29uZFxuXG4gICAgKHRyYWNrLmR1cmF0aW9uID4+PiAyNCkgJiAweEZGLFxuICAgICh0cmFjay5kdXJhdGlvbiA+Pj4gMTYpICYgMHhGRixcbiAgICAodHJhY2suZHVyYXRpb24gPj4+ICA4KSAmIDB4RkYsXG4gICAgdHJhY2suZHVyYXRpb24gJiAweEZGLCAgLy8gZHVyYXRpb25cbiAgICAweDU1LCAweGM0LCAgICAgICAgICAgICAvLyAndW5kJyBsYW5ndWFnZSAodW5kZXRlcm1pbmVkKVxuICAgIDB4MDAsIDB4MDBcbiAgXSk7XG5cbiAgLy8gVXNlIHRoZSBzYW1wbGUgcmF0ZSBmcm9tIHRoZSB0cmFjayBtZXRhZGF0YSwgd2hlbiBpdCBpc1xuICAvLyBkZWZpbmVkLiBUaGUgc2FtcGxlIHJhdGUgY2FuIGJlIHBhcnNlZCBvdXQgb2YgYW4gQURUUyBoZWFkZXIsIGZvclxuICAvLyBpbnN0YW5jZS5cbiAgaWYgKHRyYWNrLnNhbXBsZXJhdGUpIHtcbiAgICByZXN1bHRbMTJdID0gKHRyYWNrLnNhbXBsZXJhdGUgPj4+IDI0KSAmIDB4RkY7XG4gICAgcmVzdWx0WzEzXSA9ICh0cmFjay5zYW1wbGVyYXRlID4+PiAxNikgJiAweEZGO1xuICAgIHJlc3VsdFsxNF0gPSAodHJhY2suc2FtcGxlcmF0ZSA+Pj4gIDgpICYgMHhGRjtcbiAgICByZXN1bHRbMTVdID0gKHRyYWNrLnNhbXBsZXJhdGUpICAgICAgICAmIDB4RkY7XG4gIH1cblxuICByZXR1cm4gYm94KHR5cGVzLm1kaGQsIHJlc3VsdCk7XG59O1xubWRpYSA9IGZ1bmN0aW9uKHRyYWNrKSB7XG4gIHJldHVybiBib3godHlwZXMubWRpYSwgbWRoZCh0cmFjayksIGhkbHIodHJhY2sudHlwZSksIG1pbmYodHJhY2spKTtcbn07XG5tZmhkID0gZnVuY3Rpb24oc2VxdWVuY2VOdW1iZXIpIHtcbiAgcmV0dXJuIGJveCh0eXBlcy5tZmhkLCBuZXcgVWludDhBcnJheShbXG4gICAgMHgwMCxcbiAgICAweDAwLCAweDAwLCAweDAwLCAvLyBmbGFnc1xuICAgIChzZXF1ZW5jZU51bWJlciAmIDB4RkYwMDAwMDApID4+IDI0LFxuICAgIChzZXF1ZW5jZU51bWJlciAmIDB4RkYwMDAwKSA+PiAxNixcbiAgICAoc2VxdWVuY2VOdW1iZXIgJiAweEZGMDApID4+IDgsXG4gICAgc2VxdWVuY2VOdW1iZXIgJiAweEZGIC8vIHNlcXVlbmNlX251bWJlclxuICBdKSk7XG59O1xubWluZiA9IGZ1bmN0aW9uKHRyYWNrKSB7XG4gIHJldHVybiBib3godHlwZXMubWluZixcbiAgICAgICAgICAgICB0cmFjay50eXBlID09PSAndmlkZW8nID8gYm94KHR5cGVzLnZtaGQsIFZNSEQpIDogYm94KHR5cGVzLnNtaGQsIFNNSEQpLFxuICAgICAgICAgICAgIGRpbmYoKSxcbiAgICAgICAgICAgICBzdGJsKHRyYWNrKSk7XG59O1xubW9vZiA9IGZ1bmN0aW9uKHNlcXVlbmNlTnVtYmVyLCB0cmFja3MpIHtcbiAgdmFyXG4gICAgdHJhY2tGcmFnbWVudHMgPSBbXSxcbiAgICBpID0gdHJhY2tzLmxlbmd0aDtcbiAgLy8gYnVpbGQgdHJhZiBib3hlcyBmb3IgZWFjaCB0cmFjayBmcmFnbWVudFxuICB3aGlsZSAoaS0tKSB7XG4gICAgdHJhY2tGcmFnbWVudHNbaV0gPSB0cmFmKHRyYWNrc1tpXSk7XG4gIH1cbiAgcmV0dXJuIGJveC5hcHBseShudWxsLCBbXG4gICAgdHlwZXMubW9vZixcbiAgICBtZmhkKHNlcXVlbmNlTnVtYmVyKVxuICBdLmNvbmNhdCh0cmFja0ZyYWdtZW50cykpO1xufTtcbi8qKlxuICogUmV0dXJucyBhIG1vdmllIGJveC5cbiAqIEBwYXJhbSB0cmFja3Mge2FycmF5fSB0aGUgdHJhY2tzIGFzc29jaWF0ZWQgd2l0aCB0aGlzIG1vdmllXG4gKiBAc2VlIElTTy9JRUMgMTQ0OTYtMTI6MjAxMihFKSwgc2VjdGlvbiA4LjIuMVxuICovXG5tb292ID0gZnVuY3Rpb24odHJhY2tzKSB7XG4gIHZhclxuICAgIGkgPSB0cmFja3MubGVuZ3RoLFxuICAgIGJveGVzID0gW107XG5cbiAgd2hpbGUgKGktLSkge1xuICAgIGJveGVzW2ldID0gdHJhayh0cmFja3NbaV0pO1xuICB9XG5cbiAgcmV0dXJuIGJveC5hcHBseShudWxsLCBbdHlwZXMubW9vdiwgbXZoZCgweGZmZmZmZmZmKV0uY29uY2F0KGJveGVzKS5jb25jYXQobXZleCh0cmFja3MpKSk7XG59O1xubXZleCA9IGZ1bmN0aW9uKHRyYWNrcykge1xuICB2YXJcbiAgICBpID0gdHJhY2tzLmxlbmd0aCxcbiAgICBib3hlcyA9IFtdO1xuXG4gIHdoaWxlIChpLS0pIHtcbiAgICBib3hlc1tpXSA9IHRyZXgodHJhY2tzW2ldKTtcbiAgfVxuICByZXR1cm4gYm94LmFwcGx5KG51bGwsIFt0eXBlcy5tdmV4XS5jb25jYXQoYm94ZXMpKTtcbn07XG5tdmhkID0gZnVuY3Rpb24oZHVyYXRpb24pIHtcbiAgdmFyXG4gICAgYnl0ZXMgPSBuZXcgVWludDhBcnJheShbXG4gICAgICAweDAwLCAvLyB2ZXJzaW9uIDBcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIC8vIGZsYWdzXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAxLCAvLyBjcmVhdGlvbl90aW1lXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAyLCAvLyBtb2RpZmljYXRpb25fdGltZVxuICAgICAgMHgwMCwgMHgwMSwgMHg1ZiwgMHg5MCwgLy8gdGltZXNjYWxlLCA5MCwwMDAgXCJ0aWNrc1wiIHBlciBzZWNvbmRcbiAgICAgIChkdXJhdGlvbiAmIDB4RkYwMDAwMDApID4+IDI0LFxuICAgICAgKGR1cmF0aW9uICYgMHhGRjAwMDApID4+IDE2LFxuICAgICAgKGR1cmF0aW9uICYgMHhGRjAwKSA+PiA4LFxuICAgICAgZHVyYXRpb24gJiAweEZGLCAvLyBkdXJhdGlvblxuICAgICAgMHgwMCwgMHgwMSwgMHgwMCwgMHgwMCwgLy8gMS4wIHJhdGVcbiAgICAgIDB4MDEsIDB4MDAsIC8vIDEuMCB2b2x1bWVcbiAgICAgIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyByZXNlcnZlZFxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWRcbiAgICAgIDB4MDAsIDB4MDEsIDB4MDAsIDB4MDAsXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAweDAwLCAweDAxLCAweDAwLCAweDAwLFxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgICAgMHg0MCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gdHJhbnNmb3JtYXRpb246IHVuaXR5IG1hdHJpeFxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyBwcmVfZGVmaW5lZFxuICAgICAgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiAvLyBuZXh0X3RyYWNrX0lEXG4gICAgXSk7XG4gIHJldHVybiBib3godHlwZXMubXZoZCwgYnl0ZXMpO1xufTtcblxuc2R0cCA9IGZ1bmN0aW9uKHRyYWNrKSB7XG4gIHZhclxuICAgIHNhbXBsZXMgPSB0cmFjay5zYW1wbGVzIHx8IFtdLFxuICAgIGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoNCArIHNhbXBsZXMubGVuZ3RoKSxcbiAgICBmbGFncyxcbiAgICBpO1xuXG4gIC8vIGxlYXZlIHRoZSBmdWxsIGJveCBoZWFkZXIgKDQgYnl0ZXMpIGFsbCB6ZXJvXG5cbiAgLy8gd3JpdGUgdGhlIHNhbXBsZSB0YWJsZVxuICBmb3IgKGkgPSAwOyBpIDwgc2FtcGxlcy5sZW5ndGg7IGkrKykge1xuICAgIGZsYWdzID0gc2FtcGxlc1tpXS5mbGFncztcblxuICAgIGJ5dGVzW2kgKyA0XSA9IChmbGFncy5kZXBlbmRzT24gPDwgNCkgfFxuICAgICAgKGZsYWdzLmlzRGVwZW5kZWRPbiA8PCAyKSB8XG4gICAgICAoZmxhZ3MuaGFzUmVkdW5kYW5jeSk7XG4gIH1cblxuICByZXR1cm4gYm94KHR5cGVzLnNkdHAsXG4gICAgICAgICAgICAgYnl0ZXMpO1xufTtcblxuc3RibCA9IGZ1bmN0aW9uKHRyYWNrKSB7XG4gIHJldHVybiBib3godHlwZXMuc3RibCxcbiAgICAgICAgICAgICBzdHNkKHRyYWNrKSxcbiAgICAgICAgICAgICBib3godHlwZXMuc3R0cywgU1RUUyksXG4gICAgICAgICAgICAgYm94KHR5cGVzLnN0c2MsIFNUU0MpLFxuICAgICAgICAgICAgIGJveCh0eXBlcy5zdHN6LCBTVFNaKSxcbiAgICAgICAgICAgICBib3godHlwZXMuc3RjbywgU1RDTykpO1xufTtcblxuKGZ1bmN0aW9uKCkge1xuICB2YXIgdmlkZW9TYW1wbGUsIGF1ZGlvU2FtcGxlO1xuXG4gIHN0c2QgPSBmdW5jdGlvbih0cmFjaykge1xuXG4gICAgcmV0dXJuIGJveCh0eXBlcy5zdHNkLCBuZXcgVWludDhBcnJheShbXG4gICAgICAweDAwLCAvLyB2ZXJzaW9uIDBcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIC8vIGZsYWdzXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAxXG4gICAgXSksIHRyYWNrLnR5cGUgPT09ICd2aWRlbycgPyB2aWRlb1NhbXBsZSh0cmFjaykgOiBhdWRpb1NhbXBsZSh0cmFjaykpO1xuICB9O1xuXG4gIHZpZGVvU2FtcGxlID0gZnVuY3Rpb24odHJhY2spIHtcbiAgICB2YXJcbiAgICAgIHNwcyA9IHRyYWNrLnNwcyB8fCBbXSxcbiAgICAgIHBwcyA9IHRyYWNrLnBwcyB8fCBbXSxcbiAgICAgIHNlcXVlbmNlUGFyYW1ldGVyU2V0cyA9IFtdLFxuICAgICAgcGljdHVyZVBhcmFtZXRlclNldHMgPSBbXSxcbiAgICAgIGk7XG5cbiAgICAvLyBhc3NlbWJsZSB0aGUgU1BTc1xuICAgIGZvciAoaSA9IDA7IGkgPCBzcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHNlcXVlbmNlUGFyYW1ldGVyU2V0cy5wdXNoKChzcHNbaV0uYnl0ZUxlbmd0aCAmIDB4RkYwMCkgPj4+IDgpO1xuICAgICAgc2VxdWVuY2VQYXJhbWV0ZXJTZXRzLnB1c2goKHNwc1tpXS5ieXRlTGVuZ3RoICYgMHhGRikpOyAvLyBzZXF1ZW5jZVBhcmFtZXRlclNldExlbmd0aFxuICAgICAgc2VxdWVuY2VQYXJhbWV0ZXJTZXRzID0gc2VxdWVuY2VQYXJhbWV0ZXJTZXRzLmNvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChzcHNbaV0pKTsgLy8gU1BTXG4gICAgfVxuXG4gICAgLy8gYXNzZW1ibGUgdGhlIFBQU3NcbiAgICBmb3IgKGkgPSAwOyBpIDwgcHBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBwaWN0dXJlUGFyYW1ldGVyU2V0cy5wdXNoKChwcHNbaV0uYnl0ZUxlbmd0aCAmIDB4RkYwMCkgPj4+IDgpO1xuICAgICAgcGljdHVyZVBhcmFtZXRlclNldHMucHVzaCgocHBzW2ldLmJ5dGVMZW5ndGggJiAweEZGKSk7XG4gICAgICBwaWN0dXJlUGFyYW1ldGVyU2V0cyA9IHBpY3R1cmVQYXJhbWV0ZXJTZXRzLmNvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChwcHNbaV0pKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYm94KHR5cGVzLmF2YzEsIG5ldyBVaW50OEFycmF5KFtcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAvLyByZXNlcnZlZFxuICAgICAgMHgwMCwgMHgwMSwgLy8gZGF0YV9yZWZlcmVuY2VfaW5kZXhcbiAgICAgIDB4MDAsIDB4MDAsIC8vIHByZV9kZWZpbmVkXG4gICAgICAweDAwLCAweDAwLCAvLyByZXNlcnZlZFxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyBwcmVfZGVmaW5lZFxuICAgICAgKHRyYWNrLndpZHRoICYgMHhmZjAwKSA+PiA4LFxuICAgICAgdHJhY2sud2lkdGggJiAweGZmLCAvLyB3aWR0aFxuICAgICAgKHRyYWNrLmhlaWdodCAmIDB4ZmYwMCkgPj4gOCxcbiAgICAgIHRyYWNrLmhlaWdodCAmIDB4ZmYsIC8vIGhlaWdodFxuICAgICAgMHgwMCwgMHg0OCwgMHgwMCwgMHgwMCwgLy8gaG9yaXpyZXNvbHV0aW9uXG4gICAgICAweDAwLCAweDQ4LCAweDAwLCAweDAwLCAvLyB2ZXJ0cmVzb2x1dGlvblxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWRcbiAgICAgIDB4MDAsIDB4MDEsIC8vIGZyYW1lX2NvdW50XG4gICAgICAweDEzLFxuICAgICAgMHg3NiwgMHg2OSwgMHg2NCwgMHg2NSxcbiAgICAgIDB4NmYsIDB4NmEsIDB4NzMsIDB4MmQsXG4gICAgICAweDYzLCAweDZmLCAweDZlLCAweDc0LFxuICAgICAgMHg3MiwgMHg2OSwgMHg2MiwgMHgyZCxcbiAgICAgIDB4NjgsIDB4NmMsIDB4NzMsIDB4MDAsXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIC8vIGNvbXByZXNzb3JuYW1lXG4gICAgICAweDAwLCAweDE4LCAvLyBkZXB0aCA9IDI0XG4gICAgICAweDExLCAweDExIC8vIHByZV9kZWZpbmVkID0gLTFcbiAgICBdKSwgYm94KHR5cGVzLmF2Y0MsIG5ldyBVaW50OEFycmF5KFtcbiAgICAgIDB4MDEsIC8vIGNvbmZpZ3VyYXRpb25WZXJzaW9uXG4gICAgICB0cmFjay5wcm9maWxlSWRjLCAvLyBBVkNQcm9maWxlSW5kaWNhdGlvblxuICAgICAgdHJhY2sucHJvZmlsZUNvbXBhdGliaWxpdHksIC8vIHByb2ZpbGVfY29tcGF0aWJpbGl0eVxuICAgICAgdHJhY2subGV2ZWxJZGMsIC8vIEFWQ0xldmVsSW5kaWNhdGlvblxuICAgICAgMHhmZiAvLyBsZW5ndGhTaXplTWludXNPbmUsIGhhcmQtY29kZWQgdG8gNCBieXRlc1xuICAgIF0uY29uY2F0KFtcbiAgICAgIHNwcy5sZW5ndGggLy8gbnVtT2ZTZXF1ZW5jZVBhcmFtZXRlclNldHNcbiAgICBdKS5jb25jYXQoc2VxdWVuY2VQYXJhbWV0ZXJTZXRzKS5jb25jYXQoW1xuICAgICAgcHBzLmxlbmd0aCAvLyBudW1PZlBpY3R1cmVQYXJhbWV0ZXJTZXRzXG4gICAgXSkuY29uY2F0KHBpY3R1cmVQYXJhbWV0ZXJTZXRzKSkpLCAvLyBcIlBQU1wiXG4gICAgICAgICAgICBib3godHlwZXMuYnRydCwgbmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgICAgICAgICAweDAwLCAweDFjLCAweDljLCAweDgwLCAvLyBidWZmZXJTaXplREJcbiAgICAgICAgICAgICAgMHgwMCwgMHgyZCwgMHhjNiwgMHhjMCwgLy8gbWF4Qml0cmF0ZVxuICAgICAgICAgICAgICAweDAwLCAweDJkLCAweGM2LCAweGMwXG4gICAgICAgICAgICBdKSkgLy8gYXZnQml0cmF0ZVxuICAgICAgICAgICAgICApO1xuICB9O1xuXG4gIGF1ZGlvU2FtcGxlID0gZnVuY3Rpb24odHJhY2spIHtcbiAgICByZXR1cm4gYm94KHR5cGVzLm1wNGEsIG5ldyBVaW50OEFycmF5KFtcblxuICAgICAgLy8gU2FtcGxlRW50cnksIElTTy9JRUMgMTQ0OTYtMTJcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAvLyByZXNlcnZlZFxuICAgICAgMHgwMCwgMHgwMSwgLy8gZGF0YV9yZWZlcmVuY2VfaW5kZXhcblxuICAgICAgLy8gQXVkaW9TYW1wbGVFbnRyeSwgSVNPL0lFQyAxNDQ5Ni0xMlxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWRcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkXG4gICAgICAodHJhY2suY2hhbm5lbGNvdW50ICYgMHhmZjAwKSA+PiA4LFxuICAgICAgKHRyYWNrLmNoYW5uZWxjb3VudCAmIDB4ZmYpLCAvLyBjaGFubmVsY291bnRcblxuICAgICAgKHRyYWNrLnNhbXBsZXNpemUgJiAweGZmMDApID4+IDgsXG4gICAgICAodHJhY2suc2FtcGxlc2l6ZSAmIDB4ZmYpLCAvLyBzYW1wbGVzaXplXG4gICAgICAweDAwLCAweDAwLCAvLyBwcmVfZGVmaW5lZFxuICAgICAgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWRcblxuICAgICAgKHRyYWNrLnNhbXBsZXJhdGUgJiAweGZmMDApID4+IDgsXG4gICAgICAodHJhY2suc2FtcGxlcmF0ZSAmIDB4ZmYpLFxuICAgICAgMHgwMCwgMHgwMCAvLyBzYW1wbGVyYXRlLCAxNi4xNlxuXG4gICAgICAvLyBNUDRBdWRpb1NhbXBsZUVudHJ5LCBJU08vSUVDIDE0NDk2LTE0XG4gICAgXSksIGVzZHModHJhY2spKTtcbiAgfTtcbn0oKSk7XG5cbnRraGQgPSBmdW5jdGlvbih0cmFjaykge1xuICB2YXIgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkoW1xuICAgIDB4MDAsIC8vIHZlcnNpb24gMFxuICAgIDB4MDAsIDB4MDAsIDB4MDcsIC8vIGZsYWdzXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gY3JlYXRpb25fdGltZVxuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIG1vZGlmaWNhdGlvbl90aW1lXG4gICAgKHRyYWNrLmlkICYgMHhGRjAwMDAwMCkgPj4gMjQsXG4gICAgKHRyYWNrLmlkICYgMHhGRjAwMDApID4+IDE2LFxuICAgICh0cmFjay5pZCAmIDB4RkYwMCkgPj4gOCxcbiAgICB0cmFjay5pZCAmIDB4RkYsIC8vIHRyYWNrX0lEXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWRcbiAgICAodHJhY2suZHVyYXRpb24gJiAweEZGMDAwMDAwKSA+PiAyNCxcbiAgICAodHJhY2suZHVyYXRpb24gJiAweEZGMDAwMCkgPj4gMTYsXG4gICAgKHRyYWNrLmR1cmF0aW9uICYgMHhGRjAwKSA+PiA4LFxuICAgIHRyYWNrLmR1cmF0aW9uICYgMHhGRiwgLy8gZHVyYXRpb25cbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkXG4gICAgMHgwMCwgMHgwMCwgLy8gbGF5ZXJcbiAgICAweDAwLCAweDAwLCAvLyBhbHRlcm5hdGVfZ3JvdXBcbiAgICAweDAxLCAweDAwLCAvLyBub24tYXVkaW8gdHJhY2sgdm9sdW1lXG4gICAgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWRcbiAgICAweDAwLCAweDAxLCAweDAwLCAweDAwLFxuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgIDB4MDAsIDB4MDEsIDB4MDAsIDB4MDAsXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgMHg0MCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gdHJhbnNmb3JtYXRpb246IHVuaXR5IG1hdHJpeFxuICAgICh0cmFjay53aWR0aCAmIDB4RkYwMCkgPj4gOCxcbiAgICB0cmFjay53aWR0aCAmIDB4RkYsXG4gICAgMHgwMCwgMHgwMCwgLy8gd2lkdGhcbiAgICAodHJhY2suaGVpZ2h0ICYgMHhGRjAwKSA+PiA4LFxuICAgIHRyYWNrLmhlaWdodCAmIDB4RkYsXG4gICAgMHgwMCwgMHgwMCAvLyBoZWlnaHRcbiAgXSk7XG5cbiAgcmV0dXJuIGJveCh0eXBlcy50a2hkLCByZXN1bHQpO1xufTtcblxuLyoqXG4gKiBHZW5lcmF0ZSBhIHRyYWNrIGZyYWdtZW50ICh0cmFmKSBib3guIEEgdHJhZiBib3ggY29sbGVjdHMgbWV0YWRhdGFcbiAqIGFib3V0IHRyYWNrcyBpbiBhIG1vdmllIGZyYWdtZW50IChtb29mKSBib3guXG4gKi9cbnRyYWYgPSBmdW5jdGlvbih0cmFjaykge1xuICB2YXIgdHJhY2tGcmFnbWVudEhlYWRlciwgdHJhY2tGcmFnbWVudERlY29kZVRpbWUsIHRyYWNrRnJhZ21lbnRSdW4sXG4gICAgICBzYW1wbGVEZXBlbmRlbmN5VGFibGUsIGRhdGFPZmZzZXQsXG4gICAgICB1cHBlcldvcmRCYXNlTWVkaWFEZWNvZGVUaW1lLCBsb3dlcldvcmRCYXNlTWVkaWFEZWNvZGVUaW1lO1xuXG4gIHRyYWNrRnJhZ21lbnRIZWFkZXIgPSBib3godHlwZXMudGZoZCwgbmV3IFVpbnQ4QXJyYXkoW1xuICAgIDB4MDAsIC8vIHZlcnNpb24gMFxuICAgIDB4MDAsIDB4MDAsIDB4M2EsIC8vIGZsYWdzXG4gICAgKHRyYWNrLmlkICYgMHhGRjAwMDAwMCkgPj4gMjQsXG4gICAgKHRyYWNrLmlkICYgMHhGRjAwMDApID4+IDE2LFxuICAgICh0cmFjay5pZCAmIDB4RkYwMCkgPj4gOCxcbiAgICAodHJhY2suaWQgJiAweEZGKSwgLy8gdHJhY2tfSURcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAxLCAvLyBzYW1wbGVfZGVzY3JpcHRpb25faW5kZXhcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyBkZWZhdWx0X3NhbXBsZV9kdXJhdGlvblxuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIGRlZmF1bHRfc2FtcGxlX3NpemVcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwICAvLyBkZWZhdWx0X3NhbXBsZV9mbGFnc1xuICBdKSk7XG5cbiAgdXBwZXJXb3JkQmFzZU1lZGlhRGVjb2RlVGltZSA9IE1hdGguZmxvb3IodHJhY2suYmFzZU1lZGlhRGVjb2RlVGltZSAvIChVSU5UMzJfTUFYICsgMSkpO1xuICBsb3dlcldvcmRCYXNlTWVkaWFEZWNvZGVUaW1lID0gTWF0aC5mbG9vcih0cmFjay5iYXNlTWVkaWFEZWNvZGVUaW1lICUgKFVJTlQzMl9NQVggKyAxKSk7XG5cbiAgdHJhY2tGcmFnbWVudERlY29kZVRpbWUgPSBib3godHlwZXMudGZkdCwgbmV3IFVpbnQ4QXJyYXkoW1xuICAgIDB4MDEsIC8vIHZlcnNpb24gMVxuICAgIDB4MDAsIDB4MDAsIDB4MDAsIC8vIGZsYWdzXG4gICAgLy8gYmFzZU1lZGlhRGVjb2RlVGltZVxuICAgICh1cHBlcldvcmRCYXNlTWVkaWFEZWNvZGVUaW1lID4+PiAyNCkgJiAweEZGLFxuICAgICh1cHBlcldvcmRCYXNlTWVkaWFEZWNvZGVUaW1lID4+PiAxNikgJiAweEZGLFxuICAgICh1cHBlcldvcmRCYXNlTWVkaWFEZWNvZGVUaW1lID4+PiAgOCkgJiAweEZGLFxuICAgIHVwcGVyV29yZEJhc2VNZWRpYURlY29kZVRpbWUgJiAweEZGLFxuICAgIChsb3dlcldvcmRCYXNlTWVkaWFEZWNvZGVUaW1lID4+PiAyNCkgJiAweEZGLFxuICAgIChsb3dlcldvcmRCYXNlTWVkaWFEZWNvZGVUaW1lID4+PiAxNikgJiAweEZGLFxuICAgIChsb3dlcldvcmRCYXNlTWVkaWFEZWNvZGVUaW1lID4+PiAgOCkgJiAweEZGLFxuICAgIGxvd2VyV29yZEJhc2VNZWRpYURlY29kZVRpbWUgJiAweEZGXG4gIF0pKTtcblxuICAvLyB0aGUgZGF0YSBvZmZzZXQgc3BlY2lmaWVzIHRoZSBudW1iZXIgb2YgYnl0ZXMgZnJvbSB0aGUgc3RhcnQgb2ZcbiAgLy8gdGhlIGNvbnRhaW5pbmcgbW9vZiB0byB0aGUgZmlyc3QgcGF5bG9hZCBieXRlIG9mIHRoZSBhc3NvY2lhdGVkXG4gIC8vIG1kYXRcbiAgZGF0YU9mZnNldCA9ICgzMiArIC8vIHRmaGRcbiAgICAgICAgICAgICAgICAyMCArIC8vIHRmZHRcbiAgICAgICAgICAgICAgICA4ICsgIC8vIHRyYWYgaGVhZGVyXG4gICAgICAgICAgICAgICAgMTYgKyAvLyBtZmhkXG4gICAgICAgICAgICAgICAgOCArICAvLyBtb29mIGhlYWRlclxuICAgICAgICAgICAgICAgIDgpOyAgLy8gbWRhdCBoZWFkZXJcblxuICAvLyBhdWRpbyB0cmFja3MgcmVxdWlyZSBsZXNzIG1ldGFkYXRhXG4gIGlmICh0cmFjay50eXBlID09PSAnYXVkaW8nKSB7XG4gICAgdHJhY2tGcmFnbWVudFJ1biA9IHRydW4odHJhY2ssIGRhdGFPZmZzZXQpO1xuICAgIHJldHVybiBib3godHlwZXMudHJhZixcbiAgICAgICAgICAgICAgIHRyYWNrRnJhZ21lbnRIZWFkZXIsXG4gICAgICAgICAgICAgICB0cmFja0ZyYWdtZW50RGVjb2RlVGltZSxcbiAgICAgICAgICAgICAgIHRyYWNrRnJhZ21lbnRSdW4pO1xuICB9XG5cbiAgLy8gdmlkZW8gdHJhY2tzIHNob3VsZCBjb250YWluIGFuIGluZGVwZW5kZW50IGFuZCBkaXNwb3NhYmxlIHNhbXBsZXNcbiAgLy8gYm94IChzZHRwKVxuICAvLyBnZW5lcmF0ZSBvbmUgYW5kIGFkanVzdCBvZmZzZXRzIHRvIG1hdGNoXG4gIHNhbXBsZURlcGVuZGVuY3lUYWJsZSA9IHNkdHAodHJhY2spO1xuICB0cmFja0ZyYWdtZW50UnVuID0gdHJ1bih0cmFjayxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgc2FtcGxlRGVwZW5kZW5jeVRhYmxlLmxlbmd0aCArIGRhdGFPZmZzZXQpO1xuICByZXR1cm4gYm94KHR5cGVzLnRyYWYsXG4gICAgICAgICAgICAgdHJhY2tGcmFnbWVudEhlYWRlcixcbiAgICAgICAgICAgICB0cmFja0ZyYWdtZW50RGVjb2RlVGltZSxcbiAgICAgICAgICAgICB0cmFja0ZyYWdtZW50UnVuLFxuICAgICAgICAgICAgIHNhbXBsZURlcGVuZGVuY3lUYWJsZSk7XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlIGEgdHJhY2sgYm94LlxuICogQHBhcmFtIHRyYWNrIHtvYmplY3R9IGEgdHJhY2sgZGVmaW5pdGlvblxuICogQHJldHVybiB7VWludDhBcnJheX0gdGhlIHRyYWNrIGJveFxuICovXG50cmFrID0gZnVuY3Rpb24odHJhY2spIHtcbiAgdHJhY2suZHVyYXRpb24gPSB0cmFjay5kdXJhdGlvbiB8fCAweGZmZmZmZmZmO1xuICByZXR1cm4gYm94KHR5cGVzLnRyYWssXG4gICAgICAgICAgICAgdGtoZCh0cmFjayksXG4gICAgICAgICAgICAgbWRpYSh0cmFjaykpO1xufTtcblxudHJleCA9IGZ1bmN0aW9uKHRyYWNrKSB7XG4gIHZhciByZXN1bHQgPSBuZXcgVWludDhBcnJheShbXG4gICAgMHgwMCwgLy8gdmVyc2lvbiAwXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgLy8gZmxhZ3NcbiAgICAodHJhY2suaWQgJiAweEZGMDAwMDAwKSA+PiAyNCxcbiAgICAodHJhY2suaWQgJiAweEZGMDAwMCkgPj4gMTYsXG4gICAgKHRyYWNrLmlkICYgMHhGRjAwKSA+PiA4LFxuICAgICh0cmFjay5pZCAmIDB4RkYpLCAvLyB0cmFja19JRFxuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDEsIC8vIGRlZmF1bHRfc2FtcGxlX2Rlc2NyaXB0aW9uX2luZGV4XG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gZGVmYXVsdF9zYW1wbGVfZHVyYXRpb25cbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyBkZWZhdWx0X3NhbXBsZV9zaXplXG4gICAgMHgwMCwgMHgwMSwgMHgwMCwgMHgwMSAvLyBkZWZhdWx0X3NhbXBsZV9mbGFnc1xuICBdKTtcbiAgLy8gdGhlIGxhc3QgdHdvIGJ5dGVzIG9mIGRlZmF1bHRfc2FtcGxlX2ZsYWdzIGlzIHRoZSBzYW1wbGVcbiAgLy8gZGVncmFkYXRpb24gcHJpb3JpdHksIGEgaGludCBhYm91dCB0aGUgaW1wb3J0YW5jZSBvZiB0aGlzIHNhbXBsZVxuICAvLyByZWxhdGl2ZSB0byBvdGhlcnMuIExvd2VyIHRoZSBkZWdyYWRhdGlvbiBwcmlvcml0eSBmb3IgYWxsIHNhbXBsZVxuICAvLyB0eXBlcyBvdGhlciB0aGFuIHZpZGVvLlxuICBpZiAodHJhY2sudHlwZSAhPT0gJ3ZpZGVvJykge1xuICAgIHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMV0gPSAweDAwO1xuICB9XG5cbiAgcmV0dXJuIGJveCh0eXBlcy50cmV4LCByZXN1bHQpO1xufTtcblxuKGZ1bmN0aW9uKCkge1xuICB2YXIgYXVkaW9UcnVuLCB2aWRlb1RydW4sIHRydW5IZWFkZXI7XG5cbiAgLy8gVGhpcyBtZXRob2QgYXNzdW1lcyBhbGwgc2FtcGxlcyBhcmUgdW5pZm9ybS4gVGhhdCBpcywgaWYgYVxuICAvLyBkdXJhdGlvbiBpcyBwcmVzZW50IGZvciB0aGUgZmlyc3Qgc2FtcGxlLCBpdCB3aWxsIGJlIHByZXNlbnQgZm9yXG4gIC8vIGFsbCBzdWJzZXF1ZW50IHNhbXBsZXMuXG4gIC8vIHNlZSBJU08vSUVDIDE0NDk2LTEyOjIwMTIsIFNlY3Rpb24gOC44LjguMVxuICB0cnVuSGVhZGVyID0gZnVuY3Rpb24oc2FtcGxlcywgb2Zmc2V0KSB7XG4gICAgdmFyIGR1cmF0aW9uUHJlc2VudCA9IDAsIHNpemVQcmVzZW50ID0gMCxcbiAgICAgICAgZmxhZ3NQcmVzZW50ID0gMCwgY29tcG9zaXRpb25UaW1lT2Zmc2V0ID0gMDtcblxuICAgIC8vIHRydW4gZmxhZyBjb25zdGFudHNcbiAgICBpZiAoc2FtcGxlcy5sZW5ndGgpIHtcbiAgICAgIGlmIChzYW1wbGVzWzBdLmR1cmF0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZHVyYXRpb25QcmVzZW50ID0gMHgxO1xuICAgICAgfVxuICAgICAgaWYgKHNhbXBsZXNbMF0uc2l6ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHNpemVQcmVzZW50ID0gMHgyO1xuICAgICAgfVxuICAgICAgaWYgKHNhbXBsZXNbMF0uZmxhZ3MgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBmbGFnc1ByZXNlbnQgPSAweDQ7XG4gICAgICB9XG4gICAgICBpZiAoc2FtcGxlc1swXS5jb21wb3NpdGlvblRpbWVPZmZzZXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb21wb3NpdGlvblRpbWVPZmZzZXQgPSAweDg7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFtcbiAgICAgIDB4MDAsIC8vIHZlcnNpb24gMFxuICAgICAgMHgwMCxcbiAgICAgIGR1cmF0aW9uUHJlc2VudCB8IHNpemVQcmVzZW50IHwgZmxhZ3NQcmVzZW50IHwgY29tcG9zaXRpb25UaW1lT2Zmc2V0LFxuICAgICAgMHgwMSwgLy8gZmxhZ3NcbiAgICAgIChzYW1wbGVzLmxlbmd0aCAmIDB4RkYwMDAwMDApID4+PiAyNCxcbiAgICAgIChzYW1wbGVzLmxlbmd0aCAmIDB4RkYwMDAwKSA+Pj4gMTYsXG4gICAgICAoc2FtcGxlcy5sZW5ndGggJiAweEZGMDApID4+PiA4LFxuICAgICAgc2FtcGxlcy5sZW5ndGggJiAweEZGLCAvLyBzYW1wbGVfY291bnRcbiAgICAgIChvZmZzZXQgJiAweEZGMDAwMDAwKSA+Pj4gMjQsXG4gICAgICAob2Zmc2V0ICYgMHhGRjAwMDApID4+PiAxNixcbiAgICAgIChvZmZzZXQgJiAweEZGMDApID4+PiA4LFxuICAgICAgb2Zmc2V0ICYgMHhGRiAvLyBkYXRhX29mZnNldFxuICAgIF07XG4gIH07XG5cbiAgdmlkZW9UcnVuID0gZnVuY3Rpb24odHJhY2ssIG9mZnNldCkge1xuICAgIHZhciBieXRlcywgc2FtcGxlcywgc2FtcGxlLCBpO1xuXG4gICAgc2FtcGxlcyA9IHRyYWNrLnNhbXBsZXMgfHwgW107XG4gICAgb2Zmc2V0ICs9IDggKyAxMiArICgxNiAqIHNhbXBsZXMubGVuZ3RoKTtcblxuICAgIGJ5dGVzID0gdHJ1bkhlYWRlcihzYW1wbGVzLCBvZmZzZXQpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHNhbXBsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHNhbXBsZSA9IHNhbXBsZXNbaV07XG4gICAgICBieXRlcyA9IGJ5dGVzLmNvbmNhdChbXG4gICAgICAgIChzYW1wbGUuZHVyYXRpb24gJiAweEZGMDAwMDAwKSA+Pj4gMjQsXG4gICAgICAgIChzYW1wbGUuZHVyYXRpb24gJiAweEZGMDAwMCkgPj4+IDE2LFxuICAgICAgICAoc2FtcGxlLmR1cmF0aW9uICYgMHhGRjAwKSA+Pj4gOCxcbiAgICAgICAgc2FtcGxlLmR1cmF0aW9uICYgMHhGRiwgLy8gc2FtcGxlX2R1cmF0aW9uXG4gICAgICAgIChzYW1wbGUuc2l6ZSAmIDB4RkYwMDAwMDApID4+PiAyNCxcbiAgICAgICAgKHNhbXBsZS5zaXplICYgMHhGRjAwMDApID4+PiAxNixcbiAgICAgICAgKHNhbXBsZS5zaXplICYgMHhGRjAwKSA+Pj4gOCxcbiAgICAgICAgc2FtcGxlLnNpemUgJiAweEZGLCAvLyBzYW1wbGVfc2l6ZVxuICAgICAgICAoc2FtcGxlLmZsYWdzLmlzTGVhZGluZyA8PCAyKSB8IHNhbXBsZS5mbGFncy5kZXBlbmRzT24sXG4gICAgICAgIChzYW1wbGUuZmxhZ3MuaXNEZXBlbmRlZE9uIDw8IDYpIHxcbiAgICAgICAgICAoc2FtcGxlLmZsYWdzLmhhc1JlZHVuZGFuY3kgPDwgNCkgfFxuICAgICAgICAgIChzYW1wbGUuZmxhZ3MucGFkZGluZ1ZhbHVlIDw8IDEpIHxcbiAgICAgICAgICBzYW1wbGUuZmxhZ3MuaXNOb25TeW5jU2FtcGxlLFxuICAgICAgICBzYW1wbGUuZmxhZ3MuZGVncmFkYXRpb25Qcmlvcml0eSAmIDB4RjAgPDwgOCxcbiAgICAgICAgc2FtcGxlLmZsYWdzLmRlZ3JhZGF0aW9uUHJpb3JpdHkgJiAweDBGLCAvLyBzYW1wbGVfZmxhZ3NcbiAgICAgICAgKHNhbXBsZS5jb21wb3NpdGlvblRpbWVPZmZzZXQgJiAweEZGMDAwMDAwKSA+Pj4gMjQsXG4gICAgICAgIChzYW1wbGUuY29tcG9zaXRpb25UaW1lT2Zmc2V0ICYgMHhGRjAwMDApID4+PiAxNixcbiAgICAgICAgKHNhbXBsZS5jb21wb3NpdGlvblRpbWVPZmZzZXQgJiAweEZGMDApID4+PiA4LFxuICAgICAgICBzYW1wbGUuY29tcG9zaXRpb25UaW1lT2Zmc2V0ICYgMHhGRiAvLyBzYW1wbGVfY29tcG9zaXRpb25fdGltZV9vZmZzZXRcbiAgICAgIF0pO1xuICAgIH1cbiAgICByZXR1cm4gYm94KHR5cGVzLnRydW4sIG5ldyBVaW50OEFycmF5KGJ5dGVzKSk7XG4gIH07XG5cbiAgYXVkaW9UcnVuID0gZnVuY3Rpb24odHJhY2ssIG9mZnNldCkge1xuICAgIHZhciBieXRlcywgc2FtcGxlcywgc2FtcGxlLCBpO1xuXG4gICAgc2FtcGxlcyA9IHRyYWNrLnNhbXBsZXMgfHwgW107XG4gICAgb2Zmc2V0ICs9IDggKyAxMiArICg4ICogc2FtcGxlcy5sZW5ndGgpO1xuXG4gICAgYnl0ZXMgPSB0cnVuSGVhZGVyKHNhbXBsZXMsIG9mZnNldCk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgc2FtcGxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgc2FtcGxlID0gc2FtcGxlc1tpXTtcbiAgICAgIGJ5dGVzID0gYnl0ZXMuY29uY2F0KFtcbiAgICAgICAgKHNhbXBsZS5kdXJhdGlvbiAmIDB4RkYwMDAwMDApID4+PiAyNCxcbiAgICAgICAgKHNhbXBsZS5kdXJhdGlvbiAmIDB4RkYwMDAwKSA+Pj4gMTYsXG4gICAgICAgIChzYW1wbGUuZHVyYXRpb24gJiAweEZGMDApID4+PiA4LFxuICAgICAgICBzYW1wbGUuZHVyYXRpb24gJiAweEZGLCAvLyBzYW1wbGVfZHVyYXRpb25cbiAgICAgICAgKHNhbXBsZS5zaXplICYgMHhGRjAwMDAwMCkgPj4+IDI0LFxuICAgICAgICAoc2FtcGxlLnNpemUgJiAweEZGMDAwMCkgPj4+IDE2LFxuICAgICAgICAoc2FtcGxlLnNpemUgJiAweEZGMDApID4+PiA4LFxuICAgICAgICBzYW1wbGUuc2l6ZSAmIDB4RkZdKTsgLy8gc2FtcGxlX3NpemVcbiAgICB9XG5cbiAgICByZXR1cm4gYm94KHR5cGVzLnRydW4sIG5ldyBVaW50OEFycmF5KGJ5dGVzKSk7XG4gIH07XG5cbiAgdHJ1biA9IGZ1bmN0aW9uKHRyYWNrLCBvZmZzZXQpIHtcbiAgICBpZiAodHJhY2sudHlwZSA9PT0gJ2F1ZGlvJykge1xuICAgICAgcmV0dXJuIGF1ZGlvVHJ1bih0cmFjaywgb2Zmc2V0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmlkZW9UcnVuKHRyYWNrLCBvZmZzZXQpO1xuICB9O1xufSgpKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGZ0eXA6IGZ0eXAsXG4gIG1kYXQ6IG1kYXQsXG4gIG1vb2Y6IG1vb2YsXG4gIG1vb3Y6IG1vb3YsXG4gIGluaXRTZWdtZW50OiBmdW5jdGlvbih0cmFja3MpIHtcbiAgICB2YXJcbiAgICAgIGZpbGVUeXBlID0gZnR5cCgpLFxuICAgICAgbW92aWUgPSBtb292KHRyYWNrcyksXG4gICAgICByZXN1bHQ7XG5cbiAgICByZXN1bHQgPSBuZXcgVWludDhBcnJheShmaWxlVHlwZS5ieXRlTGVuZ3RoICsgbW92aWUuYnl0ZUxlbmd0aCk7XG4gICAgcmVzdWx0LnNldChmaWxlVHlwZSk7XG4gICAgcmVzdWx0LnNldChtb3ZpZSwgZmlsZVR5cGUuYnl0ZUxlbmd0aCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/videojs-contrib-media-sources/node_modules/mux.js/lib/mp4/mp4-generator.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/videojs-contrib-media-sources/node_modules/mux.js/lib/mp4/transmuxer.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/videojs-contrib-media-sources/node_modules/mux.js/lib/mp4/transmuxer.js ***!
  \**********************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/**\n * mux.js\n *\n * Copyright (c) 2015 Brightcove\n * All rights reserved.\n *\n * A stream-based mp2t to mp4 converter. This utility can be used to\n * deliver mp4s to a SourceBuffer on platforms that support native\n * Media Source Extensions.\n */\n\n\nvar Stream = __webpack_require__(/*! ../utils/stream.js */ \"(ssr)/./node_modules/videojs-contrib-media-sources/node_modules/mux.js/lib/utils/stream.js\");\nvar mp4 = __webpack_require__(/*! ./mp4-generator.js */ \"(ssr)/./node_modules/videojs-contrib-media-sources/node_modules/mux.js/lib/mp4/mp4-generator.js\");\nvar m2ts = __webpack_require__(/*! ../m2ts/m2ts.js */ \"(ssr)/./node_modules/videojs-contrib-media-sources/node_modules/mux.js/lib/m2ts/m2ts.js\");\nvar AdtsStream = __webpack_require__(/*! ../codecs/adts.js */ \"(ssr)/./node_modules/videojs-contrib-media-sources/node_modules/mux.js/lib/codecs/adts.js\");\nvar H264Stream = (__webpack_require__(/*! ../codecs/h264 */ \"(ssr)/./node_modules/videojs-contrib-media-sources/node_modules/mux.js/lib/codecs/h264.js\").H264Stream);\nvar AacStream = __webpack_require__(/*! ../aac */ \"(ssr)/./node_modules/videojs-contrib-media-sources/node_modules/mux.js/lib/aac/index.js\");\nvar coneOfSilence = __webpack_require__(/*! ../data/silence */ \"(ssr)/./node_modules/videojs-contrib-media-sources/node_modules/mux.js/lib/data/silence.js\");\nvar clock = __webpack_require__(/*! ../utils/clock */ \"(ssr)/./node_modules/videojs-contrib-media-sources/node_modules/mux.js/lib/utils/clock.js\");\n\n// constants\nvar AUDIO_PROPERTIES = [\n  'audioobjecttype',\n  'channelcount',\n  'samplerate',\n  'samplingfrequencyindex',\n  'samplesize'\n];\n\nvar VIDEO_PROPERTIES = [\n  'width',\n  'height',\n  'profileIdc',\n  'levelIdc',\n  'profileCompatibility'\n];\n\nvar ONE_SECOND_IN_TS = 90000; // 90kHz clock\n\n// object types\nvar VideoSegmentStream, AudioSegmentStream, Transmuxer, CoalesceStream;\n\n// Helper functions\nvar\n  createDefaultSample,\n  isLikelyAacData,\n  collectDtsInfo,\n  clearDtsInfo,\n  calculateTrackBaseMediaDecodeTime,\n  arrayEquals,\n  sumFrameByteLengths;\n\n/**\n * Default sample object\n * see ISO/IEC 14496-12:2012, section 8.6.4.3\n */\ncreateDefaultSample = function() {\n  return {\n    size: 0,\n    flags: {\n      isLeading: 0,\n      dependsOn: 1,\n      isDependedOn: 0,\n      hasRedundancy: 0,\n      degradationPriority: 0\n    }\n  };\n};\n\nisLikelyAacData = function(data) {\n  if ((data[0] === 'I'.charCodeAt(0)) &&\n      (data[1] === 'D'.charCodeAt(0)) &&\n      (data[2] === '3'.charCodeAt(0))) {\n    return true;\n  }\n  return false;\n};\n\n/**\n * Compare two arrays (even typed) for same-ness\n */\narrayEquals = function(a, b) {\n  var\n    i;\n\n  if (a.length !== b.length) {\n    return false;\n  }\n\n  // compare the value of each element in the array\n  for (i = 0; i < a.length; i++) {\n    if (a[i] !== b[i]) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\n/**\n * Sum the `byteLength` properties of the data in each AAC frame\n */\nsumFrameByteLengths = function(array) {\n  var\n    i,\n    currentObj,\n    sum = 0;\n\n  // sum the byteLength's all each nal unit in the frame\n  for (i = 0; i < array.length; i++) {\n    currentObj = array[i];\n    sum += currentObj.data.byteLength;\n  }\n\n  return sum;\n};\n\n/**\n * Constructs a single-track, ISO BMFF media segment from AAC data\n * events. The output of this stream can be fed to a SourceBuffer\n * configured with a suitable initialization segment.\n */\nAudioSegmentStream = function(track) {\n  var\n    adtsFrames = [],\n    sequenceNumber = 0,\n    earliestAllowedDts = 0,\n    audioAppendStartTs = 0,\n    videoBaseMediaDecodeTime = Infinity;\n\n  AudioSegmentStream.prototype.init.call(this);\n\n  this.push = function(data) {\n    collectDtsInfo(track, data);\n\n    if (track) {\n      AUDIO_PROPERTIES.forEach(function(prop) {\n        track[prop] = data[prop];\n      });\n    }\n\n    // buffer audio data until end() is called\n    adtsFrames.push(data);\n  };\n\n  this.setEarliestDts = function(earliestDts) {\n    earliestAllowedDts = earliestDts - track.timelineStartInfo.baseMediaDecodeTime;\n  };\n\n  this.setVideoBaseMediaDecodeTime = function(baseMediaDecodeTime) {\n    videoBaseMediaDecodeTime = baseMediaDecodeTime;\n  };\n\n  this.setAudioAppendStart = function(timestamp) {\n    audioAppendStartTs = timestamp;\n  };\n\n  this.flush = function() {\n    var\n      frames,\n      moof,\n      mdat,\n      boxes;\n\n    // return early if no audio data has been observed\n    if (adtsFrames.length === 0) {\n      this.trigger('done', 'AudioSegmentStream');\n      return;\n    }\n\n    frames = this.trimAdtsFramesByEarliestDts_(adtsFrames);\n    track.baseMediaDecodeTime = calculateTrackBaseMediaDecodeTime(track);\n\n    this.prefixWithSilence_(track, frames);\n\n    // we have to build the index from byte locations to\n    // samples (that is, adts frames) in the audio data\n    track.samples = this.generateSampleTable_(frames);\n\n    // concatenate the audio data to constuct the mdat\n    mdat = mp4.mdat(this.concatenateFrameData_(frames));\n\n    adtsFrames = [];\n\n    moof = mp4.moof(sequenceNumber, [track]);\n    boxes = new Uint8Array(moof.byteLength + mdat.byteLength);\n\n    // bump the sequence number for next time\n    sequenceNumber++;\n\n    boxes.set(moof);\n    boxes.set(mdat, moof.byteLength);\n\n    clearDtsInfo(track);\n\n    this.trigger('data', {track: track, boxes: boxes});\n    this.trigger('done', 'AudioSegmentStream');\n  };\n\n  // Possibly pad (prefix) the audio track with silence if appending this track\n  // would lead to the introduction of a gap in the audio buffer\n  this.prefixWithSilence_ = function(track, frames) {\n    var\n      baseMediaDecodeTimeTs,\n      frameDuration = 0,\n      audioGapDuration = 0,\n      audioFillFrameCount = 0,\n      audioFillDuration = 0,\n      silentFrame,\n      i;\n\n    if (!frames.length) {\n      return;\n    }\n\n    baseMediaDecodeTimeTs = clock.audioTsToVideoTs(track.baseMediaDecodeTime, track.samplerate);\n    // determine frame clock duration based on sample rate, round up to avoid overfills\n    frameDuration = Math.ceil(ONE_SECOND_IN_TS / (track.samplerate / 1024));\n\n    if (audioAppendStartTs && videoBaseMediaDecodeTime) {\n      // insert the shortest possible amount (audio gap or audio to video gap)\n      audioGapDuration =\n        baseMediaDecodeTimeTs - Math.max(audioAppendStartTs, videoBaseMediaDecodeTime);\n      // number of full frames in the audio gap\n      audioFillFrameCount = Math.floor(audioGapDuration / frameDuration);\n      audioFillDuration = audioFillFrameCount * frameDuration;\n    }\n\n    // don't attempt to fill gaps smaller than a single frame or larger\n    // than a half second\n    if (audioFillFrameCount < 1 || audioFillDuration > ONE_SECOND_IN_TS / 2) {\n      return;\n    }\n\n    silentFrame = coneOfSilence[track.samplerate];\n\n    if (!silentFrame) {\n      // we don't have a silent frame pregenerated for the sample rate, so use a frame\n      // from the content instead\n      silentFrame = frames[0].data;\n    }\n\n    for (i = 0; i < audioFillFrameCount; i++) {\n      frames.splice(i, 0, {\n        data: silentFrame\n      });\n    }\n\n    track.baseMediaDecodeTime -=\n      Math.floor(clock.videoTsToAudioTs(audioFillDuration, track.samplerate));\n  };\n\n  // If the audio segment extends before the earliest allowed dts\n  // value, remove AAC frames until starts at or after the earliest\n  // allowed DTS so that we don't end up with a negative baseMedia-\n  // DecodeTime for the audio track\n  this.trimAdtsFramesByEarliestDts_ = function(adtsFrames) {\n    if (track.minSegmentDts >= earliestAllowedDts) {\n      return adtsFrames;\n    }\n\n    // We will need to recalculate the earliest segment Dts\n    track.minSegmentDts = Infinity;\n\n    return adtsFrames.filter(function(currentFrame) {\n      // If this is an allowed frame, keep it and record it's Dts\n      if (currentFrame.dts >= earliestAllowedDts) {\n        track.minSegmentDts = Math.min(track.minSegmentDts, currentFrame.dts);\n        track.minSegmentPts = track.minSegmentDts;\n        return true;\n      }\n      // Otherwise, discard it\n      return false;\n    });\n  };\n\n  // generate the track's raw mdat data from an array of frames\n  this.generateSampleTable_ = function(frames) {\n    var\n      i,\n      currentFrame,\n      samples = [];\n\n    for (i = 0; i < frames.length; i++) {\n      currentFrame = frames[i];\n      samples.push({\n        size: currentFrame.data.byteLength,\n        duration: 1024 // For AAC audio, all samples contain 1024 samples\n      });\n    }\n    return samples;\n  };\n\n  // generate the track's sample table from an array of frames\n  this.concatenateFrameData_ = function(frames) {\n    var\n      i,\n      currentFrame,\n      dataOffset = 0,\n      data = new Uint8Array(sumFrameByteLengths(frames));\n\n    for (i = 0; i < frames.length; i++) {\n      currentFrame = frames[i];\n\n      data.set(currentFrame.data, dataOffset);\n      dataOffset += currentFrame.data.byteLength;\n    }\n    return data;\n  };\n};\n\nAudioSegmentStream.prototype = new Stream();\n\n/**\n * Constructs a single-track, ISO BMFF media segment from H264 data\n * events. The output of this stream can be fed to a SourceBuffer\n * configured with a suitable initialization segment.\n * @param track {object} track metadata configuration\n * @param options {object} transmuxer options object\n * @param options.alignGopsAtEnd {boolean} If true, start from the end of the\n *        gopsToAlignWith list when attempting to align gop pts\n */\nVideoSegmentStream = function(track, options) {\n  var\n    sequenceNumber = 0,\n    nalUnits = [],\n    gopsToAlignWith = [],\n    config,\n    pps;\n\n  options = options || {};\n\n  VideoSegmentStream.prototype.init.call(this);\n\n  delete track.minPTS;\n\n  this.gopCache_ = [];\n\n  this.push = function(nalUnit) {\n    collectDtsInfo(track, nalUnit);\n\n    // record the track config\n    if (nalUnit.nalUnitType === 'seq_parameter_set_rbsp' && !config) {\n      config = nalUnit.config;\n      track.sps = [nalUnit.data];\n\n      VIDEO_PROPERTIES.forEach(function(prop) {\n        track[prop] = config[prop];\n      }, this);\n    }\n\n    if (nalUnit.nalUnitType === 'pic_parameter_set_rbsp' &&\n        !pps) {\n      pps = nalUnit.data;\n      track.pps = [nalUnit.data];\n    }\n\n    // buffer video until flush() is called\n    nalUnits.push(nalUnit);\n  };\n\n  this.flush = function() {\n    var\n      frames,\n      gopForFusion,\n      gops,\n      moof,\n      mdat,\n      boxes;\n\n    // Throw away nalUnits at the start of the byte stream until\n    // we find the first AUD\n    while (nalUnits.length) {\n      if (nalUnits[0].nalUnitType === 'access_unit_delimiter_rbsp') {\n        break;\n      }\n      nalUnits.shift();\n    }\n\n    // Return early if no video data has been observed\n    if (nalUnits.length === 0) {\n      this.resetStream_();\n      this.trigger('done', 'VideoSegmentStream');\n      return;\n    }\n\n    // Organize the raw nal-units into arrays that represent\n    // higher-level constructs such as frames and gops\n    // (group-of-pictures)\n    frames = this.groupNalsIntoFrames_(nalUnits);\n    gops = this.groupFramesIntoGops_(frames);\n\n    // If the first frame of this fragment is not a keyframe we have\n    // a problem since MSE (on Chrome) requires a leading keyframe.\n    //\n    // We have two approaches to repairing this situation:\n    // 1) GOP-FUSION:\n    //    This is where we keep track of the GOPS (group-of-pictures)\n    //    from previous fragments and attempt to find one that we can\n    //    prepend to the current fragment in order to create a valid\n    //    fragment.\n    // 2) KEYFRAME-PULLING:\n    //    Here we search for the first keyframe in the fragment and\n    //    throw away all the frames between the start of the fragment\n    //    and that keyframe. We then extend the duration and pull the\n    //    PTS of the keyframe forward so that it covers the time range\n    //    of the frames that were disposed of.\n    //\n    // #1 is far prefereable over #2 which can cause \"stuttering\" but\n    // requires more things to be just right.\n    if (!gops[0][0].keyFrame) {\n      // Search for a gop for fusion from our gopCache\n      gopForFusion = this.getGopForFusion_(nalUnits[0], track);\n\n      if (gopForFusion) {\n        gops.unshift(gopForFusion);\n        // Adjust Gops' metadata to account for the inclusion of the\n        // new gop at the beginning\n        gops.byteLength += gopForFusion.byteLength;\n        gops.nalCount += gopForFusion.nalCount;\n        gops.pts = gopForFusion.pts;\n        gops.dts = gopForFusion.dts;\n        gops.duration += gopForFusion.duration;\n      } else {\n        // If we didn't find a candidate gop fall back to keyrame-pulling\n        gops = this.extendFirstKeyFrame_(gops);\n      }\n    }\n\n    // Trim gops to align with gopsToAlignWith\n    if (gopsToAlignWith.length) {\n      var alignedGops;\n\n      if (options.alignGopsAtEnd) {\n        alignedGops = this.alignGopsAtEnd_(gops);\n      } else {\n        alignedGops = this.alignGopsAtStart_(gops);\n      }\n\n      if (!alignedGops) {\n        // save all the nals in the last GOP into the gop cache\n        this.gopCache_.unshift({\n          gop: gops.pop(),\n          pps: track.pps,\n          sps: track.sps\n        });\n\n        // Keep a maximum of 6 GOPs in the cache\n        this.gopCache_.length = Math.min(6, this.gopCache_.length);\n\n        // Clear nalUnits\n        nalUnits = [];\n\n        // return early no gops can be aligned with desired gopsToAlignWith\n        this.resetStream_();\n        this.trigger('done', 'VideoSegmentStream');\n        return;\n      }\n\n      // Some gops were trimmed. clear dts info so minSegmentDts and pts are correct\n      // when recalculated before sending off to CoalesceStream\n      clearDtsInfo(track);\n\n      gops = alignedGops;\n    }\n\n    collectDtsInfo(track, gops);\n\n    // First, we have to build the index from byte locations to\n    // samples (that is, frames) in the video data\n    track.samples = this.generateSampleTable_(gops);\n\n    // Concatenate the video data and construct the mdat\n    mdat = mp4.mdat(this.concatenateNalData_(gops));\n\n    track.baseMediaDecodeTime = calculateTrackBaseMediaDecodeTime(track);\n\n    this.trigger('processedGopsInfo', gops.map(function(gop) {\n      return {\n        pts: gop.pts,\n        dts: gop.dts,\n        byteLength: gop.byteLength\n      };\n    }));\n\n    // save all the nals in the last GOP into the gop cache\n    this.gopCache_.unshift({\n      gop: gops.pop(),\n      pps: track.pps,\n      sps: track.sps\n    });\n\n    // Keep a maximum of 6 GOPs in the cache\n    this.gopCache_.length = Math.min(6, this.gopCache_.length);\n\n    // Clear nalUnits\n    nalUnits = [];\n\n    this.trigger('baseMediaDecodeTime', track.baseMediaDecodeTime);\n    this.trigger('timelineStartInfo', track.timelineStartInfo);\n\n    moof = mp4.moof(sequenceNumber, [track]);\n\n    // it would be great to allocate this array up front instead of\n    // throwing away hundreds of media segment fragments\n    boxes = new Uint8Array(moof.byteLength + mdat.byteLength);\n\n    // Bump the sequence number for next time\n    sequenceNumber++;\n\n    boxes.set(moof);\n    boxes.set(mdat, moof.byteLength);\n\n    this.trigger('data', {track: track, boxes: boxes});\n\n    this.resetStream_();\n\n    // Continue with the flush process now\n    this.trigger('done', 'VideoSegmentStream');\n  };\n\n  this.resetStream_ = function() {\n    clearDtsInfo(track);\n\n    // reset config and pps because they may differ across segments\n    // for instance, when we are rendition switching\n    config = undefined;\n    pps = undefined;\n  };\n\n  // Search for a candidate Gop for gop-fusion from the gop cache and\n  // return it or return null if no good candidate was found\n  this.getGopForFusion_ = function(nalUnit) {\n    var\n      halfSecond = 45000, // Half-a-second in a 90khz clock\n      allowableOverlap = 10000, // About 3 frames @ 30fps\n      nearestDistance = Infinity,\n      dtsDistance,\n      nearestGopObj,\n      currentGop,\n      currentGopObj,\n      i;\n\n    // Search for the GOP nearest to the beginning of this nal unit\n    for (i = 0; i < this.gopCache_.length; i++) {\n      currentGopObj = this.gopCache_[i];\n      currentGop = currentGopObj.gop;\n\n      // Reject Gops with different SPS or PPS\n      if (!(track.pps && arrayEquals(track.pps[0], currentGopObj.pps[0])) ||\n          !(track.sps && arrayEquals(track.sps[0], currentGopObj.sps[0]))) {\n        continue;\n      }\n\n      // Reject Gops that would require a negative baseMediaDecodeTime\n      if (currentGop.dts < track.timelineStartInfo.dts) {\n        continue;\n      }\n\n      // The distance between the end of the gop and the start of the nalUnit\n      dtsDistance = (nalUnit.dts - currentGop.dts) - currentGop.duration;\n\n      // Only consider GOPS that start before the nal unit and end within\n      // a half-second of the nal unit\n      if (dtsDistance >= -allowableOverlap &&\n          dtsDistance <= halfSecond) {\n\n        // Always use the closest GOP we found if there is more than\n        // one candidate\n        if (!nearestGopObj ||\n            nearestDistance > dtsDistance) {\n          nearestGopObj = currentGopObj;\n          nearestDistance = dtsDistance;\n        }\n      }\n    }\n\n    if (nearestGopObj) {\n      return nearestGopObj.gop;\n    }\n    return null;\n  };\n\n  this.extendFirstKeyFrame_ = function(gops) {\n    var currentGop;\n\n    if (!gops[0][0].keyFrame && gops.length > 1) {\n      // Remove the first GOP\n      currentGop = gops.shift();\n\n      gops.byteLength -=  currentGop.byteLength;\n      gops.nalCount -= currentGop.nalCount;\n\n      // Extend the first frame of what is now the\n      // first gop to cover the time period of the\n      // frames we just removed\n      gops[0][0].dts = currentGop.dts;\n      gops[0][0].pts = currentGop.pts;\n      gops[0][0].duration += currentGop.duration;\n    }\n\n    return gops;\n  };\n\n  // Convert an array of nal units into an array of frames with each frame being\n  // composed of the nal units that make up that frame\n  // Also keep track of cummulative data about the frame from the nal units such\n  // as the frame duration, starting pts, etc.\n  this.groupNalsIntoFrames_ = function(nalUnits) {\n    var\n      i,\n      currentNal,\n      currentFrame = [],\n      frames = [];\n\n    currentFrame.byteLength = 0;\n\n    for (i = 0; i < nalUnits.length; i++) {\n      currentNal = nalUnits[i];\n\n      // Split on 'aud'-type nal units\n      if (currentNal.nalUnitType === 'access_unit_delimiter_rbsp') {\n        // Since the very first nal unit is expected to be an AUD\n        // only push to the frames array when currentFrame is not empty\n        if (currentFrame.length) {\n          currentFrame.duration = currentNal.dts - currentFrame.dts;\n          frames.push(currentFrame);\n        }\n        currentFrame = [currentNal];\n        currentFrame.byteLength = currentNal.data.byteLength;\n        currentFrame.pts = currentNal.pts;\n        currentFrame.dts = currentNal.dts;\n      } else {\n        // Specifically flag key frames for ease of use later\n        if (currentNal.nalUnitType === 'slice_layer_without_partitioning_rbsp_idr') {\n          currentFrame.keyFrame = true;\n        }\n        currentFrame.duration = currentNal.dts - currentFrame.dts;\n        currentFrame.byteLength += currentNal.data.byteLength;\n        currentFrame.push(currentNal);\n      }\n    }\n\n    // For the last frame, use the duration of the previous frame if we\n    // have nothing better to go on\n    if (frames.length &&\n        (!currentFrame.duration ||\n         currentFrame.duration <= 0)) {\n      currentFrame.duration = frames[frames.length - 1].duration;\n    }\n\n    // Push the final frame\n    frames.push(currentFrame);\n    return frames;\n  };\n\n  // Convert an array of frames into an array of Gop with each Gop being composed\n  // of the frames that make up that Gop\n  // Also keep track of cummulative data about the Gop from the frames such as the\n  // Gop duration, starting pts, etc.\n  this.groupFramesIntoGops_ = function(frames) {\n    var\n      i,\n      currentFrame,\n      currentGop = [],\n      gops = [];\n\n    // We must pre-set some of the values on the Gop since we\n    // keep running totals of these values\n    currentGop.byteLength = 0;\n    currentGop.nalCount = 0;\n    currentGop.duration = 0;\n    currentGop.pts = frames[0].pts;\n    currentGop.dts = frames[0].dts;\n\n    // store some metadata about all the Gops\n    gops.byteLength = 0;\n    gops.nalCount = 0;\n    gops.duration = 0;\n    gops.pts = frames[0].pts;\n    gops.dts = frames[0].dts;\n\n    for (i = 0; i < frames.length; i++) {\n      currentFrame = frames[i];\n\n      if (currentFrame.keyFrame) {\n        // Since the very first frame is expected to be an keyframe\n        // only push to the gops array when currentGop is not empty\n        if (currentGop.length) {\n          gops.push(currentGop);\n          gops.byteLength += currentGop.byteLength;\n          gops.nalCount += currentGop.nalCount;\n          gops.duration += currentGop.duration;\n        }\n\n        currentGop = [currentFrame];\n        currentGop.nalCount = currentFrame.length;\n        currentGop.byteLength = currentFrame.byteLength;\n        currentGop.pts = currentFrame.pts;\n        currentGop.dts = currentFrame.dts;\n        currentGop.duration = currentFrame.duration;\n      } else {\n        currentGop.duration += currentFrame.duration;\n        currentGop.nalCount += currentFrame.length;\n        currentGop.byteLength += currentFrame.byteLength;\n        currentGop.push(currentFrame);\n      }\n    }\n\n    if (gops.length && currentGop.duration <= 0) {\n      currentGop.duration = gops[gops.length - 1].duration;\n    }\n    gops.byteLength += currentGop.byteLength;\n    gops.nalCount += currentGop.nalCount;\n    gops.duration += currentGop.duration;\n\n    // push the final Gop\n    gops.push(currentGop);\n    return gops;\n  };\n\n  // generate the track's sample table from an array of gops\n  this.generateSampleTable_ = function(gops, baseDataOffset) {\n    var\n      h, i,\n      sample,\n      currentGop,\n      currentFrame,\n      dataOffset = baseDataOffset || 0,\n      samples = [];\n\n    for (h = 0; h < gops.length; h++) {\n      currentGop = gops[h];\n\n      for (i = 0; i < currentGop.length; i++) {\n        currentFrame = currentGop[i];\n\n        sample = createDefaultSample();\n\n        sample.dataOffset = dataOffset;\n        sample.compositionTimeOffset = currentFrame.pts - currentFrame.dts;\n        sample.duration = currentFrame.duration;\n        sample.size = 4 * currentFrame.length; // Space for nal unit size\n        sample.size += currentFrame.byteLength;\n\n        if (currentFrame.keyFrame) {\n          sample.flags.dependsOn = 2;\n        }\n\n        dataOffset += sample.size;\n\n        samples.push(sample);\n      }\n    }\n    return samples;\n  };\n\n  // generate the track's raw mdat data from an array of gops\n  this.concatenateNalData_ = function(gops) {\n    var\n      h, i, j,\n      currentGop,\n      currentFrame,\n      currentNal,\n      dataOffset = 0,\n      nalsByteLength = gops.byteLength,\n      numberOfNals = gops.nalCount,\n      totalByteLength = nalsByteLength + 4 * numberOfNals,\n      data = new Uint8Array(totalByteLength),\n      view = new DataView(data.buffer);\n\n    // For each Gop..\n    for (h = 0; h < gops.length; h++) {\n      currentGop = gops[h];\n\n      // For each Frame..\n      for (i = 0; i < currentGop.length; i++) {\n        currentFrame = currentGop[i];\n\n        // For each NAL..\n        for (j = 0; j < currentFrame.length; j++) {\n          currentNal = currentFrame[j];\n\n          view.setUint32(dataOffset, currentNal.data.byteLength);\n          dataOffset += 4;\n          data.set(currentNal.data, dataOffset);\n          dataOffset += currentNal.data.byteLength;\n        }\n      }\n    }\n    return data;\n  };\n\n  // trim gop list to the first gop found that has a matching pts with a gop in the list\n  // of gopsToAlignWith starting from the START of the list\n  this.alignGopsAtStart_ = function(gops) {\n    var alignIndex, gopIndex, align, gop, byteLength, nalCount, duration, alignedGops;\n\n    byteLength = gops.byteLength;\n    nalCount = gops.nalCount;\n    duration = gops.duration;\n    alignIndex = gopIndex = 0;\n\n    while (alignIndex < gopsToAlignWith.length && gopIndex < gops.length) {\n      align = gopsToAlignWith[alignIndex];\n      gop = gops[gopIndex];\n\n      if (align.pts === gop.pts) {\n        break;\n      }\n\n      if (gop.pts > align.pts) {\n        // this current gop starts after the current gop we want to align on, so increment\n        // align index\n        alignIndex++;\n        continue;\n      }\n\n      // current gop starts before the current gop we want to align on. so increment gop\n      // index\n      gopIndex++;\n      byteLength -= gop.byteLength;\n      nalCount -= gop.nalCount;\n      duration -= gop.duration;\n    }\n\n    if (gopIndex === 0) {\n      // no gops to trim\n      return gops;\n    }\n\n    if (gopIndex === gops.length) {\n      // all gops trimmed, skip appending all gops\n      return null;\n    }\n\n    alignedGops = gops.slice(gopIndex);\n    alignedGops.byteLength = byteLength;\n    alignedGops.duration = duration;\n    alignedGops.nalCount = nalCount;\n    alignedGops.pts = alignedGops[0].pts;\n    alignedGops.dts = alignedGops[0].dts;\n\n    return alignedGops;\n  };\n\n  // trim gop list to the first gop found that has a matching pts with a gop in the list\n  // of gopsToAlignWith starting from the END of the list\n  this.alignGopsAtEnd_ = function(gops) {\n    var alignIndex, gopIndex, align, gop, alignEndIndex, matchFound;\n\n    alignIndex = gopsToAlignWith.length - 1;\n    gopIndex = gops.length - 1;\n    alignEndIndex = null;\n    matchFound = false;\n\n    while (alignIndex >= 0 && gopIndex >= 0) {\n      align = gopsToAlignWith[alignIndex];\n      gop = gops[gopIndex];\n\n      if (align.pts === gop.pts) {\n        matchFound = true;\n        break;\n      }\n\n      if (align.pts > gop.pts) {\n        alignIndex--;\n        continue;\n      }\n\n      if (alignIndex === gopsToAlignWith.length - 1) {\n        // gop.pts is greater than the last alignment candidate. If no match is found\n        // by the end of this loop, we still want to append gops that come after this\n        // point\n        alignEndIndex = gopIndex;\n      }\n\n      gopIndex--;\n    }\n\n    if (!matchFound && alignEndIndex === null) {\n      return null;\n    }\n\n    var trimIndex;\n\n    if (matchFound) {\n      trimIndex = gopIndex;\n    } else {\n      trimIndex = alignEndIndex;\n    }\n\n    if (trimIndex === 0) {\n      return gops;\n    }\n\n    var alignedGops = gops.slice(trimIndex);\n    var metadata = alignedGops.reduce(function(total, gop) {\n      total.byteLength += gop.byteLength;\n      total.duration += gop.duration;\n      total.nalCount += gop.nalCount;\n      return total;\n    }, { byteLength: 0, duration: 0, nalCount: 0 });\n\n    alignedGops.byteLength = metadata.byteLength;\n    alignedGops.duration = metadata.duration;\n    alignedGops.nalCount = metadata.nalCount;\n    alignedGops.pts = alignedGops[0].pts;\n    alignedGops.dts = alignedGops[0].dts;\n\n    return alignedGops;\n  };\n\n  this.alignGopsWith = function(newGopsToAlignWith) {\n    gopsToAlignWith = newGopsToAlignWith;\n  };\n};\n\nVideoSegmentStream.prototype = new Stream();\n\n/**\n * Store information about the start and end of the track and the\n * duration for each frame/sample we process in order to calculate\n * the baseMediaDecodeTime\n */\ncollectDtsInfo = function(track, data) {\n  if (typeof data.pts === 'number') {\n    if (track.timelineStartInfo.pts === undefined) {\n      track.timelineStartInfo.pts = data.pts;\n    }\n\n    if (track.minSegmentPts === undefined) {\n      track.minSegmentPts = data.pts;\n    } else {\n      track.minSegmentPts = Math.min(track.minSegmentPts, data.pts);\n    }\n\n    if (track.maxSegmentPts === undefined) {\n      track.maxSegmentPts = data.pts;\n    } else {\n      track.maxSegmentPts = Math.max(track.maxSegmentPts, data.pts);\n    }\n  }\n\n  if (typeof data.dts === 'number') {\n    if (track.timelineStartInfo.dts === undefined) {\n      track.timelineStartInfo.dts = data.dts;\n    }\n\n    if (track.minSegmentDts === undefined) {\n      track.minSegmentDts = data.dts;\n    } else {\n      track.minSegmentDts = Math.min(track.minSegmentDts, data.dts);\n    }\n\n    if (track.maxSegmentDts === undefined) {\n      track.maxSegmentDts = data.dts;\n    } else {\n      track.maxSegmentDts = Math.max(track.maxSegmentDts, data.dts);\n    }\n  }\n};\n\n/**\n * Clear values used to calculate the baseMediaDecodeTime between\n * tracks\n */\nclearDtsInfo = function(track) {\n  delete track.minSegmentDts;\n  delete track.maxSegmentDts;\n  delete track.minSegmentPts;\n  delete track.maxSegmentPts;\n};\n\n/**\n * Calculate the track's baseMediaDecodeTime based on the earliest\n * DTS the transmuxer has ever seen and the minimum DTS for the\n * current track\n */\ncalculateTrackBaseMediaDecodeTime = function(track) {\n  var\n    baseMediaDecodeTime,\n    scale,\n    // Calculate the distance, in time, that this segment starts from the start\n    // of the timeline (earliest time seen since the transmuxer initialized)\n    timeSinceStartOfTimeline = track.minSegmentDts - track.timelineStartInfo.dts;\n\n  // track.timelineStartInfo.baseMediaDecodeTime is the location, in time, where\n  // we want the start of the first segment to be placed\n  baseMediaDecodeTime = track.timelineStartInfo.baseMediaDecodeTime;\n\n  // Add to that the distance this segment is from the very first\n  baseMediaDecodeTime += timeSinceStartOfTimeline;\n\n  // baseMediaDecodeTime must not become negative\n  baseMediaDecodeTime = Math.max(0, baseMediaDecodeTime);\n\n  if (track.type === 'audio') {\n    // Audio has a different clock equal to the sampling_rate so we need to\n    // scale the PTS values into the clock rate of the track\n    scale = track.samplerate / ONE_SECOND_IN_TS;\n    baseMediaDecodeTime *= scale;\n    baseMediaDecodeTime = Math.floor(baseMediaDecodeTime);\n  }\n\n  return baseMediaDecodeTime;\n};\n\n/**\n * A Stream that can combine multiple streams (ie. audio & video)\n * into a single output segment for MSE. Also supports audio-only\n * and video-only streams.\n */\nCoalesceStream = function(options, metadataStream) {\n  // Number of Tracks per output segment\n  // If greater than 1, we combine multiple\n  // tracks into a single segment\n  this.numberOfTracks = 0;\n  this.metadataStream = metadataStream;\n\n  if (typeof options.remux !== 'undefined') {\n    this.remuxTracks = !!options.remux;\n  } else {\n    this.remuxTracks = true;\n  }\n\n  this.pendingTracks = [];\n  this.videoTrack = null;\n  this.pendingBoxes = [];\n  this.pendingCaptions = [];\n  this.pendingMetadata = [];\n  this.pendingBytes = 0;\n  this.emittedTracks = 0;\n\n  CoalesceStream.prototype.init.call(this);\n\n  // Take output from multiple\n  this.push = function(output) {\n    // buffer incoming captions until the associated video segment\n    // finishes\n    if (output.text) {\n      return this.pendingCaptions.push(output);\n    }\n    // buffer incoming id3 tags until the final flush\n    if (output.frames) {\n      return this.pendingMetadata.push(output);\n    }\n\n    // Add this track to the list of pending tracks and store\n    // important information required for the construction of\n    // the final segment\n    this.pendingTracks.push(output.track);\n    this.pendingBoxes.push(output.boxes);\n    this.pendingBytes += output.boxes.byteLength;\n\n    if (output.track.type === 'video') {\n      this.videoTrack = output.track;\n    }\n    if (output.track.type === 'audio') {\n      this.audioTrack = output.track;\n    }\n  };\n};\n\nCoalesceStream.prototype = new Stream();\nCoalesceStream.prototype.flush = function(flushSource) {\n  var\n    offset = 0,\n    event = {\n      captions: [],\n      captionStreams: {},\n      metadata: [],\n      info: {}\n    },\n    caption,\n    id3,\n    initSegment,\n    timelineStartPts = 0,\n    i;\n\n  if (this.pendingTracks.length < this.numberOfTracks) {\n    if (flushSource !== 'VideoSegmentStream' &&\n        flushSource !== 'AudioSegmentStream') {\n      // Return because we haven't received a flush from a data-generating\n      // portion of the segment (meaning that we have only recieved meta-data\n      // or captions.)\n      return;\n    } else if (this.remuxTracks) {\n      // Return until we have enough tracks from the pipeline to remux (if we\n      // are remuxing audio and video into a single MP4)\n      return;\n    } else if (this.pendingTracks.length === 0) {\n      // In the case where we receive a flush without any data having been\n      // received we consider it an emitted track for the purposes of coalescing\n      // `done` events.\n      // We do this for the case where there is an audio and video track in the\n      // segment but no audio data. (seen in several playlists with alternate\n      // audio tracks and no audio present in the main TS segments.)\n      this.emittedTracks++;\n\n      if (this.emittedTracks >= this.numberOfTracks) {\n        this.trigger('done');\n        this.emittedTracks = 0;\n      }\n      return;\n    }\n  }\n\n  if (this.videoTrack) {\n    timelineStartPts = this.videoTrack.timelineStartInfo.pts;\n    VIDEO_PROPERTIES.forEach(function(prop) {\n      event.info[prop] = this.videoTrack[prop];\n    }, this);\n  } else if (this.audioTrack) {\n    timelineStartPts = this.audioTrack.timelineStartInfo.pts;\n    AUDIO_PROPERTIES.forEach(function(prop) {\n      event.info[prop] = this.audioTrack[prop];\n    }, this);\n  }\n\n  if (this.pendingTracks.length === 1) {\n    event.type = this.pendingTracks[0].type;\n  } else {\n    event.type = 'combined';\n  }\n\n  this.emittedTracks += this.pendingTracks.length;\n\n  initSegment = mp4.initSegment(this.pendingTracks);\n\n  // Create a new typed array to hold the init segment\n  event.initSegment = new Uint8Array(initSegment.byteLength);\n\n  // Create an init segment containing a moov\n  // and track definitions\n  event.initSegment.set(initSegment);\n\n  // Create a new typed array to hold the moof+mdats\n  event.data = new Uint8Array(this.pendingBytes);\n\n  // Append each moof+mdat (one per track) together\n  for (i = 0; i < this.pendingBoxes.length; i++) {\n    event.data.set(this.pendingBoxes[i], offset);\n    offset += this.pendingBoxes[i].byteLength;\n  }\n\n  // Translate caption PTS times into second offsets into the\n  // video timeline for the segment, and add track info\n  for (i = 0; i < this.pendingCaptions.length; i++) {\n    caption = this.pendingCaptions[i];\n    caption.startTime = (caption.startPts - timelineStartPts);\n    caption.startTime /= 90e3;\n    caption.endTime = (caption.endPts - timelineStartPts);\n    caption.endTime /= 90e3;\n    event.captionStreams[caption.stream] = true;\n    event.captions.push(caption);\n  }\n\n  // Translate ID3 frame PTS times into second offsets into the\n  // video timeline for the segment\n  for (i = 0; i < this.pendingMetadata.length; i++) {\n    id3 = this.pendingMetadata[i];\n    id3.cueTime = (id3.pts - timelineStartPts);\n    id3.cueTime /= 90e3;\n    event.metadata.push(id3);\n  }\n  // We add this to every single emitted segment even though we only need\n  // it for the first\n  event.metadata.dispatchType = this.metadataStream.dispatchType;\n\n  // Reset stream state\n  this.pendingTracks.length = 0;\n  this.videoTrack = null;\n  this.pendingBoxes.length = 0;\n  this.pendingCaptions.length = 0;\n  this.pendingBytes = 0;\n  this.pendingMetadata.length = 0;\n\n  // Emit the built segment\n  this.trigger('data', event);\n\n  // Only emit `done` if all tracks have been flushed and emitted\n  if (this.emittedTracks >= this.numberOfTracks) {\n    this.trigger('done');\n    this.emittedTracks = 0;\n  }\n};\n/**\n * A Stream that expects MP2T binary data as input and produces\n * corresponding media segments, suitable for use with Media Source\n * Extension (MSE) implementations that support the ISO BMFF byte\n * stream format, like Chrome.\n */\nTransmuxer = function(options) {\n  var\n    self = this,\n    hasFlushed = true,\n    videoTrack,\n    audioTrack;\n\n  Transmuxer.prototype.init.call(this);\n\n  options = options || {};\n  this.baseMediaDecodeTime = options.baseMediaDecodeTime || 0;\n  this.transmuxPipeline_ = {};\n\n  this.setupAacPipeline = function() {\n    var pipeline = {};\n    this.transmuxPipeline_ = pipeline;\n\n    pipeline.type = 'aac';\n    pipeline.metadataStream = new m2ts.MetadataStream();\n\n    // set up the parsing pipeline\n    pipeline.aacStream = new AacStream();\n    pipeline.audioTimestampRolloverStream = new m2ts.TimestampRolloverStream('audio');\n    pipeline.timedMetadataTimestampRolloverStream = new m2ts.TimestampRolloverStream('timed-metadata');\n    pipeline.adtsStream = new AdtsStream();\n    pipeline.coalesceStream = new CoalesceStream(options, pipeline.metadataStream);\n    pipeline.headOfPipeline = pipeline.aacStream;\n\n    pipeline.aacStream\n      .pipe(pipeline.audioTimestampRolloverStream)\n      .pipe(pipeline.adtsStream);\n    pipeline.aacStream\n      .pipe(pipeline.timedMetadataTimestampRolloverStream)\n      .pipe(pipeline.metadataStream)\n      .pipe(pipeline.coalesceStream);\n\n    pipeline.metadataStream.on('timestamp', function(frame) {\n      pipeline.aacStream.setTimestamp(frame.timeStamp);\n    });\n\n    pipeline.aacStream.on('data', function(data) {\n      if (data.type === 'timed-metadata' && !pipeline.audioSegmentStream) {\n        audioTrack = audioTrack || {\n          timelineStartInfo: {\n            baseMediaDecodeTime: self.baseMediaDecodeTime\n          },\n          codec: 'adts',\n          type: 'audio'\n        };\n        // hook up the audio segment stream to the first track with aac data\n        pipeline.coalesceStream.numberOfTracks++;\n        pipeline.audioSegmentStream = new AudioSegmentStream(audioTrack);\n        // Set up the final part of the audio pipeline\n        pipeline.adtsStream\n          .pipe(pipeline.audioSegmentStream)\n          .pipe(pipeline.coalesceStream);\n      }\n    });\n\n    // Re-emit any data coming from the coalesce stream to the outside world\n    pipeline.coalesceStream.on('data', this.trigger.bind(this, 'data'));\n    // Let the consumer know we have finished flushing the entire pipeline\n    pipeline.coalesceStream.on('done', this.trigger.bind(this, 'done'));\n  };\n\n  this.setupTsPipeline = function() {\n    var pipeline = {};\n    this.transmuxPipeline_ = pipeline;\n\n    pipeline.type = 'ts';\n    pipeline.metadataStream = new m2ts.MetadataStream();\n\n    // set up the parsing pipeline\n    pipeline.packetStream = new m2ts.TransportPacketStream();\n    pipeline.parseStream = new m2ts.TransportParseStream();\n    pipeline.elementaryStream = new m2ts.ElementaryStream();\n    pipeline.videoTimestampRolloverStream = new m2ts.TimestampRolloverStream('video');\n    pipeline.audioTimestampRolloverStream = new m2ts.TimestampRolloverStream('audio');\n    pipeline.timedMetadataTimestampRolloverStream = new m2ts.TimestampRolloverStream('timed-metadata');\n    pipeline.adtsStream = new AdtsStream();\n    pipeline.h264Stream = new H264Stream();\n    pipeline.captionStream = new m2ts.CaptionStream();\n    pipeline.coalesceStream = new CoalesceStream(options, pipeline.metadataStream);\n    pipeline.headOfPipeline = pipeline.packetStream;\n\n    // disassemble MPEG2-TS packets into elementary streams\n    pipeline.packetStream\n      .pipe(pipeline.parseStream)\n      .pipe(pipeline.elementaryStream);\n\n    // !!THIS ORDER IS IMPORTANT!!\n    // demux the streams\n    pipeline.elementaryStream\n      .pipe(pipeline.videoTimestampRolloverStream)\n      .pipe(pipeline.h264Stream);\n    pipeline.elementaryStream\n      .pipe(pipeline.audioTimestampRolloverStream)\n      .pipe(pipeline.adtsStream);\n\n    pipeline.elementaryStream\n      .pipe(pipeline.timedMetadataTimestampRolloverStream)\n      .pipe(pipeline.metadataStream)\n      .pipe(pipeline.coalesceStream);\n\n    // Hook up CEA-608/708 caption stream\n    pipeline.h264Stream.pipe(pipeline.captionStream)\n      .pipe(pipeline.coalesceStream);\n\n    pipeline.elementaryStream.on('data', function(data) {\n      var i;\n\n      if (data.type === 'metadata') {\n        i = data.tracks.length;\n\n        // scan the tracks listed in the metadata\n        while (i--) {\n          if (!videoTrack && data.tracks[i].type === 'video') {\n            videoTrack = data.tracks[i];\n            videoTrack.timelineStartInfo.baseMediaDecodeTime = self.baseMediaDecodeTime;\n          } else if (!audioTrack && data.tracks[i].type === 'audio') {\n            audioTrack = data.tracks[i];\n            audioTrack.timelineStartInfo.baseMediaDecodeTime = self.baseMediaDecodeTime;\n          }\n        }\n\n        // hook up the video segment stream to the first track with h264 data\n        if (videoTrack && !pipeline.videoSegmentStream) {\n          pipeline.coalesceStream.numberOfTracks++;\n          pipeline.videoSegmentStream = new VideoSegmentStream(videoTrack, options);\n\n          pipeline.videoSegmentStream.on('timelineStartInfo', function(timelineStartInfo) {\n          // When video emits timelineStartInfo data after a flush, we forward that\n          // info to the AudioSegmentStream, if it exists, because video timeline\n          // data takes precedence.\n            if (audioTrack) {\n              audioTrack.timelineStartInfo = timelineStartInfo;\n              // On the first segment we trim AAC frames that exist before the\n              // very earliest DTS we have seen in video because Chrome will\n              // interpret any video track with a baseMediaDecodeTime that is\n              // non-zero as a gap.\n              pipeline.audioSegmentStream.setEarliestDts(timelineStartInfo.dts);\n            }\n          });\n\n          pipeline.videoSegmentStream.on('processedGopsInfo',\n            self.trigger.bind(self, 'gopInfo'));\n\n          pipeline.videoSegmentStream.on('baseMediaDecodeTime', function(baseMediaDecodeTime) {\n            if (audioTrack) {\n              pipeline.audioSegmentStream.setVideoBaseMediaDecodeTime(baseMediaDecodeTime);\n            }\n          });\n\n          // Set up the final part of the video pipeline\n          pipeline.h264Stream\n            .pipe(pipeline.videoSegmentStream)\n            .pipe(pipeline.coalesceStream);\n        }\n\n        if (audioTrack && !pipeline.audioSegmentStream) {\n          // hook up the audio segment stream to the first track with aac data\n          pipeline.coalesceStream.numberOfTracks++;\n          pipeline.audioSegmentStream = new AudioSegmentStream(audioTrack);\n\n          // Set up the final part of the audio pipeline\n          pipeline.adtsStream\n            .pipe(pipeline.audioSegmentStream)\n            .pipe(pipeline.coalesceStream);\n        }\n      }\n    });\n\n    // Re-emit any data coming from the coalesce stream to the outside world\n    pipeline.coalesceStream.on('data', this.trigger.bind(this, 'data'));\n    // Let the consumer know we have finished flushing the entire pipeline\n    pipeline.coalesceStream.on('done', this.trigger.bind(this, 'done'));\n  };\n\n  // hook up the segment streams once track metadata is delivered\n  this.setBaseMediaDecodeTime = function(baseMediaDecodeTime) {\n    var pipeline = this.transmuxPipeline_;\n\n    this.baseMediaDecodeTime = baseMediaDecodeTime;\n    if (audioTrack) {\n      audioTrack.timelineStartInfo.dts = undefined;\n      audioTrack.timelineStartInfo.pts = undefined;\n      clearDtsInfo(audioTrack);\n      audioTrack.timelineStartInfo.baseMediaDecodeTime = baseMediaDecodeTime;\n      if (pipeline.audioTimestampRolloverStream) {\n        pipeline.audioTimestampRolloverStream.discontinuity();\n      }\n    }\n    if (videoTrack) {\n      if (pipeline.videoSegmentStream) {\n        pipeline.videoSegmentStream.gopCache_ = [];\n        pipeline.videoTimestampRolloverStream.discontinuity();\n      }\n      videoTrack.timelineStartInfo.dts = undefined;\n      videoTrack.timelineStartInfo.pts = undefined;\n      clearDtsInfo(videoTrack);\n      pipeline.captionStream.reset();\n      videoTrack.timelineStartInfo.baseMediaDecodeTime = baseMediaDecodeTime;\n    }\n\n    if (pipeline.timedMetadataTimestampRolloverStream) {\n      pipeline.timedMetadataTimestampRolloverStream.discontinuity();\n    }\n  };\n\n  this.setAudioAppendStart = function(timestamp) {\n    if (audioTrack) {\n      this.transmuxPipeline_.audioSegmentStream.setAudioAppendStart(timestamp);\n    }\n  };\n\n  this.alignGopsWith = function(gopsToAlignWith) {\n    if (videoTrack && this.transmuxPipeline_.videoSegmentStream) {\n      this.transmuxPipeline_.videoSegmentStream.alignGopsWith(gopsToAlignWith);\n    }\n  };\n\n  // feed incoming data to the front of the parsing pipeline\n  this.push = function(data) {\n    if (hasFlushed) {\n      var isAac = isLikelyAacData(data);\n\n      if (isAac && this.transmuxPipeline_.type !== 'aac') {\n        this.setupAacPipeline();\n      } else if (!isAac && this.transmuxPipeline_.type !== 'ts') {\n        this.setupTsPipeline();\n      }\n      hasFlushed = false;\n    }\n    this.transmuxPipeline_.headOfPipeline.push(data);\n  };\n\n  // flush any buffered data\n  this.flush = function() {\n      hasFlushed = true;\n    // Start at the top of the pipeline and flush all pending work\n    this.transmuxPipeline_.headOfPipeline.flush();\n  };\n\n  // Caption data has to be reset when seeking outside buffered range\n  this.resetCaptions = function() {\n    if (this.transmuxPipeline_.captionStream) {\n      this.transmuxPipeline_.captionStream.reset();\n    }\n  };\n\n};\nTransmuxer.prototype = new Stream();\n\nmodule.exports = {\n  Transmuxer: Transmuxer,\n  VideoSegmentStream: VideoSegmentStream,\n  AudioSegmentStream: AudioSegmentStream,\n  AUDIO_PROPERTIES: AUDIO_PROPERTIES,\n  VIDEO_PROPERTIES: VIDEO_PROPERTIES\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdmlkZW9qcy1jb250cmliLW1lZGlhLXNvdXJjZXMvbm9kZV9tb2R1bGVzL211eC5qcy9saWIvbXA0L3RyYW5zbXV4ZXIuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDYTs7QUFFYixhQUFhLG1CQUFPLENBQUMsc0hBQW9CO0FBQ3pDLFVBQVUsbUJBQU8sQ0FBQywySEFBb0I7QUFDdEMsV0FBVyxtQkFBTyxDQUFDLGdIQUFpQjtBQUNwQyxpQkFBaUIsbUJBQU8sQ0FBQyxvSEFBbUI7QUFDNUMsaUJBQWlCLG1KQUFvQztBQUNyRCxnQkFBZ0IsbUJBQU8sQ0FBQyx1R0FBUTtBQUNoQyxvQkFBb0IsbUJBQU8sQ0FBQyxtSEFBaUI7QUFDN0MsWUFBWSxtQkFBTyxDQUFDLGlIQUFnQjs7QUFFcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4QkFBOEI7O0FBRTlCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWMsY0FBYztBQUM1QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLGtCQUFrQjtBQUNoQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsMEJBQTBCLDJCQUEyQjtBQUNyRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0IseUJBQXlCO0FBQ3pDO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdCQUFnQixtQkFBbUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdCQUFnQixtQkFBbUI7QUFDbkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekIsbUJBQW1CLFFBQVE7QUFDM0Isa0NBQWtDLFNBQVM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDBCQUEwQiwyQkFBMkI7O0FBRXJEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLDJCQUEyQjtBQUMzQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsZ0JBQWdCLHFCQUFxQjtBQUNyQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0IsbUJBQW1CO0FBQ25DOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCLGlCQUFpQjtBQUNqQzs7QUFFQSxrQkFBa0IsdUJBQXVCO0FBQ3pDOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixpQkFBaUI7QUFDakM7O0FBRUE7QUFDQSxrQkFBa0IsdUJBQXVCO0FBQ3pDOztBQUVBO0FBQ0Esb0JBQW9CLHlCQUF5QjtBQUM3Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssSUFBSSx5Q0FBeUM7O0FBRWxEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLDhCQUE4QjtBQUM1QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsaUNBQWlDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsaUNBQWlDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS12MC1wcm9qZWN0Ly4vbm9kZV9tb2R1bGVzL3ZpZGVvanMtY29udHJpYi1tZWRpYS1zb3VyY2VzL25vZGVfbW9kdWxlcy9tdXguanMvbGliL21wNC90cmFuc211eGVyLmpzP2RkNDIiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBtdXguanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgQnJpZ2h0Y292ZVxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBBIHN0cmVhbS1iYXNlZCBtcDJ0IHRvIG1wNCBjb252ZXJ0ZXIuIFRoaXMgdXRpbGl0eSBjYW4gYmUgdXNlZCB0b1xuICogZGVsaXZlciBtcDRzIHRvIGEgU291cmNlQnVmZmVyIG9uIHBsYXRmb3JtcyB0aGF0IHN1cHBvcnQgbmF0aXZlXG4gKiBNZWRpYSBTb3VyY2UgRXh0ZW5zaW9ucy5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgU3RyZWFtID0gcmVxdWlyZSgnLi4vdXRpbHMvc3RyZWFtLmpzJyk7XG52YXIgbXA0ID0gcmVxdWlyZSgnLi9tcDQtZ2VuZXJhdG9yLmpzJyk7XG52YXIgbTJ0cyA9IHJlcXVpcmUoJy4uL20ydHMvbTJ0cy5qcycpO1xudmFyIEFkdHNTdHJlYW0gPSByZXF1aXJlKCcuLi9jb2RlY3MvYWR0cy5qcycpO1xudmFyIEgyNjRTdHJlYW0gPSByZXF1aXJlKCcuLi9jb2RlY3MvaDI2NCcpLkgyNjRTdHJlYW07XG52YXIgQWFjU3RyZWFtID0gcmVxdWlyZSgnLi4vYWFjJyk7XG52YXIgY29uZU9mU2lsZW5jZSA9IHJlcXVpcmUoJy4uL2RhdGEvc2lsZW5jZScpO1xudmFyIGNsb2NrID0gcmVxdWlyZSgnLi4vdXRpbHMvY2xvY2snKTtcblxuLy8gY29uc3RhbnRzXG52YXIgQVVESU9fUFJPUEVSVElFUyA9IFtcbiAgJ2F1ZGlvb2JqZWN0dHlwZScsXG4gICdjaGFubmVsY291bnQnLFxuICAnc2FtcGxlcmF0ZScsXG4gICdzYW1wbGluZ2ZyZXF1ZW5jeWluZGV4JyxcbiAgJ3NhbXBsZXNpemUnXG5dO1xuXG52YXIgVklERU9fUFJPUEVSVElFUyA9IFtcbiAgJ3dpZHRoJyxcbiAgJ2hlaWdodCcsXG4gICdwcm9maWxlSWRjJyxcbiAgJ2xldmVsSWRjJyxcbiAgJ3Byb2ZpbGVDb21wYXRpYmlsaXR5J1xuXTtcblxudmFyIE9ORV9TRUNPTkRfSU5fVFMgPSA5MDAwMDsgLy8gOTBrSHogY2xvY2tcblxuLy8gb2JqZWN0IHR5cGVzXG52YXIgVmlkZW9TZWdtZW50U3RyZWFtLCBBdWRpb1NlZ21lbnRTdHJlYW0sIFRyYW5zbXV4ZXIsIENvYWxlc2NlU3RyZWFtO1xuXG4vLyBIZWxwZXIgZnVuY3Rpb25zXG52YXJcbiAgY3JlYXRlRGVmYXVsdFNhbXBsZSxcbiAgaXNMaWtlbHlBYWNEYXRhLFxuICBjb2xsZWN0RHRzSW5mbyxcbiAgY2xlYXJEdHNJbmZvLFxuICBjYWxjdWxhdGVUcmFja0Jhc2VNZWRpYURlY29kZVRpbWUsXG4gIGFycmF5RXF1YWxzLFxuICBzdW1GcmFtZUJ5dGVMZW5ndGhzO1xuXG4vKipcbiAqIERlZmF1bHQgc2FtcGxlIG9iamVjdFxuICogc2VlIElTTy9JRUMgMTQ0OTYtMTI6MjAxMiwgc2VjdGlvbiA4LjYuNC4zXG4gKi9cbmNyZWF0ZURlZmF1bHRTYW1wbGUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHtcbiAgICBzaXplOiAwLFxuICAgIGZsYWdzOiB7XG4gICAgICBpc0xlYWRpbmc6IDAsXG4gICAgICBkZXBlbmRzT246IDEsXG4gICAgICBpc0RlcGVuZGVkT246IDAsXG4gICAgICBoYXNSZWR1bmRhbmN5OiAwLFxuICAgICAgZGVncmFkYXRpb25Qcmlvcml0eTogMFxuICAgIH1cbiAgfTtcbn07XG5cbmlzTGlrZWx5QWFjRGF0YSA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgaWYgKChkYXRhWzBdID09PSAnSScuY2hhckNvZGVBdCgwKSkgJiZcbiAgICAgIChkYXRhWzFdID09PSAnRCcuY2hhckNvZGVBdCgwKSkgJiZcbiAgICAgIChkYXRhWzJdID09PSAnMycuY2hhckNvZGVBdCgwKSkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqIENvbXBhcmUgdHdvIGFycmF5cyAoZXZlbiB0eXBlZCkgZm9yIHNhbWUtbmVzc1xuICovXG5hcnJheUVxdWFscyA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgdmFyXG4gICAgaTtcblxuICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gY29tcGFyZSB0aGUgdmFsdWUgb2YgZWFjaCBlbGVtZW50IGluIHRoZSBhcnJheVxuICBmb3IgKGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgIGlmIChhW2ldICE9PSBiW2ldKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vKipcbiAqIFN1bSB0aGUgYGJ5dGVMZW5ndGhgIHByb3BlcnRpZXMgb2YgdGhlIGRhdGEgaW4gZWFjaCBBQUMgZnJhbWVcbiAqL1xuc3VtRnJhbWVCeXRlTGVuZ3RocyA9IGZ1bmN0aW9uKGFycmF5KSB7XG4gIHZhclxuICAgIGksXG4gICAgY3VycmVudE9iaixcbiAgICBzdW0gPSAwO1xuXG4gIC8vIHN1bSB0aGUgYnl0ZUxlbmd0aCdzIGFsbCBlYWNoIG5hbCB1bml0IGluIHRoZSBmcmFtZVxuICBmb3IgKGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICBjdXJyZW50T2JqID0gYXJyYXlbaV07XG4gICAgc3VtICs9IGN1cnJlbnRPYmouZGF0YS5ieXRlTGVuZ3RoO1xuICB9XG5cbiAgcmV0dXJuIHN1bTtcbn07XG5cbi8qKlxuICogQ29uc3RydWN0cyBhIHNpbmdsZS10cmFjaywgSVNPIEJNRkYgbWVkaWEgc2VnbWVudCBmcm9tIEFBQyBkYXRhXG4gKiBldmVudHMuIFRoZSBvdXRwdXQgb2YgdGhpcyBzdHJlYW0gY2FuIGJlIGZlZCB0byBhIFNvdXJjZUJ1ZmZlclxuICogY29uZmlndXJlZCB3aXRoIGEgc3VpdGFibGUgaW5pdGlhbGl6YXRpb24gc2VnbWVudC5cbiAqL1xuQXVkaW9TZWdtZW50U3RyZWFtID0gZnVuY3Rpb24odHJhY2spIHtcbiAgdmFyXG4gICAgYWR0c0ZyYW1lcyA9IFtdLFxuICAgIHNlcXVlbmNlTnVtYmVyID0gMCxcbiAgICBlYXJsaWVzdEFsbG93ZWREdHMgPSAwLFxuICAgIGF1ZGlvQXBwZW5kU3RhcnRUcyA9IDAsXG4gICAgdmlkZW9CYXNlTWVkaWFEZWNvZGVUaW1lID0gSW5maW5pdHk7XG5cbiAgQXVkaW9TZWdtZW50U3RyZWFtLnByb3RvdHlwZS5pbml0LmNhbGwodGhpcyk7XG5cbiAgdGhpcy5wdXNoID0gZnVuY3Rpb24oZGF0YSkge1xuICAgIGNvbGxlY3REdHNJbmZvKHRyYWNrLCBkYXRhKTtcblxuICAgIGlmICh0cmFjaykge1xuICAgICAgQVVESU9fUFJPUEVSVElFUy5mb3JFYWNoKGZ1bmN0aW9uKHByb3ApIHtcbiAgICAgICAgdHJhY2tbcHJvcF0gPSBkYXRhW3Byb3BdO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gYnVmZmVyIGF1ZGlvIGRhdGEgdW50aWwgZW5kKCkgaXMgY2FsbGVkXG4gICAgYWR0c0ZyYW1lcy5wdXNoKGRhdGEpO1xuICB9O1xuXG4gIHRoaXMuc2V0RWFybGllc3REdHMgPSBmdW5jdGlvbihlYXJsaWVzdER0cykge1xuICAgIGVhcmxpZXN0QWxsb3dlZER0cyA9IGVhcmxpZXN0RHRzIC0gdHJhY2sudGltZWxpbmVTdGFydEluZm8uYmFzZU1lZGlhRGVjb2RlVGltZTtcbiAgfTtcblxuICB0aGlzLnNldFZpZGVvQmFzZU1lZGlhRGVjb2RlVGltZSA9IGZ1bmN0aW9uKGJhc2VNZWRpYURlY29kZVRpbWUpIHtcbiAgICB2aWRlb0Jhc2VNZWRpYURlY29kZVRpbWUgPSBiYXNlTWVkaWFEZWNvZGVUaW1lO1xuICB9O1xuXG4gIHRoaXMuc2V0QXVkaW9BcHBlbmRTdGFydCA9IGZ1bmN0aW9uKHRpbWVzdGFtcCkge1xuICAgIGF1ZGlvQXBwZW5kU3RhcnRUcyA9IHRpbWVzdGFtcDtcbiAgfTtcblxuICB0aGlzLmZsdXNoID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyXG4gICAgICBmcmFtZXMsXG4gICAgICBtb29mLFxuICAgICAgbWRhdCxcbiAgICAgIGJveGVzO1xuXG4gICAgLy8gcmV0dXJuIGVhcmx5IGlmIG5vIGF1ZGlvIGRhdGEgaGFzIGJlZW4gb2JzZXJ2ZWRcbiAgICBpZiAoYWR0c0ZyYW1lcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRoaXMudHJpZ2dlcignZG9uZScsICdBdWRpb1NlZ21lbnRTdHJlYW0nKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBmcmFtZXMgPSB0aGlzLnRyaW1BZHRzRnJhbWVzQnlFYXJsaWVzdER0c18oYWR0c0ZyYW1lcyk7XG4gICAgdHJhY2suYmFzZU1lZGlhRGVjb2RlVGltZSA9IGNhbGN1bGF0ZVRyYWNrQmFzZU1lZGlhRGVjb2RlVGltZSh0cmFjayk7XG5cbiAgICB0aGlzLnByZWZpeFdpdGhTaWxlbmNlXyh0cmFjaywgZnJhbWVzKTtcblxuICAgIC8vIHdlIGhhdmUgdG8gYnVpbGQgdGhlIGluZGV4IGZyb20gYnl0ZSBsb2NhdGlvbnMgdG9cbiAgICAvLyBzYW1wbGVzICh0aGF0IGlzLCBhZHRzIGZyYW1lcykgaW4gdGhlIGF1ZGlvIGRhdGFcbiAgICB0cmFjay5zYW1wbGVzID0gdGhpcy5nZW5lcmF0ZVNhbXBsZVRhYmxlXyhmcmFtZXMpO1xuXG4gICAgLy8gY29uY2F0ZW5hdGUgdGhlIGF1ZGlvIGRhdGEgdG8gY29uc3R1Y3QgdGhlIG1kYXRcbiAgICBtZGF0ID0gbXA0Lm1kYXQodGhpcy5jb25jYXRlbmF0ZUZyYW1lRGF0YV8oZnJhbWVzKSk7XG5cbiAgICBhZHRzRnJhbWVzID0gW107XG5cbiAgICBtb29mID0gbXA0Lm1vb2Yoc2VxdWVuY2VOdW1iZXIsIFt0cmFja10pO1xuICAgIGJveGVzID0gbmV3IFVpbnQ4QXJyYXkobW9vZi5ieXRlTGVuZ3RoICsgbWRhdC5ieXRlTGVuZ3RoKTtcblxuICAgIC8vIGJ1bXAgdGhlIHNlcXVlbmNlIG51bWJlciBmb3IgbmV4dCB0aW1lXG4gICAgc2VxdWVuY2VOdW1iZXIrKztcblxuICAgIGJveGVzLnNldChtb29mKTtcbiAgICBib3hlcy5zZXQobWRhdCwgbW9vZi5ieXRlTGVuZ3RoKTtcblxuICAgIGNsZWFyRHRzSW5mbyh0cmFjayk7XG5cbiAgICB0aGlzLnRyaWdnZXIoJ2RhdGEnLCB7dHJhY2s6IHRyYWNrLCBib3hlczogYm94ZXN9KTtcbiAgICB0aGlzLnRyaWdnZXIoJ2RvbmUnLCAnQXVkaW9TZWdtZW50U3RyZWFtJyk7XG4gIH07XG5cbiAgLy8gUG9zc2libHkgcGFkIChwcmVmaXgpIHRoZSBhdWRpbyB0cmFjayB3aXRoIHNpbGVuY2UgaWYgYXBwZW5kaW5nIHRoaXMgdHJhY2tcbiAgLy8gd291bGQgbGVhZCB0byB0aGUgaW50cm9kdWN0aW9uIG9mIGEgZ2FwIGluIHRoZSBhdWRpbyBidWZmZXJcbiAgdGhpcy5wcmVmaXhXaXRoU2lsZW5jZV8gPSBmdW5jdGlvbih0cmFjaywgZnJhbWVzKSB7XG4gICAgdmFyXG4gICAgICBiYXNlTWVkaWFEZWNvZGVUaW1lVHMsXG4gICAgICBmcmFtZUR1cmF0aW9uID0gMCxcbiAgICAgIGF1ZGlvR2FwRHVyYXRpb24gPSAwLFxuICAgICAgYXVkaW9GaWxsRnJhbWVDb3VudCA9IDAsXG4gICAgICBhdWRpb0ZpbGxEdXJhdGlvbiA9IDAsXG4gICAgICBzaWxlbnRGcmFtZSxcbiAgICAgIGk7XG5cbiAgICBpZiAoIWZyYW1lcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBiYXNlTWVkaWFEZWNvZGVUaW1lVHMgPSBjbG9jay5hdWRpb1RzVG9WaWRlb1RzKHRyYWNrLmJhc2VNZWRpYURlY29kZVRpbWUsIHRyYWNrLnNhbXBsZXJhdGUpO1xuICAgIC8vIGRldGVybWluZSBmcmFtZSBjbG9jayBkdXJhdGlvbiBiYXNlZCBvbiBzYW1wbGUgcmF0ZSwgcm91bmQgdXAgdG8gYXZvaWQgb3ZlcmZpbGxzXG4gICAgZnJhbWVEdXJhdGlvbiA9IE1hdGguY2VpbChPTkVfU0VDT05EX0lOX1RTIC8gKHRyYWNrLnNhbXBsZXJhdGUgLyAxMDI0KSk7XG5cbiAgICBpZiAoYXVkaW9BcHBlbmRTdGFydFRzICYmIHZpZGVvQmFzZU1lZGlhRGVjb2RlVGltZSkge1xuICAgICAgLy8gaW5zZXJ0IHRoZSBzaG9ydGVzdCBwb3NzaWJsZSBhbW91bnQgKGF1ZGlvIGdhcCBvciBhdWRpbyB0byB2aWRlbyBnYXApXG4gICAgICBhdWRpb0dhcER1cmF0aW9uID1cbiAgICAgICAgYmFzZU1lZGlhRGVjb2RlVGltZVRzIC0gTWF0aC5tYXgoYXVkaW9BcHBlbmRTdGFydFRzLCB2aWRlb0Jhc2VNZWRpYURlY29kZVRpbWUpO1xuICAgICAgLy8gbnVtYmVyIG9mIGZ1bGwgZnJhbWVzIGluIHRoZSBhdWRpbyBnYXBcbiAgICAgIGF1ZGlvRmlsbEZyYW1lQ291bnQgPSBNYXRoLmZsb29yKGF1ZGlvR2FwRHVyYXRpb24gLyBmcmFtZUR1cmF0aW9uKTtcbiAgICAgIGF1ZGlvRmlsbER1cmF0aW9uID0gYXVkaW9GaWxsRnJhbWVDb3VudCAqIGZyYW1lRHVyYXRpb247XG4gICAgfVxuXG4gICAgLy8gZG9uJ3QgYXR0ZW1wdCB0byBmaWxsIGdhcHMgc21hbGxlciB0aGFuIGEgc2luZ2xlIGZyYW1lIG9yIGxhcmdlclxuICAgIC8vIHRoYW4gYSBoYWxmIHNlY29uZFxuICAgIGlmIChhdWRpb0ZpbGxGcmFtZUNvdW50IDwgMSB8fCBhdWRpb0ZpbGxEdXJhdGlvbiA+IE9ORV9TRUNPTkRfSU5fVFMgLyAyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgc2lsZW50RnJhbWUgPSBjb25lT2ZTaWxlbmNlW3RyYWNrLnNhbXBsZXJhdGVdO1xuXG4gICAgaWYgKCFzaWxlbnRGcmFtZSkge1xuICAgICAgLy8gd2UgZG9uJ3QgaGF2ZSBhIHNpbGVudCBmcmFtZSBwcmVnZW5lcmF0ZWQgZm9yIHRoZSBzYW1wbGUgcmF0ZSwgc28gdXNlIGEgZnJhbWVcbiAgICAgIC8vIGZyb20gdGhlIGNvbnRlbnQgaW5zdGVhZFxuICAgICAgc2lsZW50RnJhbWUgPSBmcmFtZXNbMF0uZGF0YTtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgYXVkaW9GaWxsRnJhbWVDb3VudDsgaSsrKSB7XG4gICAgICBmcmFtZXMuc3BsaWNlKGksIDAsIHtcbiAgICAgICAgZGF0YTogc2lsZW50RnJhbWVcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHRyYWNrLmJhc2VNZWRpYURlY29kZVRpbWUgLT1cbiAgICAgIE1hdGguZmxvb3IoY2xvY2sudmlkZW9Uc1RvQXVkaW9UcyhhdWRpb0ZpbGxEdXJhdGlvbiwgdHJhY2suc2FtcGxlcmF0ZSkpO1xuICB9O1xuXG4gIC8vIElmIHRoZSBhdWRpbyBzZWdtZW50IGV4dGVuZHMgYmVmb3JlIHRoZSBlYXJsaWVzdCBhbGxvd2VkIGR0c1xuICAvLyB2YWx1ZSwgcmVtb3ZlIEFBQyBmcmFtZXMgdW50aWwgc3RhcnRzIGF0IG9yIGFmdGVyIHRoZSBlYXJsaWVzdFxuICAvLyBhbGxvd2VkIERUUyBzbyB0aGF0IHdlIGRvbid0IGVuZCB1cCB3aXRoIGEgbmVnYXRpdmUgYmFzZU1lZGlhLVxuICAvLyBEZWNvZGVUaW1lIGZvciB0aGUgYXVkaW8gdHJhY2tcbiAgdGhpcy50cmltQWR0c0ZyYW1lc0J5RWFybGllc3REdHNfID0gZnVuY3Rpb24oYWR0c0ZyYW1lcykge1xuICAgIGlmICh0cmFjay5taW5TZWdtZW50RHRzID49IGVhcmxpZXN0QWxsb3dlZER0cykge1xuICAgICAgcmV0dXJuIGFkdHNGcmFtZXM7XG4gICAgfVxuXG4gICAgLy8gV2Ugd2lsbCBuZWVkIHRvIHJlY2FsY3VsYXRlIHRoZSBlYXJsaWVzdCBzZWdtZW50IER0c1xuICAgIHRyYWNrLm1pblNlZ21lbnREdHMgPSBJbmZpbml0eTtcblxuICAgIHJldHVybiBhZHRzRnJhbWVzLmZpbHRlcihmdW5jdGlvbihjdXJyZW50RnJhbWUpIHtcbiAgICAgIC8vIElmIHRoaXMgaXMgYW4gYWxsb3dlZCBmcmFtZSwga2VlcCBpdCBhbmQgcmVjb3JkIGl0J3MgRHRzXG4gICAgICBpZiAoY3VycmVudEZyYW1lLmR0cyA+PSBlYXJsaWVzdEFsbG93ZWREdHMpIHtcbiAgICAgICAgdHJhY2subWluU2VnbWVudER0cyA9IE1hdGgubWluKHRyYWNrLm1pblNlZ21lbnREdHMsIGN1cnJlbnRGcmFtZS5kdHMpO1xuICAgICAgICB0cmFjay5taW5TZWdtZW50UHRzID0gdHJhY2subWluU2VnbWVudER0cztcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICAvLyBPdGhlcndpc2UsIGRpc2NhcmQgaXRcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9KTtcbiAgfTtcblxuICAvLyBnZW5lcmF0ZSB0aGUgdHJhY2sncyByYXcgbWRhdCBkYXRhIGZyb20gYW4gYXJyYXkgb2YgZnJhbWVzXG4gIHRoaXMuZ2VuZXJhdGVTYW1wbGVUYWJsZV8gPSBmdW5jdGlvbihmcmFtZXMpIHtcbiAgICB2YXJcbiAgICAgIGksXG4gICAgICBjdXJyZW50RnJhbWUsXG4gICAgICBzYW1wbGVzID0gW107XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgZnJhbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjdXJyZW50RnJhbWUgPSBmcmFtZXNbaV07XG4gICAgICBzYW1wbGVzLnB1c2goe1xuICAgICAgICBzaXplOiBjdXJyZW50RnJhbWUuZGF0YS5ieXRlTGVuZ3RoLFxuICAgICAgICBkdXJhdGlvbjogMTAyNCAvLyBGb3IgQUFDIGF1ZGlvLCBhbGwgc2FtcGxlcyBjb250YWluIDEwMjQgc2FtcGxlc1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBzYW1wbGVzO1xuICB9O1xuXG4gIC8vIGdlbmVyYXRlIHRoZSB0cmFjaydzIHNhbXBsZSB0YWJsZSBmcm9tIGFuIGFycmF5IG9mIGZyYW1lc1xuICB0aGlzLmNvbmNhdGVuYXRlRnJhbWVEYXRhXyA9IGZ1bmN0aW9uKGZyYW1lcykge1xuICAgIHZhclxuICAgICAgaSxcbiAgICAgIGN1cnJlbnRGcmFtZSxcbiAgICAgIGRhdGFPZmZzZXQgPSAwLFxuICAgICAgZGF0YSA9IG5ldyBVaW50OEFycmF5KHN1bUZyYW1lQnl0ZUxlbmd0aHMoZnJhbWVzKSk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgZnJhbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjdXJyZW50RnJhbWUgPSBmcmFtZXNbaV07XG5cbiAgICAgIGRhdGEuc2V0KGN1cnJlbnRGcmFtZS5kYXRhLCBkYXRhT2Zmc2V0KTtcbiAgICAgIGRhdGFPZmZzZXQgKz0gY3VycmVudEZyYW1lLmRhdGEuYnl0ZUxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGE7XG4gIH07XG59O1xuXG5BdWRpb1NlZ21lbnRTdHJlYW0ucHJvdG90eXBlID0gbmV3IFN0cmVhbSgpO1xuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBzaW5nbGUtdHJhY2ssIElTTyBCTUZGIG1lZGlhIHNlZ21lbnQgZnJvbSBIMjY0IGRhdGFcbiAqIGV2ZW50cy4gVGhlIG91dHB1dCBvZiB0aGlzIHN0cmVhbSBjYW4gYmUgZmVkIHRvIGEgU291cmNlQnVmZmVyXG4gKiBjb25maWd1cmVkIHdpdGggYSBzdWl0YWJsZSBpbml0aWFsaXphdGlvbiBzZWdtZW50LlxuICogQHBhcmFtIHRyYWNrIHtvYmplY3R9IHRyYWNrIG1ldGFkYXRhIGNvbmZpZ3VyYXRpb25cbiAqIEBwYXJhbSBvcHRpb25zIHtvYmplY3R9IHRyYW5zbXV4ZXIgb3B0aW9ucyBvYmplY3RcbiAqIEBwYXJhbSBvcHRpb25zLmFsaWduR29wc0F0RW5kIHtib29sZWFufSBJZiB0cnVlLCBzdGFydCBmcm9tIHRoZSBlbmQgb2YgdGhlXG4gKiAgICAgICAgZ29wc1RvQWxpZ25XaXRoIGxpc3Qgd2hlbiBhdHRlbXB0aW5nIHRvIGFsaWduIGdvcCBwdHNcbiAqL1xuVmlkZW9TZWdtZW50U3RyZWFtID0gZnVuY3Rpb24odHJhY2ssIG9wdGlvbnMpIHtcbiAgdmFyXG4gICAgc2VxdWVuY2VOdW1iZXIgPSAwLFxuICAgIG5hbFVuaXRzID0gW10sXG4gICAgZ29wc1RvQWxpZ25XaXRoID0gW10sXG4gICAgY29uZmlnLFxuICAgIHBwcztcblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICBWaWRlb1NlZ21lbnRTdHJlYW0ucHJvdG90eXBlLmluaXQuY2FsbCh0aGlzKTtcblxuICBkZWxldGUgdHJhY2subWluUFRTO1xuXG4gIHRoaXMuZ29wQ2FjaGVfID0gW107XG5cbiAgdGhpcy5wdXNoID0gZnVuY3Rpb24obmFsVW5pdCkge1xuICAgIGNvbGxlY3REdHNJbmZvKHRyYWNrLCBuYWxVbml0KTtcblxuICAgIC8vIHJlY29yZCB0aGUgdHJhY2sgY29uZmlnXG4gICAgaWYgKG5hbFVuaXQubmFsVW5pdFR5cGUgPT09ICdzZXFfcGFyYW1ldGVyX3NldF9yYnNwJyAmJiAhY29uZmlnKSB7XG4gICAgICBjb25maWcgPSBuYWxVbml0LmNvbmZpZztcbiAgICAgIHRyYWNrLnNwcyA9IFtuYWxVbml0LmRhdGFdO1xuXG4gICAgICBWSURFT19QUk9QRVJUSUVTLmZvckVhY2goZnVuY3Rpb24ocHJvcCkge1xuICAgICAgICB0cmFja1twcm9wXSA9IGNvbmZpZ1twcm9wXTtcbiAgICAgIH0sIHRoaXMpO1xuICAgIH1cblxuICAgIGlmIChuYWxVbml0Lm5hbFVuaXRUeXBlID09PSAncGljX3BhcmFtZXRlcl9zZXRfcmJzcCcgJiZcbiAgICAgICAgIXBwcykge1xuICAgICAgcHBzID0gbmFsVW5pdC5kYXRhO1xuICAgICAgdHJhY2sucHBzID0gW25hbFVuaXQuZGF0YV07XG4gICAgfVxuXG4gICAgLy8gYnVmZmVyIHZpZGVvIHVudGlsIGZsdXNoKCkgaXMgY2FsbGVkXG4gICAgbmFsVW5pdHMucHVzaChuYWxVbml0KTtcbiAgfTtcblxuICB0aGlzLmZsdXNoID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyXG4gICAgICBmcmFtZXMsXG4gICAgICBnb3BGb3JGdXNpb24sXG4gICAgICBnb3BzLFxuICAgICAgbW9vZixcbiAgICAgIG1kYXQsXG4gICAgICBib3hlcztcblxuICAgIC8vIFRocm93IGF3YXkgbmFsVW5pdHMgYXQgdGhlIHN0YXJ0IG9mIHRoZSBieXRlIHN0cmVhbSB1bnRpbFxuICAgIC8vIHdlIGZpbmQgdGhlIGZpcnN0IEFVRFxuICAgIHdoaWxlIChuYWxVbml0cy5sZW5ndGgpIHtcbiAgICAgIGlmIChuYWxVbml0c1swXS5uYWxVbml0VHlwZSA9PT0gJ2FjY2Vzc191bml0X2RlbGltaXRlcl9yYnNwJykge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIG5hbFVuaXRzLnNoaWZ0KCk7XG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIGVhcmx5IGlmIG5vIHZpZGVvIGRhdGEgaGFzIGJlZW4gb2JzZXJ2ZWRcbiAgICBpZiAobmFsVW5pdHMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aGlzLnJlc2V0U3RyZWFtXygpO1xuICAgICAgdGhpcy50cmlnZ2VyKCdkb25lJywgJ1ZpZGVvU2VnbWVudFN0cmVhbScpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIE9yZ2FuaXplIHRoZSByYXcgbmFsLXVuaXRzIGludG8gYXJyYXlzIHRoYXQgcmVwcmVzZW50XG4gICAgLy8gaGlnaGVyLWxldmVsIGNvbnN0cnVjdHMgc3VjaCBhcyBmcmFtZXMgYW5kIGdvcHNcbiAgICAvLyAoZ3JvdXAtb2YtcGljdHVyZXMpXG4gICAgZnJhbWVzID0gdGhpcy5ncm91cE5hbHNJbnRvRnJhbWVzXyhuYWxVbml0cyk7XG4gICAgZ29wcyA9IHRoaXMuZ3JvdXBGcmFtZXNJbnRvR29wc18oZnJhbWVzKTtcblxuICAgIC8vIElmIHRoZSBmaXJzdCBmcmFtZSBvZiB0aGlzIGZyYWdtZW50IGlzIG5vdCBhIGtleWZyYW1lIHdlIGhhdmVcbiAgICAvLyBhIHByb2JsZW0gc2luY2UgTVNFIChvbiBDaHJvbWUpIHJlcXVpcmVzIGEgbGVhZGluZyBrZXlmcmFtZS5cbiAgICAvL1xuICAgIC8vIFdlIGhhdmUgdHdvIGFwcHJvYWNoZXMgdG8gcmVwYWlyaW5nIHRoaXMgc2l0dWF0aW9uOlxuICAgIC8vIDEpIEdPUC1GVVNJT046XG4gICAgLy8gICAgVGhpcyBpcyB3aGVyZSB3ZSBrZWVwIHRyYWNrIG9mIHRoZSBHT1BTIChncm91cC1vZi1waWN0dXJlcylcbiAgICAvLyAgICBmcm9tIHByZXZpb3VzIGZyYWdtZW50cyBhbmQgYXR0ZW1wdCB0byBmaW5kIG9uZSB0aGF0IHdlIGNhblxuICAgIC8vICAgIHByZXBlbmQgdG8gdGhlIGN1cnJlbnQgZnJhZ21lbnQgaW4gb3JkZXIgdG8gY3JlYXRlIGEgdmFsaWRcbiAgICAvLyAgICBmcmFnbWVudC5cbiAgICAvLyAyKSBLRVlGUkFNRS1QVUxMSU5HOlxuICAgIC8vICAgIEhlcmUgd2Ugc2VhcmNoIGZvciB0aGUgZmlyc3Qga2V5ZnJhbWUgaW4gdGhlIGZyYWdtZW50IGFuZFxuICAgIC8vICAgIHRocm93IGF3YXkgYWxsIHRoZSBmcmFtZXMgYmV0d2VlbiB0aGUgc3RhcnQgb2YgdGhlIGZyYWdtZW50XG4gICAgLy8gICAgYW5kIHRoYXQga2V5ZnJhbWUuIFdlIHRoZW4gZXh0ZW5kIHRoZSBkdXJhdGlvbiBhbmQgcHVsbCB0aGVcbiAgICAvLyAgICBQVFMgb2YgdGhlIGtleWZyYW1lIGZvcndhcmQgc28gdGhhdCBpdCBjb3ZlcnMgdGhlIHRpbWUgcmFuZ2VcbiAgICAvLyAgICBvZiB0aGUgZnJhbWVzIHRoYXQgd2VyZSBkaXNwb3NlZCBvZi5cbiAgICAvL1xuICAgIC8vICMxIGlzIGZhciBwcmVmZXJlYWJsZSBvdmVyICMyIHdoaWNoIGNhbiBjYXVzZSBcInN0dXR0ZXJpbmdcIiBidXRcbiAgICAvLyByZXF1aXJlcyBtb3JlIHRoaW5ncyB0byBiZSBqdXN0IHJpZ2h0LlxuICAgIGlmICghZ29wc1swXVswXS5rZXlGcmFtZSkge1xuICAgICAgLy8gU2VhcmNoIGZvciBhIGdvcCBmb3IgZnVzaW9uIGZyb20gb3VyIGdvcENhY2hlXG4gICAgICBnb3BGb3JGdXNpb24gPSB0aGlzLmdldEdvcEZvckZ1c2lvbl8obmFsVW5pdHNbMF0sIHRyYWNrKTtcblxuICAgICAgaWYgKGdvcEZvckZ1c2lvbikge1xuICAgICAgICBnb3BzLnVuc2hpZnQoZ29wRm9yRnVzaW9uKTtcbiAgICAgICAgLy8gQWRqdXN0IEdvcHMnIG1ldGFkYXRhIHRvIGFjY291bnQgZm9yIHRoZSBpbmNsdXNpb24gb2YgdGhlXG4gICAgICAgIC8vIG5ldyBnb3AgYXQgdGhlIGJlZ2lubmluZ1xuICAgICAgICBnb3BzLmJ5dGVMZW5ndGggKz0gZ29wRm9yRnVzaW9uLmJ5dGVMZW5ndGg7XG4gICAgICAgIGdvcHMubmFsQ291bnQgKz0gZ29wRm9yRnVzaW9uLm5hbENvdW50O1xuICAgICAgICBnb3BzLnB0cyA9IGdvcEZvckZ1c2lvbi5wdHM7XG4gICAgICAgIGdvcHMuZHRzID0gZ29wRm9yRnVzaW9uLmR0cztcbiAgICAgICAgZ29wcy5kdXJhdGlvbiArPSBnb3BGb3JGdXNpb24uZHVyYXRpb247XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBJZiB3ZSBkaWRuJ3QgZmluZCBhIGNhbmRpZGF0ZSBnb3AgZmFsbCBiYWNrIHRvIGtleXJhbWUtcHVsbGluZ1xuICAgICAgICBnb3BzID0gdGhpcy5leHRlbmRGaXJzdEtleUZyYW1lXyhnb3BzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUcmltIGdvcHMgdG8gYWxpZ24gd2l0aCBnb3BzVG9BbGlnbldpdGhcbiAgICBpZiAoZ29wc1RvQWxpZ25XaXRoLmxlbmd0aCkge1xuICAgICAgdmFyIGFsaWduZWRHb3BzO1xuXG4gICAgICBpZiAob3B0aW9ucy5hbGlnbkdvcHNBdEVuZCkge1xuICAgICAgICBhbGlnbmVkR29wcyA9IHRoaXMuYWxpZ25Hb3BzQXRFbmRfKGdvcHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWxpZ25lZEdvcHMgPSB0aGlzLmFsaWduR29wc0F0U3RhcnRfKGdvcHMpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWFsaWduZWRHb3BzKSB7XG4gICAgICAgIC8vIHNhdmUgYWxsIHRoZSBuYWxzIGluIHRoZSBsYXN0IEdPUCBpbnRvIHRoZSBnb3AgY2FjaGVcbiAgICAgICAgdGhpcy5nb3BDYWNoZV8udW5zaGlmdCh7XG4gICAgICAgICAgZ29wOiBnb3BzLnBvcCgpLFxuICAgICAgICAgIHBwczogdHJhY2sucHBzLFxuICAgICAgICAgIHNwczogdHJhY2suc3BzXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIEtlZXAgYSBtYXhpbXVtIG9mIDYgR09QcyBpbiB0aGUgY2FjaGVcbiAgICAgICAgdGhpcy5nb3BDYWNoZV8ubGVuZ3RoID0gTWF0aC5taW4oNiwgdGhpcy5nb3BDYWNoZV8ubGVuZ3RoKTtcblxuICAgICAgICAvLyBDbGVhciBuYWxVbml0c1xuICAgICAgICBuYWxVbml0cyA9IFtdO1xuXG4gICAgICAgIC8vIHJldHVybiBlYXJseSBubyBnb3BzIGNhbiBiZSBhbGlnbmVkIHdpdGggZGVzaXJlZCBnb3BzVG9BbGlnbldpdGhcbiAgICAgICAgdGhpcy5yZXNldFN0cmVhbV8oKTtcbiAgICAgICAgdGhpcy50cmlnZ2VyKCdkb25lJywgJ1ZpZGVvU2VnbWVudFN0cmVhbScpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIFNvbWUgZ29wcyB3ZXJlIHRyaW1tZWQuIGNsZWFyIGR0cyBpbmZvIHNvIG1pblNlZ21lbnREdHMgYW5kIHB0cyBhcmUgY29ycmVjdFxuICAgICAgLy8gd2hlbiByZWNhbGN1bGF0ZWQgYmVmb3JlIHNlbmRpbmcgb2ZmIHRvIENvYWxlc2NlU3RyZWFtXG4gICAgICBjbGVhckR0c0luZm8odHJhY2spO1xuXG4gICAgICBnb3BzID0gYWxpZ25lZEdvcHM7XG4gICAgfVxuXG4gICAgY29sbGVjdER0c0luZm8odHJhY2ssIGdvcHMpO1xuXG4gICAgLy8gRmlyc3QsIHdlIGhhdmUgdG8gYnVpbGQgdGhlIGluZGV4IGZyb20gYnl0ZSBsb2NhdGlvbnMgdG9cbiAgICAvLyBzYW1wbGVzICh0aGF0IGlzLCBmcmFtZXMpIGluIHRoZSB2aWRlbyBkYXRhXG4gICAgdHJhY2suc2FtcGxlcyA9IHRoaXMuZ2VuZXJhdGVTYW1wbGVUYWJsZV8oZ29wcyk7XG5cbiAgICAvLyBDb25jYXRlbmF0ZSB0aGUgdmlkZW8gZGF0YSBhbmQgY29uc3RydWN0IHRoZSBtZGF0XG4gICAgbWRhdCA9IG1wNC5tZGF0KHRoaXMuY29uY2F0ZW5hdGVOYWxEYXRhXyhnb3BzKSk7XG5cbiAgICB0cmFjay5iYXNlTWVkaWFEZWNvZGVUaW1lID0gY2FsY3VsYXRlVHJhY2tCYXNlTWVkaWFEZWNvZGVUaW1lKHRyYWNrKTtcblxuICAgIHRoaXMudHJpZ2dlcigncHJvY2Vzc2VkR29wc0luZm8nLCBnb3BzLm1hcChmdW5jdGlvbihnb3ApIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHB0czogZ29wLnB0cyxcbiAgICAgICAgZHRzOiBnb3AuZHRzLFxuICAgICAgICBieXRlTGVuZ3RoOiBnb3AuYnl0ZUxlbmd0aFxuICAgICAgfTtcbiAgICB9KSk7XG5cbiAgICAvLyBzYXZlIGFsbCB0aGUgbmFscyBpbiB0aGUgbGFzdCBHT1AgaW50byB0aGUgZ29wIGNhY2hlXG4gICAgdGhpcy5nb3BDYWNoZV8udW5zaGlmdCh7XG4gICAgICBnb3A6IGdvcHMucG9wKCksXG4gICAgICBwcHM6IHRyYWNrLnBwcyxcbiAgICAgIHNwczogdHJhY2suc3BzXG4gICAgfSk7XG5cbiAgICAvLyBLZWVwIGEgbWF4aW11bSBvZiA2IEdPUHMgaW4gdGhlIGNhY2hlXG4gICAgdGhpcy5nb3BDYWNoZV8ubGVuZ3RoID0gTWF0aC5taW4oNiwgdGhpcy5nb3BDYWNoZV8ubGVuZ3RoKTtcblxuICAgIC8vIENsZWFyIG5hbFVuaXRzXG4gICAgbmFsVW5pdHMgPSBbXTtcblxuICAgIHRoaXMudHJpZ2dlcignYmFzZU1lZGlhRGVjb2RlVGltZScsIHRyYWNrLmJhc2VNZWRpYURlY29kZVRpbWUpO1xuICAgIHRoaXMudHJpZ2dlcigndGltZWxpbmVTdGFydEluZm8nLCB0cmFjay50aW1lbGluZVN0YXJ0SW5mbyk7XG5cbiAgICBtb29mID0gbXA0Lm1vb2Yoc2VxdWVuY2VOdW1iZXIsIFt0cmFja10pO1xuXG4gICAgLy8gaXQgd291bGQgYmUgZ3JlYXQgdG8gYWxsb2NhdGUgdGhpcyBhcnJheSB1cCBmcm9udCBpbnN0ZWFkIG9mXG4gICAgLy8gdGhyb3dpbmcgYXdheSBodW5kcmVkcyBvZiBtZWRpYSBzZWdtZW50IGZyYWdtZW50c1xuICAgIGJveGVzID0gbmV3IFVpbnQ4QXJyYXkobW9vZi5ieXRlTGVuZ3RoICsgbWRhdC5ieXRlTGVuZ3RoKTtcblxuICAgIC8vIEJ1bXAgdGhlIHNlcXVlbmNlIG51bWJlciBmb3IgbmV4dCB0aW1lXG4gICAgc2VxdWVuY2VOdW1iZXIrKztcblxuICAgIGJveGVzLnNldChtb29mKTtcbiAgICBib3hlcy5zZXQobWRhdCwgbW9vZi5ieXRlTGVuZ3RoKTtcblxuICAgIHRoaXMudHJpZ2dlcignZGF0YScsIHt0cmFjazogdHJhY2ssIGJveGVzOiBib3hlc30pO1xuXG4gICAgdGhpcy5yZXNldFN0cmVhbV8oKTtcblxuICAgIC8vIENvbnRpbnVlIHdpdGggdGhlIGZsdXNoIHByb2Nlc3Mgbm93XG4gICAgdGhpcy50cmlnZ2VyKCdkb25lJywgJ1ZpZGVvU2VnbWVudFN0cmVhbScpO1xuICB9O1xuXG4gIHRoaXMucmVzZXRTdHJlYW1fID0gZnVuY3Rpb24oKSB7XG4gICAgY2xlYXJEdHNJbmZvKHRyYWNrKTtcblxuICAgIC8vIHJlc2V0IGNvbmZpZyBhbmQgcHBzIGJlY2F1c2UgdGhleSBtYXkgZGlmZmVyIGFjcm9zcyBzZWdtZW50c1xuICAgIC8vIGZvciBpbnN0YW5jZSwgd2hlbiB3ZSBhcmUgcmVuZGl0aW9uIHN3aXRjaGluZ1xuICAgIGNvbmZpZyA9IHVuZGVmaW5lZDtcbiAgICBwcHMgPSB1bmRlZmluZWQ7XG4gIH07XG5cbiAgLy8gU2VhcmNoIGZvciBhIGNhbmRpZGF0ZSBHb3AgZm9yIGdvcC1mdXNpb24gZnJvbSB0aGUgZ29wIGNhY2hlIGFuZFxuICAvLyByZXR1cm4gaXQgb3IgcmV0dXJuIG51bGwgaWYgbm8gZ29vZCBjYW5kaWRhdGUgd2FzIGZvdW5kXG4gIHRoaXMuZ2V0R29wRm9yRnVzaW9uXyA9IGZ1bmN0aW9uKG5hbFVuaXQpIHtcbiAgICB2YXJcbiAgICAgIGhhbGZTZWNvbmQgPSA0NTAwMCwgLy8gSGFsZi1hLXNlY29uZCBpbiBhIDkwa2h6IGNsb2NrXG4gICAgICBhbGxvd2FibGVPdmVybGFwID0gMTAwMDAsIC8vIEFib3V0IDMgZnJhbWVzIEAgMzBmcHNcbiAgICAgIG5lYXJlc3REaXN0YW5jZSA9IEluZmluaXR5LFxuICAgICAgZHRzRGlzdGFuY2UsXG4gICAgICBuZWFyZXN0R29wT2JqLFxuICAgICAgY3VycmVudEdvcCxcbiAgICAgIGN1cnJlbnRHb3BPYmosXG4gICAgICBpO1xuXG4gICAgLy8gU2VhcmNoIGZvciB0aGUgR09QIG5lYXJlc3QgdG8gdGhlIGJlZ2lubmluZyBvZiB0aGlzIG5hbCB1bml0XG4gICAgZm9yIChpID0gMDsgaSA8IHRoaXMuZ29wQ2FjaGVfLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjdXJyZW50R29wT2JqID0gdGhpcy5nb3BDYWNoZV9baV07XG4gICAgICBjdXJyZW50R29wID0gY3VycmVudEdvcE9iai5nb3A7XG5cbiAgICAgIC8vIFJlamVjdCBHb3BzIHdpdGggZGlmZmVyZW50IFNQUyBvciBQUFNcbiAgICAgIGlmICghKHRyYWNrLnBwcyAmJiBhcnJheUVxdWFscyh0cmFjay5wcHNbMF0sIGN1cnJlbnRHb3BPYmoucHBzWzBdKSkgfHxcbiAgICAgICAgICAhKHRyYWNrLnNwcyAmJiBhcnJheUVxdWFscyh0cmFjay5zcHNbMF0sIGN1cnJlbnRHb3BPYmouc3BzWzBdKSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIFJlamVjdCBHb3BzIHRoYXQgd291bGQgcmVxdWlyZSBhIG5lZ2F0aXZlIGJhc2VNZWRpYURlY29kZVRpbWVcbiAgICAgIGlmIChjdXJyZW50R29wLmR0cyA8IHRyYWNrLnRpbWVsaW5lU3RhcnRJbmZvLmR0cykge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gVGhlIGRpc3RhbmNlIGJldHdlZW4gdGhlIGVuZCBvZiB0aGUgZ29wIGFuZCB0aGUgc3RhcnQgb2YgdGhlIG5hbFVuaXRcbiAgICAgIGR0c0Rpc3RhbmNlID0gKG5hbFVuaXQuZHRzIC0gY3VycmVudEdvcC5kdHMpIC0gY3VycmVudEdvcC5kdXJhdGlvbjtcblxuICAgICAgLy8gT25seSBjb25zaWRlciBHT1BTIHRoYXQgc3RhcnQgYmVmb3JlIHRoZSBuYWwgdW5pdCBhbmQgZW5kIHdpdGhpblxuICAgICAgLy8gYSBoYWxmLXNlY29uZCBvZiB0aGUgbmFsIHVuaXRcbiAgICAgIGlmIChkdHNEaXN0YW5jZSA+PSAtYWxsb3dhYmxlT3ZlcmxhcCAmJlxuICAgICAgICAgIGR0c0Rpc3RhbmNlIDw9IGhhbGZTZWNvbmQpIHtcblxuICAgICAgICAvLyBBbHdheXMgdXNlIHRoZSBjbG9zZXN0IEdPUCB3ZSBmb3VuZCBpZiB0aGVyZSBpcyBtb3JlIHRoYW5cbiAgICAgICAgLy8gb25lIGNhbmRpZGF0ZVxuICAgICAgICBpZiAoIW5lYXJlc3RHb3BPYmogfHxcbiAgICAgICAgICAgIG5lYXJlc3REaXN0YW5jZSA+IGR0c0Rpc3RhbmNlKSB7XG4gICAgICAgICAgbmVhcmVzdEdvcE9iaiA9IGN1cnJlbnRHb3BPYmo7XG4gICAgICAgICAgbmVhcmVzdERpc3RhbmNlID0gZHRzRGlzdGFuY2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobmVhcmVzdEdvcE9iaikge1xuICAgICAgcmV0dXJuIG5lYXJlc3RHb3BPYmouZ29wO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcblxuICB0aGlzLmV4dGVuZEZpcnN0S2V5RnJhbWVfID0gZnVuY3Rpb24oZ29wcykge1xuICAgIHZhciBjdXJyZW50R29wO1xuXG4gICAgaWYgKCFnb3BzWzBdWzBdLmtleUZyYW1lICYmIGdvcHMubGVuZ3RoID4gMSkge1xuICAgICAgLy8gUmVtb3ZlIHRoZSBmaXJzdCBHT1BcbiAgICAgIGN1cnJlbnRHb3AgPSBnb3BzLnNoaWZ0KCk7XG5cbiAgICAgIGdvcHMuYnl0ZUxlbmd0aCAtPSAgY3VycmVudEdvcC5ieXRlTGVuZ3RoO1xuICAgICAgZ29wcy5uYWxDb3VudCAtPSBjdXJyZW50R29wLm5hbENvdW50O1xuXG4gICAgICAvLyBFeHRlbmQgdGhlIGZpcnN0IGZyYW1lIG9mIHdoYXQgaXMgbm93IHRoZVxuICAgICAgLy8gZmlyc3QgZ29wIHRvIGNvdmVyIHRoZSB0aW1lIHBlcmlvZCBvZiB0aGVcbiAgICAgIC8vIGZyYW1lcyB3ZSBqdXN0IHJlbW92ZWRcbiAgICAgIGdvcHNbMF1bMF0uZHRzID0gY3VycmVudEdvcC5kdHM7XG4gICAgICBnb3BzWzBdWzBdLnB0cyA9IGN1cnJlbnRHb3AucHRzO1xuICAgICAgZ29wc1swXVswXS5kdXJhdGlvbiArPSBjdXJyZW50R29wLmR1cmF0aW9uO1xuICAgIH1cblxuICAgIHJldHVybiBnb3BzO1xuICB9O1xuXG4gIC8vIENvbnZlcnQgYW4gYXJyYXkgb2YgbmFsIHVuaXRzIGludG8gYW4gYXJyYXkgb2YgZnJhbWVzIHdpdGggZWFjaCBmcmFtZSBiZWluZ1xuICAvLyBjb21wb3NlZCBvZiB0aGUgbmFsIHVuaXRzIHRoYXQgbWFrZSB1cCB0aGF0IGZyYW1lXG4gIC8vIEFsc28ga2VlcCB0cmFjayBvZiBjdW1tdWxhdGl2ZSBkYXRhIGFib3V0IHRoZSBmcmFtZSBmcm9tIHRoZSBuYWwgdW5pdHMgc3VjaFxuICAvLyBhcyB0aGUgZnJhbWUgZHVyYXRpb24sIHN0YXJ0aW5nIHB0cywgZXRjLlxuICB0aGlzLmdyb3VwTmFsc0ludG9GcmFtZXNfID0gZnVuY3Rpb24obmFsVW5pdHMpIHtcbiAgICB2YXJcbiAgICAgIGksXG4gICAgICBjdXJyZW50TmFsLFxuICAgICAgY3VycmVudEZyYW1lID0gW10sXG4gICAgICBmcmFtZXMgPSBbXTtcblxuICAgIGN1cnJlbnRGcmFtZS5ieXRlTGVuZ3RoID0gMDtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBuYWxVbml0cy5sZW5ndGg7IGkrKykge1xuICAgICAgY3VycmVudE5hbCA9IG5hbFVuaXRzW2ldO1xuXG4gICAgICAvLyBTcGxpdCBvbiAnYXVkJy10eXBlIG5hbCB1bml0c1xuICAgICAgaWYgKGN1cnJlbnROYWwubmFsVW5pdFR5cGUgPT09ICdhY2Nlc3NfdW5pdF9kZWxpbWl0ZXJfcmJzcCcpIHtcbiAgICAgICAgLy8gU2luY2UgdGhlIHZlcnkgZmlyc3QgbmFsIHVuaXQgaXMgZXhwZWN0ZWQgdG8gYmUgYW4gQVVEXG4gICAgICAgIC8vIG9ubHkgcHVzaCB0byB0aGUgZnJhbWVzIGFycmF5IHdoZW4gY3VycmVudEZyYW1lIGlzIG5vdCBlbXB0eVxuICAgICAgICBpZiAoY3VycmVudEZyYW1lLmxlbmd0aCkge1xuICAgICAgICAgIGN1cnJlbnRGcmFtZS5kdXJhdGlvbiA9IGN1cnJlbnROYWwuZHRzIC0gY3VycmVudEZyYW1lLmR0cztcbiAgICAgICAgICBmcmFtZXMucHVzaChjdXJyZW50RnJhbWUpO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnRGcmFtZSA9IFtjdXJyZW50TmFsXTtcbiAgICAgICAgY3VycmVudEZyYW1lLmJ5dGVMZW5ndGggPSBjdXJyZW50TmFsLmRhdGEuYnl0ZUxlbmd0aDtcbiAgICAgICAgY3VycmVudEZyYW1lLnB0cyA9IGN1cnJlbnROYWwucHRzO1xuICAgICAgICBjdXJyZW50RnJhbWUuZHRzID0gY3VycmVudE5hbC5kdHM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBTcGVjaWZpY2FsbHkgZmxhZyBrZXkgZnJhbWVzIGZvciBlYXNlIG9mIHVzZSBsYXRlclxuICAgICAgICBpZiAoY3VycmVudE5hbC5uYWxVbml0VHlwZSA9PT0gJ3NsaWNlX2xheWVyX3dpdGhvdXRfcGFydGl0aW9uaW5nX3Jic3BfaWRyJykge1xuICAgICAgICAgIGN1cnJlbnRGcmFtZS5rZXlGcmFtZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudEZyYW1lLmR1cmF0aW9uID0gY3VycmVudE5hbC5kdHMgLSBjdXJyZW50RnJhbWUuZHRzO1xuICAgICAgICBjdXJyZW50RnJhbWUuYnl0ZUxlbmd0aCArPSBjdXJyZW50TmFsLmRhdGEuYnl0ZUxlbmd0aDtcbiAgICAgICAgY3VycmVudEZyYW1lLnB1c2goY3VycmVudE5hbCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gRm9yIHRoZSBsYXN0IGZyYW1lLCB1c2UgdGhlIGR1cmF0aW9uIG9mIHRoZSBwcmV2aW91cyBmcmFtZSBpZiB3ZVxuICAgIC8vIGhhdmUgbm90aGluZyBiZXR0ZXIgdG8gZ28gb25cbiAgICBpZiAoZnJhbWVzLmxlbmd0aCAmJlxuICAgICAgICAoIWN1cnJlbnRGcmFtZS5kdXJhdGlvbiB8fFxuICAgICAgICAgY3VycmVudEZyYW1lLmR1cmF0aW9uIDw9IDApKSB7XG4gICAgICBjdXJyZW50RnJhbWUuZHVyYXRpb24gPSBmcmFtZXNbZnJhbWVzLmxlbmd0aCAtIDFdLmR1cmF0aW9uO1xuICAgIH1cblxuICAgIC8vIFB1c2ggdGhlIGZpbmFsIGZyYW1lXG4gICAgZnJhbWVzLnB1c2goY3VycmVudEZyYW1lKTtcbiAgICByZXR1cm4gZnJhbWVzO1xuICB9O1xuXG4gIC8vIENvbnZlcnQgYW4gYXJyYXkgb2YgZnJhbWVzIGludG8gYW4gYXJyYXkgb2YgR29wIHdpdGggZWFjaCBHb3AgYmVpbmcgY29tcG9zZWRcbiAgLy8gb2YgdGhlIGZyYW1lcyB0aGF0IG1ha2UgdXAgdGhhdCBHb3BcbiAgLy8gQWxzbyBrZWVwIHRyYWNrIG9mIGN1bW11bGF0aXZlIGRhdGEgYWJvdXQgdGhlIEdvcCBmcm9tIHRoZSBmcmFtZXMgc3VjaCBhcyB0aGVcbiAgLy8gR29wIGR1cmF0aW9uLCBzdGFydGluZyBwdHMsIGV0Yy5cbiAgdGhpcy5ncm91cEZyYW1lc0ludG9Hb3BzXyA9IGZ1bmN0aW9uKGZyYW1lcykge1xuICAgIHZhclxuICAgICAgaSxcbiAgICAgIGN1cnJlbnRGcmFtZSxcbiAgICAgIGN1cnJlbnRHb3AgPSBbXSxcbiAgICAgIGdvcHMgPSBbXTtcblxuICAgIC8vIFdlIG11c3QgcHJlLXNldCBzb21lIG9mIHRoZSB2YWx1ZXMgb24gdGhlIEdvcCBzaW5jZSB3ZVxuICAgIC8vIGtlZXAgcnVubmluZyB0b3RhbHMgb2YgdGhlc2UgdmFsdWVzXG4gICAgY3VycmVudEdvcC5ieXRlTGVuZ3RoID0gMDtcbiAgICBjdXJyZW50R29wLm5hbENvdW50ID0gMDtcbiAgICBjdXJyZW50R29wLmR1cmF0aW9uID0gMDtcbiAgICBjdXJyZW50R29wLnB0cyA9IGZyYW1lc1swXS5wdHM7XG4gICAgY3VycmVudEdvcC5kdHMgPSBmcmFtZXNbMF0uZHRzO1xuXG4gICAgLy8gc3RvcmUgc29tZSBtZXRhZGF0YSBhYm91dCBhbGwgdGhlIEdvcHNcbiAgICBnb3BzLmJ5dGVMZW5ndGggPSAwO1xuICAgIGdvcHMubmFsQ291bnQgPSAwO1xuICAgIGdvcHMuZHVyYXRpb24gPSAwO1xuICAgIGdvcHMucHRzID0gZnJhbWVzWzBdLnB0cztcbiAgICBnb3BzLmR0cyA9IGZyYW1lc1swXS5kdHM7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgZnJhbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjdXJyZW50RnJhbWUgPSBmcmFtZXNbaV07XG5cbiAgICAgIGlmIChjdXJyZW50RnJhbWUua2V5RnJhbWUpIHtcbiAgICAgICAgLy8gU2luY2UgdGhlIHZlcnkgZmlyc3QgZnJhbWUgaXMgZXhwZWN0ZWQgdG8gYmUgYW4ga2V5ZnJhbWVcbiAgICAgICAgLy8gb25seSBwdXNoIHRvIHRoZSBnb3BzIGFycmF5IHdoZW4gY3VycmVudEdvcCBpcyBub3QgZW1wdHlcbiAgICAgICAgaWYgKGN1cnJlbnRHb3AubGVuZ3RoKSB7XG4gICAgICAgICAgZ29wcy5wdXNoKGN1cnJlbnRHb3ApO1xuICAgICAgICAgIGdvcHMuYnl0ZUxlbmd0aCArPSBjdXJyZW50R29wLmJ5dGVMZW5ndGg7XG4gICAgICAgICAgZ29wcy5uYWxDb3VudCArPSBjdXJyZW50R29wLm5hbENvdW50O1xuICAgICAgICAgIGdvcHMuZHVyYXRpb24gKz0gY3VycmVudEdvcC5kdXJhdGlvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIGN1cnJlbnRHb3AgPSBbY3VycmVudEZyYW1lXTtcbiAgICAgICAgY3VycmVudEdvcC5uYWxDb3VudCA9IGN1cnJlbnRGcmFtZS5sZW5ndGg7XG4gICAgICAgIGN1cnJlbnRHb3AuYnl0ZUxlbmd0aCA9IGN1cnJlbnRGcmFtZS5ieXRlTGVuZ3RoO1xuICAgICAgICBjdXJyZW50R29wLnB0cyA9IGN1cnJlbnRGcmFtZS5wdHM7XG4gICAgICAgIGN1cnJlbnRHb3AuZHRzID0gY3VycmVudEZyYW1lLmR0cztcbiAgICAgICAgY3VycmVudEdvcC5kdXJhdGlvbiA9IGN1cnJlbnRGcmFtZS5kdXJhdGlvbjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN1cnJlbnRHb3AuZHVyYXRpb24gKz0gY3VycmVudEZyYW1lLmR1cmF0aW9uO1xuICAgICAgICBjdXJyZW50R29wLm5hbENvdW50ICs9IGN1cnJlbnRGcmFtZS5sZW5ndGg7XG4gICAgICAgIGN1cnJlbnRHb3AuYnl0ZUxlbmd0aCArPSBjdXJyZW50RnJhbWUuYnl0ZUxlbmd0aDtcbiAgICAgICAgY3VycmVudEdvcC5wdXNoKGN1cnJlbnRGcmFtZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGdvcHMubGVuZ3RoICYmIGN1cnJlbnRHb3AuZHVyYXRpb24gPD0gMCkge1xuICAgICAgY3VycmVudEdvcC5kdXJhdGlvbiA9IGdvcHNbZ29wcy5sZW5ndGggLSAxXS5kdXJhdGlvbjtcbiAgICB9XG4gICAgZ29wcy5ieXRlTGVuZ3RoICs9IGN1cnJlbnRHb3AuYnl0ZUxlbmd0aDtcbiAgICBnb3BzLm5hbENvdW50ICs9IGN1cnJlbnRHb3AubmFsQ291bnQ7XG4gICAgZ29wcy5kdXJhdGlvbiArPSBjdXJyZW50R29wLmR1cmF0aW9uO1xuXG4gICAgLy8gcHVzaCB0aGUgZmluYWwgR29wXG4gICAgZ29wcy5wdXNoKGN1cnJlbnRHb3ApO1xuICAgIHJldHVybiBnb3BzO1xuICB9O1xuXG4gIC8vIGdlbmVyYXRlIHRoZSB0cmFjaydzIHNhbXBsZSB0YWJsZSBmcm9tIGFuIGFycmF5IG9mIGdvcHNcbiAgdGhpcy5nZW5lcmF0ZVNhbXBsZVRhYmxlXyA9IGZ1bmN0aW9uKGdvcHMsIGJhc2VEYXRhT2Zmc2V0KSB7XG4gICAgdmFyXG4gICAgICBoLCBpLFxuICAgICAgc2FtcGxlLFxuICAgICAgY3VycmVudEdvcCxcbiAgICAgIGN1cnJlbnRGcmFtZSxcbiAgICAgIGRhdGFPZmZzZXQgPSBiYXNlRGF0YU9mZnNldCB8fCAwLFxuICAgICAgc2FtcGxlcyA9IFtdO1xuXG4gICAgZm9yIChoID0gMDsgaCA8IGdvcHMubGVuZ3RoOyBoKyspIHtcbiAgICAgIGN1cnJlbnRHb3AgPSBnb3BzW2hdO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgY3VycmVudEdvcC5sZW5ndGg7IGkrKykge1xuICAgICAgICBjdXJyZW50RnJhbWUgPSBjdXJyZW50R29wW2ldO1xuXG4gICAgICAgIHNhbXBsZSA9IGNyZWF0ZURlZmF1bHRTYW1wbGUoKTtcblxuICAgICAgICBzYW1wbGUuZGF0YU9mZnNldCA9IGRhdGFPZmZzZXQ7XG4gICAgICAgIHNhbXBsZS5jb21wb3NpdGlvblRpbWVPZmZzZXQgPSBjdXJyZW50RnJhbWUucHRzIC0gY3VycmVudEZyYW1lLmR0cztcbiAgICAgICAgc2FtcGxlLmR1cmF0aW9uID0gY3VycmVudEZyYW1lLmR1cmF0aW9uO1xuICAgICAgICBzYW1wbGUuc2l6ZSA9IDQgKiBjdXJyZW50RnJhbWUubGVuZ3RoOyAvLyBTcGFjZSBmb3IgbmFsIHVuaXQgc2l6ZVxuICAgICAgICBzYW1wbGUuc2l6ZSArPSBjdXJyZW50RnJhbWUuYnl0ZUxlbmd0aDtcblxuICAgICAgICBpZiAoY3VycmVudEZyYW1lLmtleUZyYW1lKSB7XG4gICAgICAgICAgc2FtcGxlLmZsYWdzLmRlcGVuZHNPbiA9IDI7XG4gICAgICAgIH1cblxuICAgICAgICBkYXRhT2Zmc2V0ICs9IHNhbXBsZS5zaXplO1xuXG4gICAgICAgIHNhbXBsZXMucHVzaChzYW1wbGUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2FtcGxlcztcbiAgfTtcblxuICAvLyBnZW5lcmF0ZSB0aGUgdHJhY2sncyByYXcgbWRhdCBkYXRhIGZyb20gYW4gYXJyYXkgb2YgZ29wc1xuICB0aGlzLmNvbmNhdGVuYXRlTmFsRGF0YV8gPSBmdW5jdGlvbihnb3BzKSB7XG4gICAgdmFyXG4gICAgICBoLCBpLCBqLFxuICAgICAgY3VycmVudEdvcCxcbiAgICAgIGN1cnJlbnRGcmFtZSxcbiAgICAgIGN1cnJlbnROYWwsXG4gICAgICBkYXRhT2Zmc2V0ID0gMCxcbiAgICAgIG5hbHNCeXRlTGVuZ3RoID0gZ29wcy5ieXRlTGVuZ3RoLFxuICAgICAgbnVtYmVyT2ZOYWxzID0gZ29wcy5uYWxDb3VudCxcbiAgICAgIHRvdGFsQnl0ZUxlbmd0aCA9IG5hbHNCeXRlTGVuZ3RoICsgNCAqIG51bWJlck9mTmFscyxcbiAgICAgIGRhdGEgPSBuZXcgVWludDhBcnJheSh0b3RhbEJ5dGVMZW5ndGgpLFxuICAgICAgdmlldyA9IG5ldyBEYXRhVmlldyhkYXRhLmJ1ZmZlcik7XG5cbiAgICAvLyBGb3IgZWFjaCBHb3AuLlxuICAgIGZvciAoaCA9IDA7IGggPCBnb3BzLmxlbmd0aDsgaCsrKSB7XG4gICAgICBjdXJyZW50R29wID0gZ29wc1toXTtcblxuICAgICAgLy8gRm9yIGVhY2ggRnJhbWUuLlxuICAgICAgZm9yIChpID0gMDsgaSA8IGN1cnJlbnRHb3AubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY3VycmVudEZyYW1lID0gY3VycmVudEdvcFtpXTtcblxuICAgICAgICAvLyBGb3IgZWFjaCBOQUwuLlxuICAgICAgICBmb3IgKGogPSAwOyBqIDwgY3VycmVudEZyYW1lLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgY3VycmVudE5hbCA9IGN1cnJlbnRGcmFtZVtqXTtcblxuICAgICAgICAgIHZpZXcuc2V0VWludDMyKGRhdGFPZmZzZXQsIGN1cnJlbnROYWwuZGF0YS5ieXRlTGVuZ3RoKTtcbiAgICAgICAgICBkYXRhT2Zmc2V0ICs9IDQ7XG4gICAgICAgICAgZGF0YS5zZXQoY3VycmVudE5hbC5kYXRhLCBkYXRhT2Zmc2V0KTtcbiAgICAgICAgICBkYXRhT2Zmc2V0ICs9IGN1cnJlbnROYWwuZGF0YS5ieXRlTGVuZ3RoO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkYXRhO1xuICB9O1xuXG4gIC8vIHRyaW0gZ29wIGxpc3QgdG8gdGhlIGZpcnN0IGdvcCBmb3VuZCB0aGF0IGhhcyBhIG1hdGNoaW5nIHB0cyB3aXRoIGEgZ29wIGluIHRoZSBsaXN0XG4gIC8vIG9mIGdvcHNUb0FsaWduV2l0aCBzdGFydGluZyBmcm9tIHRoZSBTVEFSVCBvZiB0aGUgbGlzdFxuICB0aGlzLmFsaWduR29wc0F0U3RhcnRfID0gZnVuY3Rpb24oZ29wcykge1xuICAgIHZhciBhbGlnbkluZGV4LCBnb3BJbmRleCwgYWxpZ24sIGdvcCwgYnl0ZUxlbmd0aCwgbmFsQ291bnQsIGR1cmF0aW9uLCBhbGlnbmVkR29wcztcblxuICAgIGJ5dGVMZW5ndGggPSBnb3BzLmJ5dGVMZW5ndGg7XG4gICAgbmFsQ291bnQgPSBnb3BzLm5hbENvdW50O1xuICAgIGR1cmF0aW9uID0gZ29wcy5kdXJhdGlvbjtcbiAgICBhbGlnbkluZGV4ID0gZ29wSW5kZXggPSAwO1xuXG4gICAgd2hpbGUgKGFsaWduSW5kZXggPCBnb3BzVG9BbGlnbldpdGgubGVuZ3RoICYmIGdvcEluZGV4IDwgZ29wcy5sZW5ndGgpIHtcbiAgICAgIGFsaWduID0gZ29wc1RvQWxpZ25XaXRoW2FsaWduSW5kZXhdO1xuICAgICAgZ29wID0gZ29wc1tnb3BJbmRleF07XG5cbiAgICAgIGlmIChhbGlnbi5wdHMgPT09IGdvcC5wdHMpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGlmIChnb3AucHRzID4gYWxpZ24ucHRzKSB7XG4gICAgICAgIC8vIHRoaXMgY3VycmVudCBnb3Agc3RhcnRzIGFmdGVyIHRoZSBjdXJyZW50IGdvcCB3ZSB3YW50IHRvIGFsaWduIG9uLCBzbyBpbmNyZW1lbnRcbiAgICAgICAgLy8gYWxpZ24gaW5kZXhcbiAgICAgICAgYWxpZ25JbmRleCsrO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gY3VycmVudCBnb3Agc3RhcnRzIGJlZm9yZSB0aGUgY3VycmVudCBnb3Agd2Ugd2FudCB0byBhbGlnbiBvbi4gc28gaW5jcmVtZW50IGdvcFxuICAgICAgLy8gaW5kZXhcbiAgICAgIGdvcEluZGV4Kys7XG4gICAgICBieXRlTGVuZ3RoIC09IGdvcC5ieXRlTGVuZ3RoO1xuICAgICAgbmFsQ291bnQgLT0gZ29wLm5hbENvdW50O1xuICAgICAgZHVyYXRpb24gLT0gZ29wLmR1cmF0aW9uO1xuICAgIH1cblxuICAgIGlmIChnb3BJbmRleCA9PT0gMCkge1xuICAgICAgLy8gbm8gZ29wcyB0byB0cmltXG4gICAgICByZXR1cm4gZ29wcztcbiAgICB9XG5cbiAgICBpZiAoZ29wSW5kZXggPT09IGdvcHMubGVuZ3RoKSB7XG4gICAgICAvLyBhbGwgZ29wcyB0cmltbWVkLCBza2lwIGFwcGVuZGluZyBhbGwgZ29wc1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgYWxpZ25lZEdvcHMgPSBnb3BzLnNsaWNlKGdvcEluZGV4KTtcbiAgICBhbGlnbmVkR29wcy5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aDtcbiAgICBhbGlnbmVkR29wcy5kdXJhdGlvbiA9IGR1cmF0aW9uO1xuICAgIGFsaWduZWRHb3BzLm5hbENvdW50ID0gbmFsQ291bnQ7XG4gICAgYWxpZ25lZEdvcHMucHRzID0gYWxpZ25lZEdvcHNbMF0ucHRzO1xuICAgIGFsaWduZWRHb3BzLmR0cyA9IGFsaWduZWRHb3BzWzBdLmR0cztcblxuICAgIHJldHVybiBhbGlnbmVkR29wcztcbiAgfTtcblxuICAvLyB0cmltIGdvcCBsaXN0IHRvIHRoZSBmaXJzdCBnb3AgZm91bmQgdGhhdCBoYXMgYSBtYXRjaGluZyBwdHMgd2l0aCBhIGdvcCBpbiB0aGUgbGlzdFxuICAvLyBvZiBnb3BzVG9BbGlnbldpdGggc3RhcnRpbmcgZnJvbSB0aGUgRU5EIG9mIHRoZSBsaXN0XG4gIHRoaXMuYWxpZ25Hb3BzQXRFbmRfID0gZnVuY3Rpb24oZ29wcykge1xuICAgIHZhciBhbGlnbkluZGV4LCBnb3BJbmRleCwgYWxpZ24sIGdvcCwgYWxpZ25FbmRJbmRleCwgbWF0Y2hGb3VuZDtcblxuICAgIGFsaWduSW5kZXggPSBnb3BzVG9BbGlnbldpdGgubGVuZ3RoIC0gMTtcbiAgICBnb3BJbmRleCA9IGdvcHMubGVuZ3RoIC0gMTtcbiAgICBhbGlnbkVuZEluZGV4ID0gbnVsbDtcbiAgICBtYXRjaEZvdW5kID0gZmFsc2U7XG5cbiAgICB3aGlsZSAoYWxpZ25JbmRleCA+PSAwICYmIGdvcEluZGV4ID49IDApIHtcbiAgICAgIGFsaWduID0gZ29wc1RvQWxpZ25XaXRoW2FsaWduSW5kZXhdO1xuICAgICAgZ29wID0gZ29wc1tnb3BJbmRleF07XG5cbiAgICAgIGlmIChhbGlnbi5wdHMgPT09IGdvcC5wdHMpIHtcbiAgICAgICAgbWF0Y2hGb3VuZCA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBpZiAoYWxpZ24ucHRzID4gZ29wLnB0cykge1xuICAgICAgICBhbGlnbkluZGV4LS07XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoYWxpZ25JbmRleCA9PT0gZ29wc1RvQWxpZ25XaXRoLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgLy8gZ29wLnB0cyBpcyBncmVhdGVyIHRoYW4gdGhlIGxhc3QgYWxpZ25tZW50IGNhbmRpZGF0ZS4gSWYgbm8gbWF0Y2ggaXMgZm91bmRcbiAgICAgICAgLy8gYnkgdGhlIGVuZCBvZiB0aGlzIGxvb3AsIHdlIHN0aWxsIHdhbnQgdG8gYXBwZW5kIGdvcHMgdGhhdCBjb21lIGFmdGVyIHRoaXNcbiAgICAgICAgLy8gcG9pbnRcbiAgICAgICAgYWxpZ25FbmRJbmRleCA9IGdvcEluZGV4O1xuICAgICAgfVxuXG4gICAgICBnb3BJbmRleC0tO1xuICAgIH1cblxuICAgIGlmICghbWF0Y2hGb3VuZCAmJiBhbGlnbkVuZEluZGV4ID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgdHJpbUluZGV4O1xuXG4gICAgaWYgKG1hdGNoRm91bmQpIHtcbiAgICAgIHRyaW1JbmRleCA9IGdvcEluZGV4O1xuICAgIH0gZWxzZSB7XG4gICAgICB0cmltSW5kZXggPSBhbGlnbkVuZEluZGV4O1xuICAgIH1cblxuICAgIGlmICh0cmltSW5kZXggPT09IDApIHtcbiAgICAgIHJldHVybiBnb3BzO1xuICAgIH1cblxuICAgIHZhciBhbGlnbmVkR29wcyA9IGdvcHMuc2xpY2UodHJpbUluZGV4KTtcbiAgICB2YXIgbWV0YWRhdGEgPSBhbGlnbmVkR29wcy5yZWR1Y2UoZnVuY3Rpb24odG90YWwsIGdvcCkge1xuICAgICAgdG90YWwuYnl0ZUxlbmd0aCArPSBnb3AuYnl0ZUxlbmd0aDtcbiAgICAgIHRvdGFsLmR1cmF0aW9uICs9IGdvcC5kdXJhdGlvbjtcbiAgICAgIHRvdGFsLm5hbENvdW50ICs9IGdvcC5uYWxDb3VudDtcbiAgICAgIHJldHVybiB0b3RhbDtcbiAgICB9LCB7IGJ5dGVMZW5ndGg6IDAsIGR1cmF0aW9uOiAwLCBuYWxDb3VudDogMCB9KTtcblxuICAgIGFsaWduZWRHb3BzLmJ5dGVMZW5ndGggPSBtZXRhZGF0YS5ieXRlTGVuZ3RoO1xuICAgIGFsaWduZWRHb3BzLmR1cmF0aW9uID0gbWV0YWRhdGEuZHVyYXRpb247XG4gICAgYWxpZ25lZEdvcHMubmFsQ291bnQgPSBtZXRhZGF0YS5uYWxDb3VudDtcbiAgICBhbGlnbmVkR29wcy5wdHMgPSBhbGlnbmVkR29wc1swXS5wdHM7XG4gICAgYWxpZ25lZEdvcHMuZHRzID0gYWxpZ25lZEdvcHNbMF0uZHRzO1xuXG4gICAgcmV0dXJuIGFsaWduZWRHb3BzO1xuICB9O1xuXG4gIHRoaXMuYWxpZ25Hb3BzV2l0aCA9IGZ1bmN0aW9uKG5ld0dvcHNUb0FsaWduV2l0aCkge1xuICAgIGdvcHNUb0FsaWduV2l0aCA9IG5ld0dvcHNUb0FsaWduV2l0aDtcbiAgfTtcbn07XG5cblZpZGVvU2VnbWVudFN0cmVhbS5wcm90b3R5cGUgPSBuZXcgU3RyZWFtKCk7XG5cbi8qKlxuICogU3RvcmUgaW5mb3JtYXRpb24gYWJvdXQgdGhlIHN0YXJ0IGFuZCBlbmQgb2YgdGhlIHRyYWNrIGFuZCB0aGVcbiAqIGR1cmF0aW9uIGZvciBlYWNoIGZyYW1lL3NhbXBsZSB3ZSBwcm9jZXNzIGluIG9yZGVyIHRvIGNhbGN1bGF0ZVxuICogdGhlIGJhc2VNZWRpYURlY29kZVRpbWVcbiAqL1xuY29sbGVjdER0c0luZm8gPSBmdW5jdGlvbih0cmFjaywgZGF0YSkge1xuICBpZiAodHlwZW9mIGRhdGEucHRzID09PSAnbnVtYmVyJykge1xuICAgIGlmICh0cmFjay50aW1lbGluZVN0YXJ0SW5mby5wdHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdHJhY2sudGltZWxpbmVTdGFydEluZm8ucHRzID0gZGF0YS5wdHM7XG4gICAgfVxuXG4gICAgaWYgKHRyYWNrLm1pblNlZ21lbnRQdHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdHJhY2subWluU2VnbWVudFB0cyA9IGRhdGEucHRzO1xuICAgIH0gZWxzZSB7XG4gICAgICB0cmFjay5taW5TZWdtZW50UHRzID0gTWF0aC5taW4odHJhY2subWluU2VnbWVudFB0cywgZGF0YS5wdHMpO1xuICAgIH1cblxuICAgIGlmICh0cmFjay5tYXhTZWdtZW50UHRzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRyYWNrLm1heFNlZ21lbnRQdHMgPSBkYXRhLnB0cztcbiAgICB9IGVsc2Uge1xuICAgICAgdHJhY2subWF4U2VnbWVudFB0cyA9IE1hdGgubWF4KHRyYWNrLm1heFNlZ21lbnRQdHMsIGRhdGEucHRzKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIGRhdGEuZHRzID09PSAnbnVtYmVyJykge1xuICAgIGlmICh0cmFjay50aW1lbGluZVN0YXJ0SW5mby5kdHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdHJhY2sudGltZWxpbmVTdGFydEluZm8uZHRzID0gZGF0YS5kdHM7XG4gICAgfVxuXG4gICAgaWYgKHRyYWNrLm1pblNlZ21lbnREdHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdHJhY2subWluU2VnbWVudER0cyA9IGRhdGEuZHRzO1xuICAgIH0gZWxzZSB7XG4gICAgICB0cmFjay5taW5TZWdtZW50RHRzID0gTWF0aC5taW4odHJhY2subWluU2VnbWVudER0cywgZGF0YS5kdHMpO1xuICAgIH1cblxuICAgIGlmICh0cmFjay5tYXhTZWdtZW50RHRzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRyYWNrLm1heFNlZ21lbnREdHMgPSBkYXRhLmR0cztcbiAgICB9IGVsc2Uge1xuICAgICAgdHJhY2subWF4U2VnbWVudER0cyA9IE1hdGgubWF4KHRyYWNrLm1heFNlZ21lbnREdHMsIGRhdGEuZHRzKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogQ2xlYXIgdmFsdWVzIHVzZWQgdG8gY2FsY3VsYXRlIHRoZSBiYXNlTWVkaWFEZWNvZGVUaW1lIGJldHdlZW5cbiAqIHRyYWNrc1xuICovXG5jbGVhckR0c0luZm8gPSBmdW5jdGlvbih0cmFjaykge1xuICBkZWxldGUgdHJhY2subWluU2VnbWVudER0cztcbiAgZGVsZXRlIHRyYWNrLm1heFNlZ21lbnREdHM7XG4gIGRlbGV0ZSB0cmFjay5taW5TZWdtZW50UHRzO1xuICBkZWxldGUgdHJhY2subWF4U2VnbWVudFB0cztcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlIHRoZSB0cmFjaydzIGJhc2VNZWRpYURlY29kZVRpbWUgYmFzZWQgb24gdGhlIGVhcmxpZXN0XG4gKiBEVFMgdGhlIHRyYW5zbXV4ZXIgaGFzIGV2ZXIgc2VlbiBhbmQgdGhlIG1pbmltdW0gRFRTIGZvciB0aGVcbiAqIGN1cnJlbnQgdHJhY2tcbiAqL1xuY2FsY3VsYXRlVHJhY2tCYXNlTWVkaWFEZWNvZGVUaW1lID0gZnVuY3Rpb24odHJhY2spIHtcbiAgdmFyXG4gICAgYmFzZU1lZGlhRGVjb2RlVGltZSxcbiAgICBzY2FsZSxcbiAgICAvLyBDYWxjdWxhdGUgdGhlIGRpc3RhbmNlLCBpbiB0aW1lLCB0aGF0IHRoaXMgc2VnbWVudCBzdGFydHMgZnJvbSB0aGUgc3RhcnRcbiAgICAvLyBvZiB0aGUgdGltZWxpbmUgKGVhcmxpZXN0IHRpbWUgc2VlbiBzaW5jZSB0aGUgdHJhbnNtdXhlciBpbml0aWFsaXplZClcbiAgICB0aW1lU2luY2VTdGFydE9mVGltZWxpbmUgPSB0cmFjay5taW5TZWdtZW50RHRzIC0gdHJhY2sudGltZWxpbmVTdGFydEluZm8uZHRzO1xuXG4gIC8vIHRyYWNrLnRpbWVsaW5lU3RhcnRJbmZvLmJhc2VNZWRpYURlY29kZVRpbWUgaXMgdGhlIGxvY2F0aW9uLCBpbiB0aW1lLCB3aGVyZVxuICAvLyB3ZSB3YW50IHRoZSBzdGFydCBvZiB0aGUgZmlyc3Qgc2VnbWVudCB0byBiZSBwbGFjZWRcbiAgYmFzZU1lZGlhRGVjb2RlVGltZSA9IHRyYWNrLnRpbWVsaW5lU3RhcnRJbmZvLmJhc2VNZWRpYURlY29kZVRpbWU7XG5cbiAgLy8gQWRkIHRvIHRoYXQgdGhlIGRpc3RhbmNlIHRoaXMgc2VnbWVudCBpcyBmcm9tIHRoZSB2ZXJ5IGZpcnN0XG4gIGJhc2VNZWRpYURlY29kZVRpbWUgKz0gdGltZVNpbmNlU3RhcnRPZlRpbWVsaW5lO1xuXG4gIC8vIGJhc2VNZWRpYURlY29kZVRpbWUgbXVzdCBub3QgYmVjb21lIG5lZ2F0aXZlXG4gIGJhc2VNZWRpYURlY29kZVRpbWUgPSBNYXRoLm1heCgwLCBiYXNlTWVkaWFEZWNvZGVUaW1lKTtcblxuICBpZiAodHJhY2sudHlwZSA9PT0gJ2F1ZGlvJykge1xuICAgIC8vIEF1ZGlvIGhhcyBhIGRpZmZlcmVudCBjbG9jayBlcXVhbCB0byB0aGUgc2FtcGxpbmdfcmF0ZSBzbyB3ZSBuZWVkIHRvXG4gICAgLy8gc2NhbGUgdGhlIFBUUyB2YWx1ZXMgaW50byB0aGUgY2xvY2sgcmF0ZSBvZiB0aGUgdHJhY2tcbiAgICBzY2FsZSA9IHRyYWNrLnNhbXBsZXJhdGUgLyBPTkVfU0VDT05EX0lOX1RTO1xuICAgIGJhc2VNZWRpYURlY29kZVRpbWUgKj0gc2NhbGU7XG4gICAgYmFzZU1lZGlhRGVjb2RlVGltZSA9IE1hdGguZmxvb3IoYmFzZU1lZGlhRGVjb2RlVGltZSk7XG4gIH1cblxuICByZXR1cm4gYmFzZU1lZGlhRGVjb2RlVGltZTtcbn07XG5cbi8qKlxuICogQSBTdHJlYW0gdGhhdCBjYW4gY29tYmluZSBtdWx0aXBsZSBzdHJlYW1zIChpZS4gYXVkaW8gJiB2aWRlbylcbiAqIGludG8gYSBzaW5nbGUgb3V0cHV0IHNlZ21lbnQgZm9yIE1TRS4gQWxzbyBzdXBwb3J0cyBhdWRpby1vbmx5XG4gKiBhbmQgdmlkZW8tb25seSBzdHJlYW1zLlxuICovXG5Db2FsZXNjZVN0cmVhbSA9IGZ1bmN0aW9uKG9wdGlvbnMsIG1ldGFkYXRhU3RyZWFtKSB7XG4gIC8vIE51bWJlciBvZiBUcmFja3MgcGVyIG91dHB1dCBzZWdtZW50XG4gIC8vIElmIGdyZWF0ZXIgdGhhbiAxLCB3ZSBjb21iaW5lIG11bHRpcGxlXG4gIC8vIHRyYWNrcyBpbnRvIGEgc2luZ2xlIHNlZ21lbnRcbiAgdGhpcy5udW1iZXJPZlRyYWNrcyA9IDA7XG4gIHRoaXMubWV0YWRhdGFTdHJlYW0gPSBtZXRhZGF0YVN0cmVhbTtcblxuICBpZiAodHlwZW9mIG9wdGlvbnMucmVtdXggIT09ICd1bmRlZmluZWQnKSB7XG4gICAgdGhpcy5yZW11eFRyYWNrcyA9ICEhb3B0aW9ucy5yZW11eDtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnJlbXV4VHJhY2tzID0gdHJ1ZTtcbiAgfVxuXG4gIHRoaXMucGVuZGluZ1RyYWNrcyA9IFtdO1xuICB0aGlzLnZpZGVvVHJhY2sgPSBudWxsO1xuICB0aGlzLnBlbmRpbmdCb3hlcyA9IFtdO1xuICB0aGlzLnBlbmRpbmdDYXB0aW9ucyA9IFtdO1xuICB0aGlzLnBlbmRpbmdNZXRhZGF0YSA9IFtdO1xuICB0aGlzLnBlbmRpbmdCeXRlcyA9IDA7XG4gIHRoaXMuZW1pdHRlZFRyYWNrcyA9IDA7XG5cbiAgQ29hbGVzY2VTdHJlYW0ucHJvdG90eXBlLmluaXQuY2FsbCh0aGlzKTtcblxuICAvLyBUYWtlIG91dHB1dCBmcm9tIG11bHRpcGxlXG4gIHRoaXMucHVzaCA9IGZ1bmN0aW9uKG91dHB1dCkge1xuICAgIC8vIGJ1ZmZlciBpbmNvbWluZyBjYXB0aW9ucyB1bnRpbCB0aGUgYXNzb2NpYXRlZCB2aWRlbyBzZWdtZW50XG4gICAgLy8gZmluaXNoZXNcbiAgICBpZiAob3V0cHV0LnRleHQpIHtcbiAgICAgIHJldHVybiB0aGlzLnBlbmRpbmdDYXB0aW9ucy5wdXNoKG91dHB1dCk7XG4gICAgfVxuICAgIC8vIGJ1ZmZlciBpbmNvbWluZyBpZDMgdGFncyB1bnRpbCB0aGUgZmluYWwgZmx1c2hcbiAgICBpZiAob3V0cHV0LmZyYW1lcykge1xuICAgICAgcmV0dXJuIHRoaXMucGVuZGluZ01ldGFkYXRhLnB1c2gob3V0cHV0KTtcbiAgICB9XG5cbiAgICAvLyBBZGQgdGhpcyB0cmFjayB0byB0aGUgbGlzdCBvZiBwZW5kaW5nIHRyYWNrcyBhbmQgc3RvcmVcbiAgICAvLyBpbXBvcnRhbnQgaW5mb3JtYXRpb24gcmVxdWlyZWQgZm9yIHRoZSBjb25zdHJ1Y3Rpb24gb2ZcbiAgICAvLyB0aGUgZmluYWwgc2VnbWVudFxuICAgIHRoaXMucGVuZGluZ1RyYWNrcy5wdXNoKG91dHB1dC50cmFjayk7XG4gICAgdGhpcy5wZW5kaW5nQm94ZXMucHVzaChvdXRwdXQuYm94ZXMpO1xuICAgIHRoaXMucGVuZGluZ0J5dGVzICs9IG91dHB1dC5ib3hlcy5ieXRlTGVuZ3RoO1xuXG4gICAgaWYgKG91dHB1dC50cmFjay50eXBlID09PSAndmlkZW8nKSB7XG4gICAgICB0aGlzLnZpZGVvVHJhY2sgPSBvdXRwdXQudHJhY2s7XG4gICAgfVxuICAgIGlmIChvdXRwdXQudHJhY2sudHlwZSA9PT0gJ2F1ZGlvJykge1xuICAgICAgdGhpcy5hdWRpb1RyYWNrID0gb3V0cHV0LnRyYWNrO1xuICAgIH1cbiAgfTtcbn07XG5cbkNvYWxlc2NlU3RyZWFtLnByb3RvdHlwZSA9IG5ldyBTdHJlYW0oKTtcbkNvYWxlc2NlU3RyZWFtLnByb3RvdHlwZS5mbHVzaCA9IGZ1bmN0aW9uKGZsdXNoU291cmNlKSB7XG4gIHZhclxuICAgIG9mZnNldCA9IDAsXG4gICAgZXZlbnQgPSB7XG4gICAgICBjYXB0aW9uczogW10sXG4gICAgICBjYXB0aW9uU3RyZWFtczoge30sXG4gICAgICBtZXRhZGF0YTogW10sXG4gICAgICBpbmZvOiB7fVxuICAgIH0sXG4gICAgY2FwdGlvbixcbiAgICBpZDMsXG4gICAgaW5pdFNlZ21lbnQsXG4gICAgdGltZWxpbmVTdGFydFB0cyA9IDAsXG4gICAgaTtcblxuICBpZiAodGhpcy5wZW5kaW5nVHJhY2tzLmxlbmd0aCA8IHRoaXMubnVtYmVyT2ZUcmFja3MpIHtcbiAgICBpZiAoZmx1c2hTb3VyY2UgIT09ICdWaWRlb1NlZ21lbnRTdHJlYW0nICYmXG4gICAgICAgIGZsdXNoU291cmNlICE9PSAnQXVkaW9TZWdtZW50U3RyZWFtJykge1xuICAgICAgLy8gUmV0dXJuIGJlY2F1c2Ugd2UgaGF2ZW4ndCByZWNlaXZlZCBhIGZsdXNoIGZyb20gYSBkYXRhLWdlbmVyYXRpbmdcbiAgICAgIC8vIHBvcnRpb24gb2YgdGhlIHNlZ21lbnQgKG1lYW5pbmcgdGhhdCB3ZSBoYXZlIG9ubHkgcmVjaWV2ZWQgbWV0YS1kYXRhXG4gICAgICAvLyBvciBjYXB0aW9ucy4pXG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIGlmICh0aGlzLnJlbXV4VHJhY2tzKSB7XG4gICAgICAvLyBSZXR1cm4gdW50aWwgd2UgaGF2ZSBlbm91Z2ggdHJhY2tzIGZyb20gdGhlIHBpcGVsaW5lIHRvIHJlbXV4IChpZiB3ZVxuICAgICAgLy8gYXJlIHJlbXV4aW5nIGF1ZGlvIGFuZCB2aWRlbyBpbnRvIGEgc2luZ2xlIE1QNClcbiAgICAgIHJldHVybjtcbiAgICB9IGVsc2UgaWYgKHRoaXMucGVuZGluZ1RyYWNrcy5sZW5ndGggPT09IDApIHtcbiAgICAgIC8vIEluIHRoZSBjYXNlIHdoZXJlIHdlIHJlY2VpdmUgYSBmbHVzaCB3aXRob3V0IGFueSBkYXRhIGhhdmluZyBiZWVuXG4gICAgICAvLyByZWNlaXZlZCB3ZSBjb25zaWRlciBpdCBhbiBlbWl0dGVkIHRyYWNrIGZvciB0aGUgcHVycG9zZXMgb2YgY29hbGVzY2luZ1xuICAgICAgLy8gYGRvbmVgIGV2ZW50cy5cbiAgICAgIC8vIFdlIGRvIHRoaXMgZm9yIHRoZSBjYXNlIHdoZXJlIHRoZXJlIGlzIGFuIGF1ZGlvIGFuZCB2aWRlbyB0cmFjayBpbiB0aGVcbiAgICAgIC8vIHNlZ21lbnQgYnV0IG5vIGF1ZGlvIGRhdGEuIChzZWVuIGluIHNldmVyYWwgcGxheWxpc3RzIHdpdGggYWx0ZXJuYXRlXG4gICAgICAvLyBhdWRpbyB0cmFja3MgYW5kIG5vIGF1ZGlvIHByZXNlbnQgaW4gdGhlIG1haW4gVFMgc2VnbWVudHMuKVxuICAgICAgdGhpcy5lbWl0dGVkVHJhY2tzKys7XG5cbiAgICAgIGlmICh0aGlzLmVtaXR0ZWRUcmFja3MgPj0gdGhpcy5udW1iZXJPZlRyYWNrcykge1xuICAgICAgICB0aGlzLnRyaWdnZXIoJ2RvbmUnKTtcbiAgICAgICAgdGhpcy5lbWl0dGVkVHJhY2tzID0gMDtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cblxuICBpZiAodGhpcy52aWRlb1RyYWNrKSB7XG4gICAgdGltZWxpbmVTdGFydFB0cyA9IHRoaXMudmlkZW9UcmFjay50aW1lbGluZVN0YXJ0SW5mby5wdHM7XG4gICAgVklERU9fUFJPUEVSVElFUy5mb3JFYWNoKGZ1bmN0aW9uKHByb3ApIHtcbiAgICAgIGV2ZW50LmluZm9bcHJvcF0gPSB0aGlzLnZpZGVvVHJhY2tbcHJvcF07XG4gICAgfSwgdGhpcyk7XG4gIH0gZWxzZSBpZiAodGhpcy5hdWRpb1RyYWNrKSB7XG4gICAgdGltZWxpbmVTdGFydFB0cyA9IHRoaXMuYXVkaW9UcmFjay50aW1lbGluZVN0YXJ0SW5mby5wdHM7XG4gICAgQVVESU9fUFJPUEVSVElFUy5mb3JFYWNoKGZ1bmN0aW9uKHByb3ApIHtcbiAgICAgIGV2ZW50LmluZm9bcHJvcF0gPSB0aGlzLmF1ZGlvVHJhY2tbcHJvcF07XG4gICAgfSwgdGhpcyk7XG4gIH1cblxuICBpZiAodGhpcy5wZW5kaW5nVHJhY2tzLmxlbmd0aCA9PT0gMSkge1xuICAgIGV2ZW50LnR5cGUgPSB0aGlzLnBlbmRpbmdUcmFja3NbMF0udHlwZTtcbiAgfSBlbHNlIHtcbiAgICBldmVudC50eXBlID0gJ2NvbWJpbmVkJztcbiAgfVxuXG4gIHRoaXMuZW1pdHRlZFRyYWNrcyArPSB0aGlzLnBlbmRpbmdUcmFja3MubGVuZ3RoO1xuXG4gIGluaXRTZWdtZW50ID0gbXA0LmluaXRTZWdtZW50KHRoaXMucGVuZGluZ1RyYWNrcyk7XG5cbiAgLy8gQ3JlYXRlIGEgbmV3IHR5cGVkIGFycmF5IHRvIGhvbGQgdGhlIGluaXQgc2VnbWVudFxuICBldmVudC5pbml0U2VnbWVudCA9IG5ldyBVaW50OEFycmF5KGluaXRTZWdtZW50LmJ5dGVMZW5ndGgpO1xuXG4gIC8vIENyZWF0ZSBhbiBpbml0IHNlZ21lbnQgY29udGFpbmluZyBhIG1vb3ZcbiAgLy8gYW5kIHRyYWNrIGRlZmluaXRpb25zXG4gIGV2ZW50LmluaXRTZWdtZW50LnNldChpbml0U2VnbWVudCk7XG5cbiAgLy8gQ3JlYXRlIGEgbmV3IHR5cGVkIGFycmF5IHRvIGhvbGQgdGhlIG1vb2YrbWRhdHNcbiAgZXZlbnQuZGF0YSA9IG5ldyBVaW50OEFycmF5KHRoaXMucGVuZGluZ0J5dGVzKTtcblxuICAvLyBBcHBlbmQgZWFjaCBtb29mK21kYXQgKG9uZSBwZXIgdHJhY2spIHRvZ2V0aGVyXG4gIGZvciAoaSA9IDA7IGkgPCB0aGlzLnBlbmRpbmdCb3hlcy5sZW5ndGg7IGkrKykge1xuICAgIGV2ZW50LmRhdGEuc2V0KHRoaXMucGVuZGluZ0JveGVzW2ldLCBvZmZzZXQpO1xuICAgIG9mZnNldCArPSB0aGlzLnBlbmRpbmdCb3hlc1tpXS5ieXRlTGVuZ3RoO1xuICB9XG5cbiAgLy8gVHJhbnNsYXRlIGNhcHRpb24gUFRTIHRpbWVzIGludG8gc2Vjb25kIG9mZnNldHMgaW50byB0aGVcbiAgLy8gdmlkZW8gdGltZWxpbmUgZm9yIHRoZSBzZWdtZW50LCBhbmQgYWRkIHRyYWNrIGluZm9cbiAgZm9yIChpID0gMDsgaSA8IHRoaXMucGVuZGluZ0NhcHRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgY2FwdGlvbiA9IHRoaXMucGVuZGluZ0NhcHRpb25zW2ldO1xuICAgIGNhcHRpb24uc3RhcnRUaW1lID0gKGNhcHRpb24uc3RhcnRQdHMgLSB0aW1lbGluZVN0YXJ0UHRzKTtcbiAgICBjYXB0aW9uLnN0YXJ0VGltZSAvPSA5MGUzO1xuICAgIGNhcHRpb24uZW5kVGltZSA9IChjYXB0aW9uLmVuZFB0cyAtIHRpbWVsaW5lU3RhcnRQdHMpO1xuICAgIGNhcHRpb24uZW5kVGltZSAvPSA5MGUzO1xuICAgIGV2ZW50LmNhcHRpb25TdHJlYW1zW2NhcHRpb24uc3RyZWFtXSA9IHRydWU7XG4gICAgZXZlbnQuY2FwdGlvbnMucHVzaChjYXB0aW9uKTtcbiAgfVxuXG4gIC8vIFRyYW5zbGF0ZSBJRDMgZnJhbWUgUFRTIHRpbWVzIGludG8gc2Vjb25kIG9mZnNldHMgaW50byB0aGVcbiAgLy8gdmlkZW8gdGltZWxpbmUgZm9yIHRoZSBzZWdtZW50XG4gIGZvciAoaSA9IDA7IGkgPCB0aGlzLnBlbmRpbmdNZXRhZGF0YS5sZW5ndGg7IGkrKykge1xuICAgIGlkMyA9IHRoaXMucGVuZGluZ01ldGFkYXRhW2ldO1xuICAgIGlkMy5jdWVUaW1lID0gKGlkMy5wdHMgLSB0aW1lbGluZVN0YXJ0UHRzKTtcbiAgICBpZDMuY3VlVGltZSAvPSA5MGUzO1xuICAgIGV2ZW50Lm1ldGFkYXRhLnB1c2goaWQzKTtcbiAgfVxuICAvLyBXZSBhZGQgdGhpcyB0byBldmVyeSBzaW5nbGUgZW1pdHRlZCBzZWdtZW50IGV2ZW4gdGhvdWdoIHdlIG9ubHkgbmVlZFxuICAvLyBpdCBmb3IgdGhlIGZpcnN0XG4gIGV2ZW50Lm1ldGFkYXRhLmRpc3BhdGNoVHlwZSA9IHRoaXMubWV0YWRhdGFTdHJlYW0uZGlzcGF0Y2hUeXBlO1xuXG4gIC8vIFJlc2V0IHN0cmVhbSBzdGF0ZVxuICB0aGlzLnBlbmRpbmdUcmFja3MubGVuZ3RoID0gMDtcbiAgdGhpcy52aWRlb1RyYWNrID0gbnVsbDtcbiAgdGhpcy5wZW5kaW5nQm94ZXMubGVuZ3RoID0gMDtcbiAgdGhpcy5wZW5kaW5nQ2FwdGlvbnMubGVuZ3RoID0gMDtcbiAgdGhpcy5wZW5kaW5nQnl0ZXMgPSAwO1xuICB0aGlzLnBlbmRpbmdNZXRhZGF0YS5sZW5ndGggPSAwO1xuXG4gIC8vIEVtaXQgdGhlIGJ1aWx0IHNlZ21lbnRcbiAgdGhpcy50cmlnZ2VyKCdkYXRhJywgZXZlbnQpO1xuXG4gIC8vIE9ubHkgZW1pdCBgZG9uZWAgaWYgYWxsIHRyYWNrcyBoYXZlIGJlZW4gZmx1c2hlZCBhbmQgZW1pdHRlZFxuICBpZiAodGhpcy5lbWl0dGVkVHJhY2tzID49IHRoaXMubnVtYmVyT2ZUcmFja3MpIHtcbiAgICB0aGlzLnRyaWdnZXIoJ2RvbmUnKTtcbiAgICB0aGlzLmVtaXR0ZWRUcmFja3MgPSAwO1xuICB9XG59O1xuLyoqXG4gKiBBIFN0cmVhbSB0aGF0IGV4cGVjdHMgTVAyVCBiaW5hcnkgZGF0YSBhcyBpbnB1dCBhbmQgcHJvZHVjZXNcbiAqIGNvcnJlc3BvbmRpbmcgbWVkaWEgc2VnbWVudHMsIHN1aXRhYmxlIGZvciB1c2Ugd2l0aCBNZWRpYSBTb3VyY2VcbiAqIEV4dGVuc2lvbiAoTVNFKSBpbXBsZW1lbnRhdGlvbnMgdGhhdCBzdXBwb3J0IHRoZSBJU08gQk1GRiBieXRlXG4gKiBzdHJlYW0gZm9ybWF0LCBsaWtlIENocm9tZS5cbiAqL1xuVHJhbnNtdXhlciA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgdmFyXG4gICAgc2VsZiA9IHRoaXMsXG4gICAgaGFzRmx1c2hlZCA9IHRydWUsXG4gICAgdmlkZW9UcmFjayxcbiAgICBhdWRpb1RyYWNrO1xuXG4gIFRyYW5zbXV4ZXIucHJvdG90eXBlLmluaXQuY2FsbCh0aGlzKTtcblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdGhpcy5iYXNlTWVkaWFEZWNvZGVUaW1lID0gb3B0aW9ucy5iYXNlTWVkaWFEZWNvZGVUaW1lIHx8IDA7XG4gIHRoaXMudHJhbnNtdXhQaXBlbGluZV8gPSB7fTtcblxuICB0aGlzLnNldHVwQWFjUGlwZWxpbmUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgcGlwZWxpbmUgPSB7fTtcbiAgICB0aGlzLnRyYW5zbXV4UGlwZWxpbmVfID0gcGlwZWxpbmU7XG5cbiAgICBwaXBlbGluZS50eXBlID0gJ2FhYyc7XG4gICAgcGlwZWxpbmUubWV0YWRhdGFTdHJlYW0gPSBuZXcgbTJ0cy5NZXRhZGF0YVN0cmVhbSgpO1xuXG4gICAgLy8gc2V0IHVwIHRoZSBwYXJzaW5nIHBpcGVsaW5lXG4gICAgcGlwZWxpbmUuYWFjU3RyZWFtID0gbmV3IEFhY1N0cmVhbSgpO1xuICAgIHBpcGVsaW5lLmF1ZGlvVGltZXN0YW1wUm9sbG92ZXJTdHJlYW0gPSBuZXcgbTJ0cy5UaW1lc3RhbXBSb2xsb3ZlclN0cmVhbSgnYXVkaW8nKTtcbiAgICBwaXBlbGluZS50aW1lZE1ldGFkYXRhVGltZXN0YW1wUm9sbG92ZXJTdHJlYW0gPSBuZXcgbTJ0cy5UaW1lc3RhbXBSb2xsb3ZlclN0cmVhbSgndGltZWQtbWV0YWRhdGEnKTtcbiAgICBwaXBlbGluZS5hZHRzU3RyZWFtID0gbmV3IEFkdHNTdHJlYW0oKTtcbiAgICBwaXBlbGluZS5jb2FsZXNjZVN0cmVhbSA9IG5ldyBDb2FsZXNjZVN0cmVhbShvcHRpb25zLCBwaXBlbGluZS5tZXRhZGF0YVN0cmVhbSk7XG4gICAgcGlwZWxpbmUuaGVhZE9mUGlwZWxpbmUgPSBwaXBlbGluZS5hYWNTdHJlYW07XG5cbiAgICBwaXBlbGluZS5hYWNTdHJlYW1cbiAgICAgIC5waXBlKHBpcGVsaW5lLmF1ZGlvVGltZXN0YW1wUm9sbG92ZXJTdHJlYW0pXG4gICAgICAucGlwZShwaXBlbGluZS5hZHRzU3RyZWFtKTtcbiAgICBwaXBlbGluZS5hYWNTdHJlYW1cbiAgICAgIC5waXBlKHBpcGVsaW5lLnRpbWVkTWV0YWRhdGFUaW1lc3RhbXBSb2xsb3ZlclN0cmVhbSlcbiAgICAgIC5waXBlKHBpcGVsaW5lLm1ldGFkYXRhU3RyZWFtKVxuICAgICAgLnBpcGUocGlwZWxpbmUuY29hbGVzY2VTdHJlYW0pO1xuXG4gICAgcGlwZWxpbmUubWV0YWRhdGFTdHJlYW0ub24oJ3RpbWVzdGFtcCcsIGZ1bmN0aW9uKGZyYW1lKSB7XG4gICAgICBwaXBlbGluZS5hYWNTdHJlYW0uc2V0VGltZXN0YW1wKGZyYW1lLnRpbWVTdGFtcCk7XG4gICAgfSk7XG5cbiAgICBwaXBlbGluZS5hYWNTdHJlYW0ub24oJ2RhdGEnLCBmdW5jdGlvbihkYXRhKSB7XG4gICAgICBpZiAoZGF0YS50eXBlID09PSAndGltZWQtbWV0YWRhdGEnICYmICFwaXBlbGluZS5hdWRpb1NlZ21lbnRTdHJlYW0pIHtcbiAgICAgICAgYXVkaW9UcmFjayA9IGF1ZGlvVHJhY2sgfHwge1xuICAgICAgICAgIHRpbWVsaW5lU3RhcnRJbmZvOiB7XG4gICAgICAgICAgICBiYXNlTWVkaWFEZWNvZGVUaW1lOiBzZWxmLmJhc2VNZWRpYURlY29kZVRpbWVcbiAgICAgICAgICB9LFxuICAgICAgICAgIGNvZGVjOiAnYWR0cycsXG4gICAgICAgICAgdHlwZTogJ2F1ZGlvJ1xuICAgICAgICB9O1xuICAgICAgICAvLyBob29rIHVwIHRoZSBhdWRpbyBzZWdtZW50IHN0cmVhbSB0byB0aGUgZmlyc3QgdHJhY2sgd2l0aCBhYWMgZGF0YVxuICAgICAgICBwaXBlbGluZS5jb2FsZXNjZVN0cmVhbS5udW1iZXJPZlRyYWNrcysrO1xuICAgICAgICBwaXBlbGluZS5hdWRpb1NlZ21lbnRTdHJlYW0gPSBuZXcgQXVkaW9TZWdtZW50U3RyZWFtKGF1ZGlvVHJhY2spO1xuICAgICAgICAvLyBTZXQgdXAgdGhlIGZpbmFsIHBhcnQgb2YgdGhlIGF1ZGlvIHBpcGVsaW5lXG4gICAgICAgIHBpcGVsaW5lLmFkdHNTdHJlYW1cbiAgICAgICAgICAucGlwZShwaXBlbGluZS5hdWRpb1NlZ21lbnRTdHJlYW0pXG4gICAgICAgICAgLnBpcGUocGlwZWxpbmUuY29hbGVzY2VTdHJlYW0pO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gUmUtZW1pdCBhbnkgZGF0YSBjb21pbmcgZnJvbSB0aGUgY29hbGVzY2Ugc3RyZWFtIHRvIHRoZSBvdXRzaWRlIHdvcmxkXG4gICAgcGlwZWxpbmUuY29hbGVzY2VTdHJlYW0ub24oJ2RhdGEnLCB0aGlzLnRyaWdnZXIuYmluZCh0aGlzLCAnZGF0YScpKTtcbiAgICAvLyBMZXQgdGhlIGNvbnN1bWVyIGtub3cgd2UgaGF2ZSBmaW5pc2hlZCBmbHVzaGluZyB0aGUgZW50aXJlIHBpcGVsaW5lXG4gICAgcGlwZWxpbmUuY29hbGVzY2VTdHJlYW0ub24oJ2RvbmUnLCB0aGlzLnRyaWdnZXIuYmluZCh0aGlzLCAnZG9uZScpKTtcbiAgfTtcblxuICB0aGlzLnNldHVwVHNQaXBlbGluZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBwaXBlbGluZSA9IHt9O1xuICAgIHRoaXMudHJhbnNtdXhQaXBlbGluZV8gPSBwaXBlbGluZTtcblxuICAgIHBpcGVsaW5lLnR5cGUgPSAndHMnO1xuICAgIHBpcGVsaW5lLm1ldGFkYXRhU3RyZWFtID0gbmV3IG0ydHMuTWV0YWRhdGFTdHJlYW0oKTtcblxuICAgIC8vIHNldCB1cCB0aGUgcGFyc2luZyBwaXBlbGluZVxuICAgIHBpcGVsaW5lLnBhY2tldFN0cmVhbSA9IG5ldyBtMnRzLlRyYW5zcG9ydFBhY2tldFN0cmVhbSgpO1xuICAgIHBpcGVsaW5lLnBhcnNlU3RyZWFtID0gbmV3IG0ydHMuVHJhbnNwb3J0UGFyc2VTdHJlYW0oKTtcbiAgICBwaXBlbGluZS5lbGVtZW50YXJ5U3RyZWFtID0gbmV3IG0ydHMuRWxlbWVudGFyeVN0cmVhbSgpO1xuICAgIHBpcGVsaW5lLnZpZGVvVGltZXN0YW1wUm9sbG92ZXJTdHJlYW0gPSBuZXcgbTJ0cy5UaW1lc3RhbXBSb2xsb3ZlclN0cmVhbSgndmlkZW8nKTtcbiAgICBwaXBlbGluZS5hdWRpb1RpbWVzdGFtcFJvbGxvdmVyU3RyZWFtID0gbmV3IG0ydHMuVGltZXN0YW1wUm9sbG92ZXJTdHJlYW0oJ2F1ZGlvJyk7XG4gICAgcGlwZWxpbmUudGltZWRNZXRhZGF0YVRpbWVzdGFtcFJvbGxvdmVyU3RyZWFtID0gbmV3IG0ydHMuVGltZXN0YW1wUm9sbG92ZXJTdHJlYW0oJ3RpbWVkLW1ldGFkYXRhJyk7XG4gICAgcGlwZWxpbmUuYWR0c1N0cmVhbSA9IG5ldyBBZHRzU3RyZWFtKCk7XG4gICAgcGlwZWxpbmUuaDI2NFN0cmVhbSA9IG5ldyBIMjY0U3RyZWFtKCk7XG4gICAgcGlwZWxpbmUuY2FwdGlvblN0cmVhbSA9IG5ldyBtMnRzLkNhcHRpb25TdHJlYW0oKTtcbiAgICBwaXBlbGluZS5jb2FsZXNjZVN0cmVhbSA9IG5ldyBDb2FsZXNjZVN0cmVhbShvcHRpb25zLCBwaXBlbGluZS5tZXRhZGF0YVN0cmVhbSk7XG4gICAgcGlwZWxpbmUuaGVhZE9mUGlwZWxpbmUgPSBwaXBlbGluZS5wYWNrZXRTdHJlYW07XG5cbiAgICAvLyBkaXNhc3NlbWJsZSBNUEVHMi1UUyBwYWNrZXRzIGludG8gZWxlbWVudGFyeSBzdHJlYW1zXG4gICAgcGlwZWxpbmUucGFja2V0U3RyZWFtXG4gICAgICAucGlwZShwaXBlbGluZS5wYXJzZVN0cmVhbSlcbiAgICAgIC5waXBlKHBpcGVsaW5lLmVsZW1lbnRhcnlTdHJlYW0pO1xuXG4gICAgLy8gISFUSElTIE9SREVSIElTIElNUE9SVEFOVCEhXG4gICAgLy8gZGVtdXggdGhlIHN0cmVhbXNcbiAgICBwaXBlbGluZS5lbGVtZW50YXJ5U3RyZWFtXG4gICAgICAucGlwZShwaXBlbGluZS52aWRlb1RpbWVzdGFtcFJvbGxvdmVyU3RyZWFtKVxuICAgICAgLnBpcGUocGlwZWxpbmUuaDI2NFN0cmVhbSk7XG4gICAgcGlwZWxpbmUuZWxlbWVudGFyeVN0cmVhbVxuICAgICAgLnBpcGUocGlwZWxpbmUuYXVkaW9UaW1lc3RhbXBSb2xsb3ZlclN0cmVhbSlcbiAgICAgIC5waXBlKHBpcGVsaW5lLmFkdHNTdHJlYW0pO1xuXG4gICAgcGlwZWxpbmUuZWxlbWVudGFyeVN0cmVhbVxuICAgICAgLnBpcGUocGlwZWxpbmUudGltZWRNZXRhZGF0YVRpbWVzdGFtcFJvbGxvdmVyU3RyZWFtKVxuICAgICAgLnBpcGUocGlwZWxpbmUubWV0YWRhdGFTdHJlYW0pXG4gICAgICAucGlwZShwaXBlbGluZS5jb2FsZXNjZVN0cmVhbSk7XG5cbiAgICAvLyBIb29rIHVwIENFQS02MDgvNzA4IGNhcHRpb24gc3RyZWFtXG4gICAgcGlwZWxpbmUuaDI2NFN0cmVhbS5waXBlKHBpcGVsaW5lLmNhcHRpb25TdHJlYW0pXG4gICAgICAucGlwZShwaXBlbGluZS5jb2FsZXNjZVN0cmVhbSk7XG5cbiAgICBwaXBlbGluZS5lbGVtZW50YXJ5U3RyZWFtLm9uKCdkYXRhJywgZnVuY3Rpb24oZGF0YSkge1xuICAgICAgdmFyIGk7XG5cbiAgICAgIGlmIChkYXRhLnR5cGUgPT09ICdtZXRhZGF0YScpIHtcbiAgICAgICAgaSA9IGRhdGEudHJhY2tzLmxlbmd0aDtcblxuICAgICAgICAvLyBzY2FuIHRoZSB0cmFja3MgbGlzdGVkIGluIHRoZSBtZXRhZGF0YVxuICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgaWYgKCF2aWRlb1RyYWNrICYmIGRhdGEudHJhY2tzW2ldLnR5cGUgPT09ICd2aWRlbycpIHtcbiAgICAgICAgICAgIHZpZGVvVHJhY2sgPSBkYXRhLnRyYWNrc1tpXTtcbiAgICAgICAgICAgIHZpZGVvVHJhY2sudGltZWxpbmVTdGFydEluZm8uYmFzZU1lZGlhRGVjb2RlVGltZSA9IHNlbGYuYmFzZU1lZGlhRGVjb2RlVGltZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCFhdWRpb1RyYWNrICYmIGRhdGEudHJhY2tzW2ldLnR5cGUgPT09ICdhdWRpbycpIHtcbiAgICAgICAgICAgIGF1ZGlvVHJhY2sgPSBkYXRhLnRyYWNrc1tpXTtcbiAgICAgICAgICAgIGF1ZGlvVHJhY2sudGltZWxpbmVTdGFydEluZm8uYmFzZU1lZGlhRGVjb2RlVGltZSA9IHNlbGYuYmFzZU1lZGlhRGVjb2RlVGltZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBob29rIHVwIHRoZSB2aWRlbyBzZWdtZW50IHN0cmVhbSB0byB0aGUgZmlyc3QgdHJhY2sgd2l0aCBoMjY0IGRhdGFcbiAgICAgICAgaWYgKHZpZGVvVHJhY2sgJiYgIXBpcGVsaW5lLnZpZGVvU2VnbWVudFN0cmVhbSkge1xuICAgICAgICAgIHBpcGVsaW5lLmNvYWxlc2NlU3RyZWFtLm51bWJlck9mVHJhY2tzKys7XG4gICAgICAgICAgcGlwZWxpbmUudmlkZW9TZWdtZW50U3RyZWFtID0gbmV3IFZpZGVvU2VnbWVudFN0cmVhbSh2aWRlb1RyYWNrLCBvcHRpb25zKTtcblxuICAgICAgICAgIHBpcGVsaW5lLnZpZGVvU2VnbWVudFN0cmVhbS5vbigndGltZWxpbmVTdGFydEluZm8nLCBmdW5jdGlvbih0aW1lbGluZVN0YXJ0SW5mbykge1xuICAgICAgICAgIC8vIFdoZW4gdmlkZW8gZW1pdHMgdGltZWxpbmVTdGFydEluZm8gZGF0YSBhZnRlciBhIGZsdXNoLCB3ZSBmb3J3YXJkIHRoYXRcbiAgICAgICAgICAvLyBpbmZvIHRvIHRoZSBBdWRpb1NlZ21lbnRTdHJlYW0sIGlmIGl0IGV4aXN0cywgYmVjYXVzZSB2aWRlbyB0aW1lbGluZVxuICAgICAgICAgIC8vIGRhdGEgdGFrZXMgcHJlY2VkZW5jZS5cbiAgICAgICAgICAgIGlmIChhdWRpb1RyYWNrKSB7XG4gICAgICAgICAgICAgIGF1ZGlvVHJhY2sudGltZWxpbmVTdGFydEluZm8gPSB0aW1lbGluZVN0YXJ0SW5mbztcbiAgICAgICAgICAgICAgLy8gT24gdGhlIGZpcnN0IHNlZ21lbnQgd2UgdHJpbSBBQUMgZnJhbWVzIHRoYXQgZXhpc3QgYmVmb3JlIHRoZVxuICAgICAgICAgICAgICAvLyB2ZXJ5IGVhcmxpZXN0IERUUyB3ZSBoYXZlIHNlZW4gaW4gdmlkZW8gYmVjYXVzZSBDaHJvbWUgd2lsbFxuICAgICAgICAgICAgICAvLyBpbnRlcnByZXQgYW55IHZpZGVvIHRyYWNrIHdpdGggYSBiYXNlTWVkaWFEZWNvZGVUaW1lIHRoYXQgaXNcbiAgICAgICAgICAgICAgLy8gbm9uLXplcm8gYXMgYSBnYXAuXG4gICAgICAgICAgICAgIHBpcGVsaW5lLmF1ZGlvU2VnbWVudFN0cmVhbS5zZXRFYXJsaWVzdER0cyh0aW1lbGluZVN0YXJ0SW5mby5kdHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgcGlwZWxpbmUudmlkZW9TZWdtZW50U3RyZWFtLm9uKCdwcm9jZXNzZWRHb3BzSW5mbycsXG4gICAgICAgICAgICBzZWxmLnRyaWdnZXIuYmluZChzZWxmLCAnZ29wSW5mbycpKTtcblxuICAgICAgICAgIHBpcGVsaW5lLnZpZGVvU2VnbWVudFN0cmVhbS5vbignYmFzZU1lZGlhRGVjb2RlVGltZScsIGZ1bmN0aW9uKGJhc2VNZWRpYURlY29kZVRpbWUpIHtcbiAgICAgICAgICAgIGlmIChhdWRpb1RyYWNrKSB7XG4gICAgICAgICAgICAgIHBpcGVsaW5lLmF1ZGlvU2VnbWVudFN0cmVhbS5zZXRWaWRlb0Jhc2VNZWRpYURlY29kZVRpbWUoYmFzZU1lZGlhRGVjb2RlVGltZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICAvLyBTZXQgdXAgdGhlIGZpbmFsIHBhcnQgb2YgdGhlIHZpZGVvIHBpcGVsaW5lXG4gICAgICAgICAgcGlwZWxpbmUuaDI2NFN0cmVhbVxuICAgICAgICAgICAgLnBpcGUocGlwZWxpbmUudmlkZW9TZWdtZW50U3RyZWFtKVxuICAgICAgICAgICAgLnBpcGUocGlwZWxpbmUuY29hbGVzY2VTdHJlYW0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGF1ZGlvVHJhY2sgJiYgIXBpcGVsaW5lLmF1ZGlvU2VnbWVudFN0cmVhbSkge1xuICAgICAgICAgIC8vIGhvb2sgdXAgdGhlIGF1ZGlvIHNlZ21lbnQgc3RyZWFtIHRvIHRoZSBmaXJzdCB0cmFjayB3aXRoIGFhYyBkYXRhXG4gICAgICAgICAgcGlwZWxpbmUuY29hbGVzY2VTdHJlYW0ubnVtYmVyT2ZUcmFja3MrKztcbiAgICAgICAgICBwaXBlbGluZS5hdWRpb1NlZ21lbnRTdHJlYW0gPSBuZXcgQXVkaW9TZWdtZW50U3RyZWFtKGF1ZGlvVHJhY2spO1xuXG4gICAgICAgICAgLy8gU2V0IHVwIHRoZSBmaW5hbCBwYXJ0IG9mIHRoZSBhdWRpbyBwaXBlbGluZVxuICAgICAgICAgIHBpcGVsaW5lLmFkdHNTdHJlYW1cbiAgICAgICAgICAgIC5waXBlKHBpcGVsaW5lLmF1ZGlvU2VnbWVudFN0cmVhbSlcbiAgICAgICAgICAgIC5waXBlKHBpcGVsaW5lLmNvYWxlc2NlU3RyZWFtKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gUmUtZW1pdCBhbnkgZGF0YSBjb21pbmcgZnJvbSB0aGUgY29hbGVzY2Ugc3RyZWFtIHRvIHRoZSBvdXRzaWRlIHdvcmxkXG4gICAgcGlwZWxpbmUuY29hbGVzY2VTdHJlYW0ub24oJ2RhdGEnLCB0aGlzLnRyaWdnZXIuYmluZCh0aGlzLCAnZGF0YScpKTtcbiAgICAvLyBMZXQgdGhlIGNvbnN1bWVyIGtub3cgd2UgaGF2ZSBmaW5pc2hlZCBmbHVzaGluZyB0aGUgZW50aXJlIHBpcGVsaW5lXG4gICAgcGlwZWxpbmUuY29hbGVzY2VTdHJlYW0ub24oJ2RvbmUnLCB0aGlzLnRyaWdnZXIuYmluZCh0aGlzLCAnZG9uZScpKTtcbiAgfTtcblxuICAvLyBob29rIHVwIHRoZSBzZWdtZW50IHN0cmVhbXMgb25jZSB0cmFjayBtZXRhZGF0YSBpcyBkZWxpdmVyZWRcbiAgdGhpcy5zZXRCYXNlTWVkaWFEZWNvZGVUaW1lID0gZnVuY3Rpb24oYmFzZU1lZGlhRGVjb2RlVGltZSkge1xuICAgIHZhciBwaXBlbGluZSA9IHRoaXMudHJhbnNtdXhQaXBlbGluZV87XG5cbiAgICB0aGlzLmJhc2VNZWRpYURlY29kZVRpbWUgPSBiYXNlTWVkaWFEZWNvZGVUaW1lO1xuICAgIGlmIChhdWRpb1RyYWNrKSB7XG4gICAgICBhdWRpb1RyYWNrLnRpbWVsaW5lU3RhcnRJbmZvLmR0cyA9IHVuZGVmaW5lZDtcbiAgICAgIGF1ZGlvVHJhY2sudGltZWxpbmVTdGFydEluZm8ucHRzID0gdW5kZWZpbmVkO1xuICAgICAgY2xlYXJEdHNJbmZvKGF1ZGlvVHJhY2spO1xuICAgICAgYXVkaW9UcmFjay50aW1lbGluZVN0YXJ0SW5mby5iYXNlTWVkaWFEZWNvZGVUaW1lID0gYmFzZU1lZGlhRGVjb2RlVGltZTtcbiAgICAgIGlmIChwaXBlbGluZS5hdWRpb1RpbWVzdGFtcFJvbGxvdmVyU3RyZWFtKSB7XG4gICAgICAgIHBpcGVsaW5lLmF1ZGlvVGltZXN0YW1wUm9sbG92ZXJTdHJlYW0uZGlzY29udGludWl0eSgpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodmlkZW9UcmFjaykge1xuICAgICAgaWYgKHBpcGVsaW5lLnZpZGVvU2VnbWVudFN0cmVhbSkge1xuICAgICAgICBwaXBlbGluZS52aWRlb1NlZ21lbnRTdHJlYW0uZ29wQ2FjaGVfID0gW107XG4gICAgICAgIHBpcGVsaW5lLnZpZGVvVGltZXN0YW1wUm9sbG92ZXJTdHJlYW0uZGlzY29udGludWl0eSgpO1xuICAgICAgfVxuICAgICAgdmlkZW9UcmFjay50aW1lbGluZVN0YXJ0SW5mby5kdHMgPSB1bmRlZmluZWQ7XG4gICAgICB2aWRlb1RyYWNrLnRpbWVsaW5lU3RhcnRJbmZvLnB0cyA9IHVuZGVmaW5lZDtcbiAgICAgIGNsZWFyRHRzSW5mbyh2aWRlb1RyYWNrKTtcbiAgICAgIHBpcGVsaW5lLmNhcHRpb25TdHJlYW0ucmVzZXQoKTtcbiAgICAgIHZpZGVvVHJhY2sudGltZWxpbmVTdGFydEluZm8uYmFzZU1lZGlhRGVjb2RlVGltZSA9IGJhc2VNZWRpYURlY29kZVRpbWU7XG4gICAgfVxuXG4gICAgaWYgKHBpcGVsaW5lLnRpbWVkTWV0YWRhdGFUaW1lc3RhbXBSb2xsb3ZlclN0cmVhbSkge1xuICAgICAgcGlwZWxpbmUudGltZWRNZXRhZGF0YVRpbWVzdGFtcFJvbGxvdmVyU3RyZWFtLmRpc2NvbnRpbnVpdHkoKTtcbiAgICB9XG4gIH07XG5cbiAgdGhpcy5zZXRBdWRpb0FwcGVuZFN0YXJ0ID0gZnVuY3Rpb24odGltZXN0YW1wKSB7XG4gICAgaWYgKGF1ZGlvVHJhY2spIHtcbiAgICAgIHRoaXMudHJhbnNtdXhQaXBlbGluZV8uYXVkaW9TZWdtZW50U3RyZWFtLnNldEF1ZGlvQXBwZW5kU3RhcnQodGltZXN0YW1wKTtcbiAgICB9XG4gIH07XG5cbiAgdGhpcy5hbGlnbkdvcHNXaXRoID0gZnVuY3Rpb24oZ29wc1RvQWxpZ25XaXRoKSB7XG4gICAgaWYgKHZpZGVvVHJhY2sgJiYgdGhpcy50cmFuc211eFBpcGVsaW5lXy52aWRlb1NlZ21lbnRTdHJlYW0pIHtcbiAgICAgIHRoaXMudHJhbnNtdXhQaXBlbGluZV8udmlkZW9TZWdtZW50U3RyZWFtLmFsaWduR29wc1dpdGgoZ29wc1RvQWxpZ25XaXRoKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gZmVlZCBpbmNvbWluZyBkYXRhIHRvIHRoZSBmcm9udCBvZiB0aGUgcGFyc2luZyBwaXBlbGluZVxuICB0aGlzLnB1c2ggPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgaWYgKGhhc0ZsdXNoZWQpIHtcbiAgICAgIHZhciBpc0FhYyA9IGlzTGlrZWx5QWFjRGF0YShkYXRhKTtcblxuICAgICAgaWYgKGlzQWFjICYmIHRoaXMudHJhbnNtdXhQaXBlbGluZV8udHlwZSAhPT0gJ2FhYycpIHtcbiAgICAgICAgdGhpcy5zZXR1cEFhY1BpcGVsaW5lKCk7XG4gICAgICB9IGVsc2UgaWYgKCFpc0FhYyAmJiB0aGlzLnRyYW5zbXV4UGlwZWxpbmVfLnR5cGUgIT09ICd0cycpIHtcbiAgICAgICAgdGhpcy5zZXR1cFRzUGlwZWxpbmUoKTtcbiAgICAgIH1cbiAgICAgIGhhc0ZsdXNoZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy50cmFuc211eFBpcGVsaW5lXy5oZWFkT2ZQaXBlbGluZS5wdXNoKGRhdGEpO1xuICB9O1xuXG4gIC8vIGZsdXNoIGFueSBidWZmZXJlZCBkYXRhXG4gIHRoaXMuZmx1c2ggPSBmdW5jdGlvbigpIHtcbiAgICAgIGhhc0ZsdXNoZWQgPSB0cnVlO1xuICAgIC8vIFN0YXJ0IGF0IHRoZSB0b3Agb2YgdGhlIHBpcGVsaW5lIGFuZCBmbHVzaCBhbGwgcGVuZGluZyB3b3JrXG4gICAgdGhpcy50cmFuc211eFBpcGVsaW5lXy5oZWFkT2ZQaXBlbGluZS5mbHVzaCgpO1xuICB9O1xuXG4gIC8vIENhcHRpb24gZGF0YSBoYXMgdG8gYmUgcmVzZXQgd2hlbiBzZWVraW5nIG91dHNpZGUgYnVmZmVyZWQgcmFuZ2VcbiAgdGhpcy5yZXNldENhcHRpb25zID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMudHJhbnNtdXhQaXBlbGluZV8uY2FwdGlvblN0cmVhbSkge1xuICAgICAgdGhpcy50cmFuc211eFBpcGVsaW5lXy5jYXB0aW9uU3RyZWFtLnJlc2V0KCk7XG4gICAgfVxuICB9O1xuXG59O1xuVHJhbnNtdXhlci5wcm90b3R5cGUgPSBuZXcgU3RyZWFtKCk7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBUcmFuc211eGVyOiBUcmFuc211eGVyLFxuICBWaWRlb1NlZ21lbnRTdHJlYW06IFZpZGVvU2VnbWVudFN0cmVhbSxcbiAgQXVkaW9TZWdtZW50U3RyZWFtOiBBdWRpb1NlZ21lbnRTdHJlYW0sXG4gIEFVRElPX1BST1BFUlRJRVM6IEFVRElPX1BST1BFUlRJRVMsXG4gIFZJREVPX1BST1BFUlRJRVM6IFZJREVPX1BST1BFUlRJRVNcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/videojs-contrib-media-sources/node_modules/mux.js/lib/mp4/transmuxer.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/videojs-contrib-media-sources/node_modules/mux.js/lib/utils/clock.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/videojs-contrib-media-sources/node_modules/mux.js/lib/utils/clock.js ***!
  \*******************************************************************************************/
/***/ ((module) => {

eval("var\n  ONE_SECOND_IN_TS = 90000, // 90kHz clock\n  secondsToVideoTs,\n  secondsToAudioTs,\n  videoTsToSeconds,\n  audioTsToSeconds,\n  audioTsToVideoTs,\n  videoTsToAudioTs;\n\nsecondsToVideoTs = function(seconds) {\n  return seconds * ONE_SECOND_IN_TS;\n};\n\nsecondsToAudioTs = function(seconds, sampleRate) {\n  return seconds * sampleRate;\n};\n\nvideoTsToSeconds = function(timestamp) {\n  return timestamp / ONE_SECOND_IN_TS;\n};\n\naudioTsToSeconds = function(timestamp, sampleRate) {\n  return timestamp / sampleRate;\n};\n\naudioTsToVideoTs = function(timestamp, sampleRate) {\n  return secondsToVideoTs(audioTsToSeconds(timestamp, sampleRate));\n};\n\nvideoTsToAudioTs = function(timestamp, sampleRate) {\n  return secondsToAudioTs(videoTsToSeconds(timestamp), sampleRate);\n};\n\nmodule.exports = {\n  secondsToVideoTs: secondsToVideoTs,\n  secondsToAudioTs: secondsToAudioTs,\n  videoTsToSeconds: videoTsToSeconds,\n  audioTsToSeconds: audioTsToSeconds,\n  audioTsToVideoTs: audioTsToVideoTs,\n  videoTsToAudioTs: videoTsToAudioTs\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdmlkZW9qcy1jb250cmliLW1lZGlhLXNvdXJjZXMvbm9kZV9tb2R1bGVzL211eC5qcy9saWIvdXRpbHMvY2xvY2suanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktdjAtcHJvamVjdC8uL25vZGVfbW9kdWxlcy92aWRlb2pzLWNvbnRyaWItbWVkaWEtc291cmNlcy9ub2RlX21vZHVsZXMvbXV4LmpzL2xpYi91dGlscy9jbG9jay5qcz8xYTVhIl0sInNvdXJjZXNDb250ZW50IjpbInZhclxuICBPTkVfU0VDT05EX0lOX1RTID0gOTAwMDAsIC8vIDkwa0h6IGNsb2NrXG4gIHNlY29uZHNUb1ZpZGVvVHMsXG4gIHNlY29uZHNUb0F1ZGlvVHMsXG4gIHZpZGVvVHNUb1NlY29uZHMsXG4gIGF1ZGlvVHNUb1NlY29uZHMsXG4gIGF1ZGlvVHNUb1ZpZGVvVHMsXG4gIHZpZGVvVHNUb0F1ZGlvVHM7XG5cbnNlY29uZHNUb1ZpZGVvVHMgPSBmdW5jdGlvbihzZWNvbmRzKSB7XG4gIHJldHVybiBzZWNvbmRzICogT05FX1NFQ09ORF9JTl9UUztcbn07XG5cbnNlY29uZHNUb0F1ZGlvVHMgPSBmdW5jdGlvbihzZWNvbmRzLCBzYW1wbGVSYXRlKSB7XG4gIHJldHVybiBzZWNvbmRzICogc2FtcGxlUmF0ZTtcbn07XG5cbnZpZGVvVHNUb1NlY29uZHMgPSBmdW5jdGlvbih0aW1lc3RhbXApIHtcbiAgcmV0dXJuIHRpbWVzdGFtcCAvIE9ORV9TRUNPTkRfSU5fVFM7XG59O1xuXG5hdWRpb1RzVG9TZWNvbmRzID0gZnVuY3Rpb24odGltZXN0YW1wLCBzYW1wbGVSYXRlKSB7XG4gIHJldHVybiB0aW1lc3RhbXAgLyBzYW1wbGVSYXRlO1xufTtcblxuYXVkaW9Uc1RvVmlkZW9UcyA9IGZ1bmN0aW9uKHRpbWVzdGFtcCwgc2FtcGxlUmF0ZSkge1xuICByZXR1cm4gc2Vjb25kc1RvVmlkZW9UcyhhdWRpb1RzVG9TZWNvbmRzKHRpbWVzdGFtcCwgc2FtcGxlUmF0ZSkpO1xufTtcblxudmlkZW9Uc1RvQXVkaW9UcyA9IGZ1bmN0aW9uKHRpbWVzdGFtcCwgc2FtcGxlUmF0ZSkge1xuICByZXR1cm4gc2Vjb25kc1RvQXVkaW9Ucyh2aWRlb1RzVG9TZWNvbmRzKHRpbWVzdGFtcCksIHNhbXBsZVJhdGUpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHNlY29uZHNUb1ZpZGVvVHM6IHNlY29uZHNUb1ZpZGVvVHMsXG4gIHNlY29uZHNUb0F1ZGlvVHM6IHNlY29uZHNUb0F1ZGlvVHMsXG4gIHZpZGVvVHNUb1NlY29uZHM6IHZpZGVvVHNUb1NlY29uZHMsXG4gIGF1ZGlvVHNUb1NlY29uZHM6IGF1ZGlvVHNUb1NlY29uZHMsXG4gIGF1ZGlvVHNUb1ZpZGVvVHM6IGF1ZGlvVHNUb1ZpZGVvVHMsXG4gIHZpZGVvVHNUb0F1ZGlvVHM6IHZpZGVvVHNUb0F1ZGlvVHNcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/videojs-contrib-media-sources/node_modules/mux.js/lib/utils/clock.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/videojs-contrib-media-sources/node_modules/mux.js/lib/utils/exp-golomb.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/videojs-contrib-media-sources/node_modules/mux.js/lib/utils/exp-golomb.js ***!
  \************************************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nvar ExpGolomb;\n\n/**\n * Parser for exponential Golomb codes, a variable-bitwidth number encoding\n * scheme used by h264.\n */\nExpGolomb = function(workingData) {\n  var\n    // the number of bytes left to examine in workingData\n    workingBytesAvailable = workingData.byteLength,\n\n    // the current word being examined\n    workingWord = 0, // :uint\n\n    // the number of bits left to examine in the current word\n    workingBitsAvailable = 0; // :uint;\n\n  // ():uint\n  this.length = function() {\n    return (8 * workingBytesAvailable);\n  };\n\n  // ():uint\n  this.bitsAvailable = function() {\n    return (8 * workingBytesAvailable) + workingBitsAvailable;\n  };\n\n  // ():void\n  this.loadWord = function() {\n    var\n      position = workingData.byteLength - workingBytesAvailable,\n      workingBytes = new Uint8Array(4),\n      availableBytes = Math.min(4, workingBytesAvailable);\n\n    if (availableBytes === 0) {\n      throw new Error('no bytes available');\n    }\n\n    workingBytes.set(workingData.subarray(position,\n                                          position + availableBytes));\n    workingWord = new DataView(workingBytes.buffer).getUint32(0);\n\n    // track the amount of workingData that has been processed\n    workingBitsAvailable = availableBytes * 8;\n    workingBytesAvailable -= availableBytes;\n  };\n\n  // (count:int):void\n  this.skipBits = function(count) {\n    var skipBytes; // :int\n    if (workingBitsAvailable > count) {\n      workingWord          <<= count;\n      workingBitsAvailable -= count;\n    } else {\n      count -= workingBitsAvailable;\n      skipBytes = Math.floor(count / 8);\n\n      count -= (skipBytes * 8);\n      workingBytesAvailable -= skipBytes;\n\n      this.loadWord();\n\n      workingWord <<= count;\n      workingBitsAvailable -= count;\n    }\n  };\n\n  // (size:int):uint\n  this.readBits = function(size) {\n    var\n      bits = Math.min(workingBitsAvailable, size), // :uint\n      valu = workingWord >>> (32 - bits); // :uint\n    // if size > 31, handle error\n    workingBitsAvailable -= bits;\n    if (workingBitsAvailable > 0) {\n      workingWord <<= bits;\n    } else if (workingBytesAvailable > 0) {\n      this.loadWord();\n    }\n\n    bits = size - bits;\n    if (bits > 0) {\n      return valu << bits | this.readBits(bits);\n    }\n    return valu;\n  };\n\n  // ():uint\n  this.skipLeadingZeros = function() {\n    var leadingZeroCount; // :uint\n    for (leadingZeroCount = 0; leadingZeroCount < workingBitsAvailable; ++leadingZeroCount) {\n      if ((workingWord & (0x80000000 >>> leadingZeroCount)) !== 0) {\n        // the first bit of working word is 1\n        workingWord <<= leadingZeroCount;\n        workingBitsAvailable -= leadingZeroCount;\n        return leadingZeroCount;\n      }\n    }\n\n    // we exhausted workingWord and still have not found a 1\n    this.loadWord();\n    return leadingZeroCount + this.skipLeadingZeros();\n  };\n\n  // ():void\n  this.skipUnsignedExpGolomb = function() {\n    this.skipBits(1 + this.skipLeadingZeros());\n  };\n\n  // ():void\n  this.skipExpGolomb = function() {\n    this.skipBits(1 + this.skipLeadingZeros());\n  };\n\n  // ():uint\n  this.readUnsignedExpGolomb = function() {\n    var clz = this.skipLeadingZeros(); // :uint\n    return this.readBits(clz + 1) - 1;\n  };\n\n  // ():int\n  this.readExpGolomb = function() {\n    var valu = this.readUnsignedExpGolomb(); // :int\n    if (0x01 & valu) {\n      // the number is odd if the low order bit is set\n      return (1 + valu) >>> 1; // add 1 to make it even, and divide by 2\n    }\n    return -1 * (valu >>> 1); // divide by two then make it negative\n  };\n\n  // Some convenience functions\n  // :Boolean\n  this.readBoolean = function() {\n    return this.readBits(1) === 1;\n  };\n\n  // ():int\n  this.readUnsignedByte = function() {\n    return this.readBits(8);\n  };\n\n  this.loadWord();\n};\n\nmodule.exports = ExpGolomb;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdmlkZW9qcy1jb250cmliLW1lZGlhLXNvdXJjZXMvbm9kZV9tb2R1bGVzL211eC5qcy9saWIvdXRpbHMvZXhwLWdvbG9tYi5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSw4QkFBOEI7O0FBRTlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCLCtCQUErQix5Q0FBeUM7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBOztBQUVBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBLDhCQUE4QjtBQUM5Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS12MC1wcm9qZWN0Ly4vbm9kZV9tb2R1bGVzL3ZpZGVvanMtY29udHJpYi1tZWRpYS1zb3VyY2VzL25vZGVfbW9kdWxlcy9tdXguanMvbGliL3V0aWxzL2V4cC1nb2xvbWIuanM/OTg3YSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBFeHBHb2xvbWI7XG5cbi8qKlxuICogUGFyc2VyIGZvciBleHBvbmVudGlhbCBHb2xvbWIgY29kZXMsIGEgdmFyaWFibGUtYml0d2lkdGggbnVtYmVyIGVuY29kaW5nXG4gKiBzY2hlbWUgdXNlZCBieSBoMjY0LlxuICovXG5FeHBHb2xvbWIgPSBmdW5jdGlvbih3b3JraW5nRGF0YSkge1xuICB2YXJcbiAgICAvLyB0aGUgbnVtYmVyIG9mIGJ5dGVzIGxlZnQgdG8gZXhhbWluZSBpbiB3b3JraW5nRGF0YVxuICAgIHdvcmtpbmdCeXRlc0F2YWlsYWJsZSA9IHdvcmtpbmdEYXRhLmJ5dGVMZW5ndGgsXG5cbiAgICAvLyB0aGUgY3VycmVudCB3b3JkIGJlaW5nIGV4YW1pbmVkXG4gICAgd29ya2luZ1dvcmQgPSAwLCAvLyA6dWludFxuXG4gICAgLy8gdGhlIG51bWJlciBvZiBiaXRzIGxlZnQgdG8gZXhhbWluZSBpbiB0aGUgY3VycmVudCB3b3JkXG4gICAgd29ya2luZ0JpdHNBdmFpbGFibGUgPSAwOyAvLyA6dWludDtcblxuICAvLyAoKTp1aW50XG4gIHRoaXMubGVuZ3RoID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICg4ICogd29ya2luZ0J5dGVzQXZhaWxhYmxlKTtcbiAgfTtcblxuICAvLyAoKTp1aW50XG4gIHRoaXMuYml0c0F2YWlsYWJsZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAoOCAqIHdvcmtpbmdCeXRlc0F2YWlsYWJsZSkgKyB3b3JraW5nQml0c0F2YWlsYWJsZTtcbiAgfTtcblxuICAvLyAoKTp2b2lkXG4gIHRoaXMubG9hZFdvcmQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXJcbiAgICAgIHBvc2l0aW9uID0gd29ya2luZ0RhdGEuYnl0ZUxlbmd0aCAtIHdvcmtpbmdCeXRlc0F2YWlsYWJsZSxcbiAgICAgIHdvcmtpbmdCeXRlcyA9IG5ldyBVaW50OEFycmF5KDQpLFxuICAgICAgYXZhaWxhYmxlQnl0ZXMgPSBNYXRoLm1pbig0LCB3b3JraW5nQnl0ZXNBdmFpbGFibGUpO1xuXG4gICAgaWYgKGF2YWlsYWJsZUJ5dGVzID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vIGJ5dGVzIGF2YWlsYWJsZScpO1xuICAgIH1cblxuICAgIHdvcmtpbmdCeXRlcy5zZXQod29ya2luZ0RhdGEuc3ViYXJyYXkocG9zaXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiArIGF2YWlsYWJsZUJ5dGVzKSk7XG4gICAgd29ya2luZ1dvcmQgPSBuZXcgRGF0YVZpZXcod29ya2luZ0J5dGVzLmJ1ZmZlcikuZ2V0VWludDMyKDApO1xuXG4gICAgLy8gdHJhY2sgdGhlIGFtb3VudCBvZiB3b3JraW5nRGF0YSB0aGF0IGhhcyBiZWVuIHByb2Nlc3NlZFxuICAgIHdvcmtpbmdCaXRzQXZhaWxhYmxlID0gYXZhaWxhYmxlQnl0ZXMgKiA4O1xuICAgIHdvcmtpbmdCeXRlc0F2YWlsYWJsZSAtPSBhdmFpbGFibGVCeXRlcztcbiAgfTtcblxuICAvLyAoY291bnQ6aW50KTp2b2lkXG4gIHRoaXMuc2tpcEJpdHMgPSBmdW5jdGlvbihjb3VudCkge1xuICAgIHZhciBza2lwQnl0ZXM7IC8vIDppbnRcbiAgICBpZiAod29ya2luZ0JpdHNBdmFpbGFibGUgPiBjb3VudCkge1xuICAgICAgd29ya2luZ1dvcmQgICAgICAgICAgPDw9IGNvdW50O1xuICAgICAgd29ya2luZ0JpdHNBdmFpbGFibGUgLT0gY291bnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvdW50IC09IHdvcmtpbmdCaXRzQXZhaWxhYmxlO1xuICAgICAgc2tpcEJ5dGVzID0gTWF0aC5mbG9vcihjb3VudCAvIDgpO1xuXG4gICAgICBjb3VudCAtPSAoc2tpcEJ5dGVzICogOCk7XG4gICAgICB3b3JraW5nQnl0ZXNBdmFpbGFibGUgLT0gc2tpcEJ5dGVzO1xuXG4gICAgICB0aGlzLmxvYWRXb3JkKCk7XG5cbiAgICAgIHdvcmtpbmdXb3JkIDw8PSBjb3VudDtcbiAgICAgIHdvcmtpbmdCaXRzQXZhaWxhYmxlIC09IGNvdW50O1xuICAgIH1cbiAgfTtcblxuICAvLyAoc2l6ZTppbnQpOnVpbnRcbiAgdGhpcy5yZWFkQml0cyA9IGZ1bmN0aW9uKHNpemUpIHtcbiAgICB2YXJcbiAgICAgIGJpdHMgPSBNYXRoLm1pbih3b3JraW5nQml0c0F2YWlsYWJsZSwgc2l6ZSksIC8vIDp1aW50XG4gICAgICB2YWx1ID0gd29ya2luZ1dvcmQgPj4+ICgzMiAtIGJpdHMpOyAvLyA6dWludFxuICAgIC8vIGlmIHNpemUgPiAzMSwgaGFuZGxlIGVycm9yXG4gICAgd29ya2luZ0JpdHNBdmFpbGFibGUgLT0gYml0cztcbiAgICBpZiAod29ya2luZ0JpdHNBdmFpbGFibGUgPiAwKSB7XG4gICAgICB3b3JraW5nV29yZCA8PD0gYml0cztcbiAgICB9IGVsc2UgaWYgKHdvcmtpbmdCeXRlc0F2YWlsYWJsZSA+IDApIHtcbiAgICAgIHRoaXMubG9hZFdvcmQoKTtcbiAgICB9XG5cbiAgICBiaXRzID0gc2l6ZSAtIGJpdHM7XG4gICAgaWYgKGJpdHMgPiAwKSB7XG4gICAgICByZXR1cm4gdmFsdSA8PCBiaXRzIHwgdGhpcy5yZWFkQml0cyhiaXRzKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHU7XG4gIH07XG5cbiAgLy8gKCk6dWludFxuICB0aGlzLnNraXBMZWFkaW5nWmVyb3MgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgbGVhZGluZ1plcm9Db3VudDsgLy8gOnVpbnRcbiAgICBmb3IgKGxlYWRpbmdaZXJvQ291bnQgPSAwOyBsZWFkaW5nWmVyb0NvdW50IDwgd29ya2luZ0JpdHNBdmFpbGFibGU7ICsrbGVhZGluZ1plcm9Db3VudCkge1xuICAgICAgaWYgKCh3b3JraW5nV29yZCAmICgweDgwMDAwMDAwID4+PiBsZWFkaW5nWmVyb0NvdW50KSkgIT09IDApIHtcbiAgICAgICAgLy8gdGhlIGZpcnN0IGJpdCBvZiB3b3JraW5nIHdvcmQgaXMgMVxuICAgICAgICB3b3JraW5nV29yZCA8PD0gbGVhZGluZ1plcm9Db3VudDtcbiAgICAgICAgd29ya2luZ0JpdHNBdmFpbGFibGUgLT0gbGVhZGluZ1plcm9Db3VudDtcbiAgICAgICAgcmV0dXJuIGxlYWRpbmdaZXJvQ291bnQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gd2UgZXhoYXVzdGVkIHdvcmtpbmdXb3JkIGFuZCBzdGlsbCBoYXZlIG5vdCBmb3VuZCBhIDFcbiAgICB0aGlzLmxvYWRXb3JkKCk7XG4gICAgcmV0dXJuIGxlYWRpbmdaZXJvQ291bnQgKyB0aGlzLnNraXBMZWFkaW5nWmVyb3MoKTtcbiAgfTtcblxuICAvLyAoKTp2b2lkXG4gIHRoaXMuc2tpcFVuc2lnbmVkRXhwR29sb21iID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5za2lwQml0cygxICsgdGhpcy5za2lwTGVhZGluZ1plcm9zKCkpO1xuICB9O1xuXG4gIC8vICgpOnZvaWRcbiAgdGhpcy5za2lwRXhwR29sb21iID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5za2lwQml0cygxICsgdGhpcy5za2lwTGVhZGluZ1plcm9zKCkpO1xuICB9O1xuXG4gIC8vICgpOnVpbnRcbiAgdGhpcy5yZWFkVW5zaWduZWRFeHBHb2xvbWIgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgY2x6ID0gdGhpcy5za2lwTGVhZGluZ1plcm9zKCk7IC8vIDp1aW50XG4gICAgcmV0dXJuIHRoaXMucmVhZEJpdHMoY2x6ICsgMSkgLSAxO1xuICB9O1xuXG4gIC8vICgpOmludFxuICB0aGlzLnJlYWRFeHBHb2xvbWIgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdmFsdSA9IHRoaXMucmVhZFVuc2lnbmVkRXhwR29sb21iKCk7IC8vIDppbnRcbiAgICBpZiAoMHgwMSAmIHZhbHUpIHtcbiAgICAgIC8vIHRoZSBudW1iZXIgaXMgb2RkIGlmIHRoZSBsb3cgb3JkZXIgYml0IGlzIHNldFxuICAgICAgcmV0dXJuICgxICsgdmFsdSkgPj4+IDE7IC8vIGFkZCAxIHRvIG1ha2UgaXQgZXZlbiwgYW5kIGRpdmlkZSBieSAyXG4gICAgfVxuICAgIHJldHVybiAtMSAqICh2YWx1ID4+PiAxKTsgLy8gZGl2aWRlIGJ5IHR3byB0aGVuIG1ha2UgaXQgbmVnYXRpdmVcbiAgfTtcblxuICAvLyBTb21lIGNvbnZlbmllbmNlIGZ1bmN0aW9uc1xuICAvLyA6Qm9vbGVhblxuICB0aGlzLnJlYWRCb29sZWFuID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucmVhZEJpdHMoMSkgPT09IDE7XG4gIH07XG5cbiAgLy8gKCk6aW50XG4gIHRoaXMucmVhZFVuc2lnbmVkQnl0ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnJlYWRCaXRzKDgpO1xuICB9O1xuXG4gIHRoaXMubG9hZFdvcmQoKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRXhwR29sb21iO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/videojs-contrib-media-sources/node_modules/mux.js/lib/utils/exp-golomb.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/videojs-contrib-media-sources/node_modules/mux.js/lib/utils/stream.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/videojs-contrib-media-sources/node_modules/mux.js/lib/utils/stream.js ***!
  \********************************************************************************************/
/***/ ((module) => {

"use strict";
eval("/**\n * mux.js\n *\n * Copyright (c) 2014 Brightcove\n * All rights reserved.\n *\n * A lightweight readable stream implemention that handles event dispatching.\n * Objects that inherit from streams should call init in their constructors.\n */\n\n\nvar Stream = function() {\n  this.init = function() {\n    var listeners = {};\n    /**\n     * Add a listener for a specified event type.\n     * @param type {string} the event name\n     * @param listener {function} the callback to be invoked when an event of\n     * the specified type occurs\n     */\n    this.on = function(type, listener) {\n      if (!listeners[type]) {\n        listeners[type] = [];\n      }\n      listeners[type] = listeners[type].concat(listener);\n    };\n    /**\n     * Remove a listener for a specified event type.\n     * @param type {string} the event name\n     * @param listener {function} a function previously registered for this\n     * type of event through `on`\n     */\n    this.off = function(type, listener) {\n      var index;\n      if (!listeners[type]) {\n        return false;\n      }\n      index = listeners[type].indexOf(listener);\n      listeners[type] = listeners[type].slice();\n      listeners[type].splice(index, 1);\n      return index > -1;\n    };\n    /**\n     * Trigger an event of the specified type on this stream. Any additional\n     * arguments to this function are passed as parameters to event listeners.\n     * @param type {string} the event name\n     */\n    this.trigger = function(type) {\n      var callbacks, i, length, args;\n      callbacks = listeners[type];\n      if (!callbacks) {\n        return;\n      }\n      // Slicing the arguments on every invocation of this method\n      // can add a significant amount of overhead. Avoid the\n      // intermediate object creation for the common case of a\n      // single callback argument\n      if (arguments.length === 2) {\n        length = callbacks.length;\n        for (i = 0; i < length; ++i) {\n          callbacks[i].call(this, arguments[1]);\n        }\n      } else {\n        args = [];\n        i = arguments.length;\n        for (i = 1; i < arguments.length; ++i) {\n          args.push(arguments[i]);\n        }\n        length = callbacks.length;\n        for (i = 0; i < length; ++i) {\n          callbacks[i].apply(this, args);\n        }\n      }\n    };\n    /**\n     * Destroys the stream and cleans up.\n     */\n    this.dispose = function() {\n      listeners = {};\n    };\n  };\n};\n\n/**\n * Forwards all `data` events on this stream to the destination stream. The\n * destination stream should provide a method `push` to receive the data\n * events as they arrive.\n * @param destination {stream} the stream that will receive all `data` events\n * @param autoFlush {boolean} if false, we will not call `flush` on the destination\n *                            when the current stream emits a 'done' event\n * @see http://nodejs.org/api/stream.html#stream_readable_pipe_destination_options\n */\nStream.prototype.pipe = function(destination) {\n  this.on('data', function(data) {\n    destination.push(data);\n  });\n\n  this.on('done', function(flushSource) {\n    destination.flush(flushSource);\n  });\n\n  return destination;\n};\n\n// Default stream functions that are expected to be overridden to perform\n// actual work. These are provided by the prototype as a sort of no-op\n// implementation so that we don't have to check for their existence in the\n// `pipe` function above.\nStream.prototype.push = function(data) {\n  this.trigger('data', data);\n};\n\nStream.prototype.flush = function(flushSource) {\n  this.trigger('done', flushSource);\n};\n\nmodule.exports = Stream;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdmlkZW9qcy1jb250cmliLW1lZGlhLXNvdXJjZXMvbm9kZV9tb2R1bGVzL211eC5qcy9saWIvdXRpbHMvc3RyZWFtLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1Qix3QkFBd0IsVUFBVTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCLHdCQUF3QixVQUFVO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFlBQVk7QUFDaEM7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsWUFBWTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsUUFBUTtBQUMvQixxQkFBcUIsU0FBUztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktdjAtcHJvamVjdC8uL25vZGVfbW9kdWxlcy92aWRlb2pzLWNvbnRyaWItbWVkaWEtc291cmNlcy9ub2RlX21vZHVsZXMvbXV4LmpzL2xpYi91dGlscy9zdHJlYW0uanM/NTlhNCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIG11eC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNCBCcmlnaHRjb3ZlXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIEEgbGlnaHR3ZWlnaHQgcmVhZGFibGUgc3RyZWFtIGltcGxlbWVudGlvbiB0aGF0IGhhbmRsZXMgZXZlbnQgZGlzcGF0Y2hpbmcuXG4gKiBPYmplY3RzIHRoYXQgaW5oZXJpdCBmcm9tIHN0cmVhbXMgc2hvdWxkIGNhbGwgaW5pdCBpbiB0aGVpciBjb25zdHJ1Y3RvcnMuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIFN0cmVhbSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmluaXQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgbGlzdGVuZXJzID0ge307XG4gICAgLyoqXG4gICAgICogQWRkIGEgbGlzdGVuZXIgZm9yIGEgc3BlY2lmaWVkIGV2ZW50IHR5cGUuXG4gICAgICogQHBhcmFtIHR5cGUge3N0cmluZ30gdGhlIGV2ZW50IG5hbWVcbiAgICAgKiBAcGFyYW0gbGlzdGVuZXIge2Z1bmN0aW9ufSB0aGUgY2FsbGJhY2sgdG8gYmUgaW52b2tlZCB3aGVuIGFuIGV2ZW50IG9mXG4gICAgICogdGhlIHNwZWNpZmllZCB0eXBlIG9jY3Vyc1xuICAgICAqL1xuICAgIHRoaXMub24gPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgaWYgKCFsaXN0ZW5lcnNbdHlwZV0pIHtcbiAgICAgICAgbGlzdGVuZXJzW3R5cGVdID0gW107XG4gICAgICB9XG4gICAgICBsaXN0ZW5lcnNbdHlwZV0gPSBsaXN0ZW5lcnNbdHlwZV0uY29uY2F0KGxpc3RlbmVyKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhIGxpc3RlbmVyIGZvciBhIHNwZWNpZmllZCBldmVudCB0eXBlLlxuICAgICAqIEBwYXJhbSB0eXBlIHtzdHJpbmd9IHRoZSBldmVudCBuYW1lXG4gICAgICogQHBhcmFtIGxpc3RlbmVyIHtmdW5jdGlvbn0gYSBmdW5jdGlvbiBwcmV2aW91c2x5IHJlZ2lzdGVyZWQgZm9yIHRoaXNcbiAgICAgKiB0eXBlIG9mIGV2ZW50IHRocm91Z2ggYG9uYFxuICAgICAqL1xuICAgIHRoaXMub2ZmID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIHZhciBpbmRleDtcbiAgICAgIGlmICghbGlzdGVuZXJzW3R5cGVdKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGluZGV4ID0gbGlzdGVuZXJzW3R5cGVdLmluZGV4T2YobGlzdGVuZXIpO1xuICAgICAgbGlzdGVuZXJzW3R5cGVdID0gbGlzdGVuZXJzW3R5cGVdLnNsaWNlKCk7XG4gICAgICBsaXN0ZW5lcnNbdHlwZV0uc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgIHJldHVybiBpbmRleCA+IC0xO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVHJpZ2dlciBhbiBldmVudCBvZiB0aGUgc3BlY2lmaWVkIHR5cGUgb24gdGhpcyBzdHJlYW0uIEFueSBhZGRpdGlvbmFsXG4gICAgICogYXJndW1lbnRzIHRvIHRoaXMgZnVuY3Rpb24gYXJlIHBhc3NlZCBhcyBwYXJhbWV0ZXJzIHRvIGV2ZW50IGxpc3RlbmVycy5cbiAgICAgKiBAcGFyYW0gdHlwZSB7c3RyaW5nfSB0aGUgZXZlbnQgbmFtZVxuICAgICAqL1xuICAgIHRoaXMudHJpZ2dlciA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgIHZhciBjYWxsYmFja3MsIGksIGxlbmd0aCwgYXJncztcbiAgICAgIGNhbGxiYWNrcyA9IGxpc3RlbmVyc1t0eXBlXTtcbiAgICAgIGlmICghY2FsbGJhY2tzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIFNsaWNpbmcgdGhlIGFyZ3VtZW50cyBvbiBldmVyeSBpbnZvY2F0aW9uIG9mIHRoaXMgbWV0aG9kXG4gICAgICAvLyBjYW4gYWRkIGEgc2lnbmlmaWNhbnQgYW1vdW50IG9mIG92ZXJoZWFkLiBBdm9pZCB0aGVcbiAgICAgIC8vIGludGVybWVkaWF0ZSBvYmplY3QgY3JlYXRpb24gZm9yIHRoZSBjb21tb24gY2FzZSBvZiBhXG4gICAgICAvLyBzaW5nbGUgY2FsbGJhY2sgYXJndW1lbnRcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgICAgIGxlbmd0aCA9IGNhbGxiYWNrcy5sZW5ndGg7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgICAgICAgIGNhbGxiYWNrc1tpXS5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFyZ3MgPSBbXTtcbiAgICAgICAgaSA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgIGZvciAoaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBhcmdzLnB1c2goYXJndW1lbnRzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICBsZW5ndGggPSBjYWxsYmFja3MubGVuZ3RoO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBjYWxsYmFja3NbaV0uYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIERlc3Ryb3lzIHRoZSBzdHJlYW0gYW5kIGNsZWFucyB1cC5cbiAgICAgKi9cbiAgICB0aGlzLmRpc3Bvc2UgPSBmdW5jdGlvbigpIHtcbiAgICAgIGxpc3RlbmVycyA9IHt9O1xuICAgIH07XG4gIH07XG59O1xuXG4vKipcbiAqIEZvcndhcmRzIGFsbCBgZGF0YWAgZXZlbnRzIG9uIHRoaXMgc3RyZWFtIHRvIHRoZSBkZXN0aW5hdGlvbiBzdHJlYW0uIFRoZVxuICogZGVzdGluYXRpb24gc3RyZWFtIHNob3VsZCBwcm92aWRlIGEgbWV0aG9kIGBwdXNoYCB0byByZWNlaXZlIHRoZSBkYXRhXG4gKiBldmVudHMgYXMgdGhleSBhcnJpdmUuXG4gKiBAcGFyYW0gZGVzdGluYXRpb24ge3N0cmVhbX0gdGhlIHN0cmVhbSB0aGF0IHdpbGwgcmVjZWl2ZSBhbGwgYGRhdGFgIGV2ZW50c1xuICogQHBhcmFtIGF1dG9GbHVzaCB7Ym9vbGVhbn0gaWYgZmFsc2UsIHdlIHdpbGwgbm90IGNhbGwgYGZsdXNoYCBvbiB0aGUgZGVzdGluYXRpb25cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoZW4gdGhlIGN1cnJlbnQgc3RyZWFtIGVtaXRzIGEgJ2RvbmUnIGV2ZW50XG4gKiBAc2VlIGh0dHA6Ly9ub2RlanMub3JnL2FwaS9zdHJlYW0uaHRtbCNzdHJlYW1fcmVhZGFibGVfcGlwZV9kZXN0aW5hdGlvbl9vcHRpb25zXG4gKi9cblN0cmVhbS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uKGRlc3RpbmF0aW9uKSB7XG4gIHRoaXMub24oJ2RhdGEnLCBmdW5jdGlvbihkYXRhKSB7XG4gICAgZGVzdGluYXRpb24ucHVzaChkYXRhKTtcbiAgfSk7XG5cbiAgdGhpcy5vbignZG9uZScsIGZ1bmN0aW9uKGZsdXNoU291cmNlKSB7XG4gICAgZGVzdGluYXRpb24uZmx1c2goZmx1c2hTb3VyY2UpO1xuICB9KTtcblxuICByZXR1cm4gZGVzdGluYXRpb247XG59O1xuXG4vLyBEZWZhdWx0IHN0cmVhbSBmdW5jdGlvbnMgdGhhdCBhcmUgZXhwZWN0ZWQgdG8gYmUgb3ZlcnJpZGRlbiB0byBwZXJmb3JtXG4vLyBhY3R1YWwgd29yay4gVGhlc2UgYXJlIHByb3ZpZGVkIGJ5IHRoZSBwcm90b3R5cGUgYXMgYSBzb3J0IG9mIG5vLW9wXG4vLyBpbXBsZW1lbnRhdGlvbiBzbyB0aGF0IHdlIGRvbid0IGhhdmUgdG8gY2hlY2sgZm9yIHRoZWlyIGV4aXN0ZW5jZSBpbiB0aGVcbi8vIGBwaXBlYCBmdW5jdGlvbiBhYm92ZS5cblN0cmVhbS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgdGhpcy50cmlnZ2VyKCdkYXRhJywgZGF0YSk7XG59O1xuXG5TdHJlYW0ucHJvdG90eXBlLmZsdXNoID0gZnVuY3Rpb24oZmx1c2hTb3VyY2UpIHtcbiAgdGhpcy50cmlnZ2VyKCdkb25lJywgZmx1c2hTb3VyY2UpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTdHJlYW07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/videojs-contrib-media-sources/node_modules/mux.js/lib/utils/stream.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/videojs-contrib-media-sources/node_modules/video.js/dist/video.cjs.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/videojs-contrib-media-sources/node_modules/video.js/dist/video.cjs.js ***!
  \********************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * @license\n * Video.js 6.13.0 <http://videojs.com/>\n * Copyright Brightcove, Inc. <https://www.brightcove.com/>\n * Available under Apache License Version 2.0\n * <https://github.com/videojs/video.js/blob/master/LICENSE>\n *\n * Includes vtt.js <https://github.com/mozilla/vtt.js>\n * Available under Apache License Version 2.0\n * <https://github.com/mozilla/vtt.js/blob/master/LICENSE>\n */\n\nfunction _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }\n\nvar window = _interopDefault(__webpack_require__(/*! global/window */ \"(ssr)/./node_modules/videojs-contrib-media-sources/node_modules/global/window.js\"));\nvar document = _interopDefault(__webpack_require__(/*! global/document */ \"(ssr)/./node_modules/videojs-contrib-media-sources/node_modules/global/document.js\"));\nvar tsml = _interopDefault(__webpack_require__(/*! tsml */ \"(ssr)/./node_modules/tsml/tsml.js\"));\nvar safeParseTuple = _interopDefault(__webpack_require__(/*! safe-json-parse/tuple */ \"(ssr)/./node_modules/safe-json-parse/tuple.js\"));\nvar xhr = _interopDefault(__webpack_require__(/*! xhr */ \"(ssr)/./node_modules/xhr/index.js\"));\nvar vtt = _interopDefault(__webpack_require__(/*! videojs-vtt.js */ \"(ssr)/./node_modules/videojs-contrib-media-sources/node_modules/videojs-vtt.js/lib/browser-index.js\"));\n\nvar version = \"6.13.0\";\n\n/**\n * @file browser.js\n * @module browser\n */\nvar USER_AGENT = window.navigator && window.navigator.userAgent || '';\nvar webkitVersionMap = /AppleWebKit\\/([\\d.]+)/i.exec(USER_AGENT);\nvar appleWebkitVersion = webkitVersionMap ? parseFloat(webkitVersionMap.pop()) : null;\n\n/*\n * Device is an iPhone\n *\n * @type {Boolean}\n * @constant\n * @private\n */\nvar IS_IPAD = /iPad/i.test(USER_AGENT);\n\n// The Facebook app's UIWebView identifies as both an iPhone and iPad, so\n// to identify iPhones, we need to exclude iPads.\n// http://artsy.github.io/blog/2012/10/18/the-perils-of-ios-user-agent-sniffing/\nvar IS_IPHONE = /iPhone/i.test(USER_AGENT) && !IS_IPAD;\nvar IS_IPOD = /iPod/i.test(USER_AGENT);\nvar IS_IOS = IS_IPHONE || IS_IPAD || IS_IPOD;\n\nvar IOS_VERSION = function () {\n  var match = USER_AGENT.match(/OS (\\d+)_/i);\n\n  if (match && match[1]) {\n    return match[1];\n  }\n  return null;\n}();\n\nvar IS_ANDROID = /Android/i.test(USER_AGENT);\nvar ANDROID_VERSION = function () {\n  // This matches Android Major.Minor.Patch versions\n  // ANDROID_VERSION is Major.Minor as a Number, if Minor isn't available, then only Major is returned\n  var match = USER_AGENT.match(/Android (\\d+)(?:\\.(\\d+))?(?:\\.(\\d+))*/i);\n\n  if (!match) {\n    return null;\n  }\n\n  var major = match[1] && parseFloat(match[1]);\n  var minor = match[2] && parseFloat(match[2]);\n\n  if (major && minor) {\n    return parseFloat(match[1] + '.' + match[2]);\n  } else if (major) {\n    return major;\n  }\n  return null;\n}();\n\n// Old Android is defined as Version older than 2.3, and requiring a webkit version of the android browser\nvar IS_OLD_ANDROID = IS_ANDROID && /webkit/i.test(USER_AGENT) && ANDROID_VERSION < 2.3;\nvar IS_NATIVE_ANDROID = IS_ANDROID && ANDROID_VERSION < 5 && appleWebkitVersion < 537;\n\nvar IS_FIREFOX = /Firefox/i.test(USER_AGENT);\nvar IS_EDGE = /Edge/i.test(USER_AGENT);\nvar IS_CHROME = !IS_EDGE && (/Chrome/i.test(USER_AGENT) || /CriOS/i.test(USER_AGENT));\nvar CHROME_VERSION = function () {\n  var match = USER_AGENT.match(/(Chrome|CriOS)\\/(\\d+)/);\n\n  if (match && match[2]) {\n    return parseFloat(match[2]);\n  }\n  return null;\n}();\nvar IS_IE8 = /MSIE\\s8\\.0/.test(USER_AGENT);\nvar IE_VERSION = function () {\n  var result = /MSIE\\s(\\d+)\\.\\d/.exec(USER_AGENT);\n  var version = result && parseFloat(result[1]);\n\n  if (!version && /Trident\\/7.0/i.test(USER_AGENT) && /rv:11.0/.test(USER_AGENT)) {\n    // IE 11 has a different user agent string than other IE versions\n    version = 11.0;\n  }\n\n  return version;\n}();\n\nvar IS_SAFARI = /Safari/i.test(USER_AGENT) && !IS_CHROME && !IS_ANDROID && !IS_EDGE;\nvar IS_ANY_SAFARI = (IS_SAFARI || IS_IOS) && !IS_CHROME;\n\nvar TOUCH_ENABLED = isReal() && ('ontouchstart' in window || window.navigator.maxTouchPoints || window.DocumentTouch && window.document instanceof window.DocumentTouch);\n\nvar BACKGROUND_SIZE_SUPPORTED = isReal() && 'backgroundSize' in window.document.createElement('video').style;\n\nvar browser = (Object.freeze || Object)({\n\tIS_IPAD: IS_IPAD,\n\tIS_IPHONE: IS_IPHONE,\n\tIS_IPOD: IS_IPOD,\n\tIS_IOS: IS_IOS,\n\tIOS_VERSION: IOS_VERSION,\n\tIS_ANDROID: IS_ANDROID,\n\tANDROID_VERSION: ANDROID_VERSION,\n\tIS_OLD_ANDROID: IS_OLD_ANDROID,\n\tIS_NATIVE_ANDROID: IS_NATIVE_ANDROID,\n\tIS_FIREFOX: IS_FIREFOX,\n\tIS_EDGE: IS_EDGE,\n\tIS_CHROME: IS_CHROME,\n\tCHROME_VERSION: CHROME_VERSION,\n\tIS_IE8: IS_IE8,\n\tIE_VERSION: IE_VERSION,\n\tIS_SAFARI: IS_SAFARI,\n\tIS_ANY_SAFARI: IS_ANY_SAFARI,\n\tTOUCH_ENABLED: TOUCH_ENABLED,\n\tBACKGROUND_SIZE_SUPPORTED: BACKGROUND_SIZE_SUPPORTED\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\n\n\n\n\n\n\n\n\n\n\nvar classCallCheck = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\n\n\n\n\n\n\n\n\n\n\nvar inherits = function (subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n};\n\n\n\n\n\n\n\n\n\n\n\nvar possibleConstructorReturn = function (self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n};\n\n\n\n\n\n\n\n\n\n\n\nvar taggedTemplateLiteralLoose = function (strings, raw) {\n  strings.raw = raw;\n  return strings;\n};\n\n/**\n * @file obj.js\n * @module obj\n */\n\n/**\n * @callback obj:EachCallback\n *\n * @param {Mixed} value\n *        The current key for the object that is being iterated over.\n *\n * @param {string} key\n *        The current key-value for object that is being iterated over\n */\n\n/**\n * @callback obj:ReduceCallback\n *\n * @param {Mixed} accum\n *        The value that is accumulating over the reduce loop.\n *\n * @param {Mixed} value\n *        The current key for the object that is being iterated over.\n *\n * @param {string} key\n *        The current key-value for object that is being iterated over\n *\n * @return {Mixed}\n *         The new accumulated value.\n */\nvar toString = Object.prototype.toString;\n\n/**\n * Get the keys of an Object\n *\n * @param {Object}\n *        The Object to get the keys from\n *\n * @return {string[]}\n *         An array of the keys from the object. Returns an empty array if the\n *         object passed in was invalid or had no keys.\n *\n * @private\n */\nvar keys = function keys(object) {\n  return isObject(object) ? Object.keys(object) : [];\n};\n\n/**\n * Array-like iteration for objects.\n *\n * @param {Object} object\n *        The object to iterate over\n *\n * @param {obj:EachCallback} fn\n *        The callback function which is called for each key in the object.\n */\nfunction each(object, fn) {\n  keys(object).forEach(function (key) {\n    return fn(object[key], key);\n  });\n}\n\n/**\n * Array-like reduce for objects.\n *\n * @param {Object} object\n *        The Object that you want to reduce.\n *\n * @param {Function} fn\n *         A callback function which is called for each key in the object. It\n *         receives the accumulated value and the per-iteration value and key\n *         as arguments.\n *\n * @param {Mixed} [initial = 0]\n *        Starting value\n *\n * @return {Mixed}\n *         The final accumulated value.\n */\nfunction reduce(object, fn) {\n  var initial = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\n  return keys(object).reduce(function (accum, key) {\n    return fn(accum, object[key], key);\n  }, initial);\n}\n\n/**\n * Object.assign-style object shallow merge/extend.\n *\n * @param  {Object} target\n * @param  {Object} ...sources\n * @return {Object}\n */\nfunction assign(target) {\n  for (var _len = arguments.length, sources = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    sources[_key - 1] = arguments[_key];\n  }\n\n  if (Object.assign) {\n    return Object.assign.apply(Object, [target].concat(sources));\n  }\n\n  sources.forEach(function (source) {\n    if (!source) {\n      return;\n    }\n\n    each(source, function (value, key) {\n      target[key] = value;\n    });\n  });\n\n  return target;\n}\n\n/**\n * Returns whether a value is an object of any kind - including DOM nodes,\n * arrays, regular expressions, etc. Not functions, though.\n *\n * This avoids the gotcha where using `typeof` on a `null` value\n * results in `'object'`.\n *\n * @param  {Object} value\n * @return {Boolean}\n */\nfunction isObject(value) {\n  return !!value && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object';\n}\n\n/**\n * Returns whether an object appears to be a \"plain\" object - that is, a\n * direct instance of `Object`.\n *\n * @param  {Object} value\n * @return {Boolean}\n */\nfunction isPlain(value) {\n  return isObject(value) && toString.call(value) === '[object Object]' && value.constructor === Object;\n}\n\n/**\n * @file create-logger.js\n * @module create-logger\n */\n// This is the private tracking variable for the logging history.\nvar history = [];\n\n/**\n * Log messages to the console and history based on the type of message\n *\n * @private\n * @param  {string} type\n *         The name of the console method to use.\n *\n * @param  {Array} args\n *         The arguments to be passed to the matching console method.\n */\nvar LogByTypeFactory = function LogByTypeFactory(name, log) {\n  return function (type, level, args, stringify) {\n    var lvl = log.levels[level];\n    var lvlRegExp = new RegExp('^(' + lvl + ')$');\n\n    if (type !== 'log') {\n\n      // Add the type to the front of the message when it's not \"log\".\n      args.unshift(type.toUpperCase() + ':');\n    }\n\n    // Add console prefix after adding to history.\n    args.unshift(name + ':');\n\n    // Add a clone of the args at this point to history.\n    if (history) {\n      history.push([].concat(args));\n    }\n\n    // If there's no console then don't try to output messages, but they will\n    // still be stored in history.\n    if (!window.console) {\n      return;\n    }\n\n    // Was setting these once outside of this function, but containing them\n    // in the function makes it easier to test cases where console doesn't exist\n    // when the module is executed.\n    var fn = window.console[type];\n\n    if (!fn && type === 'debug') {\n      // Certain browsers don't have support for console.debug. For those, we\n      // should default to the closest comparable log.\n      fn = window.console.info || window.console.log;\n    }\n\n    // Bail out if there's no console or if this type is not allowed by the\n    // current logging level.\n    if (!fn || !lvl || !lvlRegExp.test(type)) {\n      return;\n    }\n\n    // IEs previous to 11 log objects uselessly as \"[object Object]\"; so, JSONify\n    // objects and arrays for those less-capable browsers.\n    if (stringify) {\n      args = args.map(function (a) {\n        if (isObject(a) || Array.isArray(a)) {\n          try {\n            return JSON.stringify(a);\n          } catch (x) {\n            return String(a);\n          }\n        }\n\n        // Cast to string before joining, so we get null and undefined explicitly\n        // included in output (as we would in a modern console).\n        return String(a);\n      }).join(' ');\n    }\n\n    // Old IE versions do not allow .apply() for console methods (they are\n    // reported as objects rather than functions).\n    if (!fn.apply) {\n      fn(args);\n    } else {\n      fn[Array.isArray(args) ? 'apply' : 'call'](window.console, args);\n    }\n  };\n};\n\nfunction createLogger$1(name) {\n  // This is the private tracking variable for logging level.\n  var level = 'info';\n\n  // the curried logByType bound to the specific log and history\n  var logByType = void 0;\n\n  /**\n   * Logs plain debug messages. Similar to `console.log`.\n   *\n   * Due to [limitations](https://github.com/jsdoc3/jsdoc/issues/955#issuecomment-313829149)\n   * of our JSDoc template, we cannot properly document this as both a function\n   * and a namespace, so its function signature is documented here.\n   *\n   * #### Arguments\n   * ##### *args\n   * Mixed[]\n   *\n   * Any combination of values that could be passed to `console.log()`.\n   *\n   * #### Return Value\n   *\n   * `undefined`\n   *\n   * @namespace\n   * @param    {Mixed[]} args\n   *           One or more messages or objects that should be logged.\n   */\n  var log = function log() {\n    var stringify = log.stringify || IE_VERSION && IE_VERSION < 11;\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    logByType('log', level, args, stringify);\n  };\n\n  // This is the logByType helper that the logging methods below use\n  logByType = LogByTypeFactory(name, log);\n\n  /**\n   * Create a new sublogger which chains the old name to the new name.\n   *\n   * For example, doing `videojs.log.createLogger('player')` and then using that logger will log the following:\n   * ```js\n   *  mylogger('foo');\n   *  // > VIDEOJS: player: foo\n   * ```\n   *\n   * @param {string} name\n   *        The name to add call the new logger\n   * @return {Object}\n   */\n  log.createLogger = function (subname) {\n    return createLogger$1(name + ': ' + subname);\n  };\n\n  /**\n   * Enumeration of available logging levels, where the keys are the level names\n   * and the values are `|`-separated strings containing logging methods allowed\n   * in that logging level. These strings are used to create a regular expression\n   * matching the function name being called.\n   *\n   * Levels provided by Video.js are:\n   *\n   * - `off`: Matches no calls. Any value that can be cast to `false` will have\n   *   this effect. The most restrictive.\n   * - `all`: Matches only Video.js-provided functions (`debug`, `log`,\n   *   `log.warn`, and `log.error`).\n   * - `debug`: Matches `log.debug`, `log`, `log.warn`, and `log.error` calls.\n   * - `info` (default): Matches `log`, `log.warn`, and `log.error` calls.\n   * - `warn`: Matches `log.warn` and `log.error` calls.\n   * - `error`: Matches only `log.error` calls.\n   *\n   * @type {Object}\n   */\n  log.levels = {\n    all: 'debug|log|warn|error',\n    off: '',\n    debug: 'debug|log|warn|error',\n    info: 'log|warn|error',\n    warn: 'warn|error',\n    error: 'error',\n    DEFAULT: level\n  };\n\n  /**\n   * Get or set the current logging level.\n   *\n   * If a string matching a key from {@link module:log.levels} is provided, acts\n   * as a setter.\n   *\n   * @param  {string} [lvl]\n   *         Pass a valid level to set a new logging level.\n   *\n   * @return {string}\n   *         The current logging level.\n   */\n  log.level = function (lvl) {\n    if (typeof lvl === 'string') {\n      if (!log.levels.hasOwnProperty(lvl)) {\n        throw new Error('\"' + lvl + '\" in not a valid log level');\n      }\n      level = lvl;\n    }\n    return level;\n  };\n\n  /**\n   * Returns an array containing everything that has been logged to the history.\n   *\n   * This array is a shallow clone of the internal history record. However, its\n   * contents are _not_ cloned; so, mutating objects inside this array will\n   * mutate them in history.\n   *\n   * @return {Array}\n   */\n  log.history = function () {\n    return history ? [].concat(history) : [];\n  };\n\n  /**\n   * Allows you to filter the history by the given logger name\n   *\n   * @param {string} fname\n   *        The name to filter by\n   *\n   * @return {Array}\n   *         The filtered list to return\n   */\n  log.history.filter = function (fname) {\n    return (history || []).filter(function (historyItem) {\n      // if the first item in each historyItem includes `fname`, then it's a match\n      return new RegExp('.*' + fname + '.*').test(historyItem[0]);\n    });\n  };\n\n  /**\n   * Clears the internal history tracking, but does not prevent further history\n   * tracking.\n   */\n  log.history.clear = function () {\n    if (history) {\n      history.length = 0;\n    }\n  };\n\n  /**\n   * Disable history tracking if it is currently enabled.\n   */\n  log.history.disable = function () {\n    if (history !== null) {\n      history.length = 0;\n      history = null;\n    }\n  };\n\n  /**\n   * Enable history tracking if it is currently disabled.\n   */\n  log.history.enable = function () {\n    if (history === null) {\n      history = [];\n    }\n  };\n\n  /**\n   * Logs error messages. Similar to `console.error`.\n   *\n   * @param {Mixed[]} args\n   *        One or more messages or objects that should be logged as an error\n   */\n  log.error = function () {\n    for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n\n    return logByType('error', level, args);\n  };\n\n  /**\n   * Logs warning messages. Similar to `console.warn`.\n   *\n   * @param {Mixed[]} args\n   *        One or more messages or objects that should be logged as a warning.\n   */\n  log.warn = function () {\n    for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      args[_key3] = arguments[_key3];\n    }\n\n    return logByType('warn', level, args);\n  };\n\n  /**\n   * Logs debug messages. Similar to `console.debug`, but may also act as a comparable\n   * log if `console.debug` is not available\n   *\n   * @param {Mixed[]} args\n   *        One or more messages or objects that should be logged as debug.\n   */\n  log.debug = function () {\n    for (var _len4 = arguments.length, args = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n      args[_key4] = arguments[_key4];\n    }\n\n    return logByType('debug', level, args);\n  };\n\n  return log;\n}\n\n/**\n * @file log.js\n * @module log\n */\nvar log = createLogger$1('VIDEOJS');\nvar createLogger = log.createLogger;\n\n/**\n * @file computed-style.js\n * @module computed-style\n */\n/**\n * A safe getComputedStyle with an IE8 fallback.\n *\n * This is needed because in Firefox, if the player is loaded in an iframe with\n * `display:none`, then `getComputedStyle` returns `null`, so, we do a null-check to\n * make sure  that the player doesn't break in these cases.\n *\n * @param {Element} el\n *        The element you want the computed style of\n *\n * @param {string} prop\n *        The property name you want\n *\n * @see https://bugzilla.mozilla.org/show_bug.cgi?id=548397\n *\n * @static\n * @const\n */\nfunction computedStyle(el, prop) {\n  if (!el || !prop) {\n    return '';\n  }\n\n  if (typeof window.getComputedStyle === 'function') {\n    var cs = window.getComputedStyle(el);\n\n    return cs ? cs[prop] : '';\n  }\n\n  return el.currentStyle[prop] || '';\n}\n\nvar _templateObject = taggedTemplateLiteralLoose(['Setting attributes in the second argument of createEl()\\n                has been deprecated. Use the third argument instead.\\n                createEl(type, properties, attributes). Attempting to set ', ' to ', '.'], ['Setting attributes in the second argument of createEl()\\n                has been deprecated. Use the third argument instead.\\n                createEl(type, properties, attributes). Attempting to set ', ' to ', '.']);\n\n/**\n * @file dom.js\n * @module dom\n */\n/**\n * Detect if a value is a string with any non-whitespace characters.\n *\n * @param {string} str\n *        The string to check\n *\n * @return {boolean}\n *         - True if the string is non-blank\n *         - False otherwise\n *\n */\nfunction isNonBlankString(str) {\n  return typeof str === 'string' && /\\S/.test(str);\n}\n\n/**\n * Throws an error if the passed string has whitespace. This is used by\n * class methods to be relatively consistent with the classList API.\n *\n * @param {string} str\n *         The string to check for whitespace.\n *\n * @throws {Error}\n *         Throws an error if there is whitespace in the string.\n *\n */\nfunction throwIfWhitespace(str) {\n  if (/\\s/.test(str)) {\n    throw new Error('class has illegal whitespace characters');\n  }\n}\n\n/**\n * Produce a regular expression for matching a className within an elements className.\n *\n * @param {string} className\n *         The className to generate the RegExp for.\n *\n * @return {RegExp}\n *         The RegExp that will check for a specific `className` in an elements\n *         className.\n */\nfunction classRegExp(className) {\n  return new RegExp('(^|\\\\s)' + className + '($|\\\\s)');\n}\n\n/**\n * Whether the current DOM interface appears to be real.\n *\n * @return {Boolean}\n */\nfunction isReal() {\n  return (\n\n    // Both document and window will never be undefined thanks to `global`.\n    document === window.document &&\n\n    // In IE < 9, DOM methods return \"object\" as their type, so all we can\n    // confidently check is that it exists.\n    typeof document.createElement !== 'undefined'\n  );\n}\n\n/**\n * Determines, via duck typing, whether or not a value is a DOM element.\n *\n * @param {Mixed} value\n *        The thing to check\n *\n * @return {boolean}\n *         - True if it is a DOM element\n *         - False otherwise\n */\nfunction isEl(value) {\n  return isObject(value) && value.nodeType === 1;\n}\n\n/**\n * Determines if the current DOM is embedded in an iframe.\n *\n * @return {boolean}\n *\n */\nfunction isInFrame() {\n\n  // We need a try/catch here because Safari will throw errors when attempting\n  // to get either `parent` or `self`\n  try {\n    return window.parent !== window.self;\n  } catch (x) {\n    return true;\n  }\n}\n\n/**\n * Creates functions to query the DOM using a given method.\n *\n * @param {string} method\n *         The method to create the query with.\n *\n * @return {Function}\n *         The query method\n */\nfunction createQuerier(method) {\n  return function (selector, context) {\n    if (!isNonBlankString(selector)) {\n      return document[method](null);\n    }\n    if (isNonBlankString(context)) {\n      context = document.querySelector(context);\n    }\n\n    var ctx = isEl(context) ? context : document;\n\n    return ctx[method] && ctx[method](selector);\n  };\n}\n\n/**\n * Creates an element and applies properties.\n *\n * @param {string} [tagName='div']\n *         Name of tag to be created.\n *\n * @param {Object} [properties={}]\n *         Element properties to be applied.\n *\n * @param {Object} [attributes={}]\n *         Element attributes to be applied.\n *\n * @param {String|Element|TextNode|Array|Function} [content]\n *         Contents for the element (see: {@link dom:normalizeContent})\n *\n * @return {Element}\n *         The element that was created.\n */\nfunction createEl() {\n  var tagName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'div';\n  var properties = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var attributes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var content = arguments[3];\n\n  var el = document.createElement(tagName);\n\n  Object.getOwnPropertyNames(properties).forEach(function (propName) {\n    var val = properties[propName];\n\n    // See #2176\n    // We originally were accepting both properties and attributes in the\n    // same object, but that doesn't work so well.\n    if (propName.indexOf('aria-') !== -1 || propName === 'role' || propName === 'type') {\n      log.warn(tsml(_templateObject, propName, val));\n      el.setAttribute(propName, val);\n\n      // Handle textContent since it's not supported everywhere and we have a\n      // method for it.\n    } else if (propName === 'textContent') {\n      textContent(el, val);\n    } else {\n      el[propName] = val;\n    }\n  });\n\n  Object.getOwnPropertyNames(attributes).forEach(function (attrName) {\n    el.setAttribute(attrName, attributes[attrName]);\n  });\n\n  if (content) {\n    appendContent(el, content);\n  }\n\n  return el;\n}\n\n/**\n * Injects text into an element, replacing any existing contents entirely.\n *\n * @param {Element} el\n *        The element to add text content into\n *\n * @param {string} text\n *        The text content to add.\n *\n * @return {Element}\n *         The element with added text content.\n */\nfunction textContent(el, text) {\n  if (typeof el.textContent === 'undefined') {\n    el.innerText = text;\n  } else {\n    el.textContent = text;\n  }\n  return el;\n}\n\n/**\n * Insert an element as the first child node of another\n *\n * @param {Element} child\n *        Element to insert\n *\n * @param {Element} parent\n *        Element to insert child into\n */\nfunction prependTo(child, parent) {\n  if (parent.firstChild) {\n    parent.insertBefore(child, parent.firstChild);\n  } else {\n    parent.appendChild(child);\n  }\n}\n\n/**\n * Check if an element has a CSS class\n *\n * @param {Element} element\n *        Element to check\n *\n * @param {string} classToCheck\n *        Class name to check for\n *\n * @return {boolean}\n *         - True if the element had the class\n *         - False otherwise.\n *\n * @throws {Error}\n *         Throws an error if `classToCheck` has white space.\n */\nfunction hasClass(element, classToCheck) {\n  throwIfWhitespace(classToCheck);\n  if (element.classList) {\n    return element.classList.contains(classToCheck);\n  }\n  return classRegExp(classToCheck).test(element.className);\n}\n\n/**\n * Add a CSS class name to an element\n *\n * @param {Element} element\n *        Element to add class name to.\n *\n * @param {string} classToAdd\n *        Class name to add.\n *\n * @return {Element}\n *         The dom element with the added class name.\n */\nfunction addClass(element, classToAdd) {\n  if (element.classList) {\n    element.classList.add(classToAdd);\n\n    // Don't need to `throwIfWhitespace` here because `hasElClass` will do it\n    // in the case of classList not being supported.\n  } else if (!hasClass(element, classToAdd)) {\n    element.className = (element.className + ' ' + classToAdd).trim();\n  }\n\n  return element;\n}\n\n/**\n * Remove a CSS class name from an element\n *\n * @param {Element} element\n *        Element to remove a class name from.\n *\n * @param {string} classToRemove\n *        Class name to remove\n *\n * @return {Element}\n *         The dom element with class name removed.\n */\nfunction removeClass(element, classToRemove) {\n  if (element.classList) {\n    element.classList.remove(classToRemove);\n  } else {\n    throwIfWhitespace(classToRemove);\n    element.className = element.className.split(/\\s+/).filter(function (c) {\n      return c !== classToRemove;\n    }).join(' ');\n  }\n\n  return element;\n}\n\n/**\n * The callback definition for toggleElClass.\n *\n * @callback Dom~PredicateCallback\n * @param {Element} element\n *        The DOM element of the Component.\n *\n * @param {string} classToToggle\n *        The `className` that wants to be toggled\n *\n * @return {boolean|undefined}\n *         - If true the `classToToggle` will get added to `element`.\n *         - If false the `classToToggle` will get removed from `element`.\n *         - If undefined this callback will be ignored\n */\n\n/**\n * Adds or removes a CSS class name on an element depending on an optional\n * condition or the presence/absence of the class name.\n *\n * @param {Element} element\n *        The element to toggle a class name on.\n *\n * @param {string} classToToggle\n *        The class that should be toggled\n *\n * @param {boolean|PredicateCallback} [predicate]\n *        See the return value for {@link Dom~PredicateCallback}\n *\n * @return {Element}\n *         The element with a class that has been toggled.\n */\nfunction toggleClass(element, classToToggle, predicate) {\n\n  // This CANNOT use `classList` internally because IE does not support the\n  // second parameter to the `classList.toggle()` method! Which is fine because\n  // `classList` will be used by the add/remove functions.\n  var has = hasClass(element, classToToggle);\n\n  if (typeof predicate === 'function') {\n    predicate = predicate(element, classToToggle);\n  }\n\n  if (typeof predicate !== 'boolean') {\n    predicate = !has;\n  }\n\n  // If the necessary class operation matches the current state of the\n  // element, no action is required.\n  if (predicate === has) {\n    return;\n  }\n\n  if (predicate) {\n    addClass(element, classToToggle);\n  } else {\n    removeClass(element, classToToggle);\n  }\n\n  return element;\n}\n\n/**\n * Apply attributes to an HTML element.\n *\n * @param {Element} el\n *        Element to add attributes to.\n *\n * @param {Object} [attributes]\n *        Attributes to be applied.\n */\nfunction setAttributes(el, attributes) {\n  Object.getOwnPropertyNames(attributes).forEach(function (attrName) {\n    var attrValue = attributes[attrName];\n\n    if (attrValue === null || typeof attrValue === 'undefined' || attrValue === false) {\n      el.removeAttribute(attrName);\n    } else {\n      el.setAttribute(attrName, attrValue === true ? '' : attrValue);\n    }\n  });\n}\n\n/**\n * Get an element's attribute values, as defined on the HTML tag\n * Attributes are not the same as properties. They're defined on the tag\n * or with setAttribute (which shouldn't be used with HTML)\n * This will return true or false for boolean attributes.\n *\n * @param {Element} tag\n *        Element from which to get tag attributes.\n *\n * @return {Object}\n *         All attributes of the element.\n */\nfunction getAttributes(tag) {\n  var obj = {};\n\n  // known boolean attributes\n  // we can check for matching boolean properties, but older browsers\n  // won't know about HTML5 boolean attributes that we still read from\n  var knownBooleans = ',' + 'autoplay,controls,playsinline,loop,muted,default,defaultMuted' + ',';\n\n  if (tag && tag.attributes && tag.attributes.length > 0) {\n    var attrs = tag.attributes;\n\n    for (var i = attrs.length - 1; i >= 0; i--) {\n      var attrName = attrs[i].name;\n      var attrVal = attrs[i].value;\n\n      // check for known booleans\n      // the matching element property will return a value for typeof\n      if (typeof tag[attrName] === 'boolean' || knownBooleans.indexOf(',' + attrName + ',') !== -1) {\n        // the value of an included boolean attribute is typically an empty\n        // string ('') which would equal false if we just check for a false value.\n        // we also don't want support bad code like autoplay='false'\n        attrVal = attrVal !== null ? true : false;\n      }\n\n      obj[attrName] = attrVal;\n    }\n  }\n\n  return obj;\n}\n\n/**\n * Get the value of an element's attribute\n *\n * @param {Element} el\n *        A DOM element\n *\n * @param {string} attribute\n *        Attribute to get the value of\n *\n * @return {string}\n *         value of the attribute\n */\nfunction getAttribute(el, attribute) {\n  return el.getAttribute(attribute);\n}\n\n/**\n * Set the value of an element's attribute\n *\n * @param {Element} el\n *        A DOM element\n *\n * @param {string} attribute\n *        Attribute to set\n *\n * @param {string} value\n *        Value to set the attribute to\n */\nfunction setAttribute(el, attribute, value) {\n  el.setAttribute(attribute, value);\n}\n\n/**\n * Remove an element's attribute\n *\n * @param {Element} el\n *        A DOM element\n *\n * @param {string} attribute\n *        Attribute to remove\n */\nfunction removeAttribute(el, attribute) {\n  el.removeAttribute(attribute);\n}\n\n/**\n * Attempt to block the ability to select text while dragging controls\n */\nfunction blockTextSelection() {\n  document.body.focus();\n  document.onselectstart = function () {\n    return false;\n  };\n}\n\n/**\n * Turn off text selection blocking\n */\nfunction unblockTextSelection() {\n  document.onselectstart = function () {\n    return true;\n  };\n}\n\n/**\n * Identical to the native `getBoundingClientRect` function, but ensures that\n * the method is supported at all (it is in all browsers we claim to support)\n * and that the element is in the DOM before continuing.\n *\n * This wrapper function also shims properties which are not provided by some\n * older browsers (namely, IE8).\n *\n * Additionally, some browsers do not support adding properties to a\n * `ClientRect`/`DOMRect` object; so, we shallow-copy it with the standard\n * properties (except `x` and `y` which are not widely supported). This helps\n * avoid implementations where keys are non-enumerable.\n *\n * @param  {Element} el\n *         Element whose `ClientRect` we want to calculate.\n *\n * @return {Object|undefined}\n *         Always returns a plain\n */\nfunction getBoundingClientRect(el) {\n  if (el && el.getBoundingClientRect && el.parentNode) {\n    var rect = el.getBoundingClientRect();\n    var result = {};\n\n    ['bottom', 'height', 'left', 'right', 'top', 'width'].forEach(function (k) {\n      if (rect[k] !== undefined) {\n        result[k] = rect[k];\n      }\n    });\n\n    if (!result.height) {\n      result.height = parseFloat(computedStyle(el, 'height'));\n    }\n\n    if (!result.width) {\n      result.width = parseFloat(computedStyle(el, 'width'));\n    }\n\n    return result;\n  }\n}\n\n/**\n * The postion of a DOM element on the page.\n *\n * @typedef {Object} module:dom~Position\n *\n * @property {number} left\n *           Pixels to the left\n *\n * @property {number} top\n *           Pixels on top\n */\n\n/**\n * Offset Left.\n * getBoundingClientRect technique from\n * John Resig\n *\n * @see http://ejohn.org/blog/getboundingclientrect-is-awesome/\n *\n * @param {Element} el\n *        Element from which to get offset\n *\n * @return {module:dom~Position}\n *         The position of the element that was passed in.\n */\nfunction findPosition(el) {\n  var box = void 0;\n\n  if (el.getBoundingClientRect && el.parentNode) {\n    box = el.getBoundingClientRect();\n  }\n\n  if (!box) {\n    return {\n      left: 0,\n      top: 0\n    };\n  }\n\n  var docEl = document.documentElement;\n  var body = document.body;\n\n  var clientLeft = docEl.clientLeft || body.clientLeft || 0;\n  var scrollLeft = window.pageXOffset || body.scrollLeft;\n  var left = box.left + scrollLeft - clientLeft;\n\n  var clientTop = docEl.clientTop || body.clientTop || 0;\n  var scrollTop = window.pageYOffset || body.scrollTop;\n  var top = box.top + scrollTop - clientTop;\n\n  // Android sometimes returns slightly off decimal values, so need to round\n  return {\n    left: Math.round(left),\n    top: Math.round(top)\n  };\n}\n\n/**\n * x and y coordinates for a dom element or mouse pointer\n *\n * @typedef {Object} Dom~Coordinates\n *\n * @property {number} x\n *           x coordinate in pixels\n *\n * @property {number} y\n *           y coordinate in pixels\n */\n\n/**\n * Get pointer position in element\n * Returns an object with x and y coordinates.\n * The base on the coordinates are the bottom left of the element.\n *\n * @param {Element} el\n *        Element on which to get the pointer position on\n *\n * @param {EventTarget~Event} event\n *        Event object\n *\n * @return {Dom~Coordinates}\n *         A Coordinates object corresponding to the mouse position.\n *\n */\nfunction getPointerPosition(el, event) {\n  var position = {};\n  var box = findPosition(el);\n  var boxW = el.offsetWidth;\n  var boxH = el.offsetHeight;\n\n  var boxY = box.top;\n  var boxX = box.left;\n  var pageY = event.pageY;\n  var pageX = event.pageX;\n\n  if (event.changedTouches) {\n    pageX = event.changedTouches[0].pageX;\n    pageY = event.changedTouches[0].pageY;\n  }\n\n  position.y = Math.max(0, Math.min(1, (boxY - pageY + boxH) / boxH));\n  position.x = Math.max(0, Math.min(1, (pageX - boxX) / boxW));\n\n  return position;\n}\n\n/**\n * Determines, via duck typing, whether or not a value is a text node.\n *\n * @param {Mixed} value\n *        Check if this value is a text node.\n *\n * @return {boolean}\n *         - True if it is a text node\n *         - False otherwise\n */\nfunction isTextNode(value) {\n  return isObject(value) && value.nodeType === 3;\n}\n\n/**\n * Empties the contents of an element.\n *\n * @param {Element} el\n *        The element to empty children from\n *\n * @return {Element}\n *         The element with no children\n */\nfunction emptyEl(el) {\n  while (el.firstChild) {\n    el.removeChild(el.firstChild);\n  }\n  return el;\n}\n\n/**\n * Normalizes content for eventual insertion into the DOM.\n *\n * This allows a wide range of content definition methods, but protects\n * from falling into the trap of simply writing to `innerHTML`, which is\n * an XSS concern.\n *\n * The content for an element can be passed in multiple types and\n * combinations, whose behavior is as follows:\n *\n * @param {String|Element|TextNode|Array|Function} content\n *        - String: Normalized into a text node.\n *        - Element/TextNode: Passed through.\n *        - Array: A one-dimensional array of strings, elements, nodes, or functions\n *          (which return single strings, elements, or nodes).\n *        - Function: If the sole argument, is expected to produce a string, element,\n *          node, or array as defined above.\n *\n * @return {Array}\n *         All of the content that was passed in normalized.\n */\nfunction normalizeContent(content) {\n\n  // First, invoke content if it is a function. If it produces an array,\n  // that needs to happen before normalization.\n  if (typeof content === 'function') {\n    content = content();\n  }\n\n  // Next up, normalize to an array, so one or many items can be normalized,\n  // filtered, and returned.\n  return (Array.isArray(content) ? content : [content]).map(function (value) {\n\n    // First, invoke value if it is a function to produce a new value,\n    // which will be subsequently normalized to a Node of some kind.\n    if (typeof value === 'function') {\n      value = value();\n    }\n\n    if (isEl(value) || isTextNode(value)) {\n      return value;\n    }\n\n    if (typeof value === 'string' && /\\S/.test(value)) {\n      return document.createTextNode(value);\n    }\n  }).filter(function (value) {\n    return value;\n  });\n}\n\n/**\n * Normalizes and appends content to an element.\n *\n * @param {Element} el\n *        Element to append normalized content to.\n *\n *\n * @param {String|Element|TextNode|Array|Function} content\n *        See the `content` argument of {@link dom:normalizeContent}\n *\n * @return {Element}\n *         The element with appended normalized content.\n */\nfunction appendContent(el, content) {\n  normalizeContent(content).forEach(function (node) {\n    return el.appendChild(node);\n  });\n  return el;\n}\n\n/**\n * Normalizes and inserts content into an element; this is identical to\n * `appendContent()`, except it empties the element first.\n *\n * @param {Element} el\n *        Element to insert normalized content into.\n *\n * @param {String|Element|TextNode|Array|Function} content\n *        See the `content` argument of {@link dom:normalizeContent}\n *\n * @return {Element}\n *         The element with inserted normalized content.\n *\n */\nfunction insertContent(el, content) {\n  return appendContent(emptyEl(el), content);\n}\n\n/**\n * Check if event was a single left click\n *\n * @param {EventTarget~Event} event\n *        Event object\n *\n * @return {boolean}\n *         - True if a left click\n *         - False if not a left click\n */\nfunction isSingleLeftClick(event) {\n  // Note: if you create something draggable, be sure to\n  // call it on both `mousedown` and `mousemove` event,\n  // otherwise `mousedown` should be enough for a button\n\n  if (event.button === undefined && event.buttons === undefined) {\n    // Why do we need `buttons` ?\n    // Because, middle mouse sometimes have this:\n    // e.button === 0 and e.buttons === 4\n    // Furthermore, we want to prevent combination click, something like\n    // HOLD middlemouse then left click, that would be\n    // e.button === 0, e.buttons === 5\n    // just `button` is not gonna work\n\n    // Alright, then what this block does ?\n    // this is for chrome `simulate mobile devices`\n    // I want to support this as well\n\n    return true;\n  }\n\n  if (event.button === 0 && event.buttons === undefined) {\n    // Touch screen, sometimes on some specific device, `buttons`\n    // doesn't have anything (safari on ios, blackberry...)\n\n    return true;\n  }\n\n  if (IE_VERSION === 9) {\n    // Ignore IE9\n\n    return true;\n  }\n\n  if (event.button !== 0 || event.buttons !== 1) {\n    // This is the reason we have those if else block above\n    // if any special case we can catch and let it slide\n    // we do it above, when get to here, this definitely\n    // is-not-left-click\n\n    return false;\n  }\n\n  return true;\n}\n\n/**\n * Finds a single DOM element matching `selector` within the optional\n * `context` of another DOM element (defaulting to `document`).\n *\n * @param {string} selector\n *        A valid CSS selector, which will be passed to `querySelector`.\n *\n * @param {Element|String} [context=document]\n *        A DOM element within which to query. Can also be a selector\n *        string in which case the first matching element will be used\n *        as context. If missing (or no element matches selector), falls\n *        back to `document`.\n *\n * @return {Element|null}\n *         The element that was found or null.\n */\nvar $ = createQuerier('querySelector');\n\n/**\n * Finds a all DOM elements matching `selector` within the optional\n * `context` of another DOM element (defaulting to `document`).\n *\n * @param {string} selector\n *           A valid CSS selector, which will be passed to `querySelectorAll`.\n *\n * @param {Element|String} [context=document]\n *           A DOM element within which to query. Can also be a selector\n *           string in which case the first matching element will be used\n *           as context. If missing (or no element matches selector), falls\n *           back to `document`.\n *\n * @return {NodeList}\n *         A element list of elements that were found. Will be empty if none were found.\n *\n */\nvar $$ = createQuerier('querySelectorAll');\n\n\n\nvar Dom = (Object.freeze || Object)({\n\tisReal: isReal,\n\tisEl: isEl,\n\tisInFrame: isInFrame,\n\tcreateEl: createEl,\n\ttextContent: textContent,\n\tprependTo: prependTo,\n\thasClass: hasClass,\n\taddClass: addClass,\n\tremoveClass: removeClass,\n\ttoggleClass: toggleClass,\n\tsetAttributes: setAttributes,\n\tgetAttributes: getAttributes,\n\tgetAttribute: getAttribute,\n\tsetAttribute: setAttribute,\n\tremoveAttribute: removeAttribute,\n\tblockTextSelection: blockTextSelection,\n\tunblockTextSelection: unblockTextSelection,\n\tgetBoundingClientRect: getBoundingClientRect,\n\tfindPosition: findPosition,\n\tgetPointerPosition: getPointerPosition,\n\tisTextNode: isTextNode,\n\temptyEl: emptyEl,\n\tnormalizeContent: normalizeContent,\n\tappendContent: appendContent,\n\tinsertContent: insertContent,\n\tisSingleLeftClick: isSingleLeftClick,\n\t$: $,\n\t$$: $$\n});\n\n/**\n * @file guid.js\n * @module guid\n */\n\n/**\n * Unique ID for an element or function\n * @type {Number}\n */\nvar _guid = 1;\n\n/**\n * Get a unique auto-incrementing ID by number that has not been returned before.\n *\n * @return {number}\n *         A new unique ID.\n */\nfunction newGUID() {\n  return _guid++;\n}\n\n/**\n * @file dom-data.js\n * @module dom-data\n */\n/**\n * Element Data Store.\n *\n * Allows for binding data to an element without putting it directly on the\n * element. Ex. Event listeners are stored here.\n * (also from jsninja.com, slightly modified and updated for closure compiler)\n *\n * @type {Object}\n * @private\n */\nvar elData = {};\n\n/*\n * Unique attribute name to store an element's guid in\n *\n * @type {String}\n * @constant\n * @private\n */\nvar elIdAttr = 'vdata' + new Date().getTime();\n\n/**\n * Returns the cache object where data for an element is stored\n *\n * @param {Element} el\n *        Element to store data for.\n *\n * @return {Object}\n *         The cache object for that el that was passed in.\n */\nfunction getData(el) {\n  var id = el[elIdAttr];\n\n  if (!id) {\n    id = el[elIdAttr] = newGUID();\n  }\n\n  if (!elData[id]) {\n    elData[id] = {};\n  }\n\n  return elData[id];\n}\n\n/**\n * Returns whether or not an element has cached data\n *\n * @param {Element} el\n *        Check if this element has cached data.\n *\n * @return {boolean}\n *         - True if the DOM element has cached data.\n *         - False otherwise.\n */\nfunction hasData(el) {\n  var id = el[elIdAttr];\n\n  if (!id) {\n    return false;\n  }\n\n  return !!Object.getOwnPropertyNames(elData[id]).length;\n}\n\n/**\n * Delete data for the element from the cache and the guid attr from getElementById\n *\n * @param {Element} el\n *        Remove cached data for this element.\n */\nfunction removeData(el) {\n  var id = el[elIdAttr];\n\n  if (!id) {\n    return;\n  }\n\n  // Remove all stored data\n  delete elData[id];\n\n  // Remove the elIdAttr property from the DOM node\n  try {\n    delete el[elIdAttr];\n  } catch (e) {\n    if (el.removeAttribute) {\n      el.removeAttribute(elIdAttr);\n    } else {\n      // IE doesn't appear to support removeAttribute on the document element\n      el[elIdAttr] = null;\n    }\n  }\n}\n\n/**\n * @file events.js. An Event System (John Resig - Secrets of a JS Ninja http://jsninja.com/)\n * (Original book version wasn't completely usable, so fixed some things and made Closure Compiler compatible)\n * This should work very similarly to jQuery's events, however it's based off the book version which isn't as\n * robust as jquery's, so there's probably some differences.\n *\n * @module events\n */\n\n/**\n * Clean up the listener cache and dispatchers\n *\n * @param {Element|Object} elem\n *        Element to clean up\n *\n * @param {string} type\n *        Type of event to clean up\n */\nfunction _cleanUpEvents(elem, type) {\n  var data = getData(elem);\n\n  // Remove the events of a particular type if there are none left\n  if (data.handlers[type].length === 0) {\n    delete data.handlers[type];\n    // data.handlers[type] = null;\n    // Setting to null was causing an error with data.handlers\n\n    // Remove the meta-handler from the element\n    if (elem.removeEventListener) {\n      elem.removeEventListener(type, data.dispatcher, false);\n    } else if (elem.detachEvent) {\n      elem.detachEvent('on' + type, data.dispatcher);\n    }\n  }\n\n  // Remove the events object if there are no types left\n  if (Object.getOwnPropertyNames(data.handlers).length <= 0) {\n    delete data.handlers;\n    delete data.dispatcher;\n    delete data.disabled;\n  }\n\n  // Finally remove the element data if there is no data left\n  if (Object.getOwnPropertyNames(data).length === 0) {\n    removeData(elem);\n  }\n}\n\n/**\n * Loops through an array of event types and calls the requested method for each type.\n *\n * @param {Function} fn\n *        The event method we want to use.\n *\n * @param {Element|Object} elem\n *        Element or object to bind listeners to\n *\n * @param {string} type\n *        Type of event to bind to.\n *\n * @param {EventTarget~EventListener} callback\n *        Event listener.\n */\nfunction _handleMultipleEvents(fn, elem, types, callback) {\n  types.forEach(function (type) {\n    // Call the event method for each one of the types\n    fn(elem, type, callback);\n  });\n}\n\n/**\n * Fix a native event to have standard property values\n *\n * @param {Object} event\n *        Event object to fix.\n *\n * @return {Object}\n *         Fixed event object.\n */\nfunction fixEvent(event) {\n\n  function returnTrue() {\n    return true;\n  }\n\n  function returnFalse() {\n    return false;\n  }\n\n  // Test if fixing up is needed\n  // Used to check if !event.stopPropagation instead of isPropagationStopped\n  // But native events return true for stopPropagation, but don't have\n  // other expected methods like isPropagationStopped. Seems to be a problem\n  // with the Javascript Ninja code. So we're just overriding all events now.\n  if (!event || !event.isPropagationStopped) {\n    var old = event || window.event;\n\n    event = {};\n    // Clone the old object so that we can modify the values event = {};\n    // IE8 Doesn't like when you mess with native event properties\n    // Firefox returns false for event.hasOwnProperty('type') and other props\n    //  which makes copying more difficult.\n    // TODO: Probably best to create a whitelist of event props\n    for (var key in old) {\n      // Safari 6.0.3 warns you if you try to copy deprecated layerX/Y\n      // Chrome warns you if you try to copy deprecated keyboardEvent.keyLocation\n      // and webkitMovementX/Y\n      if (key !== 'layerX' && key !== 'layerY' && key !== 'keyLocation' && key !== 'webkitMovementX' && key !== 'webkitMovementY') {\n        // Chrome 32+ warns if you try to copy deprecated returnValue, but\n        // we still want to if preventDefault isn't supported (IE8).\n        if (!(key === 'returnValue' && old.preventDefault)) {\n          event[key] = old[key];\n        }\n      }\n    }\n\n    // The event occurred on this element\n    if (!event.target) {\n      event.target = event.srcElement || document;\n    }\n\n    // Handle which other element the event is related to\n    if (!event.relatedTarget) {\n      event.relatedTarget = event.fromElement === event.target ? event.toElement : event.fromElement;\n    }\n\n    // Stop the default browser action\n    event.preventDefault = function () {\n      if (old.preventDefault) {\n        old.preventDefault();\n      }\n      event.returnValue = false;\n      old.returnValue = false;\n      event.defaultPrevented = true;\n    };\n\n    event.defaultPrevented = false;\n\n    // Stop the event from bubbling\n    event.stopPropagation = function () {\n      if (old.stopPropagation) {\n        old.stopPropagation();\n      }\n      event.cancelBubble = true;\n      old.cancelBubble = true;\n      event.isPropagationStopped = returnTrue;\n    };\n\n    event.isPropagationStopped = returnFalse;\n\n    // Stop the event from bubbling and executing other handlers\n    event.stopImmediatePropagation = function () {\n      if (old.stopImmediatePropagation) {\n        old.stopImmediatePropagation();\n      }\n      event.isImmediatePropagationStopped = returnTrue;\n      event.stopPropagation();\n    };\n\n    event.isImmediatePropagationStopped = returnFalse;\n\n    // Handle mouse position\n    if (event.clientX !== null && event.clientX !== undefined) {\n      var doc = document.documentElement;\n      var body = document.body;\n\n      event.pageX = event.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);\n      event.pageY = event.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);\n    }\n\n    // Handle key presses\n    event.which = event.charCode || event.keyCode;\n\n    // Fix button for mouse clicks:\n    // 0 == left; 1 == middle; 2 == right\n    if (event.button !== null && event.button !== undefined) {\n\n      // The following is disabled because it does not pass videojs-standard\n      // and... yikes.\n      /* eslint-disable */\n      event.button = event.button & 1 ? 0 : event.button & 4 ? 1 : event.button & 2 ? 2 : 0;\n      /* eslint-enable */\n    }\n  }\n\n  // Returns fixed-up instance\n  return event;\n}\n\n/**\n * Whether passive event listeners are supported\n */\nvar _supportsPassive = false;\n\n(function () {\n  try {\n    var opts = Object.defineProperty({}, 'passive', {\n      get: function get() {\n        _supportsPassive = true;\n      }\n    });\n\n    window.addEventListener('test', null, opts);\n    window.removeEventListener('test', null, opts);\n  } catch (e) {\n    // disregard\n  }\n})();\n\n/**\n * Touch events Chrome expects to be passive\n */\nvar passiveEvents = ['touchstart', 'touchmove'];\n\n/**\n * Add an event listener to element\n * It stores the handler function in a separate cache object\n * and adds a generic handler to the element's event,\n * along with a unique id (guid) to the element.\n *\n * @param {Element|Object} elem\n *        Element or object to bind listeners to\n *\n * @param {string|string[]} type\n *        Type of event to bind to.\n *\n * @param {EventTarget~EventListener} fn\n *        Event listener.\n */\nfunction on(elem, type, fn) {\n  if (Array.isArray(type)) {\n    return _handleMultipleEvents(on, elem, type, fn);\n  }\n\n  var data = getData(elem);\n\n  // We need a place to store all our handler data\n  if (!data.handlers) {\n    data.handlers = {};\n  }\n\n  if (!data.handlers[type]) {\n    data.handlers[type] = [];\n  }\n\n  if (!fn.guid) {\n    fn.guid = newGUID();\n  }\n\n  data.handlers[type].push(fn);\n\n  if (!data.dispatcher) {\n    data.disabled = false;\n\n    data.dispatcher = function (event, hash) {\n\n      if (data.disabled) {\n        return;\n      }\n\n      event = fixEvent(event);\n\n      var handlers = data.handlers[event.type];\n\n      if (handlers) {\n        // Copy handlers so if handlers are added/removed during the process it doesn't throw everything off.\n        var handlersCopy = handlers.slice(0);\n\n        for (var m = 0, n = handlersCopy.length; m < n; m++) {\n          if (event.isImmediatePropagationStopped()) {\n            break;\n          } else {\n            try {\n              handlersCopy[m].call(elem, event, hash);\n            } catch (e) {\n              log.error(e);\n            }\n          }\n        }\n      }\n    };\n  }\n\n  if (data.handlers[type].length === 1) {\n    if (elem.addEventListener) {\n      var options = false;\n\n      if (_supportsPassive && passiveEvents.indexOf(type) > -1) {\n        options = { passive: true };\n      }\n      elem.addEventListener(type, data.dispatcher, options);\n    } else if (elem.attachEvent) {\n      elem.attachEvent('on' + type, data.dispatcher);\n    }\n  }\n}\n\n/**\n * Removes event listeners from an element\n *\n * @param {Element|Object} elem\n *        Object to remove listeners from.\n *\n * @param {string|string[]} [type]\n *        Type of listener to remove. Don't include to remove all events from element.\n *\n * @param {EventTarget~EventListener} [fn]\n *        Specific listener to remove. Don't include to remove listeners for an event\n *        type.\n */\nfunction off(elem, type, fn) {\n  // Don't want to add a cache object through getElData if not needed\n  if (!hasData(elem)) {\n    return;\n  }\n\n  var data = getData(elem);\n\n  // If no events exist, nothing to unbind\n  if (!data.handlers) {\n    return;\n  }\n\n  if (Array.isArray(type)) {\n    return _handleMultipleEvents(off, elem, type, fn);\n  }\n\n  // Utility function\n  var removeType = function removeType(el, t) {\n    data.handlers[t] = [];\n    _cleanUpEvents(el, t);\n  };\n\n  // Are we removing all bound events?\n  if (type === undefined) {\n    for (var t in data.handlers) {\n      if (Object.prototype.hasOwnProperty.call(data.handlers || {}, t)) {\n        removeType(elem, t);\n      }\n    }\n    return;\n  }\n\n  var handlers = data.handlers[type];\n\n  // If no handlers exist, nothing to unbind\n  if (!handlers) {\n    return;\n  }\n\n  // If no listener was provided, remove all listeners for type\n  if (!fn) {\n    removeType(elem, type);\n    return;\n  }\n\n  // We're only removing a single handler\n  if (fn.guid) {\n    for (var n = 0; n < handlers.length; n++) {\n      if (handlers[n].guid === fn.guid) {\n        handlers.splice(n--, 1);\n      }\n    }\n  }\n\n  _cleanUpEvents(elem, type);\n}\n\n/**\n * Trigger an event for an element\n *\n * @param {Element|Object} elem\n *        Element to trigger an event on\n *\n * @param {EventTarget~Event|string} event\n *        A string (the type) or an event object with a type attribute\n *\n * @param {Object} [hash]\n *        data hash to pass along with the event\n *\n * @return {boolean|undefined}\n *         - Returns the opposite of `defaultPrevented` if default was prevented\n *         - Otherwise returns undefined\n */\nfunction trigger(elem, event, hash) {\n  // Fetches element data and a reference to the parent (for bubbling).\n  // Don't want to add a data object to cache for every parent,\n  // so checking hasElData first.\n  var elemData = hasData(elem) ? getData(elem) : {};\n  var parent = elem.parentNode || elem.ownerDocument;\n  // type = event.type || event,\n  // handler;\n\n  // If an event name was passed as a string, creates an event out of it\n  if (typeof event === 'string') {\n    event = { type: event, target: elem };\n  } else if (!event.target) {\n    event.target = elem;\n  }\n\n  // Normalizes the event properties.\n  event = fixEvent(event);\n\n  // If the passed element has a dispatcher, executes the established handlers.\n  if (elemData.dispatcher) {\n    elemData.dispatcher.call(elem, event, hash);\n  }\n\n  // Unless explicitly stopped or the event does not bubble (e.g. media events)\n  // recursively calls this function to bubble the event up the DOM.\n  if (parent && !event.isPropagationStopped() && event.bubbles === true) {\n    trigger.call(null, parent, event, hash);\n\n    // If at the top of the DOM, triggers the default action unless disabled.\n  } else if (!parent && !event.defaultPrevented) {\n    var targetData = getData(event.target);\n\n    // Checks if the target has a default action for this event.\n    if (event.target[event.type]) {\n      // Temporarily disables event dispatching on the target as we have already executed the handler.\n      targetData.disabled = true;\n      // Executes the default action.\n      if (typeof event.target[event.type] === 'function') {\n        event.target[event.type]();\n      }\n      // Re-enables event dispatching.\n      targetData.disabled = false;\n    }\n  }\n\n  // Inform the triggerer if the default was prevented by returning false\n  return !event.defaultPrevented;\n}\n\n/**\n * Trigger a listener only once for an event\n *\n * @param {Element|Object} elem\n *        Element or object to bind to.\n *\n * @param {string|string[]} type\n *        Name/type of event\n *\n * @param {Event~EventListener} fn\n *        Event Listener function\n */\nfunction one(elem, type, fn) {\n  if (Array.isArray(type)) {\n    return _handleMultipleEvents(one, elem, type, fn);\n  }\n  var func = function func() {\n    off(elem, type, func);\n    fn.apply(this, arguments);\n  };\n\n  // copy the guid to the new function so it can removed using the original function's ID\n  func.guid = fn.guid = fn.guid || newGUID();\n  on(elem, type, func);\n}\n\nvar Events = (Object.freeze || Object)({\n\tfixEvent: fixEvent,\n\ton: on,\n\toff: off,\n\ttrigger: trigger,\n\tone: one\n});\n\n/**\n * @file setup.js - Functions for setting up a player without\n * user interaction based on the data-setup `attribute` of the video tag.\n *\n * @module setup\n */\nvar _windowLoaded = false;\nvar videojs$2 = void 0;\n\n/**\n * Set up any tags that have a data-setup `attribute` when the player is started.\n */\nvar autoSetup = function autoSetup() {\n\n  // Protect against breakage in non-browser environments and check global autoSetup option.\n  if (!isReal() || videojs$2.options.autoSetup === false) {\n    return;\n  }\n\n  // One day, when we stop supporting IE8, go back to this, but in the meantime...*hack hack hack*\n  // var vids = Array.prototype.slice.call(document.getElementsByTagName('video'));\n  // var audios = Array.prototype.slice.call(document.getElementsByTagName('audio'));\n  // var mediaEls = vids.concat(audios);\n\n  // Because IE8 doesn't support calling slice on a node list, we need to loop\n  // through each list of elements to build up a new, combined list of elements.\n  var vids = document.getElementsByTagName('video');\n  var audios = document.getElementsByTagName('audio');\n  var divs = document.getElementsByTagName('video-js');\n  var mediaEls = [];\n\n  if (vids && vids.length > 0) {\n    for (var i = 0, e = vids.length; i < e; i++) {\n      mediaEls.push(vids[i]);\n    }\n  }\n\n  if (audios && audios.length > 0) {\n    for (var _i = 0, _e = audios.length; _i < _e; _i++) {\n      mediaEls.push(audios[_i]);\n    }\n  }\n\n  if (divs && divs.length > 0) {\n    for (var _i2 = 0, _e2 = divs.length; _i2 < _e2; _i2++) {\n      mediaEls.push(divs[_i2]);\n    }\n  }\n\n  // Check if any media elements exist\n  if (mediaEls && mediaEls.length > 0) {\n\n    for (var _i3 = 0, _e3 = mediaEls.length; _i3 < _e3; _i3++) {\n      var mediaEl = mediaEls[_i3];\n\n      // Check if element exists, has getAttribute func.\n      // IE seems to consider typeof el.getAttribute == 'object' instead of\n      // 'function' like expected, at least when loading the player immediately.\n      if (mediaEl && mediaEl.getAttribute) {\n\n        // Make sure this player hasn't already been set up.\n        if (mediaEl.player === undefined) {\n          var options = mediaEl.getAttribute('data-setup');\n\n          // Check if data-setup attr exists.\n          // We only auto-setup if they've added the data-setup attr.\n          if (options !== null) {\n            // Create new video.js instance.\n            videojs$2(mediaEl);\n          }\n        }\n\n        // If getAttribute isn't defined, we need to wait for the DOM.\n      } else {\n        autoSetupTimeout(1);\n        break;\n      }\n    }\n\n    // No videos were found, so keep looping unless page is finished loading.\n  } else if (!_windowLoaded) {\n    autoSetupTimeout(1);\n  }\n};\n\n/**\n * Wait until the page is loaded before running autoSetup. This will be called in\n * autoSetup if `hasLoaded` returns false.\n *\n * @param {number} wait\n *        How long to wait in ms\n *\n * @param {module:videojs} [vjs]\n *        The videojs library function\n */\nfunction autoSetupTimeout(wait, vjs) {\n  if (vjs) {\n    videojs$2 = vjs;\n  }\n\n  window.setTimeout(autoSetup, wait);\n}\n\nif (isReal() && document.readyState === 'complete') {\n  _windowLoaded = true;\n} else {\n  /**\n   * Listen for the load event on window, and set _windowLoaded to true.\n   *\n   * @listens load\n   */\n  one(window, 'load', function () {\n    _windowLoaded = true;\n  });\n}\n\n/**\n * @file stylesheet.js\n * @module stylesheet\n */\n/**\n * Create a DOM syle element given a className for it.\n *\n * @param {string} className\n *        The className to add to the created style element.\n *\n * @return {Element}\n *         The element that was created.\n */\nvar createStyleElement = function createStyleElement(className) {\n  var style = document.createElement('style');\n\n  style.className = className;\n\n  return style;\n};\n\n/**\n * Add text to a DOM element.\n *\n * @param {Element} el\n *        The Element to add text content to.\n *\n * @param {string} content\n *        The text to add to the element.\n */\nvar setTextContent = function setTextContent(el, content) {\n  if (el.styleSheet) {\n    el.styleSheet.cssText = content;\n  } else {\n    el.textContent = content;\n  }\n};\n\n/**\n * @file fn.js\n * @module fn\n */\n/**\n * Bind (a.k.a proxy or Context). A simple method for changing the context of a function\n * It also stores a unique id on the function so it can be easily removed from events.\n *\n * @param {Mixed} context\n *        The object to bind as scope.\n *\n * @param {Function} fn\n *        The function to be bound to a scope.\n *\n * @param {number} [uid]\n *        An optional unique ID for the function to be set\n *\n * @return {Function}\n *         The new function that will be bound into the context given\n */\nvar bind = function bind(context, fn, uid) {\n  // Make sure the function has a unique ID\n  if (!fn.guid) {\n    fn.guid = newGUID();\n  }\n\n  // Create the new function that changes the context\n  var bound = function bound() {\n    return fn.apply(context, arguments);\n  };\n\n  // Allow for the ability to individualize this function\n  // Needed in the case where multiple objects might share the same prototype\n  // IF both items add an event listener with the same function, then you try to remove just one\n  // it will remove both because they both have the same guid.\n  // when using this, you need to use the bind method when you remove the listener as well.\n  // currently used in text tracks\n  bound.guid = uid ? uid + '_' + fn.guid : fn.guid;\n\n  return bound;\n};\n\n/**\n * Wraps the given function, `fn`, with a new function that only invokes `fn`\n * at most once per every `wait` milliseconds.\n *\n * @param  {Function} fn\n *         The function to be throttled.\n *\n * @param  {Number}   wait\n *         The number of milliseconds by which to throttle.\n *\n * @return {Function}\n */\nvar throttle = function throttle(fn, wait) {\n  var last = Date.now();\n\n  var throttled = function throttled() {\n    var now = Date.now();\n\n    if (now - last >= wait) {\n      fn.apply(undefined, arguments);\n      last = now;\n    }\n  };\n\n  return throttled;\n};\n\n/**\n * Creates a debounced function that delays invoking `func` until after `wait`\n * milliseconds have elapsed since the last time the debounced function was\n * invoked.\n *\n * Inspired by lodash and underscore implementations.\n *\n * @param  {Function} func\n *         The function to wrap with debounce behavior.\n *\n * @param  {number} wait\n *         The number of milliseconds to wait after the last invocation.\n *\n * @param  {boolean} [immediate]\n *         Whether or not to invoke the function immediately upon creation.\n *\n * @param  {Object} [context=window]\n *         The \"context\" in which the debounced function should debounce. For\n *         example, if this function should be tied to a Video.js player,\n *         the player can be passed here. Alternatively, defaults to the\n *         global `window` object.\n *\n * @return {Function}\n *         A debounced function.\n */\nvar debounce = function debounce(func, wait, immediate) {\n  var context = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : window;\n\n  var timeout = void 0;\n\n  var cancel = function cancel() {\n    context.clearTimeout(timeout);\n    timeout = null;\n  };\n\n  /* eslint-disable consistent-this */\n  var debounced = function debounced() {\n    var self = this;\n    var args = arguments;\n\n    var _later = function later() {\n      timeout = null;\n      _later = null;\n      if (!immediate) {\n        func.apply(self, args);\n      }\n    };\n\n    if (!timeout && immediate) {\n      func.apply(self, args);\n    }\n\n    context.clearTimeout(timeout);\n    timeout = context.setTimeout(_later, wait);\n  };\n  /* eslint-enable consistent-this */\n\n  debounced.cancel = cancel;\n\n  return debounced;\n};\n\n/**\n * @file src/js/event-target.js\n */\n/**\n * `EventTarget` is a class that can have the same API as the DOM `EventTarget`. It\n * adds shorthand functions that wrap around lengthy functions. For example:\n * the `on` function is a wrapper around `addEventListener`.\n *\n * @see [EventTarget Spec]{@link https://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-EventTarget}\n * @class EventTarget\n */\nvar EventTarget = function EventTarget() {};\n\n/**\n * A Custom DOM event.\n *\n * @typedef {Object} EventTarget~Event\n * @see [Properties]{@link https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent}\n */\n\n/**\n * All event listeners should follow the following format.\n *\n * @callback EventTarget~EventListener\n * @this {EventTarget}\n *\n * @param {EventTarget~Event} event\n *        the event that triggered this function\n *\n * @param {Object} [hash]\n *        hash of data sent during the event\n */\n\n/**\n * An object containing event names as keys and booleans as values.\n *\n * > NOTE: If an event name is set to a true value here {@link EventTarget#trigger}\n *         will have extra functionality. See that function for more information.\n *\n * @property EventTarget.prototype.allowedEvents_\n * @private\n */\nEventTarget.prototype.allowedEvents_ = {};\n\n/**\n * Adds an `event listener` to an instance of an `EventTarget`. An `event listener` is a\n * function that will get called when an event with a certain name gets triggered.\n *\n * @param {string|string[]} type\n *        An event name or an array of event names.\n *\n * @param {EventTarget~EventListener} fn\n *        The function to call with `EventTarget`s\n */\nEventTarget.prototype.on = function (type, fn) {\n  // Remove the addEventListener alias before calling Events.on\n  // so we don't get into an infinite type loop\n  var ael = this.addEventListener;\n\n  this.addEventListener = function () {};\n  on(this, type, fn);\n  this.addEventListener = ael;\n};\n\n/**\n * An alias of {@link EventTarget#on}. Allows `EventTarget` to mimic\n * the standard DOM API.\n *\n * @function\n * @see {@link EventTarget#on}\n */\nEventTarget.prototype.addEventListener = EventTarget.prototype.on;\n\n/**\n * Removes an `event listener` for a specific event from an instance of `EventTarget`.\n * This makes it so that the `event listener` will no longer get called when the\n * named event happens.\n *\n * @param {string|string[]} type\n *        An event name or an array of event names.\n *\n * @param {EventTarget~EventListener} fn\n *        The function to remove.\n */\nEventTarget.prototype.off = function (type, fn) {\n  off(this, type, fn);\n};\n\n/**\n * An alias of {@link EventTarget#off}. Allows `EventTarget` to mimic\n * the standard DOM API.\n *\n * @function\n * @see {@link EventTarget#off}\n */\nEventTarget.prototype.removeEventListener = EventTarget.prototype.off;\n\n/**\n * This function will add an `event listener` that gets triggered only once. After the\n * first trigger it will get removed. This is like adding an `event listener`\n * with {@link EventTarget#on} that calls {@link EventTarget#off} on itself.\n *\n * @param {string|string[]} type\n *        An event name or an array of event names.\n *\n * @param {EventTarget~EventListener} fn\n *        The function to be called once for each event name.\n */\nEventTarget.prototype.one = function (type, fn) {\n  // Remove the addEventListener alialing Events.on\n  // so we don't get into an infinite type loop\n  var ael = this.addEventListener;\n\n  this.addEventListener = function () {};\n  one(this, type, fn);\n  this.addEventListener = ael;\n};\n\n/**\n * This function causes an event to happen. This will then cause any `event listeners`\n * that are waiting for that event, to get called. If there are no `event listeners`\n * for an event then nothing will happen.\n *\n * If the name of the `Event` that is being triggered is in `EventTarget.allowedEvents_`.\n * Trigger will also call the `on` + `uppercaseEventName` function.\n *\n * Example:\n * 'click' is in `EventTarget.allowedEvents_`, so, trigger will attempt to call\n * `onClick` if it exists.\n *\n * @param {string|EventTarget~Event|Object} event\n *        The name of the event, an `Event`, or an object with a key of type set to\n *        an event name.\n */\nEventTarget.prototype.trigger = function (event) {\n  var type = event.type || event;\n\n  if (typeof event === 'string') {\n    event = { type: type };\n  }\n  event = fixEvent(event);\n\n  if (this.allowedEvents_[type] && this['on' + type]) {\n    this['on' + type](event);\n  }\n\n  trigger(this, event);\n};\n\n/**\n * An alias of {@link EventTarget#trigger}. Allows `EventTarget` to mimic\n * the standard DOM API.\n *\n * @function\n * @see {@link EventTarget#trigger}\n */\nEventTarget.prototype.dispatchEvent = EventTarget.prototype.trigger;\n\n/**\n * @file mixins/evented.js\n * @module evented\n */\n/**\n * Returns whether or not an object has had the evented mixin applied.\n *\n * @param  {Object} object\n *         An object to test.\n *\n * @return {boolean}\n *         Whether or not the object appears to be evented.\n */\nvar isEvented = function isEvented(object) {\n  return object instanceof EventTarget || !!object.eventBusEl_ && ['on', 'one', 'off', 'trigger'].every(function (k) {\n    return typeof object[k] === 'function';\n  });\n};\n\n/**\n * Whether a value is a valid event type - non-empty string or array.\n *\n * @private\n * @param  {string|Array} type\n *         The type value to test.\n *\n * @return {boolean}\n *         Whether or not the type is a valid event type.\n */\nvar isValidEventType = function isValidEventType(type) {\n  return (\n    // The regex here verifies that the `type` contains at least one non-\n    // whitespace character.\n    typeof type === 'string' && /\\S/.test(type) || Array.isArray(type) && !!type.length\n  );\n};\n\n/**\n * Validates a value to determine if it is a valid event target. Throws if not.\n *\n * @private\n * @throws {Error}\n *         If the target does not appear to be a valid event target.\n *\n * @param  {Object} target\n *         The object to test.\n */\nvar validateTarget = function validateTarget(target) {\n  if (!target.nodeName && !isEvented(target)) {\n    throw new Error('Invalid target; must be a DOM node or evented object.');\n  }\n};\n\n/**\n * Validates a value to determine if it is a valid event target. Throws if not.\n *\n * @private\n * @throws {Error}\n *         If the type does not appear to be a valid event type.\n *\n * @param  {string|Array} type\n *         The type to test.\n */\nvar validateEventType = function validateEventType(type) {\n  if (!isValidEventType(type)) {\n    throw new Error('Invalid event type; must be a non-empty string or array.');\n  }\n};\n\n/**\n * Validates a value to determine if it is a valid listener. Throws if not.\n *\n * @private\n * @throws {Error}\n *         If the listener is not a function.\n *\n * @param  {Function} listener\n *         The listener to test.\n */\nvar validateListener = function validateListener(listener) {\n  if (typeof listener !== 'function') {\n    throw new Error('Invalid listener; must be a function.');\n  }\n};\n\n/**\n * Takes an array of arguments given to `on()` or `one()`, validates them, and\n * normalizes them into an object.\n *\n * @private\n * @param  {Object} self\n *         The evented object on which `on()` or `one()` was called. This\n *         object will be bound as the `this` value for the listener.\n *\n * @param  {Array} args\n *         An array of arguments passed to `on()` or `one()`.\n *\n * @return {Object}\n *         An object containing useful values for `on()` or `one()` calls.\n */\nvar normalizeListenArgs = function normalizeListenArgs(self, args) {\n\n  // If the number of arguments is less than 3, the target is always the\n  // evented object itself.\n  var isTargetingSelf = args.length < 3 || args[0] === self || args[0] === self.eventBusEl_;\n  var target = void 0;\n  var type = void 0;\n  var listener = void 0;\n\n  if (isTargetingSelf) {\n    target = self.eventBusEl_;\n\n    // Deal with cases where we got 3 arguments, but we are still listening to\n    // the evented object itself.\n    if (args.length >= 3) {\n      args.shift();\n    }\n\n    type = args[0];\n    listener = args[1];\n  } else {\n    target = args[0];\n    type = args[1];\n    listener = args[2];\n  }\n\n  validateTarget(target);\n  validateEventType(type);\n  validateListener(listener);\n\n  listener = bind(self, listener);\n\n  return { isTargetingSelf: isTargetingSelf, target: target, type: type, listener: listener };\n};\n\n/**\n * Adds the listener to the event type(s) on the target, normalizing for\n * the type of target.\n *\n * @private\n * @param  {Element|Object} target\n *         A DOM node or evented object.\n *\n * @param  {string} method\n *         The event binding method to use (\"on\" or \"one\").\n *\n * @param  {string|Array} type\n *         One or more event type(s).\n *\n * @param  {Function} listener\n *         A listener function.\n */\nvar listen = function listen(target, method, type, listener) {\n  validateTarget(target);\n\n  if (target.nodeName) {\n    Events[method](target, type, listener);\n  } else {\n    target[method](type, listener);\n  }\n};\n\n/**\n * Contains methods that provide event capabilites to an object which is passed\n * to {@link module:evented|evented}.\n *\n * @mixin EventedMixin\n */\nvar EventedMixin = {\n\n  /**\n   * Add a listener to an event (or events) on this object or another evented\n   * object.\n   *\n   * @param  {string|Array|Element|Object} targetOrType\n   *         If this is a string or array, it represents the event type(s)\n   *         that will trigger the listener.\n   *\n   *         Another evented object can be passed here instead, which will\n   *         cause the listener to listen for events on _that_ object.\n   *\n   *         In either case, the listener's `this` value will be bound to\n   *         this object.\n   *\n   * @param  {string|Array|Function} typeOrListener\n   *         If the first argument was a string or array, this should be the\n   *         listener function. Otherwise, this is a string or array of event\n   *         type(s).\n   *\n   * @param  {Function} [listener]\n   *         If the first argument was another evented object, this will be\n   *         the listener function.\n   */\n  on: function on$$1() {\n    var _this = this;\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    var _normalizeListenArgs = normalizeListenArgs(this, args),\n        isTargetingSelf = _normalizeListenArgs.isTargetingSelf,\n        target = _normalizeListenArgs.target,\n        type = _normalizeListenArgs.type,\n        listener = _normalizeListenArgs.listener;\n\n    listen(target, 'on', type, listener);\n\n    // If this object is listening to another evented object.\n    if (!isTargetingSelf) {\n\n      // If this object is disposed, remove the listener.\n      var removeListenerOnDispose = function removeListenerOnDispose() {\n        return _this.off(target, type, listener);\n      };\n\n      // Use the same function ID as the listener so we can remove it later it\n      // using the ID of the original listener.\n      removeListenerOnDispose.guid = listener.guid;\n\n      // Add a listener to the target's dispose event as well. This ensures\n      // that if the target is disposed BEFORE this object, we remove the\n      // removal listener that was just added. Otherwise, we create a memory leak.\n      var removeRemoverOnTargetDispose = function removeRemoverOnTargetDispose() {\n        return _this.off('dispose', removeListenerOnDispose);\n      };\n\n      // Use the same function ID as the listener so we can remove it later\n      // it using the ID of the original listener.\n      removeRemoverOnTargetDispose.guid = listener.guid;\n\n      listen(this, 'on', 'dispose', removeListenerOnDispose);\n      listen(target, 'on', 'dispose', removeRemoverOnTargetDispose);\n    }\n  },\n\n\n  /**\n   * Add a listener to an event (or events) on this object or another evented\n   * object. The listener will only be called once and then removed.\n   *\n   * @param  {string|Array|Element|Object} targetOrType\n   *         If this is a string or array, it represents the event type(s)\n   *         that will trigger the listener.\n   *\n   *         Another evented object can be passed here instead, which will\n   *         cause the listener to listen for events on _that_ object.\n   *\n   *         In either case, the listener's `this` value will be bound to\n   *         this object.\n   *\n   * @param  {string|Array|Function} typeOrListener\n   *         If the first argument was a string or array, this should be the\n   *         listener function. Otherwise, this is a string or array of event\n   *         type(s).\n   *\n   * @param  {Function} [listener]\n   *         If the first argument was another evented object, this will be\n   *         the listener function.\n   */\n  one: function one$$1() {\n    var _this2 = this;\n\n    for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n\n    var _normalizeListenArgs2 = normalizeListenArgs(this, args),\n        isTargetingSelf = _normalizeListenArgs2.isTargetingSelf,\n        target = _normalizeListenArgs2.target,\n        type = _normalizeListenArgs2.type,\n        listener = _normalizeListenArgs2.listener;\n\n    // Targeting this evented object.\n\n\n    if (isTargetingSelf) {\n      listen(target, 'one', type, listener);\n\n      // Targeting another evented object.\n    } else {\n      var wrapper = function wrapper() {\n        for (var _len3 = arguments.length, largs = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n          largs[_key3] = arguments[_key3];\n        }\n\n        _this2.off(target, type, wrapper);\n        listener.apply(null, largs);\n      };\n\n      // Use the same function ID as the listener so we can remove it later\n      // it using the ID of the original listener.\n      wrapper.guid = listener.guid;\n      listen(target, 'one', type, wrapper);\n    }\n  },\n\n\n  /**\n   * Removes listener(s) from event(s) on an evented object.\n   *\n   * @param  {string|Array|Element|Object} [targetOrType]\n   *         If this is a string or array, it represents the event type(s).\n   *\n   *         Another evented object can be passed here instead, in which case\n   *         ALL 3 arguments are _required_.\n   *\n   * @param  {string|Array|Function} [typeOrListener]\n   *         If the first argument was a string or array, this may be the\n   *         listener function. Otherwise, this is a string or array of event\n   *         type(s).\n   *\n   * @param  {Function} [listener]\n   *         If the first argument was another evented object, this will be\n   *         the listener function; otherwise, _all_ listeners bound to the\n   *         event type(s) will be removed.\n   */\n  off: function off$$1(targetOrType, typeOrListener, listener) {\n\n    // Targeting this evented object.\n    if (!targetOrType || isValidEventType(targetOrType)) {\n      off(this.eventBusEl_, targetOrType, typeOrListener);\n\n      // Targeting another evented object.\n    } else {\n      var target = targetOrType;\n      var type = typeOrListener;\n\n      // Fail fast and in a meaningful way!\n      validateTarget(target);\n      validateEventType(type);\n      validateListener(listener);\n\n      // Ensure there's at least a guid, even if the function hasn't been used\n      listener = bind(this, listener);\n\n      // Remove the dispose listener on this evented object, which was given\n      // the same guid as the event listener in on().\n      this.off('dispose', listener);\n\n      if (target.nodeName) {\n        off(target, type, listener);\n        off(target, 'dispose', listener);\n      } else if (isEvented(target)) {\n        target.off(type, listener);\n        target.off('dispose', listener);\n      }\n    }\n  },\n\n\n  /**\n   * Fire an event on this evented object, causing its listeners to be called.\n   *\n   * @param   {string|Object} event\n   *          An event type or an object with a type property.\n   *\n   * @param   {Object} [hash]\n   *          An additional object to pass along to listeners.\n   *\n   * @returns {boolean}\n   *          Whether or not the default behavior was prevented.\n   */\n  trigger: function trigger$$1(event, hash) {\n    return trigger(this.eventBusEl_, event, hash);\n  }\n};\n\n/**\n * Applies {@link module:evented~EventedMixin|EventedMixin} to a target object.\n *\n * @param  {Object} target\n *         The object to which to add event methods.\n *\n * @param  {Object} [options={}]\n *         Options for customizing the mixin behavior.\n *\n * @param  {String} [options.eventBusKey]\n *         By default, adds a `eventBusEl_` DOM element to the target object,\n *         which is used as an event bus. If the target object already has a\n *         DOM element that should be used, pass its key here.\n *\n * @return {Object}\n *         The target object.\n */\nfunction evented(target) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var eventBusKey = options.eventBusKey;\n\n  // Set or create the eventBusEl_.\n\n  if (eventBusKey) {\n    if (!target[eventBusKey].nodeName) {\n      throw new Error('The eventBusKey \"' + eventBusKey + '\" does not refer to an element.');\n    }\n    target.eventBusEl_ = target[eventBusKey];\n  } else {\n    target.eventBusEl_ = createEl('span', { className: 'vjs-event-bus' });\n  }\n\n  assign(target, EventedMixin);\n\n  // When any evented object is disposed, it removes all its listeners.\n  target.on('dispose', function () {\n    target.off();\n    window.setTimeout(function () {\n      target.eventBusEl_ = null;\n    }, 0);\n  });\n\n  return target;\n}\n\n/**\n * @file mixins/stateful.js\n * @module stateful\n */\n/**\n * Contains methods that provide statefulness to an object which is passed\n * to {@link module:stateful}.\n *\n * @mixin StatefulMixin\n */\nvar StatefulMixin = {\n\n  /**\n   * A hash containing arbitrary keys and values representing the state of\n   * the object.\n   *\n   * @type {Object}\n   */\n  state: {},\n\n  /**\n   * Set the state of an object by mutating its\n   * {@link module:stateful~StatefulMixin.state|state} object in place.\n   *\n   * @fires   module:stateful~StatefulMixin#statechanged\n   * @param   {Object|Function} stateUpdates\n   *          A new set of properties to shallow-merge into the plugin state.\n   *          Can be a plain object or a function returning a plain object.\n   *\n   * @returns {Object|undefined}\n   *          An object containing changes that occurred. If no changes\n   *          occurred, returns `undefined`.\n   */\n  setState: function setState(stateUpdates) {\n    var _this = this;\n\n    // Support providing the `stateUpdates` state as a function.\n    if (typeof stateUpdates === 'function') {\n      stateUpdates = stateUpdates();\n    }\n\n    var changes = void 0;\n\n    each(stateUpdates, function (value, key) {\n\n      // Record the change if the value is different from what's in the\n      // current state.\n      if (_this.state[key] !== value) {\n        changes = changes || {};\n        changes[key] = {\n          from: _this.state[key],\n          to: value\n        };\n      }\n\n      _this.state[key] = value;\n    });\n\n    // Only trigger \"statechange\" if there were changes AND we have a trigger\n    // function. This allows us to not require that the target object be an\n    // evented object.\n    if (changes && isEvented(this)) {\n\n      /**\n       * An event triggered on an object that is both\n       * {@link module:stateful|stateful} and {@link module:evented|evented}\n       * indicating that its state has changed.\n       *\n       * @event    module:stateful~StatefulMixin#statechanged\n       * @type     {Object}\n       * @property {Object} changes\n       *           A hash containing the properties that were changed and\n       *           the values they were changed `from` and `to`.\n       */\n      this.trigger({\n        changes: changes,\n        type: 'statechanged'\n      });\n    }\n\n    return changes;\n  }\n};\n\n/**\n * Applies {@link module:stateful~StatefulMixin|StatefulMixin} to a target\n * object.\n *\n * If the target object is {@link module:evented|evented} and has a\n * `handleStateChanged` method, that method will be automatically bound to the\n * `statechanged` event on itself.\n *\n * @param   {Object} target\n *          The object to be made stateful.\n *\n * @param   {Object} [defaultState]\n *          A default set of properties to populate the newly-stateful object's\n *          `state` property.\n *\n * @returns {Object}\n *          Returns the `target`.\n */\nfunction stateful(target, defaultState) {\n  assign(target, StatefulMixin);\n\n  // This happens after the mixing-in because we need to replace the `state`\n  // added in that step.\n  target.state = assign({}, target.state, defaultState);\n\n  // Auto-bind the `handleStateChanged` method of the target object if it exists.\n  if (typeof target.handleStateChanged === 'function' && isEvented(target)) {\n    target.on('statechanged', target.handleStateChanged);\n  }\n\n  return target;\n}\n\n/**\n * @file to-title-case.js\n * @module to-title-case\n */\n\n/**\n * Uppercase the first letter of a string.\n *\n * @param {string} string\n *        String to be uppercased\n *\n * @return {string}\n *         The string with an uppercased first letter\n */\nfunction toTitleCase(string) {\n  if (typeof string !== 'string') {\n    return string;\n  }\n\n  return string.charAt(0).toUpperCase() + string.slice(1);\n}\n\n/**\n * Compares the TitleCase versions of the two strings for equality.\n *\n * @param {string} str1\n *        The first string to compare\n *\n * @param {string} str2\n *        The second string to compare\n *\n * @return {boolean}\n *         Whether the TitleCase versions of the strings are equal\n */\nfunction titleCaseEquals(str1, str2) {\n  return toTitleCase(str1) === toTitleCase(str2);\n}\n\n/**\n * @file merge-options.js\n * @module merge-options\n */\n/**\n * Deep-merge one or more options objects, recursively merging **only** plain\n * object properties.\n *\n * @param   {Object[]} sources\n *          One or more objects to merge into a new object.\n *\n * @returns {Object}\n *          A new object that is the merged result of all sources.\n */\nfunction mergeOptions() {\n  var result = {};\n\n  for (var _len = arguments.length, sources = Array(_len), _key = 0; _key < _len; _key++) {\n    sources[_key] = arguments[_key];\n  }\n\n  sources.forEach(function (source) {\n    if (!source) {\n      return;\n    }\n\n    each(source, function (value, key) {\n      if (!isPlain(value)) {\n        result[key] = value;\n        return;\n      }\n\n      if (!isPlain(result[key])) {\n        result[key] = {};\n      }\n\n      result[key] = mergeOptions(result[key], value);\n    });\n  });\n\n  return result;\n}\n\n/**\n * Player Component - Base class for all UI objects\n *\n * @file component.js\n */\n/**\n * Base class for all UI Components.\n * Components are UI objects which represent both a javascript object and an element\n * in the DOM. They can be children of other components, and can have\n * children themselves.\n *\n * Components can also use methods from {@link EventTarget}\n */\n\nvar Component = function () {\n\n  /**\n   * A callback that is called when a component is ready. Does not have any\n   * paramters and any callback value will be ignored.\n   *\n   * @callback Component~ReadyCallback\n   * @this Component\n   */\n\n  /**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   *\n   * @param {Object[]} [options.children]\n   *        An array of children objects to intialize this component with. Children objects have\n   *        a name property that will be used if more than one component of the same type needs to be\n   *        added.\n   *\n   * @param {Component~ReadyCallback} [ready]\n   *        Function that gets called when the `Component` is ready.\n   */\n  function Component(player, options, ready) {\n    classCallCheck(this, Component);\n\n\n    // The component might be the player itself and we can't pass `this` to super\n    if (!player && this.play) {\n      this.player_ = player = this; // eslint-disable-line\n    } else {\n      this.player_ = player;\n    }\n\n    // Make a copy of prototype.options_ to protect against overriding defaults\n    this.options_ = mergeOptions({}, this.options_);\n\n    // Updated options with supplied options\n    options = this.options_ = mergeOptions(this.options_, options);\n\n    // Get ID from options or options element if one is supplied\n    this.id_ = options.id || options.el && options.el.id;\n\n    // If there was no ID from the options, generate one\n    if (!this.id_) {\n      // Don't require the player ID function in the case of mock players\n      var id = player && player.id && player.id() || 'no_player';\n\n      this.id_ = id + '_component_' + newGUID();\n    }\n\n    this.name_ = options.name || null;\n\n    // Create element if one wasn't provided in options\n    if (options.el) {\n      this.el_ = options.el;\n    } else if (options.createEl !== false) {\n      this.el_ = this.createEl();\n    }\n\n    // if evented is anything except false, we want to mixin in evented\n    if (options.evented !== false) {\n      // Make this an evented object and use `el_`, if available, as its event bus\n      evented(this, { eventBusKey: this.el_ ? 'el_' : null });\n    }\n    stateful(this, this.constructor.defaultState);\n\n    this.children_ = [];\n    this.childIndex_ = {};\n    this.childNameIndex_ = {};\n\n    // Add any child components in options\n    if (options.initChildren !== false) {\n      this.initChildren();\n    }\n\n    this.ready(ready);\n    // Don't want to trigger ready here or it will before init is actually\n    // finished for all children that run this constructor\n\n    if (options.reportTouchActivity !== false) {\n      this.enableTouchActivity();\n    }\n  }\n\n  /**\n   * Dispose of the `Component` and all child components.\n   *\n   * @fires Component#dispose\n   */\n\n\n  Component.prototype.dispose = function dispose() {\n\n    /**\n     * Triggered when a `Component` is disposed.\n     *\n     * @event Component#dispose\n     * @type {EventTarget~Event}\n     *\n     * @property {boolean} [bubbles=false]\n     *           set to false so that the close event does not\n     *           bubble up\n     */\n    this.trigger({ type: 'dispose', bubbles: false });\n\n    // Dispose all children.\n    if (this.children_) {\n      for (var i = this.children_.length - 1; i >= 0; i--) {\n        if (this.children_[i].dispose) {\n          this.children_[i].dispose();\n        }\n      }\n    }\n\n    // Delete child references\n    this.children_ = null;\n    this.childIndex_ = null;\n    this.childNameIndex_ = null;\n\n    if (this.el_) {\n      // Remove element from DOM\n      if (this.el_.parentNode) {\n        this.el_.parentNode.removeChild(this.el_);\n      }\n\n      removeData(this.el_);\n      this.el_ = null;\n    }\n\n    // remove reference to the player after disposing of the element\n    this.player_ = null;\n  };\n\n  /**\n   * Return the {@link Player} that the `Component` has attached to.\n   *\n   * @return {Player}\n   *         The player that this `Component` has attached to.\n   */\n\n\n  Component.prototype.player = function player() {\n    return this.player_;\n  };\n\n  /**\n   * Deep merge of options objects with new options.\n   * > Note: When both `obj` and `options` contain properties whose values are objects.\n   *         The two properties get merged using {@link module:mergeOptions}\n   *\n   * @param {Object} obj\n   *        The object that contains new options.\n   *\n   * @return {Object}\n   *         A new object of `this.options_` and `obj` merged together.\n   *\n   * @deprecated since version 5\n   */\n\n\n  Component.prototype.options = function options(obj) {\n    log.warn('this.options() has been deprecated and will be moved to the constructor in 6.0');\n\n    if (!obj) {\n      return this.options_;\n    }\n\n    this.options_ = mergeOptions(this.options_, obj);\n    return this.options_;\n  };\n\n  /**\n   * Get the `Component`s DOM element\n   *\n   * @return {Element}\n   *         The DOM element for this `Component`.\n   */\n\n\n  Component.prototype.el = function el() {\n    return this.el_;\n  };\n\n  /**\n   * Create the `Component`s DOM element.\n   *\n   * @param {string} [tagName]\n   *        Element's DOM node type. e.g. 'div'\n   *\n   * @param {Object} [properties]\n   *        An object of properties that should be set.\n   *\n   * @param {Object} [attributes]\n   *        An object of attributes that should be set.\n   *\n   * @return {Element}\n   *         The element that gets created.\n   */\n\n\n  Component.prototype.createEl = function createEl$$1(tagName, properties, attributes) {\n    return createEl(tagName, properties, attributes);\n  };\n\n  /**\n   * Localize a string given the string in english.\n   *\n   * If tokens are provided, it'll try and run a simple token replacement on the provided string.\n   * The tokens it looks for look like `{1}` with the index being 1-indexed into the tokens array.\n   *\n   * If a `defaultValue` is provided, it'll use that over `string`,\n   * if a value isn't found in provided language files.\n   * This is useful if you want to have a descriptive key for token replacement\n   * but have a succinct localized string and not require `en.json` to be included.\n   *\n   * Currently, it is used for the progress bar timing.\n   * ```js\n   * {\n   *   \"progress bar timing: currentTime={1} duration={2}\": \"{1} of {2}\"\n   * }\n   * ```\n   * It is then used like so:\n   * ```js\n   * this.localize('progress bar timing: currentTime={1} duration{2}',\n   *               [this.player_.currentTime(), this.player_.duration()],\n   *               '{1} of {2}');\n   * ```\n   *\n   * Which outputs something like: `01:23 of 24:56`.\n   *\n   *\n   * @param {string} string\n   *        The string to localize and the key to lookup in the language files.\n   * @param {string[]} [tokens]\n   *        If the current item has token replacements, provide the tokens here.\n   * @param {string} [defaultValue]\n   *        Defaults to `string`. Can be a default value to use for token replacement\n   *        if the lookup key is needed to be separate.\n   *\n   * @return {string}\n   *         The localized string or if no localization exists the english string.\n   */\n\n\n  Component.prototype.localize = function localize(string, tokens) {\n    var defaultValue = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : string;\n\n    var code = this.player_.language && this.player_.language();\n    var languages = this.player_.languages && this.player_.languages();\n    var language = languages && languages[code];\n    var primaryCode = code && code.split('-')[0];\n    var primaryLang = languages && languages[primaryCode];\n\n    var localizedString = defaultValue;\n\n    if (language && language[string]) {\n      localizedString = language[string];\n    } else if (primaryLang && primaryLang[string]) {\n      localizedString = primaryLang[string];\n    }\n\n    if (tokens) {\n      localizedString = localizedString.replace(/\\{(\\d+)\\}/g, function (match, index) {\n        var value = tokens[index - 1];\n        var ret = value;\n\n        if (typeof value === 'undefined') {\n          ret = match;\n        }\n\n        return ret;\n      });\n    }\n\n    return localizedString;\n  };\n\n  /**\n   * Return the `Component`s DOM element. This is where children get inserted.\n   * This will usually be the the same as the element returned in {@link Component#el}.\n   *\n   * @return {Element}\n   *         The content element for this `Component`.\n   */\n\n\n  Component.prototype.contentEl = function contentEl() {\n    return this.contentEl_ || this.el_;\n  };\n\n  /**\n   * Get this `Component`s ID\n   *\n   * @return {string}\n   *         The id of this `Component`\n   */\n\n\n  Component.prototype.id = function id() {\n    return this.id_;\n  };\n\n  /**\n   * Get the `Component`s name. The name gets used to reference the `Component`\n   * and is set during registration.\n   *\n   * @return {string}\n   *         The name of this `Component`.\n   */\n\n\n  Component.prototype.name = function name() {\n    return this.name_;\n  };\n\n  /**\n   * Get an array of all child components\n   *\n   * @return {Array}\n   *         The children\n   */\n\n\n  Component.prototype.children = function children() {\n    return this.children_;\n  };\n\n  /**\n   * Returns the child `Component` with the given `id`.\n   *\n   * @param {string} id\n   *        The id of the child `Component` to get.\n   *\n   * @return {Component|undefined}\n   *         The child `Component` with the given `id` or undefined.\n   */\n\n\n  Component.prototype.getChildById = function getChildById(id) {\n    return this.childIndex_[id];\n  };\n\n  /**\n   * Returns the child `Component` with the given `name`.\n   *\n   * @param {string} name\n   *        The name of the child `Component` to get.\n   *\n   * @return {Component|undefined}\n   *         The child `Component` with the given `name` or undefined.\n   */\n\n\n  Component.prototype.getChild = function getChild(name) {\n    if (!name) {\n      return;\n    }\n\n    name = toTitleCase(name);\n\n    return this.childNameIndex_[name];\n  };\n\n  /**\n   * Add a child `Component` inside the current `Component`.\n   *\n   *\n   * @param {string|Component} child\n   *        The name or instance of a child to add.\n   *\n   * @param {Object} [options={}]\n   *        The key/value store of options that will get passed to children of\n   *        the child.\n   *\n   * @param {number} [index=this.children_.length]\n   *        The index to attempt to add a child into.\n   *\n   * @return {Component}\n   *         The `Component` that gets added as a child. When using a string the\n   *         `Component` will get created by this process.\n   */\n\n\n  Component.prototype.addChild = function addChild(child) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var index = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.children_.length;\n\n    var component = void 0;\n    var componentName = void 0;\n\n    // If child is a string, create component with options\n    if (typeof child === 'string') {\n      componentName = toTitleCase(child);\n\n      var componentClassName = options.componentClass || componentName;\n\n      // Set name through options\n      options.name = componentName;\n\n      // Create a new object & element for this controls set\n      // If there's no .player_, this is a player\n      var ComponentClass = Component.getComponent(componentClassName);\n\n      if (!ComponentClass) {\n        throw new Error('Component ' + componentClassName + ' does not exist');\n      }\n\n      // data stored directly on the videojs object may be\n      // misidentified as a component to retain\n      // backwards-compatibility with 4.x. check to make sure the\n      // component class can be instantiated.\n      if (typeof ComponentClass !== 'function') {\n        return null;\n      }\n\n      component = new ComponentClass(this.player_ || this, options);\n\n      // child is a component instance\n    } else {\n      component = child;\n    }\n\n    this.children_.splice(index, 0, component);\n\n    if (typeof component.id === 'function') {\n      this.childIndex_[component.id()] = component;\n    }\n\n    // If a name wasn't used to create the component, check if we can use the\n    // name function of the component\n    componentName = componentName || component.name && toTitleCase(component.name());\n\n    if (componentName) {\n      this.childNameIndex_[componentName] = component;\n    }\n\n    // Add the UI object's element to the container div (box)\n    // Having an element is not required\n    if (typeof component.el === 'function' && component.el()) {\n      var childNodes = this.contentEl().children;\n      var refNode = childNodes[index] || null;\n\n      this.contentEl().insertBefore(component.el(), refNode);\n    }\n\n    // Return so it can stored on parent object if desired.\n    return component;\n  };\n\n  /**\n   * Remove a child `Component` from this `Component`s list of children. Also removes\n   * the child `Component`s element from this `Component`s element.\n   *\n   * @param {Component} component\n   *        The child `Component` to remove.\n   */\n\n\n  Component.prototype.removeChild = function removeChild(component) {\n    if (typeof component === 'string') {\n      component = this.getChild(component);\n    }\n\n    if (!component || !this.children_) {\n      return;\n    }\n\n    var childFound = false;\n\n    for (var i = this.children_.length - 1; i >= 0; i--) {\n      if (this.children_[i] === component) {\n        childFound = true;\n        this.children_.splice(i, 1);\n        break;\n      }\n    }\n\n    if (!childFound) {\n      return;\n    }\n\n    this.childIndex_[component.id()] = null;\n    this.childNameIndex_[component.name()] = null;\n\n    var compEl = component.el();\n\n    if (compEl && compEl.parentNode === this.contentEl()) {\n      this.contentEl().removeChild(component.el());\n    }\n  };\n\n  /**\n   * Add and initialize default child `Component`s based upon options.\n   */\n\n\n  Component.prototype.initChildren = function initChildren() {\n    var _this = this;\n\n    var children = this.options_.children;\n\n    if (children) {\n      // `this` is `parent`\n      var parentOptions = this.options_;\n\n      var handleAdd = function handleAdd(child) {\n        var name = child.name;\n        var opts = child.opts;\n\n        // Allow options for children to be set at the parent options\n        // e.g. videojs(id, { controlBar: false });\n        // instead of videojs(id, { children: { controlBar: false });\n        if (parentOptions[name] !== undefined) {\n          opts = parentOptions[name];\n        }\n\n        // Allow for disabling default components\n        // e.g. options['children']['posterImage'] = false\n        if (opts === false) {\n          return;\n        }\n\n        // Allow options to be passed as a simple boolean if no configuration\n        // is necessary.\n        if (opts === true) {\n          opts = {};\n        }\n\n        // We also want to pass the original player options\n        // to each component as well so they don't need to\n        // reach back into the player for options later.\n        opts.playerOptions = _this.options_.playerOptions;\n\n        // Create and add the child component.\n        // Add a direct reference to the child by name on the parent instance.\n        // If two of the same component are used, different names should be supplied\n        // for each\n        var newChild = _this.addChild(name, opts);\n\n        if (newChild) {\n          _this[name] = newChild;\n        }\n      };\n\n      // Allow for an array of children details to passed in the options\n      var workingChildren = void 0;\n      var Tech = Component.getComponent('Tech');\n\n      if (Array.isArray(children)) {\n        workingChildren = children;\n      } else {\n        workingChildren = Object.keys(children);\n      }\n\n      workingChildren\n      // children that are in this.options_ but also in workingChildren  would\n      // give us extra children we do not want. So, we want to filter them out.\n      .concat(Object.keys(this.options_).filter(function (child) {\n        return !workingChildren.some(function (wchild) {\n          if (typeof wchild === 'string') {\n            return child === wchild;\n          }\n          return child === wchild.name;\n        });\n      })).map(function (child) {\n        var name = void 0;\n        var opts = void 0;\n\n        if (typeof child === 'string') {\n          name = child;\n          opts = children[name] || _this.options_[name] || {};\n        } else {\n          name = child.name;\n          opts = child;\n        }\n\n        return { name: name, opts: opts };\n      }).filter(function (child) {\n        // we have to make sure that child.name isn't in the techOrder since\n        // techs are registerd as Components but can't aren't compatible\n        // See https://github.com/videojs/video.js/issues/2772\n        var c = Component.getComponent(child.opts.componentClass || toTitleCase(child.name));\n\n        return c && !Tech.isTech(c);\n      }).forEach(handleAdd);\n    }\n  };\n\n  /**\n   * Builds the default DOM class name. Should be overriden by sub-components.\n   *\n   * @return {string}\n   *         The DOM class name for this object.\n   *\n   * @abstract\n   */\n\n\n  Component.prototype.buildCSSClass = function buildCSSClass() {\n    // Child classes can include a function that does:\n    // return 'CLASS NAME' + this._super();\n    return '';\n  };\n\n  /**\n   * Bind a listener to the component's ready state.\n   * Different from event listeners in that if the ready event has already happened\n   * it will trigger the function immediately.\n   *\n   * @return {Component}\n   *         Returns itself; method can be chained.\n   */\n\n\n  Component.prototype.ready = function ready(fn) {\n    var sync = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n    if (!fn) {\n      return;\n    }\n\n    if (!this.isReady_) {\n      this.readyQueue_ = this.readyQueue_ || [];\n      this.readyQueue_.push(fn);\n      return;\n    }\n\n    if (sync) {\n      fn.call(this);\n    } else {\n      // Call the function asynchronously by default for consistency\n      this.setTimeout(fn, 1);\n    }\n  };\n\n  /**\n   * Trigger all the ready listeners for this `Component`.\n   *\n   * @fires Component#ready\n   */\n\n\n  Component.prototype.triggerReady = function triggerReady() {\n    this.isReady_ = true;\n\n    // Ensure ready is triggered asynchronously\n    this.setTimeout(function () {\n      var readyQueue = this.readyQueue_;\n\n      // Reset Ready Queue\n      this.readyQueue_ = [];\n\n      if (readyQueue && readyQueue.length > 0) {\n        readyQueue.forEach(function (fn) {\n          fn.call(this);\n        }, this);\n      }\n\n      // Allow for using event listeners also\n      /**\n       * Triggered when a `Component` is ready.\n       *\n       * @event Component#ready\n       * @type {EventTarget~Event}\n       */\n      this.trigger('ready');\n    }, 1);\n  };\n\n  /**\n   * Find a single DOM element matching a `selector`. This can be within the `Component`s\n   * `contentEl()` or another custom context.\n   *\n   * @param {string} selector\n   *        A valid CSS selector, which will be passed to `querySelector`.\n   *\n   * @param {Element|string} [context=this.contentEl()]\n   *        A DOM element within which to query. Can also be a selector string in\n   *        which case the first matching element will get used as context. If\n   *        missing `this.contentEl()` gets used. If  `this.contentEl()` returns\n   *        nothing it falls back to `document`.\n   *\n   * @return {Element|null}\n   *         the dom element that was found, or null\n   *\n   * @see [Information on CSS Selectors](https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Getting_Started/Selectors)\n   */\n\n\n  Component.prototype.$ = function $$$1(selector, context) {\n    return $(selector, context || this.contentEl());\n  };\n\n  /**\n   * Finds all DOM element matching a `selector`. This can be within the `Component`s\n   * `contentEl()` or another custom context.\n   *\n   * @param {string} selector\n   *        A valid CSS selector, which will be passed to `querySelectorAll`.\n   *\n   * @param {Element|string} [context=this.contentEl()]\n   *        A DOM element within which to query. Can also be a selector string in\n   *        which case the first matching element will get used as context. If\n   *        missing `this.contentEl()` gets used. If  `this.contentEl()` returns\n   *        nothing it falls back to `document`.\n   *\n   * @return {NodeList}\n   *         a list of dom elements that were found\n   *\n   * @see [Information on CSS Selectors](https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Getting_Started/Selectors)\n   */\n\n\n  Component.prototype.$$ = function $$$$1(selector, context) {\n    return $$(selector, context || this.contentEl());\n  };\n\n  /**\n   * Check if a component's element has a CSS class name.\n   *\n   * @param {string} classToCheck\n   *        CSS class name to check.\n   *\n   * @return {boolean}\n   *         - True if the `Component` has the class.\n   *         - False if the `Component` does not have the class`\n   */\n\n\n  Component.prototype.hasClass = function hasClass$$1(classToCheck) {\n    return hasClass(this.el_, classToCheck);\n  };\n\n  /**\n   * Add a CSS class name to the `Component`s element.\n   *\n   * @param {string} classToAdd\n   *        CSS class name to add\n   */\n\n\n  Component.prototype.addClass = function addClass$$1(classToAdd) {\n    addClass(this.el_, classToAdd);\n  };\n\n  /**\n   * Remove a CSS class name from the `Component`s element.\n   *\n   * @param {string} classToRemove\n   *        CSS class name to remove\n   */\n\n\n  Component.prototype.removeClass = function removeClass$$1(classToRemove) {\n    removeClass(this.el_, classToRemove);\n  };\n\n  /**\n   * Add or remove a CSS class name from the component's element.\n   * - `classToToggle` gets added when {@link Component#hasClass} would return false.\n   * - `classToToggle` gets removed when {@link Component#hasClass} would return true.\n   *\n   * @param  {string} classToToggle\n   *         The class to add or remove based on (@link Component#hasClass}\n   *\n   * @param  {boolean|Dom~predicate} [predicate]\n   *         An {@link Dom~predicate} function or a boolean\n   */\n\n\n  Component.prototype.toggleClass = function toggleClass$$1(classToToggle, predicate) {\n    toggleClass(this.el_, classToToggle, predicate);\n  };\n\n  /**\n   * Show the `Component`s element if it is hidden by removing the\n   * 'vjs-hidden' class name from it.\n   */\n\n\n  Component.prototype.show = function show() {\n    this.removeClass('vjs-hidden');\n  };\n\n  /**\n   * Hide the `Component`s element if it is currently showing by adding the\n   * 'vjs-hidden` class name to it.\n   */\n\n\n  Component.prototype.hide = function hide() {\n    this.addClass('vjs-hidden');\n  };\n\n  /**\n   * Lock a `Component`s element in its visible state by adding the 'vjs-lock-showing'\n   * class name to it. Used during fadeIn/fadeOut.\n   *\n   * @private\n   */\n\n\n  Component.prototype.lockShowing = function lockShowing() {\n    this.addClass('vjs-lock-showing');\n  };\n\n  /**\n   * Unlock a `Component`s element from its visible state by removing the 'vjs-lock-showing'\n   * class name from it. Used during fadeIn/fadeOut.\n   *\n   * @private\n   */\n\n\n  Component.prototype.unlockShowing = function unlockShowing() {\n    this.removeClass('vjs-lock-showing');\n  };\n\n  /**\n   * Get the value of an attribute on the `Component`s element.\n   *\n   * @param {string} attribute\n   *        Name of the attribute to get the value from.\n   *\n   * @return {string|null}\n   *         - The value of the attribute that was asked for.\n   *         - Can be an empty string on some browsers if the attribute does not exist\n   *           or has no value\n   *         - Most browsers will return null if the attibute does not exist or has\n   *           no value.\n   *\n   * @see [DOM API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Element/getAttribute}\n   */\n\n\n  Component.prototype.getAttribute = function getAttribute$$1(attribute) {\n    return getAttribute(this.el_, attribute);\n  };\n\n  /**\n   * Set the value of an attribute on the `Component`'s element\n   *\n   * @param {string} attribute\n   *        Name of the attribute to set.\n   *\n   * @param {string} value\n   *        Value to set the attribute to.\n   *\n   * @see [DOM API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Element/setAttribute}\n   */\n\n\n  Component.prototype.setAttribute = function setAttribute$$1(attribute, value) {\n    setAttribute(this.el_, attribute, value);\n  };\n\n  /**\n   * Remove an attribute from the `Component`s element.\n   *\n   * @param {string} attribute\n   *        Name of the attribute to remove.\n   *\n   * @see [DOM API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Element/removeAttribute}\n   */\n\n\n  Component.prototype.removeAttribute = function removeAttribute$$1(attribute) {\n    removeAttribute(this.el_, attribute);\n  };\n\n  /**\n   * Get or set the width of the component based upon the CSS styles.\n   * See {@link Component#dimension} for more detailed information.\n   *\n   * @param {number|string} [num]\n   *        The width that you want to set postfixed with '%', 'px' or nothing.\n   *\n   * @param {boolean} [skipListeners]\n   *        Skip the componentresize event trigger\n   *\n   * @return {number|string}\n   *         The width when getting, zero if there is no width. Can be a string\n   *           postpixed with '%' or 'px'.\n   */\n\n\n  Component.prototype.width = function width(num, skipListeners) {\n    return this.dimension('width', num, skipListeners);\n  };\n\n  /**\n   * Get or set the height of the component based upon the CSS styles.\n   * See {@link Component#dimension} for more detailed information.\n   *\n   * @param {number|string} [num]\n   *        The height that you want to set postfixed with '%', 'px' or nothing.\n   *\n   * @param {boolean} [skipListeners]\n   *        Skip the componentresize event trigger\n   *\n   * @return {number|string}\n   *         The width when getting, zero if there is no width. Can be a string\n   *         postpixed with '%' or 'px'.\n   */\n\n\n  Component.prototype.height = function height(num, skipListeners) {\n    return this.dimension('height', num, skipListeners);\n  };\n\n  /**\n   * Set both the width and height of the `Component` element at the same time.\n   *\n   * @param  {number|string} width\n   *         Width to set the `Component`s element to.\n   *\n   * @param  {number|string} height\n   *         Height to set the `Component`s element to.\n   */\n\n\n  Component.prototype.dimensions = function dimensions(width, height) {\n    // Skip componentresize listeners on width for optimization\n    this.width(width, true);\n    this.height(height);\n  };\n\n  /**\n   * Get or set width or height of the `Component` element. This is the shared code\n   * for the {@link Component#width} and {@link Component#height}.\n   *\n   * Things to know:\n   * - If the width or height in an number this will return the number postfixed with 'px'.\n   * - If the width/height is a percent this will return the percent postfixed with '%'\n   * - Hidden elements have a width of 0 with `window.getComputedStyle`. This function\n   *   defaults to the `Component`s `style.width` and falls back to `window.getComputedStyle`.\n   *   See [this]{@link http://www.foliotek.com/devblog/getting-the-width-of-a-hidden-element-with-jquery-using-width/}\n   *   for more information\n   * - If you want the computed style of the component, use {@link Component#currentWidth}\n   *   and {@link {Component#currentHeight}\n   *\n   * @fires Component#componentresize\n   *\n   * @param {string} widthOrHeight\n   8        'width' or 'height'\n   *\n   * @param  {number|string} [num]\n   8         New dimension\n   *\n   * @param  {boolean} [skipListeners]\n   *         Skip componentresize event trigger\n   *\n   * @return {number}\n   *         The dimension when getting or 0 if unset\n   */\n\n\n  Component.prototype.dimension = function dimension(widthOrHeight, num, skipListeners) {\n    if (num !== undefined) {\n      // Set to zero if null or literally NaN (NaN !== NaN)\n      if (num === null || num !== num) {\n        num = 0;\n      }\n\n      // Check if using css width/height (% or px) and adjust\n      if (('' + num).indexOf('%') !== -1 || ('' + num).indexOf('px') !== -1) {\n        this.el_.style[widthOrHeight] = num;\n      } else if (num === 'auto') {\n        this.el_.style[widthOrHeight] = '';\n      } else {\n        this.el_.style[widthOrHeight] = num + 'px';\n      }\n\n      // skipListeners allows us to avoid triggering the resize event when setting both width and height\n      if (!skipListeners) {\n        /**\n         * Triggered when a component is resized.\n         *\n         * @event Component#componentresize\n         * @type {EventTarget~Event}\n         */\n        this.trigger('componentresize');\n      }\n\n      return;\n    }\n\n    // Not setting a value, so getting it\n    // Make sure element exists\n    if (!this.el_) {\n      return 0;\n    }\n\n    // Get dimension value from style\n    var val = this.el_.style[widthOrHeight];\n    var pxIndex = val.indexOf('px');\n\n    if (pxIndex !== -1) {\n      // Return the pixel value with no 'px'\n      return parseInt(val.slice(0, pxIndex), 10);\n    }\n\n    // No px so using % or no style was set, so falling back to offsetWidth/height\n    // If component has display:none, offset will return 0\n    // TODO: handle display:none and no dimension style using px\n    return parseInt(this.el_['offset' + toTitleCase(widthOrHeight)], 10);\n  };\n\n  /**\n   * Get the computed width or the height of the component's element.\n   *\n   * Uses `window.getComputedStyle`.\n   *\n   * @param {string} widthOrHeight\n   *        A string containing 'width' or 'height'. Whichever one you want to get.\n   *\n   * @return {number}\n   *         The dimension that gets asked for or 0 if nothing was set\n   *         for that dimension.\n   */\n\n\n  Component.prototype.currentDimension = function currentDimension(widthOrHeight) {\n    var computedWidthOrHeight = 0;\n\n    if (widthOrHeight !== 'width' && widthOrHeight !== 'height') {\n      throw new Error('currentDimension only accepts width or height value');\n    }\n\n    if (typeof window.getComputedStyle === 'function') {\n      var computedStyle = window.getComputedStyle(this.el_);\n\n      computedWidthOrHeight = computedStyle.getPropertyValue(widthOrHeight) || computedStyle[widthOrHeight];\n    }\n\n    // remove 'px' from variable and parse as integer\n    computedWidthOrHeight = parseFloat(computedWidthOrHeight);\n\n    // if the computed value is still 0, it's possible that the browser is lying\n    // and we want to check the offset values.\n    // This code also runs on IE8 and wherever getComputedStyle doesn't exist.\n    if (computedWidthOrHeight === 0) {\n      var rule = 'offset' + toTitleCase(widthOrHeight);\n\n      computedWidthOrHeight = this.el_[rule];\n    }\n\n    return computedWidthOrHeight;\n  };\n\n  /**\n   * An object that contains width and height values of the `Component`s\n   * computed style. Uses `window.getComputedStyle`.\n   *\n   * @typedef {Object} Component~DimensionObject\n   *\n   * @property {number} width\n   *           The width of the `Component`s computed style.\n   *\n   * @property {number} height\n   *           The height of the `Component`s computed style.\n   */\n\n  /**\n   * Get an object that contains computed width and height values of the\n   * component's element.\n   *\n   * Uses `window.getComputedStyle`.\n   *\n   * @return {Component~DimensionObject}\n   *         The computed dimensions of the component's element.\n   */\n\n\n  Component.prototype.currentDimensions = function currentDimensions() {\n    return {\n      width: this.currentDimension('width'),\n      height: this.currentDimension('height')\n    };\n  };\n\n  /**\n   * Get the computed width of the component's element.\n   *\n   * Uses `window.getComputedStyle`.\n   *\n   * @return {number}\n   *         The computed width of the component's element.\n   */\n\n\n  Component.prototype.currentWidth = function currentWidth() {\n    return this.currentDimension('width');\n  };\n\n  /**\n   * Get the computed height of the component's element.\n   *\n   * Uses `window.getComputedStyle`.\n   *\n   * @return {number}\n   *         The computed height of the component's element.\n   */\n\n\n  Component.prototype.currentHeight = function currentHeight() {\n    return this.currentDimension('height');\n  };\n\n  /**\n   * Set the focus to this component\n   */\n\n\n  Component.prototype.focus = function focus() {\n    this.el_.focus();\n  };\n\n  /**\n   * Remove the focus from this component\n   */\n\n\n  Component.prototype.blur = function blur() {\n    this.el_.blur();\n  };\n\n  /**\n   * Emit a 'tap' events when touch event support gets detected. This gets used to\n   * support toggling the controls through a tap on the video. They get enabled\n   * because every sub-component would have extra overhead otherwise.\n   *\n   * @private\n   * @fires Component#tap\n   * @listens Component#touchstart\n   * @listens Component#touchmove\n   * @listens Component#touchleave\n   * @listens Component#touchcancel\n   * @listens Component#touchend\n    */\n\n\n  Component.prototype.emitTapEvents = function emitTapEvents() {\n    // Track the start time so we can determine how long the touch lasted\n    var touchStart = 0;\n    var firstTouch = null;\n\n    // Maximum movement allowed during a touch event to still be considered a tap\n    // Other popular libs use anywhere from 2 (hammer.js) to 15,\n    // so 10 seems like a nice, round number.\n    var tapMovementThreshold = 10;\n\n    // The maximum length a touch can be while still being considered a tap\n    var touchTimeThreshold = 200;\n\n    var couldBeTap = void 0;\n\n    this.on('touchstart', function (event) {\n      // If more than one finger, don't consider treating this as a click\n      if (event.touches.length === 1) {\n        // Copy pageX/pageY from the object\n        firstTouch = {\n          pageX: event.touches[0].pageX,\n          pageY: event.touches[0].pageY\n        };\n        // Record start time so we can detect a tap vs. \"touch and hold\"\n        touchStart = new Date().getTime();\n        // Reset couldBeTap tracking\n        couldBeTap = true;\n      }\n    });\n\n    this.on('touchmove', function (event) {\n      // If more than one finger, don't consider treating this as a click\n      if (event.touches.length > 1) {\n        couldBeTap = false;\n      } else if (firstTouch) {\n        // Some devices will throw touchmoves for all but the slightest of taps.\n        // So, if we moved only a small distance, this could still be a tap\n        var xdiff = event.touches[0].pageX - firstTouch.pageX;\n        var ydiff = event.touches[0].pageY - firstTouch.pageY;\n        var touchDistance = Math.sqrt(xdiff * xdiff + ydiff * ydiff);\n\n        if (touchDistance > tapMovementThreshold) {\n          couldBeTap = false;\n        }\n      }\n    });\n\n    var noTap = function noTap() {\n      couldBeTap = false;\n    };\n\n    // TODO: Listen to the original target. http://youtu.be/DujfpXOKUp8?t=13m8s\n    this.on('touchleave', noTap);\n    this.on('touchcancel', noTap);\n\n    // When the touch ends, measure how long it took and trigger the appropriate\n    // event\n    this.on('touchend', function (event) {\n      firstTouch = null;\n      // Proceed only if the touchmove/leave/cancel event didn't happen\n      if (couldBeTap === true) {\n        // Measure how long the touch lasted\n        var touchTime = new Date().getTime() - touchStart;\n\n        // Make sure the touch was less than the threshold to be considered a tap\n        if (touchTime < touchTimeThreshold) {\n          // Don't let browser turn this into a click\n          event.preventDefault();\n          /**\n           * Triggered when a `Component` is tapped.\n           *\n           * @event Component#tap\n           * @type {EventTarget~Event}\n           */\n          this.trigger('tap');\n          // It may be good to copy the touchend event object and change the\n          // type to tap, if the other event properties aren't exact after\n          // Events.fixEvent runs (e.g. event.target)\n        }\n      }\n    });\n  };\n\n  /**\n   * This function reports user activity whenever touch events happen. This can get\n   * turned off by any sub-components that wants touch events to act another way.\n   *\n   * Report user touch activity when touch events occur. User activity gets used to\n   * determine when controls should show/hide. It is simple when it comes to mouse\n   * events, because any mouse event should show the controls. So we capture mouse\n   * events that bubble up to the player and report activity when that happens.\n   * With touch events it isn't as easy as `touchstart` and `touchend` toggle player\n   * controls. So touch events can't help us at the player level either.\n   *\n   * User activity gets checked asynchronously. So what could happen is a tap event\n   * on the video turns the controls off. Then the `touchend` event bubbles up to\n   * the player. Which, if it reported user activity, would turn the controls right\n   * back on. We also don't want to completely block touch events from bubbling up.\n   * Furthermore a `touchmove` event and anything other than a tap, should not turn\n   * controls back on.\n   *\n   * @listens Component#touchstart\n   * @listens Component#touchmove\n   * @listens Component#touchend\n   * @listens Component#touchcancel\n   */\n\n\n  Component.prototype.enableTouchActivity = function enableTouchActivity() {\n    // Don't continue if the root player doesn't support reporting user activity\n    if (!this.player() || !this.player().reportUserActivity) {\n      return;\n    }\n\n    // listener for reporting that the user is active\n    var report = bind(this.player(), this.player().reportUserActivity);\n\n    var touchHolding = void 0;\n\n    this.on('touchstart', function () {\n      report();\n      // For as long as the they are touching the device or have their mouse down,\n      // we consider them active even if they're not moving their finger or mouse.\n      // So we want to continue to update that they are active\n      this.clearInterval(touchHolding);\n      // report at the same interval as activityCheck\n      touchHolding = this.setInterval(report, 250);\n    });\n\n    var touchEnd = function touchEnd(event) {\n      report();\n      // stop the interval that maintains activity if the touch is holding\n      this.clearInterval(touchHolding);\n    };\n\n    this.on('touchmove', report);\n    this.on('touchend', touchEnd);\n    this.on('touchcancel', touchEnd);\n  };\n\n  /**\n   * A callback that has no parameters and is bound into `Component`s context.\n   *\n   * @callback Component~GenericCallback\n   * @this Component\n   */\n\n  /**\n   * Creates a function that runs after an `x` millisecond timeout. This function is a\n   * wrapper around `window.setTimeout`. There are a few reasons to use this one\n   * instead though:\n   * 1. It gets cleared via  {@link Component#clearTimeout} when\n   *    {@link Component#dispose} gets called.\n   * 2. The function callback will gets turned into a {@link Component~GenericCallback}\n   *\n   * > Note: You can't use `window.clearTimeout` on the id returned by this function. This\n   *         will cause its dispose listener not to get cleaned up! Please use\n   *         {@link Component#clearTimeout} or {@link Component#dispose} instead.\n   *\n   * @param {Component~GenericCallback} fn\n   *        The function that will be run after `timeout`.\n   *\n   * @param {number} timeout\n   *        Timeout in milliseconds to delay before executing the specified function.\n   *\n   * @return {number}\n   *         Returns a timeout ID that gets used to identify the timeout. It can also\n   *         get used in {@link Component#clearTimeout} to clear the timeout that\n   *         was set.\n   *\n   * @listens Component#dispose\n   * @see [Similar to]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/setTimeout}\n   */\n\n\n  Component.prototype.setTimeout = function setTimeout(fn, timeout) {\n    var _this2 = this;\n\n    // declare as variables so they are properly available in timeout function\n    // eslint-disable-next-line\n    var timeoutId, disposeFn;\n\n    fn = bind(this, fn);\n\n    timeoutId = window.setTimeout(function () {\n      _this2.off('dispose', disposeFn);\n      fn();\n    }, timeout);\n\n    disposeFn = function disposeFn() {\n      return _this2.clearTimeout(timeoutId);\n    };\n\n    disposeFn.guid = 'vjs-timeout-' + timeoutId;\n\n    this.on('dispose', disposeFn);\n\n    return timeoutId;\n  };\n\n  /**\n   * Clears a timeout that gets created via `window.setTimeout` or\n   * {@link Component#setTimeout}. If you set a timeout via {@link Component#setTimeout}\n   * use this function instead of `window.clearTimout`. If you don't your dispose\n   * listener will not get cleaned up until {@link Component#dispose}!\n   *\n   * @param {number} timeoutId\n   *        The id of the timeout to clear. The return value of\n   *        {@link Component#setTimeout} or `window.setTimeout`.\n   *\n   * @return {number}\n   *         Returns the timeout id that was cleared.\n   *\n   * @see [Similar to]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/clearTimeout}\n   */\n\n\n  Component.prototype.clearTimeout = function clearTimeout(timeoutId) {\n    window.clearTimeout(timeoutId);\n\n    var disposeFn = function disposeFn() {};\n\n    disposeFn.guid = 'vjs-timeout-' + timeoutId;\n\n    this.off('dispose', disposeFn);\n\n    return timeoutId;\n  };\n\n  /**\n   * Creates a function that gets run every `x` milliseconds. This function is a wrapper\n   * around `window.setInterval`. There are a few reasons to use this one instead though.\n   * 1. It gets cleared via  {@link Component#clearInterval} when\n   *    {@link Component#dispose} gets called.\n   * 2. The function callback will be a {@link Component~GenericCallback}\n   *\n   * @param {Component~GenericCallback} fn\n   *        The function to run every `x` seconds.\n   *\n   * @param {number} interval\n   *        Execute the specified function every `x` milliseconds.\n   *\n   * @return {number}\n   *         Returns an id that can be used to identify the interval. It can also be be used in\n   *         {@link Component#clearInterval} to clear the interval.\n   *\n   * @listens Component#dispose\n   * @see [Similar to]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/setInterval}\n   */\n\n\n  Component.prototype.setInterval = function setInterval(fn, interval) {\n    var _this3 = this;\n\n    fn = bind(this, fn);\n\n    var intervalId = window.setInterval(fn, interval);\n\n    var disposeFn = function disposeFn() {\n      return _this3.clearInterval(intervalId);\n    };\n\n    disposeFn.guid = 'vjs-interval-' + intervalId;\n\n    this.on('dispose', disposeFn);\n\n    return intervalId;\n  };\n\n  /**\n   * Clears an interval that gets created via `window.setInterval` or\n   * {@link Component#setInterval}. If you set an inteval via {@link Component#setInterval}\n   * use this function instead of `window.clearInterval`. If you don't your dispose\n   * listener will not get cleaned up until {@link Component#dispose}!\n   *\n   * @param {number} intervalId\n   *        The id of the interval to clear. The return value of\n   *        {@link Component#setInterval} or `window.setInterval`.\n   *\n   * @return {number}\n   *         Returns the interval id that was cleared.\n   *\n   * @see [Similar to]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/clearInterval}\n   */\n\n\n  Component.prototype.clearInterval = function clearInterval(intervalId) {\n    window.clearInterval(intervalId);\n\n    var disposeFn = function disposeFn() {};\n\n    disposeFn.guid = 'vjs-interval-' + intervalId;\n\n    this.off('dispose', disposeFn);\n\n    return intervalId;\n  };\n\n  /**\n   * Queues up a callback to be passed to requestAnimationFrame (rAF), but\n   * with a few extra bonuses:\n   *\n   * - Supports browsers that do not support rAF by falling back to\n   *   {@link Component#setTimeout}.\n   *\n   * - The callback is turned into a {@link Component~GenericCallback} (i.e.\n   *   bound to the component).\n   *\n   * - Automatic cancellation of the rAF callback is handled if the component\n   *   is disposed before it is called.\n   *\n   * @param  {Component~GenericCallback} fn\n   *         A function that will be bound to this component and executed just\n   *         before the browser's next repaint.\n   *\n   * @return {number}\n   *         Returns an rAF ID that gets used to identify the timeout. It can\n   *         also be used in {@link Component#cancelAnimationFrame} to cancel\n   *         the animation frame callback.\n   *\n   * @listens Component#dispose\n   * @see [Similar to]{@link https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame}\n   */\n\n\n  Component.prototype.requestAnimationFrame = function requestAnimationFrame(fn) {\n    var _this4 = this;\n\n    // declare as variables so they are properly available in rAF function\n    // eslint-disable-next-line\n    var id, disposeFn;\n\n    if (this.supportsRaf_) {\n      fn = bind(this, fn);\n\n      id = window.requestAnimationFrame(function () {\n        _this4.off('dispose', disposeFn);\n        fn();\n      });\n\n      disposeFn = function disposeFn() {\n        return _this4.cancelAnimationFrame(id);\n      };\n\n      disposeFn.guid = 'vjs-raf-' + id;\n      this.on('dispose', disposeFn);\n\n      return id;\n    }\n\n    // Fall back to using a timer.\n    return this.setTimeout(fn, 1000 / 60);\n  };\n\n  /**\n   * Cancels a queued callback passed to {@link Component#requestAnimationFrame}\n   * (rAF).\n   *\n   * If you queue an rAF callback via {@link Component#requestAnimationFrame},\n   * use this function instead of `window.cancelAnimationFrame`. If you don't,\n   * your dispose listener will not get cleaned up until {@link Component#dispose}!\n   *\n   * @param {number} id\n   *        The rAF ID to clear. The return value of {@link Component#requestAnimationFrame}.\n   *\n   * @return {number}\n   *         Returns the rAF ID that was cleared.\n   *\n   * @see [Similar to]{@link https://developer.mozilla.org/en-US/docs/Web/API/window/cancelAnimationFrame}\n   */\n\n\n  Component.prototype.cancelAnimationFrame = function cancelAnimationFrame(id) {\n    if (this.supportsRaf_) {\n      window.cancelAnimationFrame(id);\n\n      var disposeFn = function disposeFn() {};\n\n      disposeFn.guid = 'vjs-raf-' + id;\n\n      this.off('dispose', disposeFn);\n\n      return id;\n    }\n\n    // Fall back to using a timer.\n    return this.clearTimeout(id);\n  };\n\n  /**\n   * Register a `Component` with `videojs` given the name and the component.\n   *\n   * > NOTE: {@link Tech}s should not be registered as a `Component`. {@link Tech}s\n   *         should be registered using {@link Tech.registerTech} or\n   *         {@link videojs:videojs.registerTech}.\n   *\n   * > NOTE: This function can also be seen on videojs as\n   *         {@link videojs:videojs.registerComponent}.\n   *\n   * @param {string} name\n   *        The name of the `Component` to register.\n   *\n   * @param {Component} ComponentToRegister\n   *        The `Component` class to register.\n   *\n   * @return {Component}\n   *         The `Component` that was registered.\n   */\n\n\n  Component.registerComponent = function registerComponent(name, ComponentToRegister) {\n    if (typeof name !== 'string' || !name) {\n      throw new Error('Illegal component name, \"' + name + '\"; must be a non-empty string.');\n    }\n\n    var Tech = Component.getComponent('Tech');\n\n    // We need to make sure this check is only done if Tech has been registered.\n    var isTech = Tech && Tech.isTech(ComponentToRegister);\n    var isComp = Component === ComponentToRegister || Component.prototype.isPrototypeOf(ComponentToRegister.prototype);\n\n    if (isTech || !isComp) {\n      var reason = void 0;\n\n      if (isTech) {\n        reason = 'techs must be registered using Tech.registerTech()';\n      } else {\n        reason = 'must be a Component subclass';\n      }\n\n      throw new Error('Illegal component, \"' + name + '\"; ' + reason + '.');\n    }\n\n    name = toTitleCase(name);\n\n    if (!Component.components_) {\n      Component.components_ = {};\n    }\n\n    var Player = Component.getComponent('Player');\n\n    if (name === 'Player' && Player && Player.players) {\n      var players = Player.players;\n      var playerNames = Object.keys(players);\n\n      // If we have players that were disposed, then their name will still be\n      // in Players.players. So, we must loop through and verify that the value\n      // for each item is not null. This allows registration of the Player component\n      // after all players have been disposed or before any were created.\n      if (players && playerNames.length > 0 && playerNames.map(function (pname) {\n        return players[pname];\n      }).every(Boolean)) {\n        throw new Error('Can not register Player component after player has been created.');\n      }\n    }\n\n    Component.components_[name] = ComponentToRegister;\n\n    return ComponentToRegister;\n  };\n\n  /**\n   * Get a `Component` based on the name it was registered with.\n   *\n   * @param {string} name\n   *        The Name of the component to get.\n   *\n   * @return {Component}\n   *         The `Component` that got registered under the given name.\n   *\n   * @deprecated In `videojs` 6 this will not return `Component`s that were not\n   *             registered using {@link Component.registerComponent}. Currently we\n   *             check the global `videojs` object for a `Component` name and\n   *             return that if it exists.\n   */\n\n\n  Component.getComponent = function getComponent(name) {\n    if (!name) {\n      return;\n    }\n\n    name = toTitleCase(name);\n\n    if (Component.components_ && Component.components_[name]) {\n      return Component.components_[name];\n    }\n  };\n\n  return Component;\n}();\n\n/**\n * Whether or not this component supports `requestAnimationFrame`.\n *\n * This is exposed primarily for testing purposes.\n *\n * @private\n * @type {Boolean}\n */\n\n\nComponent.prototype.supportsRaf_ = typeof window.requestAnimationFrame === 'function' && typeof window.cancelAnimationFrame === 'function';\n\nComponent.registerComponent('Component', Component);\n\n/**\n * @file time-ranges.js\n * @module time-ranges\n */\n\n/**\n * Returns the time for the specified index at the start or end\n * of a TimeRange object.\n *\n * @function time-ranges:indexFunction\n *\n * @param {number} [index=0]\n *        The range number to return the time for.\n *\n * @return {number}\n *         The time that offset at the specified index.\n *\n * @depricated index must be set to a value, in the future this will throw an error.\n */\n\n/**\n * An object that contains ranges of time for various reasons.\n *\n * @typedef {Object} TimeRange\n *\n * @property {number} length\n *           The number of time ranges represented by this Object\n *\n * @property {time-ranges:indexFunction} start\n *           Returns the time offset at which a specified time range begins.\n *\n * @property {time-ranges:indexFunction} end\n *           Returns the time offset at which a specified time range ends.\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/API/TimeRanges\n */\n\n/**\n * Check if any of the time ranges are over the maximum index.\n *\n * @param {string} fnName\n *        The function name to use for logging\n *\n * @param {number} index\n *        The index to check\n *\n * @param {number} maxIndex\n *        The maximum possible index\n *\n * @throws {Error} if the timeRanges provided are over the maxIndex\n */\nfunction rangeCheck(fnName, index, maxIndex) {\n  if (typeof index !== 'number' || index < 0 || index > maxIndex) {\n    throw new Error('Failed to execute \\'' + fnName + '\\' on \\'TimeRanges\\': The index provided (' + index + ') is non-numeric or out of bounds (0-' + maxIndex + ').');\n  }\n}\n\n/**\n * Get the time for the specified index at the start or end\n * of a TimeRange object.\n *\n * @param {string} fnName\n *        The function name to use for logging\n *\n * @param {string} valueIndex\n *        The proprety that should be used to get the time. should be 'start' or 'end'\n *\n * @param {Array} ranges\n *        An array of time ranges\n *\n * @param {Array} [rangeIndex=0]\n *        The index to start the search at\n *\n * @return {number}\n *         The time that offset at the specified index.\n *\n *\n * @depricated rangeIndex must be set to a value, in the future this will throw an error.\n * @throws {Error} if rangeIndex is more than the length of ranges\n */\nfunction getRange(fnName, valueIndex, ranges, rangeIndex) {\n  rangeCheck(fnName, rangeIndex, ranges.length - 1);\n  return ranges[rangeIndex][valueIndex];\n}\n\n/**\n * Create a time range object given ranges of time.\n *\n * @param {Array} [ranges]\n *        An array of time ranges.\n */\nfunction createTimeRangesObj(ranges) {\n  if (ranges === undefined || ranges.length === 0) {\n    return {\n      length: 0,\n      start: function start() {\n        throw new Error('This TimeRanges object is empty');\n      },\n      end: function end() {\n        throw new Error('This TimeRanges object is empty');\n      }\n    };\n  }\n  return {\n    length: ranges.length,\n    start: getRange.bind(null, 'start', 0, ranges),\n    end: getRange.bind(null, 'end', 1, ranges)\n  };\n}\n\n/**\n * Should create a fake `TimeRange` object which mimics an HTML5 time range instance.\n *\n * @param {number|Array} start\n *        The start of a single range or an array of ranges\n *\n * @param {number} end\n *        The end of a single range.\n *\n * @private\n */\nfunction createTimeRanges(start, end) {\n  if (Array.isArray(start)) {\n    return createTimeRangesObj(start);\n  } else if (start === undefined || end === undefined) {\n    return createTimeRangesObj();\n  }\n  return createTimeRangesObj([[start, end]]);\n}\n\n/**\n * @file buffer.js\n * @module buffer\n */\n/**\n * Compute the percentage of the media that has been buffered.\n *\n * @param {TimeRange} buffered\n *        The current `TimeRange` object representing buffered time ranges\n *\n * @param {number} duration\n *        Total duration of the media\n *\n * @return {number}\n *         Percent buffered of the total duration in decimal form.\n */\nfunction bufferedPercent(buffered, duration) {\n  var bufferedDuration = 0;\n  var start = void 0;\n  var end = void 0;\n\n  if (!duration) {\n    return 0;\n  }\n\n  if (!buffered || !buffered.length) {\n    buffered = createTimeRanges(0, 0);\n  }\n\n  for (var i = 0; i < buffered.length; i++) {\n    start = buffered.start(i);\n    end = buffered.end(i);\n\n    // buffered end can be bigger than duration by a very small fraction\n    if (end > duration) {\n      end = duration;\n    }\n\n    bufferedDuration += end - start;\n  }\n\n  return bufferedDuration / duration;\n}\n\n/**\n * @file fullscreen-api.js\n * @module fullscreen-api\n * @private\n */\n/**\n * Store the browser-specific methods for the fullscreen API.\n *\n * @type {Object}\n * @see [Specification]{@link https://fullscreen.spec.whatwg.org}\n * @see [Map Approach From Screenfull.js]{@link https://github.com/sindresorhus/screenfull.js}\n */\nvar FullscreenApi = {};\n\n// browser API methods\nvar apiMap = [['requestFullscreen', 'exitFullscreen', 'fullscreenElement', 'fullscreenEnabled', 'fullscreenchange', 'fullscreenerror'],\n// WebKit\n['webkitRequestFullscreen', 'webkitExitFullscreen', 'webkitFullscreenElement', 'webkitFullscreenEnabled', 'webkitfullscreenchange', 'webkitfullscreenerror'],\n// Old WebKit (Safari 5.1)\n['webkitRequestFullScreen', 'webkitCancelFullScreen', 'webkitCurrentFullScreenElement', 'webkitCancelFullScreen', 'webkitfullscreenchange', 'webkitfullscreenerror'],\n// Mozilla\n['mozRequestFullScreen', 'mozCancelFullScreen', 'mozFullScreenElement', 'mozFullScreenEnabled', 'mozfullscreenchange', 'mozfullscreenerror'],\n// Microsoft\n['msRequestFullscreen', 'msExitFullscreen', 'msFullscreenElement', 'msFullscreenEnabled', 'MSFullscreenChange', 'MSFullscreenError']];\n\nvar specApi = apiMap[0];\nvar browserApi = void 0;\n\n// determine the supported set of functions\nfor (var i = 0; i < apiMap.length; i++) {\n  // check for exitFullscreen function\n  if (apiMap[i][1] in document) {\n    browserApi = apiMap[i];\n    break;\n  }\n}\n\n// map the browser API names to the spec API names\nif (browserApi) {\n  for (var _i = 0; _i < browserApi.length; _i++) {\n    FullscreenApi[specApi[_i]] = browserApi[_i];\n  }\n}\n\n/**\n * @file media-error.js\n */\n/**\n * A Custom `MediaError` class which mimics the standard HTML5 `MediaError` class.\n *\n * @param {number|string|Object|MediaError} value\n *        This can be of multiple types:\n *        - number: should be a standard error code\n *        - string: an error message (the code will be 0)\n *        - Object: arbitrary properties\n *        - `MediaError` (native): used to populate a video.js `MediaError` object\n *        - `MediaError` (video.js): will return itself if it's already a\n *          video.js `MediaError` object.\n *\n * @see [MediaError Spec]{@link https://dev.w3.org/html5/spec-author-view/video.html#mediaerror}\n * @see [Encrypted MediaError Spec]{@link https://www.w3.org/TR/2013/WD-encrypted-media-20130510/#error-codes}\n *\n * @class MediaError\n */\nfunction MediaError(value) {\n\n  // Allow redundant calls to this constructor to avoid having `instanceof`\n  // checks peppered around the code.\n  if (value instanceof MediaError) {\n    return value;\n  }\n\n  if (typeof value === 'number') {\n    this.code = value;\n  } else if (typeof value === 'string') {\n    // default code is zero, so this is a custom error\n    this.message = value;\n  } else if (isObject(value)) {\n\n    // We assign the `code` property manually because native `MediaError` objects\n    // do not expose it as an own/enumerable property of the object.\n    if (typeof value.code === 'number') {\n      this.code = value.code;\n    }\n\n    assign(this, value);\n  }\n\n  if (!this.message) {\n    this.message = MediaError.defaultMessages[this.code] || '';\n  }\n}\n\n/**\n * The error code that refers two one of the defined `MediaError` types\n *\n * @type {Number}\n */\nMediaError.prototype.code = 0;\n\n/**\n * An optional message that to show with the error. Message is not part of the HTML5\n * video spec but allows for more informative custom errors.\n *\n * @type {String}\n */\nMediaError.prototype.message = '';\n\n/**\n * An optional status code that can be set by plugins to allow even more detail about\n * the error. For example a plugin might provide a specific HTTP status code and an\n * error message for that code. Then when the plugin gets that error this class will\n * know how to display an error message for it. This allows a custom message to show\n * up on the `Player` error overlay.\n *\n * @type {Array}\n */\nMediaError.prototype.status = null;\n\n/**\n * Errors indexed by the W3C standard. The order **CANNOT CHANGE**! See the\n * specification listed under {@link MediaError} for more information.\n *\n * @enum {array}\n * @readonly\n * @property {string} 0 - MEDIA_ERR_CUSTOM\n * @property {string} 1 - MEDIA_ERR_CUSTOM\n * @property {string} 2 - MEDIA_ERR_ABORTED\n * @property {string} 3 - MEDIA_ERR_NETWORK\n * @property {string} 4 - MEDIA_ERR_SRC_NOT_SUPPORTED\n * @property {string} 5 - MEDIA_ERR_ENCRYPTED\n */\nMediaError.errorTypes = ['MEDIA_ERR_CUSTOM', 'MEDIA_ERR_ABORTED', 'MEDIA_ERR_NETWORK', 'MEDIA_ERR_DECODE', 'MEDIA_ERR_SRC_NOT_SUPPORTED', 'MEDIA_ERR_ENCRYPTED'];\n\n/**\n * The default `MediaError` messages based on the {@link MediaError.errorTypes}.\n *\n * @type {Array}\n * @constant\n */\nMediaError.defaultMessages = {\n  1: 'You aborted the media playback',\n  2: 'A network error caused the media download to fail part-way.',\n  3: 'The media playback was aborted due to a corruption problem or because the media used features your browser did not support.',\n  4: 'The media could not be loaded, either because the server or network failed or because the format is not supported.',\n  5: 'The media is encrypted and we do not have the keys to decrypt it.'\n};\n\n// Add types as properties on MediaError\n// e.g. MediaError.MEDIA_ERR_SRC_NOT_SUPPORTED = 4;\nfor (var errNum = 0; errNum < MediaError.errorTypes.length; errNum++) {\n  MediaError[MediaError.errorTypes[errNum]] = errNum;\n  // values should be accessible on both the class and instance\n  MediaError.prototype[MediaError.errorTypes[errNum]] = errNum;\n}\n\n/**\n * Returns whether an object is `Promise`-like (i.e. has a `then` method).\n *\n * @param  {Object}  value\n *         An object that may or may not be `Promise`-like.\n *\n * @return {Boolean}\n *         Whether or not the object is `Promise`-like.\n */\nfunction isPromise(value) {\n  return value !== undefined && value !== null && typeof value.then === 'function';\n}\n\n/**\n * Silence a Promise-like object.\n *\n * This is useful for avoiding non-harmful, but potentially confusing \"uncaught\n * play promise\" rejection error messages.\n *\n * @param  {Object} value\n *         An object that may or may not be `Promise`-like.\n */\nfunction silencePromise(value) {\n  if (isPromise(value)) {\n    value.then(null, function (e) {});\n  }\n}\n\n/**\n * @file text-track-list-converter.js Utilities for capturing text track state and\n * re-creating tracks based on a capture.\n *\n * @module text-track-list-converter\n */\n\n/**\n * Examine a single {@link TextTrack} and return a JSON-compatible javascript object that\n * represents the {@link TextTrack}'s state.\n *\n * @param {TextTrack} track\n *        The text track to query.\n *\n * @return {Object}\n *         A serializable javascript representation of the TextTrack.\n * @private\n */\nvar trackToJson_ = function trackToJson_(track) {\n  var ret = ['kind', 'label', 'language', 'id', 'inBandMetadataTrackDispatchType', 'mode', 'src'].reduce(function (acc, prop, i) {\n\n    if (track[prop]) {\n      acc[prop] = track[prop];\n    }\n\n    return acc;\n  }, {\n    cues: track.cues && Array.prototype.map.call(track.cues, function (cue) {\n      return {\n        startTime: cue.startTime,\n        endTime: cue.endTime,\n        text: cue.text,\n        id: cue.id\n      };\n    })\n  });\n\n  return ret;\n};\n\n/**\n * Examine a {@link Tech} and return a JSON-compatible javascript array that represents the\n * state of all {@link TextTrack}s currently configured. The return array is compatible with\n * {@link text-track-list-converter:jsonToTextTracks}.\n *\n * @param {Tech} tech\n *        The tech object to query\n *\n * @return {Array}\n *         A serializable javascript representation of the {@link Tech}s\n *         {@link TextTrackList}.\n */\nvar textTracksToJson = function textTracksToJson(tech) {\n\n  var trackEls = tech.$$('track');\n\n  var trackObjs = Array.prototype.map.call(trackEls, function (t) {\n    return t.track;\n  });\n  var tracks = Array.prototype.map.call(trackEls, function (trackEl) {\n    var json = trackToJson_(trackEl.track);\n\n    if (trackEl.src) {\n      json.src = trackEl.src;\n    }\n    return json;\n  });\n\n  return tracks.concat(Array.prototype.filter.call(tech.textTracks(), function (track) {\n    return trackObjs.indexOf(track) === -1;\n  }).map(trackToJson_));\n};\n\n/**\n * Create a set of remote {@link TextTrack}s on a {@link Tech} based on an array of javascript\n * object {@link TextTrack} representations.\n *\n * @param {Array} json\n *        An array of `TextTrack` representation objects, like those that would be\n *        produced by `textTracksToJson`.\n *\n * @param {Tech} tech\n *        The `Tech` to create the `TextTrack`s on.\n */\nvar jsonToTextTracks = function jsonToTextTracks(json, tech) {\n  json.forEach(function (track) {\n    var addedTrack = tech.addRemoteTextTrack(track).track;\n\n    if (!track.src && track.cues) {\n      track.cues.forEach(function (cue) {\n        return addedTrack.addCue(cue);\n      });\n    }\n  });\n\n  return tech.textTracks();\n};\n\nvar textTrackConverter = { textTracksToJson: textTracksToJson, jsonToTextTracks: jsonToTextTracks, trackToJson_: trackToJson_ };\n\n/**\n * @file modal-dialog.js\n */\nvar MODAL_CLASS_NAME = 'vjs-modal-dialog';\nvar ESC = 27;\n\n/**\n * The `ModalDialog` displays over the video and its controls, which blocks\n * interaction with the player until it is closed.\n *\n * Modal dialogs include a \"Close\" button and will close when that button\n * is activated - or when ESC is pressed anywhere.\n *\n * @extends Component\n */\n\nvar ModalDialog = function (_Component) {\n  inherits(ModalDialog, _Component);\n\n  /**\n   * Create an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   *\n   * @param {Mixed} [options.content=undefined]\n   *        Provide customized content for this modal.\n   *\n   * @param {string} [options.description]\n   *        A text description for the modal, primarily for accessibility.\n   *\n   * @param {boolean} [options.fillAlways=false]\n   *        Normally, modals are automatically filled only the first time\n   *        they open. This tells the modal to refresh its content\n   *        every time it opens.\n   *\n   * @param {string} [options.label]\n   *        A text label for the modal, primarily for accessibility.\n   *\n   * @param {boolean} [options.temporary=true]\n   *        If `true`, the modal can only be opened once; it will be\n   *        disposed as soon as it's closed.\n   *\n   * @param {boolean} [options.uncloseable=false]\n   *        If `true`, the user will not be able to close the modal\n   *        through the UI in the normal ways. Programmatic closing is\n   *        still possible.\n   */\n  function ModalDialog(player, options) {\n    classCallCheck(this, ModalDialog);\n\n    var _this = possibleConstructorReturn(this, _Component.call(this, player, options));\n\n    _this.opened_ = _this.hasBeenOpened_ = _this.hasBeenFilled_ = false;\n\n    _this.closeable(!_this.options_.uncloseable);\n    _this.content(_this.options_.content);\n\n    // Make sure the contentEl is defined AFTER any children are initialized\n    // because we only want the contents of the modal in the contentEl\n    // (not the UI elements like the close button).\n    _this.contentEl_ = createEl('div', {\n      className: MODAL_CLASS_NAME + '-content'\n    }, {\n      role: 'document'\n    });\n\n    _this.descEl_ = createEl('p', {\n      className: MODAL_CLASS_NAME + '-description vjs-control-text',\n      id: _this.el().getAttribute('aria-describedby')\n    });\n\n    textContent(_this.descEl_, _this.description());\n    _this.el_.appendChild(_this.descEl_);\n    _this.el_.appendChild(_this.contentEl_);\n    return _this;\n  }\n\n  /**\n   * Create the `ModalDialog`'s DOM element\n   *\n   * @return {Element}\n   *         The DOM element that gets created.\n   */\n\n\n  ModalDialog.prototype.createEl = function createEl$$1() {\n    return _Component.prototype.createEl.call(this, 'div', {\n      className: this.buildCSSClass(),\n      tabIndex: -1\n    }, {\n      'aria-describedby': this.id() + '_description',\n      'aria-hidden': 'true',\n      'aria-label': this.label(),\n      'role': 'dialog'\n    });\n  };\n\n  ModalDialog.prototype.dispose = function dispose() {\n    this.contentEl_ = null;\n    this.descEl_ = null;\n    this.previouslyActiveEl_ = null;\n\n    _Component.prototype.dispose.call(this);\n  };\n\n  /**\n   * Builds the default DOM `className`.\n   *\n   * @return {string}\n   *         The DOM `className` for this object.\n   */\n\n\n  ModalDialog.prototype.buildCSSClass = function buildCSSClass() {\n    return MODAL_CLASS_NAME + ' vjs-hidden ' + _Component.prototype.buildCSSClass.call(this);\n  };\n\n  /**\n   * Handles `keydown` events on the document, looking for ESC, which closes\n   * the modal.\n   *\n   * @param {EventTarget~Event} e\n   *        The keypress that triggered this event.\n   *\n   * @listens keydown\n   */\n\n\n  ModalDialog.prototype.handleKeyPress = function handleKeyPress(e) {\n    if (e.which === ESC && this.closeable()) {\n      this.close();\n    }\n  };\n\n  /**\n   * Returns the label string for this modal. Primarily used for accessibility.\n   *\n   * @return {string}\n   *         the localized or raw label of this modal.\n   */\n\n\n  ModalDialog.prototype.label = function label() {\n    return this.localize(this.options_.label || 'Modal Window');\n  };\n\n  /**\n   * Returns the description string for this modal. Primarily used for\n   * accessibility.\n   *\n   * @return {string}\n   *         The localized or raw description of this modal.\n   */\n\n\n  ModalDialog.prototype.description = function description() {\n    var desc = this.options_.description || this.localize('This is a modal window.');\n\n    // Append a universal closeability message if the modal is closeable.\n    if (this.closeable()) {\n      desc += ' ' + this.localize('This modal can be closed by pressing the Escape key or activating the close button.');\n    }\n\n    return desc;\n  };\n\n  /**\n   * Opens the modal.\n   *\n   * @fires ModalDialog#beforemodalopen\n   * @fires ModalDialog#modalopen\n   */\n\n\n  ModalDialog.prototype.open = function open() {\n    if (!this.opened_) {\n      var player = this.player();\n\n      /**\n        * Fired just before a `ModalDialog` is opened.\n        *\n        * @event ModalDialog#beforemodalopen\n        * @type {EventTarget~Event}\n        */\n      this.trigger('beforemodalopen');\n      this.opened_ = true;\n\n      // Fill content if the modal has never opened before and\n      // never been filled.\n      if (this.options_.fillAlways || !this.hasBeenOpened_ && !this.hasBeenFilled_) {\n        this.fill();\n      }\n\n      // If the player was playing, pause it and take note of its previously\n      // playing state.\n      this.wasPlaying_ = !player.paused();\n\n      if (this.options_.pauseOnOpen && this.wasPlaying_) {\n        player.pause();\n      }\n\n      if (this.closeable()) {\n        this.on(this.el_.ownerDocument, 'keydown', bind(this, this.handleKeyPress));\n      }\n\n      // Hide controls and note if they were enabled.\n      this.hadControls_ = player.controls();\n      player.controls(false);\n\n      this.show();\n      this.conditionalFocus_();\n      this.el().setAttribute('aria-hidden', 'false');\n\n      /**\n        * Fired just after a `ModalDialog` is opened.\n        *\n        * @event ModalDialog#modalopen\n        * @type {EventTarget~Event}\n        */\n      this.trigger('modalopen');\n      this.hasBeenOpened_ = true;\n    }\n  };\n\n  /**\n   * If the `ModalDialog` is currently open or closed.\n   *\n   * @param  {boolean} [value]\n   *         If given, it will open (`true`) or close (`false`) the modal.\n   *\n   * @return {boolean}\n   *         the current open state of the modaldialog\n   */\n\n\n  ModalDialog.prototype.opened = function opened(value) {\n    if (typeof value === 'boolean') {\n      this[value ? 'open' : 'close']();\n    }\n    return this.opened_;\n  };\n\n  /**\n   * Closes the modal, does nothing if the `ModalDialog` is\n   * not open.\n   *\n   * @fires ModalDialog#beforemodalclose\n   * @fires ModalDialog#modalclose\n   */\n\n\n  ModalDialog.prototype.close = function close() {\n    if (!this.opened_) {\n      return;\n    }\n    var player = this.player();\n\n    /**\n      * Fired just before a `ModalDialog` is closed.\n      *\n      * @event ModalDialog#beforemodalclose\n      * @type {EventTarget~Event}\n      */\n    this.trigger('beforemodalclose');\n    this.opened_ = false;\n\n    if (this.wasPlaying_ && this.options_.pauseOnOpen) {\n      player.play();\n    }\n\n    if (this.closeable()) {\n      this.off(this.el_.ownerDocument, 'keydown', bind(this, this.handleKeyPress));\n    }\n\n    if (this.hadControls_) {\n      player.controls(true);\n    }\n\n    this.hide();\n    this.el().setAttribute('aria-hidden', 'true');\n\n    /**\n      * Fired just after a `ModalDialog` is closed.\n      *\n      * @event ModalDialog#modalclose\n      * @type {EventTarget~Event}\n      */\n    this.trigger('modalclose');\n    this.conditionalBlur_();\n\n    if (this.options_.temporary) {\n      this.dispose();\n    }\n  };\n\n  /**\n   * Check to see if the `ModalDialog` is closeable via the UI.\n   *\n   * @param  {boolean} [value]\n   *         If given as a boolean, it will set the `closeable` option.\n   *\n   * @return {boolean}\n   *         Returns the final value of the closable option.\n   */\n\n\n  ModalDialog.prototype.closeable = function closeable(value) {\n    if (typeof value === 'boolean') {\n      var closeable = this.closeable_ = !!value;\n      var close = this.getChild('closeButton');\n\n      // If this is being made closeable and has no close button, add one.\n      if (closeable && !close) {\n\n        // The close button should be a child of the modal - not its\n        // content element, so temporarily change the content element.\n        var temp = this.contentEl_;\n\n        this.contentEl_ = this.el_;\n        close = this.addChild('closeButton', { controlText: 'Close Modal Dialog' });\n        this.contentEl_ = temp;\n        this.on(close, 'close', this.close);\n      }\n\n      // If this is being made uncloseable and has a close button, remove it.\n      if (!closeable && close) {\n        this.off(close, 'close', this.close);\n        this.removeChild(close);\n        close.dispose();\n      }\n    }\n    return this.closeable_;\n  };\n\n  /**\n   * Fill the modal's content element with the modal's \"content\" option.\n   * The content element will be emptied before this change takes place.\n   */\n\n\n  ModalDialog.prototype.fill = function fill() {\n    this.fillWith(this.content());\n  };\n\n  /**\n   * Fill the modal's content element with arbitrary content.\n   * The content element will be emptied before this change takes place.\n   *\n   * @fires ModalDialog#beforemodalfill\n   * @fires ModalDialog#modalfill\n   *\n   * @param {Mixed} [content]\n   *        The same rules apply to this as apply to the `content` option.\n   */\n\n\n  ModalDialog.prototype.fillWith = function fillWith(content) {\n    var contentEl = this.contentEl();\n    var parentEl = contentEl.parentNode;\n    var nextSiblingEl = contentEl.nextSibling;\n\n    /**\n     * Fired just before a `ModalDialog` is filled with content.\n     *\n     * @event ModalDialog#beforemodalfill\n     * @type {EventTarget~Event}\n     */\n    this.trigger('beforemodalfill');\n    this.hasBeenFilled_ = true;\n\n    // Detach the content element from the DOM before performing\n    // manipulation to avoid modifying the live DOM multiple times.\n    parentEl.removeChild(contentEl);\n    this.empty();\n    insertContent(contentEl, content);\n    /**\n     * Fired just after a `ModalDialog` is filled with content.\n     *\n     * @event ModalDialog#modalfill\n     * @type {EventTarget~Event}\n     */\n    this.trigger('modalfill');\n\n    // Re-inject the re-filled content element.\n    if (nextSiblingEl) {\n      parentEl.insertBefore(contentEl, nextSiblingEl);\n    } else {\n      parentEl.appendChild(contentEl);\n    }\n\n    // make sure that the close button is last in the dialog DOM\n    var closeButton = this.getChild('closeButton');\n\n    if (closeButton) {\n      parentEl.appendChild(closeButton.el_);\n    }\n  };\n\n  /**\n   * Empties the content element. This happens anytime the modal is filled.\n   *\n   * @fires ModalDialog#beforemodalempty\n   * @fires ModalDialog#modalempty\n   */\n\n\n  ModalDialog.prototype.empty = function empty() {\n    /**\n     * Fired just before a `ModalDialog` is emptied.\n     *\n     * @event ModalDialog#beforemodalempty\n     * @type {EventTarget~Event}\n     */\n    this.trigger('beforemodalempty');\n    emptyEl(this.contentEl());\n\n    /**\n     * Fired just after a `ModalDialog` is emptied.\n     *\n     * @event ModalDialog#modalempty\n     * @type {EventTarget~Event}\n     */\n    this.trigger('modalempty');\n  };\n\n  /**\n   * Gets or sets the modal content, which gets normalized before being\n   * rendered into the DOM.\n   *\n   * This does not update the DOM or fill the modal, but it is called during\n   * that process.\n   *\n   * @param  {Mixed} [value]\n   *         If defined, sets the internal content value to be used on the\n   *         next call(s) to `fill`. This value is normalized before being\n   *         inserted. To \"clear\" the internal content value, pass `null`.\n   *\n   * @return {Mixed}\n   *         The current content of the modal dialog\n   */\n\n\n  ModalDialog.prototype.content = function content(value) {\n    if (typeof value !== 'undefined') {\n      this.content_ = value;\n    }\n    return this.content_;\n  };\n\n  /**\n   * conditionally focus the modal dialog if focus was previously on the player.\n   *\n   * @private\n   */\n\n\n  ModalDialog.prototype.conditionalFocus_ = function conditionalFocus_() {\n    var activeEl = document.activeElement;\n    var playerEl = this.player_.el_;\n\n    this.previouslyActiveEl_ = null;\n\n    if (playerEl.contains(activeEl) || playerEl === activeEl) {\n      this.previouslyActiveEl_ = activeEl;\n\n      this.focus();\n\n      this.on(document, 'keydown', this.handleKeyDown);\n    }\n  };\n\n  /**\n   * conditionally blur the element and refocus the last focused element\n   *\n   * @private\n   */\n\n\n  ModalDialog.prototype.conditionalBlur_ = function conditionalBlur_() {\n    if (this.previouslyActiveEl_) {\n      this.previouslyActiveEl_.focus();\n      this.previouslyActiveEl_ = null;\n    }\n\n    this.off(document, 'keydown', this.handleKeyDown);\n  };\n\n  /**\n   * Keydown handler. Attached when modal is focused.\n   *\n   * @listens keydown\n   */\n\n\n  ModalDialog.prototype.handleKeyDown = function handleKeyDown(event) {\n    // exit early if it isn't a tab key\n    if (event.which !== 9) {\n      return;\n    }\n\n    var focusableEls = this.focusableEls_();\n    var activeEl = this.el_.querySelector(':focus');\n    var focusIndex = void 0;\n\n    for (var i = 0; i < focusableEls.length; i++) {\n      if (activeEl === focusableEls[i]) {\n        focusIndex = i;\n        break;\n      }\n    }\n\n    if (document.activeElement === this.el_) {\n      focusIndex = 0;\n    }\n\n    if (event.shiftKey && focusIndex === 0) {\n      focusableEls[focusableEls.length - 1].focus();\n      event.preventDefault();\n    } else if (!event.shiftKey && focusIndex === focusableEls.length - 1) {\n      focusableEls[0].focus();\n      event.preventDefault();\n    }\n  };\n\n  /**\n   * get all focusable elements\n   *\n   * @private\n   */\n\n\n  ModalDialog.prototype.focusableEls_ = function focusableEls_() {\n    var allChildren = this.el_.querySelectorAll('*');\n\n    return Array.prototype.filter.call(allChildren, function (child) {\n      return (child instanceof window.HTMLAnchorElement || child instanceof window.HTMLAreaElement) && child.hasAttribute('href') || (child instanceof window.HTMLInputElement || child instanceof window.HTMLSelectElement || child instanceof window.HTMLTextAreaElement || child instanceof window.HTMLButtonElement) && !child.hasAttribute('disabled') || child instanceof window.HTMLIFrameElement || child instanceof window.HTMLObjectElement || child instanceof window.HTMLEmbedElement || child.hasAttribute('tabindex') && child.getAttribute('tabindex') !== -1 || child.hasAttribute('contenteditable');\n    });\n  };\n\n  return ModalDialog;\n}(Component);\n\n/**\n * Default options for `ModalDialog` default options.\n *\n * @type {Object}\n * @private\n */\n\n\nModalDialog.prototype.options_ = {\n  pauseOnOpen: true,\n  temporary: true\n};\n\nComponent.registerComponent('ModalDialog', ModalDialog);\n\n/**\n * @file track-list.js\n */\n/**\n * Common functionaliy between {@link TextTrackList}, {@link AudioTrackList}, and\n * {@link VideoTrackList}\n *\n * @extends EventTarget\n */\n\nvar TrackList = function (_EventTarget) {\n  inherits(TrackList, _EventTarget);\n\n  /**\n   * Create an instance of this class\n   *\n   * @param {Track[]} tracks\n   *        A list of tracks to initialize the list with.\n   *\n   * @param {Object} [list]\n   *        The child object with inheritance done manually for ie8.\n   *\n   * @abstract\n   */\n  function TrackList() {\n    var tracks = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n    var _ret;\n\n    var list = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    classCallCheck(this, TrackList);\n\n    var _this = possibleConstructorReturn(this, _EventTarget.call(this));\n\n    if (!list) {\n      list = _this; // eslint-disable-line\n      if (IS_IE8) {\n        list = document.createElement('custom');\n        for (var prop in TrackList.prototype) {\n          if (prop !== 'constructor') {\n            list[prop] = TrackList.prototype[prop];\n          }\n        }\n      }\n    }\n\n    list.tracks_ = [];\n\n    /**\n     * @memberof TrackList\n     * @member {number} length\n     *         The current number of `Track`s in the this Trackist.\n     * @instance\n     */\n    Object.defineProperty(list, 'length', {\n      get: function get$$1() {\n        return this.tracks_.length;\n      }\n    });\n\n    for (var i = 0; i < tracks.length; i++) {\n      list.addTrack(tracks[i]);\n    }\n\n    // must return the object, as for ie8 it will not be this\n    // but a reference to a document object\n    return _ret = list, possibleConstructorReturn(_this, _ret);\n  }\n\n  /**\n   * Add a {@link Track} to the `TrackList`\n   *\n   * @param {Track} track\n   *        The audio, video, or text track to add to the list.\n   *\n   * @fires TrackList#addtrack\n   */\n\n\n  TrackList.prototype.addTrack = function addTrack(track) {\n    var index = this.tracks_.length;\n\n    if (!('' + index in this)) {\n      Object.defineProperty(this, index, {\n        get: function get$$1() {\n          return this.tracks_[index];\n        }\n      });\n    }\n\n    // Do not add duplicate tracks\n    if (this.tracks_.indexOf(track) === -1) {\n      this.tracks_.push(track);\n      /**\n       * Triggered when a track is added to a track list.\n       *\n       * @event TrackList#addtrack\n       * @type {EventTarget~Event}\n       * @property {Track} track\n       *           A reference to track that was added.\n       */\n      this.trigger({\n        track: track,\n        type: 'addtrack'\n      });\n    }\n  };\n\n  /**\n   * Remove a {@link Track} from the `TrackList`\n   *\n   * @param {Track} rtrack\n   *        The audio, video, or text track to remove from the list.\n   *\n   * @fires TrackList#removetrack\n   */\n\n\n  TrackList.prototype.removeTrack = function removeTrack(rtrack) {\n    var track = void 0;\n\n    for (var i = 0, l = this.length; i < l; i++) {\n      if (this[i] === rtrack) {\n        track = this[i];\n        if (track.off) {\n          track.off();\n        }\n\n        this.tracks_.splice(i, 1);\n\n        break;\n      }\n    }\n\n    if (!track) {\n      return;\n    }\n\n    /**\n     * Triggered when a track is removed from track list.\n     *\n     * @event TrackList#removetrack\n     * @type {EventTarget~Event}\n     * @property {Track} track\n     *           A reference to track that was removed.\n     */\n    this.trigger({\n      track: track,\n      type: 'removetrack'\n    });\n  };\n\n  /**\n   * Get a Track from the TrackList by a tracks id\n   *\n   * @param {String} id - the id of the track to get\n   * @method getTrackById\n   * @return {Track}\n   * @private\n   */\n\n\n  TrackList.prototype.getTrackById = function getTrackById(id) {\n    var result = null;\n\n    for (var i = 0, l = this.length; i < l; i++) {\n      var track = this[i];\n\n      if (track.id === id) {\n        result = track;\n        break;\n      }\n    }\n\n    return result;\n  };\n\n  return TrackList;\n}(EventTarget);\n\n/**\n * Triggered when a different track is selected/enabled.\n *\n * @event TrackList#change\n * @type {EventTarget~Event}\n */\n\n/**\n * Events that can be called with on + eventName. See {@link EventHandler}.\n *\n * @property {Object} TrackList#allowedEvents_\n * @private\n */\n\n\nTrackList.prototype.allowedEvents_ = {\n  change: 'change',\n  addtrack: 'addtrack',\n  removetrack: 'removetrack'\n};\n\n// emulate attribute EventHandler support to allow for feature detection\nfor (var event in TrackList.prototype.allowedEvents_) {\n  TrackList.prototype['on' + event] = null;\n}\n\n/**\n * @file audio-track-list.js\n */\n/**\n * Anywhere we call this function we diverge from the spec\n * as we only support one enabled audiotrack at a time\n *\n * @param {AudioTrackList} list\n *        list to work on\n *\n * @param {AudioTrack} track\n *        The track to skip\n *\n * @private\n */\nvar disableOthers = function disableOthers(list, track) {\n  for (var i = 0; i < list.length; i++) {\n    if (!Object.keys(list[i]).length || track.id === list[i].id) {\n      continue;\n    }\n    // another audio track is enabled, disable it\n    list[i].enabled = false;\n  }\n};\n\n/**\n * The current list of {@link AudioTrack} for a media file.\n *\n * @see [Spec]{@link https://html.spec.whatwg.org/multipage/embedded-content.html#audiotracklist}\n * @extends TrackList\n */\n\nvar AudioTrackList = function (_TrackList) {\n  inherits(AudioTrackList, _TrackList);\n\n  /**\n   * Create an instance of this class.\n   *\n   * @param {AudioTrack[]} [tracks=[]]\n   *        A list of `AudioTrack` to instantiate the list with.\n   */\n  function AudioTrackList() {\n    var _this, _ret;\n\n    var tracks = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    classCallCheck(this, AudioTrackList);\n\n    var list = void 0;\n\n    // make sure only 1 track is enabled\n    // sorted from last index to first index\n    for (var i = tracks.length - 1; i >= 0; i--) {\n      if (tracks[i].enabled) {\n        disableOthers(tracks, tracks[i]);\n        break;\n      }\n    }\n\n    // IE8 forces us to implement inheritance ourselves\n    // as it does not support Object.defineProperty properly\n    if (IS_IE8) {\n      list = document.createElement('custom');\n      for (var prop in TrackList.prototype) {\n        if (prop !== 'constructor') {\n          list[prop] = TrackList.prototype[prop];\n        }\n      }\n      for (var _prop in AudioTrackList.prototype) {\n        if (_prop !== 'constructor') {\n          list[_prop] = AudioTrackList.prototype[_prop];\n        }\n      }\n    }\n\n    list = (_this = possibleConstructorReturn(this, _TrackList.call(this, tracks, list)), _this);\n    list.changing_ = false;\n\n    return _ret = list, possibleConstructorReturn(_this, _ret);\n  }\n\n  /**\n   * Add an {@link AudioTrack} to the `AudioTrackList`.\n   *\n   * @param {AudioTrack} track\n   *        The AudioTrack to add to the list\n   *\n   * @fires TrackList#addtrack\n   */\n\n\n  AudioTrackList.prototype.addTrack = function addTrack(track) {\n    var _this2 = this;\n\n    if (track.enabled) {\n      disableOthers(this, track);\n    }\n\n    _TrackList.prototype.addTrack.call(this, track);\n    // native tracks don't have this\n    if (!track.addEventListener) {\n      return;\n    }\n\n    /**\n     * @listens AudioTrack#enabledchange\n     * @fires TrackList#change\n     */\n    track.addEventListener('enabledchange', function () {\n      // when we are disabling other tracks (since we don't support\n      // more than one track at a time) we will set changing_\n      // to true so that we don't trigger additional change events\n      if (_this2.changing_) {\n        return;\n      }\n      _this2.changing_ = true;\n      disableOthers(_this2, track);\n      _this2.changing_ = false;\n      _this2.trigger('change');\n    });\n  };\n\n  return AudioTrackList;\n}(TrackList);\n\n/**\n * @file video-track-list.js\n */\n/**\n * Un-select all other {@link VideoTrack}s that are selected.\n *\n * @param {VideoTrackList} list\n *        list to work on\n *\n * @param {VideoTrack} track\n *        The track to skip\n *\n * @private\n */\nvar disableOthers$1 = function disableOthers(list, track) {\n  for (var i = 0; i < list.length; i++) {\n    if (!Object.keys(list[i]).length || track.id === list[i].id) {\n      continue;\n    }\n    // another video track is enabled, disable it\n    list[i].selected = false;\n  }\n};\n\n/**\n * The current list of {@link VideoTrack} for a video.\n *\n * @see [Spec]{@link https://html.spec.whatwg.org/multipage/embedded-content.html#videotracklist}\n * @extends TrackList\n */\n\nvar VideoTrackList = function (_TrackList) {\n  inherits(VideoTrackList, _TrackList);\n\n  /**\n   * Create an instance of this class.\n   *\n   * @param {VideoTrack[]} [tracks=[]]\n   *        A list of `VideoTrack` to instantiate the list with.\n   */\n  function VideoTrackList() {\n    var _this, _ret;\n\n    var tracks = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    classCallCheck(this, VideoTrackList);\n\n    var list = void 0;\n\n    // make sure only 1 track is enabled\n    // sorted from last index to first index\n    for (var i = tracks.length - 1; i >= 0; i--) {\n      if (tracks[i].selected) {\n        disableOthers$1(tracks, tracks[i]);\n        break;\n      }\n    }\n\n    // IE8 forces us to implement inheritance ourselves\n    // as it does not support Object.defineProperty properly\n    if (IS_IE8) {\n      list = document.createElement('custom');\n      for (var prop in TrackList.prototype) {\n        if (prop !== 'constructor') {\n          list[prop] = TrackList.prototype[prop];\n        }\n      }\n      for (var _prop in VideoTrackList.prototype) {\n        if (_prop !== 'constructor') {\n          list[_prop] = VideoTrackList.prototype[_prop];\n        }\n      }\n    }\n\n    list = (_this = possibleConstructorReturn(this, _TrackList.call(this, tracks, list)), _this);\n    list.changing_ = false;\n\n    /**\n     * @member {number} VideoTrackList#selectedIndex\n     *         The current index of the selected {@link VideoTrack`}.\n     */\n    Object.defineProperty(list, 'selectedIndex', {\n      get: function get$$1() {\n        for (var _i = 0; _i < this.length; _i++) {\n          if (this[_i].selected) {\n            return _i;\n          }\n        }\n        return -1;\n      },\n      set: function set$$1() {}\n    });\n\n    return _ret = list, possibleConstructorReturn(_this, _ret);\n  }\n\n  /**\n   * Add a {@link VideoTrack} to the `VideoTrackList`.\n   *\n   * @param {VideoTrack} track\n   *        The VideoTrack to add to the list\n   *\n   * @fires TrackList#addtrack\n   */\n\n\n  VideoTrackList.prototype.addTrack = function addTrack(track) {\n    var _this2 = this;\n\n    if (track.selected) {\n      disableOthers$1(this, track);\n    }\n\n    _TrackList.prototype.addTrack.call(this, track);\n    // native tracks don't have this\n    if (!track.addEventListener) {\n      return;\n    }\n\n    /**\n     * @listens VideoTrack#selectedchange\n     * @fires TrackList#change\n     */\n    track.addEventListener('selectedchange', function () {\n      if (_this2.changing_) {\n        return;\n      }\n      _this2.changing_ = true;\n      disableOthers$1(_this2, track);\n      _this2.changing_ = false;\n      _this2.trigger('change');\n    });\n  };\n\n  return VideoTrackList;\n}(TrackList);\n\n/**\n * @file text-track-list.js\n */\n/**\n * The current list of {@link TextTrack} for a media file.\n *\n * @see [Spec]{@link https://html.spec.whatwg.org/multipage/embedded-content.html#texttracklist}\n * @extends TrackList\n */\n\nvar TextTrackList = function (_TrackList) {\n  inherits(TextTrackList, _TrackList);\n\n  /**\n   * Create an instance of this class.\n   *\n   * @param {TextTrack[]} [tracks=[]]\n   *        A list of `TextTrack` to instantiate the list with.\n   */\n  function TextTrackList() {\n    var _this, _ret;\n\n    var tracks = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    classCallCheck(this, TextTrackList);\n\n    var list = void 0;\n\n    // IE8 forces us to implement inheritance ourselves\n    // as it does not support Object.defineProperty properly\n    if (IS_IE8) {\n      list = document.createElement('custom');\n      for (var prop in TrackList.prototype) {\n        if (prop !== 'constructor') {\n          list[prop] = TrackList.prototype[prop];\n        }\n      }\n      for (var _prop in TextTrackList.prototype) {\n        if (_prop !== 'constructor') {\n          list[_prop] = TextTrackList.prototype[_prop];\n        }\n      }\n    }\n\n    list = (_this = possibleConstructorReturn(this, _TrackList.call(this, tracks, list)), _this);\n    return _ret = list, possibleConstructorReturn(_this, _ret);\n  }\n\n  /**\n   * Add a {@link TextTrack} to the `TextTrackList`\n   *\n   * @param {TextTrack} track\n   *        The text track to add to the list.\n   *\n   * @fires TrackList#addtrack\n   */\n\n\n  TextTrackList.prototype.addTrack = function addTrack(track) {\n    _TrackList.prototype.addTrack.call(this, track);\n\n    /**\n     * @listens TextTrack#modechange\n     * @fires TrackList#change\n     */\n    track.addEventListener('modechange', bind(this, function () {\n      this.trigger('change');\n    }));\n\n    var nonLanguageTextTrackKind = ['metadata', 'chapters'];\n\n    if (nonLanguageTextTrackKind.indexOf(track.kind) === -1) {\n      track.addEventListener('modechange', bind(this, function () {\n        this.trigger('selectedlanguagechange');\n      }));\n    }\n  };\n\n  return TextTrackList;\n}(TrackList);\n\n/**\n * @file html-track-element-list.js\n */\n\n/**\n * The current list of {@link HtmlTrackElement}s.\n */\n\nvar HtmlTrackElementList = function () {\n\n  /**\n   * Create an instance of this class.\n   *\n   * @param {HtmlTrackElement[]} [tracks=[]]\n   *        A list of `HtmlTrackElement` to instantiate the list with.\n   */\n  function HtmlTrackElementList() {\n    var trackElements = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    classCallCheck(this, HtmlTrackElementList);\n\n    var list = this; // eslint-disable-line\n\n    if (IS_IE8) {\n      list = document.createElement('custom');\n\n      for (var prop in HtmlTrackElementList.prototype) {\n        if (prop !== 'constructor') {\n          list[prop] = HtmlTrackElementList.prototype[prop];\n        }\n      }\n    }\n\n    list.trackElements_ = [];\n\n    /**\n     * @memberof HtmlTrackElementList\n     * @member {number} length\n     *         The current number of `Track`s in the this Trackist.\n     * @instance\n     */\n    Object.defineProperty(list, 'length', {\n      get: function get$$1() {\n        return this.trackElements_.length;\n      }\n    });\n\n    for (var i = 0, length = trackElements.length; i < length; i++) {\n      list.addTrackElement_(trackElements[i]);\n    }\n\n    if (IS_IE8) {\n      return list;\n    }\n  }\n\n  /**\n   * Add an {@link HtmlTrackElement} to the `HtmlTrackElementList`\n   *\n   * @param {HtmlTrackElement} trackElement\n   *        The track element to add to the list.\n   *\n   * @private\n   */\n\n\n  HtmlTrackElementList.prototype.addTrackElement_ = function addTrackElement_(trackElement) {\n    var index = this.trackElements_.length;\n\n    if (!('' + index in this)) {\n      Object.defineProperty(this, index, {\n        get: function get$$1() {\n          return this.trackElements_[index];\n        }\n      });\n    }\n\n    // Do not add duplicate elements\n    if (this.trackElements_.indexOf(trackElement) === -1) {\n      this.trackElements_.push(trackElement);\n    }\n  };\n\n  /**\n   * Get an {@link HtmlTrackElement} from the `HtmlTrackElementList` given an\n   * {@link TextTrack}.\n   *\n   * @param {TextTrack} track\n   *        The track associated with a track element.\n   *\n   * @return {HtmlTrackElement|undefined}\n   *         The track element that was found or undefined.\n   *\n   * @private\n   */\n\n\n  HtmlTrackElementList.prototype.getTrackElementByTrack_ = function getTrackElementByTrack_(track) {\n    var trackElement_ = void 0;\n\n    for (var i = 0, length = this.trackElements_.length; i < length; i++) {\n      if (track === this.trackElements_[i].track) {\n        trackElement_ = this.trackElements_[i];\n\n        break;\n      }\n    }\n\n    return trackElement_;\n  };\n\n  /**\n   * Remove a {@link HtmlTrackElement} from the `HtmlTrackElementList`\n   *\n   * @param {HtmlTrackElement} trackElement\n   *        The track element to remove from the list.\n   *\n   * @private\n   */\n\n\n  HtmlTrackElementList.prototype.removeTrackElement_ = function removeTrackElement_(trackElement) {\n    for (var i = 0, length = this.trackElements_.length; i < length; i++) {\n      if (trackElement === this.trackElements_[i]) {\n        this.trackElements_.splice(i, 1);\n\n        break;\n      }\n    }\n  };\n\n  return HtmlTrackElementList;\n}();\n\n/**\n * @file text-track-cue-list.js\n */\n/**\n * @typedef {Object} TextTrackCueList~TextTrackCue\n *\n * @property {string} id\n *           The unique id for this text track cue\n *\n * @property {number} startTime\n *           The start time for this text track cue\n *\n * @property {number} endTime\n *           The end time for this text track cue\n *\n * @property {boolean} pauseOnExit\n *           Pause when the end time is reached if true.\n *\n * @see [Spec]{@link https://html.spec.whatwg.org/multipage/embedded-content.html#texttrackcue}\n */\n\n/**\n * A List of TextTrackCues.\n *\n * @see [Spec]{@link https://html.spec.whatwg.org/multipage/embedded-content.html#texttrackcuelist}\n */\n\nvar TextTrackCueList = function () {\n\n  /**\n   * Create an instance of this class..\n   *\n   * @param {Array} cues\n   *        A list of cues to be initialized with\n   */\n  function TextTrackCueList(cues) {\n    classCallCheck(this, TextTrackCueList);\n\n    var list = this; // eslint-disable-line\n\n    if (IS_IE8) {\n      list = document.createElement('custom');\n\n      for (var prop in TextTrackCueList.prototype) {\n        if (prop !== 'constructor') {\n          list[prop] = TextTrackCueList.prototype[prop];\n        }\n      }\n    }\n\n    TextTrackCueList.prototype.setCues_.call(list, cues);\n\n    /**\n     * @memberof TextTrackCueList\n     * @member {number} length\n     *         The current number of `TextTrackCue`s in the TextTrackCueList.\n     * @instance\n     */\n    Object.defineProperty(list, 'length', {\n      get: function get$$1() {\n        return this.length_;\n      }\n    });\n\n    if (IS_IE8) {\n      return list;\n    }\n  }\n\n  /**\n   * A setter for cues in this list. Creates getters\n   * an an index for the cues.\n   *\n   * @param {Array} cues\n   *        An array of cues to set\n   *\n   * @private\n   */\n\n\n  TextTrackCueList.prototype.setCues_ = function setCues_(cues) {\n    var oldLength = this.length || 0;\n    var i = 0;\n    var l = cues.length;\n\n    this.cues_ = cues;\n    this.length_ = cues.length;\n\n    var defineProp = function defineProp(index) {\n      if (!('' + index in this)) {\n        Object.defineProperty(this, '' + index, {\n          get: function get$$1() {\n            return this.cues_[index];\n          }\n        });\n      }\n    };\n\n    if (oldLength < l) {\n      i = oldLength;\n\n      for (; i < l; i++) {\n        defineProp.call(this, i);\n      }\n    }\n  };\n\n  /**\n   * Get a `TextTrackCue` that is currently in the `TextTrackCueList` by id.\n   *\n   * @param {string} id\n   *        The id of the cue that should be searched for.\n   *\n   * @return {TextTrackCueList~TextTrackCue|null}\n   *         A single cue or null if none was found.\n   */\n\n\n  TextTrackCueList.prototype.getCueById = function getCueById(id) {\n    var result = null;\n\n    for (var i = 0, l = this.length; i < l; i++) {\n      var cue = this[i];\n\n      if (cue.id === id) {\n        result = cue;\n        break;\n      }\n    }\n\n    return result;\n  };\n\n  return TextTrackCueList;\n}();\n\n/**\n * @file track-kinds.js\n */\n\n/**\n * All possible `VideoTrackKind`s\n *\n * @see https://html.spec.whatwg.org/multipage/embedded-content.html#dom-videotrack-kind\n * @typedef VideoTrack~Kind\n * @enum\n */\nvar VideoTrackKind = {\n  alternative: 'alternative',\n  captions: 'captions',\n  main: 'main',\n  sign: 'sign',\n  subtitles: 'subtitles',\n  commentary: 'commentary'\n};\n\n/**\n * All possible `AudioTrackKind`s\n *\n * @see https://html.spec.whatwg.org/multipage/embedded-content.html#dom-audiotrack-kind\n * @typedef AudioTrack~Kind\n * @enum\n */\nvar AudioTrackKind = {\n  'alternative': 'alternative',\n  'descriptions': 'descriptions',\n  'main': 'main',\n  'main-desc': 'main-desc',\n  'translation': 'translation',\n  'commentary': 'commentary'\n};\n\n/**\n * All possible `TextTrackKind`s\n *\n * @see https://html.spec.whatwg.org/multipage/embedded-content.html#dom-texttrack-kind\n * @typedef TextTrack~Kind\n * @enum\n */\nvar TextTrackKind = {\n  subtitles: 'subtitles',\n  captions: 'captions',\n  descriptions: 'descriptions',\n  chapters: 'chapters',\n  metadata: 'metadata'\n};\n\n/**\n * All possible `TextTrackMode`s\n *\n * @see https://html.spec.whatwg.org/multipage/embedded-content.html#texttrackmode\n * @typedef TextTrack~Mode\n * @enum\n */\nvar TextTrackMode = {\n  disabled: 'disabled',\n  hidden: 'hidden',\n  showing: 'showing'\n};\n\n/**\n * @file track.js\n */\n/**\n * A Track class that contains all of the common functionality for {@link AudioTrack},\n * {@link VideoTrack}, and {@link TextTrack}.\n *\n * > Note: This class should not be used directly\n *\n * @see {@link https://html.spec.whatwg.org/multipage/embedded-content.html}\n * @extends EventTarget\n * @abstract\n */\n\nvar Track = function (_EventTarget) {\n  inherits(Track, _EventTarget);\n\n  /**\n   * Create an instance of this class.\n   *\n   * @param {Object} [options={}]\n   *        Object of option names and values\n   *\n   * @param {string} [options.kind='']\n   *        A valid kind for the track type you are creating.\n   *\n   * @param {string} [options.id='vjs_track_' + Guid.newGUID()]\n   *        A unique id for this AudioTrack.\n   *\n   * @param {string} [options.label='']\n   *        The menu label for this track.\n   *\n   * @param {string} [options.language='']\n   *        A valid two character language code.\n   *\n   * @abstract\n   */\n  function Track() {\n    var _ret;\n\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    classCallCheck(this, Track);\n\n    var _this = possibleConstructorReturn(this, _EventTarget.call(this));\n\n    var track = _this; // eslint-disable-line\n\n    if (IS_IE8) {\n      track = document.createElement('custom');\n      for (var prop in Track.prototype) {\n        if (prop !== 'constructor') {\n          track[prop] = Track.prototype[prop];\n        }\n      }\n    }\n\n    var trackProps = {\n      id: options.id || 'vjs_track_' + newGUID(),\n      kind: options.kind || '',\n      label: options.label || '',\n      language: options.language || ''\n    };\n\n    /**\n     * @memberof Track\n     * @member {string} id\n     *         The id of this track. Cannot be changed after creation.\n     * @instance\n     *\n     * @readonly\n     */\n\n    /**\n     * @memberof Track\n     * @member {string} kind\n     *         The kind of track that this is. Cannot be changed after creation.\n     * @instance\n     *\n     * @readonly\n     */\n\n    /**\n     * @memberof Track\n     * @member {string} label\n     *         The label of this track. Cannot be changed after creation.\n     * @instance\n     *\n     * @readonly\n     */\n\n    /**\n     * @memberof Track\n     * @member {string} language\n     *         The two letter language code for this track. Cannot be changed after\n     *         creation.\n     * @instance\n     *\n     * @readonly\n     */\n\n    var _loop = function _loop(key) {\n      Object.defineProperty(track, key, {\n        get: function get$$1() {\n          return trackProps[key];\n        },\n        set: function set$$1() {}\n      });\n    };\n\n    for (var key in trackProps) {\n      _loop(key);\n    }\n\n    return _ret = track, possibleConstructorReturn(_this, _ret);\n  }\n\n  return Track;\n}(EventTarget);\n\n/**\n * @file url.js\n * @module url\n */\n/**\n * @typedef {Object} url:URLObject\n *\n * @property {string} protocol\n *           The protocol of the url that was parsed.\n *\n * @property {string} hostname\n *           The hostname of the url that was parsed.\n *\n * @property {string} port\n *           The port of the url that was parsed.\n *\n * @property {string} pathname\n *           The pathname of the url that was parsed.\n *\n * @property {string} search\n *           The search query of the url that was parsed.\n *\n * @property {string} hash\n *           The hash of the url that was parsed.\n *\n * @property {string} host\n *           The host of the url that was parsed.\n */\n\n/**\n * Resolve and parse the elements of a URL.\n *\n * @param  {String} url\n *         The url to parse\n *\n * @return {url:URLObject}\n *         An object of url details\n */\nvar parseUrl = function parseUrl(url) {\n  var props = ['protocol', 'hostname', 'port', 'pathname', 'search', 'hash', 'host'];\n\n  // add the url to an anchor and let the browser parse the URL\n  var a = document.createElement('a');\n\n  a.href = url;\n\n  // IE8 (and 9?) Fix\n  // ie8 doesn't parse the URL correctly until the anchor is actually\n  // added to the body, and an innerHTML is needed to trigger the parsing\n  var addToBody = a.host === '' && a.protocol !== 'file:';\n  var div = void 0;\n\n  if (addToBody) {\n    div = document.createElement('div');\n    div.innerHTML = '<a href=\"' + url + '\"></a>';\n    a = div.firstChild;\n    // prevent the div from affecting layout\n    div.setAttribute('style', 'display:none; position:absolute;');\n    document.body.appendChild(div);\n  }\n\n  // Copy the specific URL properties to a new object\n  // This is also needed for IE8 because the anchor loses its\n  // properties when it's removed from the dom\n  var details = {};\n\n  for (var i = 0; i < props.length; i++) {\n    details[props[i]] = a[props[i]];\n  }\n\n  // IE9 adds the port to the host property unlike everyone else. If\n  // a port identifier is added for standard ports, strip it.\n  if (details.protocol === 'http:') {\n    details.host = details.host.replace(/:80$/, '');\n  }\n\n  if (details.protocol === 'https:') {\n    details.host = details.host.replace(/:443$/, '');\n  }\n\n  if (!details.protocol) {\n    details.protocol = window.location.protocol;\n  }\n\n  if (addToBody) {\n    document.body.removeChild(div);\n  }\n\n  return details;\n};\n\n/**\n * Get absolute version of relative URL. Used to tell flash correct URL.\n *\n *\n * @param  {string} url\n *         URL to make absolute\n *\n * @return {string}\n *         Absolute URL\n *\n * @see http://stackoverflow.com/questions/470832/getting-an-absolute-url-from-a-relative-one-ie6-issue\n */\nvar getAbsoluteURL = function getAbsoluteURL(url) {\n  // Check if absolute URL\n  if (!url.match(/^https?:\\/\\//)) {\n    // Convert to absolute URL. Flash hosted off-site needs an absolute URL.\n    var div = document.createElement('div');\n\n    div.innerHTML = '<a href=\"' + url + '\">x</a>';\n    url = div.firstChild.href;\n  }\n\n  return url;\n};\n\n/**\n * Returns the extension of the passed file name. It will return an empty string\n * if passed an invalid path.\n *\n * @param {string} path\n *        The fileName path like '/path/to/file.mp4'\n *\n * @returns {string}\n *          The extension in lower case or an empty string if no\n *          extension could be found.\n */\nvar getFileExtension = function getFileExtension(path) {\n  if (typeof path === 'string') {\n    var splitPathRe = /^(\\/?)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?)(\\.([^\\.\\/\\?]+)))(?:[\\/]*|[\\?].*)$/i;\n    var pathParts = splitPathRe.exec(path);\n\n    if (pathParts) {\n      return pathParts.pop().toLowerCase();\n    }\n  }\n\n  return '';\n};\n\n/**\n * Returns whether the url passed is a cross domain request or not.\n *\n * @param {string} url\n *        The url to check.\n *\n * @return {boolean}\n *         Whether it is a cross domain request or not.\n */\nvar isCrossOrigin = function isCrossOrigin(url) {\n  var winLoc = window.location;\n  var urlInfo = parseUrl(url);\n\n  // IE8 protocol relative urls will return ':' for protocol\n  var srcProtocol = urlInfo.protocol === ':' ? winLoc.protocol : urlInfo.protocol;\n\n  // Check if url is for another domain/origin\n  // IE8 doesn't know location.origin, so we won't rely on it here\n  var crossOrigin = srcProtocol + urlInfo.host !== winLoc.protocol + winLoc.host;\n\n  return crossOrigin;\n};\n\nvar Url = (Object.freeze || Object)({\n\tparseUrl: parseUrl,\n\tgetAbsoluteURL: getAbsoluteURL,\n\tgetFileExtension: getFileExtension,\n\tisCrossOrigin: isCrossOrigin\n});\n\n/**\n * @file text-track.js\n */\n/**\n * Takes a webvtt file contents and parses it into cues\n *\n * @param {string} srcContent\n *        webVTT file contents\n *\n * @param {TextTrack} track\n *        TextTrack to add cues to. Cues come from the srcContent.\n *\n * @private\n */\nvar parseCues = function parseCues(srcContent, track) {\n  var parser = new window.WebVTT.Parser(window, window.vttjs, window.WebVTT.StringDecoder());\n  var errors = [];\n\n  parser.oncue = function (cue) {\n    track.addCue(cue);\n  };\n\n  parser.onparsingerror = function (error) {\n    errors.push(error);\n  };\n\n  parser.onflush = function () {\n    track.trigger({\n      type: 'loadeddata',\n      target: track\n    });\n  };\n\n  parser.parse(srcContent);\n  if (errors.length > 0) {\n    if (window.console && window.console.groupCollapsed) {\n      window.console.groupCollapsed('Text Track parsing errors for ' + track.src);\n    }\n    errors.forEach(function (error) {\n      return log.error(error);\n    });\n    if (window.console && window.console.groupEnd) {\n      window.console.groupEnd();\n    }\n  }\n\n  parser.flush();\n};\n\n/**\n * Load a `TextTrack` from a specifed url.\n *\n * @param {string} src\n *        Url to load track from.\n *\n * @param {TextTrack} track\n *        Track to add cues to. Comes from the content at the end of `url`.\n *\n * @private\n */\nvar loadTrack = function loadTrack(src, track) {\n  var opts = {\n    uri: src\n  };\n  var crossOrigin = isCrossOrigin(src);\n\n  if (crossOrigin) {\n    opts.cors = crossOrigin;\n  }\n\n  xhr(opts, bind(this, function (err, response, responseBody) {\n    if (err) {\n      return log.error(err, response);\n    }\n\n    track.loaded_ = true;\n\n    // Make sure that vttjs has loaded, otherwise, wait till it finished loading\n    // NOTE: this is only used for the alt/video.novtt.js build\n    if (typeof window.WebVTT !== 'function') {\n      if (track.tech_) {\n        var loadHandler = function loadHandler() {\n          return parseCues(responseBody, track);\n        };\n\n        track.tech_.on('vttjsloaded', loadHandler);\n        track.tech_.on('vttjserror', function () {\n          log.error('vttjs failed to load, stopping trying to process ' + track.src);\n          track.tech_.off('vttjsloaded', loadHandler);\n        });\n      }\n    } else {\n      parseCues(responseBody, track);\n    }\n  }));\n};\n\n/**\n * A representation of a single `TextTrack`.\n *\n * @see [Spec]{@link https://html.spec.whatwg.org/multipage/embedded-content.html#texttrack}\n * @extends Track\n */\n\nvar TextTrack = function (_Track) {\n  inherits(TextTrack, _Track);\n\n  /**\n   * Create an instance of this class.\n   *\n   * @param {Object} options={}\n   *        Object of option names and values\n   *\n   * @param {Tech} options.tech\n   *        A reference to the tech that owns this TextTrack.\n   *\n   * @param {TextTrack~Kind} [options.kind='subtitles']\n   *        A valid text track kind.\n   *\n   * @param {TextTrack~Mode} [options.mode='disabled']\n   *        A valid text track mode.\n   *\n   * @param {string} [options.id='vjs_track_' + Guid.newGUID()]\n   *        A unique id for this TextTrack.\n   *\n   * @param {string} [options.label='']\n   *        The menu label for this track.\n   *\n   * @param {string} [options.language='']\n   *        A valid two character language code.\n   *\n   * @param {string} [options.srclang='']\n   *        A valid two character language code. An alternative, but deprioritized\n   *        vesion of `options.language`\n   *\n   * @param {string} [options.src]\n   *        A url to TextTrack cues.\n   *\n   * @param {boolean} [options.default]\n   *        If this track should default to on or off.\n   */\n  function TextTrack() {\n    var _this, _ret;\n\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    classCallCheck(this, TextTrack);\n\n    if (!options.tech) {\n      throw new Error('A tech was not provided.');\n    }\n\n    var settings = mergeOptions(options, {\n      kind: TextTrackKind[options.kind] || 'subtitles',\n      language: options.language || options.srclang || ''\n    });\n    var mode = TextTrackMode[settings.mode] || 'disabled';\n    var default_ = settings['default'];\n\n    if (settings.kind === 'metadata' || settings.kind === 'chapters') {\n      mode = 'hidden';\n    }\n    // on IE8 this will be a document element\n    // for every other browser this will be a normal object\n    var tt = (_this = possibleConstructorReturn(this, _Track.call(this, settings)), _this);\n\n    tt.tech_ = settings.tech;\n\n    if (IS_IE8) {\n      for (var prop in TextTrack.prototype) {\n        if (prop !== 'constructor') {\n          tt[prop] = TextTrack.prototype[prop];\n        }\n      }\n    }\n\n    tt.cues_ = [];\n    tt.activeCues_ = [];\n\n    var cues = new TextTrackCueList(tt.cues_);\n    var activeCues = new TextTrackCueList(tt.activeCues_);\n    var changed = false;\n    var timeupdateHandler = bind(tt, function () {\n\n      // Accessing this.activeCues for the side-effects of updating itself\n      // due to it's nature as a getter function. Do not remove or cues will\n      // stop updating!\n      // Use the setter to prevent deletion from uglify (pure_getters rule)\n      this.activeCues = this.activeCues;\n      if (changed) {\n        this.trigger('cuechange');\n        changed = false;\n      }\n    });\n\n    if (mode !== 'disabled') {\n      tt.tech_.ready(function () {\n        tt.tech_.on('timeupdate', timeupdateHandler);\n      }, true);\n    }\n\n    /**\n     * @memberof TextTrack\n     * @member {boolean} default\n     *         If this track was set to be on or off by default. Cannot be changed after\n     *         creation.\n     * @instance\n     *\n     * @readonly\n     */\n    Object.defineProperty(tt, 'default', {\n      get: function get$$1() {\n        return default_;\n      },\n      set: function set$$1() {}\n    });\n\n    /**\n     * @memberof TextTrack\n     * @member {string} mode\n     *         Set the mode of this TextTrack to a valid {@link TextTrack~Mode}. Will\n     *         not be set if setting to an invalid mode.\n     * @instance\n     *\n     * @fires TextTrack#modechange\n     */\n    Object.defineProperty(tt, 'mode', {\n      get: function get$$1() {\n        return mode;\n      },\n      set: function set$$1(newMode) {\n        var _this2 = this;\n\n        if (!TextTrackMode[newMode]) {\n          return;\n        }\n        mode = newMode;\n        if (mode !== 'disabled') {\n\n          this.tech_.ready(function () {\n            _this2.tech_.on('timeupdate', timeupdateHandler);\n          }, true);\n        } else {\n          this.tech_.off('timeupdate', timeupdateHandler);\n        }\n        /**\n         * An event that fires when mode changes on this track. This allows\n         * the TextTrackList that holds this track to act accordingly.\n         *\n         * > Note: This is not part of the spec!\n         *\n         * @event TextTrack#modechange\n         * @type {EventTarget~Event}\n         */\n        this.trigger('modechange');\n      }\n    });\n\n    /**\n     * @memberof TextTrack\n     * @member {TextTrackCueList} cues\n     *         The text track cue list for this TextTrack.\n     * @instance\n     */\n    Object.defineProperty(tt, 'cues', {\n      get: function get$$1() {\n        if (!this.loaded_) {\n          return null;\n        }\n\n        return cues;\n      },\n      set: function set$$1() {}\n    });\n\n    /**\n     * @memberof TextTrack\n     * @member {TextTrackCueList} activeCues\n     *         The list text track cues that are currently active for this TextTrack.\n     * @instance\n     */\n    Object.defineProperty(tt, 'activeCues', {\n      get: function get$$1() {\n        if (!this.loaded_) {\n          return null;\n        }\n\n        // nothing to do\n        if (this.cues.length === 0) {\n          return activeCues;\n        }\n\n        var ct = this.tech_.currentTime();\n        var active = [];\n\n        for (var i = 0, l = this.cues.length; i < l; i++) {\n          var cue = this.cues[i];\n\n          if (cue.startTime <= ct && cue.endTime >= ct) {\n            active.push(cue);\n          } else if (cue.startTime === cue.endTime && cue.startTime <= ct && cue.startTime + 0.5 >= ct) {\n            active.push(cue);\n          }\n        }\n\n        changed = false;\n\n        if (active.length !== this.activeCues_.length) {\n          changed = true;\n        } else {\n          for (var _i = 0; _i < active.length; _i++) {\n            if (this.activeCues_.indexOf(active[_i]) === -1) {\n              changed = true;\n            }\n          }\n        }\n\n        this.activeCues_ = active;\n        activeCues.setCues_(this.activeCues_);\n\n        return activeCues;\n      },\n\n\n      // /!\\ Keep this setter empty (see the timeupdate handler above)\n      set: function set$$1() {}\n    });\n\n    if (settings.src) {\n      tt.src = settings.src;\n      loadTrack(settings.src, tt);\n    } else {\n      tt.loaded_ = true;\n    }\n\n    return _ret = tt, possibleConstructorReturn(_this, _ret);\n  }\n\n  /**\n   * Add a cue to the internal list of cues.\n   *\n   * @param {TextTrack~Cue} cue\n   *        The cue to add to our internal list\n   */\n\n\n  TextTrack.prototype.addCue = function addCue(originalCue) {\n    var cue = originalCue;\n\n    if (window.vttjs && !(originalCue instanceof window.vttjs.VTTCue)) {\n      cue = new window.vttjs.VTTCue(originalCue.startTime, originalCue.endTime, originalCue.text);\n\n      for (var prop in originalCue) {\n        if (!(prop in cue)) {\n          cue[prop] = originalCue[prop];\n        }\n      }\n\n      // make sure that `id` is copied over\n      cue.id = originalCue.id;\n      cue.originalCue_ = originalCue;\n    }\n\n    var tracks = this.tech_.textTracks();\n\n    for (var i = 0; i < tracks.length; i++) {\n      if (tracks[i] !== this) {\n        tracks[i].removeCue(cue);\n      }\n    }\n\n    this.cues_.push(cue);\n    this.cues.setCues_(this.cues_);\n  };\n\n  /**\n   * Remove a cue from our internal list\n   *\n   * @param {TextTrack~Cue} removeCue\n   *        The cue to remove from our internal list\n   */\n\n\n  TextTrack.prototype.removeCue = function removeCue(_removeCue) {\n    var i = this.cues_.length;\n\n    while (i--) {\n      var cue = this.cues_[i];\n\n      if (cue === _removeCue || cue.originalCue_ && cue.originalCue_ === _removeCue) {\n        this.cues_.splice(i, 1);\n        this.cues.setCues_(this.cues_);\n        break;\n      }\n    }\n  };\n\n  return TextTrack;\n}(Track);\n\n/**\n * cuechange - One or more cues in the track have become active or stopped being active.\n */\n\n\nTextTrack.prototype.allowedEvents_ = {\n  cuechange: 'cuechange'\n};\n\n/**\n * A representation of a single `AudioTrack`. If it is part of an {@link AudioTrackList}\n * only one `AudioTrack` in the list will be enabled at a time.\n *\n * @see [Spec]{@link https://html.spec.whatwg.org/multipage/embedded-content.html#audiotrack}\n * @extends Track\n */\n\nvar AudioTrack = function (_Track) {\n  inherits(AudioTrack, _Track);\n\n  /**\n   * Create an instance of this class.\n   *\n   * @param {Object} [options={}]\n   *        Object of option names and values\n   *\n   * @param {AudioTrack~Kind} [options.kind='']\n   *        A valid audio track kind\n   *\n   * @param {string} [options.id='vjs_track_' + Guid.newGUID()]\n   *        A unique id for this AudioTrack.\n   *\n   * @param {string} [options.label='']\n   *        The menu label for this track.\n   *\n   * @param {string} [options.language='']\n   *        A valid two character language code.\n   *\n   * @param {boolean} [options.enabled]\n   *        If this track is the one that is currently playing. If this track is part of\n   *        an {@link AudioTrackList}, only one {@link AudioTrack} will be enabled.\n   */\n  function AudioTrack() {\n    var _this, _ret;\n\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    classCallCheck(this, AudioTrack);\n\n    var settings = mergeOptions(options, {\n      kind: AudioTrackKind[options.kind] || ''\n    });\n    // on IE8 this will be a document element\n    // for every other browser this will be a normal object\n    var track = (_this = possibleConstructorReturn(this, _Track.call(this, settings)), _this);\n    var enabled = false;\n\n    if (IS_IE8) {\n      for (var prop in AudioTrack.prototype) {\n        if (prop !== 'constructor') {\n          track[prop] = AudioTrack.prototype[prop];\n        }\n      }\n    }\n    /**\n     * @memberof AudioTrack\n     * @member {boolean} enabled\n     *         If this `AudioTrack` is enabled or not. When setting this will\n     *         fire {@link AudioTrack#enabledchange} if the state of enabled is changed.\n     * @instance\n     *\n     * @fires VideoTrack#selectedchange\n     */\n    Object.defineProperty(track, 'enabled', {\n      get: function get$$1() {\n        return enabled;\n      },\n      set: function set$$1(newEnabled) {\n        // an invalid or unchanged value\n        if (typeof newEnabled !== 'boolean' || newEnabled === enabled) {\n          return;\n        }\n        enabled = newEnabled;\n\n        /**\n         * An event that fires when enabled changes on this track. This allows\n         * the AudioTrackList that holds this track to act accordingly.\n         *\n         * > Note: This is not part of the spec! Native tracks will do\n         *         this internally without an event.\n         *\n         * @event AudioTrack#enabledchange\n         * @type {EventTarget~Event}\n         */\n        this.trigger('enabledchange');\n      }\n    });\n\n    // if the user sets this track to selected then\n    // set selected to that true value otherwise\n    // we keep it false\n    if (settings.enabled) {\n      track.enabled = settings.enabled;\n    }\n    track.loaded_ = true;\n\n    return _ret = track, possibleConstructorReturn(_this, _ret);\n  }\n\n  return AudioTrack;\n}(Track);\n\n/**\n * A representation of a single `VideoTrack`.\n *\n * @see [Spec]{@link https://html.spec.whatwg.org/multipage/embedded-content.html#videotrack}\n * @extends Track\n */\n\nvar VideoTrack = function (_Track) {\n  inherits(VideoTrack, _Track);\n\n  /**\n   * Create an instance of this class.\n   *\n   * @param {Object} [options={}]\n   *        Object of option names and values\n   *\n   * @param {string} [options.kind='']\n   *        A valid {@link VideoTrack~Kind}\n   *\n   * @param {string} [options.id='vjs_track_' + Guid.newGUID()]\n   *        A unique id for this AudioTrack.\n   *\n   * @param {string} [options.label='']\n   *        The menu label for this track.\n   *\n   * @param {string} [options.language='']\n   *        A valid two character language code.\n   *\n   * @param {boolean} [options.selected]\n   *        If this track is the one that is currently playing.\n   */\n  function VideoTrack() {\n    var _this, _ret;\n\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    classCallCheck(this, VideoTrack);\n\n    var settings = mergeOptions(options, {\n      kind: VideoTrackKind[options.kind] || ''\n    });\n\n    // on IE8 this will be a document element\n    // for every other browser this will be a normal object\n    var track = (_this = possibleConstructorReturn(this, _Track.call(this, settings)), _this);\n    var selected = false;\n\n    if (IS_IE8) {\n      for (var prop in VideoTrack.prototype) {\n        if (prop !== 'constructor') {\n          track[prop] = VideoTrack.prototype[prop];\n        }\n      }\n    }\n\n    /**\n     * @memberof VideoTrack\n     * @member {boolean} selected\n     *         If this `VideoTrack` is selected or not. When setting this will\n     *         fire {@link VideoTrack#selectedchange} if the state of selected changed.\n     * @instance\n     *\n     * @fires VideoTrack#selectedchange\n     */\n    Object.defineProperty(track, 'selected', {\n      get: function get$$1() {\n        return selected;\n      },\n      set: function set$$1(newSelected) {\n        // an invalid or unchanged value\n        if (typeof newSelected !== 'boolean' || newSelected === selected) {\n          return;\n        }\n        selected = newSelected;\n\n        /**\n         * An event that fires when selected changes on this track. This allows\n         * the VideoTrackList that holds this track to act accordingly.\n         *\n         * > Note: This is not part of the spec! Native tracks will do\n         *         this internally without an event.\n         *\n         * @event VideoTrack#selectedchange\n         * @type {EventTarget~Event}\n         */\n        this.trigger('selectedchange');\n      }\n    });\n\n    // if the user sets this track to selected then\n    // set selected to that true value otherwise\n    // we keep it false\n    if (settings.selected) {\n      track.selected = settings.selected;\n    }\n\n    return _ret = track, possibleConstructorReturn(_this, _ret);\n  }\n\n  return VideoTrack;\n}(Track);\n\n/**\n * @file html-track-element.js\n */\n\n/**\n * @memberof HTMLTrackElement\n * @typedef {HTMLTrackElement~ReadyState}\n * @enum {number}\n */\nvar NONE = 0;\nvar LOADING = 1;\nvar LOADED = 2;\nvar ERROR = 3;\n\n/**\n * A single track represented in the DOM.\n *\n * @see [Spec]{@link https://html.spec.whatwg.org/multipage/embedded-content.html#htmltrackelement}\n * @extends EventTarget\n */\n\nvar HTMLTrackElement = function (_EventTarget) {\n  inherits(HTMLTrackElement, _EventTarget);\n\n  /**\n   * Create an instance of this class.\n   *\n   * @param {Object} options={}\n   *        Object of option names and values\n   *\n   * @param {Tech} options.tech\n   *        A reference to the tech that owns this HTMLTrackElement.\n   *\n   * @param {TextTrack~Kind} [options.kind='subtitles']\n   *        A valid text track kind.\n   *\n   * @param {TextTrack~Mode} [options.mode='disabled']\n   *        A valid text track mode.\n   *\n   * @param {string} [options.id='vjs_track_' + Guid.newGUID()]\n   *        A unique id for this TextTrack.\n   *\n   * @param {string} [options.label='']\n   *        The menu label for this track.\n   *\n   * @param {string} [options.language='']\n   *        A valid two character language code.\n   *\n   * @param {string} [options.srclang='']\n   *        A valid two character language code. An alternative, but deprioritized\n   *        vesion of `options.language`\n   *\n   * @param {string} [options.src]\n   *        A url to TextTrack cues.\n   *\n   * @param {boolean} [options.default]\n   *        If this track should default to on or off.\n   */\n  function HTMLTrackElement() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    classCallCheck(this, HTMLTrackElement);\n\n    var _this = possibleConstructorReturn(this, _EventTarget.call(this));\n\n    var readyState = void 0;\n    var trackElement = _this; // eslint-disable-line\n\n    if (IS_IE8) {\n      trackElement = document.createElement('custom');\n\n      for (var prop in HTMLTrackElement.prototype) {\n        if (prop !== 'constructor') {\n          trackElement[prop] = HTMLTrackElement.prototype[prop];\n        }\n      }\n    }\n\n    var track = new TextTrack(options);\n\n    trackElement.kind = track.kind;\n    trackElement.src = track.src;\n    trackElement.srclang = track.language;\n    trackElement.label = track.label;\n    trackElement['default'] = track['default'];\n\n    /**\n     * @memberof HTMLTrackElement\n     * @member {HTMLTrackElement~ReadyState} readyState\n     *         The current ready state of the track element.\n     * @instance\n     */\n    Object.defineProperty(trackElement, 'readyState', {\n      get: function get$$1() {\n        return readyState;\n      }\n    });\n\n    /**\n     * @memberof HTMLTrackElement\n     * @member {TextTrack} track\n     *         The underlying TextTrack object.\n     * @instance\n     *\n     */\n    Object.defineProperty(trackElement, 'track', {\n      get: function get$$1() {\n        return track;\n      }\n    });\n\n    readyState = NONE;\n\n    /**\n     * @listens TextTrack#loadeddata\n     * @fires HTMLTrackElement#load\n     */\n    track.addEventListener('loadeddata', function () {\n      readyState = LOADED;\n\n      trackElement.trigger({\n        type: 'load',\n        target: trackElement\n      });\n    });\n\n    if (IS_IE8) {\n      var _ret;\n\n      return _ret = trackElement, possibleConstructorReturn(_this, _ret);\n    }\n    return _this;\n  }\n\n  return HTMLTrackElement;\n}(EventTarget);\n\nHTMLTrackElement.prototype.allowedEvents_ = {\n  load: 'load'\n};\n\nHTMLTrackElement.NONE = NONE;\nHTMLTrackElement.LOADING = LOADING;\nHTMLTrackElement.LOADED = LOADED;\nHTMLTrackElement.ERROR = ERROR;\n\n/*\n * This file contains all track properties that are used in\n * player.js, tech.js, html5.js and possibly other techs in the future.\n */\n\nvar NORMAL = {\n  audio: {\n    ListClass: AudioTrackList,\n    TrackClass: AudioTrack,\n    capitalName: 'Audio'\n  },\n  video: {\n    ListClass: VideoTrackList,\n    TrackClass: VideoTrack,\n    capitalName: 'Video'\n  },\n  text: {\n    ListClass: TextTrackList,\n    TrackClass: TextTrack,\n    capitalName: 'Text'\n  }\n};\n\nObject.keys(NORMAL).forEach(function (type) {\n  NORMAL[type].getterName = type + 'Tracks';\n  NORMAL[type].privateName = type + 'Tracks_';\n});\n\nvar REMOTE = {\n  remoteText: {\n    ListClass: TextTrackList,\n    TrackClass: TextTrack,\n    capitalName: 'RemoteText',\n    getterName: 'remoteTextTracks',\n    privateName: 'remoteTextTracks_'\n  },\n  remoteTextEl: {\n    ListClass: HtmlTrackElementList,\n    TrackClass: HTMLTrackElement,\n    capitalName: 'RemoteTextTrackEls',\n    getterName: 'remoteTextTrackEls',\n    privateName: 'remoteTextTrackEls_'\n  }\n};\n\nvar ALL = mergeOptions(NORMAL, REMOTE);\n\nREMOTE.names = Object.keys(REMOTE);\nNORMAL.names = Object.keys(NORMAL);\nALL.names = [].concat(REMOTE.names).concat(NORMAL.names);\n\n/**\n * @file tech.js\n */\n\n/**\n * An Object containing a structure like: `{src: 'url', type: 'mimetype'}` or string\n * that just contains the src url alone.\n * * `var SourceObject = {src: 'http://ex.com/video.mp4', type: 'video/mp4'};`\n   * `var SourceString = 'http://example.com/some-video.mp4';`\n *\n * @typedef {Object|string} Tech~SourceObject\n *\n * @property {string} src\n *           The url to the source\n *\n * @property {string} type\n *           The mime type of the source\n */\n\n/**\n * A function used by {@link Tech} to create a new {@link TextTrack}.\n *\n * @private\n *\n * @param {Tech} self\n *        An instance of the Tech class.\n *\n * @param {string} kind\n *        `TextTrack` kind (subtitles, captions, descriptions, chapters, or metadata)\n *\n * @param {string} [label]\n *        Label to identify the text track\n *\n * @param {string} [language]\n *        Two letter language abbreviation\n *\n * @param {Object} [options={}]\n *        An object with additional text track options\n *\n * @return {TextTrack}\n *          The text track that was created.\n */\nfunction createTrackHelper(self, kind, label, language) {\n  var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n\n  var tracks = self.textTracks();\n\n  options.kind = kind;\n\n  if (label) {\n    options.label = label;\n  }\n  if (language) {\n    options.language = language;\n  }\n  options.tech = self;\n\n  var track = new ALL.text.TrackClass(options);\n\n  tracks.addTrack(track);\n\n  return track;\n}\n\n/**\n * This is the base class for media playback technology controllers, such as\n * {@link Flash} and {@link HTML5}\n *\n * @extends Component\n */\n\nvar Tech = function (_Component) {\n  inherits(Tech, _Component);\n\n  /**\n   * Create an instance of this Tech.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   *\n   * @param {Component~ReadyCallback} ready\n   *        Callback function to call when the `HTML5` Tech is ready.\n   */\n  function Tech() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var ready = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {};\n    classCallCheck(this, Tech);\n\n    // we don't want the tech to report user activity automatically.\n    // This is done manually in addControlsListeners\n    options.reportTouchActivity = false;\n\n    // keep track of whether the current source has played at all to\n    // implement a very limited played()\n    var _this = possibleConstructorReturn(this, _Component.call(this, null, options, ready));\n\n    _this.hasStarted_ = false;\n    _this.on('playing', function () {\n      this.hasStarted_ = true;\n    });\n    _this.on('loadstart', function () {\n      this.hasStarted_ = false;\n    });\n\n    ALL.names.forEach(function (name) {\n      var props = ALL[name];\n\n      if (options && options[props.getterName]) {\n        _this[props.privateName] = options[props.getterName];\n      }\n    });\n\n    // Manually track progress in cases where the browser/flash player doesn't report it.\n    if (!_this.featuresProgressEvents) {\n      _this.manualProgressOn();\n    }\n\n    // Manually track timeupdates in cases where the browser/flash player doesn't report it.\n    if (!_this.featuresTimeupdateEvents) {\n      _this.manualTimeUpdatesOn();\n    }\n\n    ['Text', 'Audio', 'Video'].forEach(function (track) {\n      if (options['native' + track + 'Tracks'] === false) {\n        _this['featuresNative' + track + 'Tracks'] = false;\n      }\n    });\n\n    if (options.nativeCaptions === false || options.nativeTextTracks === false) {\n      _this.featuresNativeTextTracks = false;\n    } else if (options.nativeCaptions === true || options.nativeTextTracks === true) {\n      _this.featuresNativeTextTracks = true;\n    }\n\n    if (!_this.featuresNativeTextTracks) {\n      _this.emulateTextTracks();\n    }\n\n    _this.autoRemoteTextTracks_ = new ALL.text.ListClass();\n\n    _this.initTrackListeners();\n\n    // Turn on component tap events only if not using native controls\n    if (!options.nativeControlsForTouch) {\n      _this.emitTapEvents();\n    }\n\n    if (_this.constructor) {\n      _this.name_ = _this.constructor.name || 'Unknown Tech';\n    }\n    return _this;\n  }\n\n  /**\n   * A special function to trigger source set in a way that will allow player\n   * to re-trigger if the player or tech are not ready yet.\n   *\n   * @fires Tech#sourceset\n   * @param {string} src The source string at the time of the source changing.\n   */\n\n\n  Tech.prototype.triggerSourceset = function triggerSourceset(src) {\n    var _this2 = this;\n\n    if (!this.isReady_) {\n      // on initial ready we have to trigger source set\n      // 1ms after ready so that player can watch for it.\n      this.one('ready', function () {\n        return _this2.setTimeout(function () {\n          return _this2.triggerSourceset(src);\n        }, 1);\n      });\n    }\n\n    /**\n     * Fired when the source is set on the tech causing the media element\n     * to reload.\n     *\n     * @see {@link Player#event:sourceset}\n     * @event Tech#sourceset\n     * @type {EventTarget~Event}\n     */\n    this.trigger({\n      src: src,\n      type: 'sourceset'\n    });\n  };\n\n  /* Fallbacks for unsupported event types\n  ================================================================================ */\n\n  /**\n   * Polyfill the `progress` event for browsers that don't support it natively.\n   *\n   * @see {@link Tech#trackProgress}\n   */\n\n\n  Tech.prototype.manualProgressOn = function manualProgressOn() {\n    this.on('durationchange', this.onDurationChange);\n\n    this.manualProgress = true;\n\n    // Trigger progress watching when a source begins loading\n    this.one('ready', this.trackProgress);\n  };\n\n  /**\n   * Turn off the polyfill for `progress` events that was created in\n   * {@link Tech#manualProgressOn}\n   */\n\n\n  Tech.prototype.manualProgressOff = function manualProgressOff() {\n    this.manualProgress = false;\n    this.stopTrackingProgress();\n\n    this.off('durationchange', this.onDurationChange);\n  };\n\n  /**\n   * This is used to trigger a `progress` event when the buffered percent changes. It\n   * sets an interval function that will be called every 500 milliseconds to check if the\n   * buffer end percent has changed.\n   *\n   * > This function is called by {@link Tech#manualProgressOn}\n   *\n   * @param {EventTarget~Event} event\n   *        The `ready` event that caused this to run.\n   *\n   * @listens Tech#ready\n   * @fires Tech#progress\n   */\n\n\n  Tech.prototype.trackProgress = function trackProgress(event) {\n    this.stopTrackingProgress();\n    this.progressInterval = this.setInterval(bind(this, function () {\n      // Don't trigger unless buffered amount is greater than last time\n\n      var numBufferedPercent = this.bufferedPercent();\n\n      if (this.bufferedPercent_ !== numBufferedPercent) {\n        /**\n         * See {@link Player#progress}\n         *\n         * @event Tech#progress\n         * @type {EventTarget~Event}\n         */\n        this.trigger('progress');\n      }\n\n      this.bufferedPercent_ = numBufferedPercent;\n\n      if (numBufferedPercent === 1) {\n        this.stopTrackingProgress();\n      }\n    }), 500);\n  };\n\n  /**\n   * Update our internal duration on a `durationchange` event by calling\n   * {@link Tech#duration}.\n   *\n   * @param {EventTarget~Event} event\n   *        The `durationchange` event that caused this to run.\n   *\n   * @listens Tech#durationchange\n   */\n\n\n  Tech.prototype.onDurationChange = function onDurationChange(event) {\n    this.duration_ = this.duration();\n  };\n\n  /**\n   * Get and create a `TimeRange` object for buffering.\n   *\n   * @return {TimeRange}\n   *         The time range object that was created.\n   */\n\n\n  Tech.prototype.buffered = function buffered() {\n    return createTimeRanges(0, 0);\n  };\n\n  /**\n   * Get the percentage of the current video that is currently buffered.\n   *\n   * @return {number}\n   *         A number from 0 to 1 that represents the decimal percentage of the\n   *         video that is buffered.\n   *\n   */\n\n\n  Tech.prototype.bufferedPercent = function bufferedPercent$$1() {\n    return bufferedPercent(this.buffered(), this.duration_);\n  };\n\n  /**\n   * Turn off the polyfill for `progress` events that was created in\n   * {@link Tech#manualProgressOn}\n   * Stop manually tracking progress events by clearing the interval that was set in\n   * {@link Tech#trackProgress}.\n   */\n\n\n  Tech.prototype.stopTrackingProgress = function stopTrackingProgress() {\n    this.clearInterval(this.progressInterval);\n  };\n\n  /**\n   * Polyfill the `timeupdate` event for browsers that don't support it.\n   *\n   * @see {@link Tech#trackCurrentTime}\n   */\n\n\n  Tech.prototype.manualTimeUpdatesOn = function manualTimeUpdatesOn() {\n    this.manualTimeUpdates = true;\n\n    this.on('play', this.trackCurrentTime);\n    this.on('pause', this.stopTrackingCurrentTime);\n  };\n\n  /**\n   * Turn off the polyfill for `timeupdate` events that was created in\n   * {@link Tech#manualTimeUpdatesOn}\n   */\n\n\n  Tech.prototype.manualTimeUpdatesOff = function manualTimeUpdatesOff() {\n    this.manualTimeUpdates = false;\n    this.stopTrackingCurrentTime();\n    this.off('play', this.trackCurrentTime);\n    this.off('pause', this.stopTrackingCurrentTime);\n  };\n\n  /**\n   * Sets up an interval function to track current time and trigger `timeupdate` every\n   * 250 milliseconds.\n   *\n   * @listens Tech#play\n   * @triggers Tech#timeupdate\n   */\n\n\n  Tech.prototype.trackCurrentTime = function trackCurrentTime() {\n    if (this.currentTimeInterval) {\n      this.stopTrackingCurrentTime();\n    }\n    this.currentTimeInterval = this.setInterval(function () {\n      /**\n       * Triggered at an interval of 250ms to indicated that time is passing in the video.\n       *\n       * @event Tech#timeupdate\n       * @type {EventTarget~Event}\n       */\n      this.trigger({ type: 'timeupdate', target: this, manuallyTriggered: true });\n\n      // 42 = 24 fps // 250 is what Webkit uses // FF uses 15\n    }, 250);\n  };\n\n  /**\n   * Stop the interval function created in {@link Tech#trackCurrentTime} so that the\n   * `timeupdate` event is no longer triggered.\n   *\n   * @listens {Tech#pause}\n   */\n\n\n  Tech.prototype.stopTrackingCurrentTime = function stopTrackingCurrentTime() {\n    this.clearInterval(this.currentTimeInterval);\n\n    // #1002 - if the video ends right before the next timeupdate would happen,\n    // the progress bar won't make it all the way to the end\n    this.trigger({ type: 'timeupdate', target: this, manuallyTriggered: true });\n  };\n\n  /**\n   * Turn off all event polyfills, clear the `Tech`s {@link AudioTrackList},\n   * {@link VideoTrackList}, and {@link TextTrackList}, and dispose of this Tech.\n   *\n   * @fires Component#dispose\n   */\n\n\n  Tech.prototype.dispose = function dispose() {\n\n    // clear out all tracks because we can't reuse them between techs\n    this.clearTracks(NORMAL.names);\n\n    // Turn off any manual progress or timeupdate tracking\n    if (this.manualProgress) {\n      this.manualProgressOff();\n    }\n\n    if (this.manualTimeUpdates) {\n      this.manualTimeUpdatesOff();\n    }\n\n    _Component.prototype.dispose.call(this);\n  };\n\n  /**\n   * Clear out a single `TrackList` or an array of `TrackLists` given their names.\n   *\n   * > Note: Techs without source handlers should call this between sources for `video`\n   *         & `audio` tracks. You don't want to use them between tracks!\n   *\n   * @param {string[]|string} types\n   *        TrackList names to clear, valid names are `video`, `audio`, and\n   *        `text`.\n   */\n\n\n  Tech.prototype.clearTracks = function clearTracks(types) {\n    var _this3 = this;\n\n    types = [].concat(types);\n    // clear out all tracks because we can't reuse them between techs\n    types.forEach(function (type) {\n      var list = _this3[type + 'Tracks']() || [];\n      var i = list.length;\n\n      while (i--) {\n        var track = list[i];\n\n        if (type === 'text') {\n          _this3.removeRemoteTextTrack(track);\n        }\n        list.removeTrack(track);\n      }\n    });\n  };\n\n  /**\n   * Remove any TextTracks added via addRemoteTextTrack that are\n   * flagged for automatic garbage collection\n   */\n\n\n  Tech.prototype.cleanupAutoTextTracks = function cleanupAutoTextTracks() {\n    var list = this.autoRemoteTextTracks_ || [];\n    var i = list.length;\n\n    while (i--) {\n      var track = list[i];\n\n      this.removeRemoteTextTrack(track);\n    }\n  };\n\n  /**\n   * Reset the tech, which will removes all sources and reset the internal readyState.\n   *\n   * @abstract\n   */\n\n\n  Tech.prototype.reset = function reset() {};\n\n  /**\n   * Get or set an error on the Tech.\n   *\n   * @param {MediaError} [err]\n   *        Error to set on the Tech\n   *\n   * @return {MediaError|null}\n   *         The current error object on the tech, or null if there isn't one.\n   */\n\n\n  Tech.prototype.error = function error(err) {\n    if (err !== undefined) {\n      this.error_ = new MediaError(err);\n      this.trigger('error');\n    }\n    return this.error_;\n  };\n\n  /**\n   * Returns the `TimeRange`s that have been played through for the current source.\n   *\n   * > NOTE: This implementation is incomplete. It does not track the played `TimeRange`.\n   *         It only checks wether the source has played at all or not.\n   *\n   * @return {TimeRange}\n   *         - A single time range if this video has played\n   *         - An empty set of ranges if not.\n   */\n\n\n  Tech.prototype.played = function played() {\n    if (this.hasStarted_) {\n      return createTimeRanges(0, 0);\n    }\n    return createTimeRanges();\n  };\n\n  /**\n   * Causes a manual time update to occur if {@link Tech#manualTimeUpdatesOn} was\n   * previously called.\n   *\n   * @fires Tech#timeupdate\n   */\n\n\n  Tech.prototype.setCurrentTime = function setCurrentTime() {\n    // improve the accuracy of manual timeupdates\n    if (this.manualTimeUpdates) {\n      /**\n       * A manual `timeupdate` event.\n       *\n       * @event Tech#timeupdate\n       * @type {EventTarget~Event}\n       */\n      this.trigger({ type: 'timeupdate', target: this, manuallyTriggered: true });\n    }\n  };\n\n  /**\n   * Turn on listeners for {@link VideoTrackList}, {@link {AudioTrackList}, and\n   * {@link TextTrackList} events.\n   *\n   * This adds {@link EventTarget~EventListeners} for `addtrack`, and  `removetrack`.\n   *\n   * @fires Tech#audiotrackchange\n   * @fires Tech#videotrackchange\n   * @fires Tech#texttrackchange\n   */\n\n\n  Tech.prototype.initTrackListeners = function initTrackListeners() {\n    var _this4 = this;\n\n    /**\n     * Triggered when tracks are added or removed on the Tech {@link AudioTrackList}\n     *\n     * @event Tech#audiotrackchange\n     * @type {EventTarget~Event}\n     */\n\n    /**\n     * Triggered when tracks are added or removed on the Tech {@link VideoTrackList}\n     *\n     * @event Tech#videotrackchange\n     * @type {EventTarget~Event}\n     */\n\n    /**\n     * Triggered when tracks are added or removed on the Tech {@link TextTrackList}\n     *\n     * @event Tech#texttrackchange\n     * @type {EventTarget~Event}\n     */\n    NORMAL.names.forEach(function (name) {\n      var props = NORMAL[name];\n      var trackListChanges = function trackListChanges() {\n        _this4.trigger(name + 'trackchange');\n      };\n\n      var tracks = _this4[props.getterName]();\n\n      tracks.addEventListener('removetrack', trackListChanges);\n      tracks.addEventListener('addtrack', trackListChanges);\n\n      _this4.on('dispose', function () {\n        tracks.removeEventListener('removetrack', trackListChanges);\n        tracks.removeEventListener('addtrack', trackListChanges);\n      });\n    });\n  };\n\n  /**\n   * Emulate TextTracks using vtt.js if necessary\n   *\n   * @fires Tech#vttjsloaded\n   * @fires Tech#vttjserror\n   */\n\n\n  Tech.prototype.addWebVttScript_ = function addWebVttScript_() {\n    var _this5 = this;\n\n    if (window.WebVTT) {\n      return;\n    }\n\n    // Initially, Tech.el_ is a child of a dummy-div wait until the Component system\n    // signals that the Tech is ready at which point Tech.el_ is part of the DOM\n    // before inserting the WebVTT script\n    if (document.body.contains(this.el())) {\n\n      // load via require if available and vtt.js script location was not passed in\n      // as an option. novtt builds will turn the above require call into an empty object\n      // which will cause this if check to always fail.\n      if (!this.options_['vtt.js'] && isPlain(vtt) && Object.keys(vtt).length > 0) {\n        this.trigger('vttjsloaded');\n        return;\n      }\n\n      // load vtt.js via the script location option or the cdn of no location was\n      // passed in\n      var script = document.createElement('script');\n\n      script.src = this.options_['vtt.js'] || 'https://vjs.zencdn.net/vttjs/0.12.4/vtt.min.js';\n      script.onload = function () {\n        /**\n         * Fired when vtt.js is loaded.\n         *\n         * @event Tech#vttjsloaded\n         * @type {EventTarget~Event}\n         */\n        _this5.trigger('vttjsloaded');\n      };\n      script.onerror = function () {\n        /**\n         * Fired when vtt.js was not loaded due to an error\n         *\n         * @event Tech#vttjsloaded\n         * @type {EventTarget~Event}\n         */\n        _this5.trigger('vttjserror');\n      };\n      this.on('dispose', function () {\n        script.onload = null;\n        script.onerror = null;\n      });\n      // but have not loaded yet and we set it to true before the inject so that\n      // we don't overwrite the injected window.WebVTT if it loads right away\n      window.WebVTT = true;\n      this.el().parentNode.appendChild(script);\n    } else {\n      this.ready(this.addWebVttScript_);\n    }\n  };\n\n  /**\n   * Emulate texttracks\n   *\n   */\n\n\n  Tech.prototype.emulateTextTracks = function emulateTextTracks() {\n    var _this6 = this;\n\n    var tracks = this.textTracks();\n    var remoteTracks = this.remoteTextTracks();\n    var handleAddTrack = function handleAddTrack(e) {\n      return tracks.addTrack(e.track);\n    };\n    var handleRemoveTrack = function handleRemoveTrack(e) {\n      return tracks.removeTrack(e.track);\n    };\n\n    remoteTracks.on('addtrack', handleAddTrack);\n    remoteTracks.on('removetrack', handleRemoveTrack);\n\n    this.addWebVttScript_();\n\n    var updateDisplay = function updateDisplay() {\n      return _this6.trigger('texttrackchange');\n    };\n\n    var textTracksChanges = function textTracksChanges() {\n      updateDisplay();\n\n      for (var i = 0; i < tracks.length; i++) {\n        var track = tracks[i];\n\n        track.removeEventListener('cuechange', updateDisplay);\n        if (track.mode === 'showing') {\n          track.addEventListener('cuechange', updateDisplay);\n        }\n      }\n    };\n\n    textTracksChanges();\n    tracks.addEventListener('change', textTracksChanges);\n    tracks.addEventListener('addtrack', textTracksChanges);\n    tracks.addEventListener('removetrack', textTracksChanges);\n\n    this.on('dispose', function () {\n      remoteTracks.off('addtrack', handleAddTrack);\n      remoteTracks.off('removetrack', handleRemoveTrack);\n      tracks.removeEventListener('change', textTracksChanges);\n      tracks.removeEventListener('addtrack', textTracksChanges);\n      tracks.removeEventListener('removetrack', textTracksChanges);\n\n      for (var i = 0; i < tracks.length; i++) {\n        var track = tracks[i];\n\n        track.removeEventListener('cuechange', updateDisplay);\n      }\n    });\n  };\n\n  /**\n   * Create and returns a remote {@link TextTrack} object.\n   *\n   * @param {string} kind\n   *        `TextTrack` kind (subtitles, captions, descriptions, chapters, or metadata)\n   *\n   * @param {string} [label]\n   *        Label to identify the text track\n   *\n   * @param {string} [language]\n   *        Two letter language abbreviation\n   *\n   * @return {TextTrack}\n   *         The TextTrack that gets created.\n   */\n\n\n  Tech.prototype.addTextTrack = function addTextTrack(kind, label, language) {\n    if (!kind) {\n      throw new Error('TextTrack kind is required but was not provided');\n    }\n\n    return createTrackHelper(this, kind, label, language);\n  };\n\n  /**\n   * Create an emulated TextTrack for use by addRemoteTextTrack\n   *\n   * This is intended to be overridden by classes that inherit from\n   * Tech in order to create native or custom TextTracks.\n   *\n   * @param {Object} options\n   *        The object should contain the options to initialize the TextTrack with.\n   *\n   * @param {string} [options.kind]\n   *        `TextTrack` kind (subtitles, captions, descriptions, chapters, or metadata).\n   *\n   * @param {string} [options.label].\n   *        Label to identify the text track\n   *\n   * @param {string} [options.language]\n   *        Two letter language abbreviation.\n   *\n   * @return {HTMLTrackElement}\n   *         The track element that gets created.\n   */\n\n\n  Tech.prototype.createRemoteTextTrack = function createRemoteTextTrack(options) {\n    var track = mergeOptions(options, {\n      tech: this\n    });\n\n    return new REMOTE.remoteTextEl.TrackClass(track);\n  };\n\n  /**\n   * Creates a remote text track object and returns an html track element.\n   *\n   * > Note: This can be an emulated {@link HTMLTrackElement} or a native one.\n   *\n   * @param {Object} options\n   *        See {@link Tech#createRemoteTextTrack} for more detailed properties.\n   *\n   * @param {boolean} [manualCleanup=true]\n   *        - When false: the TextTrack will be automatically removed from the video\n   *          element whenever the source changes\n   *        - When True: The TextTrack will have to be cleaned up manually\n   *\n   * @return {HTMLTrackElement}\n   *         An Html Track Element.\n   *\n   * @deprecated The default functionality for this function will be equivalent\n   *             to \"manualCleanup=false\" in the future. The manualCleanup parameter will\n   *             also be removed.\n   */\n\n\n  Tech.prototype.addRemoteTextTrack = function addRemoteTextTrack() {\n    var _this7 = this;\n\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var manualCleanup = arguments[1];\n\n    var htmlTrackElement = this.createRemoteTextTrack(options);\n\n    if (manualCleanup !== true && manualCleanup !== false) {\n      // deprecation warning\n      log.warn('Calling addRemoteTextTrack without explicitly setting the \"manualCleanup\" parameter to `true` is deprecated and default to `false` in future version of video.js');\n      manualCleanup = true;\n    }\n\n    // store HTMLTrackElement and TextTrack to remote list\n    this.remoteTextTrackEls().addTrackElement_(htmlTrackElement);\n    this.remoteTextTracks().addTrack(htmlTrackElement.track);\n\n    if (manualCleanup !== true) {\n      // create the TextTrackList if it doesn't exist\n      this.ready(function () {\n        return _this7.autoRemoteTextTracks_.addTrack(htmlTrackElement.track);\n      });\n    }\n\n    return htmlTrackElement;\n  };\n\n  /**\n   * Remove a remote text track from the remote `TextTrackList`.\n   *\n   * @param {TextTrack} track\n   *        `TextTrack` to remove from the `TextTrackList`\n   */\n\n\n  Tech.prototype.removeRemoteTextTrack = function removeRemoteTextTrack(track) {\n    var trackElement = this.remoteTextTrackEls().getTrackElementByTrack_(track);\n\n    // remove HTMLTrackElement and TextTrack from remote list\n    this.remoteTextTrackEls().removeTrackElement_(trackElement);\n    this.remoteTextTracks().removeTrack(track);\n    this.autoRemoteTextTracks_.removeTrack(track);\n  };\n\n  /**\n   * Gets available media playback quality metrics as specified by the W3C's Media\n   * Playback Quality API.\n   *\n   * @see [Spec]{@link https://wicg.github.io/media-playback-quality}\n   *\n   * @return {Object}\n   *         An object with supported media playback quality metrics\n   *\n   * @abstract\n   */\n\n\n  Tech.prototype.getVideoPlaybackQuality = function getVideoPlaybackQuality() {\n    return {};\n  };\n\n  /**\n   * A method to set a poster from a `Tech`.\n   *\n   * @abstract\n   */\n\n\n  Tech.prototype.setPoster = function setPoster() {};\n\n  /**\n   * A method to check for the presence of the 'playsinine' <video> attribute.\n   *\n   * @abstract\n   */\n\n\n  Tech.prototype.playsinline = function playsinline() {};\n\n  /**\n   * A method to set or unset the 'playsinine' <video> attribute.\n   *\n   * @abstract\n   */\n\n\n  Tech.prototype.setPlaysinline = function setPlaysinline() {};\n\n  /*\n   * Check if the tech can support the given mime-type.\n   *\n   * The base tech does not support any type, but source handlers might\n   * overwrite this.\n   *\n   * @param  {string} type\n   *         The mimetype to check for support\n   *\n   * @return {string}\n   *         'probably', 'maybe', or empty string\n   *\n   * @see [Spec]{@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/canPlayType}\n   *\n   * @abstract\n   */\n\n\n  Tech.prototype.canPlayType = function canPlayType() {\n    return '';\n  };\n\n  /**\n   * Check if the type is supported by this tech.\n   *\n   * The base tech does not support any type, but source handlers might\n   * overwrite this.\n   *\n   * @param {string} type\n   *        The media type to check\n   * @return {string} Returns the native video element's response\n   */\n\n\n  Tech.canPlayType = function canPlayType() {\n    return '';\n  };\n\n  /**\n   * Check if the tech can support the given source\n   * @param {Object} srcObj\n   *        The source object\n   * @param {Object} options\n   *        The options passed to the tech\n   * @return {string} 'probably', 'maybe', or '' (empty string)\n   */\n\n\n  Tech.canPlaySource = function canPlaySource(srcObj, options) {\n    return Tech.canPlayType(srcObj.type);\n  };\n\n  /*\n   * Return whether the argument is a Tech or not.\n   * Can be passed either a Class like `Html5` or a instance like `player.tech_`\n   *\n   * @param {Object} component\n   *        The item to check\n   *\n   * @return {boolean}\n   *         Whether it is a tech or not\n   *         - True if it is a tech\n   *         - False if it is not\n   */\n\n\n  Tech.isTech = function isTech(component) {\n    return component.prototype instanceof Tech || component instanceof Tech || component === Tech;\n  };\n\n  /**\n   * Registers a `Tech` into a shared list for videojs.\n   *\n   * @param {string} name\n   *        Name of the `Tech` to register.\n   *\n   * @param {Object} tech\n   *        The `Tech` class to register.\n   */\n\n\n  Tech.registerTech = function registerTech(name, tech) {\n    if (!Tech.techs_) {\n      Tech.techs_ = {};\n    }\n\n    if (!Tech.isTech(tech)) {\n      throw new Error('Tech ' + name + ' must be a Tech');\n    }\n\n    if (!Tech.canPlayType) {\n      throw new Error('Techs must have a static canPlayType method on them');\n    }\n    if (!Tech.canPlaySource) {\n      throw new Error('Techs must have a static canPlaySource method on them');\n    }\n\n    name = toTitleCase(name);\n\n    Tech.techs_[name] = tech;\n    if (name !== 'Tech') {\n      // camel case the techName for use in techOrder\n      Tech.defaultTechOrder_.push(name);\n    }\n    return tech;\n  };\n\n  /**\n   * Get a `Tech` from the shared list by name.\n   *\n   * @param {string} name\n   *        `camelCase` or `TitleCase` name of the Tech to get\n   *\n   * @return {Tech|undefined}\n   *         The `Tech` or undefined if there was no tech with the name requsted.\n   */\n\n\n  Tech.getTech = function getTech(name) {\n    if (!name) {\n      return;\n    }\n\n    name = toTitleCase(name);\n\n    if (Tech.techs_ && Tech.techs_[name]) {\n      return Tech.techs_[name];\n    }\n\n    if (window && window.videojs && window.videojs[name]) {\n      log.warn('The ' + name + ' tech was added to the videojs object when it should be registered using videojs.registerTech(name, tech)');\n      return window.videojs[name];\n    }\n  };\n\n  return Tech;\n}(Component);\n\n/**\n * Get the {@link VideoTrackList}\n *\n * @returns {VideoTrackList}\n * @method Tech.prototype.videoTracks\n */\n\n/**\n * Get the {@link AudioTrackList}\n *\n * @returns {AudioTrackList}\n * @method Tech.prototype.audioTracks\n */\n\n/**\n * Get the {@link TextTrackList}\n *\n * @returns {TextTrackList}\n * @method Tech.prototype.textTracks\n */\n\n/**\n * Get the remote element {@link TextTrackList}\n *\n * @returns {TextTrackList}\n * @method Tech.prototype.remoteTextTracks\n */\n\n/**\n * Get the remote element {@link HtmlTrackElementList}\n *\n * @returns {HtmlTrackElementList}\n * @method Tech.prototype.remoteTextTrackEls\n */\n\nALL.names.forEach(function (name) {\n  var props = ALL[name];\n\n  Tech.prototype[props.getterName] = function () {\n    this[props.privateName] = this[props.privateName] || new props.ListClass();\n    return this[props.privateName];\n  };\n});\n\n/**\n * List of associated text tracks\n *\n * @type {TextTrackList}\n * @private\n * @property Tech#textTracks_\n */\n\n/**\n * List of associated audio tracks.\n *\n * @type {AudioTrackList}\n * @private\n * @property Tech#audioTracks_\n */\n\n/**\n * List of associated video tracks.\n *\n * @type {VideoTrackList}\n * @private\n * @property Tech#videoTracks_\n */\n\n/**\n * Boolean indicating wether the `Tech` supports volume control.\n *\n * @type {boolean}\n * @default\n */\nTech.prototype.featuresVolumeControl = true;\n\n/**\n * Boolean indicating whether the `Tech` supports muting volume.\n *\n * @type {bolean}\n * @default\n */\nTech.prototype.featuresMuteControl = true;\n\n/**\n * Boolean indicating whether the `Tech` supports fullscreen resize control.\n * Resizing plugins using request fullscreen reloads the plugin\n *\n * @type {boolean}\n * @default\n */\nTech.prototype.featuresFullscreenResize = false;\n\n/**\n * Boolean indicating wether the `Tech` supports changing the speed at which the video\n * plays. Examples:\n *   - Set player to play 2x (twice) as fast\n *   - Set player to play 0.5x (half) as fast\n *\n * @type {boolean}\n * @default\n */\nTech.prototype.featuresPlaybackRate = false;\n\n/**\n * Boolean indicating wether the `Tech` supports the `progress` event. This is currently\n * not triggered by video-js-swf. This will be used to determine if\n * {@link Tech#manualProgressOn} should be called.\n *\n * @type {boolean}\n * @default\n */\nTech.prototype.featuresProgressEvents = false;\n\n/**\n * Boolean indicating wether the `Tech` supports the `sourceset` event.\n *\n * A tech should set this to `true` and then use {@link Tech#triggerSourceset}\n * to trigger a {@link Tech#event:sourceset} at the earliest time after getting\n * a new source.\n *\n * @type {boolean}\n * @default\n */\nTech.prototype.featuresSourceset = false;\n\n/**\n * Boolean indicating wether the `Tech` supports the `timeupdate` event. This is currently\n * not triggered by video-js-swf. This will be used to determine if\n * {@link Tech#manualTimeUpdates} should be called.\n *\n * @type {boolean}\n * @default\n */\nTech.prototype.featuresTimeupdateEvents = false;\n\n/**\n * Boolean indicating wether the `Tech` supports the native `TextTrack`s.\n * This will help us integrate with native `TextTrack`s if the browser supports them.\n *\n * @type {boolean}\n * @default\n */\nTech.prototype.featuresNativeTextTracks = false;\n\n/**\n * A functional mixin for techs that want to use the Source Handler pattern.\n * Source handlers are scripts for handling specific formats.\n * The source handler pattern is used for adaptive formats (HLS, DASH) that\n * manually load video data and feed it into a Source Buffer (Media Source Extensions)\n * Example: `Tech.withSourceHandlers.call(MyTech);`\n *\n * @param {Tech} _Tech\n *        The tech to add source handler functions to.\n *\n * @mixes Tech~SourceHandlerAdditions\n */\nTech.withSourceHandlers = function (_Tech) {\n\n  /**\n   * Register a source handler\n   *\n   * @param {Function} handler\n   *        The source handler class\n   *\n   * @param {number} [index]\n   *        Register it at the following index\n   */\n  _Tech.registerSourceHandler = function (handler, index) {\n    var handlers = _Tech.sourceHandlers;\n\n    if (!handlers) {\n      handlers = _Tech.sourceHandlers = [];\n    }\n\n    if (index === undefined) {\n      // add to the end of the list\n      index = handlers.length;\n    }\n\n    handlers.splice(index, 0, handler);\n  };\n\n  /**\n   * Check if the tech can support the given type. Also checks the\n   * Techs sourceHandlers.\n   *\n   * @param {string} type\n   *         The mimetype to check.\n   *\n   * @return {string}\n   *         'probably', 'maybe', or '' (empty string)\n   */\n  _Tech.canPlayType = function (type) {\n    var handlers = _Tech.sourceHandlers || [];\n    var can = void 0;\n\n    for (var i = 0; i < handlers.length; i++) {\n      can = handlers[i].canPlayType(type);\n\n      if (can) {\n        return can;\n      }\n    }\n\n    return '';\n  };\n\n  /**\n   * Returns the first source handler that supports the source.\n   *\n   * TODO: Answer question: should 'probably' be prioritized over 'maybe'\n   *\n   * @param {Tech~SourceObject} source\n   *        The source object\n   *\n   * @param {Object} options\n   *        The options passed to the tech\n   *\n   * @return {SourceHandler|null}\n   *          The first source handler that supports the source or null if\n   *          no SourceHandler supports the source\n   */\n  _Tech.selectSourceHandler = function (source, options) {\n    var handlers = _Tech.sourceHandlers || [];\n    var can = void 0;\n\n    for (var i = 0; i < handlers.length; i++) {\n      can = handlers[i].canHandleSource(source, options);\n\n      if (can) {\n        return handlers[i];\n      }\n    }\n\n    return null;\n  };\n\n  /**\n   * Check if the tech can support the given source.\n   *\n   * @param {Tech~SourceObject} srcObj\n   *        The source object\n   *\n   * @param {Object} options\n   *        The options passed to the tech\n   *\n   * @return {string}\n   *         'probably', 'maybe', or '' (empty string)\n   */\n  _Tech.canPlaySource = function (srcObj, options) {\n    var sh = _Tech.selectSourceHandler(srcObj, options);\n\n    if (sh) {\n      return sh.canHandleSource(srcObj, options);\n    }\n\n    return '';\n  };\n\n  /**\n   * When using a source handler, prefer its implementation of\n   * any function normally provided by the tech.\n   */\n  var deferrable = ['seekable', 'seeking', 'duration'];\n\n  /**\n   * A wrapper around {@link Tech#seekable} that will call a `SourceHandler`s seekable\n   * function if it exists, with a fallback to the Techs seekable function.\n   *\n   * @method _Tech.seekable\n   */\n\n  /**\n   * A wrapper around {@link Tech#duration} that will call a `SourceHandler`s duration\n   * function if it exists, otherwise it will fallback to the techs duration function.\n   *\n   * @method _Tech.duration\n   */\n\n  deferrable.forEach(function (fnName) {\n    var originalFn = this[fnName];\n\n    if (typeof originalFn !== 'function') {\n      return;\n    }\n\n    this[fnName] = function () {\n      if (this.sourceHandler_ && this.sourceHandler_[fnName]) {\n        return this.sourceHandler_[fnName].apply(this.sourceHandler_, arguments);\n      }\n      return originalFn.apply(this, arguments);\n    };\n  }, _Tech.prototype);\n\n  /**\n   * Create a function for setting the source using a source object\n   * and source handlers.\n   * Should never be called unless a source handler was found.\n   *\n   * @param {Tech~SourceObject} source\n   *        A source object with src and type keys\n   */\n  _Tech.prototype.setSource = function (source) {\n    var sh = _Tech.selectSourceHandler(source, this.options_);\n\n    if (!sh) {\n      // Fall back to a native source hander when unsupported sources are\n      // deliberately set\n      if (_Tech.nativeSourceHandler) {\n        sh = _Tech.nativeSourceHandler;\n      } else {\n        log.error('No source hander found for the current source.');\n      }\n    }\n\n    // Dispose any existing source handler\n    this.disposeSourceHandler();\n    this.off('dispose', this.disposeSourceHandler);\n\n    if (sh !== _Tech.nativeSourceHandler) {\n      this.currentSource_ = source;\n    }\n\n    this.sourceHandler_ = sh.handleSource(source, this, this.options_);\n    this.on('dispose', this.disposeSourceHandler);\n  };\n\n  /**\n   * Clean up any existing SourceHandlers and listeners when the Tech is disposed.\n   *\n   * @listens Tech#dispose\n   */\n  _Tech.prototype.disposeSourceHandler = function () {\n    // if we have a source and get another one\n    // then we are loading something new\n    // than clear all of our current tracks\n    if (this.currentSource_) {\n      this.clearTracks(['audio', 'video']);\n      this.currentSource_ = null;\n    }\n\n    // always clean up auto-text tracks\n    this.cleanupAutoTextTracks();\n\n    if (this.sourceHandler_) {\n\n      if (this.sourceHandler_.dispose) {\n        this.sourceHandler_.dispose();\n      }\n\n      this.sourceHandler_ = null;\n    }\n  };\n};\n\n// The base Tech class needs to be registered as a Component. It is the only\n// Tech that can be registered as a Component.\nComponent.registerComponent('Tech', Tech);\nTech.registerTech('Tech', Tech);\n\n/**\n * A list of techs that should be added to techOrder on Players\n *\n * @private\n */\nTech.defaultTechOrder_ = [];\n\nvar middlewares = {};\nvar middlewareInstances = {};\n\nvar TERMINATOR = {};\n\nfunction use(type, middleware) {\n  middlewares[type] = middlewares[type] || [];\n  middlewares[type].push(middleware);\n}\n\n\n\nfunction setSource(player, src, next) {\n  player.setTimeout(function () {\n    return setSourceHelper(src, middlewares[src.type], next, player);\n  }, 1);\n}\n\nfunction setTech(middleware, tech) {\n  middleware.forEach(function (mw) {\n    return mw.setTech && mw.setTech(tech);\n  });\n}\n\n/**\n * Calls a getter on the tech first, through each middleware\n * from right to left to the player.\n */\nfunction get$1(middleware, tech, method) {\n  return middleware.reduceRight(middlewareIterator(method), tech[method]());\n}\n\n/**\n * Takes the argument given to the player and calls the setter method on each\n * middlware from left to right to the tech.\n */\nfunction set$1(middleware, tech, method, arg) {\n  return tech[method](middleware.reduce(middlewareIterator(method), arg));\n}\n\n/**\n * Takes the argument given to the player and calls the `call` version of the method\n * on each middleware from left to right.\n * Then, call the passed in method on the tech and return the result unchanged\n * back to the player, through middleware, this time from right to left.\n */\nfunction mediate(middleware, tech, method) {\n  var arg = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n\n  var callMethod = 'call' + toTitleCase(method);\n  var middlewareValue = middleware.reduce(middlewareIterator(callMethod), arg);\n  var terminated = middlewareValue === TERMINATOR;\n  var returnValue = terminated ? null : tech[method](middlewareValue);\n\n  executeRight(middleware, method, returnValue, terminated);\n\n  return returnValue;\n}\n\nvar allowedGetters = {\n  buffered: 1,\n  currentTime: 1,\n  duration: 1,\n  seekable: 1,\n  played: 1,\n  paused: 1\n};\n\nvar allowedSetters = {\n  setCurrentTime: 1\n};\n\nvar allowedMediators = {\n  play: 1,\n  pause: 1\n};\n\nfunction middlewareIterator(method) {\n  return function (value, mw) {\n    // if the previous middleware terminated, pass along the termination\n    if (value === TERMINATOR) {\n      return TERMINATOR;\n    }\n\n    if (mw[method]) {\n      return mw[method](value);\n    }\n\n    return value;\n  };\n}\n\nfunction executeRight(mws, method, value, terminated) {\n  for (var i = mws.length - 1; i >= 0; i--) {\n    var mw = mws[i];\n\n    if (mw[method]) {\n      mw[method](terminated, value);\n    }\n  }\n}\n\nfunction clearCacheForPlayer(player) {\n  middlewareInstances[player.id()] = null;\n}\n\n/**\n * {\n *  [playerId]: [[mwFactory, mwInstance], ...]\n * }\n */\nfunction getOrCreateFactory(player, mwFactory) {\n  var mws = middlewareInstances[player.id()];\n  var mw = null;\n\n  if (mws === undefined || mws === null) {\n    mw = mwFactory(player);\n    middlewareInstances[player.id()] = [[mwFactory, mw]];\n    return mw;\n  }\n\n  for (var i = 0; i < mws.length; i++) {\n    var _mws$i = mws[i],\n        mwf = _mws$i[0],\n        mwi = _mws$i[1];\n\n\n    if (mwf !== mwFactory) {\n      continue;\n    }\n\n    mw = mwi;\n  }\n\n  if (mw === null) {\n    mw = mwFactory(player);\n    mws.push([mwFactory, mw]);\n  }\n\n  return mw;\n}\n\nfunction setSourceHelper() {\n  var src = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var middleware = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  var next = arguments[2];\n  var player = arguments[3];\n  var acc = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [];\n  var lastRun = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n  var mwFactory = middleware[0],\n      mwrest = middleware.slice(1);\n\n  // if mwFactory is a string, then we're at a fork in the road\n\n  if (typeof mwFactory === 'string') {\n    setSourceHelper(src, middlewares[mwFactory], next, player, acc, lastRun);\n\n    // if we have an mwFactory, call it with the player to get the mw,\n    // then call the mw's setSource method\n  } else if (mwFactory) {\n    var mw = getOrCreateFactory(player, mwFactory);\n\n    // if setSource isn't present, implicitly select this middleware\n    if (!mw.setSource) {\n      acc.push(mw);\n      return setSourceHelper(src, mwrest, next, player, acc, lastRun);\n    }\n\n    mw.setSource(assign({}, src), function (err, _src) {\n\n      // something happened, try the next middleware on the current level\n      // make sure to use the old src\n      if (err) {\n        return setSourceHelper(src, mwrest, next, player, acc, lastRun);\n      }\n\n      // we've succeeded, now we need to go deeper\n      acc.push(mw);\n\n      // if it's the same type, continue down the current chain\n      // otherwise, we want to go down the new chain\n      setSourceHelper(_src, src.type === _src.type ? mwrest : middlewares[_src.type], next, player, acc, lastRun);\n    });\n  } else if (mwrest.length) {\n    setSourceHelper(src, mwrest, next, player, acc, lastRun);\n  } else if (lastRun) {\n    next(src, acc);\n  } else {\n    setSourceHelper(src, middlewares['*'], next, player, acc, true);\n  }\n}\n\n/**\n * Mimetypes\n *\n * @see http://hul.harvard.edu/ois/////systems/wax/wax-public-help/mimetypes.htm\n * @typedef Mimetypes~Kind\n * @enum\n */\nvar MimetypesKind = {\n  opus: 'video/ogg',\n  ogv: 'video/ogg',\n  mp4: 'video/mp4',\n  mov: 'video/mp4',\n  m4v: 'video/mp4',\n  mkv: 'video/x-matroska',\n  mp3: 'audio/mpeg',\n  aac: 'audio/aac',\n  oga: 'audio/ogg',\n  m3u8: 'application/x-mpegURL'\n};\n\n/**\n * Get the mimetype of a given src url if possible\n *\n * @param {string} src\n *        The url to the src\n *\n * @return {string}\n *         return the mimetype if it was known or empty string otherwise\n */\nvar getMimetype = function getMimetype() {\n  var src = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n\n  var ext = getFileExtension(src);\n  var mimetype = MimetypesKind[ext.toLowerCase()];\n\n  return mimetype || '';\n};\n\n/**\n * Find the mime type of a given source string if possible. Uses the player\n * source cache.\n *\n * @param {Player} player\n *        The player object\n *\n * @param {string} src\n *        The source string\n *\n * @return {string}\n *         The type that was found\n */\nvar findMimetype = function findMimetype(player, src) {\n  if (!src) {\n    return '';\n  }\n\n  // 1. check for the type in the `source` cache\n  if (player.cache_.source.src === src && player.cache_.source.type) {\n    return player.cache_.source.type;\n  }\n\n  // 2. see if we have this source in our `currentSources` cache\n  var matchingSources = player.cache_.sources.filter(function (s) {\n    return s.src === src;\n  });\n\n  if (matchingSources.length) {\n    return matchingSources[0].type;\n  }\n\n  // 3. look for the src url in source elements and use the type there\n  var sources = player.$$('source');\n\n  for (var i = 0; i < sources.length; i++) {\n    var s = sources[i];\n\n    if (s.type && s.src && s.src === src) {\n      return s.type;\n    }\n  }\n\n  // 4. finally fallback to our list of mime types based on src url extension\n  return getMimetype(src);\n};\n\n/**\n * @module filter-source\n */\n/**\n * Filter out single bad source objects or multiple source objects in an\n * array. Also flattens nested source object arrays into a 1 dimensional\n * array of source objects.\n *\n * @param {Tech~SourceObject|Tech~SourceObject[]} src\n *        The src object to filter\n *\n * @return {Tech~SourceObject[]}\n *         An array of sourceobjects containing only valid sources\n *\n * @private\n */\nvar filterSource = function filterSource(src) {\n  // traverse array\n  if (Array.isArray(src)) {\n    var newsrc = [];\n\n    src.forEach(function (srcobj) {\n      srcobj = filterSource(srcobj);\n\n      if (Array.isArray(srcobj)) {\n        newsrc = newsrc.concat(srcobj);\n      } else if (isObject(srcobj)) {\n        newsrc.push(srcobj);\n      }\n    });\n\n    src = newsrc;\n  } else if (typeof src === 'string' && src.trim()) {\n    // convert string into object\n    src = [fixSource({ src: src })];\n  } else if (isObject(src) && typeof src.src === 'string' && src.src && src.src.trim()) {\n    // src is already valid\n    src = [fixSource(src)];\n  } else {\n    // invalid source, turn it into an empty array\n    src = [];\n  }\n\n  return src;\n};\n\n/**\n * Checks src mimetype, adding it when possible\n *\n * @param {Tech~SourceObject} src\n *        The src object to check\n * @return {Tech~SourceObject}\n *        src Object with known type\n */\nfunction fixSource(src) {\n  var mimetype = getMimetype(src.src);\n\n  if (!src.type && mimetype) {\n    src.type = mimetype;\n  }\n\n  return src;\n}\n\n/**\n * @file loader.js\n */\n/**\n * The `MediaLoader` is the `Component` that decides which playback technology to load\n * when a player is initialized.\n *\n * @extends Component\n */\n\nvar MediaLoader = function (_Component) {\n  inherits(MediaLoader, _Component);\n\n  /**\n   * Create an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should attach to.\n   *\n   * @param {Object} [options]\n   *        The key/value stroe of player options.\n   *\n   * @param {Component~ReadyCallback} [ready]\n   *        The function that is run when this component is ready.\n   */\n  function MediaLoader(player, options, ready) {\n    classCallCheck(this, MediaLoader);\n\n    // MediaLoader has no element\n    var options_ = mergeOptions({ createEl: false }, options);\n\n    // If there are no sources when the player is initialized,\n    // load the first supported playback technology.\n\n    var _this = possibleConstructorReturn(this, _Component.call(this, player, options_, ready));\n\n    if (!options.playerOptions.sources || options.playerOptions.sources.length === 0) {\n      for (var i = 0, j = options.playerOptions.techOrder; i < j.length; i++) {\n        var techName = toTitleCase(j[i]);\n        var tech = Tech.getTech(techName);\n\n        // Support old behavior of techs being registered as components.\n        // Remove once that deprecated behavior is removed.\n        if (!techName) {\n          tech = Component.getComponent(techName);\n        }\n\n        // Check if the browser supports this technology\n        if (tech && tech.isSupported()) {\n          player.loadTech_(techName);\n          break;\n        }\n      }\n    } else {\n      // Loop through playback technologies (HTML5, Flash) and check for support.\n      // Then load the best source.\n      // A few assumptions here:\n      //   All playback technologies respect preload false.\n      player.src(options.playerOptions.sources);\n    }\n    return _this;\n  }\n\n  return MediaLoader;\n}(Component);\n\nComponent.registerComponent('MediaLoader', MediaLoader);\n\n/**\n * @file button.js\n */\n/**\n * Clickable Component which is clickable or keyboard actionable,\n * but is not a native HTML button.\n *\n * @extends Component\n */\n\nvar ClickableComponent = function (_Component) {\n  inherits(ClickableComponent, _Component);\n\n  /**\n   * Creates an instance of this class.\n   *\n   * @param  {Player} player\n   *         The `Player` that this class should be attached to.\n   *\n   * @param  {Object} [options]\n   *         The key/value store of player options.\n   */\n  function ClickableComponent(player, options) {\n    classCallCheck(this, ClickableComponent);\n\n    var _this = possibleConstructorReturn(this, _Component.call(this, player, options));\n\n    _this.emitTapEvents();\n\n    _this.enable();\n    return _this;\n  }\n\n  /**\n   * Create the `Component`s DOM element.\n   *\n   * @param {string} [tag=div]\n   *        The element's node type.\n   *\n   * @param {Object} [props={}]\n   *        An object of properties that should be set on the element.\n   *\n   * @param {Object} [attributes={}]\n   *        An object of attributes that should be set on the element.\n   *\n   * @return {Element}\n   *         The element that gets created.\n   */\n\n\n  ClickableComponent.prototype.createEl = function createEl$$1() {\n    var tag = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'div';\n    var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var attributes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    props = assign({\n      innerHTML: '<span aria-hidden=\"true\" class=\"vjs-icon-placeholder\"></span>',\n      className: this.buildCSSClass(),\n      tabIndex: 0\n    }, props);\n\n    if (tag === 'button') {\n      log.error('Creating a ClickableComponent with an HTML element of ' + tag + ' is not supported; use a Button instead.');\n    }\n\n    // Add ARIA attributes for clickable element which is not a native HTML button\n    attributes = assign({\n      role: 'button'\n    }, attributes);\n\n    this.tabIndex_ = props.tabIndex;\n\n    var el = _Component.prototype.createEl.call(this, tag, props, attributes);\n\n    this.createControlTextEl(el);\n\n    return el;\n  };\n\n  ClickableComponent.prototype.dispose = function dispose() {\n    // remove controlTextEl_ on dipose\n    this.controlTextEl_ = null;\n\n    _Component.prototype.dispose.call(this);\n  };\n\n  /**\n   * Create a control text element on this `Component`\n   *\n   * @param {Element} [el]\n   *        Parent element for the control text.\n   *\n   * @return {Element}\n   *         The control text element that gets created.\n   */\n\n\n  ClickableComponent.prototype.createControlTextEl = function createControlTextEl(el) {\n    this.controlTextEl_ = createEl('span', {\n      className: 'vjs-control-text'\n    }, {\n      // let the screen reader user know that the text of the element may change\n      'aria-live': 'polite'\n    });\n\n    if (el) {\n      el.appendChild(this.controlTextEl_);\n    }\n\n    this.controlText(this.controlText_, el);\n\n    return this.controlTextEl_;\n  };\n\n  /**\n   * Get or set the localize text to use for the controls on the `Component`.\n   *\n   * @param {string} [text]\n   *        Control text for element.\n   *\n   * @param {Element} [el=this.el()]\n   *        Element to set the title on.\n   *\n   * @return {string}\n   *         - The control text when getting\n   */\n\n\n  ClickableComponent.prototype.controlText = function controlText(text) {\n    var el = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.el();\n\n    if (text === undefined) {\n      return this.controlText_ || 'Need Text';\n    }\n\n    var localizedText = this.localize(text);\n\n    this.controlText_ = text;\n    textContent(this.controlTextEl_, localizedText);\n    if (!this.nonIconControl) {\n      // Set title attribute if only an icon is shown\n      el.setAttribute('title', localizedText);\n    }\n  };\n\n  /**\n   * Builds the default DOM `className`.\n   *\n   * @return {string}\n   *         The DOM `className` for this object.\n   */\n\n\n  ClickableComponent.prototype.buildCSSClass = function buildCSSClass() {\n    return 'vjs-control vjs-button ' + _Component.prototype.buildCSSClass.call(this);\n  };\n\n  /**\n   * Enable this `Component`s element.\n   */\n\n\n  ClickableComponent.prototype.enable = function enable() {\n    if (!this.enabled_) {\n      this.enabled_ = true;\n      this.removeClass('vjs-disabled');\n      this.el_.setAttribute('aria-disabled', 'false');\n      if (typeof this.tabIndex_ !== 'undefined') {\n        this.el_.setAttribute('tabIndex', this.tabIndex_);\n      }\n      this.on(['tap', 'click'], this.handleClick);\n      this.on('focus', this.handleFocus);\n      this.on('blur', this.handleBlur);\n    }\n  };\n\n  /**\n   * Disable this `Component`s element.\n   */\n\n\n  ClickableComponent.prototype.disable = function disable() {\n    this.enabled_ = false;\n    this.addClass('vjs-disabled');\n    this.el_.setAttribute('aria-disabled', 'true');\n    if (typeof this.tabIndex_ !== 'undefined') {\n      this.el_.removeAttribute('tabIndex');\n    }\n    this.off(['tap', 'click'], this.handleClick);\n    this.off('focus', this.handleFocus);\n    this.off('blur', this.handleBlur);\n  };\n\n  /**\n   * This gets called when a `ClickableComponent` gets:\n   * - Clicked (via the `click` event, listening starts in the constructor)\n   * - Tapped (via the `tap` event, listening starts in the constructor)\n   * - The following things happen in order:\n   *   1. {@link ClickableComponent#handleFocus} is called via a `focus` event on the\n   *      `ClickableComponent`.\n   *   2. {@link ClickableComponent#handleFocus} adds a listener for `keydown` on using\n   *      {@link ClickableComponent#handleKeyPress}.\n   *   3. `ClickableComponent` has not had a `blur` event (`blur` means that focus was lost). The user presses\n   *      the space or enter key.\n   *   4. {@link ClickableComponent#handleKeyPress} calls this function with the `keydown`\n   *      event as a parameter.\n   *\n   * @param {EventTarget~Event} event\n   *        The `keydown`, `tap`, or `click` event that caused this function to be\n   *        called.\n   *\n   * @listens tap\n   * @listens click\n   * @abstract\n   */\n\n\n  ClickableComponent.prototype.handleClick = function handleClick(event) {};\n\n  /**\n   * This gets called when a `ClickableComponent` gains focus via a `focus` event.\n   * Turns on listening for `keydown` events. When they happen it\n   * calls `this.handleKeyPress`.\n   *\n   * @param {EventTarget~Event} event\n   *        The `focus` event that caused this function to be called.\n   *\n   * @listens focus\n   */\n\n\n  ClickableComponent.prototype.handleFocus = function handleFocus(event) {\n    on(document, 'keydown', bind(this, this.handleKeyPress));\n  };\n\n  /**\n   * Called when this ClickableComponent has focus and a key gets pressed down. By\n   * default it will call `this.handleClick` when the key is space or enter.\n   *\n   * @param {EventTarget~Event} event\n   *        The `keydown` event that caused this function to be called.\n   *\n   * @listens keydown\n   */\n\n\n  ClickableComponent.prototype.handleKeyPress = function handleKeyPress(event) {\n\n    // Support Space (32) or Enter (13) key operation to fire a click event\n    if (event.which === 32 || event.which === 13) {\n      event.preventDefault();\n      this.trigger('click');\n    } else if (_Component.prototype.handleKeyPress) {\n\n      // Pass keypress handling up for unsupported keys\n      _Component.prototype.handleKeyPress.call(this, event);\n    }\n  };\n\n  /**\n   * Called when a `ClickableComponent` loses focus. Turns off the listener for\n   * `keydown` events. Which Stops `this.handleKeyPress` from getting called.\n   *\n   * @param {EventTarget~Event} event\n   *        The `blur` event that caused this function to be called.\n   *\n   * @listens blur\n   */\n\n\n  ClickableComponent.prototype.handleBlur = function handleBlur(event) {\n    off(document, 'keydown', bind(this, this.handleKeyPress));\n  };\n\n  return ClickableComponent;\n}(Component);\n\nComponent.registerComponent('ClickableComponent', ClickableComponent);\n\n/**\n * @file poster-image.js\n */\n/**\n * A `ClickableComponent` that handles showing the poster image for the player.\n *\n * @extends ClickableComponent\n */\n\nvar PosterImage = function (_ClickableComponent) {\n  inherits(PosterImage, _ClickableComponent);\n\n  /**\n   * Create an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should attach to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   */\n  function PosterImage(player, options) {\n    classCallCheck(this, PosterImage);\n\n    var _this = possibleConstructorReturn(this, _ClickableComponent.call(this, player, options));\n\n    _this.update();\n    player.on('posterchange', bind(_this, _this.update));\n    return _this;\n  }\n\n  /**\n   * Clean up and dispose of the `PosterImage`.\n   */\n\n\n  PosterImage.prototype.dispose = function dispose() {\n    this.player().off('posterchange', this.update);\n    _ClickableComponent.prototype.dispose.call(this);\n  };\n\n  /**\n   * Create the `PosterImage`s DOM element.\n   *\n   * @return {Element}\n   *         The element that gets created.\n   */\n\n\n  PosterImage.prototype.createEl = function createEl$$1() {\n    var el = createEl('div', {\n      className: 'vjs-poster',\n\n      // Don't want poster to be tabbable.\n      tabIndex: -1\n    });\n\n    // To ensure the poster image resizes while maintaining its original aspect\n    // ratio, use a div with `background-size` when available. For browsers that\n    // do not support `background-size` (e.g. IE8), fall back on using a regular\n    // img element.\n    if (!BACKGROUND_SIZE_SUPPORTED) {\n      this.fallbackImg_ = createEl('img');\n      el.appendChild(this.fallbackImg_);\n    }\n\n    return el;\n  };\n\n  /**\n   * An {@link EventTarget~EventListener} for {@link Player#posterchange} events.\n   *\n   * @listens Player#posterchange\n   *\n   * @param {EventTarget~Event} [event]\n   *        The `Player#posterchange` event that triggered this function.\n   */\n\n\n  PosterImage.prototype.update = function update(event) {\n    var url = this.player().poster();\n\n    this.setSrc(url);\n\n    // If there's no poster source we should display:none on this component\n    // so it's not still clickable or right-clickable\n    if (url) {\n      this.show();\n    } else {\n      this.hide();\n    }\n  };\n\n  /**\n   * Set the source of the `PosterImage` depending on the display method.\n   *\n   * @param {string} url\n   *        The URL to the source for the `PosterImage`.\n   */\n\n\n  PosterImage.prototype.setSrc = function setSrc(url) {\n    if (this.fallbackImg_) {\n      this.fallbackImg_.src = url;\n    } else {\n      var backgroundImage = '';\n\n      // Any falsey values should stay as an empty string, otherwise\n      // this will throw an extra error\n      if (url) {\n        backgroundImage = 'url(\"' + url + '\")';\n      }\n\n      this.el_.style.backgroundImage = backgroundImage;\n    }\n  };\n\n  /**\n   * An {@link EventTarget~EventListener} for clicks on the `PosterImage`. See\n   * {@link ClickableComponent#handleClick} for instances where this will be triggered.\n   *\n   * @listens tap\n   * @listens click\n   * @listens keydown\n   *\n   * @param {EventTarget~Event} event\n   +        The `click`, `tap` or `keydown` event that caused this function to be called.\n   */\n\n\n  PosterImage.prototype.handleClick = function handleClick(event) {\n    // We don't want a click to trigger playback when controls are disabled\n    if (!this.player_.controls()) {\n      return;\n    }\n\n    if (this.player_.paused()) {\n      silencePromise(this.player_.play());\n    } else {\n      this.player_.pause();\n    }\n  };\n\n  return PosterImage;\n}(ClickableComponent);\n\nComponent.registerComponent('PosterImage', PosterImage);\n\n/**\n * @file text-track-display.js\n */\nvar darkGray = '#222';\nvar lightGray = '#ccc';\nvar fontMap = {\n  monospace: 'monospace',\n  sansSerif: 'sans-serif',\n  serif: 'serif',\n  monospaceSansSerif: '\"Andale Mono\", \"Lucida Console\", monospace',\n  monospaceSerif: '\"Courier New\", monospace',\n  proportionalSansSerif: 'sans-serif',\n  proportionalSerif: 'serif',\n  casual: '\"Comic Sans MS\", Impact, fantasy',\n  script: '\"Monotype Corsiva\", cursive',\n  smallcaps: '\"Andale Mono\", \"Lucida Console\", monospace, sans-serif'\n};\n\n/**\n * Construct an rgba color from a given hex color code.\n *\n * @param {number} color\n *        Hex number for color, like #f0e or #f604e2.\n *\n * @param {number} opacity\n *        Value for opacity, 0.0 - 1.0.\n *\n * @return {string}\n *         The rgba color that was created, like 'rgba(255, 0, 0, 0.3)'.\n */\nfunction constructColor(color, opacity) {\n  var hex = void 0;\n\n  if (color.length === 4) {\n    // color looks like \"#f0e\"\n    hex = color[1] + color[1] + color[2] + color[2] + color[3] + color[3];\n  } else if (color.length === 7) {\n    // color looks like \"#f604e2\"\n    hex = color.slice(1);\n  } else {\n    throw new Error('Invalid color code provided, ' + color + '; must be formatted as e.g. #f0e or #f604e2.');\n  }\n  return 'rgba(' + parseInt(hex.slice(0, 2), 16) + ',' + parseInt(hex.slice(2, 4), 16) + ',' + parseInt(hex.slice(4, 6), 16) + ',' + opacity + ')';\n}\n\n/**\n * Try to update the style of a DOM element. Some style changes will throw an error,\n * particularly in IE8. Those should be noops.\n *\n * @param {Element} el\n *        The DOM element to be styled.\n *\n * @param {string} style\n *        The CSS property on the element that should be styled.\n *\n * @param {string} rule\n *        The style rule that should be applied to the property.\n *\n * @private\n */\nfunction tryUpdateStyle(el, style, rule) {\n  try {\n    el.style[style] = rule;\n  } catch (e) {\n\n    // Satisfies linter.\n    return;\n  }\n}\n\n/**\n * The component for displaying text track cues.\n *\n * @extends Component\n */\n\nvar TextTrackDisplay = function (_Component) {\n  inherits(TextTrackDisplay, _Component);\n\n  /**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   *\n   * @param {Component~ReadyCallback} [ready]\n   *        The function to call when `TextTrackDisplay` is ready.\n   */\n  function TextTrackDisplay(player, options, ready) {\n    classCallCheck(this, TextTrackDisplay);\n\n    var _this = possibleConstructorReturn(this, _Component.call(this, player, options, ready));\n\n    var updateDisplayHandler = bind(_this, _this.updateDisplay);\n\n    player.on('loadstart', bind(_this, _this.toggleDisplay));\n    player.on('texttrackchange', updateDisplayHandler);\n    player.on('loadstart', bind(_this, _this.preselectTrack));\n\n    // This used to be called during player init, but was causing an error\n    // if a track should show by default and the display hadn't loaded yet.\n    // Should probably be moved to an external track loader when we support\n    // tracks that don't need a display.\n    player.ready(bind(_this, function () {\n      if (player.tech_ && player.tech_.featuresNativeTextTracks) {\n        this.hide();\n        return;\n      }\n\n      player.on('fullscreenchange', updateDisplayHandler);\n      player.on('playerresize', updateDisplayHandler);\n\n      if (window.addEventListener) {\n        window.addEventListener('orientationchange', updateDisplayHandler);\n      }\n      player.on('dispose', function () {\n        return window.removeEventListener('orientationchange', updateDisplayHandler);\n      });\n\n      var tracks = this.options_.playerOptions.tracks || [];\n\n      for (var i = 0; i < tracks.length; i++) {\n        this.player_.addRemoteTextTrack(tracks[i], true);\n      }\n\n      this.preselectTrack();\n    }));\n    return _this;\n  }\n\n  /**\n  * Preselect a track following this precedence:\n  * - matches the previously selected {@link TextTrack}'s language and kind\n  * - matches the previously selected {@link TextTrack}'s language only\n  * - is the first default captions track\n  * - is the first default descriptions track\n  *\n  * @listens Player#loadstart\n  */\n\n\n  TextTrackDisplay.prototype.preselectTrack = function preselectTrack() {\n    var modes = { captions: 1, subtitles: 1 };\n    var trackList = this.player_.textTracks();\n    var userPref = this.player_.cache_.selectedLanguage;\n    var firstDesc = void 0;\n    var firstCaptions = void 0;\n    var preferredTrack = void 0;\n\n    for (var i = 0; i < trackList.length; i++) {\n      var track = trackList[i];\n\n      if (userPref && userPref.enabled && userPref.language === track.language) {\n        // Always choose the track that matches both language and kind\n        if (track.kind === userPref.kind) {\n          preferredTrack = track;\n          // or choose the first track that matches language\n        } else if (!preferredTrack) {\n          preferredTrack = track;\n        }\n\n        // clear everything if offTextTrackMenuItem was clicked\n      } else if (userPref && !userPref.enabled) {\n        preferredTrack = null;\n        firstDesc = null;\n        firstCaptions = null;\n      } else if (track['default']) {\n        if (track.kind === 'descriptions' && !firstDesc) {\n          firstDesc = track;\n        } else if (track.kind in modes && !firstCaptions) {\n          firstCaptions = track;\n        }\n      }\n    }\n\n    // The preferredTrack matches the user preference and takes\n    // precendence over all the other tracks.\n    // So, display the preferredTrack before the first default track\n    // and the subtitles/captions track before the descriptions track\n    if (preferredTrack) {\n      preferredTrack.mode = 'showing';\n    } else if (firstCaptions) {\n      firstCaptions.mode = 'showing';\n    } else if (firstDesc) {\n      firstDesc.mode = 'showing';\n    }\n  };\n\n  /**\n   * Turn display of {@link TextTrack}'s from the current state into the other state.\n   * There are only two states:\n   * - 'shown'\n   * - 'hidden'\n   *\n   * @listens Player#loadstart\n   */\n\n\n  TextTrackDisplay.prototype.toggleDisplay = function toggleDisplay() {\n    if (this.player_.tech_ && this.player_.tech_.featuresNativeTextTracks) {\n      this.hide();\n    } else {\n      this.show();\n    }\n  };\n\n  /**\n   * Create the {@link Component}'s DOM element.\n   *\n   * @return {Element}\n   *         The element that was created.\n   */\n\n\n  TextTrackDisplay.prototype.createEl = function createEl() {\n    return _Component.prototype.createEl.call(this, 'div', {\n      className: 'vjs-text-track-display'\n    }, {\n      'aria-live': 'off',\n      'aria-atomic': 'true'\n    });\n  };\n\n  /**\n   * Clear all displayed {@link TextTrack}s.\n   */\n\n\n  TextTrackDisplay.prototype.clearDisplay = function clearDisplay() {\n    if (typeof window.WebVTT === 'function') {\n      window.WebVTT.processCues(window, [], this.el_);\n    }\n  };\n\n  /**\n   * Update the displayed TextTrack when a either a {@link Player#texttrackchange} or\n   * a {@link Player#fullscreenchange} is fired.\n   *\n   * @listens Player#texttrackchange\n   * @listens Player#fullscreenchange\n   */\n\n\n  TextTrackDisplay.prototype.updateDisplay = function updateDisplay() {\n    var tracks = this.player_.textTracks();\n\n    this.clearDisplay();\n\n    // Track display prioritization model: if multiple tracks are 'showing',\n    //  display the first 'subtitles' or 'captions' track which is 'showing',\n    //  otherwise display the first 'descriptions' track which is 'showing'\n\n    var descriptionsTrack = null;\n    var captionsSubtitlesTrack = null;\n    var i = tracks.length;\n\n    while (i--) {\n      var track = tracks[i];\n\n      if (track.mode === 'showing') {\n        if (track.kind === 'descriptions') {\n          descriptionsTrack = track;\n        } else {\n          captionsSubtitlesTrack = track;\n        }\n      }\n    }\n\n    if (captionsSubtitlesTrack) {\n      if (this.getAttribute('aria-live') !== 'off') {\n        this.setAttribute('aria-live', 'off');\n      }\n      this.updateForTrack(captionsSubtitlesTrack);\n    } else if (descriptionsTrack) {\n      if (this.getAttribute('aria-live') !== 'assertive') {\n        this.setAttribute('aria-live', 'assertive');\n      }\n      this.updateForTrack(descriptionsTrack);\n    }\n  };\n\n  /**\n   * Add an {@link Texttrack} to to the {@link Tech}s {@link TextTrackList}.\n   *\n   * @param {TextTrack} track\n   *        Text track object to be added to the list.\n   */\n\n\n  TextTrackDisplay.prototype.updateForTrack = function updateForTrack(track) {\n    if (typeof window.WebVTT !== 'function' || !track.activeCues) {\n      return;\n    }\n\n    var cues = [];\n\n    for (var _i = 0; _i < track.activeCues.length; _i++) {\n      cues.push(track.activeCues[_i]);\n    }\n\n    window.WebVTT.processCues(window, cues, this.el_);\n\n    if (!this.player_.textTrackSettings) {\n      return;\n    }\n\n    var overrides = this.player_.textTrackSettings.getValues();\n\n    var i = cues.length;\n\n    while (i--) {\n      var cue = cues[i];\n\n      if (!cue) {\n        continue;\n      }\n\n      var cueDiv = cue.displayState;\n\n      if (overrides.color) {\n        cueDiv.firstChild.style.color = overrides.color;\n      }\n      if (overrides.textOpacity) {\n        tryUpdateStyle(cueDiv.firstChild, 'color', constructColor(overrides.color || '#fff', overrides.textOpacity));\n      }\n      if (overrides.backgroundColor) {\n        cueDiv.firstChild.style.backgroundColor = overrides.backgroundColor;\n      }\n      if (overrides.backgroundOpacity) {\n        tryUpdateStyle(cueDiv.firstChild, 'backgroundColor', constructColor(overrides.backgroundColor || '#000', overrides.backgroundOpacity));\n      }\n      if (overrides.windowColor) {\n        if (overrides.windowOpacity) {\n          tryUpdateStyle(cueDiv, 'backgroundColor', constructColor(overrides.windowColor, overrides.windowOpacity));\n        } else {\n          cueDiv.style.backgroundColor = overrides.windowColor;\n        }\n      }\n      if (overrides.edgeStyle) {\n        if (overrides.edgeStyle === 'dropshadow') {\n          cueDiv.firstChild.style.textShadow = '2px 2px 3px ' + darkGray + ', 2px 2px 4px ' + darkGray + ', 2px 2px 5px ' + darkGray;\n        } else if (overrides.edgeStyle === 'raised') {\n          cueDiv.firstChild.style.textShadow = '1px 1px ' + darkGray + ', 2px 2px ' + darkGray + ', 3px 3px ' + darkGray;\n        } else if (overrides.edgeStyle === 'depressed') {\n          cueDiv.firstChild.style.textShadow = '1px 1px ' + lightGray + ', 0 1px ' + lightGray + ', -1px -1px ' + darkGray + ', 0 -1px ' + darkGray;\n        } else if (overrides.edgeStyle === 'uniform') {\n          cueDiv.firstChild.style.textShadow = '0 0 4px ' + darkGray + ', 0 0 4px ' + darkGray + ', 0 0 4px ' + darkGray + ', 0 0 4px ' + darkGray;\n        }\n      }\n      if (overrides.fontPercent && overrides.fontPercent !== 1) {\n        var fontSize = window.parseFloat(cueDiv.style.fontSize);\n\n        cueDiv.style.fontSize = fontSize * overrides.fontPercent + 'px';\n        cueDiv.style.height = 'auto';\n        cueDiv.style.top = 'auto';\n        cueDiv.style.bottom = '2px';\n      }\n      if (overrides.fontFamily && overrides.fontFamily !== 'default') {\n        if (overrides.fontFamily === 'small-caps') {\n          cueDiv.firstChild.style.fontVariant = 'small-caps';\n        } else {\n          cueDiv.firstChild.style.fontFamily = fontMap[overrides.fontFamily];\n        }\n      }\n    }\n  };\n\n  return TextTrackDisplay;\n}(Component);\n\nComponent.registerComponent('TextTrackDisplay', TextTrackDisplay);\n\n/**\n * @file loading-spinner.js\n */\n/**\n * A loading spinner for use during waiting/loading events.\n *\n * @extends Component\n */\n\nvar LoadingSpinner = function (_Component) {\n  inherits(LoadingSpinner, _Component);\n\n  function LoadingSpinner() {\n    classCallCheck(this, LoadingSpinner);\n    return possibleConstructorReturn(this, _Component.apply(this, arguments));\n  }\n\n  /**\n   * Create the `LoadingSpinner`s DOM element.\n   *\n   * @return {Element}\n   *         The dom element that gets created.\n   */\n  LoadingSpinner.prototype.createEl = function createEl$$1() {\n    var isAudio = this.player_.isAudio();\n    var playerType = this.localize(isAudio ? 'Audio Player' : 'Video Player');\n    var controlText = createEl('span', {\n      className: 'vjs-control-text',\n      innerHTML: this.localize('{1} is loading.', [playerType])\n    });\n\n    var el = _Component.prototype.createEl.call(this, 'div', {\n      className: 'vjs-loading-spinner',\n      dir: 'ltr'\n    });\n\n    el.appendChild(controlText);\n\n    return el;\n  };\n\n  return LoadingSpinner;\n}(Component);\n\nComponent.registerComponent('LoadingSpinner', LoadingSpinner);\n\n/**\n * @file button.js\n */\n/**\n * Base class for all buttons.\n *\n * @extends ClickableComponent\n */\n\nvar Button = function (_ClickableComponent) {\n  inherits(Button, _ClickableComponent);\n\n  function Button() {\n    classCallCheck(this, Button);\n    return possibleConstructorReturn(this, _ClickableComponent.apply(this, arguments));\n  }\n\n  /**\n   * Create the `Button`s DOM element.\n   *\n   * @param {string} [tag=\"button\"]\n   *        The element's node type. This argument is IGNORED: no matter what\n   *        is passed, it will always create a `button` element.\n   *\n   * @param {Object} [props={}]\n   *        An object of properties that should be set on the element.\n   *\n   * @param {Object} [attributes={}]\n   *        An object of attributes that should be set on the element.\n   *\n   * @return {Element}\n   *         The element that gets created.\n   */\n  Button.prototype.createEl = function createEl(tag) {\n    var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var attributes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    tag = 'button';\n\n    props = assign({\n      innerHTML: '<span aria-hidden=\"true\" class=\"vjs-icon-placeholder\"></span>',\n      className: this.buildCSSClass()\n    }, props);\n\n    // Add attributes for button element\n    attributes = assign({\n\n      // Necessary since the default button type is \"submit\"\n      type: 'button'\n    }, attributes);\n\n    var el = Component.prototype.createEl.call(this, tag, props, attributes);\n\n    this.createControlTextEl(el);\n\n    return el;\n  };\n\n  /**\n   * Add a child `Component` inside of this `Button`.\n   *\n   * @param {string|Component} child\n   *        The name or instance of a child to add.\n   *\n   * @param {Object} [options={}]\n   *        The key/value store of options that will get passed to children of\n   *        the child.\n   *\n   * @return {Component}\n   *         The `Component` that gets added as a child. When using a string the\n   *         `Component` will get created by this process.\n   *\n   * @deprecated since version 5\n   */\n\n\n  Button.prototype.addChild = function addChild(child) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    var className = this.constructor.name;\n\n    log.warn('Adding an actionable (user controllable) child to a Button (' + className + ') is not supported; use a ClickableComponent instead.');\n\n    // Avoid the error message generated by ClickableComponent's addChild method\n    return Component.prototype.addChild.call(this, child, options);\n  };\n\n  /**\n   * Enable the `Button` element so that it can be activated or clicked. Use this with\n   * {@link Button#disable}.\n   */\n\n\n  Button.prototype.enable = function enable() {\n    _ClickableComponent.prototype.enable.call(this);\n    this.el_.removeAttribute('disabled');\n  };\n\n  /**\n   * Disable the `Button` element so that it cannot be activated or clicked. Use this with\n   * {@link Button#enable}.\n   */\n\n\n  Button.prototype.disable = function disable() {\n    _ClickableComponent.prototype.disable.call(this);\n    this.el_.setAttribute('disabled', 'disabled');\n  };\n\n  /**\n   * This gets called when a `Button` has focus and `keydown` is triggered via a key\n   * press.\n   *\n   * @param {EventTarget~Event} event\n   *        The event that caused this function to get called.\n   *\n   * @listens keydown\n   */\n\n\n  Button.prototype.handleKeyPress = function handleKeyPress(event) {\n\n    // Ignore Space (32) or Enter (13) key operation, which is handled by the browser for a button.\n    if (event.which === 32 || event.which === 13) {\n      return;\n    }\n\n    // Pass keypress handling up for unsupported keys\n    _ClickableComponent.prototype.handleKeyPress.call(this, event);\n  };\n\n  return Button;\n}(ClickableComponent);\n\nComponent.registerComponent('Button', Button);\n\n/**\n * @file big-play-button.js\n */\n/**\n * The initial play button that shows before the video has played. The hiding of the\n * `BigPlayButton` get done via CSS and `Player` states.\n *\n * @extends Button\n */\n\nvar BigPlayButton = function (_Button) {\n  inherits(BigPlayButton, _Button);\n\n  function BigPlayButton(player, options) {\n    classCallCheck(this, BigPlayButton);\n\n    var _this = possibleConstructorReturn(this, _Button.call(this, player, options));\n\n    _this.mouseused_ = false;\n\n    _this.on('mousedown', _this.handleMouseDown);\n    return _this;\n  }\n\n  /**\n   * Builds the default DOM `className`.\n   *\n   * @return {string}\n   *         The DOM `className` for this object. Always returns 'vjs-big-play-button'.\n   */\n\n\n  BigPlayButton.prototype.buildCSSClass = function buildCSSClass() {\n    return 'vjs-big-play-button';\n  };\n\n  /**\n   * This gets called when a `BigPlayButton` \"clicked\". See {@link ClickableComponent}\n   * for more detailed information on what a click can be.\n   *\n   * @param {EventTarget~Event} event\n   *        The `keydown`, `tap`, or `click` event that caused this function to be\n   *        called.\n   *\n   * @listens tap\n   * @listens click\n   */\n\n\n  BigPlayButton.prototype.handleClick = function handleClick(event) {\n    var playPromise = this.player_.play();\n\n    // exit early if clicked via the mouse\n    if (this.mouseused_ && event.clientX && event.clientY) {\n      silencePromise(playPromise);\n      return;\n    }\n\n    var cb = this.player_.getChild('controlBar');\n    var playToggle = cb && cb.getChild('playToggle');\n\n    if (!playToggle) {\n      this.player_.focus();\n      return;\n    }\n\n    var playFocus = function playFocus() {\n      return playToggle.focus();\n    };\n\n    if (isPromise(playPromise)) {\n      playPromise.then(playFocus, function () {});\n    } else {\n      this.setTimeout(playFocus, 1);\n    }\n  };\n\n  BigPlayButton.prototype.handleKeyPress = function handleKeyPress(event) {\n    this.mouseused_ = false;\n\n    _Button.prototype.handleKeyPress.call(this, event);\n  };\n\n  BigPlayButton.prototype.handleMouseDown = function handleMouseDown(event) {\n    this.mouseused_ = true;\n  };\n\n  return BigPlayButton;\n}(Button);\n\n/**\n * The text that should display over the `BigPlayButton`s controls. Added to for localization.\n *\n * @type {string}\n * @private\n */\n\n\nBigPlayButton.prototype.controlText_ = 'Play Video';\n\nComponent.registerComponent('BigPlayButton', BigPlayButton);\n\n/**\n * @file close-button.js\n */\n/**\n * The `CloseButton` is a `{@link Button}` that fires a `close` event when\n * it gets clicked.\n *\n * @extends Button\n */\n\nvar CloseButton = function (_Button) {\n  inherits(CloseButton, _Button);\n\n  /**\n   * Creates an instance of the this class.\n   *\n   * @param  {Player} player\n   *         The `Player` that this class should be attached to.\n   *\n   * @param  {Object} [options]\n   *         The key/value store of player options.\n   */\n  function CloseButton(player, options) {\n    classCallCheck(this, CloseButton);\n\n    var _this = possibleConstructorReturn(this, _Button.call(this, player, options));\n\n    _this.controlText(options && options.controlText || _this.localize('Close'));\n    return _this;\n  }\n\n  /**\n   * Builds the default DOM `className`.\n   *\n   * @return {string}\n   *         The DOM `className` for this object.\n   */\n\n\n  CloseButton.prototype.buildCSSClass = function buildCSSClass() {\n    return 'vjs-close-button ' + _Button.prototype.buildCSSClass.call(this);\n  };\n\n  /**\n   * This gets called when a `CloseButton` gets clicked. See\n   * {@link ClickableComponent#handleClick} for more information on when this will be\n   * triggered\n   *\n   * @param {EventTarget~Event} event\n   *        The `keydown`, `tap`, or `click` event that caused this function to be\n   *        called.\n   *\n   * @listens tap\n   * @listens click\n   * @fires CloseButton#close\n   */\n\n\n  CloseButton.prototype.handleClick = function handleClick(event) {\n\n    /**\n     * Triggered when the a `CloseButton` is clicked.\n     *\n     * @event CloseButton#close\n     * @type {EventTarget~Event}\n     *\n     * @property {boolean} [bubbles=false]\n     *           set to false so that the close event does not\n     *           bubble up to parents if there is no listener\n     */\n    this.trigger({ type: 'close', bubbles: false });\n  };\n\n  return CloseButton;\n}(Button);\n\nComponent.registerComponent('CloseButton', CloseButton);\n\n/**\n * @file play-toggle.js\n */\n/**\n * Button to toggle between play and pause.\n *\n * @extends Button\n */\n\nvar PlayToggle = function (_Button) {\n  inherits(PlayToggle, _Button);\n\n  /**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   */\n  function PlayToggle(player, options) {\n    classCallCheck(this, PlayToggle);\n\n    var _this = possibleConstructorReturn(this, _Button.call(this, player, options));\n\n    _this.on(player, 'play', _this.handlePlay);\n    _this.on(player, 'pause', _this.handlePause);\n    _this.on(player, 'ended', _this.handleEnded);\n    return _this;\n  }\n\n  /**\n   * Builds the default DOM `className`.\n   *\n   * @return {string}\n   *         The DOM `className` for this object.\n   */\n\n\n  PlayToggle.prototype.buildCSSClass = function buildCSSClass() {\n    return 'vjs-play-control ' + _Button.prototype.buildCSSClass.call(this);\n  };\n\n  /**\n   * This gets called when an `PlayToggle` is \"clicked\". See\n   * {@link ClickableComponent} for more detailed information on what a click can be.\n   *\n   * @param {EventTarget~Event} [event]\n   *        The `keydown`, `tap`, or `click` event that caused this function to be\n   *        called.\n   *\n   * @listens tap\n   * @listens click\n   */\n\n\n  PlayToggle.prototype.handleClick = function handleClick(event) {\n    if (this.player_.paused()) {\n      this.player_.play();\n    } else {\n      this.player_.pause();\n    }\n  };\n\n  /**\n   * This gets called once after the video has ended and the user seeks so that\n   * we can change the replay button back to a play button.\n   *\n   * @param {EventTarget~Event} [event]\n   *        The event that caused this function to run.\n   *\n   * @listens Player#seeked\n   */\n\n\n  PlayToggle.prototype.handleSeeked = function handleSeeked(event) {\n    this.removeClass('vjs-ended');\n\n    if (this.player_.paused()) {\n      this.handlePause(event);\n    } else {\n      this.handlePlay(event);\n    }\n  };\n\n  /**\n   * Add the vjs-playing class to the element so it can change appearance.\n   *\n   * @param {EventTarget~Event} [event]\n   *        The event that caused this function to run.\n   *\n   * @listens Player#play\n   */\n\n\n  PlayToggle.prototype.handlePlay = function handlePlay(event) {\n    this.removeClass('vjs-ended');\n    this.removeClass('vjs-paused');\n    this.addClass('vjs-playing');\n    // change the button text to \"Pause\"\n    this.controlText('Pause');\n  };\n\n  /**\n   * Add the vjs-paused class to the element so it can change appearance.\n   *\n   * @param {EventTarget~Event} [event]\n   *        The event that caused this function to run.\n   *\n   * @listens Player#pause\n   */\n\n\n  PlayToggle.prototype.handlePause = function handlePause(event) {\n    this.removeClass('vjs-playing');\n    this.addClass('vjs-paused');\n    // change the button text to \"Play\"\n    this.controlText('Play');\n  };\n\n  /**\n   * Add the vjs-ended class to the element so it can change appearance\n   *\n   * @param {EventTarget~Event} [event]\n   *        The event that caused this function to run.\n   *\n   * @listens Player#ended\n   */\n\n\n  PlayToggle.prototype.handleEnded = function handleEnded(event) {\n    this.removeClass('vjs-playing');\n    this.addClass('vjs-ended');\n    // change the button text to \"Replay\"\n    this.controlText('Replay');\n\n    // on the next seek remove the replay button\n    this.one(this.player_, 'seeked', this.handleSeeked);\n  };\n\n  return PlayToggle;\n}(Button);\n\n/**\n * The text that should display over the `PlayToggle`s controls. Added for localization.\n *\n * @type {string}\n * @private\n */\n\n\nPlayToggle.prototype.controlText_ = 'Play';\n\nComponent.registerComponent('PlayToggle', PlayToggle);\n\n/**\n * @file format-time.js\n * @module format-time\n */\n\n/**\n* Format seconds as a time string, H:MM:SS or M:SS. Supplying a guide (in seconds)\n* will force a number of leading zeros to cover the length of the guide.\n*\n* @param {number} seconds\n*        Number of seconds to be turned into a string\n*\n* @param {number} guide\n*        Number (in seconds) to model the string after\n*\n* @return {string}\n*         Time formatted as H:MM:SS or M:SS\n*/\nvar defaultImplementation = function defaultImplementation(seconds, guide) {\n  seconds = seconds < 0 ? 0 : seconds;\n  var s = Math.floor(seconds % 60);\n  var m = Math.floor(seconds / 60 % 60);\n  var h = Math.floor(seconds / 3600);\n  var gm = Math.floor(guide / 60 % 60);\n  var gh = Math.floor(guide / 3600);\n\n  // handle invalid times\n  if (isNaN(seconds) || seconds === Infinity) {\n    // '-' is false for all relational operators (e.g. <, >=) so this setting\n    // will add the minimum number of fields specified by the guide\n    h = m = s = '-';\n  }\n\n  // Check if we need to show hours\n  h = h > 0 || gh > 0 ? h + ':' : '';\n\n  // If hours are showing, we may need to add a leading zero.\n  // Always show at least one digit of minutes.\n  m = ((h || gm >= 10) && m < 10 ? '0' + m : m) + ':';\n\n  // Check if leading zero is need for seconds\n  s = s < 10 ? '0' + s : s;\n\n  return h + m + s;\n};\n\nvar implementation = defaultImplementation;\n\n/**\n * Replaces the default formatTime implementation with a custom implementation.\n *\n * @param {Function} customImplementation\n *        A function which will be used in place of the default formatTime implementation.\n *        Will receive the current time in seconds and the guide (in seconds) as arguments.\n */\nfunction setFormatTime(customImplementation) {\n  implementation = customImplementation;\n}\n\n/**\n * Resets formatTime to the default implementation.\n */\nfunction resetFormatTime() {\n  implementation = defaultImplementation;\n}\n\nvar formatTime = function (seconds) {\n  var guide = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : seconds;\n\n  return implementation(seconds, guide);\n};\n\n/**\n * @file time-display.js\n */\n/**\n * Displays the time left in the video\n *\n * @extends Component\n */\n\nvar TimeDisplay = function (_Component) {\n  inherits(TimeDisplay, _Component);\n\n  /**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   */\n  function TimeDisplay(player, options) {\n    classCallCheck(this, TimeDisplay);\n\n    var _this = possibleConstructorReturn(this, _Component.call(this, player, options));\n\n    _this.throttledUpdateContent = throttle(bind(_this, _this.updateContent), 25);\n    _this.on(player, 'timeupdate', _this.throttledUpdateContent);\n    return _this;\n  }\n\n  /**\n   * Create the `Component`'s DOM element\n   *\n   * @return {Element}\n   *         The element that was created.\n   */\n\n\n  TimeDisplay.prototype.createEl = function createEl$$1(plainName) {\n    var className = this.buildCSSClass();\n    var el = _Component.prototype.createEl.call(this, 'div', {\n      className: className + ' vjs-time-control vjs-control',\n      innerHTML: '<span class=\"vjs-control-text\">' + this.localize(this.labelText_) + '\\xA0</span>'\n    });\n\n    this.contentEl_ = createEl('span', {\n      className: className + '-display'\n    }, {\n      // tell screen readers not to automatically read the time as it changes\n      'aria-live': 'off'\n    });\n\n    this.updateTextNode_();\n    el.appendChild(this.contentEl_);\n    return el;\n  };\n\n  TimeDisplay.prototype.dispose = function dispose() {\n    this.contentEl_ = null;\n    this.textNode_ = null;\n\n    _Component.prototype.dispose.call(this);\n  };\n\n  /**\n   * Updates the \"remaining time\" text node with new content using the\n   * contents of the `formattedTime_` property.\n   *\n   * @private\n   */\n\n\n  TimeDisplay.prototype.updateTextNode_ = function updateTextNode_() {\n    if (!this.contentEl_) {\n      return;\n    }\n\n    while (this.contentEl_.firstChild) {\n      this.contentEl_.removeChild(this.contentEl_.firstChild);\n    }\n\n    this.textNode_ = document.createTextNode(this.formattedTime_ || this.formatTime_(0));\n    this.contentEl_.appendChild(this.textNode_);\n  };\n\n  /**\n   * Generates a formatted time for this component to use in display.\n   *\n   * @param  {number} time\n   *         A numeric time, in seconds.\n   *\n   * @return {string}\n   *         A formatted time\n   *\n   * @private\n   */\n\n\n  TimeDisplay.prototype.formatTime_ = function formatTime_(time) {\n    return formatTime(time);\n  };\n\n  /**\n   * Updates the time display text node if it has what was passed in changed\n   * the formatted time.\n   *\n   * @param {number} time\n   *        The time to update to\n   *\n   * @private\n   */\n\n\n  TimeDisplay.prototype.updateFormattedTime_ = function updateFormattedTime_(time) {\n    var formattedTime = this.formatTime_(time);\n\n    if (formattedTime === this.formattedTime_) {\n      return;\n    }\n\n    this.formattedTime_ = formattedTime;\n    this.requestAnimationFrame(this.updateTextNode_);\n  };\n\n  /**\n   * To be filled out in the child class, should update the displayed time\n   * in accordance with the fact that the current time has changed.\n   *\n   * @param {EventTarget~Event} [event]\n   *        The `timeupdate`  event that caused this to run.\n   *\n   * @listens Player#timeupdate\n   */\n\n\n  TimeDisplay.prototype.updateContent = function updateContent(event) {};\n\n  return TimeDisplay;\n}(Component);\n\n/**\n * The text that is added to the `TimeDisplay` for screen reader users.\n *\n * @type {string}\n * @private\n */\n\n\nTimeDisplay.prototype.labelText_ = 'Time';\n\n/**\n * The text that should display over the `TimeDisplay`s controls. Added to for localization.\n *\n * @type {string}\n * @private\n *\n * @deprecated in v7; controlText_ is not used in non-active display Components\n */\nTimeDisplay.prototype.controlText_ = 'Time';\n\nComponent.registerComponent('TimeDisplay', TimeDisplay);\n\n/**\n * @file current-time-display.js\n */\n/**\n * Displays the current time\n *\n * @extends Component\n */\n\nvar CurrentTimeDisplay = function (_TimeDisplay) {\n  inherits(CurrentTimeDisplay, _TimeDisplay);\n\n  /**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   */\n  function CurrentTimeDisplay(player, options) {\n    classCallCheck(this, CurrentTimeDisplay);\n\n    var _this = possibleConstructorReturn(this, _TimeDisplay.call(this, player, options));\n\n    _this.on(player, 'ended', _this.handleEnded);\n    return _this;\n  }\n\n  /**\n   * Builds the default DOM `className`.\n   *\n   * @return {string}\n   *         The DOM `className` for this object.\n   */\n\n\n  CurrentTimeDisplay.prototype.buildCSSClass = function buildCSSClass() {\n    return 'vjs-current-time';\n  };\n\n  /**\n   * Update current time display\n   *\n   * @param {EventTarget~Event} [event]\n   *        The `timeupdate` event that caused this function to run.\n   *\n   * @listens Player#timeupdate\n   */\n\n\n  CurrentTimeDisplay.prototype.updateContent = function updateContent(event) {\n    // Allows for smooth scrubbing, when player can't keep up.\n    var time = this.player_.scrubbing() ? this.player_.getCache().currentTime : this.player_.currentTime();\n\n    this.updateFormattedTime_(time);\n  };\n\n  /**\n   * When the player fires ended there should be no time left. Sadly\n   * this is not always the case, lets make it seem like that is the case\n   * for users.\n   *\n   * @param {EventTarget~Event} [event]\n   *        The `ended` event that caused this to run.\n   *\n   * @listens Player#ended\n   */\n\n\n  CurrentTimeDisplay.prototype.handleEnded = function handleEnded(event) {\n    if (!this.player_.duration()) {\n      return;\n    }\n    this.updateFormattedTime_(this.player_.duration());\n  };\n\n  return CurrentTimeDisplay;\n}(TimeDisplay);\n\n/**\n * The text that is added to the `CurrentTimeDisplay` for screen reader users.\n *\n * @type {string}\n * @private\n */\n\n\nCurrentTimeDisplay.prototype.labelText_ = 'Current Time';\n\n/**\n * The text that should display over the `CurrentTimeDisplay`s controls. Added to for localization.\n *\n * @type {string}\n * @private\n *\n * @deprecated in v7; controlText_ is not used in non-active display Components\n */\nCurrentTimeDisplay.prototype.controlText_ = 'Current Time';\n\nComponent.registerComponent('CurrentTimeDisplay', CurrentTimeDisplay);\n\n/**\n * @file duration-display.js\n */\n/**\n * Displays the duration\n *\n * @extends Component\n */\n\nvar DurationDisplay = function (_TimeDisplay) {\n  inherits(DurationDisplay, _TimeDisplay);\n\n  /**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   */\n  function DurationDisplay(player, options) {\n    classCallCheck(this, DurationDisplay);\n\n    // we do not want to/need to throttle duration changes,\n    // as they should always display the changed duration as\n    // it has changed\n    var _this = possibleConstructorReturn(this, _TimeDisplay.call(this, player, options));\n\n    _this.on(player, 'durationchange', _this.updateContent);\n\n    // Also listen for timeupdate (in the parent) and loadedmetadata because removing those\n    // listeners could have broken dependent applications/libraries. These\n    // can likely be removed for 7.0.\n    _this.on(player, 'loadedmetadata', _this.throttledUpdateContent);\n    return _this;\n  }\n\n  /**\n   * Builds the default DOM `className`.\n   *\n   * @return {string}\n   *         The DOM `className` for this object.\n   */\n\n\n  DurationDisplay.prototype.buildCSSClass = function buildCSSClass() {\n    return 'vjs-duration';\n  };\n\n  /**\n   * Update duration time display.\n   *\n   * @param {EventTarget~Event} [event]\n   *        The `durationchange`, `timeupdate`, or `loadedmetadata` event that caused\n   *        this function to be called.\n   *\n   * @listens Player#durationchange\n   * @listens Player#timeupdate\n   * @listens Player#loadedmetadata\n   */\n\n\n  DurationDisplay.prototype.updateContent = function updateContent(event) {\n    var duration = this.player_.duration();\n\n    if (duration && this.duration_ !== duration) {\n      this.duration_ = duration;\n      this.updateFormattedTime_(duration);\n    }\n  };\n\n  return DurationDisplay;\n}(TimeDisplay);\n\n/**\n * The text that is added to the `DurationDisplay` for screen reader users.\n *\n * @type {string}\n * @private\n */\n\n\nDurationDisplay.prototype.labelText_ = 'Duration';\n\n/**\n * The text that should display over the `DurationDisplay`s controls. Added to for localization.\n *\n * @type {string}\n * @private\n *\n * @deprecated in v7; controlText_ is not used in non-active display Components\n */\nDurationDisplay.prototype.controlText_ = 'Duration';\n\nComponent.registerComponent('DurationDisplay', DurationDisplay);\n\n/**\n * @file time-divider.js\n */\n/**\n * The separator between the current time and duration.\n * Can be hidden if it's not needed in the design.\n *\n * @extends Component\n */\n\nvar TimeDivider = function (_Component) {\n  inherits(TimeDivider, _Component);\n\n  function TimeDivider() {\n    classCallCheck(this, TimeDivider);\n    return possibleConstructorReturn(this, _Component.apply(this, arguments));\n  }\n\n  /**\n   * Create the component's DOM element\n   *\n   * @return {Element}\n   *         The element that was created.\n   */\n  TimeDivider.prototype.createEl = function createEl() {\n    return _Component.prototype.createEl.call(this, 'div', {\n      className: 'vjs-time-control vjs-time-divider',\n      innerHTML: '<div><span>/</span></div>'\n    });\n  };\n\n  return TimeDivider;\n}(Component);\n\nComponent.registerComponent('TimeDivider', TimeDivider);\n\n/**\n * @file remaining-time-display.js\n */\n/**\n * Displays the time left in the video\n *\n * @extends Component\n */\n\nvar RemainingTimeDisplay = function (_TimeDisplay) {\n  inherits(RemainingTimeDisplay, _TimeDisplay);\n\n  /**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   */\n  function RemainingTimeDisplay(player, options) {\n    classCallCheck(this, RemainingTimeDisplay);\n\n    var _this = possibleConstructorReturn(this, _TimeDisplay.call(this, player, options));\n\n    _this.on(player, 'durationchange', _this.throttledUpdateContent);\n    _this.on(player, 'ended', _this.handleEnded);\n    return _this;\n  }\n\n  /**\n   * Builds the default DOM `className`.\n   *\n   * @return {string}\n   *         The DOM `className` for this object.\n   */\n\n\n  RemainingTimeDisplay.prototype.buildCSSClass = function buildCSSClass() {\n    return 'vjs-remaining-time';\n  };\n\n  /**\n   * The remaining time display prefixes numbers with a \"minus\" character.\n   *\n   * @param  {number} time\n   *         A numeric time, in seconds.\n   *\n   * @return {string}\n   *         A formatted time\n   *\n   * @private\n   */\n\n\n  RemainingTimeDisplay.prototype.formatTime_ = function formatTime_(time) {\n    // TODO: The \"-\" should be decorative, and not announced by a screen reader\n    return '-' + _TimeDisplay.prototype.formatTime_.call(this, time);\n  };\n\n  /**\n   * Update remaining time display.\n   *\n   * @param {EventTarget~Event} [event]\n   *        The `timeupdate` or `durationchange` event that caused this to run.\n   *\n   * @listens Player#timeupdate\n   * @listens Player#durationchange\n   */\n\n\n  RemainingTimeDisplay.prototype.updateContent = function updateContent(event) {\n    if (!this.player_.duration()) {\n      return;\n    }\n\n    // @deprecated We should only use remainingTimeDisplay\n    // as of video.js 7\n    if (this.player_.remainingTimeDisplay) {\n      this.updateFormattedTime_(this.player_.remainingTimeDisplay());\n    } else {\n      this.updateFormattedTime_(this.player_.remainingTime());\n    }\n  };\n\n  /**\n   * When the player fires ended there should be no time left. Sadly\n   * this is not always the case, lets make it seem like that is the case\n   * for users.\n   *\n   * @param {EventTarget~Event} [event]\n   *        The `ended` event that caused this to run.\n   *\n   * @listens Player#ended\n   */\n\n\n  RemainingTimeDisplay.prototype.handleEnded = function handleEnded(event) {\n    if (!this.player_.duration()) {\n      return;\n    }\n    this.updateFormattedTime_(0);\n  };\n\n  return RemainingTimeDisplay;\n}(TimeDisplay);\n\n/**\n * The text that is added to the `RemainingTimeDisplay` for screen reader users.\n *\n * @type {string}\n * @private\n */\n\n\nRemainingTimeDisplay.prototype.labelText_ = 'Remaining Time';\n\n/**\n * The text that should display over the `RemainingTimeDisplay`s controls. Added to for localization.\n *\n * @type {string}\n * @private\n *\n * @deprecated in v7; controlText_ is not used in non-active display Components\n */\nRemainingTimeDisplay.prototype.controlText_ = 'Remaining Time';\n\nComponent.registerComponent('RemainingTimeDisplay', RemainingTimeDisplay);\n\n/**\n * @file live-display.js\n */\n// TODO - Future make it click to snap to live\n\n/**\n * Displays the live indicator when duration is Infinity.\n *\n * @extends Component\n */\n\nvar LiveDisplay = function (_Component) {\n  inherits(LiveDisplay, _Component);\n\n  /**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   */\n  function LiveDisplay(player, options) {\n    classCallCheck(this, LiveDisplay);\n\n    var _this = possibleConstructorReturn(this, _Component.call(this, player, options));\n\n    _this.updateShowing();\n    _this.on(_this.player(), 'durationchange', _this.updateShowing);\n    return _this;\n  }\n\n  /**\n   * Create the `Component`'s DOM element\n   *\n   * @return {Element}\n   *         The element that was created.\n   */\n\n\n  LiveDisplay.prototype.createEl = function createEl$$1() {\n    var el = _Component.prototype.createEl.call(this, 'div', {\n      className: 'vjs-live-control vjs-control'\n    });\n\n    this.contentEl_ = createEl('div', {\n      className: 'vjs-live-display',\n      innerHTML: '<span class=\"vjs-control-text\">' + this.localize('Stream Type') + '\\xA0</span>' + this.localize('LIVE')\n    }, {\n      'aria-live': 'off'\n    });\n\n    el.appendChild(this.contentEl_);\n    return el;\n  };\n\n  LiveDisplay.prototype.dispose = function dispose() {\n    this.contentEl_ = null;\n\n    _Component.prototype.dispose.call(this);\n  };\n\n  /**\n   * Check the duration to see if the LiveDisplay should be showing or not. Then show/hide\n   * it accordingly\n   *\n   * @param {EventTarget~Event} [event]\n   *        The {@link Player#durationchange} event that caused this function to run.\n   *\n   * @listens Player#durationchange\n   */\n\n\n  LiveDisplay.prototype.updateShowing = function updateShowing(event) {\n    if (this.player().duration() === Infinity) {\n      this.show();\n    } else {\n      this.hide();\n    }\n  };\n\n  return LiveDisplay;\n}(Component);\n\nComponent.registerComponent('LiveDisplay', LiveDisplay);\n\n/**\n * @file slider.js\n */\n/**\n * The base functionality for a slider. Can be vertical or horizontal.\n * For instance the volume bar or the seek bar on a video is a slider.\n *\n * @extends Component\n */\n\nvar Slider = function (_Component) {\n  inherits(Slider, _Component);\n\n  /**\n   * Create an instance of this class\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   */\n  function Slider(player, options) {\n    classCallCheck(this, Slider);\n\n    // Set property names to bar to match with the child Slider class is looking for\n    var _this = possibleConstructorReturn(this, _Component.call(this, player, options));\n\n    _this.bar = _this.getChild(_this.options_.barName);\n\n    // Set a horizontal or vertical class on the slider depending on the slider type\n    _this.vertical(!!_this.options_.vertical);\n\n    _this.enable();\n    return _this;\n  }\n\n  /**\n   * Are controls are currently enabled for this slider or not.\n   *\n   * @return {boolean}\n   *         true if controls are enabled, false otherwise\n   */\n\n\n  Slider.prototype.enabled = function enabled() {\n    return this.enabled_;\n  };\n\n  /**\n   * Enable controls for this slider if they are disabled\n   */\n\n\n  Slider.prototype.enable = function enable() {\n    if (this.enabled()) {\n      return;\n    }\n\n    this.on('mousedown', this.handleMouseDown);\n    this.on('touchstart', this.handleMouseDown);\n    this.on('focus', this.handleFocus);\n    this.on('blur', this.handleBlur);\n    this.on('click', this.handleClick);\n\n    this.on(this.player_, 'controlsvisible', this.update);\n\n    if (this.playerEvent) {\n      this.on(this.player_, this.playerEvent, this.update);\n    }\n\n    this.removeClass('disabled');\n    this.setAttribute('tabindex', 0);\n\n    this.enabled_ = true;\n  };\n\n  /**\n   * Disable controls for this slider if they are enabled\n   */\n\n\n  Slider.prototype.disable = function disable() {\n    if (!this.enabled()) {\n      return;\n    }\n    var doc = this.bar.el_.ownerDocument;\n\n    this.off('mousedown', this.handleMouseDown);\n    this.off('touchstart', this.handleMouseDown);\n    this.off('focus', this.handleFocus);\n    this.off('blur', this.handleBlur);\n    this.off('click', this.handleClick);\n    this.off(this.player_, 'controlsvisible', this.update);\n    this.off(doc, 'mousemove', this.handleMouseMove);\n    this.off(doc, 'mouseup', this.handleMouseUp);\n    this.off(doc, 'touchmove', this.handleMouseMove);\n    this.off(doc, 'touchend', this.handleMouseUp);\n    this.removeAttribute('tabindex');\n\n    this.addClass('disabled');\n\n    if (this.playerEvent) {\n      this.off(this.player_, this.playerEvent, this.update);\n    }\n    this.enabled_ = false;\n  };\n\n  /**\n   * Create the `Button`s DOM element.\n   *\n   * @param {string} type\n   *        Type of element to create.\n   *\n   * @param {Object} [props={}]\n   *        List of properties in Object form.\n   *\n   * @param {Object} [attributes={}]\n   *        list of attributes in Object form.\n   *\n   * @return {Element}\n   *         The element that gets created.\n   */\n\n\n  Slider.prototype.createEl = function createEl$$1(type) {\n    var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var attributes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    // Add the slider element class to all sub classes\n    props.className = props.className + ' vjs-slider';\n    props = assign({\n      tabIndex: 0\n    }, props);\n\n    attributes = assign({\n      'role': 'slider',\n      'aria-valuenow': 0,\n      'aria-valuemin': 0,\n      'aria-valuemax': 100,\n      'tabIndex': 0\n    }, attributes);\n\n    return _Component.prototype.createEl.call(this, type, props, attributes);\n  };\n\n  /**\n   * Handle `mousedown` or `touchstart` events on the `Slider`.\n   *\n   * @param {EventTarget~Event} event\n   *        `mousedown` or `touchstart` event that triggered this function\n   *\n   * @listens mousedown\n   * @listens touchstart\n   * @fires Slider#slideractive\n   */\n\n\n  Slider.prototype.handleMouseDown = function handleMouseDown(event) {\n    var doc = this.bar.el_.ownerDocument;\n\n    if (event.type === 'mousedown') {\n      event.preventDefault();\n    }\n    // Do not call preventDefault() on touchstart in Chrome\n    // to avoid console warnings. Use a 'touch-action: none' style\n    // instead to prevent unintented scrolling.\n    // https://developers.google.com/web/updates/2017/01/scrolling-intervention\n    if (event.type === 'touchstart' && !IS_CHROME) {\n      event.preventDefault();\n    }\n    blockTextSelection();\n\n    this.addClass('vjs-sliding');\n    /**\n     * Triggered when the slider is in an active state\n     *\n     * @event Slider#slideractive\n     * @type {EventTarget~Event}\n     */\n    this.trigger('slideractive');\n\n    this.on(doc, 'mousemove', this.handleMouseMove);\n    this.on(doc, 'mouseup', this.handleMouseUp);\n    this.on(doc, 'touchmove', this.handleMouseMove);\n    this.on(doc, 'touchend', this.handleMouseUp);\n\n    this.handleMouseMove(event);\n  };\n\n  /**\n   * Handle the `mousemove`, `touchmove`, and `mousedown` events on this `Slider`.\n   * The `mousemove` and `touchmove` events will only only trigger this function during\n   * `mousedown` and `touchstart`. This is due to {@link Slider#handleMouseDown} and\n   * {@link Slider#handleMouseUp}.\n   *\n   * @param {EventTarget~Event} event\n   *        `mousedown`, `mousemove`, `touchstart`, or `touchmove` event that triggered\n   *        this function\n   *\n   * @listens mousemove\n   * @listens touchmove\n   */\n\n\n  Slider.prototype.handleMouseMove = function handleMouseMove(event) {};\n\n  /**\n   * Handle `mouseup` or `touchend` events on the `Slider`.\n   *\n   * @param {EventTarget~Event} event\n   *        `mouseup` or `touchend` event that triggered this function.\n   *\n   * @listens touchend\n   * @listens mouseup\n   * @fires Slider#sliderinactive\n   */\n\n\n  Slider.prototype.handleMouseUp = function handleMouseUp() {\n    var doc = this.bar.el_.ownerDocument;\n\n    unblockTextSelection();\n\n    this.removeClass('vjs-sliding');\n    /**\n     * Triggered when the slider is no longer in an active state.\n     *\n     * @event Slider#sliderinactive\n     * @type {EventTarget~Event}\n     */\n    this.trigger('sliderinactive');\n\n    this.off(doc, 'mousemove', this.handleMouseMove);\n    this.off(doc, 'mouseup', this.handleMouseUp);\n    this.off(doc, 'touchmove', this.handleMouseMove);\n    this.off(doc, 'touchend', this.handleMouseUp);\n\n    this.update();\n  };\n\n  /**\n   * Update the progress bar of the `Slider`.\n   *\n   * @returns {number}\n   *          The percentage of progress the progress bar represents as a\n   *          number from 0 to 1.\n   */\n\n\n  Slider.prototype.update = function update() {\n\n    // In VolumeBar init we have a setTimeout for update that pops and update\n    // to the end of the execution stack. The player is destroyed before then\n    // update will cause an error\n    if (!this.el_) {\n      return;\n    }\n\n    // If scrubbing, we could use a cached value to make the handle keep up\n    // with the user's mouse. On HTML5 browsers scrubbing is really smooth, but\n    // some flash players are slow, so we might want to utilize this later.\n    // var progress =  (this.player_.scrubbing()) ? this.player_.getCache().currentTime / this.player_.duration() : this.player_.currentTime() / this.player_.duration();\n    var progress = this.getPercent();\n    var bar = this.bar;\n\n    // If there's no bar...\n    if (!bar) {\n      return;\n    }\n\n    // Protect against no duration and other division issues\n    if (typeof progress !== 'number' || progress !== progress || progress < 0 || progress === Infinity) {\n      progress = 0;\n    }\n\n    // Convert to a percentage for setting\n    var percentage = (progress * 100).toFixed(2) + '%';\n    var style = bar.el().style;\n\n    // Set the new bar width or height\n    if (this.vertical()) {\n      style.height = percentage;\n    } else {\n      style.width = percentage;\n    }\n\n    return progress;\n  };\n\n  /**\n   * Calculate distance for slider\n   *\n   * @param {EventTarget~Event} event\n   *        The event that caused this function to run.\n   *\n   * @return {number}\n   *         The current position of the Slider.\n   *         - postition.x for vertical `Slider`s\n   *         - postition.y for horizontal `Slider`s\n   */\n\n\n  Slider.prototype.calculateDistance = function calculateDistance(event) {\n    var position = getPointerPosition(this.el_, event);\n\n    if (this.vertical()) {\n      return position.y;\n    }\n    return position.x;\n  };\n\n  /**\n   * Handle a `focus` event on this `Slider`.\n   *\n   * @param {EventTarget~Event} event\n   *        The `focus` event that caused this function to run.\n   *\n   * @listens focus\n   */\n\n\n  Slider.prototype.handleFocus = function handleFocus() {\n    this.on(this.bar.el_.ownerDocument, 'keydown', this.handleKeyPress);\n  };\n\n  /**\n   * Handle a `keydown` event on the `Slider`. Watches for left, rigth, up, and down\n   * arrow keys. This function will only be called when the slider has focus. See\n   * {@link Slider#handleFocus} and {@link Slider#handleBlur}.\n   *\n   * @param {EventTarget~Event} event\n   *        the `keydown` event that caused this function to run.\n   *\n   * @listens keydown\n   */\n\n\n  Slider.prototype.handleKeyPress = function handleKeyPress(event) {\n    // Left and Down Arrows\n    if (event.which === 37 || event.which === 40) {\n      event.preventDefault();\n      this.stepBack();\n\n      // Up and Right Arrows\n    } else if (event.which === 38 || event.which === 39) {\n      event.preventDefault();\n      this.stepForward();\n    }\n  };\n\n  /**\n   * Handle a `blur` event on this `Slider`.\n   *\n   * @param {EventTarget~Event} event\n   *        The `blur` event that caused this function to run.\n   *\n   * @listens blur\n   */\n\n  Slider.prototype.handleBlur = function handleBlur() {\n    this.off(this.bar.el_.ownerDocument, 'keydown', this.handleKeyPress);\n  };\n\n  /**\n   * Listener for click events on slider, used to prevent clicks\n   *   from bubbling up to parent elements like button menus.\n   *\n   * @param {Object} event\n   *        Event that caused this object to run\n   */\n\n\n  Slider.prototype.handleClick = function handleClick(event) {\n    event.stopImmediatePropagation();\n    event.preventDefault();\n  };\n\n  /**\n   * Get/set if slider is horizontal for vertical\n   *\n   * @param {boolean} [bool]\n   *        - true if slider is vertical,\n   *        - false is horizontal\n   *\n   * @return {boolean}\n   *         - true if slider is vertical, and getting\n   *         - false if the slider is horizontal, and getting\n   */\n\n\n  Slider.prototype.vertical = function vertical(bool) {\n    if (bool === undefined) {\n      return this.vertical_ || false;\n    }\n\n    this.vertical_ = !!bool;\n\n    if (this.vertical_) {\n      this.addClass('vjs-slider-vertical');\n    } else {\n      this.addClass('vjs-slider-horizontal');\n    }\n  };\n\n  return Slider;\n}(Component);\n\nComponent.registerComponent('Slider', Slider);\n\n/**\n * @file load-progress-bar.js\n */\n/**\n * Shows loading progress\n *\n * @extends Component\n */\n\nvar LoadProgressBar = function (_Component) {\n  inherits(LoadProgressBar, _Component);\n\n  /**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   */\n  function LoadProgressBar(player, options) {\n    classCallCheck(this, LoadProgressBar);\n\n    var _this = possibleConstructorReturn(this, _Component.call(this, player, options));\n\n    _this.partEls_ = [];\n    _this.on(player, 'progress', _this.update);\n    return _this;\n  }\n\n  /**\n   * Create the `Component`'s DOM element\n   *\n   * @return {Element}\n   *         The element that was created.\n   */\n\n\n  LoadProgressBar.prototype.createEl = function createEl$$1() {\n    return _Component.prototype.createEl.call(this, 'div', {\n      className: 'vjs-load-progress',\n      innerHTML: '<span class=\"vjs-control-text\"><span>' + this.localize('Loaded') + '</span>: 0%</span>'\n    });\n  };\n\n  LoadProgressBar.prototype.dispose = function dispose() {\n    this.partEls_ = null;\n\n    _Component.prototype.dispose.call(this);\n  };\n\n  /**\n   * Update progress bar\n   *\n   * @param {EventTarget~Event} [event]\n   *        The `progress` event that caused this function to run.\n   *\n   * @listens Player#progress\n   */\n\n\n  LoadProgressBar.prototype.update = function update(event) {\n    var buffered = this.player_.buffered();\n    var duration = this.player_.duration();\n    var bufferedEnd = this.player_.bufferedEnd();\n    var children = this.partEls_;\n\n    // get the percent width of a time compared to the total end\n    var percentify = function percentify(time, end) {\n      // no NaN\n      var percent = time / end || 0;\n\n      return (percent >= 1 ? 1 : percent) * 100 + '%';\n    };\n\n    // update the width of the progress bar\n    this.el_.style.width = percentify(bufferedEnd, duration);\n\n    // add child elements to represent the individual buffered time ranges\n    for (var i = 0; i < buffered.length; i++) {\n      var start = buffered.start(i);\n      var end = buffered.end(i);\n      var part = children[i];\n\n      if (!part) {\n        part = this.el_.appendChild(createEl());\n        children[i] = part;\n      }\n\n      // set the percent based on the width of the progress bar (bufferedEnd)\n      part.style.left = percentify(start, bufferedEnd);\n      part.style.width = percentify(end - start, bufferedEnd);\n    }\n\n    // remove unused buffered range elements\n    for (var _i = children.length; _i > buffered.length; _i--) {\n      this.el_.removeChild(children[_i - 1]);\n    }\n    children.length = buffered.length;\n  };\n\n  return LoadProgressBar;\n}(Component);\n\nComponent.registerComponent('LoadProgressBar', LoadProgressBar);\n\n/**\n * @file time-tooltip.js\n */\n/**\n * Time tooltips display a time above the progress bar.\n *\n * @extends Component\n */\n\nvar TimeTooltip = function (_Component) {\n  inherits(TimeTooltip, _Component);\n\n  function TimeTooltip() {\n    classCallCheck(this, TimeTooltip);\n    return possibleConstructorReturn(this, _Component.apply(this, arguments));\n  }\n\n  /**\n   * Create the time tooltip DOM element\n   *\n   * @return {Element}\n   *         The element that was created.\n   */\n  TimeTooltip.prototype.createEl = function createEl$$1() {\n    return _Component.prototype.createEl.call(this, 'div', {\n      className: 'vjs-time-tooltip'\n    });\n  };\n\n  /**\n   * Updates the position of the time tooltip relative to the `SeekBar`.\n   *\n   * @param {Object} seekBarRect\n   *        The `ClientRect` for the {@link SeekBar} element.\n   *\n   * @param {number} seekBarPoint\n   *        A number from 0 to 1, representing a horizontal reference point\n   *        from the left edge of the {@link SeekBar}\n   */\n\n\n  TimeTooltip.prototype.update = function update(seekBarRect, seekBarPoint, content) {\n    var tooltipRect = getBoundingClientRect(this.el_);\n    var playerRect = getBoundingClientRect(this.player_.el());\n    var seekBarPointPx = seekBarRect.width * seekBarPoint;\n\n    // do nothing if either rect isn't available\n    // for example, if the player isn't in the DOM for testing\n    if (!playerRect || !tooltipRect) {\n      return;\n    }\n\n    // This is the space left of the `seekBarPoint` available within the bounds\n    // of the player. We calculate any gap between the left edge of the player\n    // and the left edge of the `SeekBar` and add the number of pixels in the\n    // `SeekBar` before hitting the `seekBarPoint`\n    var spaceLeftOfPoint = seekBarRect.left - playerRect.left + seekBarPointPx;\n\n    // This is the space right of the `seekBarPoint` available within the bounds\n    // of the player. We calculate the number of pixels from the `seekBarPoint`\n    // to the right edge of the `SeekBar` and add to that any gap between the\n    // right edge of the `SeekBar` and the player.\n    var spaceRightOfPoint = seekBarRect.width - seekBarPointPx + (playerRect.right - seekBarRect.right);\n\n    // This is the number of pixels by which the tooltip will need to be pulled\n    // further to the right to center it over the `seekBarPoint`.\n    var pullTooltipBy = tooltipRect.width / 2;\n\n    // Adjust the `pullTooltipBy` distance to the left or right depending on\n    // the results of the space calculations above.\n    if (spaceLeftOfPoint < pullTooltipBy) {\n      pullTooltipBy += pullTooltipBy - spaceLeftOfPoint;\n    } else if (spaceRightOfPoint < pullTooltipBy) {\n      pullTooltipBy = spaceRightOfPoint;\n    }\n\n    // Due to the imprecision of decimal/ratio based calculations and varying\n    // rounding behaviors, there are cases where the spacing adjustment is off\n    // by a pixel or two. This adds insurance to these calculations.\n    if (pullTooltipBy < 0) {\n      pullTooltipBy = 0;\n    } else if (pullTooltipBy > tooltipRect.width) {\n      pullTooltipBy = tooltipRect.width;\n    }\n\n    this.el_.style.right = '-' + pullTooltipBy + 'px';\n    textContent(this.el_, content);\n  };\n\n  return TimeTooltip;\n}(Component);\n\nComponent.registerComponent('TimeTooltip', TimeTooltip);\n\n/**\n * @file play-progress-bar.js\n */\n/**\n * Used by {@link SeekBar} to display media playback progress as part of the\n * {@link ProgressControl}.\n *\n * @extends Component\n */\n\nvar PlayProgressBar = function (_Component) {\n  inherits(PlayProgressBar, _Component);\n\n  function PlayProgressBar() {\n    classCallCheck(this, PlayProgressBar);\n    return possibleConstructorReturn(this, _Component.apply(this, arguments));\n  }\n\n  /**\n   * Create the the DOM element for this class.\n   *\n   * @return {Element}\n   *         The element that was created.\n   */\n  PlayProgressBar.prototype.createEl = function createEl() {\n    return _Component.prototype.createEl.call(this, 'div', {\n      className: 'vjs-play-progress vjs-slider-bar',\n      innerHTML: '<span class=\"vjs-control-text\"><span>' + this.localize('Progress') + '</span>: 0%</span>'\n    });\n  };\n\n  /**\n   * Enqueues updates to its own DOM as well as the DOM of its\n   * {@link TimeTooltip} child.\n   *\n   * @param {Object} seekBarRect\n   *        The `ClientRect` for the {@link SeekBar} element.\n   *\n   * @param {number} seekBarPoint\n   *        A number from 0 to 1, representing a horizontal reference point\n   *        from the left edge of the {@link SeekBar}\n   */\n\n\n  PlayProgressBar.prototype.update = function update(seekBarRect, seekBarPoint) {\n    var _this2 = this;\n\n    // If there is an existing rAF ID, cancel it so we don't over-queue.\n    if (this.rafId_) {\n      this.cancelAnimationFrame(this.rafId_);\n    }\n\n    this.rafId_ = this.requestAnimationFrame(function () {\n      var time = _this2.player_.scrubbing() ? _this2.player_.getCache().currentTime : _this2.player_.currentTime();\n\n      var content = formatTime(time, _this2.player_.duration());\n      var timeTooltip = _this2.getChild('timeTooltip');\n\n      if (timeTooltip) {\n        timeTooltip.update(seekBarRect, seekBarPoint, content);\n      }\n    });\n  };\n\n  return PlayProgressBar;\n}(Component);\n\n/**\n * Default options for {@link PlayProgressBar}.\n *\n * @type {Object}\n * @private\n */\n\n\nPlayProgressBar.prototype.options_ = {\n  children: []\n};\n\n// Time tooltips should not be added to a player on mobile devices or IE8\nif ((!IE_VERSION || IE_VERSION > 8) && !IS_IOS && !IS_ANDROID) {\n  PlayProgressBar.prototype.options_.children.push('timeTooltip');\n}\n\nComponent.registerComponent('PlayProgressBar', PlayProgressBar);\n\n/**\n * @file mouse-time-display.js\n */\n/**\n * The {@link MouseTimeDisplay} component tracks mouse movement over the\n * {@link ProgressControl}. It displays an indicator and a {@link TimeTooltip}\n * indicating the time which is represented by a given point in the\n * {@link ProgressControl}.\n *\n * @extends Component\n */\n\nvar MouseTimeDisplay = function (_Component) {\n  inherits(MouseTimeDisplay, _Component);\n\n  /**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The {@link Player} that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   */\n  function MouseTimeDisplay(player, options) {\n    classCallCheck(this, MouseTimeDisplay);\n\n    var _this = possibleConstructorReturn(this, _Component.call(this, player, options));\n\n    _this.update = throttle(bind(_this, _this.update), 25);\n    return _this;\n  }\n\n  /**\n   * Create the DOM element for this class.\n   *\n   * @return {Element}\n   *         The element that was created.\n   */\n\n\n  MouseTimeDisplay.prototype.createEl = function createEl() {\n    return _Component.prototype.createEl.call(this, 'div', {\n      className: 'vjs-mouse-display'\n    });\n  };\n\n  /**\n   * Enqueues updates to its own DOM as well as the DOM of its\n   * {@link TimeTooltip} child.\n   *\n   * @param {Object} seekBarRect\n   *        The `ClientRect` for the {@link SeekBar} element.\n   *\n   * @param {number} seekBarPoint\n   *        A number from 0 to 1, representing a horizontal reference point\n   *        from the left edge of the {@link SeekBar}\n   */\n\n\n  MouseTimeDisplay.prototype.update = function update(seekBarRect, seekBarPoint) {\n    var _this2 = this;\n\n    // If there is an existing rAF ID, cancel it so we don't over-queue.\n    if (this.rafId_) {\n      this.cancelAnimationFrame(this.rafId_);\n    }\n\n    this.rafId_ = this.requestAnimationFrame(function () {\n      var duration = _this2.player_.duration();\n      var content = formatTime(seekBarPoint * duration, duration);\n\n      _this2.el_.style.left = seekBarRect.width * seekBarPoint + 'px';\n      _this2.getChild('timeTooltip').update(seekBarRect, seekBarPoint, content);\n    });\n  };\n\n  return MouseTimeDisplay;\n}(Component);\n\n/**\n * Default options for `MouseTimeDisplay`\n *\n * @type {Object}\n * @private\n */\n\n\nMouseTimeDisplay.prototype.options_ = {\n  children: ['timeTooltip']\n};\n\nComponent.registerComponent('MouseTimeDisplay', MouseTimeDisplay);\n\n/**\n * @file seek-bar.js\n */\n// The number of seconds the `step*` functions move the timeline.\nvar STEP_SECONDS = 5;\n\n// The interval at which the bar should update as it progresses.\nvar UPDATE_REFRESH_INTERVAL = 30;\n\n/**\n * Seek bar and container for the progress bars. Uses {@link PlayProgressBar}\n * as its `bar`.\n *\n * @extends Slider\n */\n\nvar SeekBar = function (_Slider) {\n  inherits(SeekBar, _Slider);\n\n  /**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   */\n  function SeekBar(player, options) {\n    classCallCheck(this, SeekBar);\n\n    var _this = possibleConstructorReturn(this, _Slider.call(this, player, options));\n\n    _this.setEventHandlers_();\n    return _this;\n  }\n\n  /**\n   * Sets the event handlers\n   *\n   * @private\n   */\n\n\n  SeekBar.prototype.setEventHandlers_ = function setEventHandlers_() {\n    var _this2 = this;\n\n    this.update = throttle(bind(this, this.update), UPDATE_REFRESH_INTERVAL);\n\n    this.on(this.player_, 'timeupdate', this.update);\n    this.on(this.player_, 'ended', this.handleEnded);\n\n    // when playing, let's ensure we smoothly update the play progress bar\n    // via an interval\n    this.updateInterval = null;\n\n    this.on(this.player_, ['playing'], function () {\n      _this2.clearInterval(_this2.updateInterval);\n\n      _this2.updateInterval = _this2.setInterval(function () {\n        _this2.requestAnimationFrame(function () {\n          _this2.update();\n        });\n      }, UPDATE_REFRESH_INTERVAL);\n    });\n\n    this.on(this.player_, ['ended', 'pause', 'waiting'], function () {\n      _this2.clearInterval(_this2.updateInterval);\n    });\n\n    this.on(this.player_, ['timeupdate', 'ended'], this.update);\n  };\n\n  /**\n   * Create the `Component`'s DOM element\n   *\n   * @return {Element}\n   *         The element that was created.\n   */\n\n\n  SeekBar.prototype.createEl = function createEl$$1() {\n    return _Slider.prototype.createEl.call(this, 'div', {\n      className: 'vjs-progress-holder'\n    }, {\n      'aria-label': this.localize('Progress Bar')\n    });\n  };\n\n  /**\n   * This function updates the play progress bar and accessiblity\n   * attributes to whatever is passed in.\n   *\n   * @param {number} currentTime\n   *        The currentTime value that should be used for accessiblity\n   *\n   * @param {number} percent\n   *        The percentage as a decimal that the bar should be filled from 0-1.\n   *\n   * @private\n   */\n\n\n  SeekBar.prototype.update_ = function update_(currentTime, percent) {\n    var duration = this.player_.duration();\n\n    // machine readable value of progress bar (percentage complete)\n    this.el_.setAttribute('aria-valuenow', (percent * 100).toFixed(2));\n\n    // human readable value of progress bar (time complete)\n    this.el_.setAttribute('aria-valuetext', this.localize('progress bar timing: currentTime={1} duration={2}', [formatTime(currentTime, duration), formatTime(duration, duration)], '{1} of {2}'));\n\n    // Update the `PlayProgressBar`.\n    this.bar.update(getBoundingClientRect(this.el_), percent);\n  };\n\n  /**\n   * Update the seek bar's UI.\n   *\n   * @param {EventTarget~Event} [event]\n   *        The `timeupdate` or `ended` event that caused this to run.\n   *\n   * @listens Player#timeupdate\n   *\n   * @returns {number}\n   *          The current percent at a number from 0-1\n   */\n\n\n  SeekBar.prototype.update = function update(event) {\n    var percent = _Slider.prototype.update.call(this);\n\n    this.update_(this.getCurrentTime_(), percent);\n    return percent;\n  };\n\n  /**\n   * Get the value of current time but allows for smooth scrubbing,\n   * when player can't keep up.\n   *\n   * @return {number}\n   *         The current time value to display\n   *\n   * @private\n   */\n\n\n  SeekBar.prototype.getCurrentTime_ = function getCurrentTime_() {\n    return this.player_.scrubbing() ? this.player_.getCache().currentTime : this.player_.currentTime();\n  };\n\n  /**\n   * We want the seek bar to be full on ended\n   * no matter what the actual internal values are. so we force it.\n   *\n   * @param {EventTarget~Event} [event]\n   *        The `timeupdate` or `ended` event that caused this to run.\n   *\n   * @listens Player#ended\n   */\n\n\n  SeekBar.prototype.handleEnded = function handleEnded(event) {\n    this.update_(this.player_.duration(), 1);\n  };\n\n  /**\n   * Get the percentage of media played so far.\n   *\n   * @return {number}\n   *         The percentage of media played so far (0 to 1).\n   */\n\n\n  SeekBar.prototype.getPercent = function getPercent() {\n    var percent = this.getCurrentTime_() / this.player_.duration();\n\n    return percent >= 1 ? 1 : percent;\n  };\n\n  /**\n   * Handle mouse down on seek bar\n   *\n   * @param {EventTarget~Event} event\n   *        The `mousedown` event that caused this to run.\n   *\n   * @listens mousedown\n   */\n\n\n  SeekBar.prototype.handleMouseDown = function handleMouseDown(event) {\n    if (!isSingleLeftClick(event)) {\n      return;\n    }\n\n    // Stop event propagation to prevent double fire in progress-control.js\n    event.stopPropagation();\n    this.player_.scrubbing(true);\n\n    this.videoWasPlaying = !this.player_.paused();\n    this.player_.pause();\n\n    _Slider.prototype.handleMouseDown.call(this, event);\n  };\n\n  /**\n   * Handle mouse move on seek bar\n   *\n   * @param {EventTarget~Event} event\n   *        The `mousemove` event that caused this to run.\n   *\n   * @listens mousemove\n   */\n\n\n  SeekBar.prototype.handleMouseMove = function handleMouseMove(event) {\n    if (!isSingleLeftClick(event)) {\n      return;\n    }\n\n    var newTime = this.calculateDistance(event) * this.player_.duration();\n\n    // Don't let video end while scrubbing.\n    if (newTime === this.player_.duration()) {\n      newTime = newTime - 0.1;\n    }\n\n    // Set new time (tell player to seek to new time)\n    this.player_.currentTime(newTime);\n  };\n\n  SeekBar.prototype.enable = function enable() {\n    _Slider.prototype.enable.call(this);\n    var mouseTimeDisplay = this.getChild('mouseTimeDisplay');\n\n    if (!mouseTimeDisplay) {\n      return;\n    }\n\n    mouseTimeDisplay.show();\n  };\n\n  SeekBar.prototype.disable = function disable() {\n    _Slider.prototype.disable.call(this);\n    var mouseTimeDisplay = this.getChild('mouseTimeDisplay');\n\n    if (!mouseTimeDisplay) {\n      return;\n    }\n\n    mouseTimeDisplay.hide();\n  };\n\n  /**\n   * Handle mouse up on seek bar\n   *\n   * @param {EventTarget~Event} event\n   *        The `mouseup` event that caused this to run.\n   *\n   * @listens mouseup\n   */\n\n\n  SeekBar.prototype.handleMouseUp = function handleMouseUp(event) {\n    _Slider.prototype.handleMouseUp.call(this, event);\n\n    // Stop event propagation to prevent double fire in progress-control.js\n    if (event) {\n      event.stopPropagation();\n    }\n    this.player_.scrubbing(false);\n\n    /**\n     * Trigger timeupdate because we're done seeking and the time has changed.\n     * This is particularly useful for if the player is paused to time the time displays.\n     *\n     * @event Tech#timeupdate\n     * @type {EventTarget~Event}\n     */\n    this.player_.trigger({ type: 'timeupdate', target: this, manuallyTriggered: true });\n    if (this.videoWasPlaying) {\n      silencePromise(this.player_.play());\n    }\n  };\n\n  /**\n   * Move more quickly fast forward for keyboard-only users\n   */\n\n\n  SeekBar.prototype.stepForward = function stepForward() {\n    this.player_.currentTime(this.player_.currentTime() + STEP_SECONDS);\n  };\n\n  /**\n   * Move more quickly rewind for keyboard-only users\n   */\n\n\n  SeekBar.prototype.stepBack = function stepBack() {\n    this.player_.currentTime(this.player_.currentTime() - STEP_SECONDS);\n  };\n\n  /**\n   * Toggles the playback state of the player\n   * This gets called when enter or space is used on the seekbar\n   *\n   * @param {EventTarget~Event} event\n   *        The `keydown` event that caused this function to be called\n   *\n   */\n\n\n  SeekBar.prototype.handleAction = function handleAction(event) {\n    if (this.player_.paused()) {\n      this.player_.play();\n    } else {\n      this.player_.pause();\n    }\n  };\n\n  /**\n   * Called when this SeekBar has focus and a key gets pressed down. By\n   * default it will call `this.handleAction` when the key is space or enter.\n   *\n   * @param {EventTarget~Event} event\n   *        The `keydown` event that caused this function to be called.\n   *\n   * @listens keydown\n   */\n\n\n  SeekBar.prototype.handleKeyPress = function handleKeyPress(event) {\n\n    // Support Space (32) or Enter (13) key operation to fire a click event\n    if (event.which === 32 || event.which === 13) {\n      event.preventDefault();\n      this.handleAction(event);\n    } else if (_Slider.prototype.handleKeyPress) {\n\n      // Pass keypress handling up for unsupported keys\n      _Slider.prototype.handleKeyPress.call(this, event);\n    }\n  };\n\n  return SeekBar;\n}(Slider);\n\n/**\n * Default options for the `SeekBar`\n *\n * @type {Object}\n * @private\n */\n\n\nSeekBar.prototype.options_ = {\n  children: ['loadProgressBar', 'playProgressBar'],\n  barName: 'playProgressBar'\n};\n\n// MouseTimeDisplay tooltips should not be added to a player on mobile devices or IE8\nif ((!IE_VERSION || IE_VERSION > 8) && !IS_IOS && !IS_ANDROID) {\n  SeekBar.prototype.options_.children.splice(1, 0, 'mouseTimeDisplay');\n}\n\n/**\n * Call the update event for this Slider when this event happens on the player.\n *\n * @type {string}\n */\nSeekBar.prototype.playerEvent = 'timeupdate';\n\nComponent.registerComponent('SeekBar', SeekBar);\n\n/**\n * @file progress-control.js\n */\n/**\n * The Progress Control component contains the seek bar, load progress,\n * and play progress.\n *\n * @extends Component\n */\n\nvar ProgressControl = function (_Component) {\n  inherits(ProgressControl, _Component);\n\n  /**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   */\n  function ProgressControl(player, options) {\n    classCallCheck(this, ProgressControl);\n\n    var _this = possibleConstructorReturn(this, _Component.call(this, player, options));\n\n    _this.handleMouseMove = throttle(bind(_this, _this.handleMouseMove), 25);\n    _this.throttledHandleMouseSeek = throttle(bind(_this, _this.handleMouseSeek), 25);\n\n    _this.enable();\n    return _this;\n  }\n\n  /**\n   * Create the `Component`'s DOM element\n   *\n   * @return {Element}\n   *         The element that was created.\n   */\n\n\n  ProgressControl.prototype.createEl = function createEl$$1() {\n    return _Component.prototype.createEl.call(this, 'div', {\n      className: 'vjs-progress-control vjs-control'\n    });\n  };\n\n  /**\n   * When the mouse moves over the `ProgressControl`, the pointer position\n   * gets passed down to the `MouseTimeDisplay` component.\n   *\n   * @param {EventTarget~Event} event\n   *        The `mousemove` event that caused this function to run.\n   *\n   * @listen mousemove\n   */\n\n\n  ProgressControl.prototype.handleMouseMove = function handleMouseMove(event) {\n    var seekBar = this.getChild('seekBar');\n\n    if (seekBar) {\n      var mouseTimeDisplay = seekBar.getChild('mouseTimeDisplay');\n      var seekBarEl = seekBar.el();\n      var seekBarRect = getBoundingClientRect(seekBarEl);\n      var seekBarPoint = getPointerPosition(seekBarEl, event).x;\n\n      // The default skin has a gap on either side of the `SeekBar`. This means\n      // that it's possible to trigger this behavior outside the boundaries of\n      // the `SeekBar`. This ensures we stay within it at all times.\n      if (seekBarPoint > 1) {\n        seekBarPoint = 1;\n      } else if (seekBarPoint < 0) {\n        seekBarPoint = 0;\n      }\n\n      if (mouseTimeDisplay) {\n        mouseTimeDisplay.update(seekBarRect, seekBarPoint);\n      }\n    }\n  };\n\n  /**\n   * A throttled version of the {@link ProgressControl#handleMouseSeek} listener.\n   *\n   * @method ProgressControl#throttledHandleMouseSeek\n   * @param {EventTarget~Event} event\n   *        The `mousemove` event that caused this function to run.\n   *\n   * @listen mousemove\n   * @listen touchmove\n   */\n\n  /**\n   * Handle `mousemove` or `touchmove` events on the `ProgressControl`.\n   *\n   * @param {EventTarget~Event} event\n   *        `mousedown` or `touchstart` event that triggered this function\n   *\n   * @listens mousemove\n   * @listens touchmove\n   */\n\n\n  ProgressControl.prototype.handleMouseSeek = function handleMouseSeek(event) {\n    var seekBar = this.getChild('seekBar');\n\n    if (seekBar) {\n      seekBar.handleMouseMove(event);\n    }\n  };\n\n  /**\n   * Are controls are currently enabled for this progress control.\n   *\n   * @return {boolean}\n   *         true if controls are enabled, false otherwise\n   */\n\n\n  ProgressControl.prototype.enabled = function enabled() {\n    return this.enabled_;\n  };\n\n  /**\n   * Disable all controls on the progress control and its children\n   */\n\n\n  ProgressControl.prototype.disable = function disable() {\n    this.children().forEach(function (child) {\n      return child.disable && child.disable();\n    });\n\n    if (!this.enabled()) {\n      return;\n    }\n\n    this.off(['mousedown', 'touchstart'], this.handleMouseDown);\n    this.off(this.el_, 'mousemove', this.handleMouseMove);\n    this.handleMouseUp();\n\n    this.addClass('disabled');\n\n    this.enabled_ = false;\n  };\n\n  /**\n   * Enable all controls on the progress control and its children\n   */\n\n\n  ProgressControl.prototype.enable = function enable() {\n    this.children().forEach(function (child) {\n      return child.enable && child.enable();\n    });\n\n    if (this.enabled()) {\n      return;\n    }\n\n    this.on(['mousedown', 'touchstart'], this.handleMouseDown);\n    this.on(this.el_, 'mousemove', this.handleMouseMove);\n    this.removeClass('disabled');\n\n    this.enabled_ = true;\n  };\n\n  /**\n   * Handle `mousedown` or `touchstart` events on the `ProgressControl`.\n   *\n   * @param {EventTarget~Event} event\n   *        `mousedown` or `touchstart` event that triggered this function\n   *\n   * @listens mousedown\n   * @listens touchstart\n   */\n\n\n  ProgressControl.prototype.handleMouseDown = function handleMouseDown(event) {\n    var doc = this.el_.ownerDocument;\n    var seekBar = this.getChild('seekBar');\n\n    if (seekBar) {\n      seekBar.handleMouseDown(event);\n    }\n\n    this.on(doc, 'mousemove', this.throttledHandleMouseSeek);\n    this.on(doc, 'touchmove', this.throttledHandleMouseSeek);\n    this.on(doc, 'mouseup', this.handleMouseUp);\n    this.on(doc, 'touchend', this.handleMouseUp);\n  };\n\n  /**\n   * Handle `mouseup` or `touchend` events on the `ProgressControl`.\n   *\n   * @param {EventTarget~Event} event\n   *        `mouseup` or `touchend` event that triggered this function.\n   *\n   * @listens touchend\n   * @listens mouseup\n   */\n\n\n  ProgressControl.prototype.handleMouseUp = function handleMouseUp(event) {\n    var doc = this.el_.ownerDocument;\n    var seekBar = this.getChild('seekBar');\n\n    if (seekBar) {\n      seekBar.handleMouseUp(event);\n    }\n\n    this.off(doc, 'mousemove', this.throttledHandleMouseSeek);\n    this.off(doc, 'touchmove', this.throttledHandleMouseSeek);\n    this.off(doc, 'mouseup', this.handleMouseUp);\n    this.off(doc, 'touchend', this.handleMouseUp);\n  };\n\n  return ProgressControl;\n}(Component);\n\n/**\n * Default options for `ProgressControl`\n *\n * @type {Object}\n * @private\n */\n\n\nProgressControl.prototype.options_ = {\n  children: ['seekBar']\n};\n\nComponent.registerComponent('ProgressControl', ProgressControl);\n\n/**\n * @file fullscreen-toggle.js\n */\n/**\n * Toggle fullscreen video\n *\n * @extends Button\n */\n\nvar FullscreenToggle = function (_Button) {\n  inherits(FullscreenToggle, _Button);\n\n  /**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   */\n  function FullscreenToggle(player, options) {\n    classCallCheck(this, FullscreenToggle);\n\n    var _this = possibleConstructorReturn(this, _Button.call(this, player, options));\n\n    _this.on(player, 'fullscreenchange', _this.handleFullscreenChange);\n\n    if (document[FullscreenApi.fullscreenEnabled] === false) {\n      _this.disable();\n    }\n    return _this;\n  }\n\n  /**\n   * Builds the default DOM `className`.\n   *\n   * @return {string}\n   *         The DOM `className` for this object.\n   */\n\n\n  FullscreenToggle.prototype.buildCSSClass = function buildCSSClass() {\n    return 'vjs-fullscreen-control ' + _Button.prototype.buildCSSClass.call(this);\n  };\n\n  /**\n   * Handles fullscreenchange on the player and change control text accordingly.\n   *\n   * @param {EventTarget~Event} [event]\n   *        The {@link Player#fullscreenchange} event that caused this function to be\n   *        called.\n   *\n   * @listens Player#fullscreenchange\n   */\n\n\n  FullscreenToggle.prototype.handleFullscreenChange = function handleFullscreenChange(event) {\n    if (this.player_.isFullscreen()) {\n      this.controlText('Non-Fullscreen');\n    } else {\n      this.controlText('Fullscreen');\n    }\n  };\n\n  /**\n   * This gets called when an `FullscreenToggle` is \"clicked\". See\n   * {@link ClickableComponent} for more detailed information on what a click can be.\n   *\n   * @param {EventTarget~Event} [event]\n   *        The `keydown`, `tap`, or `click` event that caused this function to be\n   *        called.\n   *\n   * @listens tap\n   * @listens click\n   */\n\n\n  FullscreenToggle.prototype.handleClick = function handleClick(event) {\n    if (!this.player_.isFullscreen()) {\n      this.player_.requestFullscreen();\n    } else {\n      this.player_.exitFullscreen();\n    }\n  };\n\n  return FullscreenToggle;\n}(Button);\n\n/**\n * The text that should display over the `FullscreenToggle`s controls. Added for localization.\n *\n * @type {string}\n * @private\n */\n\n\nFullscreenToggle.prototype.controlText_ = 'Fullscreen';\n\nComponent.registerComponent('FullscreenToggle', FullscreenToggle);\n\n/**\n * Check if volume control is supported and if it isn't hide the\n * `Component` that was passed  using the `vjs-hidden` class.\n *\n * @param {Component} self\n *        The component that should be hidden if volume is unsupported\n *\n * @param {Player} player\n *        A reference to the player\n *\n * @private\n */\nvar checkVolumeSupport = function checkVolumeSupport(self, player) {\n  // hide volume controls when they're not supported by the current tech\n  if (player.tech_ && !player.tech_.featuresVolumeControl) {\n    self.addClass('vjs-hidden');\n  }\n\n  self.on(player, 'loadstart', function () {\n    if (!player.tech_.featuresVolumeControl) {\n      self.addClass('vjs-hidden');\n    } else {\n      self.removeClass('vjs-hidden');\n    }\n  });\n};\n\n/**\n * @file volume-level.js\n */\n/**\n * Shows volume level\n *\n * @extends Component\n */\n\nvar VolumeLevel = function (_Component) {\n  inherits(VolumeLevel, _Component);\n\n  function VolumeLevel() {\n    classCallCheck(this, VolumeLevel);\n    return possibleConstructorReturn(this, _Component.apply(this, arguments));\n  }\n\n  /**\n   * Create the `Component`'s DOM element\n   *\n   * @return {Element}\n   *         The element that was created.\n   */\n  VolumeLevel.prototype.createEl = function createEl() {\n    return _Component.prototype.createEl.call(this, 'div', {\n      className: 'vjs-volume-level',\n      innerHTML: '<span class=\"vjs-control-text\"></span>'\n    });\n  };\n\n  return VolumeLevel;\n}(Component);\n\nComponent.registerComponent('VolumeLevel', VolumeLevel);\n\n/**\n * @file volume-bar.js\n */\n// Required children\n/**\n * The bar that contains the volume level and can be clicked on to adjust the level\n *\n * @extends Slider\n */\n\nvar VolumeBar = function (_Slider) {\n  inherits(VolumeBar, _Slider);\n\n  /**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   */\n  function VolumeBar(player, options) {\n    classCallCheck(this, VolumeBar);\n\n    var _this = possibleConstructorReturn(this, _Slider.call(this, player, options));\n\n    _this.on('slideractive', _this.updateLastVolume_);\n    _this.on(player, 'volumechange', _this.updateARIAAttributes);\n    player.ready(function () {\n      return _this.updateARIAAttributes();\n    });\n    return _this;\n  }\n\n  /**\n   * Create the `Component`'s DOM element\n   *\n   * @return {Element}\n   *         The element that was created.\n   */\n\n\n  VolumeBar.prototype.createEl = function createEl$$1() {\n    return _Slider.prototype.createEl.call(this, 'div', {\n      className: 'vjs-volume-bar vjs-slider-bar'\n    }, {\n      'aria-label': this.localize('Volume Level'),\n      'aria-live': 'polite'\n    });\n  };\n\n  /**\n   * Handle mouse down on volume bar\n   *\n   * @param {EventTarget~Event} event\n   *        The `mousedown` event that caused this to run.\n   *\n   * @listens mousedown\n   */\n\n\n  VolumeBar.prototype.handleMouseDown = function handleMouseDown(event) {\n    if (!isSingleLeftClick(event)) {\n      return;\n    }\n\n    _Slider.prototype.handleMouseDown.call(this, event);\n  };\n\n  /**\n   * Handle movement events on the {@link VolumeMenuButton}.\n   *\n   * @param {EventTarget~Event} event\n   *        The event that caused this function to run.\n   *\n   * @listens mousemove\n   */\n\n\n  VolumeBar.prototype.handleMouseMove = function handleMouseMove(event) {\n    if (!isSingleLeftClick(event)) {\n      return;\n    }\n\n    this.checkMuted();\n    this.player_.volume(this.calculateDistance(event));\n  };\n\n  /**\n   * If the player is muted unmute it.\n   */\n\n\n  VolumeBar.prototype.checkMuted = function checkMuted() {\n    if (this.player_.muted()) {\n      this.player_.muted(false);\n    }\n  };\n\n  /**\n   * Get percent of volume level\n   *\n   * @return {number}\n   *         Volume level percent as a decimal number.\n   */\n\n\n  VolumeBar.prototype.getPercent = function getPercent() {\n    if (this.player_.muted()) {\n      return 0;\n    }\n    return this.player_.volume();\n  };\n\n  /**\n   * Increase volume level for keyboard users\n   */\n\n\n  VolumeBar.prototype.stepForward = function stepForward() {\n    this.checkMuted();\n    this.player_.volume(this.player_.volume() + 0.1);\n  };\n\n  /**\n   * Decrease volume level for keyboard users\n   */\n\n\n  VolumeBar.prototype.stepBack = function stepBack() {\n    this.checkMuted();\n    this.player_.volume(this.player_.volume() - 0.1);\n  };\n\n  /**\n   * Update ARIA accessibility attributes\n   *\n   * @param {EventTarget~Event} [event]\n   *        The `volumechange` event that caused this function to run.\n   *\n   * @listens Player#volumechange\n   */\n\n\n  VolumeBar.prototype.updateARIAAttributes = function updateARIAAttributes(event) {\n    var ariaValue = this.player_.muted() ? 0 : this.volumeAsPercentage_();\n\n    this.el_.setAttribute('aria-valuenow', ariaValue);\n    this.el_.setAttribute('aria-valuetext', ariaValue + '%');\n  };\n\n  /**\n   * Returns the current value of the player volume as a percentage\n   *\n   * @private\n   */\n\n\n  VolumeBar.prototype.volumeAsPercentage_ = function volumeAsPercentage_() {\n    return Math.round(this.player_.volume() * 100);\n  };\n\n  /**\n   * When user starts dragging the VolumeBar, store the volume and listen for\n   * the end of the drag. When the drag ends, if the volume was set to zero,\n   * set lastVolume to the stored volume.\n   *\n   * @listens slideractive\n   * @private\n   */\n\n\n  VolumeBar.prototype.updateLastVolume_ = function updateLastVolume_() {\n    var _this2 = this;\n\n    var volumeBeforeDrag = this.player_.volume();\n\n    this.one('sliderinactive', function () {\n      if (_this2.player_.volume() === 0) {\n        _this2.player_.lastVolume_(volumeBeforeDrag);\n      }\n    });\n  };\n\n  return VolumeBar;\n}(Slider);\n\n/**\n * Default options for the `VolumeBar`\n *\n * @type {Object}\n * @private\n */\n\n\nVolumeBar.prototype.options_ = {\n  children: ['volumeLevel'],\n  barName: 'volumeLevel'\n};\n\n/**\n * Call the update event for this Slider when this event happens on the player.\n *\n * @type {string}\n */\nVolumeBar.prototype.playerEvent = 'volumechange';\n\nComponent.registerComponent('VolumeBar', VolumeBar);\n\n/**\n * @file volume-control.js\n */\n// Required children\n/**\n * The component for controlling the volume level\n *\n * @extends Component\n */\n\nvar VolumeControl = function (_Component) {\n  inherits(VolumeControl, _Component);\n\n  /**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options={}]\n   *        The key/value store of player options.\n   */\n  function VolumeControl(player) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    classCallCheck(this, VolumeControl);\n\n    options.vertical = options.vertical || false;\n\n    // Pass the vertical option down to the VolumeBar if\n    // the VolumeBar is turned on.\n    if (typeof options.volumeBar === 'undefined' || isPlain(options.volumeBar)) {\n      options.volumeBar = options.volumeBar || {};\n      options.volumeBar.vertical = options.vertical;\n    }\n\n    // hide this control if volume support is missing\n    var _this = possibleConstructorReturn(this, _Component.call(this, player, options));\n\n    checkVolumeSupport(_this, player);\n\n    _this.throttledHandleMouseMove = throttle(bind(_this, _this.handleMouseMove), 25);\n\n    _this.on('mousedown', _this.handleMouseDown);\n    _this.on('touchstart', _this.handleMouseDown);\n\n    // while the slider is active (the mouse has been pressed down and\n    // is dragging) or in focus we do not want to hide the VolumeBar\n    _this.on(_this.volumeBar, ['focus', 'slideractive'], function () {\n      _this.volumeBar.addClass('vjs-slider-active');\n      _this.addClass('vjs-slider-active');\n      _this.trigger('slideractive');\n    });\n\n    _this.on(_this.volumeBar, ['blur', 'sliderinactive'], function () {\n      _this.volumeBar.removeClass('vjs-slider-active');\n      _this.removeClass('vjs-slider-active');\n      _this.trigger('sliderinactive');\n    });\n    return _this;\n  }\n\n  /**\n   * Create the `Component`'s DOM element\n   *\n   * @return {Element}\n   *         The element that was created.\n   */\n\n\n  VolumeControl.prototype.createEl = function createEl() {\n    var orientationClass = 'vjs-volume-horizontal';\n\n    if (this.options_.vertical) {\n      orientationClass = 'vjs-volume-vertical';\n    }\n\n    return _Component.prototype.createEl.call(this, 'div', {\n      className: 'vjs-volume-control vjs-control ' + orientationClass\n    });\n  };\n\n  /**\n   * Handle `mousedown` or `touchstart` events on the `VolumeControl`.\n   *\n   * @param {EventTarget~Event} event\n   *        `mousedown` or `touchstart` event that triggered this function\n   *\n   * @listens mousedown\n   * @listens touchstart\n   */\n\n\n  VolumeControl.prototype.handleMouseDown = function handleMouseDown(event) {\n    var doc = this.el_.ownerDocument;\n\n    this.on(doc, 'mousemove', this.throttledHandleMouseMove);\n    this.on(doc, 'touchmove', this.throttledHandleMouseMove);\n    this.on(doc, 'mouseup', this.handleMouseUp);\n    this.on(doc, 'touchend', this.handleMouseUp);\n  };\n\n  /**\n   * Handle `mouseup` or `touchend` events on the `VolumeControl`.\n   *\n   * @param {EventTarget~Event} event\n   *        `mouseup` or `touchend` event that triggered this function.\n   *\n   * @listens touchend\n   * @listens mouseup\n   */\n\n\n  VolumeControl.prototype.handleMouseUp = function handleMouseUp(event) {\n    var doc = this.el_.ownerDocument;\n\n    this.off(doc, 'mousemove', this.throttledHandleMouseMove);\n    this.off(doc, 'touchmove', this.throttledHandleMouseMove);\n    this.off(doc, 'mouseup', this.handleMouseUp);\n    this.off(doc, 'touchend', this.handleMouseUp);\n  };\n\n  /**\n   * Handle `mousedown` or `touchstart` events on the `VolumeControl`.\n   *\n   * @param {EventTarget~Event} event\n   *        `mousedown` or `touchstart` event that triggered this function\n   *\n   * @listens mousedown\n   * @listens touchstart\n   */\n\n\n  VolumeControl.prototype.handleMouseMove = function handleMouseMove(event) {\n    this.volumeBar.handleMouseMove(event);\n  };\n\n  return VolumeControl;\n}(Component);\n\n/**\n * Default options for the `VolumeControl`\n *\n * @type {Object}\n * @private\n */\n\n\nVolumeControl.prototype.options_ = {\n  children: ['volumeBar']\n};\n\nComponent.registerComponent('VolumeControl', VolumeControl);\n\n/**\n * Check if muting volume is supported and if it isn't hide the mute toggle\n * button.\n *\n * @param {Component} self\n *        A reference to the mute toggle button\n *\n * @param {Player} player\n *        A reference to the player\n *\n * @private\n */\nvar checkMuteSupport = function checkMuteSupport(self, player) {\n  // hide mute toggle button if it's not supported by the current tech\n  if (player.tech_ && !player.tech_.featuresMuteControl) {\n    self.addClass('vjs-hidden');\n  }\n\n  self.on(player, 'loadstart', function () {\n    if (!player.tech_.featuresMuteControl) {\n      self.addClass('vjs-hidden');\n    } else {\n      self.removeClass('vjs-hidden');\n    }\n  });\n};\n\n/**\n * @file mute-toggle.js\n */\n/**\n * A button component for muting the audio.\n *\n * @extends Button\n */\n\nvar MuteToggle = function (_Button) {\n  inherits(MuteToggle, _Button);\n\n  /**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   */\n  function MuteToggle(player, options) {\n    classCallCheck(this, MuteToggle);\n\n    // hide this control if volume support is missing\n    var _this = possibleConstructorReturn(this, _Button.call(this, player, options));\n\n    checkMuteSupport(_this, player);\n\n    _this.on(player, ['loadstart', 'volumechange'], _this.update);\n    return _this;\n  }\n\n  /**\n   * Builds the default DOM `className`.\n   *\n   * @return {string}\n   *         The DOM `className` for this object.\n   */\n\n\n  MuteToggle.prototype.buildCSSClass = function buildCSSClass() {\n    return 'vjs-mute-control ' + _Button.prototype.buildCSSClass.call(this);\n  };\n\n  /**\n   * This gets called when an `MuteToggle` is \"clicked\". See\n   * {@link ClickableComponent} for more detailed information on what a click can be.\n   *\n   * @param {EventTarget~Event} [event]\n   *        The `keydown`, `tap`, or `click` event that caused this function to be\n   *        called.\n   *\n   * @listens tap\n   * @listens click\n   */\n\n\n  MuteToggle.prototype.handleClick = function handleClick(event) {\n    var vol = this.player_.volume();\n    var lastVolume = this.player_.lastVolume_();\n\n    if (vol === 0) {\n      var volumeToSet = lastVolume < 0.1 ? 0.1 : lastVolume;\n\n      this.player_.volume(volumeToSet);\n      this.player_.muted(false);\n    } else {\n      this.player_.muted(this.player_.muted() ? false : true);\n    }\n  };\n\n  /**\n   * Update the `MuteToggle` button based on the state of `volume` and `muted`\n   * on the player.\n   *\n   * @param {EventTarget~Event} [event]\n   *        The {@link Player#loadstart} event if this function was called\n   *        through an event.\n   *\n   * @listens Player#loadstart\n   * @listens Player#volumechange\n   */\n\n\n  MuteToggle.prototype.update = function update(event) {\n    this.updateIcon_();\n    this.updateControlText_();\n  };\n\n  /**\n   * Update the appearance of the `MuteToggle` icon.\n   *\n   * Possible states (given `level` variable below):\n   * - 0: crossed out\n   * - 1: zero bars of volume\n   * - 2: one bar of volume\n   * - 3: two bars of volume\n   *\n   * @private\n   */\n\n\n  MuteToggle.prototype.updateIcon_ = function updateIcon_() {\n    var vol = this.player_.volume();\n    var level = 3;\n\n    // in iOS when a player is loaded with muted attribute\n    // and volume is changed with a native mute button\n    // we want to make sure muted state is updated\n    if (IS_IOS) {\n      this.player_.muted(this.player_.tech_.el_.muted);\n    }\n\n    if (vol === 0 || this.player_.muted()) {\n      level = 0;\n    } else if (vol < 0.33) {\n      level = 1;\n    } else if (vol < 0.67) {\n      level = 2;\n    }\n\n    // TODO improve muted icon classes\n    for (var i = 0; i < 4; i++) {\n      removeClass(this.el_, 'vjs-vol-' + i);\n    }\n    addClass(this.el_, 'vjs-vol-' + level);\n  };\n\n  /**\n   * If `muted` has changed on the player, update the control text\n   * (`title` attribute on `vjs-mute-control` element and content of\n   * `vjs-control-text` element).\n   *\n   * @private\n   */\n\n\n  MuteToggle.prototype.updateControlText_ = function updateControlText_() {\n    var soundOff = this.player_.muted() || this.player_.volume() === 0;\n    var text = soundOff ? 'Unmute' : 'Mute';\n\n    if (this.controlText() !== text) {\n      this.controlText(text);\n    }\n  };\n\n  return MuteToggle;\n}(Button);\n\n/**\n * The text that should display over the `MuteToggle`s controls. Added for localization.\n *\n * @type {string}\n * @private\n */\n\n\nMuteToggle.prototype.controlText_ = 'Mute';\n\nComponent.registerComponent('MuteToggle', MuteToggle);\n\n/**\n * @file volume-control.js\n */\n// Required children\n/**\n * A Component to contain the MuteToggle and VolumeControl so that\n * they can work together.\n *\n * @extends Component\n */\n\nvar VolumePanel = function (_Component) {\n  inherits(VolumePanel, _Component);\n\n  /**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options={}]\n   *        The key/value store of player options.\n   */\n  function VolumePanel(player) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    classCallCheck(this, VolumePanel);\n\n    if (typeof options.inline !== 'undefined') {\n      options.inline = options.inline;\n    } else {\n      options.inline = true;\n    }\n\n    // pass the inline option down to the VolumeControl as vertical if\n    // the VolumeControl is on.\n    if (typeof options.volumeControl === 'undefined' || isPlain(options.volumeControl)) {\n      options.volumeControl = options.volumeControl || {};\n      options.volumeControl.vertical = !options.inline;\n    }\n\n    var _this = possibleConstructorReturn(this, _Component.call(this, player, options));\n\n    _this.on(player, ['loadstart'], _this.volumePanelState_);\n\n    // while the slider is active (the mouse has been pressed down and\n    // is dragging) we do not want to hide the VolumeBar\n    _this.on(_this.volumeControl, ['slideractive'], _this.sliderActive_);\n\n    _this.on(_this.volumeControl, ['sliderinactive'], _this.sliderInactive_);\n    return _this;\n  }\n\n  /**\n   * Add vjs-slider-active class to the VolumePanel\n   *\n   * @listens VolumeControl#slideractive\n   * @private\n   */\n\n\n  VolumePanel.prototype.sliderActive_ = function sliderActive_() {\n    this.addClass('vjs-slider-active');\n  };\n\n  /**\n   * Removes vjs-slider-active class to the VolumePanel\n   *\n   * @listens VolumeControl#sliderinactive\n   * @private\n   */\n\n\n  VolumePanel.prototype.sliderInactive_ = function sliderInactive_() {\n    this.removeClass('vjs-slider-active');\n  };\n\n  /**\n   * Adds vjs-hidden or vjs-mute-toggle-only to the VolumePanel\n   * depending on MuteToggle and VolumeControl state\n   *\n   * @listens Player#loadstart\n   * @private\n   */\n\n\n  VolumePanel.prototype.volumePanelState_ = function volumePanelState_() {\n    // hide volume panel if neither volume control or mute toggle\n    // are displayed\n    if (this.volumeControl.hasClass('vjs-hidden') && this.muteToggle.hasClass('vjs-hidden')) {\n      this.addClass('vjs-hidden');\n    }\n\n    // if only mute toggle is visible we don't want\n    // volume panel expanding when hovered or active\n    if (this.volumeControl.hasClass('vjs-hidden') && !this.muteToggle.hasClass('vjs-hidden')) {\n      this.addClass('vjs-mute-toggle-only');\n    }\n  };\n\n  /**\n   * Create the `Component`'s DOM element\n   *\n   * @return {Element}\n   *         The element that was created.\n   */\n\n\n  VolumePanel.prototype.createEl = function createEl() {\n    var orientationClass = 'vjs-volume-panel-horizontal';\n\n    if (!this.options_.inline) {\n      orientationClass = 'vjs-volume-panel-vertical';\n    }\n\n    return _Component.prototype.createEl.call(this, 'div', {\n      className: 'vjs-volume-panel vjs-control ' + orientationClass\n    });\n  };\n\n  return VolumePanel;\n}(Component);\n\n/**\n * Default options for the `VolumeControl`\n *\n * @type {Object}\n * @private\n */\n\n\nVolumePanel.prototype.options_ = {\n  children: ['muteToggle', 'volumeControl']\n};\n\nComponent.registerComponent('VolumePanel', VolumePanel);\n\n/**\n * @file menu.js\n */\n/**\n * The Menu component is used to build popup menus, including subtitle and\n * captions selection menus.\n *\n * @extends Component\n */\n\nvar Menu = function (_Component) {\n  inherits(Menu, _Component);\n\n  /**\n   * Create an instance of this class.\n   *\n   * @param {Player} player\n   *        the player that this component should attach to\n   *\n   * @param {Object} [options]\n   *        Object of option names and values\n   *\n   */\n  function Menu(player, options) {\n    classCallCheck(this, Menu);\n\n    var _this = possibleConstructorReturn(this, _Component.call(this, player, options));\n\n    if (options) {\n      _this.menuButton_ = options.menuButton;\n    }\n\n    _this.focusedChild_ = -1;\n\n    _this.on('keydown', _this.handleKeyPress);\n    return _this;\n  }\n\n  /**\n   * Add a {@link MenuItem} to the menu.\n   *\n   * @param {Object|string} component\n   *        The name or instance of the `MenuItem` to add.\n   *\n   */\n\n\n  Menu.prototype.addItem = function addItem(component) {\n    this.addChild(component);\n    component.on('click', bind(this, function (event) {\n      // Unpress the associated MenuButton, and move focus back to it\n      if (this.menuButton_) {\n        this.menuButton_.unpressButton();\n\n        // don't focus menu button if item is a caption settings item\n        // because focus will move elsewhere and it logs an error on IE8\n        if (component.name() !== 'CaptionSettingsMenuItem') {\n          this.menuButton_.focus();\n        }\n      }\n    }));\n  };\n\n  /**\n   * Create the `Menu`s DOM element.\n   *\n   * @return {Element}\n   *         the element that was created\n   */\n\n\n  Menu.prototype.createEl = function createEl$$1() {\n    var contentElType = this.options_.contentElType || 'ul';\n\n    this.contentEl_ = createEl(contentElType, {\n      className: 'vjs-menu-content'\n    });\n\n    this.contentEl_.setAttribute('role', 'menu');\n\n    var el = _Component.prototype.createEl.call(this, 'div', {\n      append: this.contentEl_,\n      className: 'vjs-menu'\n    });\n\n    el.appendChild(this.contentEl_);\n\n    // Prevent clicks from bubbling up. Needed for Menu Buttons,\n    // where a click on the parent is significant\n    on(el, 'click', function (event) {\n      event.preventDefault();\n      event.stopImmediatePropagation();\n    });\n\n    return el;\n  };\n\n  Menu.prototype.dispose = function dispose() {\n    this.contentEl_ = null;\n\n    _Component.prototype.dispose.call(this);\n  };\n\n  /**\n   * Handle a `keydown` event on this menu. This listener is added in the constructor.\n   *\n   * @param {EventTarget~Event} event\n   *        A `keydown` event that happened on the menu.\n   *\n   * @listens keydown\n   */\n\n\n  Menu.prototype.handleKeyPress = function handleKeyPress(event) {\n    // Left and Down Arrows\n    if (event.which === 37 || event.which === 40) {\n      event.preventDefault();\n      this.stepForward();\n\n      // Up and Right Arrows\n    } else if (event.which === 38 || event.which === 39) {\n      event.preventDefault();\n      this.stepBack();\n    }\n  };\n\n  /**\n   * Move to next (lower) menu item for keyboard users.\n   */\n\n\n  Menu.prototype.stepForward = function stepForward() {\n    var stepChild = 0;\n\n    if (this.focusedChild_ !== undefined) {\n      stepChild = this.focusedChild_ + 1;\n    }\n    this.focus(stepChild);\n  };\n\n  /**\n   * Move to previous (higher) menu item for keyboard users.\n   */\n\n\n  Menu.prototype.stepBack = function stepBack() {\n    var stepChild = 0;\n\n    if (this.focusedChild_ !== undefined) {\n      stepChild = this.focusedChild_ - 1;\n    }\n    this.focus(stepChild);\n  };\n\n  /**\n   * Set focus on a {@link MenuItem} in the `Menu`.\n   *\n   * @param {Object|string} [item=0]\n   *        Index of child item set focus on.\n   */\n\n\n  Menu.prototype.focus = function focus() {\n    var item = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n\n    var children = this.children().slice();\n    var haveTitle = children.length && children[0].className && /vjs-menu-title/.test(children[0].className);\n\n    if (haveTitle) {\n      children.shift();\n    }\n\n    if (children.length > 0) {\n      if (item < 0) {\n        item = 0;\n      } else if (item >= children.length) {\n        item = children.length - 1;\n      }\n\n      this.focusedChild_ = item;\n\n      children[item].el_.focus();\n    }\n  };\n\n  return Menu;\n}(Component);\n\nComponent.registerComponent('Menu', Menu);\n\n/**\n * @file menu-button.js\n */\n/**\n * A `MenuButton` class for any popup {@link Menu}.\n *\n * @extends Component\n */\n\nvar MenuButton = function (_Component) {\n  inherits(MenuButton, _Component);\n\n  /**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options={}]\n   *        The key/value store of player options.\n   */\n  function MenuButton(player) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    classCallCheck(this, MenuButton);\n\n    var _this = possibleConstructorReturn(this, _Component.call(this, player, options));\n\n    _this.menuButton_ = new Button(player, options);\n\n    _this.menuButton_.controlText(_this.controlText_);\n    _this.menuButton_.el_.setAttribute('aria-haspopup', 'true');\n\n    // Add buildCSSClass values to the button, not the wrapper\n    var buttonClass = Button.prototype.buildCSSClass();\n\n    _this.menuButton_.el_.className = _this.buildCSSClass() + ' ' + buttonClass;\n    _this.menuButton_.removeClass('vjs-control');\n\n    _this.addChild(_this.menuButton_);\n\n    _this.update();\n\n    _this.enabled_ = true;\n\n    _this.on(_this.menuButton_, 'tap', _this.handleClick);\n    _this.on(_this.menuButton_, 'click', _this.handleClick);\n    _this.on(_this.menuButton_, 'focus', _this.handleFocus);\n    _this.on(_this.menuButton_, 'blur', _this.handleBlur);\n\n    _this.on('keydown', _this.handleSubmenuKeyPress);\n    return _this;\n  }\n\n  /**\n   * Update the menu based on the current state of its items.\n   */\n\n\n  MenuButton.prototype.update = function update() {\n    var menu = this.createMenu();\n\n    if (this.menu) {\n      this.menu.dispose();\n      this.removeChild(this.menu);\n    }\n\n    this.menu = menu;\n    this.addChild(menu);\n\n    /**\n     * Track the state of the menu button\n     *\n     * @type {Boolean}\n     * @private\n     */\n    this.buttonPressed_ = false;\n    this.menuButton_.el_.setAttribute('aria-expanded', 'false');\n\n    if (this.items && this.items.length <= this.hideThreshold_) {\n      this.hide();\n    } else {\n      this.show();\n    }\n  };\n\n  /**\n   * Create the menu and add all items to it.\n   *\n   * @return {Menu}\n   *         The constructed menu\n   */\n\n\n  MenuButton.prototype.createMenu = function createMenu() {\n    var menu = new Menu(this.player_, { menuButton: this });\n\n    /**\n     * Hide the menu if the number of items is less than or equal to this threshold. This defaults\n     * to 0 and whenever we add items which can be hidden to the menu we'll increment it. We list\n     * it here because every time we run `createMenu` we need to reset the value.\n     *\n     * @protected\n     * @type {Number}\n     */\n    this.hideThreshold_ = 0;\n\n    // Add a title list item to the top\n    if (this.options_.title) {\n      var title = createEl('li', {\n        className: 'vjs-menu-title',\n        innerHTML: toTitleCase(this.options_.title),\n        tabIndex: -1\n      });\n\n      this.hideThreshold_ += 1;\n\n      menu.children_.unshift(title);\n      prependTo(title, menu.contentEl());\n    }\n\n    this.items = this.createItems();\n\n    if (this.items) {\n      // Add menu items to the menu\n      for (var i = 0; i < this.items.length; i++) {\n        menu.addItem(this.items[i]);\n      }\n    }\n\n    return menu;\n  };\n\n  /**\n   * Create the list of menu items. Specific to each subclass.\n   *\n   * @abstract\n   */\n\n\n  MenuButton.prototype.createItems = function createItems() {};\n\n  /**\n   * Create the `MenuButtons`s DOM element.\n   *\n   * @return {Element}\n   *         The element that gets created.\n   */\n\n\n  MenuButton.prototype.createEl = function createEl$$1() {\n    return _Component.prototype.createEl.call(this, 'div', {\n      className: this.buildWrapperCSSClass()\n    }, {});\n  };\n\n  /**\n   * Allow sub components to stack CSS class names for the wrapper element\n   *\n   * @return {string}\n   *         The constructed wrapper DOM `className`\n   */\n\n\n  MenuButton.prototype.buildWrapperCSSClass = function buildWrapperCSSClass() {\n    var menuButtonClass = 'vjs-menu-button';\n\n    // If the inline option is passed, we want to use different styles altogether.\n    if (this.options_.inline === true) {\n      menuButtonClass += '-inline';\n    } else {\n      menuButtonClass += '-popup';\n    }\n\n    // TODO: Fix the CSS so that this isn't necessary\n    var buttonClass = Button.prototype.buildCSSClass();\n\n    return 'vjs-menu-button ' + menuButtonClass + ' ' + buttonClass + ' ' + _Component.prototype.buildCSSClass.call(this);\n  };\n\n  /**\n   * Builds the default DOM `className`.\n   *\n   * @return {string}\n   *         The DOM `className` for this object.\n   */\n\n\n  MenuButton.prototype.buildCSSClass = function buildCSSClass() {\n    var menuButtonClass = 'vjs-menu-button';\n\n    // If the inline option is passed, we want to use different styles altogether.\n    if (this.options_.inline === true) {\n      menuButtonClass += '-inline';\n    } else {\n      menuButtonClass += '-popup';\n    }\n\n    return 'vjs-menu-button ' + menuButtonClass + ' ' + _Component.prototype.buildCSSClass.call(this);\n  };\n\n  /**\n   * Get or set the localized control text that will be used for accessibility.\n   *\n   * > NOTE: This will come from the internal `menuButton_` element.\n   *\n   * @param {string} [text]\n   *        Control text for element.\n   *\n   * @param {Element} [el=this.menuButton_.el()]\n   *        Element to set the title on.\n   *\n   * @return {string}\n   *         - The control text when getting\n   */\n\n\n  MenuButton.prototype.controlText = function controlText(text) {\n    var el = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.menuButton_.el();\n\n    return this.menuButton_.controlText(text, el);\n  };\n\n  /**\n   * Handle a click on a `MenuButton`.\n   * See {@link ClickableComponent#handleClick} for instances where this is called.\n   *\n   * @param {EventTarget~Event} event\n   *        The `keydown`, `tap`, or `click` event that caused this function to be\n   *        called.\n   *\n   * @listens tap\n   * @listens click\n   */\n\n\n  MenuButton.prototype.handleClick = function handleClick(event) {\n    // When you click the button it adds focus, which will show the menu.\n    // So we'll remove focus when the mouse leaves the button. Focus is needed\n    // for tab navigation.\n\n    this.one(this.menu.contentEl(), 'mouseleave', bind(this, function (e) {\n      this.unpressButton();\n      this.el_.blur();\n    }));\n    if (this.buttonPressed_) {\n      this.unpressButton();\n    } else {\n      this.pressButton();\n    }\n  };\n\n  /**\n   * Set the focus to the actual button, not to this element\n   */\n\n\n  MenuButton.prototype.focus = function focus() {\n    this.menuButton_.focus();\n  };\n\n  /**\n   * Remove the focus from the actual button, not this element\n   */\n\n\n  MenuButton.prototype.blur = function blur() {\n    this.menuButton_.blur();\n  };\n\n  /**\n   * This gets called when a `MenuButton` gains focus via a `focus` event.\n   * Turns on listening for `keydown` events. When they happen it\n   * calls `this.handleKeyPress`.\n   *\n   * @param {EventTarget~Event} event\n   *        The `focus` event that caused this function to be called.\n   *\n   * @listens focus\n   */\n\n\n  MenuButton.prototype.handleFocus = function handleFocus() {\n    on(document, 'keydown', bind(this, this.handleKeyPress));\n  };\n\n  /**\n   * Called when a `MenuButton` loses focus. Turns off the listener for\n   * `keydown` events. Which Stops `this.handleKeyPress` from getting called.\n   *\n   * @param {EventTarget~Event} event\n   *        The `blur` event that caused this function to be called.\n   *\n   * @listens blur\n   */\n\n\n  MenuButton.prototype.handleBlur = function handleBlur() {\n    off(document, 'keydown', bind(this, this.handleKeyPress));\n  };\n\n  /**\n   * Handle tab, escape, down arrow, and up arrow keys for `MenuButton`. See\n   * {@link ClickableComponent#handleKeyPress} for instances where this is called.\n   *\n   * @param {EventTarget~Event} event\n   *        The `keydown` event that caused this function to be called.\n   *\n   * @listens keydown\n   */\n\n\n  MenuButton.prototype.handleKeyPress = function handleKeyPress(event) {\n\n    // Escape (27) key or Tab (9) key unpress the 'button'\n    if (event.which === 27 || event.which === 9) {\n      if (this.buttonPressed_) {\n        this.unpressButton();\n      }\n      // Don't preventDefault for Tab key - we still want to lose focus\n      if (event.which !== 9) {\n        event.preventDefault();\n        // Set focus back to the menu button's button\n        this.menuButton_.el_.focus();\n      }\n      // Up (38) key or Down (40) key press the 'button'\n    } else if (event.which === 38 || event.which === 40) {\n      if (!this.buttonPressed_) {\n        this.pressButton();\n        event.preventDefault();\n      }\n    }\n  };\n\n  /**\n   * Handle a `keydown` event on a sub-menu. The listener for this is added in\n   * the constructor.\n   *\n   * @param {EventTarget~Event} event\n   *        Key press event\n   *\n   * @listens keydown\n   */\n\n\n  MenuButton.prototype.handleSubmenuKeyPress = function handleSubmenuKeyPress(event) {\n\n    // Escape (27) key or Tab (9) key unpress the 'button'\n    if (event.which === 27 || event.which === 9) {\n      if (this.buttonPressed_) {\n        this.unpressButton();\n      }\n      // Don't preventDefault for Tab key - we still want to lose focus\n      if (event.which !== 9) {\n        event.preventDefault();\n        // Set focus back to the menu button's button\n        this.menuButton_.el_.focus();\n      }\n    }\n  };\n\n  /**\n   * Put the current `MenuButton` into a pressed state.\n   */\n\n\n  MenuButton.prototype.pressButton = function pressButton() {\n    if (this.enabled_) {\n      this.buttonPressed_ = true;\n      this.menu.lockShowing();\n      this.menuButton_.el_.setAttribute('aria-expanded', 'true');\n\n      // set the focus into the submenu, except on iOS where it is resulting in\n      // undesired scrolling behavior when the player is in an iframe\n      if (IS_IOS && isInFrame()) {\n        // Return early so that the menu isn't focused\n        return;\n      }\n\n      this.menu.focus();\n    }\n  };\n\n  /**\n   * Take the current `MenuButton` out of a pressed state.\n   */\n\n\n  MenuButton.prototype.unpressButton = function unpressButton() {\n    if (this.enabled_) {\n      this.buttonPressed_ = false;\n      this.menu.unlockShowing();\n      this.menuButton_.el_.setAttribute('aria-expanded', 'false');\n    }\n  };\n\n  /**\n   * Disable the `MenuButton`. Don't allow it to be clicked.\n   */\n\n\n  MenuButton.prototype.disable = function disable() {\n    this.unpressButton();\n\n    this.enabled_ = false;\n    this.addClass('vjs-disabled');\n\n    this.menuButton_.disable();\n  };\n\n  /**\n   * Enable the `MenuButton`. Allow it to be clicked.\n   */\n\n\n  MenuButton.prototype.enable = function enable() {\n    this.enabled_ = true;\n    this.removeClass('vjs-disabled');\n\n    this.menuButton_.enable();\n  };\n\n  return MenuButton;\n}(Component);\n\nComponent.registerComponent('MenuButton', MenuButton);\n\n/**\n * @file track-button.js\n */\n/**\n * The base class for buttons that toggle specific  track types (e.g. subtitles).\n *\n * @extends MenuButton\n */\n\nvar TrackButton = function (_MenuButton) {\n  inherits(TrackButton, _MenuButton);\n\n  /**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   */\n  function TrackButton(player, options) {\n    classCallCheck(this, TrackButton);\n\n    var tracks = options.tracks;\n\n    var _this = possibleConstructorReturn(this, _MenuButton.call(this, player, options));\n\n    if (_this.items.length <= 1) {\n      _this.hide();\n    }\n\n    if (!tracks) {\n      return possibleConstructorReturn(_this);\n    }\n\n    var updateHandler = bind(_this, _this.update);\n\n    tracks.addEventListener('removetrack', updateHandler);\n    tracks.addEventListener('addtrack', updateHandler);\n    _this.player_.on('ready', updateHandler);\n\n    _this.player_.on('dispose', function () {\n      tracks.removeEventListener('removetrack', updateHandler);\n      tracks.removeEventListener('addtrack', updateHandler);\n    });\n    return _this;\n  }\n\n  return TrackButton;\n}(MenuButton);\n\nComponent.registerComponent('TrackButton', TrackButton);\n\n/**\n * @file menu-item.js\n */\n/**\n * The component for a menu item. `<li>`\n *\n * @extends ClickableComponent\n */\n\nvar MenuItem = function (_ClickableComponent) {\n  inherits(MenuItem, _ClickableComponent);\n\n  /**\n   * Creates an instance of the this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options={}]\n   *        The key/value store of player options.\n   *\n   */\n  function MenuItem(player, options) {\n    classCallCheck(this, MenuItem);\n\n    var _this = possibleConstructorReturn(this, _ClickableComponent.call(this, player, options));\n\n    _this.selectable = options.selectable;\n    _this.isSelected_ = options.selected || false;\n    _this.multiSelectable = options.multiSelectable;\n\n    _this.selected(_this.isSelected_);\n\n    if (_this.selectable) {\n      if (_this.multiSelectable) {\n        _this.el_.setAttribute('role', 'menuitemcheckbox');\n      } else {\n        _this.el_.setAttribute('role', 'menuitemradio');\n      }\n    } else {\n      _this.el_.setAttribute('role', 'menuitem');\n    }\n    return _this;\n  }\n\n  /**\n   * Create the `MenuItem's DOM element\n   *\n   * @param {string} [type=li]\n   *        Element's node type, not actually used, always set to `li`.\n   *\n   * @param {Object} [props={}]\n   *        An object of properties that should be set on the element\n   *\n   * @param {Object} [attrs={}]\n   *        An object of attributes that should be set on the element\n   *\n   * @return {Element}\n   *         The element that gets created.\n   */\n\n\n  MenuItem.prototype.createEl = function createEl(type, props, attrs) {\n    // The control is textual, not just an icon\n    this.nonIconControl = true;\n\n    return _ClickableComponent.prototype.createEl.call(this, 'li', assign({\n      className: 'vjs-menu-item',\n      innerHTML: '<span class=\"vjs-menu-item-text\">' + this.localize(this.options_.label) + '</span>',\n      tabIndex: -1\n    }, props), attrs);\n  };\n\n  /**\n   * Any click on a `MenuItem` puts it into the selected state.\n   * See {@link ClickableComponent#handleClick} for instances where this is called.\n   *\n   * @param {EventTarget~Event} event\n   *        The `keydown`, `tap`, or `click` event that caused this function to be\n   *        called.\n   *\n   * @listens tap\n   * @listens click\n   */\n\n\n  MenuItem.prototype.handleClick = function handleClick(event) {\n    this.selected(true);\n  };\n\n  /**\n   * Set the state for this menu item as selected or not.\n   *\n   * @param {boolean} selected\n   *        if the menu item is selected or not\n   */\n\n\n  MenuItem.prototype.selected = function selected(_selected) {\n    if (this.selectable) {\n      if (_selected) {\n        this.addClass('vjs-selected');\n        this.el_.setAttribute('aria-checked', 'true');\n        // aria-checked isn't fully supported by browsers/screen readers,\n        // so indicate selected state to screen reader in the control text.\n        this.controlText(', selected');\n        this.isSelected_ = true;\n      } else {\n        this.removeClass('vjs-selected');\n        this.el_.setAttribute('aria-checked', 'false');\n        // Indicate un-selected state to screen reader\n        this.controlText('');\n        this.isSelected_ = false;\n      }\n    }\n  };\n\n  return MenuItem;\n}(ClickableComponent);\n\nComponent.registerComponent('MenuItem', MenuItem);\n\n/**\n * @file text-track-menu-item.js\n */\n/**\n * The specific menu item type for selecting a language within a text track kind\n *\n * @extends MenuItem\n */\n\nvar TextTrackMenuItem = function (_MenuItem) {\n  inherits(TextTrackMenuItem, _MenuItem);\n\n  /**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   */\n  function TextTrackMenuItem(player, options) {\n    classCallCheck(this, TextTrackMenuItem);\n\n    var track = options.track;\n    var tracks = player.textTracks();\n\n    // Modify options for parent MenuItem class's init.\n    options.label = track.label || track.language || 'Unknown';\n    options.selected = track.mode === 'showing';\n\n    var _this = possibleConstructorReturn(this, _MenuItem.call(this, player, options));\n\n    _this.track = track;\n    var changeHandler = function changeHandler() {\n      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      _this.handleTracksChange.apply(_this, args);\n    };\n    var selectedLanguageChangeHandler = function selectedLanguageChangeHandler() {\n      for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n\n      _this.handleSelectedLanguageChange.apply(_this, args);\n    };\n\n    player.on(['loadstart', 'texttrackchange'], changeHandler);\n    tracks.addEventListener('change', changeHandler);\n    tracks.addEventListener('selectedlanguagechange', selectedLanguageChangeHandler);\n    _this.on('dispose', function () {\n      player.off(['loadstart', 'texttrackchange'], changeHandler);\n      tracks.removeEventListener('change', changeHandler);\n      tracks.removeEventListener('selectedlanguagechange', selectedLanguageChangeHandler);\n    });\n\n    // iOS7 doesn't dispatch change events to TextTrackLists when an\n    // associated track's mode changes. Without something like\n    // Object.observe() (also not present on iOS7), it's not\n    // possible to detect changes to the mode attribute and polyfill\n    // the change event. As a poor substitute, we manually dispatch\n    // change events whenever the controls modify the mode.\n    if (tracks.onchange === undefined) {\n      var event = void 0;\n\n      _this.on(['tap', 'click'], function () {\n        if (_typeof(window.Event) !== 'object') {\n          // Android 2.3 throws an Illegal Constructor error for window.Event\n          try {\n            event = new window.Event('change');\n          } catch (err) {\n            // continue regardless of error\n          }\n        }\n\n        if (!event) {\n          event = document.createEvent('Event');\n          event.initEvent('change', true, true);\n        }\n\n        tracks.dispatchEvent(event);\n      });\n    }\n\n    // set the default state based on current tracks\n    _this.handleTracksChange();\n    return _this;\n  }\n\n  /**\n   * This gets called when an `TextTrackMenuItem` is \"clicked\". See\n   * {@link ClickableComponent} for more detailed information on what a click can be.\n   *\n   * @param {EventTarget~Event} event\n   *        The `keydown`, `tap`, or `click` event that caused this function to be\n   *        called.\n   *\n   * @listens tap\n   * @listens click\n   */\n\n\n  TextTrackMenuItem.prototype.handleClick = function handleClick(event) {\n    var kind = this.track.kind;\n    var kinds = this.track.kinds;\n    var tracks = this.player_.textTracks();\n\n    if (!kinds) {\n      kinds = [kind];\n    }\n\n    _MenuItem.prototype.handleClick.call(this, event);\n\n    if (!tracks) {\n      return;\n    }\n\n    for (var i = 0; i < tracks.length; i++) {\n      var track = tracks[i];\n\n      if (track === this.track && kinds.indexOf(track.kind) > -1) {\n        if (track.mode !== 'showing') {\n          track.mode = 'showing';\n        }\n      } else if (track.mode !== 'disabled') {\n        track.mode = 'disabled';\n      }\n    }\n  };\n\n  /**\n   * Handle text track list change\n   *\n   * @param {EventTarget~Event} event\n   *        The `change` event that caused this function to be called.\n   *\n   * @listens TextTrackList#change\n   */\n\n\n  TextTrackMenuItem.prototype.handleTracksChange = function handleTracksChange(event) {\n    var shouldBeSelected = this.track.mode === 'showing';\n\n    // Prevent redundant selected() calls because they may cause\n    // screen readers to read the appended control text unnecessarily\n    if (shouldBeSelected !== this.isSelected_) {\n      this.selected(shouldBeSelected);\n    }\n  };\n\n  TextTrackMenuItem.prototype.handleSelectedLanguageChange = function handleSelectedLanguageChange(event) {\n    if (this.track.mode === 'showing') {\n      var selectedLanguage = this.player_.cache_.selectedLanguage;\n\n      // Don't replace the kind of track across the same language\n      if (selectedLanguage && selectedLanguage.enabled && selectedLanguage.language === this.track.language && selectedLanguage.kind !== this.track.kind) {\n        return;\n      }\n\n      this.player_.cache_.selectedLanguage = {\n        enabled: true,\n        language: this.track.language,\n        kind: this.track.kind\n      };\n    }\n  };\n\n  TextTrackMenuItem.prototype.dispose = function dispose() {\n    // remove reference to track object on dispose\n    this.track = null;\n\n    _MenuItem.prototype.dispose.call(this);\n  };\n\n  return TextTrackMenuItem;\n}(MenuItem);\n\nComponent.registerComponent('TextTrackMenuItem', TextTrackMenuItem);\n\n/**\n * @file off-text-track-menu-item.js\n */\n/**\n * A special menu item for turning of a specific type of text track\n *\n * @extends TextTrackMenuItem\n */\n\nvar OffTextTrackMenuItem = function (_TextTrackMenuItem) {\n  inherits(OffTextTrackMenuItem, _TextTrackMenuItem);\n\n  /**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   */\n  function OffTextTrackMenuItem(player, options) {\n    classCallCheck(this, OffTextTrackMenuItem);\n\n    // Create pseudo track info\n    // Requires options['kind']\n    options.track = {\n      player: player,\n      kind: options.kind,\n      kinds: options.kinds,\n      'default': false,\n      mode: 'disabled'\n    };\n\n    if (!options.kinds) {\n      options.kinds = [options.kind];\n    }\n\n    if (options.label) {\n      options.track.label = options.label;\n    } else {\n      options.track.label = options.kinds.join(' and ') + ' off';\n    }\n\n    // MenuItem is selectable\n    options.selectable = true;\n    // MenuItem is NOT multiSelectable (i.e. only one can be marked \"selected\" at a time)\n    options.multiSelectable = false;\n\n    return possibleConstructorReturn(this, _TextTrackMenuItem.call(this, player, options));\n  }\n\n  /**\n   * Handle text track change\n   *\n   * @param {EventTarget~Event} event\n   *        The event that caused this function to run\n   */\n\n\n  OffTextTrackMenuItem.prototype.handleTracksChange = function handleTracksChange(event) {\n    var tracks = this.player().textTracks();\n    var shouldBeSelected = true;\n\n    for (var i = 0, l = tracks.length; i < l; i++) {\n      var track = tracks[i];\n\n      if (this.options_.kinds.indexOf(track.kind) > -1 && track.mode === 'showing') {\n        shouldBeSelected = false;\n        break;\n      }\n    }\n\n    // Prevent redundant selected() calls because they may cause\n    // screen readers to read the appended control text unnecessarily\n    if (shouldBeSelected !== this.isSelected_) {\n      this.selected(shouldBeSelected);\n    }\n  };\n\n  OffTextTrackMenuItem.prototype.handleSelectedLanguageChange = function handleSelectedLanguageChange(event) {\n    var tracks = this.player().textTracks();\n    var allHidden = true;\n\n    for (var i = 0, l = tracks.length; i < l; i++) {\n      var track = tracks[i];\n\n      if (['captions', 'descriptions', 'subtitles'].indexOf(track.kind) > -1 && track.mode === 'showing') {\n        allHidden = false;\n        break;\n      }\n    }\n\n    if (allHidden) {\n      this.player_.cache_.selectedLanguage = {\n        enabled: false\n      };\n    }\n  };\n\n  return OffTextTrackMenuItem;\n}(TextTrackMenuItem);\n\nComponent.registerComponent('OffTextTrackMenuItem', OffTextTrackMenuItem);\n\n/**\n * @file text-track-button.js\n */\n/**\n * The base class for buttons that toggle specific text track types (e.g. subtitles)\n *\n * @extends MenuButton\n */\n\nvar TextTrackButton = function (_TrackButton) {\n  inherits(TextTrackButton, _TrackButton);\n\n  /**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options={}]\n   *        The key/value store of player options.\n   */\n  function TextTrackButton(player) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    classCallCheck(this, TextTrackButton);\n\n    options.tracks = player.textTracks();\n\n    return possibleConstructorReturn(this, _TrackButton.call(this, player, options));\n  }\n\n  /**\n   * Create a menu item for each text track\n   *\n   * @param {TextTrackMenuItem[]} [items=[]]\n   *        Existing array of items to use during creation\n   *\n   * @return {TextTrackMenuItem[]}\n   *         Array of menu items that were created\n   */\n\n\n  TextTrackButton.prototype.createItems = function createItems() {\n    var items = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    var TrackMenuItem = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : TextTrackMenuItem;\n\n\n    // Label is an overide for the [track] off label\n    // USed to localise captions/subtitles\n    var label = void 0;\n\n    if (this.label_) {\n      label = this.label_ + ' off';\n    }\n    // Add an OFF menu item to turn all tracks off\n    items.push(new OffTextTrackMenuItem(this.player_, {\n      kinds: this.kinds_,\n      kind: this.kind_,\n      label: label\n    }));\n\n    this.hideThreshold_ += 1;\n\n    var tracks = this.player_.textTracks();\n\n    if (!Array.isArray(this.kinds_)) {\n      this.kinds_ = [this.kind_];\n    }\n\n    for (var i = 0; i < tracks.length; i++) {\n      var track = tracks[i];\n\n      // only add tracks that are of an appropriate kind and have a label\n      if (this.kinds_.indexOf(track.kind) > -1) {\n\n        var item = new TrackMenuItem(this.player_, {\n          track: track,\n          // MenuItem is selectable\n          selectable: true,\n          // MenuItem is NOT multiSelectable (i.e. only one can be marked \"selected\" at a time)\n          multiSelectable: false\n        });\n\n        item.addClass('vjs-' + track.kind + '-menu-item');\n        items.push(item);\n      }\n    }\n\n    return items;\n  };\n\n  return TextTrackButton;\n}(TrackButton);\n\nComponent.registerComponent('TextTrackButton', TextTrackButton);\n\n/**\n * @file chapters-track-menu-item.js\n */\n/**\n * The chapter track menu item\n *\n * @extends MenuItem\n */\n\nvar ChaptersTrackMenuItem = function (_MenuItem) {\n  inherits(ChaptersTrackMenuItem, _MenuItem);\n\n  /**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   */\n  function ChaptersTrackMenuItem(player, options) {\n    classCallCheck(this, ChaptersTrackMenuItem);\n\n    var track = options.track;\n    var cue = options.cue;\n    var currentTime = player.currentTime();\n\n    // Modify options for parent MenuItem class's init.\n    options.selectable = true;\n    options.multiSelectable = false;\n    options.label = cue.text;\n    options.selected = cue.startTime <= currentTime && currentTime < cue.endTime;\n\n    var _this = possibleConstructorReturn(this, _MenuItem.call(this, player, options));\n\n    _this.track = track;\n    _this.cue = cue;\n    track.addEventListener('cuechange', bind(_this, _this.update));\n    return _this;\n  }\n\n  /**\n   * This gets called when an `ChaptersTrackMenuItem` is \"clicked\". See\n   * {@link ClickableComponent} for more detailed information on what a click can be.\n   *\n   * @param {EventTarget~Event} [event]\n   *        The `keydown`, `tap`, or `click` event that caused this function to be\n   *        called.\n   *\n   * @listens tap\n   * @listens click\n   */\n\n\n  ChaptersTrackMenuItem.prototype.handleClick = function handleClick(event) {\n    _MenuItem.prototype.handleClick.call(this);\n    this.player_.currentTime(this.cue.startTime);\n    this.update(this.cue.startTime);\n  };\n\n  /**\n   * Update chapter menu item\n   *\n   * @param {EventTarget~Event} [event]\n   *        The `cuechange` event that caused this function to run.\n   *\n   * @listens TextTrack#cuechange\n   */\n\n\n  ChaptersTrackMenuItem.prototype.update = function update(event) {\n    var cue = this.cue;\n    var currentTime = this.player_.currentTime();\n\n    // vjs.log(currentTime, cue.startTime);\n    this.selected(cue.startTime <= currentTime && currentTime < cue.endTime);\n  };\n\n  return ChaptersTrackMenuItem;\n}(MenuItem);\n\nComponent.registerComponent('ChaptersTrackMenuItem', ChaptersTrackMenuItem);\n\n/**\n * @file chapters-button.js\n */\n/**\n * The button component for toggling and selecting chapters\n * Chapters act much differently than other text tracks\n * Cues are navigation vs. other tracks of alternative languages\n *\n * @extends TextTrackButton\n */\n\nvar ChaptersButton = function (_TextTrackButton) {\n  inherits(ChaptersButton, _TextTrackButton);\n\n  /**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   *\n   * @param {Component~ReadyCallback} [ready]\n   *        The function to call when this function is ready.\n   */\n  function ChaptersButton(player, options, ready) {\n    classCallCheck(this, ChaptersButton);\n    return possibleConstructorReturn(this, _TextTrackButton.call(this, player, options, ready));\n  }\n\n  /**\n   * Builds the default DOM `className`.\n   *\n   * @return {string}\n   *         The DOM `className` for this object.\n   */\n\n\n  ChaptersButton.prototype.buildCSSClass = function buildCSSClass() {\n    return 'vjs-chapters-button ' + _TextTrackButton.prototype.buildCSSClass.call(this);\n  };\n\n  ChaptersButton.prototype.buildWrapperCSSClass = function buildWrapperCSSClass() {\n    return 'vjs-chapters-button ' + _TextTrackButton.prototype.buildWrapperCSSClass.call(this);\n  };\n\n  /**\n   * Update the menu based on the current state of its items.\n   *\n   * @param {EventTarget~Event} [event]\n   *        An event that triggered this function to run.\n   *\n   * @listens TextTrackList#addtrack\n   * @listens TextTrackList#removetrack\n   * @listens TextTrackList#change\n   */\n\n\n  ChaptersButton.prototype.update = function update(event) {\n    if (!this.track_ || event && (event.type === 'addtrack' || event.type === 'removetrack')) {\n      this.setTrack(this.findChaptersTrack());\n    }\n    _TextTrackButton.prototype.update.call(this);\n  };\n\n  /**\n   * Set the currently selected track for the chapters button.\n   *\n   * @param {TextTrack} track\n   *        The new track to select. Nothing will change if this is the currently selected\n   *        track.\n   */\n\n\n  ChaptersButton.prototype.setTrack = function setTrack(track) {\n    if (this.track_ === track) {\n      return;\n    }\n\n    if (!this.updateHandler_) {\n      this.updateHandler_ = this.update.bind(this);\n    }\n\n    // here this.track_ refers to the old track instance\n    if (this.track_) {\n      var remoteTextTrackEl = this.player_.remoteTextTrackEls().getTrackElementByTrack_(this.track_);\n\n      if (remoteTextTrackEl) {\n        remoteTextTrackEl.removeEventListener('load', this.updateHandler_);\n      }\n\n      this.track_ = null;\n    }\n\n    this.track_ = track;\n\n    // here this.track_ refers to the new track instance\n    if (this.track_) {\n      this.track_.mode = 'hidden';\n\n      var _remoteTextTrackEl = this.player_.remoteTextTrackEls().getTrackElementByTrack_(this.track_);\n\n      if (_remoteTextTrackEl) {\n        _remoteTextTrackEl.addEventListener('load', this.updateHandler_);\n      }\n    }\n  };\n\n  /**\n   * Find the track object that is currently in use by this ChaptersButton\n   *\n   * @return {TextTrack|undefined}\n   *         The current track or undefined if none was found.\n   */\n\n\n  ChaptersButton.prototype.findChaptersTrack = function findChaptersTrack() {\n    var tracks = this.player_.textTracks() || [];\n\n    for (var i = tracks.length - 1; i >= 0; i--) {\n      // We will always choose the last track as our chaptersTrack\n      var track = tracks[i];\n\n      if (track.kind === this.kind_) {\n        return track;\n      }\n    }\n  };\n\n  /**\n   * Get the caption for the ChaptersButton based on the track label. This will also\n   * use the current tracks localized kind as a fallback if a label does not exist.\n   *\n   * @return {string}\n   *         The tracks current label or the localized track kind.\n   */\n\n\n  ChaptersButton.prototype.getMenuCaption = function getMenuCaption() {\n    if (this.track_ && this.track_.label) {\n      return this.track_.label;\n    }\n    return this.localize(toTitleCase(this.kind_));\n  };\n\n  /**\n   * Create menu from chapter track\n   *\n   * @return {Menu}\n   *         New menu for the chapter buttons\n   */\n\n\n  ChaptersButton.prototype.createMenu = function createMenu() {\n    this.options_.title = this.getMenuCaption();\n    return _TextTrackButton.prototype.createMenu.call(this);\n  };\n\n  /**\n   * Create a menu item for each text track\n   *\n   * @return {TextTrackMenuItem[]}\n   *         Array of menu items\n   */\n\n\n  ChaptersButton.prototype.createItems = function createItems() {\n    var items = [];\n\n    if (!this.track_) {\n      return items;\n    }\n\n    var cues = this.track_.cues;\n\n    if (!cues) {\n      return items;\n    }\n\n    for (var i = 0, l = cues.length; i < l; i++) {\n      var cue = cues[i];\n      var mi = new ChaptersTrackMenuItem(this.player_, { track: this.track_, cue: cue });\n\n      items.push(mi);\n    }\n\n    return items;\n  };\n\n  return ChaptersButton;\n}(TextTrackButton);\n\n/**\n * `kind` of TextTrack to look for to associate it with this menu.\n *\n * @type {string}\n * @private\n */\n\n\nChaptersButton.prototype.kind_ = 'chapters';\n\n/**\n * The text that should display over the `ChaptersButton`s controls. Added for localization.\n *\n * @type {string}\n * @private\n */\nChaptersButton.prototype.controlText_ = 'Chapters';\n\nComponent.registerComponent('ChaptersButton', ChaptersButton);\n\n/**\n * @file descriptions-button.js\n */\n/**\n * The button component for toggling and selecting descriptions\n *\n * @extends TextTrackButton\n */\n\nvar DescriptionsButton = function (_TextTrackButton) {\n  inherits(DescriptionsButton, _TextTrackButton);\n\n  /**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   *\n   * @param {Component~ReadyCallback} [ready]\n   *        The function to call when this component is ready.\n   */\n  function DescriptionsButton(player, options, ready) {\n    classCallCheck(this, DescriptionsButton);\n\n    var _this = possibleConstructorReturn(this, _TextTrackButton.call(this, player, options, ready));\n\n    var tracks = player.textTracks();\n    var changeHandler = bind(_this, _this.handleTracksChange);\n\n    tracks.addEventListener('change', changeHandler);\n    _this.on('dispose', function () {\n      tracks.removeEventListener('change', changeHandler);\n    });\n    return _this;\n  }\n\n  /**\n   * Handle text track change\n   *\n   * @param {EventTarget~Event} event\n   *        The event that caused this function to run\n   *\n   * @listens TextTrackList#change\n   */\n\n\n  DescriptionsButton.prototype.handleTracksChange = function handleTracksChange(event) {\n    var tracks = this.player().textTracks();\n    var disabled = false;\n\n    // Check whether a track of a different kind is showing\n    for (var i = 0, l = tracks.length; i < l; i++) {\n      var track = tracks[i];\n\n      if (track.kind !== this.kind_ && track.mode === 'showing') {\n        disabled = true;\n        break;\n      }\n    }\n\n    // If another track is showing, disable this menu button\n    if (disabled) {\n      this.disable();\n    } else {\n      this.enable();\n    }\n  };\n\n  /**\n   * Builds the default DOM `className`.\n   *\n   * @return {string}\n   *         The DOM `className` for this object.\n   */\n\n\n  DescriptionsButton.prototype.buildCSSClass = function buildCSSClass() {\n    return 'vjs-descriptions-button ' + _TextTrackButton.prototype.buildCSSClass.call(this);\n  };\n\n  DescriptionsButton.prototype.buildWrapperCSSClass = function buildWrapperCSSClass() {\n    return 'vjs-descriptions-button ' + _TextTrackButton.prototype.buildWrapperCSSClass.call(this);\n  };\n\n  return DescriptionsButton;\n}(TextTrackButton);\n\n/**\n * `kind` of TextTrack to look for to associate it with this menu.\n *\n * @type {string}\n * @private\n */\n\n\nDescriptionsButton.prototype.kind_ = 'descriptions';\n\n/**\n * The text that should display over the `DescriptionsButton`s controls. Added for localization.\n *\n * @type {string}\n * @private\n */\nDescriptionsButton.prototype.controlText_ = 'Descriptions';\n\nComponent.registerComponent('DescriptionsButton', DescriptionsButton);\n\n/**\n * @file subtitles-button.js\n */\n/**\n * The button component for toggling and selecting subtitles\n *\n * @extends TextTrackButton\n */\n\nvar SubtitlesButton = function (_TextTrackButton) {\n  inherits(SubtitlesButton, _TextTrackButton);\n\n  /**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   *\n   * @param {Component~ReadyCallback} [ready]\n   *        The function to call when this component is ready.\n   */\n  function SubtitlesButton(player, options, ready) {\n    classCallCheck(this, SubtitlesButton);\n    return possibleConstructorReturn(this, _TextTrackButton.call(this, player, options, ready));\n  }\n\n  /**\n   * Builds the default DOM `className`.\n   *\n   * @return {string}\n   *         The DOM `className` for this object.\n   */\n\n\n  SubtitlesButton.prototype.buildCSSClass = function buildCSSClass() {\n    return 'vjs-subtitles-button ' + _TextTrackButton.prototype.buildCSSClass.call(this);\n  };\n\n  SubtitlesButton.prototype.buildWrapperCSSClass = function buildWrapperCSSClass() {\n    return 'vjs-subtitles-button ' + _TextTrackButton.prototype.buildWrapperCSSClass.call(this);\n  };\n\n  return SubtitlesButton;\n}(TextTrackButton);\n\n/**\n * `kind` of TextTrack to look for to associate it with this menu.\n *\n * @type {string}\n * @private\n */\n\n\nSubtitlesButton.prototype.kind_ = 'subtitles';\n\n/**\n * The text that should display over the `SubtitlesButton`s controls. Added for localization.\n *\n * @type {string}\n * @private\n */\nSubtitlesButton.prototype.controlText_ = 'Subtitles';\n\nComponent.registerComponent('SubtitlesButton', SubtitlesButton);\n\n/**\n * @file caption-settings-menu-item.js\n */\n/**\n * The menu item for caption track settings menu\n *\n * @extends TextTrackMenuItem\n */\n\nvar CaptionSettingsMenuItem = function (_TextTrackMenuItem) {\n  inherits(CaptionSettingsMenuItem, _TextTrackMenuItem);\n\n  /**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   */\n  function CaptionSettingsMenuItem(player, options) {\n    classCallCheck(this, CaptionSettingsMenuItem);\n\n    options.track = {\n      player: player,\n      kind: options.kind,\n      label: options.kind + ' settings',\n      selectable: false,\n      'default': false,\n      mode: 'disabled'\n    };\n\n    // CaptionSettingsMenuItem has no concept of 'selected'\n    options.selectable = false;\n\n    options.name = 'CaptionSettingsMenuItem';\n\n    var _this = possibleConstructorReturn(this, _TextTrackMenuItem.call(this, player, options));\n\n    _this.addClass('vjs-texttrack-settings');\n    _this.controlText(', opens ' + options.kind + ' settings dialog');\n    return _this;\n  }\n\n  /**\n   * This gets called when an `CaptionSettingsMenuItem` is \"clicked\". See\n   * {@link ClickableComponent} for more detailed information on what a click can be.\n   *\n   * @param {EventTarget~Event} [event]\n   *        The `keydown`, `tap`, or `click` event that caused this function to be\n   *        called.\n   *\n   * @listens tap\n   * @listens click\n   */\n\n\n  CaptionSettingsMenuItem.prototype.handleClick = function handleClick(event) {\n    this.player().getChild('textTrackSettings').open();\n  };\n\n  return CaptionSettingsMenuItem;\n}(TextTrackMenuItem);\n\nComponent.registerComponent('CaptionSettingsMenuItem', CaptionSettingsMenuItem);\n\n/**\n * @file captions-button.js\n */\n/**\n * The button component for toggling and selecting captions\n *\n * @extends TextTrackButton\n */\n\nvar CaptionsButton = function (_TextTrackButton) {\n  inherits(CaptionsButton, _TextTrackButton);\n\n  /**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   *\n   * @param {Component~ReadyCallback} [ready]\n   *        The function to call when this component is ready.\n   */\n  function CaptionsButton(player, options, ready) {\n    classCallCheck(this, CaptionsButton);\n    return possibleConstructorReturn(this, _TextTrackButton.call(this, player, options, ready));\n  }\n\n  /**\n   * Builds the default DOM `className`.\n   *\n   * @return {string}\n   *         The DOM `className` for this object.\n   */\n\n\n  CaptionsButton.prototype.buildCSSClass = function buildCSSClass() {\n    return 'vjs-captions-button ' + _TextTrackButton.prototype.buildCSSClass.call(this);\n  };\n\n  CaptionsButton.prototype.buildWrapperCSSClass = function buildWrapperCSSClass() {\n    return 'vjs-captions-button ' + _TextTrackButton.prototype.buildWrapperCSSClass.call(this);\n  };\n\n  /**\n   * Create caption menu items\n   *\n   * @return {CaptionSettingsMenuItem[]}\n   *         The array of current menu items.\n   */\n\n\n  CaptionsButton.prototype.createItems = function createItems() {\n    var items = [];\n\n    if (!(this.player().tech_ && this.player().tech_.featuresNativeTextTracks) && this.player().getChild('textTrackSettings')) {\n      items.push(new CaptionSettingsMenuItem(this.player_, { kind: this.kind_ }));\n\n      this.hideThreshold_ += 1;\n    }\n\n    return _TextTrackButton.prototype.createItems.call(this, items);\n  };\n\n  return CaptionsButton;\n}(TextTrackButton);\n\n/**\n * `kind` of TextTrack to look for to associate it with this menu.\n *\n * @type {string}\n * @private\n */\n\n\nCaptionsButton.prototype.kind_ = 'captions';\n\n/**\n * The text that should display over the `CaptionsButton`s controls. Added for localization.\n *\n * @type {string}\n * @private\n */\nCaptionsButton.prototype.controlText_ = 'Captions';\n\nComponent.registerComponent('CaptionsButton', CaptionsButton);\n\n/**\n * @file subs-caps-menu-item.js\n */\n/**\n * SubsCapsMenuItem has an [cc] icon to distinguish captions from subtitles\n * in the SubsCapsMenu.\n *\n * @extends TextTrackMenuItem\n */\n\nvar SubsCapsMenuItem = function (_TextTrackMenuItem) {\n  inherits(SubsCapsMenuItem, _TextTrackMenuItem);\n\n  function SubsCapsMenuItem() {\n    classCallCheck(this, SubsCapsMenuItem);\n    return possibleConstructorReturn(this, _TextTrackMenuItem.apply(this, arguments));\n  }\n\n  SubsCapsMenuItem.prototype.createEl = function createEl(type, props, attrs) {\n    var innerHTML = '<span class=\"vjs-menu-item-text\">' + this.localize(this.options_.label);\n\n    if (this.options_.track.kind === 'captions') {\n      innerHTML += '\\n        <span aria-hidden=\"true\" class=\"vjs-icon-placeholder\"></span>\\n        <span class=\"vjs-control-text\"> ' + this.localize('Captions') + '</span>\\n      ';\n    }\n\n    innerHTML += '</span>';\n\n    var el = _TextTrackMenuItem.prototype.createEl.call(this, type, assign({\n      innerHTML: innerHTML\n    }, props), attrs);\n\n    return el;\n  };\n\n  return SubsCapsMenuItem;\n}(TextTrackMenuItem);\n\nComponent.registerComponent('SubsCapsMenuItem', SubsCapsMenuItem);\n\n/**\n * @file sub-caps-button.js\n */\n/**\n * The button component for toggling and selecting captions and/or subtitles\n *\n * @extends TextTrackButton\n */\n\nvar SubsCapsButton = function (_TextTrackButton) {\n  inherits(SubsCapsButton, _TextTrackButton);\n\n  function SubsCapsButton(player) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    classCallCheck(this, SubsCapsButton);\n\n    // Although North America uses \"captions\" in most cases for\n    // \"captions and subtitles\" other locales use \"subtitles\"\n    var _this = possibleConstructorReturn(this, _TextTrackButton.call(this, player, options));\n\n    _this.label_ = 'subtitles';\n    if (['en', 'en-us', 'en-ca', 'fr-ca'].indexOf(_this.player_.language_) > -1) {\n      _this.label_ = 'captions';\n    }\n    _this.menuButton_.controlText(toTitleCase(_this.label_));\n    return _this;\n  }\n\n  /**\n   * Builds the default DOM `className`.\n   *\n   * @return {string}\n   *         The DOM `className` for this object.\n   */\n\n\n  SubsCapsButton.prototype.buildCSSClass = function buildCSSClass() {\n    return 'vjs-subs-caps-button ' + _TextTrackButton.prototype.buildCSSClass.call(this);\n  };\n\n  SubsCapsButton.prototype.buildWrapperCSSClass = function buildWrapperCSSClass() {\n    return 'vjs-subs-caps-button ' + _TextTrackButton.prototype.buildWrapperCSSClass.call(this);\n  };\n\n  /**\n   * Create caption/subtitles menu items\n   *\n   * @return {CaptionSettingsMenuItem[]}\n   *         The array of current menu items.\n   */\n\n\n  SubsCapsButton.prototype.createItems = function createItems() {\n    var items = [];\n\n    if (!(this.player().tech_ && this.player().tech_.featuresNativeTextTracks) && this.player().getChild('textTrackSettings')) {\n      items.push(new CaptionSettingsMenuItem(this.player_, { kind: this.label_ }));\n\n      this.hideThreshold_ += 1;\n    }\n\n    items = _TextTrackButton.prototype.createItems.call(this, items, SubsCapsMenuItem);\n    return items;\n  };\n\n  return SubsCapsButton;\n}(TextTrackButton);\n\n/**\n * `kind`s of TextTrack to look for to associate it with this menu.\n *\n * @type {array}\n * @private\n */\n\n\nSubsCapsButton.prototype.kinds_ = ['captions', 'subtitles'];\n\n/**\n * The text that should display over the `SubsCapsButton`s controls.\n *\n *\n * @type {string}\n * @private\n */\nSubsCapsButton.prototype.controlText_ = 'Subtitles';\n\nComponent.registerComponent('SubsCapsButton', SubsCapsButton);\n\n/**\n * @file audio-track-menu-item.js\n */\n/**\n * An {@link AudioTrack} {@link MenuItem}\n *\n * @extends MenuItem\n */\n\nvar AudioTrackMenuItem = function (_MenuItem) {\n  inherits(AudioTrackMenuItem, _MenuItem);\n\n  /**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   */\n  function AudioTrackMenuItem(player, options) {\n    classCallCheck(this, AudioTrackMenuItem);\n\n    var track = options.track;\n    var tracks = player.audioTracks();\n\n    // Modify options for parent MenuItem class's init.\n    options.label = track.label || track.language || 'Unknown';\n    options.selected = track.enabled;\n\n    var _this = possibleConstructorReturn(this, _MenuItem.call(this, player, options));\n\n    _this.track = track;\n\n    _this.addClass('vjs-' + track.kind + '-menu-item');\n\n    var changeHandler = function changeHandler() {\n      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      _this.handleTracksChange.apply(_this, args);\n    };\n\n    tracks.addEventListener('change', changeHandler);\n    _this.on('dispose', function () {\n      tracks.removeEventListener('change', changeHandler);\n    });\n    return _this;\n  }\n\n  AudioTrackMenuItem.prototype.createEl = function createEl(type, props, attrs) {\n    var innerHTML = '<span class=\"vjs-menu-item-text\">' + this.localize(this.options_.label);\n\n    if (this.options_.track.kind === 'main-desc') {\n      innerHTML += '\\n        <span aria-hidden=\"true\" class=\"vjs-icon-placeholder\"></span>\\n        <span class=\"vjs-control-text\"> ' + this.localize('Descriptions') + '</span>\\n      ';\n    }\n\n    innerHTML += '</span>';\n\n    var el = _MenuItem.prototype.createEl.call(this, type, assign({\n      innerHTML: innerHTML\n    }, props), attrs);\n\n    return el;\n  };\n\n  /**\n   * This gets called when an `AudioTrackMenuItem is \"clicked\". See {@link ClickableComponent}\n   * for more detailed information on what a click can be.\n   *\n   * @param {EventTarget~Event} [event]\n   *        The `keydown`, `tap`, or `click` event that caused this function to be\n   *        called.\n   *\n   * @listens tap\n   * @listens click\n   */\n\n\n  AudioTrackMenuItem.prototype.handleClick = function handleClick(event) {\n    var tracks = this.player_.audioTracks();\n\n    _MenuItem.prototype.handleClick.call(this, event);\n\n    for (var i = 0; i < tracks.length; i++) {\n      var track = tracks[i];\n\n      track.enabled = track === this.track;\n    }\n  };\n\n  /**\n   * Handle any {@link AudioTrack} change.\n   *\n   * @param {EventTarget~Event} [event]\n   *        The {@link AudioTrackList#change} event that caused this to run.\n   *\n   * @listens AudioTrackList#change\n   */\n\n\n  AudioTrackMenuItem.prototype.handleTracksChange = function handleTracksChange(event) {\n    this.selected(this.track.enabled);\n  };\n\n  return AudioTrackMenuItem;\n}(MenuItem);\n\nComponent.registerComponent('AudioTrackMenuItem', AudioTrackMenuItem);\n\n/**\n * @file audio-track-button.js\n */\n/**\n * The base class for buttons that toggle specific {@link AudioTrack} types.\n *\n * @extends TrackButton\n */\n\nvar AudioTrackButton = function (_TrackButton) {\n  inherits(AudioTrackButton, _TrackButton);\n\n  /**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options={}]\n   *        The key/value store of player options.\n   */\n  function AudioTrackButton(player) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    classCallCheck(this, AudioTrackButton);\n\n    options.tracks = player.audioTracks();\n\n    return possibleConstructorReturn(this, _TrackButton.call(this, player, options));\n  }\n\n  /**\n   * Builds the default DOM `className`.\n   *\n   * @return {string}\n   *         The DOM `className` for this object.\n   */\n\n\n  AudioTrackButton.prototype.buildCSSClass = function buildCSSClass() {\n    return 'vjs-audio-button ' + _TrackButton.prototype.buildCSSClass.call(this);\n  };\n\n  AudioTrackButton.prototype.buildWrapperCSSClass = function buildWrapperCSSClass() {\n    return 'vjs-audio-button ' + _TrackButton.prototype.buildWrapperCSSClass.call(this);\n  };\n\n  /**\n   * Create a menu item for each audio track\n   *\n   * @param {AudioTrackMenuItem[]} [items=[]]\n   *        An array of existing menu items to use.\n   *\n   * @return {AudioTrackMenuItem[]}\n   *         An array of menu items\n   */\n\n\n  AudioTrackButton.prototype.createItems = function createItems() {\n    var items = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n    // if there's only one audio track, there no point in showing it\n    this.hideThreshold_ = 1;\n\n    var tracks = this.player_.audioTracks();\n\n    for (var i = 0; i < tracks.length; i++) {\n      var track = tracks[i];\n\n      items.push(new AudioTrackMenuItem(this.player_, {\n        track: track,\n        // MenuItem is selectable\n        selectable: true,\n        // MenuItem is NOT multiSelectable (i.e. only one can be marked \"selected\" at a time)\n        multiSelectable: false\n      }));\n    }\n\n    return items;\n  };\n\n  return AudioTrackButton;\n}(TrackButton);\n\n/**\n * The text that should display over the `AudioTrackButton`s controls. Added for localization.\n *\n * @type {string}\n * @private\n */\n\n\nAudioTrackButton.prototype.controlText_ = 'Audio Track';\nComponent.registerComponent('AudioTrackButton', AudioTrackButton);\n\n/**\n * @file playback-rate-menu-item.js\n */\n/**\n * The specific menu item type for selecting a playback rate.\n *\n * @extends MenuItem\n */\n\nvar PlaybackRateMenuItem = function (_MenuItem) {\n  inherits(PlaybackRateMenuItem, _MenuItem);\n\n  /**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   */\n  function PlaybackRateMenuItem(player, options) {\n    classCallCheck(this, PlaybackRateMenuItem);\n\n    var label = options.rate;\n    var rate = parseFloat(label, 10);\n\n    // Modify options for parent MenuItem class's init.\n    options.label = label;\n    options.selected = rate === 1;\n    options.selectable = true;\n    options.multiSelectable = false;\n\n    var _this = possibleConstructorReturn(this, _MenuItem.call(this, player, options));\n\n    _this.label = label;\n    _this.rate = rate;\n\n    _this.on(player, 'ratechange', _this.update);\n    return _this;\n  }\n\n  /**\n   * This gets called when an `PlaybackRateMenuItem` is \"clicked\". See\n   * {@link ClickableComponent} for more detailed information on what a click can be.\n   *\n   * @param {EventTarget~Event} [event]\n   *        The `keydown`, `tap`, or `click` event that caused this function to be\n   *        called.\n   *\n   * @listens tap\n   * @listens click\n   */\n\n\n  PlaybackRateMenuItem.prototype.handleClick = function handleClick(event) {\n    _MenuItem.prototype.handleClick.call(this);\n    this.player().playbackRate(this.rate);\n  };\n\n  /**\n   * Update the PlaybackRateMenuItem when the playbackrate changes.\n   *\n   * @param {EventTarget~Event} [event]\n   *        The `ratechange` event that caused this function to run.\n   *\n   * @listens Player#ratechange\n   */\n\n\n  PlaybackRateMenuItem.prototype.update = function update(event) {\n    this.selected(this.player().playbackRate() === this.rate);\n  };\n\n  return PlaybackRateMenuItem;\n}(MenuItem);\n\n/**\n * The text that should display over the `PlaybackRateMenuItem`s controls. Added for localization.\n *\n * @type {string}\n * @private\n */\n\n\nPlaybackRateMenuItem.prototype.contentElType = 'button';\n\nComponent.registerComponent('PlaybackRateMenuItem', PlaybackRateMenuItem);\n\n/**\n * @file playback-rate-menu-button.js\n */\n/**\n * The component for controlling the playback rate.\n *\n * @extends MenuButton\n */\n\nvar PlaybackRateMenuButton = function (_MenuButton) {\n  inherits(PlaybackRateMenuButton, _MenuButton);\n\n  /**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   */\n  function PlaybackRateMenuButton(player, options) {\n    classCallCheck(this, PlaybackRateMenuButton);\n\n    var _this = possibleConstructorReturn(this, _MenuButton.call(this, player, options));\n\n    _this.updateVisibility();\n    _this.updateLabel();\n\n    _this.on(player, 'loadstart', _this.updateVisibility);\n    _this.on(player, 'ratechange', _this.updateLabel);\n    return _this;\n  }\n\n  /**\n   * Create the `Component`'s DOM element\n   *\n   * @return {Element}\n   *         The element that was created.\n   */\n\n\n  PlaybackRateMenuButton.prototype.createEl = function createEl$$1() {\n    var el = _MenuButton.prototype.createEl.call(this);\n\n    this.labelEl_ = createEl('div', {\n      className: 'vjs-playback-rate-value',\n      innerHTML: '1x'\n    });\n\n    el.appendChild(this.labelEl_);\n\n    return el;\n  };\n\n  PlaybackRateMenuButton.prototype.dispose = function dispose() {\n    this.labelEl_ = null;\n\n    _MenuButton.prototype.dispose.call(this);\n  };\n\n  /**\n   * Builds the default DOM `className`.\n   *\n   * @return {string}\n   *         The DOM `className` for this object.\n   */\n\n\n  PlaybackRateMenuButton.prototype.buildCSSClass = function buildCSSClass() {\n    return 'vjs-playback-rate ' + _MenuButton.prototype.buildCSSClass.call(this);\n  };\n\n  PlaybackRateMenuButton.prototype.buildWrapperCSSClass = function buildWrapperCSSClass() {\n    return 'vjs-playback-rate ' + _MenuButton.prototype.buildWrapperCSSClass.call(this);\n  };\n\n  /**\n   * Create the playback rate menu\n   *\n   * @return {Menu}\n   *         Menu object populated with {@link PlaybackRateMenuItem}s\n   */\n\n\n  PlaybackRateMenuButton.prototype.createMenu = function createMenu() {\n    var menu = new Menu(this.player());\n    var rates = this.playbackRates();\n\n    if (rates) {\n      for (var i = rates.length - 1; i >= 0; i--) {\n        menu.addChild(new PlaybackRateMenuItem(this.player(), { rate: rates[i] + 'x' }));\n      }\n    }\n\n    return menu;\n  };\n\n  /**\n   * Updates ARIA accessibility attributes\n   */\n\n\n  PlaybackRateMenuButton.prototype.updateARIAAttributes = function updateARIAAttributes() {\n    // Current playback rate\n    this.el().setAttribute('aria-valuenow', this.player().playbackRate());\n  };\n\n  /**\n   * This gets called when an `PlaybackRateMenuButton` is \"clicked\". See\n   * {@link ClickableComponent} for more detailed information on what a click can be.\n   *\n   * @param {EventTarget~Event} [event]\n   *        The `keydown`, `tap`, or `click` event that caused this function to be\n   *        called.\n   *\n   * @listens tap\n   * @listens click\n   */\n\n\n  PlaybackRateMenuButton.prototype.handleClick = function handleClick(event) {\n    // select next rate option\n    var currentRate = this.player().playbackRate();\n    var rates = this.playbackRates();\n\n    // this will select first one if the last one currently selected\n    var newRate = rates[0];\n\n    for (var i = 0; i < rates.length; i++) {\n      if (rates[i] > currentRate) {\n        newRate = rates[i];\n        break;\n      }\n    }\n    this.player().playbackRate(newRate);\n  };\n\n  /**\n   * Get possible playback rates\n   *\n   * @return {Array}\n   *         All possible playback rates\n   */\n\n\n  PlaybackRateMenuButton.prototype.playbackRates = function playbackRates() {\n    return this.options_.playbackRates || this.options_.playerOptions && this.options_.playerOptions.playbackRates;\n  };\n\n  /**\n   * Get whether playback rates is supported by the tech\n   * and an array of playback rates exists\n   *\n   * @return {boolean}\n   *         Whether changing playback rate is supported\n   */\n\n\n  PlaybackRateMenuButton.prototype.playbackRateSupported = function playbackRateSupported() {\n    return this.player().tech_ && this.player().tech_.featuresPlaybackRate && this.playbackRates() && this.playbackRates().length > 0;\n  };\n\n  /**\n   * Hide playback rate controls when they're no playback rate options to select\n   *\n   * @param {EventTarget~Event} [event]\n   *        The event that caused this function to run.\n   *\n   * @listens Player#loadstart\n   */\n\n\n  PlaybackRateMenuButton.prototype.updateVisibility = function updateVisibility(event) {\n    if (this.playbackRateSupported()) {\n      this.removeClass('vjs-hidden');\n    } else {\n      this.addClass('vjs-hidden');\n    }\n  };\n\n  /**\n   * Update button label when rate changed\n   *\n   * @param {EventTarget~Event} [event]\n   *        The event that caused this function to run.\n   *\n   * @listens Player#ratechange\n   */\n\n\n  PlaybackRateMenuButton.prototype.updateLabel = function updateLabel(event) {\n    if (this.playbackRateSupported()) {\n      this.labelEl_.innerHTML = this.player().playbackRate() + 'x';\n    }\n  };\n\n  return PlaybackRateMenuButton;\n}(MenuButton);\n\n/**\n * The text that should display over the `FullscreenToggle`s controls. Added for localization.\n *\n * @type {string}\n * @private\n */\n\n\nPlaybackRateMenuButton.prototype.controlText_ = 'Playback Rate';\n\nComponent.registerComponent('PlaybackRateMenuButton', PlaybackRateMenuButton);\n\n/**\n * @file spacer.js\n */\n/**\n * Just an empty spacer element that can be used as an append point for plugins, etc.\n * Also can be used to create space between elements when necessary.\n *\n * @extends Component\n */\n\nvar Spacer = function (_Component) {\n  inherits(Spacer, _Component);\n\n  function Spacer() {\n    classCallCheck(this, Spacer);\n    return possibleConstructorReturn(this, _Component.apply(this, arguments));\n  }\n\n  /**\n   * Builds the default DOM `className`.\n   *\n   * @return {string}\n   *         The DOM `className` for this object.\n   */\n  Spacer.prototype.buildCSSClass = function buildCSSClass() {\n    return 'vjs-spacer ' + _Component.prototype.buildCSSClass.call(this);\n  };\n\n  /**\n   * Create the `Component`'s DOM element\n   *\n   * @return {Element}\n   *         The element that was created.\n   */\n\n\n  Spacer.prototype.createEl = function createEl() {\n    return _Component.prototype.createEl.call(this, 'div', {\n      className: this.buildCSSClass()\n    });\n  };\n\n  return Spacer;\n}(Component);\n\nComponent.registerComponent('Spacer', Spacer);\n\n/**\n * @file custom-control-spacer.js\n */\n/**\n * Spacer specifically meant to be used as an insertion point for new plugins, etc.\n *\n * @extends Spacer\n */\n\nvar CustomControlSpacer = function (_Spacer) {\n  inherits(CustomControlSpacer, _Spacer);\n\n  function CustomControlSpacer() {\n    classCallCheck(this, CustomControlSpacer);\n    return possibleConstructorReturn(this, _Spacer.apply(this, arguments));\n  }\n\n  /**\n   * Builds the default DOM `className`.\n   *\n   * @return {string}\n   *         The DOM `className` for this object.\n   */\n  CustomControlSpacer.prototype.buildCSSClass = function buildCSSClass() {\n    return 'vjs-custom-control-spacer ' + _Spacer.prototype.buildCSSClass.call(this);\n  };\n\n  /**\n   * Create the `Component`'s DOM element\n   *\n   * @return {Element}\n   *         The element that was created.\n   */\n\n\n  CustomControlSpacer.prototype.createEl = function createEl() {\n    var el = _Spacer.prototype.createEl.call(this, {\n      className: this.buildCSSClass()\n    });\n\n    // No-flex/table-cell mode requires there be some content\n    // in the cell to fill the remaining space of the table.\n    el.innerHTML = '\\xA0';\n    return el;\n  };\n\n  return CustomControlSpacer;\n}(Spacer);\n\nComponent.registerComponent('CustomControlSpacer', CustomControlSpacer);\n\n/**\n * @file control-bar.js\n */\n// Required children\n/**\n * Container of main controls.\n *\n * @extends Component\n */\n\nvar ControlBar = function (_Component) {\n  inherits(ControlBar, _Component);\n\n  function ControlBar() {\n    classCallCheck(this, ControlBar);\n    return possibleConstructorReturn(this, _Component.apply(this, arguments));\n  }\n\n  /**\n   * Create the `Component`'s DOM element\n   *\n   * @return {Element}\n   *         The element that was created.\n   */\n  ControlBar.prototype.createEl = function createEl() {\n    return _Component.prototype.createEl.call(this, 'div', {\n      className: 'vjs-control-bar',\n      dir: 'ltr'\n    });\n  };\n\n  return ControlBar;\n}(Component);\n\n/**\n * Default options for `ControlBar`\n *\n * @type {Object}\n * @private\n */\n\n\nControlBar.prototype.options_ = {\n  children: ['playToggle', 'volumePanel', 'currentTimeDisplay', 'timeDivider', 'durationDisplay', 'progressControl', 'liveDisplay', 'remainingTimeDisplay', 'customControlSpacer', 'playbackRateMenuButton', 'chaptersButton', 'descriptionsButton', 'subsCapsButton', 'audioTrackButton', 'fullscreenToggle']\n};\n\nComponent.registerComponent('ControlBar', ControlBar);\n\n/**\n * @file error-display.js\n */\n/**\n * A display that indicates an error has occurred. This means that the video\n * is unplayable.\n *\n * @extends ModalDialog\n */\n\nvar ErrorDisplay = function (_ModalDialog) {\n  inherits(ErrorDisplay, _ModalDialog);\n\n  /**\n   * Creates an instance of this class.\n   *\n   * @param  {Player} player\n   *         The `Player` that this class should be attached to.\n   *\n   * @param  {Object} [options]\n   *         The key/value store of player options.\n   */\n  function ErrorDisplay(player, options) {\n    classCallCheck(this, ErrorDisplay);\n\n    var _this = possibleConstructorReturn(this, _ModalDialog.call(this, player, options));\n\n    _this.on(player, 'error', _this.open);\n    return _this;\n  }\n\n  /**\n   * Builds the default DOM `className`.\n   *\n   * @return {string}\n   *         The DOM `className` for this object.\n   *\n   * @deprecated Since version 5.\n   */\n\n\n  ErrorDisplay.prototype.buildCSSClass = function buildCSSClass() {\n    return 'vjs-error-display ' + _ModalDialog.prototype.buildCSSClass.call(this);\n  };\n\n  /**\n   * Gets the localized error message based on the `Player`s error.\n   *\n   * @return {string}\n   *         The `Player`s error message localized or an empty string.\n   */\n\n\n  ErrorDisplay.prototype.content = function content() {\n    var error = this.player().error();\n\n    return error ? this.localize(error.message) : '';\n  };\n\n  return ErrorDisplay;\n}(ModalDialog);\n\n/**\n * The default options for an `ErrorDisplay`.\n *\n * @private\n */\n\n\nErrorDisplay.prototype.options_ = mergeOptions(ModalDialog.prototype.options_, {\n  pauseOnOpen: false,\n  fillAlways: true,\n  temporary: false,\n  uncloseable: true\n});\n\nComponent.registerComponent('ErrorDisplay', ErrorDisplay);\n\n/**\n * @file text-track-settings.js\n */\nvar LOCAL_STORAGE_KEY = 'vjs-text-track-settings';\n\nvar COLOR_BLACK = ['#000', 'Black'];\nvar COLOR_BLUE = ['#00F', 'Blue'];\nvar COLOR_CYAN = ['#0FF', 'Cyan'];\nvar COLOR_GREEN = ['#0F0', 'Green'];\nvar COLOR_MAGENTA = ['#F0F', 'Magenta'];\nvar COLOR_RED = ['#F00', 'Red'];\nvar COLOR_WHITE = ['#FFF', 'White'];\nvar COLOR_YELLOW = ['#FF0', 'Yellow'];\n\nvar OPACITY_OPAQUE = ['1', 'Opaque'];\nvar OPACITY_SEMI = ['0.5', 'Semi-Transparent'];\nvar OPACITY_TRANS = ['0', 'Transparent'];\n\n// Configuration for the various <select> elements in the DOM of this component.\n//\n// Possible keys include:\n//\n// `default`:\n//   The default option index. Only needs to be provided if not zero.\n// `parser`:\n//   A function which is used to parse the value from the selected option in\n//   a customized way.\n// `selector`:\n//   The selector used to find the associated <select> element.\nvar selectConfigs = {\n  backgroundColor: {\n    selector: '.vjs-bg-color > select',\n    id: 'captions-background-color-%s',\n    label: 'Color',\n    options: [COLOR_BLACK, COLOR_WHITE, COLOR_RED, COLOR_GREEN, COLOR_BLUE, COLOR_YELLOW, COLOR_MAGENTA, COLOR_CYAN]\n  },\n\n  backgroundOpacity: {\n    selector: '.vjs-bg-opacity > select',\n    id: 'captions-background-opacity-%s',\n    label: 'Transparency',\n    options: [OPACITY_OPAQUE, OPACITY_SEMI, OPACITY_TRANS]\n  },\n\n  color: {\n    selector: '.vjs-fg-color > select',\n    id: 'captions-foreground-color-%s',\n    label: 'Color',\n    options: [COLOR_WHITE, COLOR_BLACK, COLOR_RED, COLOR_GREEN, COLOR_BLUE, COLOR_YELLOW, COLOR_MAGENTA, COLOR_CYAN]\n  },\n\n  edgeStyle: {\n    selector: '.vjs-edge-style > select',\n    id: '%s',\n    label: 'Text Edge Style',\n    options: [['none', 'None'], ['raised', 'Raised'], ['depressed', 'Depressed'], ['uniform', 'Uniform'], ['dropshadow', 'Dropshadow']]\n  },\n\n  fontFamily: {\n    selector: '.vjs-font-family > select',\n    id: 'captions-font-family-%s',\n    label: 'Font Family',\n    options: [['proportionalSansSerif', 'Proportional Sans-Serif'], ['monospaceSansSerif', 'Monospace Sans-Serif'], ['proportionalSerif', 'Proportional Serif'], ['monospaceSerif', 'Monospace Serif'], ['casual', 'Casual'], ['script', 'Script'], ['small-caps', 'Small Caps']]\n  },\n\n  fontPercent: {\n    selector: '.vjs-font-percent > select',\n    id: 'captions-font-size-%s',\n    label: 'Font Size',\n    options: [['0.50', '50%'], ['0.75', '75%'], ['1.00', '100%'], ['1.25', '125%'], ['1.50', '150%'], ['1.75', '175%'], ['2.00', '200%'], ['3.00', '300%'], ['4.00', '400%']],\n    'default': 2,\n    parser: function parser(v) {\n      return v === '1.00' ? null : Number(v);\n    }\n  },\n\n  textOpacity: {\n    selector: '.vjs-text-opacity > select',\n    id: 'captions-foreground-opacity-%s',\n    label: 'Transparency',\n    options: [OPACITY_OPAQUE, OPACITY_SEMI]\n  },\n\n  // Options for this object are defined below.\n  windowColor: {\n    selector: '.vjs-window-color > select',\n    id: 'captions-window-color-%s',\n    label: 'Color'\n  },\n\n  // Options for this object are defined below.\n  windowOpacity: {\n    selector: '.vjs-window-opacity > select',\n    id: 'captions-window-opacity-%s',\n    label: 'Transparency',\n    options: [OPACITY_TRANS, OPACITY_SEMI, OPACITY_OPAQUE]\n  }\n};\n\nselectConfigs.windowColor.options = selectConfigs.backgroundColor.options;\n\n/**\n * Get the actual value of an option.\n *\n * @param  {string} value\n *         The value to get\n *\n * @param  {Function} [parser]\n *         Optional function to adjust the value.\n *\n * @return {Mixed}\n *         - Will be `undefined` if no value exists\n *         - Will be `undefined` if the given value is \"none\".\n *         - Will be the actual value otherwise.\n *\n * @private\n */\nfunction parseOptionValue(value, parser) {\n  if (parser) {\n    value = parser(value);\n  }\n\n  if (value && value !== 'none') {\n    return value;\n  }\n}\n\n/**\n * Gets the value of the selected <option> element within a <select> element.\n *\n * @param  {Element} el\n *         the element to look in\n *\n * @param  {Function} [parser]\n *         Optional function to adjust the value.\n *\n * @return {Mixed}\n *         - Will be `undefined` if no value exists\n *         - Will be `undefined` if the given value is \"none\".\n *         - Will be the actual value otherwise.\n *\n * @private\n */\nfunction getSelectedOptionValue(el, parser) {\n  var value = el.options[el.options.selectedIndex].value;\n\n  return parseOptionValue(value, parser);\n}\n\n/**\n * Sets the selected <option> element within a <select> element based on a\n * given value.\n *\n * @param {Element} el\n *        The element to look in.\n *\n * @param {string} value\n *        the property to look on.\n *\n * @param {Function} [parser]\n *        Optional function to adjust the value before comparing.\n *\n * @private\n */\nfunction setSelectedOption(el, value, parser) {\n  if (!value) {\n    return;\n  }\n\n  for (var i = 0; i < el.options.length; i++) {\n    if (parseOptionValue(el.options[i].value, parser) === value) {\n      el.selectedIndex = i;\n      break;\n    }\n  }\n}\n\n/**\n * Manipulate Text Tracks settings.\n *\n * @extends ModalDialog\n */\n\nvar TextTrackSettings = function (_ModalDialog) {\n  inherits(TextTrackSettings, _ModalDialog);\n\n  /**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *         The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *         The key/value store of player options.\n   */\n  function TextTrackSettings(player, options) {\n    classCallCheck(this, TextTrackSettings);\n\n    options.temporary = false;\n\n    var _this = possibleConstructorReturn(this, _ModalDialog.call(this, player, options));\n\n    _this.updateDisplay = bind(_this, _this.updateDisplay);\n\n    // fill the modal and pretend we have opened it\n    _this.fill();\n    _this.hasBeenOpened_ = _this.hasBeenFilled_ = true;\n\n    _this.endDialog = createEl('p', {\n      className: 'vjs-control-text',\n      textContent: _this.localize('End of dialog window.')\n    });\n    _this.el().appendChild(_this.endDialog);\n\n    _this.setDefaults();\n\n    // Grab `persistTextTrackSettings` from the player options if not passed in child options\n    if (options.persistTextTrackSettings === undefined) {\n      _this.options_.persistTextTrackSettings = _this.options_.playerOptions.persistTextTrackSettings;\n    }\n\n    _this.on(_this.$('.vjs-done-button'), 'click', function () {\n      _this.saveSettings();\n      _this.close();\n    });\n\n    _this.on(_this.$('.vjs-default-button'), 'click', function () {\n      _this.setDefaults();\n      _this.updateDisplay();\n    });\n\n    each(selectConfigs, function (config) {\n      _this.on(_this.$(config.selector), 'change', _this.updateDisplay);\n    });\n\n    if (_this.options_.persistTextTrackSettings) {\n      _this.restoreSettings();\n    }\n    return _this;\n  }\n\n  TextTrackSettings.prototype.dispose = function dispose() {\n    this.endDialog = null;\n\n    _ModalDialog.prototype.dispose.call(this);\n  };\n\n  /**\n   * Create a <select> element with configured options.\n   *\n   * @param {string} key\n   *        Configuration key to use during creation.\n   *\n   * @return {string}\n   *         An HTML string.\n   *\n   * @private\n   */\n\n\n  TextTrackSettings.prototype.createElSelect_ = function createElSelect_(key) {\n    var _this2 = this;\n\n    var legendId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n    var type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'label';\n\n    var config = selectConfigs[key];\n    var id = config.id.replace('%s', this.id_);\n    var selectLabelledbyIds = [legendId, id].join(' ').trim();\n\n    return ['<' + type + ' id=\"' + id + '\" class=\"' + (type === 'label' ? 'vjs-label' : '') + '\">', this.localize(config.label), '</' + type + '>', '<select aria-labelledby=\"' + selectLabelledbyIds + '\">'].concat(config.options.map(function (o) {\n      var optionId = id + '-' + o[1].replace(/\\W+/g, '');\n\n      return ['<option id=\"' + optionId + '\" value=\"' + o[0] + '\" ', 'aria-labelledby=\"' + selectLabelledbyIds + ' ' + optionId + '\">', _this2.localize(o[1]), '</option>'].join('');\n    })).concat('</select>').join('');\n  };\n\n  /**\n   * Create foreground color element for the component\n   *\n   * @return {string}\n   *         An HTML string.\n   *\n   * @private\n   */\n\n\n  TextTrackSettings.prototype.createElFgColor_ = function createElFgColor_() {\n    var legendId = 'captions-text-legend-' + this.id_;\n\n    return ['<fieldset class=\"vjs-fg-color vjs-track-setting\">', '<legend id=\"' + legendId + '\">', this.localize('Text'), '</legend>', this.createElSelect_('color', legendId), '<span class=\"vjs-text-opacity vjs-opacity\">', this.createElSelect_('textOpacity', legendId), '</span>', '</fieldset>'].join('');\n  };\n\n  /**\n   * Create background color element for the component\n   *\n   * @return {string}\n   *         An HTML string.\n   *\n   * @private\n   */\n\n\n  TextTrackSettings.prototype.createElBgColor_ = function createElBgColor_() {\n    var legendId = 'captions-background-' + this.id_;\n\n    return ['<fieldset class=\"vjs-bg-color vjs-track-setting\">', '<legend id=\"' + legendId + '\">', this.localize('Background'), '</legend>', this.createElSelect_('backgroundColor', legendId), '<span class=\"vjs-bg-opacity vjs-opacity\">', this.createElSelect_('backgroundOpacity', legendId), '</span>', '</fieldset>'].join('');\n  };\n\n  /**\n   * Create window color element for the component\n   *\n   * @return {string}\n   *         An HTML string.\n   *\n   * @private\n   */\n\n\n  TextTrackSettings.prototype.createElWinColor_ = function createElWinColor_() {\n    var legendId = 'captions-window-' + this.id_;\n\n    return ['<fieldset class=\"vjs-window-color vjs-track-setting\">', '<legend id=\"' + legendId + '\">', this.localize('Window'), '</legend>', this.createElSelect_('windowColor', legendId), '<span class=\"vjs-window-opacity vjs-opacity\">', this.createElSelect_('windowOpacity', legendId), '</span>', '</fieldset>'].join('');\n  };\n\n  /**\n   * Create color elements for the component\n   *\n   * @return {Element}\n   *         The element that was created\n   *\n   * @private\n   */\n\n\n  TextTrackSettings.prototype.createElColors_ = function createElColors_() {\n    return createEl('div', {\n      className: 'vjs-track-settings-colors',\n      innerHTML: [this.createElFgColor_(), this.createElBgColor_(), this.createElWinColor_()].join('')\n    });\n  };\n\n  /**\n   * Create font elements for the component\n   *\n   * @return {Element}\n   *         The element that was created.\n   *\n   * @private\n   */\n\n\n  TextTrackSettings.prototype.createElFont_ = function createElFont_() {\n    return createEl('div', {\n      className: 'vjs-track-settings-font',\n      innerHTML: ['<fieldset class=\"vjs-font-percent vjs-track-setting\">', this.createElSelect_('fontPercent', '', 'legend'), '</fieldset>', '<fieldset class=\"vjs-edge-style vjs-track-setting\">', this.createElSelect_('edgeStyle', '', 'legend'), '</fieldset>', '<fieldset class=\"vjs-font-family vjs-track-setting\">', this.createElSelect_('fontFamily', '', 'legend'), '</fieldset>'].join('')\n    });\n  };\n\n  /**\n   * Create controls for the component\n   *\n   * @return {Element}\n   *         The element that was created.\n   *\n   * @private\n   */\n\n\n  TextTrackSettings.prototype.createElControls_ = function createElControls_() {\n    var defaultsDescription = this.localize('restore all settings to the default values');\n\n    return createEl('div', {\n      className: 'vjs-track-settings-controls',\n      innerHTML: ['<button type=\"button\" class=\"vjs-default-button\" title=\"' + defaultsDescription + '\">', this.localize('Reset'), '<span class=\"vjs-control-text\"> ' + defaultsDescription + '</span>', '</button>', '<button type=\"button\" class=\"vjs-done-button\">' + this.localize('Done') + '</button>'].join('')\n    });\n  };\n\n  TextTrackSettings.prototype.content = function content() {\n    return [this.createElColors_(), this.createElFont_(), this.createElControls_()];\n  };\n\n  TextTrackSettings.prototype.label = function label() {\n    return this.localize('Caption Settings Dialog');\n  };\n\n  TextTrackSettings.prototype.description = function description() {\n    return this.localize('Beginning of dialog window. Escape will cancel and close the window.');\n  };\n\n  TextTrackSettings.prototype.buildCSSClass = function buildCSSClass() {\n    return _ModalDialog.prototype.buildCSSClass.call(this) + ' vjs-text-track-settings';\n  };\n\n  /**\n   * Gets an object of text track settings (or null).\n   *\n   * @return {Object}\n   *         An object with config values parsed from the DOM or localStorage.\n   */\n\n\n  TextTrackSettings.prototype.getValues = function getValues() {\n    var _this3 = this;\n\n    return reduce(selectConfigs, function (accum, config, key) {\n      var value = getSelectedOptionValue(_this3.$(config.selector), config.parser);\n\n      if (value !== undefined) {\n        accum[key] = value;\n      }\n\n      return accum;\n    }, {});\n  };\n\n  /**\n   * Sets text track settings from an object of values.\n   *\n   * @param {Object} values\n   *        An object with config values parsed from the DOM or localStorage.\n   */\n\n\n  TextTrackSettings.prototype.setValues = function setValues(values) {\n    var _this4 = this;\n\n    each(selectConfigs, function (config, key) {\n      setSelectedOption(_this4.$(config.selector), values[key], config.parser);\n    });\n  };\n\n  /**\n   * Sets all `<select>` elements to their default values.\n   */\n\n\n  TextTrackSettings.prototype.setDefaults = function setDefaults() {\n    var _this5 = this;\n\n    each(selectConfigs, function (config) {\n      var index = config.hasOwnProperty('default') ? config['default'] : 0;\n\n      _this5.$(config.selector).selectedIndex = index;\n    });\n  };\n\n  /**\n   * Restore texttrack settings from localStorage\n   */\n\n\n  TextTrackSettings.prototype.restoreSettings = function restoreSettings() {\n    var values = void 0;\n\n    try {\n      values = JSON.parse(window.localStorage.getItem(LOCAL_STORAGE_KEY));\n    } catch (err) {\n      log.warn(err);\n    }\n\n    if (values) {\n      this.setValues(values);\n    }\n  };\n\n  /**\n   * Save text track settings to localStorage\n   */\n\n\n  TextTrackSettings.prototype.saveSettings = function saveSettings() {\n    if (!this.options_.persistTextTrackSettings) {\n      return;\n    }\n\n    var values = this.getValues();\n\n    try {\n      if (Object.keys(values).length) {\n        window.localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(values));\n      } else {\n        window.localStorage.removeItem(LOCAL_STORAGE_KEY);\n      }\n    } catch (err) {\n      log.warn(err);\n    }\n  };\n\n  /**\n   * Update display of text track settings\n   */\n\n\n  TextTrackSettings.prototype.updateDisplay = function updateDisplay() {\n    var ttDisplay = this.player_.getChild('textTrackDisplay');\n\n    if (ttDisplay) {\n      ttDisplay.updateDisplay();\n    }\n  };\n\n  /**\n   * conditionally blur the element and refocus the captions button\n   *\n   * @private\n   */\n\n\n  TextTrackSettings.prototype.conditionalBlur_ = function conditionalBlur_() {\n    this.previouslyActiveEl_ = null;\n    this.off(document, 'keydown', this.handleKeyDown);\n\n    var cb = this.player_.controlBar;\n    var subsCapsBtn = cb && cb.subsCapsButton;\n    var ccBtn = cb && cb.captionsButton;\n\n    if (subsCapsBtn) {\n      subsCapsBtn.focus();\n    } else if (ccBtn) {\n      ccBtn.focus();\n    }\n  };\n\n  return TextTrackSettings;\n}(ModalDialog);\n\nComponent.registerComponent('TextTrackSettings', TextTrackSettings);\n\n/**\n * @file resize-manager.js\n */\n/**\n * A Resize Manager. It is in charge of triggering `playerresize` on the player in the right conditions.\n *\n * It'll either create an iframe and use a debounced resize handler on it or use the new {@link https://wicg.github.io/ResizeObserver/|ResizeObserver}.\n *\n * If the ResizeObserver is available natively, it will be used. A polyfill can be passed in as an option.\n * If a `playerresize` event is not needed, the ResizeManager component can be removed from the player, see the example below.\n * @example <caption>How to disable the resize manager</caption>\n * const player = videojs('#vid', {\n *   resizeManager: false\n * });\n *\n * @see {@link https://wicg.github.io/ResizeObserver/|ResizeObserver specification}\n *\n * @extends Component\n */\n\nvar ResizeManager = function (_Component) {\n  inherits(ResizeManager, _Component);\n\n  /**\n   * Create the ResizeManager.\n   *\n   * @param {Object} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of ResizeManager options.\n   *\n   * @param {Object} [options.ResizeObserver]\n   *        A polyfill for ResizeObserver can be passed in here.\n   *        If this is set to null it will ignore the native ResizeObserver and fall back to the iframe fallback.\n   */\n  function ResizeManager(player, options) {\n    classCallCheck(this, ResizeManager);\n\n    var RESIZE_OBSERVER_AVAILABLE = options.ResizeObserver || window.ResizeObserver;\n\n    // if `null` was passed, we want to disable the ResizeObserver\n    if (options.ResizeObserver === null) {\n      RESIZE_OBSERVER_AVAILABLE = false;\n    }\n\n    // Only create an element when ResizeObserver isn't available\n    var options_ = mergeOptions({ createEl: !RESIZE_OBSERVER_AVAILABLE }, options);\n\n    var _this = possibleConstructorReturn(this, _Component.call(this, player, options_));\n\n    _this.ResizeObserver = options.ResizeObserver || window.ResizeObserver;\n    _this.loadListener_ = null;\n    _this.resizeObserver_ = null;\n    _this.debouncedHandler_ = debounce(function () {\n      _this.resizeHandler();\n    }, 100, false, _this);\n\n    if (RESIZE_OBSERVER_AVAILABLE) {\n      _this.resizeObserver_ = new _this.ResizeObserver(_this.debouncedHandler_);\n      _this.resizeObserver_.observe(player.el());\n    } else {\n      _this.loadListener_ = function () {\n        if (!_this.el_ || !_this.el_.contentWindow) {\n          return;\n        }\n\n        on(_this.el_.contentWindow, 'resize', _this.debouncedHandler_);\n      };\n\n      _this.one('load', _this.loadListener_);\n    }\n    return _this;\n  }\n\n  ResizeManager.prototype.createEl = function createEl() {\n    return _Component.prototype.createEl.call(this, 'iframe', {\n      className: 'vjs-resize-manager'\n    });\n  };\n\n  /**\n   * Called when a resize is triggered on the iframe or a resize is observed via the ResizeObserver\n   *\n   * @fires Player#playerresize\n   */\n\n\n  ResizeManager.prototype.resizeHandler = function resizeHandler() {\n    /**\n     * Called when the player size has changed\n     *\n     * @event Player#playerresize\n     * @type {EventTarget~Event}\n     */\n    // make sure player is still around to trigger\n    // prevents this from causing an error after dispose\n    if (!this.player_ || !this.player_.trigger) {\n      return;\n    }\n\n    this.player_.trigger('playerresize');\n  };\n\n  ResizeManager.prototype.dispose = function dispose() {\n    if (this.debouncedHandler_) {\n      this.debouncedHandler_.cancel();\n    }\n\n    if (this.resizeObserver_) {\n      if (this.player_.el()) {\n        this.resizeObserver_.unobserve(this.player_.el());\n      }\n      this.resizeObserver_.disconnect();\n    }\n\n    if (this.el_ && this.el_.contentWindow) {\n      off(this.el_.contentWindow, 'resize', this.debouncedHandler_);\n    }\n\n    if (this.loadListener_) {\n      this.off('load', this.loadListener_);\n    }\n\n    this.ResizeObserver = null;\n    this.resizeObserver = null;\n    this.debouncedHandler_ = null;\n    this.loadListener_ = null;\n  };\n\n  return ResizeManager;\n}(Component);\n\nComponent.registerComponent('ResizeManager', ResizeManager);\n\n/**\n * This function is used to fire a sourceset when there is something\n * similar to `mediaEl.load()` being called. It will try to find the source via\n * the `src` attribute and then the `<source>` elements. It will then fire `sourceset`\n * with the source that was found or empty string if we cannot know. If it cannot\n * find a source then `sourceset` will not be fired.\n *\n * @param {Html5} tech\n *        The tech object that sourceset was setup on\n *\n * @return {boolean}\n *         returns false if the sourceset was not fired and true otherwise.\n */\nvar sourcesetLoad = function sourcesetLoad(tech) {\n  var el = tech.el();\n\n  // if `el.src` is set, that source will be loaded.\n  if (el.hasAttribute('src')) {\n    tech.triggerSourceset(el.src);\n    return true;\n  }\n\n  /**\n   * Since there isn't a src property on the media element, source elements will be used for\n   * implementing the source selection algorithm. This happens asynchronously and\n   * for most cases were there is more than one source we cannot tell what source will\n   * be loaded, without re-implementing the source selection algorithm. At this time we are not\n   * going to do that. There are three special cases that we do handle here though:\n   *\n   * 1. If there are no sources, do not fire `sourceset`.\n   * 2. If there is only one `<source>` with a `src` property/attribute that is our `src`\n   * 3. If there is more than one `<source>` but all of them have the same `src` url.\n   *    That will be our src.\n   */\n  var sources = tech.$$('source');\n  var srcUrls = [];\n  var src = '';\n\n  // if there are no sources, do not fire sourceset\n  if (!sources.length) {\n    return false;\n  }\n\n  // only count valid/non-duplicate source elements\n  for (var i = 0; i < sources.length; i++) {\n    var url = sources[i].src;\n\n    if (url && srcUrls.indexOf(url) === -1) {\n      srcUrls.push(url);\n    }\n  }\n\n  // there were no valid sources\n  if (!srcUrls.length) {\n    return false;\n  }\n\n  // there is only one valid source element url\n  // use that\n  if (srcUrls.length === 1) {\n    src = srcUrls[0];\n  }\n\n  tech.triggerSourceset(src);\n  return true;\n};\n\n/**\n * our implementation of an `innerHTML` descriptor for browsers\n * that do not have one.\n */\nvar innerHTMLDescriptorPolyfill = {};\n\nif (!IS_IE8) {\n  innerHTMLDescriptorPolyfill = Object.defineProperty({}, 'innerHTML', {\n    get: function get() {\n      return this.cloneNode(true).innerHTML;\n    },\n    set: function set(v) {\n      // make a dummy node to use innerHTML on\n      var dummy = document.createElement(this.nodeName.toLowerCase());\n\n      // set innerHTML to the value provided\n      dummy.innerHTML = v;\n\n      // make a document fragment to hold the nodes from dummy\n      var docFrag = document.createDocumentFragment();\n\n      // copy all of the nodes created by the innerHTML on dummy\n      // to the document fragment\n      while (dummy.childNodes.length) {\n        docFrag.appendChild(dummy.childNodes[0]);\n      }\n\n      // remove content\n      this.innerText = '';\n\n      // now we add all of that html in one by appending the\n      // document fragment. This is how innerHTML does it.\n      window.Element.prototype.appendChild.call(this, docFrag);\n\n      // then return the result that innerHTML's setter would\n      return this.innerHTML;\n    }\n  });\n}\n/**\n * Get a property descriptor given a list of priorities and the\n * property to get.\n */\nvar getDescriptor = function getDescriptor(priority, prop) {\n  var descriptor = {};\n\n  for (var i = 0; i < priority.length; i++) {\n    descriptor = Object.getOwnPropertyDescriptor(priority[i], prop);\n\n    if (descriptor && descriptor.set && descriptor.get) {\n      break;\n    }\n  }\n\n  descriptor.enumerable = true;\n  descriptor.configurable = true;\n\n  return descriptor;\n};\n\nvar getInnerHTMLDescriptor = function getInnerHTMLDescriptor(tech) {\n  return getDescriptor([tech.el(), window.HTMLMediaElement.prototype, window.Element.prototype, innerHTMLDescriptorPolyfill], 'innerHTML');\n};\n\n/**\n * Patches browser internal functions so that we can tell syncronously\n * if a `<source>` was appended to the media element. For some reason this\n * causes a `sourceset` if the the media element is ready and has no source.\n * This happens when:\n * - The page has just loaded and the media element does not have a source.\n * - The media element was emptied of all sources, then `load()` was called.\n *\n * It does this by patching the following functions/properties when they are supported:\n *\n * - `append()` - can be used to add a `<source>` element to the media element\n * - `appendChild()` - can be used to add a `<source>` element to the media element\n * - `insertAdjacentHTML()` -  can be used to add a `<source>` element to the media element\n * - `innerHTML` -  can be used to add a `<source>` element to the media element\n *\n * @param {Html5} tech\n *        The tech object that sourceset is being setup on.\n */\nvar firstSourceWatch = function firstSourceWatch(tech) {\n  var el = tech.el();\n\n  // make sure firstSourceWatch isn't setup twice.\n  if (el.resetSourceWatch_) {\n    return;\n  }\n\n  var old = {};\n  var innerDescriptor = getInnerHTMLDescriptor(tech);\n  var appendWrapper = function appendWrapper(appendFn) {\n    return function () {\n      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      var retval = appendFn.apply(el, args);\n\n      sourcesetLoad(tech);\n\n      return retval;\n    };\n  };\n\n  ['append', 'appendChild', 'insertAdjacentHTML'].forEach(function (k) {\n    if (!el[k]) {\n      return;\n    }\n\n    // store the old function\n    old[k] = el[k];\n\n    // call the old function with a sourceset if a source\n    // was loaded\n    el[k] = appendWrapper(old[k]);\n  });\n\n  Object.defineProperty(el, 'innerHTML', mergeOptions(innerDescriptor, {\n    set: appendWrapper(innerDescriptor.set)\n  }));\n\n  el.resetSourceWatch_ = function () {\n    el.resetSourceWatch_ = null;\n    Object.keys(old).forEach(function (k) {\n      el[k] = old[k];\n    });\n\n    Object.defineProperty(el, 'innerHTML', innerDescriptor);\n  };\n\n  // on the first sourceset, we need to revert our changes\n  tech.one('sourceset', el.resetSourceWatch_);\n};\n\n/**\n * our implementation of a `src` descriptor for browsers\n * that do not have one.\n */\n\nvar srcDescriptorPolyfill = {};\n\nif (!IS_IE8) {\n  srcDescriptorPolyfill = Object.defineProperty({}, 'src', {\n    get: function get() {\n      if (this.hasAttribute('src')) {\n        return getAbsoluteURL(window.Element.prototype.getAttribute.call(this, 'src'));\n      }\n\n      return '';\n    },\n    set: function set(v) {\n      window.Element.prototype.setAttribute.call(this, 'src', v);\n\n      return v;\n    }\n  });\n}\n\nvar getSrcDescriptor = function getSrcDescriptor(tech) {\n  return getDescriptor([tech.el(), window.HTMLMediaElement.prototype, srcDescriptorPolyfill], 'src');\n};\n\n/**\n * setup `sourceset` handling on the `Html5` tech. This function\n * patches the following element properties/functions:\n *\n * - `src` - to determine when `src` is set\n * - `setAttribute()` - to determine when `src` is set\n * - `load()` - this re-triggers the source selection algorithm, and can\n *              cause a sourceset.\n *\n * If there is no source when we are adding `sourceset` support or during a `load()`\n * we also patch the functions listed in `firstSourceWatch`.\n *\n * @param {Html5} tech\n *        The tech to patch\n */\nvar setupSourceset = function setupSourceset(tech) {\n  if (!tech.featuresSourceset) {\n    return;\n  }\n\n  var el = tech.el();\n\n  // make sure sourceset isn't setup twice.\n  if (el.resetSourceset_) {\n    return;\n  }\n\n  var srcDescriptor = getSrcDescriptor(tech);\n  var oldSetAttribute = el.setAttribute;\n  var oldLoad = el.load;\n\n  Object.defineProperty(el, 'src', mergeOptions(srcDescriptor, {\n    set: function set(v) {\n      var retval = srcDescriptor.set.call(el, v);\n\n      // we use the getter here to get the actual value set on src\n      tech.triggerSourceset(el.src);\n\n      return retval;\n    }\n  }));\n\n  el.setAttribute = function (n, v) {\n    var retval = oldSetAttribute.call(el, n, v);\n\n    if (/src/i.test(n)) {\n      tech.triggerSourceset(el.src);\n    }\n\n    return retval;\n  };\n\n  el.load = function () {\n    var retval = oldLoad.call(el);\n\n    // if load was called, but there was no source to fire\n    // sourceset on. We have to watch for a source append\n    // as that can trigger a `sourceset` when the media element\n    // has no source\n    if (!sourcesetLoad(tech)) {\n      tech.triggerSourceset('');\n      firstSourceWatch(tech);\n    }\n\n    return retval;\n  };\n\n  if (el.currentSrc) {\n    tech.triggerSourceset(el.currentSrc);\n  } else if (!sourcesetLoad(tech)) {\n    firstSourceWatch(tech);\n  }\n\n  el.resetSourceset_ = function () {\n    el.resetSourceset_ = null;\n    el.load = oldLoad;\n    el.setAttribute = oldSetAttribute;\n    Object.defineProperty(el, 'src', srcDescriptor);\n    if (el.resetSourceWatch_) {\n      el.resetSourceWatch_();\n    }\n  };\n};\n\nvar _templateObject$2 = taggedTemplateLiteralLoose(['Text Tracks are being loaded from another origin but the crossorigin attribute isn\\'t used.\\n            This may prevent text tracks from loading.'], ['Text Tracks are being loaded from another origin but the crossorigin attribute isn\\'t used.\\n            This may prevent text tracks from loading.']);\n\n/**\n * @file html5.js\n */\n/**\n * HTML5 Media Controller - Wrapper for HTML5 Media API\n *\n * @mixes Tech~SouceHandlerAdditions\n * @extends Tech\n */\n\nvar Html5 = function (_Tech) {\n  inherits(Html5, _Tech);\n\n  /**\n   * Create an instance of this Tech.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   *\n   * @param {Component~ReadyCallback} ready\n   *        Callback function to call when the `HTML5` Tech is ready.\n   */\n  function Html5(options, ready) {\n    classCallCheck(this, Html5);\n\n    var _this = possibleConstructorReturn(this, _Tech.call(this, options, ready));\n\n    var source = options.source;\n    var crossoriginTracks = false;\n\n    // Set the source if one is provided\n    // 1) Check if the source is new (if not, we want to keep the original so playback isn't interrupted)\n    // 2) Check to see if the network state of the tag was failed at init, and if so, reset the source\n    // anyway so the error gets fired.\n    if (source && (_this.el_.currentSrc !== source.src || options.tag && options.tag.initNetworkState_ === 3)) {\n      _this.setSource(source);\n    } else {\n      _this.handleLateInit_(_this.el_);\n    }\n\n    // setup sourceset after late sourceset/init\n    if (options.enableSourceset) {\n      _this.setupSourcesetHandling_();\n    }\n\n    if (_this.el_.hasChildNodes()) {\n\n      var nodes = _this.el_.childNodes;\n      var nodesLength = nodes.length;\n      var removeNodes = [];\n\n      while (nodesLength--) {\n        var node = nodes[nodesLength];\n        var nodeName = node.nodeName.toLowerCase();\n\n        if (nodeName === 'track') {\n          if (!_this.featuresNativeTextTracks) {\n            // Empty video tag tracks so the built-in player doesn't use them also.\n            // This may not be fast enough to stop HTML5 browsers from reading the tags\n            // so we'll need to turn off any default tracks if we're manually doing\n            // captions and subtitles. videoElement.textTracks\n            removeNodes.push(node);\n          } else {\n            // store HTMLTrackElement and TextTrack to remote list\n            _this.remoteTextTrackEls().addTrackElement_(node);\n            _this.remoteTextTracks().addTrack(node.track);\n            _this.textTracks().addTrack(node.track);\n            if (!crossoriginTracks && !_this.el_.hasAttribute('crossorigin') && isCrossOrigin(node.src)) {\n              crossoriginTracks = true;\n            }\n          }\n        }\n      }\n\n      for (var i = 0; i < removeNodes.length; i++) {\n        _this.el_.removeChild(removeNodes[i]);\n      }\n    }\n\n    _this.proxyNativeTracks_();\n    if (_this.featuresNativeTextTracks && crossoriginTracks) {\n      log.warn(tsml(_templateObject$2));\n    }\n\n    // prevent iOS Safari from disabling metadata text tracks during native playback\n    _this.restoreMetadataTracksInIOSNativePlayer_();\n\n    // Determine if native controls should be used\n    // Our goal should be to get the custom controls on mobile solid everywhere\n    // so we can remove this all together. Right now this will block custom\n    // controls on touch enabled laptops like the Chrome Pixel\n    if ((TOUCH_ENABLED || IS_IPHONE || IS_NATIVE_ANDROID) && options.nativeControlsForTouch === true) {\n      _this.setControls(true);\n    }\n\n    // on iOS, we want to proxy `webkitbeginfullscreen` and `webkitendfullscreen`\n    // into a `fullscreenchange` event\n    _this.proxyWebkitFullscreen_();\n\n    _this.triggerReady();\n    return _this;\n  }\n\n  /**\n   * Dispose of `HTML5` media element and remove all tracks.\n   */\n\n\n  Html5.prototype.dispose = function dispose() {\n    if (this.el_ && this.el_.resetSourceset_) {\n      this.el_.resetSourceset_();\n    }\n    Html5.disposeMediaElement(this.el_);\n    this.options_ = null;\n\n    // tech will handle clearing of the emulated track list\n    _Tech.prototype.dispose.call(this);\n  };\n\n  /**\n   * Modify the media element so that we can detect when\n   * the source is changed. Fires `sourceset` just after the source has changed\n   */\n\n\n  Html5.prototype.setupSourcesetHandling_ = function setupSourcesetHandling_() {\n    setupSourceset(this);\n  };\n\n  /**\n   * When a captions track is enabled in the iOS Safari native player, all other\n   * tracks are disabled (including metadata tracks), which nulls all of their\n   * associated cue points. This will restore metadata tracks to their pre-fullscreen\n   * state in those cases so that cue points are not needlessly lost.\n   *\n   * @private\n   */\n\n\n  Html5.prototype.restoreMetadataTracksInIOSNativePlayer_ = function restoreMetadataTracksInIOSNativePlayer_() {\n    var textTracks = this.textTracks();\n    var metadataTracksPreFullscreenState = void 0;\n\n    // captures a snapshot of every metadata track's current state\n    var takeMetadataTrackSnapshot = function takeMetadataTrackSnapshot() {\n      metadataTracksPreFullscreenState = [];\n\n      for (var i = 0; i < textTracks.length; i++) {\n        var track = textTracks[i];\n\n        if (track.kind === 'metadata') {\n          metadataTracksPreFullscreenState.push({\n            track: track,\n            storedMode: track.mode\n          });\n        }\n      }\n    };\n\n    // snapshot each metadata track's initial state, and update the snapshot\n    // each time there is a track 'change' event\n    takeMetadataTrackSnapshot();\n    textTracks.addEventListener('change', takeMetadataTrackSnapshot);\n\n    this.on('dispose', function () {\n      return textTracks.removeEventListener('change', takeMetadataTrackSnapshot);\n    });\n\n    var restoreTrackMode = function restoreTrackMode() {\n      for (var i = 0; i < metadataTracksPreFullscreenState.length; i++) {\n        var storedTrack = metadataTracksPreFullscreenState[i];\n\n        if (storedTrack.track.mode === 'disabled' && storedTrack.track.mode !== storedTrack.storedMode) {\n          storedTrack.track.mode = storedTrack.storedMode;\n        }\n      }\n      // we only want this handler to be executed on the first 'change' event\n      textTracks.removeEventListener('change', restoreTrackMode);\n    };\n\n    // when we enter fullscreen playback, stop updating the snapshot and\n    // restore all track modes to their pre-fullscreen state\n    this.on('webkitbeginfullscreen', function () {\n      textTracks.removeEventListener('change', takeMetadataTrackSnapshot);\n\n      // remove the listener before adding it just in case it wasn't previously removed\n      textTracks.removeEventListener('change', restoreTrackMode);\n      textTracks.addEventListener('change', restoreTrackMode);\n    });\n\n    // start updating the snapshot again after leaving fullscreen\n    this.on('webkitendfullscreen', function () {\n      // remove the listener before adding it just in case it wasn't previously removed\n      textTracks.removeEventListener('change', takeMetadataTrackSnapshot);\n      textTracks.addEventListener('change', takeMetadataTrackSnapshot);\n\n      // remove the restoreTrackMode handler in case it wasn't triggered during fullscreen playback\n      textTracks.removeEventListener('change', restoreTrackMode);\n    });\n  };\n\n  /**\n   * Proxy all native track list events to our track lists if the browser we are playing\n   * in supports that type of track list.\n   *\n   * @private\n   */\n\n\n  Html5.prototype.proxyNativeTracks_ = function proxyNativeTracks_() {\n    var _this2 = this;\n\n    NORMAL.names.forEach(function (name) {\n      var props = NORMAL[name];\n      var elTracks = _this2.el()[props.getterName];\n      var techTracks = _this2[props.getterName]();\n\n      if (!_this2['featuresNative' + props.capitalName + 'Tracks'] || !elTracks || !elTracks.addEventListener) {\n        return;\n      }\n      var listeners = {\n        change: function change(e) {\n          techTracks.trigger({\n            type: 'change',\n            target: techTracks,\n            currentTarget: techTracks,\n            srcElement: techTracks\n          });\n        },\n        addtrack: function addtrack(e) {\n          techTracks.addTrack(e.track);\n        },\n        removetrack: function removetrack(e) {\n          techTracks.removeTrack(e.track);\n        }\n      };\n      var removeOldTracks = function removeOldTracks() {\n        var removeTracks = [];\n\n        for (var i = 0; i < techTracks.length; i++) {\n          var found = false;\n\n          for (var j = 0; j < elTracks.length; j++) {\n            if (elTracks[j] === techTracks[i]) {\n              found = true;\n              break;\n            }\n          }\n\n          if (!found) {\n            removeTracks.push(techTracks[i]);\n          }\n        }\n\n        while (removeTracks.length) {\n          techTracks.removeTrack(removeTracks.shift());\n        }\n      };\n\n      Object.keys(listeners).forEach(function (eventName) {\n        var listener = listeners[eventName];\n\n        elTracks.addEventListener(eventName, listener);\n        _this2.on('dispose', function (e) {\n          return elTracks.removeEventListener(eventName, listener);\n        });\n      });\n\n      // Remove (native) tracks that are not used anymore\n      _this2.on('loadstart', removeOldTracks);\n      _this2.on('dispose', function (e) {\n        return _this2.off('loadstart', removeOldTracks);\n      });\n    });\n  };\n\n  /**\n   * Create the `Html5` Tech's DOM element.\n   *\n   * @return {Element}\n   *         The element that gets created.\n   */\n\n\n  Html5.prototype.createEl = function createEl$$1() {\n    var el = this.options_.tag;\n\n    // Check if this browser supports moving the element into the box.\n    // On the iPhone video will break if you move the element,\n    // So we have to create a brand new element.\n    // If we ingested the player div, we do not need to move the media element.\n    if (!el || !(this.options_.playerElIngest || this.movingMediaElementInDOM)) {\n\n      // If the original tag is still there, clone and remove it.\n      if (el) {\n        var clone = el.cloneNode(true);\n\n        if (el.parentNode) {\n          el.parentNode.insertBefore(clone, el);\n        }\n        Html5.disposeMediaElement(el);\n        el = clone;\n      } else {\n        el = document.createElement('video');\n\n        // determine if native controls should be used\n        var tagAttributes = this.options_.tag && getAttributes(this.options_.tag);\n        var attributes = mergeOptions({}, tagAttributes);\n\n        if (!TOUCH_ENABLED || this.options_.nativeControlsForTouch !== true) {\n          delete attributes.controls;\n        }\n\n        setAttributes(el, assign(attributes, {\n          id: this.options_.techId,\n          'class': 'vjs-tech'\n        }));\n      }\n\n      el.playerId = this.options_.playerId;\n    }\n\n    if (typeof this.options_.preload !== 'undefined') {\n      setAttribute(el, 'preload', this.options_.preload);\n    }\n\n    // Update specific tag settings, in case they were overridden\n    // `autoplay` has to be *last* so that `muted` and `playsinline` are present\n    // when iOS/Safari or other browsers attempt to autoplay.\n    var settingsAttrs = ['loop', 'muted', 'playsinline', 'autoplay'];\n\n    for (var i = 0; i < settingsAttrs.length; i++) {\n      var attr = settingsAttrs[i];\n      var value = this.options_[attr];\n\n      if (typeof value !== 'undefined') {\n        if (value) {\n          setAttribute(el, attr, attr);\n        } else {\n          removeAttribute(el, attr);\n        }\n        el[attr] = value;\n      }\n    }\n\n    return el;\n  };\n\n  /**\n   * This will be triggered if the loadstart event has already fired, before videojs was\n   * ready. Two known examples of when this can happen are:\n   * 1. If we're loading the playback object after it has started loading\n   * 2. The media is already playing the (often with autoplay on) then\n   *\n   * This function will fire another loadstart so that videojs can catchup.\n   *\n   * @fires Tech#loadstart\n   *\n   * @return {undefined}\n   *         returns nothing.\n   */\n\n\n  Html5.prototype.handleLateInit_ = function handleLateInit_(el) {\n    if (el.networkState === 0 || el.networkState === 3) {\n      // The video element hasn't started loading the source yet\n      // or didn't find a source\n      return;\n    }\n\n    if (el.readyState === 0) {\n      // NetworkState is set synchronously BUT loadstart is fired at the\n      // end of the current stack, usually before setInterval(fn, 0).\n      // So at this point we know loadstart may have already fired or is\n      // about to fire, and either way the player hasn't seen it yet.\n      // We don't want to fire loadstart prematurely here and cause a\n      // double loadstart so we'll wait and see if it happens between now\n      // and the next loop, and fire it if not.\n      // HOWEVER, we also want to make sure it fires before loadedmetadata\n      // which could also happen between now and the next loop, so we'll\n      // watch for that also.\n      var loadstartFired = false;\n      var setLoadstartFired = function setLoadstartFired() {\n        loadstartFired = true;\n      };\n\n      this.on('loadstart', setLoadstartFired);\n\n      var triggerLoadstart = function triggerLoadstart() {\n        // We did miss the original loadstart. Make sure the player\n        // sees loadstart before loadedmetadata\n        if (!loadstartFired) {\n          this.trigger('loadstart');\n        }\n      };\n\n      this.on('loadedmetadata', triggerLoadstart);\n\n      this.ready(function () {\n        this.off('loadstart', setLoadstartFired);\n        this.off('loadedmetadata', triggerLoadstart);\n\n        if (!loadstartFired) {\n          // We did miss the original native loadstart. Fire it now.\n          this.trigger('loadstart');\n        }\n      });\n\n      return;\n    }\n\n    // From here on we know that loadstart already fired and we missed it.\n    // The other readyState events aren't as much of a problem if we double\n    // them, so not going to go to as much trouble as loadstart to prevent\n    // that unless we find reason to.\n    var eventsToTrigger = ['loadstart'];\n\n    // loadedmetadata: newly equal to HAVE_METADATA (1) or greater\n    eventsToTrigger.push('loadedmetadata');\n\n    // loadeddata: newly increased to HAVE_CURRENT_DATA (2) or greater\n    if (el.readyState >= 2) {\n      eventsToTrigger.push('loadeddata');\n    }\n\n    // canplay: newly increased to HAVE_FUTURE_DATA (3) or greater\n    if (el.readyState >= 3) {\n      eventsToTrigger.push('canplay');\n    }\n\n    // canplaythrough: newly equal to HAVE_ENOUGH_DATA (4)\n    if (el.readyState >= 4) {\n      eventsToTrigger.push('canplaythrough');\n    }\n\n    // We still need to give the player time to add event listeners\n    this.ready(function () {\n      eventsToTrigger.forEach(function (type) {\n        this.trigger(type);\n      }, this);\n    });\n  };\n\n  /**\n   * Set current time for the `HTML5` tech.\n   *\n   * @param {number} seconds\n   *        Set the current time of the media to this.\n   */\n\n\n  Html5.prototype.setCurrentTime = function setCurrentTime(seconds) {\n    try {\n      this.el_.currentTime = seconds;\n    } catch (e) {\n      log(e, 'Video is not ready. (Video.js)');\n      // this.warning(VideoJS.warnings.videoNotReady);\n    }\n  };\n\n  /**\n   * Get the current duration of the HTML5 media element.\n   *\n   * @return {number}\n   *         The duration of the media or 0 if there is no duration.\n   */\n\n\n  Html5.prototype.duration = function duration() {\n    var _this3 = this;\n\n    // Android Chrome will report duration as Infinity for VOD HLS until after\n    // playback has started, which triggers the live display erroneously.\n    // Return NaN if playback has not started and trigger a durationupdate once\n    // the duration can be reliably known.\n    if (this.el_.duration === Infinity && IS_ANDROID && IS_CHROME && this.el_.currentTime === 0) {\n      // Wait for the first `timeupdate` with currentTime > 0 - there may be\n      // several with 0\n      var checkProgress = function checkProgress() {\n        if (_this3.el_.currentTime > 0) {\n          // Trigger durationchange for genuinely live video\n          if (_this3.el_.duration === Infinity) {\n            _this3.trigger('durationchange');\n          }\n          _this3.off('timeupdate', checkProgress);\n        }\n      };\n\n      this.on('timeupdate', checkProgress);\n      return NaN;\n    }\n    return this.el_.duration || NaN;\n  };\n\n  /**\n   * Get the current width of the HTML5 media element.\n   *\n   * @return {number}\n   *         The width of the HTML5 media element.\n   */\n\n\n  Html5.prototype.width = function width() {\n    return this.el_.offsetWidth;\n  };\n\n  /**\n   * Get the current height of the HTML5 media element.\n   *\n   * @return {number}\n   *         The heigth of the HTML5 media element.\n   */\n\n\n  Html5.prototype.height = function height() {\n    return this.el_.offsetHeight;\n  };\n\n  /**\n   * Proxy iOS `webkitbeginfullscreen` and `webkitendfullscreen` into\n   * `fullscreenchange` event.\n   *\n   * @private\n   * @fires fullscreenchange\n   * @listens webkitendfullscreen\n   * @listens webkitbeginfullscreen\n   * @listens webkitbeginfullscreen\n   */\n\n\n  Html5.prototype.proxyWebkitFullscreen_ = function proxyWebkitFullscreen_() {\n    var _this4 = this;\n\n    if (!('webkitDisplayingFullscreen' in this.el_)) {\n      return;\n    }\n\n    var endFn = function endFn() {\n      this.trigger('fullscreenchange', { isFullscreen: false });\n    };\n\n    var beginFn = function beginFn() {\n      if ('webkitPresentationMode' in this.el_ && this.el_.webkitPresentationMode !== 'picture-in-picture') {\n        this.one('webkitendfullscreen', endFn);\n\n        this.trigger('fullscreenchange', { isFullscreen: true });\n      }\n    };\n\n    this.on('webkitbeginfullscreen', beginFn);\n    this.on('dispose', function () {\n      _this4.off('webkitbeginfullscreen', beginFn);\n      _this4.off('webkitendfullscreen', endFn);\n    });\n  };\n\n  /**\n   * Check if fullscreen is supported on the current playback device.\n   *\n   * @return {boolean}\n   *         - True if fullscreen is supported.\n   *         - False if fullscreen is not supported.\n   */\n\n\n  Html5.prototype.supportsFullScreen = function supportsFullScreen() {\n    if (typeof this.el_.webkitEnterFullScreen === 'function') {\n      var userAgent = window.navigator && window.navigator.userAgent || '';\n\n      // Seems to be broken in Chromium/Chrome && Safari in Leopard\n      if (/Android/.test(userAgent) || !/Chrome|Mac OS X 10.5/.test(userAgent)) {\n        return true;\n      }\n    }\n    return false;\n  };\n\n  /**\n   * Request that the `HTML5` Tech enter fullscreen.\n   */\n\n\n  Html5.prototype.enterFullScreen = function enterFullScreen() {\n    var video = this.el_;\n\n    if (video.paused && video.networkState <= video.HAVE_METADATA) {\n      // attempt to prime the video element for programmatic access\n      // this isn't necessary on the desktop but shouldn't hurt\n      this.el_.play();\n\n      // playing and pausing synchronously during the transition to fullscreen\n      // can get iOS ~6.1 devices into a play/pause loop\n      this.setTimeout(function () {\n        video.pause();\n        video.webkitEnterFullScreen();\n      }, 0);\n    } else {\n      video.webkitEnterFullScreen();\n    }\n  };\n\n  /**\n   * Request that the `HTML5` Tech exit fullscreen.\n   */\n\n\n  Html5.prototype.exitFullScreen = function exitFullScreen() {\n    this.el_.webkitExitFullScreen();\n  };\n\n  /**\n   * A getter/setter for the `Html5` Tech's source object.\n   * > Note: Please use {@link Html5#setSource}\n   *\n   * @param {Tech~SourceObject} [src]\n   *        The source object you want to set on the `HTML5` techs element.\n   *\n   * @return {Tech~SourceObject|undefined}\n   *         - The current source object when a source is not passed in.\n   *         - undefined when setting\n   *\n   * @deprecated Since version 5.\n   */\n\n\n  Html5.prototype.src = function src(_src) {\n    if (_src === undefined) {\n      return this.el_.src;\n    }\n\n    // Setting src through `src` instead of `setSrc` will be deprecated\n    this.setSrc(_src);\n  };\n\n  /**\n   * Reset the tech by removing all sources and then calling\n   * {@link Html5.resetMediaElement}.\n   */\n\n\n  Html5.prototype.reset = function reset() {\n    Html5.resetMediaElement(this.el_);\n  };\n\n  /**\n   * Get the current source on the `HTML5` Tech. Falls back to returning the source from\n   * the HTML5 media element.\n   *\n   * @return {Tech~SourceObject}\n   *         The current source object from the HTML5 tech. With a fallback to the\n   *         elements source.\n   */\n\n\n  Html5.prototype.currentSrc = function currentSrc() {\n    if (this.currentSource_) {\n      return this.currentSource_.src;\n    }\n    return this.el_.currentSrc;\n  };\n\n  /**\n   * Set controls attribute for the HTML5 media Element.\n   *\n   * @param {string} val\n   *        Value to set the controls attribute to\n   */\n\n\n  Html5.prototype.setControls = function setControls(val) {\n    this.el_.controls = !!val;\n  };\n\n  /**\n   * Create and returns a remote {@link TextTrack} object.\n   *\n   * @param {string} kind\n   *        `TextTrack` kind (subtitles, captions, descriptions, chapters, or metadata)\n   *\n   * @param {string} [label]\n   *        Label to identify the text track\n   *\n   * @param {string} [language]\n   *        Two letter language abbreviation\n   *\n   * @return {TextTrack}\n   *         The TextTrack that gets created.\n   */\n\n\n  Html5.prototype.addTextTrack = function addTextTrack(kind, label, language) {\n    if (!this.featuresNativeTextTracks) {\n      return _Tech.prototype.addTextTrack.call(this, kind, label, language);\n    }\n\n    return this.el_.addTextTrack(kind, label, language);\n  };\n\n  /**\n   * Creates either native TextTrack or an emulated TextTrack depending\n   * on the value of `featuresNativeTextTracks`\n   *\n   * @param {Object} options\n   *        The object should contain the options to intialize the TextTrack with.\n   *\n   * @param {string} [options.kind]\n   *        `TextTrack` kind (subtitles, captions, descriptions, chapters, or metadata).\n   *\n   * @param {string} [options.label].\n   *        Label to identify the text track\n   *\n   * @param {string} [options.language]\n   *        Two letter language abbreviation.\n   *\n   * @param {boolean} [options.default]\n   *        Default this track to on.\n   *\n   * @param {string} [options.id]\n   *        The internal id to assign this track.\n   *\n   * @param {string} [options.src]\n   *        A source url for the track.\n   *\n   * @return {HTMLTrackElement}\n   *         The track element that gets created.\n   */\n\n\n  Html5.prototype.createRemoteTextTrack = function createRemoteTextTrack(options) {\n    if (!this.featuresNativeTextTracks) {\n      return _Tech.prototype.createRemoteTextTrack.call(this, options);\n    }\n    var htmlTrackElement = document.createElement('track');\n\n    if (options.kind) {\n      htmlTrackElement.kind = options.kind;\n    }\n    if (options.label) {\n      htmlTrackElement.label = options.label;\n    }\n    if (options.language || options.srclang) {\n      htmlTrackElement.srclang = options.language || options.srclang;\n    }\n    if (options['default']) {\n      htmlTrackElement['default'] = options['default'];\n    }\n    if (options.id) {\n      htmlTrackElement.id = options.id;\n    }\n    if (options.src) {\n      htmlTrackElement.src = options.src;\n    }\n\n    return htmlTrackElement;\n  };\n\n  /**\n   * Creates a remote text track object and returns an html track element.\n   *\n   * @param {Object} options The object should contain values for\n   * kind, language, label, and src (location of the WebVTT file)\n   * @param {Boolean} [manualCleanup=true] if set to false, the TextTrack will be\n   * automatically removed from the video element whenever the source changes\n   * @return {HTMLTrackElement} An Html Track Element.\n   * This can be an emulated {@link HTMLTrackElement} or a native one.\n   * @deprecated The default value of the \"manualCleanup\" parameter will default\n   * to \"false\" in upcoming versions of Video.js\n   */\n\n\n  Html5.prototype.addRemoteTextTrack = function addRemoteTextTrack(options, manualCleanup) {\n    var htmlTrackElement = _Tech.prototype.addRemoteTextTrack.call(this, options, manualCleanup);\n\n    if (this.featuresNativeTextTracks) {\n      this.el().appendChild(htmlTrackElement);\n    }\n\n    return htmlTrackElement;\n  };\n\n  /**\n   * Remove remote `TextTrack` from `TextTrackList` object\n   *\n   * @param {TextTrack} track\n   *        `TextTrack` object to remove\n   */\n\n\n  Html5.prototype.removeRemoteTextTrack = function removeRemoteTextTrack(track) {\n    _Tech.prototype.removeRemoteTextTrack.call(this, track);\n\n    if (this.featuresNativeTextTracks) {\n      var tracks = this.$$('track');\n\n      var i = tracks.length;\n\n      while (i--) {\n        if (track === tracks[i] || track === tracks[i].track) {\n          this.el().removeChild(tracks[i]);\n        }\n      }\n    }\n  };\n\n  /**\n   * Gets available media playback quality metrics as specified by the W3C's Media\n   * Playback Quality API.\n   *\n   * @see [Spec]{@link https://wicg.github.io/media-playback-quality}\n   *\n   * @return {Object}\n   *         An object with supported media playback quality metrics\n   */\n\n\n  Html5.prototype.getVideoPlaybackQuality = function getVideoPlaybackQuality() {\n    if (typeof this.el().getVideoPlaybackQuality === 'function') {\n      return this.el().getVideoPlaybackQuality();\n    }\n\n    var videoPlaybackQuality = {};\n\n    if (typeof this.el().webkitDroppedFrameCount !== 'undefined' && typeof this.el().webkitDecodedFrameCount !== 'undefined') {\n      videoPlaybackQuality.droppedVideoFrames = this.el().webkitDroppedFrameCount;\n      videoPlaybackQuality.totalVideoFrames = this.el().webkitDecodedFrameCount;\n    }\n\n    if (window.performance && typeof window.performance.now === 'function') {\n      videoPlaybackQuality.creationTime = window.performance.now();\n    } else if (window.performance && window.performance.timing && typeof window.performance.timing.navigationStart === 'number') {\n      videoPlaybackQuality.creationTime = window.Date.now() - window.performance.timing.navigationStart;\n    }\n\n    return videoPlaybackQuality;\n  };\n\n  return Html5;\n}(Tech);\n\n/* HTML5 Support Testing ---------------------------------------------------- */\n\nif (isReal()) {\n\n  /**\n   * Element for testing browser HTML5 media capabilities\n   *\n   * @type {Element}\n   * @constant\n   * @private\n   */\n  Html5.TEST_VID = document.createElement('video');\n  var track = document.createElement('track');\n\n  track.kind = 'captions';\n  track.srclang = 'en';\n  track.label = 'English';\n  Html5.TEST_VID.appendChild(track);\n}\n\n/**\n * Check if HTML5 media is supported by this browser/device.\n *\n * @return {boolean}\n *         - True if HTML5 media is supported.\n *         - False if HTML5 media is not supported.\n */\nHtml5.isSupported = function () {\n  // IE9 with no Media Player is a LIAR! (#984)\n  try {\n    Html5.TEST_VID.volume = 0.5;\n  } catch (e) {\n    return false;\n  }\n\n  return !!(Html5.TEST_VID && Html5.TEST_VID.canPlayType);\n};\n\n/**\n * Check if the tech can support the given type\n *\n * @param {string} type\n *        The mimetype to check\n * @return {string} 'probably', 'maybe', or '' (empty string)\n */\nHtml5.canPlayType = function (type) {\n  return Html5.TEST_VID.canPlayType(type);\n};\n\n/**\n * Check if the tech can support the given source\n * @param {Object} srcObj\n *        The source object\n * @param {Object} options\n *        The options passed to the tech\n * @return {string} 'probably', 'maybe', or '' (empty string)\n */\nHtml5.canPlaySource = function (srcObj, options) {\n  return Html5.canPlayType(srcObj.type);\n};\n\n/**\n * Check if the volume can be changed in this browser/device.\n * Volume cannot be changed in a lot of mobile devices.\n * Specifically, it can't be changed from 1 on iOS.\n *\n * @return {boolean}\n *         - True if volume can be controlled\n *         - False otherwise\n */\nHtml5.canControlVolume = function () {\n  // IE will error if Windows Media Player not installed #3315\n  try {\n    var volume = Html5.TEST_VID.volume;\n\n    Html5.TEST_VID.volume = volume / 2 + 0.1;\n    return volume !== Html5.TEST_VID.volume;\n  } catch (e) {\n    return false;\n  }\n};\n\n/**\n * Check if the volume can be muted in this browser/device.\n * Some devices, e.g. iOS, don't allow changing volume\n * but permits muting/unmuting.\n *\n * @return {bolean}\n *      - True if volume can be muted\n *      - False otherwise\n */\nHtml5.canMuteVolume = function () {\n  try {\n    var muted = Html5.TEST_VID.muted;\n\n    // in some versions of iOS muted property doesn't always\n    // work, so we want to set both property and attribute\n    Html5.TEST_VID.muted = !muted;\n    if (Html5.TEST_VID.muted) {\n      setAttribute(Html5.TEST_VID, 'muted', 'muted');\n    } else {\n      removeAttribute(Html5.TEST_VID, 'muted', 'muted');\n    }\n    return muted !== Html5.TEST_VID.muted;\n  } catch (e) {\n    return false;\n  }\n};\n\n/**\n * Check if the playback rate can be changed in this browser/device.\n *\n * @return {boolean}\n *         - True if playback rate can be controlled\n *         - False otherwise\n */\nHtml5.canControlPlaybackRate = function () {\n  // Playback rate API is implemented in Android Chrome, but doesn't do anything\n  // https://github.com/videojs/video.js/issues/3180\n  if (IS_ANDROID && IS_CHROME && CHROME_VERSION < 58) {\n    return false;\n  }\n  // IE will error if Windows Media Player not installed #3315\n  try {\n    var playbackRate = Html5.TEST_VID.playbackRate;\n\n    Html5.TEST_VID.playbackRate = playbackRate / 2 + 0.1;\n    return playbackRate !== Html5.TEST_VID.playbackRate;\n  } catch (e) {\n    return false;\n  }\n};\n\n/**\n * Check if we can override a video/audio elements attributes, with\n * Object.defineProperty.\n *\n * @return {boolean}\n *         - True if builtin attributes can be overriden\n *         - False otherwise\n */\nHtml5.canOverrideAttributes = function () {\n  if (IS_IE8) {\n    return false;\n  }\n  // if we cannot overwrite the src/innerHTML property, there is no support\n  // iOS 7 safari for instance cannot do this.\n  try {\n    var noop = function noop() {};\n\n    Object.defineProperty(document.createElement('video'), 'src', { get: noop, set: noop });\n    Object.defineProperty(document.createElement('audio'), 'src', { get: noop, set: noop });\n    Object.defineProperty(document.createElement('video'), 'innerHTML', { get: noop, set: noop });\n    Object.defineProperty(document.createElement('audio'), 'innerHTML', { get: noop, set: noop });\n  } catch (e) {\n    return false;\n  }\n\n  return true;\n};\n\n/**\n * Check to see if native `TextTrack`s are supported by this browser/device.\n *\n * @return {boolean}\n *         - True if native `TextTrack`s are supported.\n *         - False otherwise\n */\nHtml5.supportsNativeTextTracks = function () {\n  return IS_ANY_SAFARI || IS_IOS && IS_CHROME;\n};\n\n/**\n * Check to see if native `VideoTrack`s are supported by this browser/device\n *\n * @return {boolean}\n *        - True if native `VideoTrack`s are supported.\n *        - False otherwise\n */\nHtml5.supportsNativeVideoTracks = function () {\n  return !!(Html5.TEST_VID && Html5.TEST_VID.videoTracks);\n};\n\n/**\n * Check to see if native `AudioTrack`s are supported by this browser/device\n *\n * @return {boolean}\n *        - True if native `AudioTrack`s are supported.\n *        - False otherwise\n */\nHtml5.supportsNativeAudioTracks = function () {\n  return !!(Html5.TEST_VID && Html5.TEST_VID.audioTracks);\n};\n\n/**\n * An array of events available on the Html5 tech.\n *\n * @private\n * @type {Array}\n */\nHtml5.Events = ['loadstart', 'suspend', 'abort', 'error', 'emptied', 'stalled', 'loadedmetadata', 'loadeddata', 'canplay', 'canplaythrough', 'playing', 'waiting', 'seeking', 'seeked', 'ended', 'durationchange', 'timeupdate', 'progress', 'play', 'pause', 'ratechange', 'resize', 'volumechange'];\n\n/**\n * Boolean indicating whether the `Tech` supports volume control.\n *\n * @type {boolean}\n * @default {@link Html5.canControlVolume}\n */\nHtml5.prototype.featuresVolumeControl = Html5.canControlVolume();\n\n/**\n * Boolean indicating whether the `Tech` supports muting volume.\n *\n * @type {bolean}\n * @default {@link Html5.canMuteVolume}\n */\nHtml5.prototype.featuresMuteControl = Html5.canMuteVolume();\n\n/**\n * Boolean indicating whether the `Tech` supports changing the speed at which the media\n * plays. Examples:\n *   - Set player to play 2x (twice) as fast\n *   - Set player to play 0.5x (half) as fast\n *\n * @type {boolean}\n * @default {@link Html5.canControlPlaybackRate}\n */\nHtml5.prototype.featuresPlaybackRate = Html5.canControlPlaybackRate();\n\n/**\n * Boolean indicating wether the `Tech` supports the `sourceset` event.\n *\n * @type {boolean}\n * @default\n */\nHtml5.prototype.featuresSourceset = Html5.canOverrideAttributes();\n\n/**\n * Boolean indicating whether the `HTML5` tech currently supports the media element\n * moving in the DOM. iOS breaks if you move the media element, so this is set this to\n * false there. Everywhere else this should be true.\n *\n * @type {boolean}\n * @default\n */\nHtml5.prototype.movingMediaElementInDOM = !IS_IOS;\n\n// TODO: Previous comment: No longer appears to be used. Can probably be removed.\n//       Is this true?\n/**\n * Boolean indicating whether the `HTML5` tech currently supports automatic media resize\n * when going into fullscreen.\n *\n * @type {boolean}\n * @default\n */\nHtml5.prototype.featuresFullscreenResize = true;\n\n/**\n * Boolean indicating whether the `HTML5` tech currently supports the progress event.\n * If this is false, manual `progress` events will be triggred instead.\n *\n * @type {boolean}\n * @default\n */\nHtml5.prototype.featuresProgressEvents = true;\n\n/**\n * Boolean indicating whether the `HTML5` tech currently supports the timeupdate event.\n * If this is false, manual `timeupdate` events will be triggred instead.\n *\n * @default\n */\nHtml5.prototype.featuresTimeupdateEvents = true;\n\n/**\n * Boolean indicating whether the `HTML5` tech currently supports native `TextTrack`s.\n *\n * @type {boolean}\n * @default {@link Html5.supportsNativeTextTracks}\n */\nHtml5.prototype.featuresNativeTextTracks = Html5.supportsNativeTextTracks();\n\n/**\n * Boolean indicating whether the `HTML5` tech currently supports native `VideoTrack`s.\n *\n * @type {boolean}\n * @default {@link Html5.supportsNativeVideoTracks}\n */\nHtml5.prototype.featuresNativeVideoTracks = Html5.supportsNativeVideoTracks();\n\n/**\n * Boolean indicating whether the `HTML5` tech currently supports native `AudioTrack`s.\n *\n * @type {boolean}\n * @default {@link Html5.supportsNativeAudioTracks}\n */\nHtml5.prototype.featuresNativeAudioTracks = Html5.supportsNativeAudioTracks();\n\n// HTML5 Feature detection and Device Fixes --------------------------------- //\nvar canPlayType = Html5.TEST_VID && Html5.TEST_VID.constructor.prototype.canPlayType;\nvar mpegurlRE = /^application\\/(?:x-|vnd\\.apple\\.)mpegurl/i;\nvar mp4RE = /^video\\/mp4/i;\n\nHtml5.patchCanPlayType = function () {\n\n  // Android 4.0 and above can play HLS to some extent but it reports being unable to do so\n  // Firefox and Chrome report correctly\n  if (ANDROID_VERSION >= 4.0 && !IS_FIREFOX && !IS_CHROME) {\n    Html5.TEST_VID.constructor.prototype.canPlayType = function (type) {\n      if (type && mpegurlRE.test(type)) {\n        return 'maybe';\n      }\n      return canPlayType.call(this, type);\n    };\n\n    // Override Android 2.2 and less canPlayType method which is broken\n  } else if (IS_OLD_ANDROID) {\n    Html5.TEST_VID.constructor.prototype.canPlayType = function (type) {\n      if (type && mp4RE.test(type)) {\n        return 'maybe';\n      }\n      return canPlayType.call(this, type);\n    };\n  }\n};\n\nHtml5.unpatchCanPlayType = function () {\n  var r = Html5.TEST_VID.constructor.prototype.canPlayType;\n\n  Html5.TEST_VID.constructor.prototype.canPlayType = canPlayType;\n  return r;\n};\n\n// by default, patch the media element\nHtml5.patchCanPlayType();\n\nHtml5.disposeMediaElement = function (el) {\n  if (!el) {\n    return;\n  }\n\n  if (el.parentNode) {\n    el.parentNode.removeChild(el);\n  }\n\n  // remove any child track or source nodes to prevent their loading\n  while (el.hasChildNodes()) {\n    el.removeChild(el.firstChild);\n  }\n\n  // remove any src reference. not setting `src=''` because that causes a warning\n  // in firefox\n  el.removeAttribute('src');\n\n  // force the media element to update its loading state by calling load()\n  // however IE on Windows 7N has a bug that throws an error so need a try/catch (#793)\n  if (typeof el.load === 'function') {\n    // wrapping in an iife so it's not deoptimized (#1060#discussion_r10324473)\n    (function () {\n      try {\n        el.load();\n      } catch (e) {\n        // not supported\n      }\n    })();\n  }\n};\n\nHtml5.resetMediaElement = function (el) {\n  if (!el) {\n    return;\n  }\n\n  var sources = el.querySelectorAll('source');\n  var i = sources.length;\n\n  while (i--) {\n    el.removeChild(sources[i]);\n  }\n\n  // remove any src reference.\n  // not setting `src=''` because that throws an error\n  el.removeAttribute('src');\n\n  if (typeof el.load === 'function') {\n    // wrapping in an iife so it's not deoptimized (#1060#discussion_r10324473)\n    (function () {\n      try {\n        el.load();\n      } catch (e) {\n        // satisfy linter\n      }\n    })();\n  }\n};\n\n/* Native HTML5 element property wrapping ----------------------------------- */\n// Wrap native boolean attributes with getters that check both property and attribute\n// The list is as followed:\n// muted, defaultMuted, autoplay, controls, loop, playsinline\n[\n/**\n * Get the value of `muted` from the media element. `muted` indicates\n * that the volume for the media should be set to silent. This does not actually change\n * the `volume` attribute.\n *\n * @method Html5#muted\n * @return {boolean}\n *         - True if the value of `volume` should be ignored and the audio set to silent.\n *         - False if the value of `volume` should be used.\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-muted}\n */\n'muted',\n\n/**\n * Get the value of `defaultMuted` from the media element. `defaultMuted` indicates\n * whether the media should start muted or not. Only changes the default state of the\n * media. `muted` and `defaultMuted` can have different values. {@link Html5#muted} indicates the\n * current state.\n *\n * @method Html5#defaultMuted\n * @return {boolean}\n *         - The value of `defaultMuted` from the media element.\n *         - True indicates that the media should start muted.\n *         - False indicates that the media should not start muted\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-defaultmuted}\n */\n'defaultMuted',\n\n/**\n * Get the value of `autoplay` from the media element. `autoplay` indicates\n * that the media should start to play as soon as the page is ready.\n *\n * @method Html5#autoplay\n * @return {boolean}\n *         - The value of `autoplay` from the media element.\n *         - True indicates that the media should start as soon as the page loads.\n *         - False indicates that the media should not start as soon as the page loads.\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-autoplay}\n */\n'autoplay',\n\n/**\n * Get the value of `controls` from the media element. `controls` indicates\n * whether the native media controls should be shown or hidden.\n *\n * @method Html5#controls\n * @return {boolean}\n *         - The value of `controls` from the media element.\n *         - True indicates that native controls should be showing.\n *         - False indicates that native controls should be hidden.\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-controls}\n */\n'controls',\n\n/**\n * Get the value of `loop` from the media element. `loop` indicates\n * that the media should return to the start of the media and continue playing once\n * it reaches the end.\n *\n * @method Html5#loop\n * @return {boolean}\n *         - The value of `loop` from the media element.\n *         - True indicates that playback should seek back to start once\n *           the end of a media is reached.\n *         - False indicates that playback should not loop back to the start when the\n *           end of the media is reached.\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-loop}\n */\n'loop',\n\n/**\n * Get the value of `playsinline` from the media element. `playsinline` indicates\n * to the browser that non-fullscreen playback is preferred when fullscreen\n * playback is the native default, such as in iOS Safari.\n *\n * @method Html5#playsinline\n * @return {boolean}\n *         - The value of `playsinline` from the media element.\n *         - True indicates that the media should play inline.\n *         - False indicates that the media should not play inline.\n *\n * @see [Spec]{@link https://html.spec.whatwg.org/#attr-video-playsinline}\n */\n'playsinline'].forEach(function (prop) {\n  Html5.prototype[prop] = function () {\n    return this.el_[prop] || this.el_.hasAttribute(prop);\n  };\n});\n\n// Wrap native boolean attributes with setters that set both property and attribute\n// The list is as followed:\n// setMuted, setDefaultMuted, setAutoplay, setLoop, setPlaysinline\n// setControls is special-cased above\n[\n/**\n * Set the value of `muted` on the media element. `muted` indicates that the current\n * audio level should be silent.\n *\n * @method Html5#setMuted\n * @param {boolean} muted\n *        - True if the audio should be set to silent\n *        - False otherwise\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-muted}\n */\n'muted',\n\n/**\n * Set the value of `defaultMuted` on the media element. `defaultMuted` indicates that the current\n * audio level should be silent, but will only effect the muted level on intial playback..\n *\n * @method Html5.prototype.setDefaultMuted\n * @param {boolean} defaultMuted\n *        - True if the audio should be set to silent\n *        - False otherwise\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-defaultmuted}\n */\n'defaultMuted',\n\n/**\n * Set the value of `autoplay` on the media element. `autoplay` indicates\n * that the media should start to play as soon as the page is ready.\n *\n * @method Html5#setAutoplay\n * @param {boolean} autoplay\n *         - True indicates that the media should start as soon as the page loads.\n *         - False indicates that the media should not start as soon as the page loads.\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-autoplay}\n */\n'autoplay',\n\n/**\n * Set the value of `loop` on the media element. `loop` indicates\n * that the media should return to the start of the media and continue playing once\n * it reaches the end.\n *\n * @method Html5#setLoop\n * @param {boolean} loop\n *         - True indicates that playback should seek back to start once\n *           the end of a media is reached.\n *         - False indicates that playback should not loop back to the start when the\n *           end of the media is reached.\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-loop}\n */\n'loop',\n\n/**\n * Set the value of `playsinline` from the media element. `playsinline` indicates\n * to the browser that non-fullscreen playback is preferred when fullscreen\n * playback is the native default, such as in iOS Safari.\n *\n * @method Html5#setPlaysinline\n * @param {boolean} playsinline\n *         - True indicates that the media should play inline.\n *         - False indicates that the media should not play inline.\n *\n * @see [Spec]{@link https://html.spec.whatwg.org/#attr-video-playsinline}\n */\n'playsinline'].forEach(function (prop) {\n  Html5.prototype['set' + toTitleCase(prop)] = function (v) {\n    this.el_[prop] = v;\n\n    if (v) {\n      this.el_.setAttribute(prop, prop);\n    } else {\n      this.el_.removeAttribute(prop);\n    }\n  };\n});\n\n// Wrap native properties with a getter\n// The list is as followed\n// paused, currentTime, buffered, volume, poster, preload, error, seeking\n// seekable, ended, playbackRate, defaultPlaybackRate, played, networkState\n// readyState, videoWidth, videoHeight\n[\n/**\n * Get the value of `paused` from the media element. `paused` indicates whether the media element\n * is currently paused or not.\n *\n * @method Html5#paused\n * @return {boolean}\n *         The value of `paused` from the media element.\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-paused}\n */\n'paused',\n\n/**\n * Get the value of `currentTime` from the media element. `currentTime` indicates\n * the current second that the media is at in playback.\n *\n * @method Html5#currentTime\n * @return {number}\n *         The value of `currentTime` from the media element.\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-currenttime}\n */\n'currentTime',\n\n/**\n * Get the value of `buffered` from the media element. `buffered` is a `TimeRange`\n * object that represents the parts of the media that are already downloaded and\n * available for playback.\n *\n * @method Html5#buffered\n * @return {TimeRange}\n *         The value of `buffered` from the media element.\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-buffered}\n */\n'buffered',\n\n/**\n * Get the value of `volume` from the media element. `volume` indicates\n * the current playback volume of audio for a media. `volume` will be a value from 0\n * (silent) to 1 (loudest and default).\n *\n * @method Html5#volume\n * @return {number}\n *         The value of `volume` from the media element. Value will be between 0-1.\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-a-volume}\n */\n'volume',\n\n/**\n * Get the value of `poster` from the media element. `poster` indicates\n * that the url of an image file that can/will be shown when no media data is available.\n *\n * @method Html5#poster\n * @return {string}\n *         The value of `poster` from the media element. Value will be a url to an\n *         image.\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-video-poster}\n */\n'poster',\n\n/**\n * Get the value of `preload` from the media element. `preload` indicates\n * what should download before the media is interacted with. It can have the following\n * values:\n * - none: nothing should be downloaded\n * - metadata: poster and the first few frames of the media may be downloaded to get\n *   media dimensions and other metadata\n * - auto: allow the media and metadata for the media to be downloaded before\n *    interaction\n *\n * @method Html5#preload\n * @return {string}\n *         The value of `preload` from the media element. Will be 'none', 'metadata',\n *         or 'auto'.\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-preload}\n */\n'preload',\n\n/**\n * Get the value of the `error` from the media element. `error` indicates any\n * MediaError that may have occured during playback. If error returns null there is no\n * current error.\n *\n * @method Html5#error\n * @return {MediaError|null}\n *         The value of `error` from the media element. Will be `MediaError` if there\n *         is a current error and null otherwise.\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-error}\n */\n'error',\n\n/**\n * Get the value of `seeking` from the media element. `seeking` indicates whether the\n * media is currently seeking to a new position or not.\n *\n * @method Html5#seeking\n * @return {boolean}\n *         - The value of `seeking` from the media element.\n *         - True indicates that the media is currently seeking to a new position.\n *         - Flase indicates that the media is not seeking to a new position at this time.\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-seeking}\n */\n'seeking',\n\n/**\n * Get the value of `seekable` from the media element. `seekable` returns a\n * `TimeRange` object indicating ranges of time that can currently be `seeked` to.\n *\n * @method Html5#seekable\n * @return {TimeRange}\n *         The value of `seekable` from the media element. A `TimeRange` object\n *         indicating the current ranges of time that can be seeked to.\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-seekable}\n */\n'seekable',\n\n/**\n * Get the value of `ended` from the media element. `ended` indicates whether\n * the media has reached the end or not.\n *\n * @method Html5#ended\n * @return {boolean}\n *         - The value of `ended` from the media element.\n *         - True indicates that the media has ended.\n *         - False indicates that the media has not ended.\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-ended}\n */\n'ended',\n\n/**\n * Get the value of `playbackRate` from the media element. `playbackRate` indicates\n * the rate at which the media is currently playing back. Examples:\n *   - if playbackRate is set to 2, media will play twice as fast.\n *   - if playbackRate is set to 0.5, media will play half as fast.\n *\n * @method Html5#playbackRate\n * @return {number}\n *         The value of `playbackRate` from the media element. A number indicating\n *         the current playback speed of the media, where 1 is normal speed.\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-playbackrate}\n */\n'playbackRate',\n\n/**\n * Get the value of `defaultPlaybackRate` from the media element. `defaultPlaybackRate` indicates\n * the rate at which the media is currently playing back. This value will not indicate the current\n * `playbackRate` after playback has started, use {@link Html5#playbackRate} for that.\n *\n * Examples:\n *   - if defaultPlaybackRate is set to 2, media will play twice as fast.\n *   - if defaultPlaybackRate is set to 0.5, media will play half as fast.\n *\n * @method Html5.prototype.defaultPlaybackRate\n * @return {number}\n *         The value of `defaultPlaybackRate` from the media element. A number indicating\n *         the current playback speed of the media, where 1 is normal speed.\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-playbackrate}\n */\n'defaultPlaybackRate',\n\n/**\n * Get the value of `played` from the media element. `played` returns a `TimeRange`\n * object representing points in the media timeline that have been played.\n *\n * @method Html5#played\n * @return {TimeRange}\n *         The value of `played` from the media element. A `TimeRange` object indicating\n *         the ranges of time that have been played.\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-played}\n */\n'played',\n\n/**\n * Get the value of `networkState` from the media element. `networkState` indicates\n * the current network state. It returns an enumeration from the following list:\n * - 0: NETWORK_EMPTY\n * - 1: NEWORK_IDLE\n * - 2: NETWORK_LOADING\n * - 3: NETWORK_NO_SOURCE\n *\n * @method Html5#networkState\n * @return {number}\n *         The value of `networkState` from the media element. This will be a number\n *         from the list in the description.\n *\n * @see [Spec] {@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-networkstate}\n */\n'networkState',\n\n/**\n * Get the value of `readyState` from the media element. `readyState` indicates\n * the current state of the media element. It returns an enumeration from the\n * following list:\n * - 0: HAVE_NOTHING\n * - 1: HAVE_METADATA\n * - 2: HAVE_CURRENT_DATA\n * - 3: HAVE_FUTURE_DATA\n * - 4: HAVE_ENOUGH_DATA\n *\n * @method Html5#readyState\n * @return {number}\n *         The value of `readyState` from the media element. This will be a number\n *         from the list in the description.\n *\n * @see [Spec] {@link https://www.w3.org/TR/html5/embedded-content-0.html#ready-states}\n */\n'readyState',\n\n/**\n * Get the value of `videoWidth` from the video element. `videoWidth` indicates\n * the current width of the video in css pixels.\n *\n * @method Html5#videoWidth\n * @return {number}\n *         The value of `videoWidth` from the video element. This will be a number\n *         in css pixels.\n *\n * @see [Spec] {@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-video-videowidth}\n */\n'videoWidth',\n\n/**\n * Get the value of `videoHeight` from the video element. `videoHeigth` indicates\n * the current height of the video in css pixels.\n *\n * @method Html5#videoHeight\n * @return {number}\n *         The value of `videoHeight` from the video element. This will be a number\n *         in css pixels.\n *\n * @see [Spec] {@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-video-videowidth}\n */\n'videoHeight'].forEach(function (prop) {\n  Html5.prototype[prop] = function () {\n    return this.el_[prop];\n  };\n});\n\n// Wrap native properties with a setter in this format:\n// set + toTitleCase(name)\n// The list is as follows:\n// setVolume, setSrc, setPoster, setPreload, setPlaybackRate, setDefaultPlaybackRate\n[\n/**\n * Set the value of `volume` on the media element. `volume` indicates the current\n * audio level as a percentage in decimal form. This means that 1 is 100%, 0.5 is 50%, and\n * so on.\n *\n * @method Html5#setVolume\n * @param {number} percentAsDecimal\n *        The volume percent as a decimal. Valid range is from 0-1.\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-a-volume}\n */\n'volume',\n\n/**\n * Set the value of `src` on the media element. `src` indicates the current\n * {@link Tech~SourceObject} for the media.\n *\n * @method Html5#setSrc\n * @param {Tech~SourceObject} src\n *        The source object to set as the current source.\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-src}\n */\n'src',\n\n/**\n * Set the value of `poster` on the media element. `poster` is the url to\n * an image file that can/will be shown when no media data is available.\n *\n * @method Html5#setPoster\n * @param {string} poster\n *        The url to an image that should be used as the `poster` for the media\n *        element.\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-poster}\n */\n'poster',\n\n/**\n * Set the value of `preload` on the media element. `preload` indicates\n * what should download before the media is interacted with. It can have the following\n * values:\n * - none: nothing should be downloaded\n * - metadata: poster and the first few frames of the media may be downloaded to get\n *   media dimensions and other metadata\n * - auto: allow the media and metadata for the media to be downloaded before\n *    interaction\n *\n * @method Html5#setPreload\n * @param {string} preload\n *         The value of `preload` to set on the media element. Must be 'none', 'metadata',\n *         or 'auto'.\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-preload}\n */\n'preload',\n\n/**\n * Set the value of `playbackRate` on the media element. `playbackRate` indicates\n * the rate at which the media should play back. Examples:\n *   - if playbackRate is set to 2, media will play twice as fast.\n *   - if playbackRate is set to 0.5, media will play half as fast.\n *\n * @method Html5#setPlaybackRate\n * @return {number}\n *         The value of `playbackRate` from the media element. A number indicating\n *         the current playback speed of the media, where 1 is normal speed.\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-playbackrate}\n */\n'playbackRate',\n\n/**\n * Set the value of `defaultPlaybackRate` on the media element. `defaultPlaybackRate` indicates\n * the rate at which the media should play back upon initial startup. Changing this value\n * after a video has started will do nothing. Instead you should used {@link Html5#setPlaybackRate}.\n *\n * Example Values:\n *   - if playbackRate is set to 2, media will play twice as fast.\n *   - if playbackRate is set to 0.5, media will play half as fast.\n *\n * @method Html5.prototype.setDefaultPlaybackRate\n * @return {number}\n *         The value of `defaultPlaybackRate` from the media element. A number indicating\n *         the current playback speed of the media, where 1 is normal speed.\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-defaultplaybackrate}\n */\n'defaultPlaybackRate'].forEach(function (prop) {\n  Html5.prototype['set' + toTitleCase(prop)] = function (v) {\n    this.el_[prop] = v;\n  };\n});\n\n// wrap native functions with a function\n// The list is as follows:\n// pause, load play\n[\n/**\n * A wrapper around the media elements `pause` function. This will call the `HTML5`\n * media elements `pause` function.\n *\n * @method Html5#pause\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-pause}\n */\n'pause',\n\n/**\n * A wrapper around the media elements `load` function. This will call the `HTML5`s\n * media element `load` function.\n *\n * @method Html5#load\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-load}\n */\n'load',\n\n/**\n * A wrapper around the media elements `play` function. This will call the `HTML5`s\n * media element `play` function.\n *\n * @method Html5#play\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-play}\n */\n'play'].forEach(function (prop) {\n  Html5.prototype[prop] = function () {\n    return this.el_[prop]();\n  };\n});\n\nTech.withSourceHandlers(Html5);\n\n/**\n * Native source handler for Html5, simply passes the source to the media element.\n *\n * @proprety {Tech~SourceObject} source\n *        The source object\n *\n * @proprety {Html5} tech\n *        The instance of the HTML5 tech.\n */\nHtml5.nativeSourceHandler = {};\n\n/**\n * Check if the media element can play the given mime type.\n *\n * @param {string} type\n *        The mimetype to check\n *\n * @return {string}\n *         'probably', 'maybe', or '' (empty string)\n */\nHtml5.nativeSourceHandler.canPlayType = function (type) {\n  // IE9 on Windows 7 without MediaPlayer throws an error here\n  // https://github.com/videojs/video.js/issues/519\n  try {\n    return Html5.TEST_VID.canPlayType(type);\n  } catch (e) {\n    return '';\n  }\n};\n\n/**\n * Check if the media element can handle a source natively.\n *\n * @param {Tech~SourceObject} source\n *         The source object\n *\n * @param {Object} [options]\n *         Options to be passed to the tech.\n *\n * @return {string}\n *         'probably', 'maybe', or '' (empty string).\n */\nHtml5.nativeSourceHandler.canHandleSource = function (source, options) {\n\n  // If a type was provided we should rely on that\n  if (source.type) {\n    return Html5.nativeSourceHandler.canPlayType(source.type);\n\n    // If no type, fall back to checking 'video/[EXTENSION]'\n  } else if (source.src) {\n    var ext = getFileExtension(source.src);\n\n    return Html5.nativeSourceHandler.canPlayType('video/' + ext);\n  }\n\n  return '';\n};\n\n/**\n * Pass the source to the native media element.\n *\n * @param {Tech~SourceObject} source\n *        The source object\n *\n * @param {Html5} tech\n *        The instance of the Html5 tech\n *\n * @param {Object} [options]\n *        The options to pass to the source\n */\nHtml5.nativeSourceHandler.handleSource = function (source, tech, options) {\n  tech.setSrc(source.src);\n};\n\n/**\n * A noop for the native dispose function, as cleanup is not needed.\n */\nHtml5.nativeSourceHandler.dispose = function () {};\n\n// Register the native source handler\nHtml5.registerSourceHandler(Html5.nativeSourceHandler);\n\nTech.registerTech('Html5', Html5);\n\nvar _templateObject$1 = taggedTemplateLiteralLoose(['\\n        Using the tech directly can be dangerous. I hope you know what you\\'re doing.\\n        See https://github.com/videojs/video.js/issues/2617 for more info.\\n      '], ['\\n        Using the tech directly can be dangerous. I hope you know what you\\'re doing.\\n        See https://github.com/videojs/video.js/issues/2617 for more info.\\n      ']);\n\n/**\n * @file player.js\n */\n// Subclasses Component\n// The following imports are used only to ensure that the corresponding modules\n// are always included in the video.js package. Importing the modules will\n// execute them and they will register themselves with video.js.\n// Import Html5 tech, at least for disposing the original video tag.\n// The following tech events are simply re-triggered\n// on the player when they happen\nvar TECH_EVENTS_RETRIGGER = [\n/**\n * Fired while the user agent is downloading media data.\n *\n * @event Player#progress\n * @type {EventTarget~Event}\n */\n/**\n * Retrigger the `progress` event that was triggered by the {@link Tech}.\n *\n * @private\n * @method Player#handleTechProgress_\n * @fires Player#progress\n * @listens Tech#progress\n */\n'progress',\n\n/**\n * Fires when the loading of an audio/video is aborted.\n *\n * @event Player#abort\n * @type {EventTarget~Event}\n */\n/**\n * Retrigger the `abort` event that was triggered by the {@link Tech}.\n *\n * @private\n * @method Player#handleTechAbort_\n * @fires Player#abort\n * @listens Tech#abort\n */\n'abort',\n\n/**\n * Fires when the browser is intentionally not getting media data.\n *\n * @event Player#suspend\n * @type {EventTarget~Event}\n */\n/**\n * Retrigger the `suspend` event that was triggered by the {@link Tech}.\n *\n * @private\n * @method Player#handleTechSuspend_\n * @fires Player#suspend\n * @listens Tech#suspend\n */\n'suspend',\n\n/**\n * Fires when the current playlist is empty.\n *\n * @event Player#emptied\n * @type {EventTarget~Event}\n */\n/**\n * Retrigger the `emptied` event that was triggered by the {@link Tech}.\n *\n * @private\n * @method Player#handleTechEmptied_\n * @fires Player#emptied\n * @listens Tech#emptied\n */\n'emptied',\n/**\n * Fires when the browser is trying to get media data, but data is not available.\n *\n * @event Player#stalled\n * @type {EventTarget~Event}\n */\n/**\n * Retrigger the `stalled` event that was triggered by the {@link Tech}.\n *\n * @private\n * @method Player#handleTechStalled_\n * @fires Player#stalled\n * @listens Tech#stalled\n */\n'stalled',\n\n/**\n * Fires when the browser has loaded meta data for the audio/video.\n *\n * @event Player#loadedmetadata\n * @type {EventTarget~Event}\n */\n/**\n * Retrigger the `stalled` event that was triggered by the {@link Tech}.\n *\n * @private\n * @method Player#handleTechLoadedmetadata_\n * @fires Player#loadedmetadata\n * @listens Tech#loadedmetadata\n */\n'loadedmetadata',\n\n/**\n * Fires when the browser has loaded the current frame of the audio/video.\n *\n * @event Player#loadeddata\n * @type {event}\n */\n/**\n * Retrigger the `loadeddata` event that was triggered by the {@link Tech}.\n *\n * @private\n * @method Player#handleTechLoaddeddata_\n * @fires Player#loadeddata\n * @listens Tech#loadeddata\n */\n'loadeddata',\n\n/**\n * Fires when the current playback position has changed.\n *\n * @event Player#timeupdate\n * @type {event}\n */\n/**\n * Retrigger the `timeupdate` event that was triggered by the {@link Tech}.\n *\n * @private\n * @method Player#handleTechTimeUpdate_\n * @fires Player#timeupdate\n * @listens Tech#timeupdate\n */\n'timeupdate',\n\n/**\n * Fires when the video's intrinsic dimensions change\n *\n * @event Player#resize\n * @type {event}\n */\n/**\n * Retrigger the `resize` event that was triggered by the {@link Tech}.\n *\n * @private\n * @method Player#handleTechResize_\n * @fires Player#resize\n * @listens Tech#resize\n */\n'resize',\n\n/**\n * Fires when the volume has been changed\n *\n * @event Player#volumechange\n * @type {event}\n */\n/**\n * Retrigger the `volumechange` event that was triggered by the {@link Tech}.\n *\n * @private\n * @method Player#handleTechVolumechange_\n * @fires Player#volumechange\n * @listens Tech#volumechange\n */\n'volumechange',\n\n/**\n * Fires when the text track has been changed\n *\n * @event Player#texttrackchange\n * @type {event}\n */\n/**\n * Retrigger the `texttrackchange` event that was triggered by the {@link Tech}.\n *\n * @private\n * @method Player#handleTechTexttrackchange_\n * @fires Player#texttrackchange\n * @listens Tech#texttrackchange\n */\n'texttrackchange'];\n\n// events to queue when playback rate is zero\n// this is a hash for the sole purpose of mapping non-camel-cased event names\n// to camel-cased function names\nvar TECH_EVENTS_QUEUE = {\n  canplay: 'CanPlay',\n  canplaythrough: 'CanPlayThrough',\n  playing: 'Playing',\n  seeked: 'Seeked'\n};\n\nvar BREAKPOINT_ORDER = ['tiny', 'xsmall', 'small', 'medium', 'large', 'xlarge', 'huge'];\n\nvar BREAKPOINT_CLASSES = {};\n\n// grep: vjs-layout-tiny\n// grep: vjs-layout-x-small\n// grep: vjs-layout-small\n// grep: vjs-layout-medium\n// grep: vjs-layout-large\n// grep: vjs-layout-x-large\n// grep: vjs-layout-huge\nBREAKPOINT_ORDER.forEach(function (k) {\n  var v = k.charAt(0) === 'x' ? 'x-' + k.substring(1) : k;\n\n  BREAKPOINT_CLASSES[k] = 'vjs-layout-' + v;\n});\n\nvar DEFAULT_BREAKPOINTS = {\n  tiny: 210,\n  xsmall: 320,\n  small: 425,\n  medium: 768,\n  large: 1440,\n  xlarge: 2560,\n  huge: Infinity\n};\n\n/**\n * An instance of the `Player` class is created when any of the Video.js setup methods\n * are used to initialize a video.\n *\n * After an instance has been created it can be accessed globally in two ways:\n * 1. By calling `videojs('example_video_1');`\n * 2. By using it directly via  `videojs.players.example_video_1;`\n *\n * @extends Component\n */\n\nvar Player = function (_Component) {\n  inherits(Player, _Component);\n\n  /**\n   * Create an instance of this class.\n   *\n   * @param {Element} tag\n   *        The original video DOM element used for configuring options.\n   *\n   * @param {Object} [options]\n   *        Object of option names and values.\n   *\n   * @param {Component~ReadyCallback} [ready]\n   *        Ready callback function.\n   */\n  function Player(tag, options, ready) {\n    classCallCheck(this, Player);\n\n    // Make sure tag ID exists\n    tag.id = tag.id || options.id || 'vjs_video_' + newGUID();\n\n    // Set Options\n    // The options argument overrides options set in the video tag\n    // which overrides globally set options.\n    // This latter part coincides with the load order\n    // (tag must exist before Player)\n    options = assign(Player.getTagSettings(tag), options);\n\n    // Delay the initialization of children because we need to set up\n    // player properties first, and can't use `this` before `super()`\n    options.initChildren = false;\n\n    // Same with creating the element\n    options.createEl = false;\n\n    // don't auto mixin the evented mixin\n    options.evented = false;\n\n    // we don't want the player to report touch activity on itself\n    // see enableTouchActivity in Component\n    options.reportTouchActivity = false;\n\n    // If language is not set, get the closest lang attribute\n    if (!options.language) {\n      if (typeof tag.closest === 'function') {\n        var closest = tag.closest('[lang]');\n\n        if (closest && closest.getAttribute) {\n          options.language = closest.getAttribute('lang');\n        }\n      } else {\n        var element = tag;\n\n        while (element && element.nodeType === 1) {\n          if (getAttributes(element).hasOwnProperty('lang')) {\n            options.language = element.getAttribute('lang');\n            break;\n          }\n          element = element.parentNode;\n        }\n      }\n    }\n\n    // Run base component initializing with new options\n\n    // create logger\n    var _this = possibleConstructorReturn(this, _Component.call(this, null, options, ready));\n\n    _this.log = createLogger(_this.id_);\n\n    // Tracks when a tech changes the poster\n    _this.isPosterFromTech_ = false;\n\n    // Holds callback info that gets queued when playback rate is zero\n    // and a seek is happening\n    _this.queuedCallbacks_ = [];\n\n    // Turn off API access because we're loading a new tech that might load asynchronously\n    _this.isReady_ = false;\n\n    // Init state hasStarted_\n    _this.hasStarted_ = false;\n\n    // Init state userActive_\n    _this.userActive_ = false;\n\n    // if the global option object was accidentally blown away by\n    // someone, bail early with an informative error\n    if (!_this.options_ || !_this.options_.techOrder || !_this.options_.techOrder.length) {\n      throw new Error('No techOrder specified. Did you overwrite ' + 'videojs.options instead of just changing the ' + 'properties you want to override?');\n    }\n\n    // Store the original tag used to set options\n    _this.tag = tag;\n\n    // Store the tag attributes used to restore html5 element\n    _this.tagAttributes = tag && getAttributes(tag);\n\n    // Update current language\n    _this.language(_this.options_.language);\n\n    // Update Supported Languages\n    if (options.languages) {\n      // Normalise player option languages to lowercase\n      var languagesToLower = {};\n\n      Object.getOwnPropertyNames(options.languages).forEach(function (name$$1) {\n        languagesToLower[name$$1.toLowerCase()] = options.languages[name$$1];\n      });\n      _this.languages_ = languagesToLower;\n    } else {\n      _this.languages_ = Player.prototype.options_.languages;\n    }\n\n    // Cache for video property values.\n    _this.cache_ = {};\n\n    // Set poster\n    _this.poster_ = options.poster || '';\n\n    // Set controls\n    _this.controls_ = !!options.controls;\n\n    // Set default values for lastVolume\n    _this.cache_.lastVolume = 1;\n\n    // Original tag settings stored in options\n    // now remove immediately so native controls don't flash.\n    // May be turned back on by HTML5 tech if nativeControlsForTouch is true\n    tag.controls = false;\n    tag.removeAttribute('controls');\n\n    // the attribute overrides the option\n    if (tag.hasAttribute('autoplay')) {\n      _this.options_.autoplay = true;\n    } else {\n      // otherwise use the setter to validate and\n      // set the correct value.\n      _this.autoplay(_this.options_.autoplay);\n    }\n\n    /*\n     * Store the internal state of scrubbing\n     *\n     * @private\n     * @return {Boolean} True if the user is scrubbing\n     */\n    _this.scrubbing_ = false;\n\n    _this.el_ = _this.createEl();\n\n    // Set default value for lastPlaybackRate\n    _this.cache_.lastPlaybackRate = _this.defaultPlaybackRate();\n\n    // Make this an evented object and use `el_` as its event bus.\n    evented(_this, { eventBusKey: 'el_' });\n\n    // We also want to pass the original player options to each component and plugin\n    // as well so they don't need to reach back into the player for options later.\n    // We also need to do another copy of this.options_ so we don't end up with\n    // an infinite loop.\n    var playerOptionsCopy = mergeOptions(_this.options_);\n\n    // Load plugins\n    if (options.plugins) {\n      var plugins = options.plugins;\n\n      Object.keys(plugins).forEach(function (name$$1) {\n        if (typeof this[name$$1] === 'function') {\n          this[name$$1](plugins[name$$1]);\n        } else {\n          throw new Error('plugin \"' + name$$1 + '\" does not exist');\n        }\n      }, _this);\n    }\n\n    _this.options_.playerOptions = playerOptionsCopy;\n\n    _this.middleware_ = [];\n\n    _this.initChildren();\n\n    // Set isAudio based on whether or not an audio tag was used\n    _this.isAudio(tag.nodeName.toLowerCase() === 'audio');\n\n    // Update controls className. Can't do this when the controls are initially\n    // set because the element doesn't exist yet.\n    if (_this.controls()) {\n      _this.addClass('vjs-controls-enabled');\n    } else {\n      _this.addClass('vjs-controls-disabled');\n    }\n\n    // Set ARIA label and region role depending on player type\n    _this.el_.setAttribute('role', 'region');\n    if (_this.isAudio()) {\n      _this.el_.setAttribute('aria-label', _this.localize('Audio Player'));\n    } else {\n      _this.el_.setAttribute('aria-label', _this.localize('Video Player'));\n    }\n\n    if (_this.isAudio()) {\n      _this.addClass('vjs-audio');\n    }\n\n    if (_this.flexNotSupported_()) {\n      _this.addClass('vjs-no-flex');\n    }\n\n    // TODO: Make this smarter. Toggle user state between touching/mousing\n    // using events, since devices can have both touch and mouse events.\n    // if (browser.TOUCH_ENABLED) {\n    //   this.addClass('vjs-touch-enabled');\n    // }\n\n    // iOS Safari has broken hover handling\n    if (!IS_IOS) {\n      _this.addClass('vjs-workinghover');\n    }\n\n    // Make player easily findable by ID\n    Player.players[_this.id_] = _this;\n\n    // Add a major version class to aid css in plugins\n    var majorVersion = version.split('.')[0];\n\n    _this.addClass('vjs-v' + majorVersion);\n\n    // When the player is first initialized, trigger activity so components\n    // like the control bar show themselves if needed\n    _this.userActive(true);\n    _this.reportUserActivity();\n\n    _this.one('play', _this.listenForUserActivity_);\n    _this.on('fullscreenchange', _this.handleFullscreenChange_);\n    _this.on('stageclick', _this.handleStageClick_);\n\n    _this.breakpoints(_this.options_.breakpoints);\n    _this.responsive(_this.options_.responsive);\n\n    _this.changingSrc_ = false;\n    _this.playWaitingForReady_ = false;\n    _this.playOnLoadstart_ = null;\n    return _this;\n  }\n\n  /**\n   * Destroys the video player and does any necessary cleanup.\n   *\n   * This is especially helpful if you are dynamically adding and removing videos\n   * to/from the DOM.\n   *\n   * @fires Player#dispose\n   */\n\n\n  Player.prototype.dispose = function dispose() {\n    /**\n     * Called when the player is being disposed of.\n     *\n     * @event Player#dispose\n     * @type {EventTarget~Event}\n     */\n    this.trigger('dispose');\n    // prevent dispose from being called twice\n    this.off('dispose');\n\n    if (this.styleEl_ && this.styleEl_.parentNode) {\n      this.styleEl_.parentNode.removeChild(this.styleEl_);\n      this.styleEl_ = null;\n    }\n\n    // Kill reference to this player\n    Player.players[this.id_] = null;\n\n    if (this.tag && this.tag.player) {\n      this.tag.player = null;\n    }\n\n    if (this.el_ && this.el_.player) {\n      this.el_.player = null;\n    }\n\n    if (this.tech_) {\n      this.tech_.dispose();\n      this.isPosterFromTech_ = false;\n      this.poster_ = '';\n    }\n\n    if (this.playerElIngest_) {\n      this.playerElIngest_ = null;\n    }\n\n    if (this.tag) {\n      this.tag = null;\n    }\n\n    clearCacheForPlayer(this);\n\n    // the actual .el_ is removed here\n    _Component.prototype.dispose.call(this);\n  };\n\n  /**\n   * Create the `Player`'s DOM element.\n   *\n   * @return {Element}\n   *         The DOM element that gets created.\n   */\n\n\n  Player.prototype.createEl = function createEl$$1() {\n    var tag = this.tag;\n    var el = void 0;\n    var playerElIngest = this.playerElIngest_ = tag.parentNode && tag.parentNode.hasAttribute && tag.parentNode.hasAttribute('data-vjs-player');\n    var divEmbed = this.tag.tagName.toLowerCase() === 'video-js';\n\n    if (playerElIngest) {\n      el = this.el_ = tag.parentNode;\n    } else if (!divEmbed) {\n      el = this.el_ = _Component.prototype.createEl.call(this, 'div');\n    }\n\n    // Copy over all the attributes from the tag, including ID and class\n    // ID will now reference player box, not the video tag\n    var attrs = getAttributes(tag);\n\n    if (divEmbed) {\n      el = this.el_ = tag;\n      tag = this.tag = document.createElement('video');\n      while (el.children.length) {\n        tag.appendChild(el.firstChild);\n      }\n\n      if (!hasClass(el, 'video-js')) {\n        addClass(el, 'video-js');\n      }\n\n      el.appendChild(tag);\n\n      playerElIngest = this.playerElIngest_ = el;\n\n      // copy over properties from the video-js element\n      // ie8 doesn't support Object.keys nor hasOwnProperty\n      // on dom elements so we have to specify properties individually\n      ['autoplay', 'controls', 'crossOrigin', 'defaultMuted', 'defaultPlaybackRate', 'loop', 'muted', 'playbackRate', 'src', 'volume'].forEach(function (prop) {\n        if (typeof el[prop] !== 'undefined') {\n          tag[prop] = el[prop];\n        }\n      });\n    }\n\n    // set tabindex to -1 to remove the video element from the focus order\n    tag.setAttribute('tabindex', '-1');\n    attrs.tabindex = '-1';\n\n    // Workaround for #4583 (JAWS+IE doesn't announce BPB or play button)\n    // See https://github.com/FreedomScientific/VFO-standards-support/issues/78\n    // Note that we can't detect if JAWS is being used, but this ARIA attribute\n    //  doesn't change behavior of IE11 if JAWS is not being used\n    if (IE_VERSION) {\n      tag.setAttribute('role', 'application');\n      attrs.role = 'application';\n    }\n\n    // Remove width/height attrs from tag so CSS can make it 100% width/height\n    tag.removeAttribute('width');\n    tag.removeAttribute('height');\n\n    if ('width' in attrs) {\n      delete attrs.width;\n    }\n    if ('height' in attrs) {\n      delete attrs.height;\n    }\n\n    Object.getOwnPropertyNames(attrs).forEach(function (attr) {\n      // workaround so we don't totally break IE7\n      // http://stackoverflow.com/questions/3653444/css-styles-not-applied-on-dynamic-elements-in-internet-explorer-7\n      if (attr === 'class') {\n        el.className += ' ' + attrs[attr];\n\n        if (divEmbed) {\n          tag.className += ' ' + attrs[attr];\n        }\n      } else {\n        el.setAttribute(attr, attrs[attr]);\n\n        if (divEmbed) {\n          tag.setAttribute(attr, attrs[attr]);\n        }\n      }\n    });\n\n    // Update tag id/class for use as HTML5 playback tech\n    // Might think we should do this after embedding in container so .vjs-tech class\n    // doesn't flash 100% width/height, but class only applies with .video-js parent\n    tag.playerId = tag.id;\n    tag.id += '_html5_api';\n    tag.className = 'vjs-tech';\n\n    // Make player findable on elements\n    tag.player = el.player = this;\n    // Default state of video is paused\n    this.addClass('vjs-paused');\n\n    // Add a style element in the player that we'll use to set the width/height\n    // of the player in a way that's still overrideable by CSS, just like the\n    // video element\n    if (window.VIDEOJS_NO_DYNAMIC_STYLE !== true) {\n      this.styleEl_ = createStyleElement('vjs-styles-dimensions');\n      var defaultsStyleEl = $('.vjs-styles-defaults');\n      var head = $('head');\n\n      head.insertBefore(this.styleEl_, defaultsStyleEl ? defaultsStyleEl.nextSibling : head.firstChild);\n    }\n\n    this.fill_ = false;\n    this.fluid_ = false;\n\n    // Pass in the width/height/aspectRatio options which will update the style el\n    this.width(this.options_.width);\n    this.height(this.options_.height);\n    this.fill(this.options_.fill);\n    this.fluid(this.options_.fluid);\n    this.aspectRatio(this.options_.aspectRatio);\n\n    // Hide any links within the video/audio tag, because IE doesn't hide them completely.\n    var links = tag.getElementsByTagName('a');\n\n    for (var i = 0; i < links.length; i++) {\n      var linkEl = links.item(i);\n\n      addClass(linkEl, 'vjs-hidden');\n      linkEl.setAttribute('hidden', 'hidden');\n    }\n\n    // insertElFirst seems to cause the networkState to flicker from 3 to 2, so\n    // keep track of the original for later so we can know if the source originally failed\n    tag.initNetworkState_ = tag.networkState;\n\n    // Wrap video tag in div (el/box) container\n    if (tag.parentNode && !playerElIngest) {\n      tag.parentNode.insertBefore(el, tag);\n    }\n\n    // insert the tag as the first child of the player element\n    // then manually add it to the children array so that this.addChild\n    // will work properly for other components\n    //\n    // Breaks iPhone, fixed in HTML5 setup.\n    prependTo(tag, el);\n    this.children_.unshift(tag);\n\n    // Set lang attr on player to ensure CSS :lang() in consistent with player\n    // if it's been set to something different to the doc\n    this.el_.setAttribute('lang', this.language_);\n\n    this.el_ = el;\n\n    return el;\n  };\n\n  /**\n   * A getter/setter for the `Player`'s width. Returns the player's configured value.\n   * To get the current width use `currentWidth()`.\n   *\n   * @param {number} [value]\n   *        The value to set the `Player`'s width to.\n   *\n   * @return {number}\n   *         The current width of the `Player` when getting.\n   */\n\n\n  Player.prototype.width = function width(value) {\n    return this.dimension('width', value);\n  };\n\n  /**\n   * A getter/setter for the `Player`'s height. Returns the player's configured value.\n   * To get the current height use `currentheight()`.\n   *\n   * @param {number} [value]\n   *        The value to set the `Player`'s heigth to.\n   *\n   * @return {number}\n   *         The current height of the `Player` when getting.\n   */\n\n\n  Player.prototype.height = function height(value) {\n    return this.dimension('height', value);\n  };\n\n  /**\n   * A getter/setter for the `Player`'s width & height.\n   *\n   * @param {string} dimension\n   *        This string can be:\n   *        - 'width'\n   *        - 'height'\n   *\n   * @param {number} [value]\n   *        Value for dimension specified in the first argument.\n   *\n   * @return {number}\n   *         The dimension arguments value when getting (width/height).\n   */\n\n\n  Player.prototype.dimension = function dimension(_dimension, value) {\n    var privDimension = _dimension + '_';\n\n    if (value === undefined) {\n      return this[privDimension] || 0;\n    }\n\n    if (value === '') {\n      // If an empty string is given, reset the dimension to be automatic\n      this[privDimension] = undefined;\n      this.updateStyleEl_();\n      return;\n    }\n\n    var parsedVal = parseFloat(value);\n\n    if (isNaN(parsedVal)) {\n      log.error('Improper value \"' + value + '\" supplied for for ' + _dimension);\n      return;\n    }\n\n    this[privDimension] = parsedVal;\n    this.updateStyleEl_();\n  };\n\n  /**\n   * A getter/setter/toggler for the vjs-fluid `className` on the `Player`.\n   *\n   * Turning this on will turn off fill mode.\n   *\n   * @param {boolean} [bool]\n   *        - A value of true adds the class.\n   *        - A value of false removes the class.\n   *        - No value will be a getter.\n   *\n   * @return {boolean|undefined}\n   *         - The value of fluid when getting.\n   *         - `undefined` when setting.\n   */\n\n\n  Player.prototype.fluid = function fluid(bool) {\n    if (bool === undefined) {\n      return !!this.fluid_;\n    }\n\n    this.fluid_ = !!bool;\n\n    if (bool) {\n      this.addClass('vjs-fluid');\n      this.fill(false);\n    } else {\n      this.removeClass('vjs-fluid');\n    }\n\n    this.updateStyleEl_();\n  };\n\n  /**\n   * A getter/setter/toggler for the vjs-fill `className` on the `Player`.\n   *\n   * Turning this on will turn off fluid mode.\n   *\n   * @param {boolean} [bool]\n   *        - A value of true adds the class.\n   *        - A value of false removes the class.\n   *        - No value will be a getter.\n   *\n   * @return {boolean|undefined}\n   *         - The value of fluid when getting.\n   *         - `undefined` when setting.\n   */\n\n\n  Player.prototype.fill = function fill(bool) {\n    if (bool === undefined) {\n      return !!this.fill_;\n    }\n\n    this.fill_ = !!bool;\n\n    if (bool) {\n      this.addClass('vjs-fill');\n      this.fluid(false);\n    } else {\n      this.removeClass('vjs-fill');\n    }\n  };\n\n  /**\n   * Get/Set the aspect ratio\n   *\n   * @param {string} [ratio]\n   *        Aspect ratio for player\n   *\n   * @return {string|undefined}\n   *         returns the current aspect ratio when getting\n   */\n\n  /**\n   * A getter/setter for the `Player`'s aspect ratio.\n   *\n   * @param {string} [ratio]\n   *        The value to set the `Player's aspect ratio to.\n   *\n   * @return {string|undefined}\n   *         - The current aspect ratio of the `Player` when getting.\n   *         - undefined when setting\n   */\n\n\n  Player.prototype.aspectRatio = function aspectRatio(ratio) {\n    if (ratio === undefined) {\n      return this.aspectRatio_;\n    }\n\n    // Check for width:height format\n    if (!/^\\d+\\:\\d+$/.test(ratio)) {\n      throw new Error('Improper value supplied for aspect ratio. The format should be width:height, for example 16:9.');\n    }\n    this.aspectRatio_ = ratio;\n\n    // We're assuming if you set an aspect ratio you want fluid mode,\n    // because in fixed mode you could calculate width and height yourself.\n    this.fluid(true);\n\n    this.updateStyleEl_();\n  };\n\n  /**\n   * Update styles of the `Player` element (height, width and aspect ratio).\n   *\n   * @private\n   * @listens Tech#loadedmetadata\n   */\n\n\n  Player.prototype.updateStyleEl_ = function updateStyleEl_() {\n    if (window.VIDEOJS_NO_DYNAMIC_STYLE === true) {\n      var _width = typeof this.width_ === 'number' ? this.width_ : this.options_.width;\n      var _height = typeof this.height_ === 'number' ? this.height_ : this.options_.height;\n      var techEl = this.tech_ && this.tech_.el();\n\n      if (techEl) {\n        if (_width >= 0) {\n          techEl.width = _width;\n        }\n        if (_height >= 0) {\n          techEl.height = _height;\n        }\n      }\n\n      return;\n    }\n\n    var width = void 0;\n    var height = void 0;\n    var aspectRatio = void 0;\n    var idClass = void 0;\n\n    // The aspect ratio is either used directly or to calculate width and height.\n    if (this.aspectRatio_ !== undefined && this.aspectRatio_ !== 'auto') {\n      // Use any aspectRatio that's been specifically set\n      aspectRatio = this.aspectRatio_;\n    } else if (this.videoWidth() > 0) {\n      // Otherwise try to get the aspect ratio from the video metadata\n      aspectRatio = this.videoWidth() + ':' + this.videoHeight();\n    } else {\n      // Or use a default. The video element's is 2:1, but 16:9 is more common.\n      aspectRatio = '16:9';\n    }\n\n    // Get the ratio as a decimal we can use to calculate dimensions\n    var ratioParts = aspectRatio.split(':');\n    var ratioMultiplier = ratioParts[1] / ratioParts[0];\n\n    if (this.width_ !== undefined) {\n      // Use any width that's been specifically set\n      width = this.width_;\n    } else if (this.height_ !== undefined) {\n      // Or calulate the width from the aspect ratio if a height has been set\n      width = this.height_ / ratioMultiplier;\n    } else {\n      // Or use the video's metadata, or use the video el's default of 300\n      width = this.videoWidth() || 300;\n    }\n\n    if (this.height_ !== undefined) {\n      // Use any height that's been specifically set\n      height = this.height_;\n    } else {\n      // Otherwise calculate the height from the ratio and the width\n      height = width * ratioMultiplier;\n    }\n\n    // Ensure the CSS class is valid by starting with an alpha character\n    if (/^[^a-zA-Z]/.test(this.id())) {\n      idClass = 'dimensions-' + this.id();\n    } else {\n      idClass = this.id() + '-dimensions';\n    }\n\n    // Ensure the right class is still on the player for the style element\n    this.addClass(idClass);\n\n    setTextContent(this.styleEl_, '\\n      .' + idClass + ' {\\n        width: ' + width + 'px;\\n        height: ' + height + 'px;\\n      }\\n\\n      .' + idClass + '.vjs-fluid {\\n        padding-top: ' + ratioMultiplier * 100 + '%;\\n      }\\n    ');\n  };\n\n  /**\n   * Load/Create an instance of playback {@link Tech} including element\n   * and API methods. Then append the `Tech` element in `Player` as a child.\n   *\n   * @param {string} techName\n   *        name of the playback technology\n   *\n   * @param {string} source\n   *        video source\n   *\n   * @private\n   */\n\n\n  Player.prototype.loadTech_ = function loadTech_(techName, source) {\n    var _this2 = this;\n\n    // Pause and remove current playback technology\n    if (this.tech_) {\n      this.unloadTech_();\n    }\n\n    var titleTechName = toTitleCase(techName);\n    var camelTechName = techName.charAt(0).toLowerCase() + techName.slice(1);\n\n    // get rid of the HTML5 video tag as soon as we are using another tech\n    if (titleTechName !== 'Html5' && this.tag) {\n      Tech.getTech('Html5').disposeMediaElement(this.tag);\n      this.tag.player = null;\n      this.tag = null;\n    }\n\n    this.techName_ = titleTechName;\n\n    // Turn off API access because we're loading a new tech that might load asynchronously\n    this.isReady_ = false;\n\n    // if autoplay is a string we pass false to the tech\n    // because the player is going to handle autoplay on `loadstart`\n    var autoplay = typeof this.autoplay() === 'string' ? false : this.autoplay();\n\n    // Grab tech-specific options from player options and add source and parent element to use.\n    var techOptions = {\n      source: source,\n      autoplay: autoplay,\n      'nativeControlsForTouch': this.options_.nativeControlsForTouch,\n      'playerId': this.id(),\n      'techId': this.id() + '_' + camelTechName + '_api',\n      'playsinline': this.options_.playsinline,\n      'preload': this.options_.preload,\n      'loop': this.options_.loop,\n      'muted': this.options_.muted,\n      'poster': this.poster(),\n      'language': this.language(),\n      'playerElIngest': this.playerElIngest_ || false,\n      'vtt.js': this.options_['vtt.js'],\n      'canOverridePoster': !!this.options_.techCanOverridePoster,\n      'enableSourceset': this.options_.enableSourceset\n    };\n\n    ALL.names.forEach(function (name$$1) {\n      var props = ALL[name$$1];\n\n      techOptions[props.getterName] = _this2[props.privateName];\n    });\n\n    assign(techOptions, this.options_[titleTechName]);\n    assign(techOptions, this.options_[camelTechName]);\n    assign(techOptions, this.options_[techName.toLowerCase()]);\n\n    if (this.tag) {\n      techOptions.tag = this.tag;\n    }\n\n    if (source && source.src === this.cache_.src && this.cache_.currentTime > 0) {\n      techOptions.startTime = this.cache_.currentTime;\n    }\n\n    // Initialize tech instance\n    var TechClass = Tech.getTech(techName);\n\n    if (!TechClass) {\n      throw new Error('No Tech named \\'' + titleTechName + '\\' exists! \\'' + titleTechName + '\\' should be registered using videojs.registerTech()\\'');\n    }\n\n    this.tech_ = new TechClass(techOptions);\n\n    // player.triggerReady is always async, so don't need this to be async\n    this.tech_.ready(bind(this, this.handleTechReady_), true);\n\n    textTrackConverter.jsonToTextTracks(this.textTracksJson_ || [], this.tech_);\n\n    // Listen to all HTML5-defined events and trigger them on the player\n    TECH_EVENTS_RETRIGGER.forEach(function (event) {\n      _this2.on(_this2.tech_, event, _this2['handleTech' + toTitleCase(event) + '_']);\n    });\n\n    Object.keys(TECH_EVENTS_QUEUE).forEach(function (event) {\n      _this2.on(_this2.tech_, event, function (eventObj) {\n        if (_this2.tech_.playbackRate() === 0 && _this2.tech_.seeking()) {\n          _this2.queuedCallbacks_.push({\n            callback: _this2['handleTech' + TECH_EVENTS_QUEUE[event] + '_'].bind(_this2),\n            event: eventObj\n          });\n          return;\n        }\n        _this2['handleTech' + TECH_EVENTS_QUEUE[event] + '_'](eventObj);\n      });\n    });\n\n    this.on(this.tech_, 'loadstart', this.handleTechLoadStart_);\n    this.on(this.tech_, 'sourceset', this.handleTechSourceset_);\n    this.on(this.tech_, 'waiting', this.handleTechWaiting_);\n    this.on(this.tech_, 'ended', this.handleTechEnded_);\n    this.on(this.tech_, 'seeking', this.handleTechSeeking_);\n    this.on(this.tech_, 'play', this.handleTechPlay_);\n    this.on(this.tech_, 'firstplay', this.handleTechFirstPlay_);\n    this.on(this.tech_, 'pause', this.handleTechPause_);\n    this.on(this.tech_, 'durationchange', this.handleTechDurationChange_);\n    this.on(this.tech_, 'fullscreenchange', this.handleTechFullscreenChange_);\n    this.on(this.tech_, 'error', this.handleTechError_);\n    this.on(this.tech_, 'loadedmetadata', this.updateStyleEl_);\n    this.on(this.tech_, 'posterchange', this.handleTechPosterChange_);\n    this.on(this.tech_, 'textdata', this.handleTechTextData_);\n    this.on(this.tech_, 'ratechange', this.handleTechRateChange_);\n\n    this.usingNativeControls(this.techGet_('controls'));\n\n    if (this.controls() && !this.usingNativeControls()) {\n      this.addTechControlsListeners_();\n    }\n\n    // Add the tech element in the DOM if it was not already there\n    // Make sure to not insert the original video element if using Html5\n    if (this.tech_.el().parentNode !== this.el() && (titleTechName !== 'Html5' || !this.tag)) {\n      prependTo(this.tech_.el(), this.el());\n    }\n\n    // Get rid of the original video tag reference after the first tech is loaded\n    if (this.tag) {\n      this.tag.player = null;\n      this.tag = null;\n    }\n  };\n\n  /**\n   * Unload and dispose of the current playback {@link Tech}.\n   *\n   * @private\n   */\n\n\n  Player.prototype.unloadTech_ = function unloadTech_() {\n    var _this3 = this;\n\n    // Save the current text tracks so that we can reuse the same text tracks with the next tech\n    ALL.names.forEach(function (name$$1) {\n      var props = ALL[name$$1];\n\n      _this3[props.privateName] = _this3[props.getterName]();\n    });\n    this.textTracksJson_ = textTrackConverter.textTracksToJson(this.tech_);\n\n    this.isReady_ = false;\n\n    this.tech_.dispose();\n\n    this.tech_ = false;\n\n    if (this.isPosterFromTech_) {\n      this.poster_ = '';\n      this.trigger('posterchange');\n    }\n\n    this.isPosterFromTech_ = false;\n  };\n\n  /**\n   * Return a reference to the current {@link Tech}.\n   * It will print a warning by default about the danger of using the tech directly\n   * but any argument that is passed in will silence the warning.\n   *\n   * @param {*} [safety]\n   *        Anything passed in to silence the warning\n   *\n   * @return {Tech}\n   *         The Tech\n   */\n\n\n  Player.prototype.tech = function tech(safety) {\n    if (safety === undefined) {\n      log.warn(tsml(_templateObject$1));\n    }\n\n    return this.tech_;\n  };\n\n  /**\n   * Set up click and touch listeners for the playback element\n   *\n   * - On desktops: a click on the video itself will toggle playback\n   * - On mobile devices: a click on the video toggles controls\n   *   which is done by toggling the user state between active and\n   *   inactive\n   * - A tap can signal that a user has become active or has become inactive\n   *   e.g. a quick tap on an iPhone movie should reveal the controls. Another\n   *   quick tap should hide them again (signaling the user is in an inactive\n   *   viewing state)\n   * - In addition to this, we still want the user to be considered inactive after\n   *   a few seconds of inactivity.\n   *\n   * > Note: the only part of iOS interaction we can't mimic with this setup\n   * is a touch and hold on the video element counting as activity in order to\n   * keep the controls showing, but that shouldn't be an issue. A touch and hold\n   * on any controls will still keep the user active\n   *\n   * @private\n   */\n\n\n  Player.prototype.addTechControlsListeners_ = function addTechControlsListeners_() {\n    // Make sure to remove all the previous listeners in case we are called multiple times.\n    this.removeTechControlsListeners_();\n\n    // Some browsers (Chrome & IE) don't trigger a click on a flash swf, but do\n    // trigger mousedown/up.\n    // http://stackoverflow.com/questions/1444562/javascript-onclick-event-over-flash-object\n    // Any touch events are set to block the mousedown event from happening\n    this.on(this.tech_, 'mousedown', this.handleTechClick_);\n\n    // If the controls were hidden we don't want that to change without a tap event\n    // so we'll check if the controls were already showing before reporting user\n    // activity\n    this.on(this.tech_, 'touchstart', this.handleTechTouchStart_);\n    this.on(this.tech_, 'touchmove', this.handleTechTouchMove_);\n    this.on(this.tech_, 'touchend', this.handleTechTouchEnd_);\n\n    // The tap listener needs to come after the touchend listener because the tap\n    // listener cancels out any reportedUserActivity when setting userActive(false)\n    this.on(this.tech_, 'tap', this.handleTechTap_);\n  };\n\n  /**\n   * Remove the listeners used for click and tap controls. This is needed for\n   * toggling to controls disabled, where a tap/touch should do nothing.\n   *\n   * @private\n   */\n\n\n  Player.prototype.removeTechControlsListeners_ = function removeTechControlsListeners_() {\n    // We don't want to just use `this.off()` because there might be other needed\n    // listeners added by techs that extend this.\n    this.off(this.tech_, 'tap', this.handleTechTap_);\n    this.off(this.tech_, 'touchstart', this.handleTechTouchStart_);\n    this.off(this.tech_, 'touchmove', this.handleTechTouchMove_);\n    this.off(this.tech_, 'touchend', this.handleTechTouchEnd_);\n    this.off(this.tech_, 'mousedown', this.handleTechClick_);\n  };\n\n  /**\n   * Player waits for the tech to be ready\n   *\n   * @private\n   */\n\n\n  Player.prototype.handleTechReady_ = function handleTechReady_() {\n    this.triggerReady();\n\n    // Keep the same volume as before\n    if (this.cache_.volume) {\n      this.techCall_('setVolume', this.cache_.volume);\n    }\n\n    // Look if the tech found a higher resolution poster while loading\n    this.handleTechPosterChange_();\n\n    // Update the duration if available\n    this.handleTechDurationChange_();\n\n    // Chrome and Safari both have issues with autoplay.\n    // In Safari (5.1.1), when we move the video element into the container div, autoplay doesn't work.\n    // In Chrome (15), if you have autoplay + a poster + no controls, the video gets hidden (but audio plays)\n    // This fixes both issues. Need to wait for API, so it updates displays correctly\n    if ((this.src() || this.currentSrc()) && this.tag && this.options_.autoplay && this.paused()) {\n      try {\n        // Chrome Fix. Fixed in Chrome v16.\n        delete this.tag.poster;\n      } catch (e) {\n        log('deleting tag.poster throws in some browsers', e);\n      }\n    }\n  };\n\n  /**\n   * Retrigger the `loadstart` event that was triggered by the {@link Tech}. This\n   * function will also trigger {@link Player#firstplay} if it is the first loadstart\n   * for a video.\n   *\n   * @fires Player#loadstart\n   * @fires Player#firstplay\n   * @listens Tech#loadstart\n   * @private\n   */\n\n\n  Player.prototype.handleTechLoadStart_ = function handleTechLoadStart_() {\n    // TODO: Update to use `emptied` event instead. See #1277.\n\n    this.removeClass('vjs-ended');\n    this.removeClass('vjs-seeking');\n\n    // reset the error state\n    this.error(null);\n\n    // If it's already playing we want to trigger a firstplay event now.\n    // The firstplay event relies on both the play and loadstart events\n    // which can happen in any order for a new source\n    if (!this.paused()) {\n      /**\n       * Fired when the user agent begins looking for media data\n       *\n       * @event Player#loadstart\n       * @type {EventTarget~Event}\n       */\n      this.trigger('loadstart');\n      this.trigger('firstplay');\n    } else {\n      // reset the hasStarted state\n      this.hasStarted(false);\n      this.trigger('loadstart');\n    }\n\n    // autoplay happens after loadstart for the browser,\n    // so we mimic that behavior\n    this.manualAutoplay_(this.autoplay());\n  };\n\n  /**\n   * Handle autoplay string values, rather than the typical boolean\n   * values that should be handled by the tech. Note that this is not\n   * part of any specification. Valid values and what they do can be\n   * found on the autoplay getter at Player#autoplay()\n   */\n\n\n  Player.prototype.manualAutoplay_ = function manualAutoplay_(type) {\n    var _this4 = this;\n\n    if (!this.tech_ || typeof type !== 'string') {\n      return;\n    }\n\n    var muted = function muted() {\n      var previouslyMuted = _this4.muted();\n\n      _this4.muted(true);\n\n      var playPromise = _this4.play();\n\n      if (!playPromise || !playPromise.then || !playPromise['catch']) {\n        return;\n      }\n\n      return playPromise['catch'](function (e) {\n        // restore old value of muted on failure\n        _this4.muted(previouslyMuted);\n      });\n    };\n\n    var promise = void 0;\n\n    if (type === 'any') {\n      promise = this.play();\n\n      if (promise && promise.then && promise['catch']) {\n        promise['catch'](function () {\n          return muted();\n        });\n      }\n    } else if (type === 'muted') {\n      promise = muted();\n    } else {\n      promise = this.play();\n    }\n\n    if (!promise || !promise.then || !promise['catch']) {\n      return;\n    }\n\n    return promise.then(function () {\n      _this4.trigger({ type: 'autoplay-success', autoplay: type });\n    })['catch'](function (e) {\n      _this4.trigger({ type: 'autoplay-failure', autoplay: type });\n    });\n  };\n\n  /**\n   * Update the internal source caches so that we return the correct source from\n   * `src()`, `currentSource()`, and `currentSources()`.\n   *\n   * > Note: `currentSources` will not be updated if the source that is passed in exists\n   *         in the current `currentSources` cache.\n   *\n   *\n   * @param {Tech~SourceObject} srcObj\n   *        A string or object source to update our caches to.\n   */\n\n\n  Player.prototype.updateSourceCaches_ = function updateSourceCaches_() {\n    var srcObj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n\n\n    var src = srcObj;\n    var type = '';\n\n    if (typeof src !== 'string') {\n      src = srcObj.src;\n      type = srcObj.type;\n    }\n\n    // make sure all the caches are set to default values\n    // to prevent null checking\n    this.cache_.source = this.cache_.source || {};\n    this.cache_.sources = this.cache_.sources || [];\n\n    // try to get the type of the src that was passed in\n    if (src && !type) {\n      type = findMimetype(this, src);\n    }\n\n    // update `currentSource` cache always\n    this.cache_.source = mergeOptions({}, srcObj, { src: src, type: type });\n\n    var matchingSources = this.cache_.sources.filter(function (s) {\n      return s.src && s.src === src;\n    });\n    var sourceElSources = [];\n    var sourceEls = this.$$('source');\n    var matchingSourceEls = [];\n\n    for (var i = 0; i < sourceEls.length; i++) {\n      var sourceObj = getAttributes(sourceEls[i]);\n\n      sourceElSources.push(sourceObj);\n\n      if (sourceObj.src && sourceObj.src === src) {\n        matchingSourceEls.push(sourceObj.src);\n      }\n    }\n\n    // if we have matching source els but not matching sources\n    // the current source cache is not up to date\n    if (matchingSourceEls.length && !matchingSources.length) {\n      this.cache_.sources = sourceElSources;\n      // if we don't have matching source or source els set the\n      // sources cache to the `currentSource` cache\n    } else if (!matchingSources.length) {\n      this.cache_.sources = [this.cache_.source];\n    }\n\n    // update the tech `src` cache\n    this.cache_.src = src;\n  };\n\n  /**\n   * *EXPERIMENTAL* Fired when the source is set or changed on the {@link Tech}\n   * causing the media element to reload.\n   *\n   * It will fire for the initial source and each subsequent source.\n   * This event is a custom event from Video.js and is triggered by the {@link Tech}.\n   *\n   * The event object for this event contains a `src` property that will contain the source\n   * that was available when the event was triggered. This is generally only necessary if Video.js\n   * is switching techs while the source was being changed.\n   *\n   * It is also fired when `load` is called on the player (or media element)\n   * because the {@link https://html.spec.whatwg.org/multipage/media.html#dom-media-load|specification for `load`}\n   * says that the resource selection algorithm needs to be aborted and restarted.\n   * In this case, it is very likely that the `src` property will be set to the\n   * empty string `\"\"` to indicate we do not know what the source will be but\n   * that it is changing.\n   *\n   * *This event is currently still experimental and may change in minor releases.*\n   * __To use this, pass `enableSourceset` option to the player.__\n   *\n   * @event Player#sourceset\n   * @type {EventTarget~Event}\n   * @prop {string} src\n   *                The source url available when the `sourceset` was triggered.\n   *                It will be an empty string if we cannot know what the source is\n   *                but know that the source will change.\n   */\n  /**\n   * Retrigger the `sourceset` event that was triggered by the {@link Tech}.\n   *\n   * @fires Player#sourceset\n   * @listens Tech#sourceset\n   * @private\n   */\n\n\n  Player.prototype.handleTechSourceset_ = function handleTechSourceset_(event) {\n    var _this5 = this;\n\n    // only update the source cache when the source\n    // was not updated using the player api\n    if (!this.changingSrc_) {\n      var updateSourceCaches = function updateSourceCaches(src) {\n        return _this5.updateSourceCaches_(src);\n      };\n      var playerSrc = this.currentSource().src;\n      var eventSrc = event.src;\n\n      // if we have a playerSrc that is not a blob, and a tech src that is a blob\n      if (playerSrc && !/^blob:/.test(playerSrc) && /^blob:/.test(eventSrc)) {\n\n        // if both the tech source and the player source were updated we assume\n        // something like @videojs/http-streaming did the sourceset and skip updating the source cache.\n        if (!this.lastSource_ || this.lastSource_.tech !== eventSrc && this.lastSource_.player !== playerSrc) {\n          updateSourceCaches = function updateSourceCaches() {};\n        }\n      }\n\n      // update the source to the intial source right away\n      // in some cases this will be empty string\n      updateSourceCaches(eventSrc);\n\n      // if the `sourceset` `src` was an empty string\n      // wait for a `loadstart` to update the cache to `currentSrc`.\n      // If a sourceset happens before a `loadstart`, we reset the state\n      // as this function will be called again.\n      if (!event.src) {\n        var updateCache = function updateCache(e) {\n          if (e.type !== 'sourceset') {\n            var techSrc = _this5.techGet('currentSrc');\n\n            _this5.lastSource_.tech = techSrc;\n            _this5.updateSourceCaches_(techSrc);\n          }\n\n          _this5.tech_.off(['sourceset', 'loadstart'], updateCache);\n        };\n\n        this.tech_.one(['sourceset', 'loadstart'], updateCache);\n      }\n    }\n    this.lastSource_ = { player: this.currentSource().src, tech: event.src };\n\n    this.trigger({\n      src: event.src,\n      type: 'sourceset'\n    });\n  };\n\n  /**\n   * Add/remove the vjs-has-started class\n   *\n   * @fires Player#firstplay\n   *\n   * @param {boolean} request\n   *        - true: adds the class\n   *        - false: remove the class\n   *\n   * @return {boolean}\n   *         the boolean value of hasStarted_\n   */\n\n\n  Player.prototype.hasStarted = function hasStarted(request) {\n    if (request === undefined) {\n      // act as getter, if we have no request to change\n      return this.hasStarted_;\n    }\n\n    if (request === this.hasStarted_) {\n      return;\n    }\n\n    this.hasStarted_ = request;\n\n    if (this.hasStarted_) {\n      this.addClass('vjs-has-started');\n      this.trigger('firstplay');\n    } else {\n      this.removeClass('vjs-has-started');\n    }\n  };\n\n  /**\n   * Fired whenever the media begins or resumes playback\n   *\n   * @see [Spec]{@link https://html.spec.whatwg.org/multipage/embedded-content.html#dom-media-play}\n   * @fires Player#play\n   * @listens Tech#play\n   * @private\n   */\n\n\n  Player.prototype.handleTechPlay_ = function handleTechPlay_() {\n    this.removeClass('vjs-ended');\n    this.removeClass('vjs-paused');\n    this.addClass('vjs-playing');\n\n    // hide the poster when the user hits play\n    this.hasStarted(true);\n    /**\n     * Triggered whenever an {@link Tech#play} event happens. Indicates that\n     * playback has started or resumed.\n     *\n     * @event Player#play\n     * @type {EventTarget~Event}\n     */\n    this.trigger('play');\n  };\n\n  /**\n   * Retrigger the `ratechange` event that was triggered by the {@link Tech}.\n   *\n   * If there were any events queued while the playback rate was zero, fire\n   * those events now.\n   *\n   * @private\n   * @method Player#handleTechRateChange_\n   * @fires Player#ratechange\n   * @listens Tech#ratechange\n   */\n\n\n  Player.prototype.handleTechRateChange_ = function handleTechRateChange_() {\n    if (this.tech_.playbackRate() > 0 && this.cache_.lastPlaybackRate === 0) {\n      this.queuedCallbacks_.forEach(function (queued) {\n        return queued.callback(queued.event);\n      });\n      this.queuedCallbacks_ = [];\n    }\n    this.cache_.lastPlaybackRate = this.tech_.playbackRate();\n    /**\n     * Fires when the playing speed of the audio/video is changed\n     *\n     * @event Player#ratechange\n     * @type {event}\n     */\n    this.trigger('ratechange');\n  };\n\n  /**\n   * Retrigger the `waiting` event that was triggered by the {@link Tech}.\n   *\n   * @fires Player#waiting\n   * @listens Tech#waiting\n   * @private\n   */\n\n\n  Player.prototype.handleTechWaiting_ = function handleTechWaiting_() {\n    var _this6 = this;\n\n    this.addClass('vjs-waiting');\n    /**\n     * A readyState change on the DOM element has caused playback to stop.\n     *\n     * @event Player#waiting\n     * @type {EventTarget~Event}\n     */\n    this.trigger('waiting');\n    this.one('timeupdate', function () {\n      return _this6.removeClass('vjs-waiting');\n    });\n  };\n\n  /**\n   * Retrigger the `canplay` event that was triggered by the {@link Tech}.\n   * > Note: This is not consistent between browsers. See #1351\n   *\n   * @fires Player#canplay\n   * @listens Tech#canplay\n   * @private\n   */\n\n\n  Player.prototype.handleTechCanPlay_ = function handleTechCanPlay_() {\n    this.removeClass('vjs-waiting');\n    /**\n     * The media has a readyState of HAVE_FUTURE_DATA or greater.\n     *\n     * @event Player#canplay\n     * @type {EventTarget~Event}\n     */\n    this.trigger('canplay');\n  };\n\n  /**\n   * Retrigger the `canplaythrough` event that was triggered by the {@link Tech}.\n   *\n   * @fires Player#canplaythrough\n   * @listens Tech#canplaythrough\n   * @private\n   */\n\n\n  Player.prototype.handleTechCanPlayThrough_ = function handleTechCanPlayThrough_() {\n    this.removeClass('vjs-waiting');\n    /**\n     * The media has a readyState of HAVE_ENOUGH_DATA or greater. This means that the\n     * entire media file can be played without buffering.\n     *\n     * @event Player#canplaythrough\n     * @type {EventTarget~Event}\n     */\n    this.trigger('canplaythrough');\n  };\n\n  /**\n   * Retrigger the `playing` event that was triggered by the {@link Tech}.\n   *\n   * @fires Player#playing\n   * @listens Tech#playing\n   * @private\n   */\n\n\n  Player.prototype.handleTechPlaying_ = function handleTechPlaying_() {\n    this.removeClass('vjs-waiting');\n    /**\n     * The media is no longer blocked from playback, and has started playing.\n     *\n     * @event Player#playing\n     * @type {EventTarget~Event}\n     */\n    this.trigger('playing');\n  };\n\n  /**\n   * Retrigger the `seeking` event that was triggered by the {@link Tech}.\n   *\n   * @fires Player#seeking\n   * @listens Tech#seeking\n   * @private\n   */\n\n\n  Player.prototype.handleTechSeeking_ = function handleTechSeeking_() {\n    this.addClass('vjs-seeking');\n    /**\n     * Fired whenever the player is jumping to a new time\n     *\n     * @event Player#seeking\n     * @type {EventTarget~Event}\n     */\n    this.trigger('seeking');\n  };\n\n  /**\n   * Retrigger the `seeked` event that was triggered by the {@link Tech}.\n   *\n   * @fires Player#seeked\n   * @listens Tech#seeked\n   * @private\n   */\n\n\n  Player.prototype.handleTechSeeked_ = function handleTechSeeked_() {\n    this.removeClass('vjs-seeking');\n    /**\n     * Fired when the player has finished jumping to a new time\n     *\n     * @event Player#seeked\n     * @type {EventTarget~Event}\n     */\n    this.trigger('seeked');\n  };\n\n  /**\n   * Retrigger the `firstplay` event that was triggered by the {@link Tech}.\n   *\n   * @fires Player#firstplay\n   * @listens Tech#firstplay\n   * @deprecated As of 6.0 firstplay event is deprecated.\n   *             As of 6.0 passing the `starttime` option to the player and the firstplay event are deprecated.\n   * @private\n   */\n\n\n  Player.prototype.handleTechFirstPlay_ = function handleTechFirstPlay_() {\n    // If the first starttime attribute is specified\n    // then we will start at the given offset in seconds\n    if (this.options_.starttime) {\n      log.warn('Passing the `starttime` option to the player will be deprecated in 6.0');\n      this.currentTime(this.options_.starttime);\n    }\n\n    this.addClass('vjs-has-started');\n    /**\n     * Fired the first time a video is played. Not part of the HLS spec, and this is\n     * probably not the best implementation yet, so use sparingly. If you don't have a\n     * reason to prevent playback, use `myPlayer.one('play');` instead.\n     *\n     * @event Player#firstplay\n     * @deprecated As of 6.0 firstplay event is deprecated.\n     * @type {EventTarget~Event}\n     */\n    this.trigger('firstplay');\n  };\n\n  /**\n   * Retrigger the `pause` event that was triggered by the {@link Tech}.\n   *\n   * @fires Player#pause\n   * @listens Tech#pause\n   * @private\n   */\n\n\n  Player.prototype.handleTechPause_ = function handleTechPause_() {\n    this.removeClass('vjs-playing');\n    this.addClass('vjs-paused');\n    /**\n     * Fired whenever the media has been paused\n     *\n     * @event Player#pause\n     * @type {EventTarget~Event}\n     */\n    this.trigger('pause');\n  };\n\n  /**\n   * Retrigger the `ended` event that was triggered by the {@link Tech}.\n   *\n   * @fires Player#ended\n   * @listens Tech#ended\n   * @private\n   */\n\n\n  Player.prototype.handleTechEnded_ = function handleTechEnded_() {\n    this.addClass('vjs-ended');\n    if (this.options_.loop) {\n      this.currentTime(0);\n      this.play();\n    } else if (!this.paused()) {\n      this.pause();\n    }\n\n    /**\n     * Fired when the end of the media resource is reached (currentTime == duration)\n     *\n     * @event Player#ended\n     * @type {EventTarget~Event}\n     */\n    this.trigger('ended');\n  };\n\n  /**\n   * Fired when the duration of the media resource is first known or changed\n   *\n   * @listens Tech#durationchange\n   * @private\n   */\n\n\n  Player.prototype.handleTechDurationChange_ = function handleTechDurationChange_() {\n    this.duration(this.techGet_('duration'));\n  };\n\n  /**\n   * Handle a click on the media element to play/pause\n   *\n   * @param {EventTarget~Event} event\n   *        the event that caused this function to trigger\n   *\n   * @listens Tech#mousedown\n   * @private\n   */\n\n\n  Player.prototype.handleTechClick_ = function handleTechClick_(event) {\n    if (!isSingleLeftClick(event)) {\n      return;\n    }\n\n    // When controls are disabled a click should not toggle playback because\n    // the click is considered a control\n    if (!this.controls_) {\n      return;\n    }\n\n    if (this.paused()) {\n      silencePromise(this.play());\n    } else {\n      this.pause();\n    }\n  };\n\n  /**\n   * Handle a tap on the media element. It will toggle the user\n   * activity state, which hides and shows the controls.\n   *\n   * @listens Tech#tap\n   * @private\n   */\n\n\n  Player.prototype.handleTechTap_ = function handleTechTap_() {\n    this.userActive(!this.userActive());\n  };\n\n  /**\n   * Handle touch to start\n   *\n   * @listens Tech#touchstart\n   * @private\n   */\n\n\n  Player.prototype.handleTechTouchStart_ = function handleTechTouchStart_() {\n    this.userWasActive = this.userActive();\n  };\n\n  /**\n   * Handle touch to move\n   *\n   * @listens Tech#touchmove\n   * @private\n   */\n\n\n  Player.prototype.handleTechTouchMove_ = function handleTechTouchMove_() {\n    if (this.userWasActive) {\n      this.reportUserActivity();\n    }\n  };\n\n  /**\n   * Handle touch to end\n   *\n   * @param {EventTarget~Event} event\n   *        the touchend event that triggered\n   *        this function\n   *\n   * @listens Tech#touchend\n   * @private\n   */\n\n\n  Player.prototype.handleTechTouchEnd_ = function handleTechTouchEnd_(event) {\n    // Stop the mouse events from also happening\n    event.preventDefault();\n  };\n\n  /**\n   * Fired when the player switches in or out of fullscreen mode\n   *\n   * @private\n   * @listens Player#fullscreenchange\n   */\n\n\n  Player.prototype.handleFullscreenChange_ = function handleFullscreenChange_() {\n    if (this.isFullscreen()) {\n      this.addClass('vjs-fullscreen');\n    } else {\n      this.removeClass('vjs-fullscreen');\n    }\n  };\n\n  /**\n   * native click events on the SWF aren't triggered on IE11, Win8.1RT\n   * use stageclick events triggered from inside the SWF instead\n   *\n   * @private\n   * @listens stageclick\n   */\n\n\n  Player.prototype.handleStageClick_ = function handleStageClick_() {\n    this.reportUserActivity();\n  };\n\n  /**\n   * Handle Tech Fullscreen Change\n   *\n   * @param {EventTarget~Event} event\n   *        the fullscreenchange event that triggered this function\n   *\n   * @param {Object} data\n   *        the data that was sent with the event\n   *\n   * @private\n   * @listens Tech#fullscreenchange\n   * @fires Player#fullscreenchange\n   */\n\n\n  Player.prototype.handleTechFullscreenChange_ = function handleTechFullscreenChange_(event, data) {\n    if (data) {\n      this.isFullscreen(data.isFullscreen);\n    }\n    /**\n     * Fired when going in and out of fullscreen.\n     *\n     * @event Player#fullscreenchange\n     * @type {EventTarget~Event}\n     */\n    this.trigger('fullscreenchange');\n  };\n\n  /**\n   * Fires when an error occurred during the loading of an audio/video.\n   *\n   * @private\n   * @listens Tech#error\n   */\n\n\n  Player.prototype.handleTechError_ = function handleTechError_() {\n    var error = this.tech_.error();\n\n    this.error(error);\n  };\n\n  /**\n   * Retrigger the `textdata` event that was triggered by the {@link Tech}.\n   *\n   * @fires Player#textdata\n   * @listens Tech#textdata\n   * @private\n   */\n\n\n  Player.prototype.handleTechTextData_ = function handleTechTextData_() {\n    var data = null;\n\n    if (arguments.length > 1) {\n      data = arguments[1];\n    }\n\n    /**\n     * Fires when we get a textdata event from tech\n     *\n     * @event Player#textdata\n     * @type {EventTarget~Event}\n     */\n    this.trigger('textdata', data);\n  };\n\n  /**\n   * Get object for cached values.\n   *\n   * @return {Object}\n   *         get the current object cache\n   */\n\n\n  Player.prototype.getCache = function getCache() {\n    return this.cache_;\n  };\n\n  /**\n   * Pass values to the playback tech\n   *\n   * @param {string} [method]\n   *        the method to call\n   *\n   * @param {Object} arg\n   *        the argument to pass\n   *\n   * @private\n   */\n\n\n  Player.prototype.techCall_ = function techCall_(method, arg) {\n    // If it's not ready yet, call method when it is\n\n    this.ready(function () {\n      if (method in allowedSetters) {\n        return set$1(this.middleware_, this.tech_, method, arg);\n      } else if (method in allowedMediators) {\n        return mediate(this.middleware_, this.tech_, method, arg);\n      }\n\n      try {\n        if (this.tech_) {\n          this.tech_[method](arg);\n        }\n      } catch (e) {\n        log(e);\n        throw e;\n      }\n    }, true);\n  };\n\n  /**\n   * Get calls can't wait for the tech, and sometimes don't need to.\n   *\n   * @param {string} method\n   *        Tech method\n   *\n   * @return {Function|undefined}\n   *         the method or undefined\n   *\n   * @private\n   */\n\n\n  Player.prototype.techGet_ = function techGet_(method) {\n    if (!this.tech_ || !this.tech_.isReady_) {\n      return;\n    }\n\n    if (method in allowedGetters) {\n      return get$1(this.middleware_, this.tech_, method);\n    } else if (method in allowedMediators) {\n      return mediate(this.middleware_, this.tech_, method);\n    }\n\n    // Flash likes to die and reload when you hide or reposition it.\n    // In these cases the object methods go away and we get errors.\n    // When that happens we'll catch the errors and inform tech that it's not ready any more.\n    try {\n      return this.tech_[method]();\n    } catch (e) {\n\n      // When building additional tech libs, an expected method may not be defined yet\n      if (this.tech_[method] === undefined) {\n        log('Video.js: ' + method + ' method not defined for ' + this.techName_ + ' playback technology.', e);\n        throw e;\n      }\n\n      // When a method isn't available on the object it throws a TypeError\n      if (e.name === 'TypeError') {\n        log('Video.js: ' + method + ' unavailable on ' + this.techName_ + ' playback technology element.', e);\n        this.tech_.isReady_ = false;\n        throw e;\n      }\n\n      // If error unknown, just log and throw\n      log(e);\n      throw e;\n    }\n  };\n\n  /**\n   * Attempt to begin playback at the first opportunity.\n   *\n   * @return {Promise|undefined}\n   *         Returns a promise if the browser supports Promises (or one\n   *         was passed in as an option). This promise will be resolved on\n   *         the return value of play. If this is undefined it will fulfill the\n   *         promise chain otherwise the promise chain will be fulfilled when\n   *         the promise from play is fulfilled.\n   */\n\n\n  Player.prototype.play = function play() {\n    var _this7 = this;\n\n    var PromiseClass = this.options_.Promise || window.Promise;\n\n    if (PromiseClass) {\n      return new PromiseClass(function (resolve) {\n        _this7.play_(resolve);\n      });\n    }\n\n    return this.play_();\n  };\n\n  /**\n   * The actual logic for play, takes a callback that will be resolved on the\n   * return value of play. This allows us to resolve to the play promise if there\n   * is one on modern browsers.\n   *\n   * @private\n   * @param {Function} [callback]\n   *        The callback that should be called when the techs play is actually called\n   */\n\n\n  Player.prototype.play_ = function play_() {\n    var _this8 = this;\n\n    var callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : silencePromise;\n\n    // If this is called while we have a play queued up on a loadstart, remove\n    // that listener to avoid getting in a potentially bad state.\n    if (this.playOnLoadstart_) {\n      this.off('loadstart', this.playOnLoadstart_);\n    }\n\n    // If the player/tech is not ready, queue up another call to `play()` for\n    // when it is. This will loop back into this method for another attempt at\n    // playback when the tech is ready.\n    if (!this.isReady_) {\n\n      // Bail out if we're already waiting for `ready`!\n      if (this.playWaitingForReady_) {\n        return;\n      }\n\n      this.playWaitingForReady_ = true;\n      this.ready(function () {\n        _this8.playWaitingForReady_ = false;\n        callback(_this8.play());\n      });\n\n      // If the player/tech is ready and we have a source, we can attempt playback.\n    } else if (!this.changingSrc_ && (this.src() || this.currentSrc())) {\n      callback(this.techGet_('play'));\n      return;\n\n      // If the tech is ready, but we do not have a source, we'll need to wait\n      // for both the `ready` and a `loadstart` when the source is finally\n      // resolved by middleware and set on the player.\n      //\n      // This can happen if `play()` is called while changing sources or before\n      // one has been set on the player.\n    } else {\n\n      this.playOnLoadstart_ = function () {\n        _this8.playOnLoadstart_ = null;\n        callback(_this8.play());\n      };\n\n      this.one('loadstart', this.playOnLoadstart_);\n    }\n  };\n\n  /**\n   * Pause the video playback\n   *\n   * @return {Player}\n   *         A reference to the player object this function was called on\n   */\n\n\n  Player.prototype.pause = function pause() {\n    this.techCall_('pause');\n  };\n\n  /**\n   * Check if the player is paused or has yet to play\n   *\n   * @return {boolean}\n   *         - false: if the media is currently playing\n   *         - true: if media is not currently playing\n   */\n\n\n  Player.prototype.paused = function paused() {\n    // The initial state of paused should be true (in Safari it's actually false)\n    return this.techGet_('paused') === false ? false : true;\n  };\n\n  /**\n   * Get a TimeRange object representing the current ranges of time that the user\n   * has played.\n   *\n   * @return {TimeRange}\n   *         A time range object that represents all the increments of time that have\n   *         been played.\n   */\n\n\n  Player.prototype.played = function played() {\n    return this.techGet_('played') || createTimeRanges(0, 0);\n  };\n\n  /**\n   * Returns whether or not the user is \"scrubbing\". Scrubbing is\n   * when the user has clicked the progress bar handle and is\n   * dragging it along the progress bar.\n   *\n   * @param {boolean} [isScrubbing]\n   *        wether the user is or is not scrubbing\n   *\n   * @return {boolean}\n   *         The value of scrubbing when getting\n   */\n\n\n  Player.prototype.scrubbing = function scrubbing(isScrubbing) {\n    if (typeof isScrubbing === 'undefined') {\n      return this.scrubbing_;\n    }\n    this.scrubbing_ = !!isScrubbing;\n\n    if (isScrubbing) {\n      this.addClass('vjs-scrubbing');\n    } else {\n      this.removeClass('vjs-scrubbing');\n    }\n  };\n\n  /**\n   * Get or set the current time (in seconds)\n   *\n   * @param {number|string} [seconds]\n   *        The time to seek to in seconds\n   *\n   * @return {number}\n   *         - the current time in seconds when getting\n   */\n\n\n  Player.prototype.currentTime = function currentTime(seconds) {\n    if (typeof seconds !== 'undefined') {\n      if (seconds < 0) {\n        seconds = 0;\n      }\n      this.techCall_('setCurrentTime', seconds);\n      return;\n    }\n\n    // cache last currentTime and return. default to 0 seconds\n    //\n    // Caching the currentTime is meant to prevent a massive amount of reads on the tech's\n    // currentTime when scrubbing, but may not provide much performance benefit afterall.\n    // Should be tested. Also something has to read the actual current time or the cache will\n    // never get updated.\n    this.cache_.currentTime = this.techGet_('currentTime') || 0;\n    return this.cache_.currentTime;\n  };\n\n  /**\n   * Normally gets the length in time of the video in seconds;\n   * in all but the rarest use cases an argument will NOT be passed to the method\n   *\n   * > **NOTE**: The video must have started loading before the duration can be\n   * known, and in the case of Flash, may not be known until the video starts\n   * playing.\n   *\n   * @fires Player#durationchange\n   *\n   * @param {number} [seconds]\n   *        The duration of the video to set in seconds\n   *\n   * @return {number}\n   *         - The duration of the video in seconds when getting\n   */\n\n\n  Player.prototype.duration = function duration(seconds) {\n    if (seconds === undefined) {\n      // return NaN if the duration is not known\n      return this.cache_.duration !== undefined ? this.cache_.duration : NaN;\n    }\n\n    seconds = parseFloat(seconds);\n\n    // Standardize on Inifity for signaling video is live\n    if (seconds < 0) {\n      seconds = Infinity;\n    }\n\n    if (seconds !== this.cache_.duration) {\n      // Cache the last set value for optimized scrubbing (esp. Flash)\n      this.cache_.duration = seconds;\n\n      if (seconds === Infinity) {\n        this.addClass('vjs-live');\n      } else {\n        this.removeClass('vjs-live');\n      }\n      /**\n       * @event Player#durationchange\n       * @type {EventTarget~Event}\n       */\n      this.trigger('durationchange');\n    }\n  };\n\n  /**\n   * Calculates how much time is left in the video. Not part\n   * of the native video API.\n   *\n   * @return {number}\n   *         The time remaining in seconds\n   */\n\n\n  Player.prototype.remainingTime = function remainingTime() {\n    return this.duration() - this.currentTime();\n  };\n\n  /**\n   * A remaining time function that is intented to be used when\n   * the time is to be displayed directly to the user.\n   *\n   * @return {number}\n   *         The rounded time remaining in seconds\n   */\n\n\n  Player.prototype.remainingTimeDisplay = function remainingTimeDisplay() {\n    return Math.floor(this.duration()) - Math.floor(this.currentTime());\n  };\n\n  //\n  // Kind of like an array of portions of the video that have been downloaded.\n\n  /**\n   * Get a TimeRange object with an array of the times of the video\n   * that have been downloaded. If you just want the percent of the\n   * video that's been downloaded, use bufferedPercent.\n   *\n   * @see [Buffered Spec]{@link http://dev.w3.org/html5/spec/video.html#dom-media-buffered}\n   *\n   * @return {TimeRange}\n   *         A mock TimeRange object (following HTML spec)\n   */\n\n\n  Player.prototype.buffered = function buffered() {\n    var buffered = this.techGet_('buffered');\n\n    if (!buffered || !buffered.length) {\n      buffered = createTimeRanges(0, 0);\n    }\n\n    return buffered;\n  };\n\n  /**\n   * Get the percent (as a decimal) of the video that's been downloaded.\n   * This method is not a part of the native HTML video API.\n   *\n   * @return {number}\n   *         A decimal between 0 and 1 representing the percent\n   *         that is bufferred 0 being 0% and 1 being 100%\n   */\n\n\n  Player.prototype.bufferedPercent = function bufferedPercent$$1() {\n    return bufferedPercent(this.buffered(), this.duration());\n  };\n\n  /**\n   * Get the ending time of the last buffered time range\n   * This is used in the progress bar to encapsulate all time ranges.\n   *\n   * @return {number}\n   *         The end of the last buffered time range\n   */\n\n\n  Player.prototype.bufferedEnd = function bufferedEnd() {\n    var buffered = this.buffered();\n    var duration = this.duration();\n    var end = buffered.end(buffered.length - 1);\n\n    if (end > duration) {\n      end = duration;\n    }\n\n    return end;\n  };\n\n  /**\n   * Get or set the current volume of the media\n   *\n   * @param  {number} [percentAsDecimal]\n   *         The new volume as a decimal percent:\n   *         - 0 is muted/0%/off\n   *         - 1.0 is 100%/full\n   *         - 0.5 is half volume or 50%\n   *\n   * @return {number}\n   *         The current volume as a percent when getting\n   */\n\n\n  Player.prototype.volume = function volume(percentAsDecimal) {\n    var vol = void 0;\n\n    if (percentAsDecimal !== undefined) {\n      // Force value to between 0 and 1\n      vol = Math.max(0, Math.min(1, parseFloat(percentAsDecimal)));\n      this.cache_.volume = vol;\n      this.techCall_('setVolume', vol);\n\n      if (vol > 0) {\n        this.lastVolume_(vol);\n      }\n\n      return;\n    }\n\n    // Default to 1 when returning current volume.\n    vol = parseFloat(this.techGet_('volume'));\n    return isNaN(vol) ? 1 : vol;\n  };\n\n  /**\n   * Get the current muted state, or turn mute on or off\n   *\n   * @param {boolean} [muted]\n   *        - true to mute\n   *        - false to unmute\n   *\n   * @return {boolean}\n   *         - true if mute is on and getting\n   *         - false if mute is off and getting\n   */\n\n\n  Player.prototype.muted = function muted(_muted) {\n    if (_muted !== undefined) {\n      this.techCall_('setMuted', _muted);\n      return;\n    }\n    return this.techGet_('muted') || false;\n  };\n\n  /**\n   * Get the current defaultMuted state, or turn defaultMuted on or off. defaultMuted\n   * indicates the state of muted on intial playback.\n   *\n   * ```js\n   *   var myPlayer = videojs('some-player-id');\n   *\n   *   myPlayer.src(\"http://www.example.com/path/to/video.mp4\");\n   *\n   *   // get, should be false\n   *   console.log(myPlayer.defaultMuted());\n   *   // set to true\n   *   myPlayer.defaultMuted(true);\n   *   // get should be true\n   *   console.log(myPlayer.defaultMuted());\n   * ```\n   *\n   * @param {boolean} [defaultMuted]\n   *        - true to mute\n   *        - false to unmute\n   *\n   * @return {boolean|Player}\n   *         - true if defaultMuted is on and getting\n   *         - false if defaultMuted is off and getting\n   *         - A reference to the current player when setting\n   */\n\n\n  Player.prototype.defaultMuted = function defaultMuted(_defaultMuted) {\n    if (_defaultMuted !== undefined) {\n      return this.techCall_('setDefaultMuted', _defaultMuted);\n    }\n    return this.techGet_('defaultMuted') || false;\n  };\n\n  /**\n   * Get the last volume, or set it\n   *\n   * @param  {number} [percentAsDecimal]\n   *         The new last volume as a decimal percent:\n   *         - 0 is muted/0%/off\n   *         - 1.0 is 100%/full\n   *         - 0.5 is half volume or 50%\n   *\n   * @return {number}\n   *         the current value of lastVolume as a percent when getting\n   *\n   * @private\n   */\n\n\n  Player.prototype.lastVolume_ = function lastVolume_(percentAsDecimal) {\n    if (percentAsDecimal !== undefined && percentAsDecimal !== 0) {\n      this.cache_.lastVolume = percentAsDecimal;\n      return;\n    }\n    return this.cache_.lastVolume;\n  };\n\n  /**\n   * Check if current tech can support native fullscreen\n   * (e.g. with built in controls like iOS, so not our flash swf)\n   *\n   * @return {boolean}\n   *         if native fullscreen is supported\n   */\n\n\n  Player.prototype.supportsFullScreen = function supportsFullScreen() {\n    return this.techGet_('supportsFullScreen') || false;\n  };\n\n  /**\n   * Check if the player is in fullscreen mode or tell the player that it\n   * is or is not in fullscreen mode.\n   *\n   * > NOTE: As of the latest HTML5 spec, isFullscreen is no longer an official\n   * property and instead document.fullscreenElement is used. But isFullscreen is\n   * still a valuable property for internal player workings.\n   *\n   * @param  {boolean} [isFS]\n   *         Set the players current fullscreen state\n   *\n   * @return {boolean}\n   *         - true if fullscreen is on and getting\n   *         - false if fullscreen is off and getting\n   */\n\n\n  Player.prototype.isFullscreen = function isFullscreen(isFS) {\n    if (isFS !== undefined) {\n      this.isFullscreen_ = !!isFS;\n      return;\n    }\n    return !!this.isFullscreen_;\n  };\n\n  /**\n   * Increase the size of the video to full screen\n   * In some browsers, full screen is not supported natively, so it enters\n   * \"full window mode\", where the video fills the browser window.\n   * In browsers and devices that support native full screen, sometimes the\n   * browser's default controls will be shown, and not the Video.js custom skin.\n   * This includes most mobile devices (iOS, Android) and older versions of\n   * Safari.\n   *\n   * @fires Player#fullscreenchange\n   */\n\n\n  Player.prototype.requestFullscreen = function requestFullscreen() {\n    var fsApi = FullscreenApi;\n\n    this.isFullscreen(true);\n\n    if (fsApi.requestFullscreen) {\n      // the browser supports going fullscreen at the element level so we can\n      // take the controls fullscreen as well as the video\n\n      // Trigger fullscreenchange event after change\n      // We have to specifically add this each time, and remove\n      // when canceling fullscreen. Otherwise if there's multiple\n      // players on a page, they would all be reacting to the same fullscreen\n      // events\n      on(document, fsApi.fullscreenchange, bind(this, function documentFullscreenChange(e) {\n        this.isFullscreen(document[fsApi.fullscreenElement]);\n\n        // If cancelling fullscreen, remove event listener.\n        if (this.isFullscreen() === false) {\n          off(document, fsApi.fullscreenchange, documentFullscreenChange);\n        }\n        /**\n         * @event Player#fullscreenchange\n         * @type {EventTarget~Event}\n         */\n        this.trigger('fullscreenchange');\n      }));\n\n      this.el_[fsApi.requestFullscreen]();\n    } else if (this.tech_.supportsFullScreen()) {\n      // we can't take the video.js controls fullscreen but we can go fullscreen\n      // with native controls\n      this.techCall_('enterFullScreen');\n    } else {\n      // fullscreen isn't supported so we'll just stretch the video element to\n      // fill the viewport\n      this.enterFullWindow();\n      /**\n       * @event Player#fullscreenchange\n       * @type {EventTarget~Event}\n       */\n      this.trigger('fullscreenchange');\n    }\n  };\n\n  /**\n   * Return the video to its normal size after having been in full screen mode\n   *\n   * @fires Player#fullscreenchange\n   */\n\n\n  Player.prototype.exitFullscreen = function exitFullscreen() {\n    var fsApi = FullscreenApi;\n\n    this.isFullscreen(false);\n\n    // Check for browser element fullscreen support\n    if (fsApi.requestFullscreen) {\n      document[fsApi.exitFullscreen]();\n    } else if (this.tech_.supportsFullScreen()) {\n      this.techCall_('exitFullScreen');\n    } else {\n      this.exitFullWindow();\n      /**\n       * @event Player#fullscreenchange\n       * @type {EventTarget~Event}\n       */\n      this.trigger('fullscreenchange');\n    }\n  };\n\n  /**\n   * When fullscreen isn't supported we can stretch the\n   * video container to as wide as the browser will let us.\n   *\n   * @fires Player#enterFullWindow\n   */\n\n\n  Player.prototype.enterFullWindow = function enterFullWindow() {\n    this.isFullWindow = true;\n\n    // Storing original doc overflow value to return to when fullscreen is off\n    this.docOrigOverflow = document.documentElement.style.overflow;\n\n    // Add listener for esc key to exit fullscreen\n    on(document, 'keydown', bind(this, this.fullWindowOnEscKey));\n\n    // Hide any scroll bars\n    document.documentElement.style.overflow = 'hidden';\n\n    // Apply fullscreen styles\n    addClass(document.body, 'vjs-full-window');\n\n    /**\n     * @event Player#enterFullWindow\n     * @type {EventTarget~Event}\n     */\n    this.trigger('enterFullWindow');\n  };\n\n  /**\n   * Check for call to either exit full window or\n   * full screen on ESC key\n   *\n   * @param {string} event\n   *        Event to check for key press\n   */\n\n\n  Player.prototype.fullWindowOnEscKey = function fullWindowOnEscKey(event) {\n    if (event.keyCode === 27) {\n      if (this.isFullscreen() === true) {\n        this.exitFullscreen();\n      } else {\n        this.exitFullWindow();\n      }\n    }\n  };\n\n  /**\n   * Exit full window\n   *\n   * @fires Player#exitFullWindow\n   */\n\n\n  Player.prototype.exitFullWindow = function exitFullWindow() {\n    this.isFullWindow = false;\n    off(document, 'keydown', this.fullWindowOnEscKey);\n\n    // Unhide scroll bars.\n    document.documentElement.style.overflow = this.docOrigOverflow;\n\n    // Remove fullscreen styles\n    removeClass(document.body, 'vjs-full-window');\n\n    // Resize the box, controller, and poster to original sizes\n    // this.positionAll();\n    /**\n     * @event Player#exitFullWindow\n     * @type {EventTarget~Event}\n     */\n    this.trigger('exitFullWindow');\n  };\n\n  /**\n   * Check whether the player can play a given mimetype\n   *\n   * @see https://www.w3.org/TR/2011/WD-html5-20110113/video.html#dom-navigator-canplaytype\n   *\n   * @param {string} type\n   *        The mimetype to check\n   *\n   * @return {string}\n   *         'probably', 'maybe', or '' (empty string)\n   */\n\n\n  Player.prototype.canPlayType = function canPlayType(type) {\n    var can = void 0;\n\n    // Loop through each playback technology in the options order\n    for (var i = 0, j = this.options_.techOrder; i < j.length; i++) {\n      var techName = j[i];\n      var tech = Tech.getTech(techName);\n\n      // Support old behavior of techs being registered as components.\n      // Remove once that deprecated behavior is removed.\n      if (!tech) {\n        tech = Component.getComponent(techName);\n      }\n\n      // Check if the current tech is defined before continuing\n      if (!tech) {\n        log.error('The \"' + techName + '\" tech is undefined. Skipped browser support check for that tech.');\n        continue;\n      }\n\n      // Check if the browser supports this technology\n      if (tech.isSupported()) {\n        can = tech.canPlayType(type);\n\n        if (can) {\n          return can;\n        }\n      }\n    }\n\n    return '';\n  };\n\n  /**\n   * Select source based on tech-order or source-order\n   * Uses source-order selection if `options.sourceOrder` is truthy. Otherwise,\n   * defaults to tech-order selection\n   *\n   * @param {Array} sources\n   *        The sources for a media asset\n   *\n   * @return {Object|boolean}\n   *         Object of source and tech order or false\n   */\n\n\n  Player.prototype.selectSource = function selectSource(sources) {\n    var _this9 = this;\n\n    // Get only the techs specified in `techOrder` that exist and are supported by the\n    // current platform\n    var techs = this.options_.techOrder.map(function (techName) {\n      return [techName, Tech.getTech(techName)];\n    }).filter(function (_ref) {\n      var techName = _ref[0],\n          tech = _ref[1];\n\n      // Check if the current tech is defined before continuing\n      if (tech) {\n        // Check if the browser supports this technology\n        return tech.isSupported();\n      }\n\n      log.error('The \"' + techName + '\" tech is undefined. Skipped browser support check for that tech.');\n      return false;\n    });\n\n    // Iterate over each `innerArray` element once per `outerArray` element and execute\n    // `tester` with both. If `tester` returns a non-falsy value, exit early and return\n    // that value.\n    var findFirstPassingTechSourcePair = function findFirstPassingTechSourcePair(outerArray, innerArray, tester) {\n      var found = void 0;\n\n      outerArray.some(function (outerChoice) {\n        return innerArray.some(function (innerChoice) {\n          found = tester(outerChoice, innerChoice);\n\n          if (found) {\n            return true;\n          }\n        });\n      });\n\n      return found;\n    };\n\n    var foundSourceAndTech = void 0;\n    var flip = function flip(fn) {\n      return function (a, b) {\n        return fn(b, a);\n      };\n    };\n    var finder = function finder(_ref2, source) {\n      var techName = _ref2[0],\n          tech = _ref2[1];\n\n      if (tech.canPlaySource(source, _this9.options_[techName.toLowerCase()])) {\n        return { source: source, tech: techName };\n      }\n    };\n\n    // Depending on the truthiness of `options.sourceOrder`, we swap the order of techs and sources\n    // to select from them based on their priority.\n    if (this.options_.sourceOrder) {\n      // Source-first ordering\n      foundSourceAndTech = findFirstPassingTechSourcePair(sources, techs, flip(finder));\n    } else {\n      // Tech-first ordering\n      foundSourceAndTech = findFirstPassingTechSourcePair(techs, sources, finder);\n    }\n\n    return foundSourceAndTech || false;\n  };\n\n  /**\n   * Get or set the video source.\n   *\n   * @param {Tech~SourceObject|Tech~SourceObject[]|string} [source]\n   *        A SourceObject, an array of SourceObjects, or a string referencing\n   *        a URL to a media source. It is _highly recommended_ that an object\n   *        or array of objects is used here, so that source selection\n   *        algorithms can take the `type` into account.\n   *\n   *        If not provided, this method acts as a getter.\n   *\n   * @return {string|undefined}\n   *         If the `source` argument is missing, returns the current source\n   *         URL. Otherwise, returns nothing/undefined.\n   */\n\n\n  Player.prototype.src = function src(source) {\n    var _this10 = this;\n\n    // getter usage\n    if (typeof source === 'undefined') {\n      return this.cache_.src || '';\n    }\n    // filter out invalid sources and turn our source into\n    // an array of source objects\n    var sources = filterSource(source);\n\n    // if a source was passed in then it is invalid because\n    // it was filtered to a zero length Array. So we have to\n    // show an error\n    if (!sources.length) {\n      this.setTimeout(function () {\n        this.error({ code: 4, message: this.localize(this.options_.notSupportedMessage) });\n      }, 0);\n      return;\n    }\n\n    // intial sources\n    this.changingSrc_ = true;\n\n    this.cache_.sources = sources;\n    this.updateSourceCaches_(sources[0]);\n\n    // middlewareSource is the source after it has been changed by middleware\n    setSource(this, sources[0], function (middlewareSource, mws) {\n      _this10.middleware_ = mws;\n\n      // since sourceSet is async we have to update the cache again after we select a source since\n      // the source that is selected could be out of order from the cache update above this callback.\n      _this10.cache_.sources = sources;\n      _this10.updateSourceCaches_(middlewareSource);\n\n      var err = _this10.src_(middlewareSource);\n\n      if (err) {\n        if (sources.length > 1) {\n          return _this10.src(sources.slice(1));\n        }\n\n        _this10.changingSrc_ = false;\n\n        // We need to wrap this in a timeout to give folks a chance to add error event handlers\n        _this10.setTimeout(function () {\n          this.error({ code: 4, message: this.localize(this.options_.notSupportedMessage) });\n        }, 0);\n\n        // we could not find an appropriate tech, but let's still notify the delegate that this is it\n        // this needs a better comment about why this is needed\n        _this10.triggerReady();\n\n        return;\n      }\n\n      setTech(mws, _this10.tech_);\n    });\n  };\n\n  /**\n   * Set the source object on the tech, returns a boolean that indicates wether\n   * there is a tech that can play the source or not\n   *\n   * @param {Tech~SourceObject} source\n   *        The source object to set on the Tech\n   *\n   * @return {Boolean}\n   *         - True if there is no Tech to playback this source\n   *         - False otherwise\n   *\n   * @private\n   */\n\n\n  Player.prototype.src_ = function src_(source) {\n    var _this11 = this;\n\n    var sourceTech = this.selectSource([source]);\n\n    if (!sourceTech) {\n      return true;\n    }\n\n    if (!titleCaseEquals(sourceTech.tech, this.techName_)) {\n      this.changingSrc_ = true;\n      // load this technology with the chosen source\n      this.loadTech_(sourceTech.tech, sourceTech.source);\n      this.tech_.ready(function () {\n        _this11.changingSrc_ = false;\n      });\n      return false;\n    }\n\n    // wait until the tech is ready to set the source\n    // and set it synchronously if possible (#2326)\n    this.ready(function () {\n\n      // The setSource tech method was added with source handlers\n      // so older techs won't support it\n      // We need to check the direct prototype for the case where subclasses\n      // of the tech do not support source handlers\n      if (this.tech_.constructor.prototype.hasOwnProperty('setSource')) {\n        this.techCall_('setSource', source);\n      } else {\n        this.techCall_('src', source.src);\n      }\n\n      this.changingSrc_ = false;\n    }, true);\n\n    return false;\n  };\n\n  /**\n   * Begin loading the src data.\n   */\n\n\n  Player.prototype.load = function load() {\n    this.techCall_('load');\n  };\n\n  /**\n   * Reset the player. Loads the first tech in the techOrder,\n   * removes all the text tracks in the existing `tech`,\n   * and calls `reset` on the `tech`.\n   */\n\n\n  Player.prototype.reset = function reset() {\n    if (this.tech_) {\n      this.tech_.clearTracks('text');\n    }\n    this.loadTech_(this.options_.techOrder[0], null);\n    this.techCall_('reset');\n  };\n\n  /**\n   * Returns all of the current source objects.\n   *\n   * @return {Tech~SourceObject[]}\n   *         The current source objects\n   */\n\n\n  Player.prototype.currentSources = function currentSources() {\n    var source = this.currentSource();\n    var sources = [];\n\n    // assume `{}` or `{ src }`\n    if (Object.keys(source).length !== 0) {\n      sources.push(source);\n    }\n\n    return this.cache_.sources || sources;\n  };\n\n  /**\n   * Returns the current source object.\n   *\n   * @return {Tech~SourceObject}\n   *         The current source object\n   */\n\n\n  Player.prototype.currentSource = function currentSource() {\n    return this.cache_.source || {};\n  };\n\n  /**\n   * Returns the fully qualified URL of the current source value e.g. http://mysite.com/video.mp4\n   * Can be used in conjuction with `currentType` to assist in rebuilding the current source object.\n   *\n   * @return {string}\n   *         The current source\n   */\n\n\n  Player.prototype.currentSrc = function currentSrc() {\n    return this.currentSource() && this.currentSource().src || '';\n  };\n\n  /**\n   * Get the current source type e.g. video/mp4\n   * This can allow you rebuild the current source object so that you could load the same\n   * source and tech later\n   *\n   * @return {string}\n   *         The source MIME type\n   */\n\n\n  Player.prototype.currentType = function currentType() {\n    return this.currentSource() && this.currentSource().type || '';\n  };\n\n  /**\n   * Get or set the preload attribute\n   *\n   * @param {boolean} [value]\n   *        - true means that we should preload\n   *        - false maens that we should not preload\n   *\n   * @return {string}\n   *         The preload attribute value when getting\n   */\n\n\n  Player.prototype.preload = function preload(value) {\n    if (value !== undefined) {\n      this.techCall_('setPreload', value);\n      this.options_.preload = value;\n      return;\n    }\n    return this.techGet_('preload');\n  };\n\n  /**\n   * Get or set the autoplay option. When this is a boolean it will\n   * modify the attribute on the tech. When this is a string the attribute on\n   * the tech will be removed and `Player` will handle autoplay on loadstarts.\n   *\n   * @param {boolean|string} [value]\n   *        - true: autoplay using the browser behavior\n   *        - false: do not autoplay\n   *        - 'play': call play() on every loadstart\n   *        - 'muted': call muted() then play() on every loadstart\n   *        - 'any': call play() on every loadstart. if that fails call muted() then play().\n   *        - *: values other than those listed here will be set `autoplay` to true\n   *\n   * @return {boolean|string}\n   *         The current value of autoplay when getting\n   */\n\n\n  Player.prototype.autoplay = function autoplay(value) {\n    // getter usage\n    if (value === undefined) {\n      return this.options_.autoplay || false;\n    }\n\n    var techAutoplay = void 0;\n\n    // if the value is a valid string set it to that\n    if (typeof value === 'string' && /(any|play|muted)/.test(value)) {\n      this.options_.autoplay = value;\n      this.manualAutoplay_(value);\n      techAutoplay = false;\n\n      // any falsy value sets autoplay to false in the browser,\n      // lets do the same\n    } else if (!value) {\n      this.options_.autoplay = false;\n\n      // any other value (ie truthy) sets autoplay to true\n    } else {\n      this.options_.autoplay = true;\n    }\n\n    techAutoplay = techAutoplay || this.options_.autoplay;\n\n    // if we don't have a tech then we do not queue up\n    // a setAutoplay call on tech ready. We do this because the\n    // autoplay option will be passed in the constructor and we\n    // do not need to set it twice\n    if (this.tech_) {\n      this.techCall_('setAutoplay', techAutoplay);\n    }\n  };\n\n  /**\n   * Set or unset the playsinline attribute.\n   * Playsinline tells the browser that non-fullscreen playback is preferred.\n   *\n   * @param {boolean} [value]\n   *        - true means that we should try to play inline by default\n   *        - false means that we should use the browser's default playback mode,\n   *          which in most cases is inline. iOS Safari is a notable exception\n   *          and plays fullscreen by default.\n   *\n   * @return {string|Player}\n   *         - the current value of playsinline\n   *         - the player when setting\n   *\n   * @see [Spec]{@link https://html.spec.whatwg.org/#attr-video-playsinline}\n   */\n\n\n  Player.prototype.playsinline = function playsinline(value) {\n    if (value !== undefined) {\n      this.techCall_('setPlaysinline', value);\n      this.options_.playsinline = value;\n      return this;\n    }\n    return this.techGet_('playsinline');\n  };\n\n  /**\n   * Get or set the loop attribute on the video element.\n   *\n   * @param {boolean} [value]\n   *        - true means that we should loop the video\n   *        - false means that we should not loop the video\n   *\n   * @return {string}\n   *         The current value of loop when getting\n   */\n\n\n  Player.prototype.loop = function loop(value) {\n    if (value !== undefined) {\n      this.techCall_('setLoop', value);\n      this.options_.loop = value;\n      return;\n    }\n    return this.techGet_('loop');\n  };\n\n  /**\n   * Get or set the poster image source url\n   *\n   * @fires Player#posterchange\n   *\n   * @param {string} [src]\n   *        Poster image source URL\n   *\n   * @return {string}\n   *         The current value of poster when getting\n   */\n\n\n  Player.prototype.poster = function poster(src) {\n    if (src === undefined) {\n      return this.poster_;\n    }\n\n    // The correct way to remove a poster is to set as an empty string\n    // other falsey values will throw errors\n    if (!src) {\n      src = '';\n    }\n\n    if (src === this.poster_) {\n      return;\n    }\n\n    // update the internal poster variable\n    this.poster_ = src;\n\n    // update the tech's poster\n    this.techCall_('setPoster', src);\n\n    this.isPosterFromTech_ = false;\n\n    // alert components that the poster has been set\n    /**\n     * This event fires when the poster image is changed on the player.\n     *\n     * @event Player#posterchange\n     * @type {EventTarget~Event}\n     */\n    this.trigger('posterchange');\n  };\n\n  /**\n   * Some techs (e.g. YouTube) can provide a poster source in an\n   * asynchronous way. We want the poster component to use this\n   * poster source so that it covers up the tech's controls.\n   * (YouTube's play button). However we only want to use this\n   * source if the player user hasn't set a poster through\n   * the normal APIs.\n   *\n   * @fires Player#posterchange\n   * @listens Tech#posterchange\n   * @private\n   */\n\n\n  Player.prototype.handleTechPosterChange_ = function handleTechPosterChange_() {\n    if ((!this.poster_ || this.options_.techCanOverridePoster) && this.tech_ && this.tech_.poster) {\n      var newPoster = this.tech_.poster() || '';\n\n      if (newPoster !== this.poster_) {\n        this.poster_ = newPoster;\n        this.isPosterFromTech_ = true;\n\n        // Let components know the poster has changed\n        this.trigger('posterchange');\n      }\n    }\n  };\n\n  /**\n   * Get or set whether or not the controls are showing.\n   *\n   * @fires Player#controlsenabled\n   *\n   * @param {boolean} [bool]\n   *        - true to turn controls on\n   *        - false to turn controls off\n   *\n   * @return {boolean}\n   *         The current value of controls when getting\n   */\n\n\n  Player.prototype.controls = function controls(bool) {\n    if (bool === undefined) {\n      return !!this.controls_;\n    }\n\n    bool = !!bool;\n\n    // Don't trigger a change event unless it actually changed\n    if (this.controls_ === bool) {\n      return;\n    }\n\n    this.controls_ = bool;\n\n    if (this.usingNativeControls()) {\n      this.techCall_('setControls', bool);\n    }\n\n    if (this.controls_) {\n      this.removeClass('vjs-controls-disabled');\n      this.addClass('vjs-controls-enabled');\n      /**\n       * @event Player#controlsenabled\n       * @type {EventTarget~Event}\n       */\n      this.trigger('controlsenabled');\n      if (!this.usingNativeControls()) {\n        this.addTechControlsListeners_();\n      }\n    } else {\n      this.removeClass('vjs-controls-enabled');\n      this.addClass('vjs-controls-disabled');\n      /**\n       * @event Player#controlsdisabled\n       * @type {EventTarget~Event}\n       */\n      this.trigger('controlsdisabled');\n      if (!this.usingNativeControls()) {\n        this.removeTechControlsListeners_();\n      }\n    }\n  };\n\n  /**\n   * Toggle native controls on/off. Native controls are the controls built into\n   * devices (e.g. default iPhone controls), Flash, or other techs\n   * (e.g. Vimeo Controls)\n   * **This should only be set by the current tech, because only the tech knows\n   * if it can support native controls**\n   *\n   * @fires Player#usingnativecontrols\n   * @fires Player#usingcustomcontrols\n   *\n   * @param {boolean} [bool]\n   *        - true to turn native controls on\n   *        - false to turn native controls off\n   *\n   * @return {boolean}\n   *         The current value of native controls when getting\n   */\n\n\n  Player.prototype.usingNativeControls = function usingNativeControls(bool) {\n    if (bool === undefined) {\n      return !!this.usingNativeControls_;\n    }\n\n    bool = !!bool;\n\n    // Don't trigger a change event unless it actually changed\n    if (this.usingNativeControls_ === bool) {\n      return;\n    }\n\n    this.usingNativeControls_ = bool;\n\n    if (this.usingNativeControls_) {\n      this.addClass('vjs-using-native-controls');\n\n      /**\n       * player is using the native device controls\n       *\n       * @event Player#usingnativecontrols\n       * @type {EventTarget~Event}\n       */\n      this.trigger('usingnativecontrols');\n    } else {\n      this.removeClass('vjs-using-native-controls');\n\n      /**\n       * player is using the custom HTML controls\n       *\n       * @event Player#usingcustomcontrols\n       * @type {EventTarget~Event}\n       */\n      this.trigger('usingcustomcontrols');\n    }\n  };\n\n  /**\n   * Set or get the current MediaError\n   *\n   * @fires Player#error\n   *\n   * @param  {MediaError|string|number} [err]\n   *         A MediaError or a string/number to be turned\n   *         into a MediaError\n   *\n   * @return {MediaError|null}\n   *         The current MediaError when getting (or null)\n   */\n\n\n  Player.prototype.error = function error(err) {\n    if (err === undefined) {\n      return this.error_ || null;\n    }\n\n    // restoring to default\n    if (err === null) {\n      this.error_ = err;\n      this.removeClass('vjs-error');\n      if (this.errorDisplay) {\n        this.errorDisplay.close();\n      }\n      return;\n    }\n\n    this.error_ = new MediaError(err);\n\n    // add the vjs-error classname to the player\n    this.addClass('vjs-error');\n\n    // log the name of the error type and any message\n    // ie8 just logs \"[object object]\" if you just log the error object\n    log.error('(CODE:' + this.error_.code + ' ' + MediaError.errorTypes[this.error_.code] + ')', this.error_.message, this.error_);\n\n    /**\n     * @event Player#error\n     * @type {EventTarget~Event}\n     */\n    this.trigger('error');\n\n    return;\n  };\n\n  /**\n   * Report user activity\n   *\n   * @param {Object} event\n   *        Event object\n   */\n\n\n  Player.prototype.reportUserActivity = function reportUserActivity(event) {\n    this.userActivity_ = true;\n  };\n\n  /**\n   * Get/set if user is active\n   *\n   * @fires Player#useractive\n   * @fires Player#userinactive\n   *\n   * @param {boolean} [bool]\n   *        - true if the user is active\n   *        - false if the user is inactive\n   *\n   * @return {boolean}\n   *         The current value of userActive when getting\n   */\n\n\n  Player.prototype.userActive = function userActive(bool) {\n    if (bool === undefined) {\n      return this.userActive_;\n    }\n\n    bool = !!bool;\n\n    if (bool === this.userActive_) {\n      return;\n    }\n\n    this.userActive_ = bool;\n\n    if (this.userActive_) {\n      this.userActivity_ = true;\n      this.removeClass('vjs-user-inactive');\n      this.addClass('vjs-user-active');\n      /**\n       * @event Player#useractive\n       * @type {EventTarget~Event}\n       */\n      this.trigger('useractive');\n      return;\n    }\n\n    // Chrome/Safari/IE have bugs where when you change the cursor it can\n    // trigger a mousemove event. This causes an issue when you're hiding\n    // the cursor when the user is inactive, and a mousemove signals user\n    // activity. Making it impossible to go into inactive mode. Specifically\n    // this happens in fullscreen when we really need to hide the cursor.\n    //\n    // When this gets resolved in ALL browsers it can be removed\n    // https://code.google.com/p/chromium/issues/detail?id=103041\n    if (this.tech_) {\n      this.tech_.one('mousemove', function (e) {\n        e.stopPropagation();\n        e.preventDefault();\n      });\n    }\n\n    this.userActivity_ = false;\n    this.removeClass('vjs-user-active');\n    this.addClass('vjs-user-inactive');\n    /**\n     * @event Player#userinactive\n     * @type {EventTarget~Event}\n     */\n    this.trigger('userinactive');\n  };\n\n  /**\n   * Listen for user activity based on timeout value\n   *\n   * @private\n   */\n\n\n  Player.prototype.listenForUserActivity_ = function listenForUserActivity_() {\n    var mouseInProgress = void 0;\n    var lastMoveX = void 0;\n    var lastMoveY = void 0;\n    var handleActivity = bind(this, this.reportUserActivity);\n\n    var handleMouseMove = function handleMouseMove(e) {\n      // #1068 - Prevent mousemove spamming\n      // Chrome Bug: https://code.google.com/p/chromium/issues/detail?id=366970\n      if (e.screenX !== lastMoveX || e.screenY !== lastMoveY) {\n        lastMoveX = e.screenX;\n        lastMoveY = e.screenY;\n        handleActivity();\n      }\n    };\n\n    var handleMouseDown = function handleMouseDown() {\n      handleActivity();\n      // For as long as the they are touching the device or have their mouse down,\n      // we consider them active even if they're not moving their finger or mouse.\n      // So we want to continue to update that they are active\n      this.clearInterval(mouseInProgress);\n      // Setting userActivity=true now and setting the interval to the same time\n      // as the activityCheck interval (250) should ensure we never miss the\n      // next activityCheck\n      mouseInProgress = this.setInterval(handleActivity, 250);\n    };\n\n    var handleMouseUp = function handleMouseUp(event) {\n      handleActivity();\n      // Stop the interval that maintains activity if the mouse/touch is down\n      this.clearInterval(mouseInProgress);\n    };\n\n    // Any mouse movement will be considered user activity\n    this.on('mousedown', handleMouseDown);\n    this.on('mousemove', handleMouseMove);\n    this.on('mouseup', handleMouseUp);\n\n    // Listen for keyboard navigation\n    // Shouldn't need to use inProgress interval because of key repeat\n    this.on('keydown', handleActivity);\n    this.on('keyup', handleActivity);\n\n    // Run an interval every 250 milliseconds instead of stuffing everything into\n    // the mousemove/touchmove function itself, to prevent performance degradation.\n    // `this.reportUserActivity` simply sets this.userActivity_ to true, which\n    // then gets picked up by this loop\n    // http://ejohn.org/blog/learning-from-twitter/\n    var inactivityTimeout = void 0;\n\n    this.setInterval(function () {\n      // Check to see if mouse/touch activity has happened\n      if (!this.userActivity_) {\n        return;\n      }\n\n      // Reset the activity tracker\n      this.userActivity_ = false;\n\n      // If the user state was inactive, set the state to active\n      this.userActive(true);\n\n      // Clear any existing inactivity timeout to start the timer over\n      this.clearTimeout(inactivityTimeout);\n\n      var timeout = this.options_.inactivityTimeout;\n\n      if (timeout <= 0) {\n        return;\n      }\n\n      // In <timeout> milliseconds, if no more activity has occurred the\n      // user will be considered inactive\n      inactivityTimeout = this.setTimeout(function () {\n        // Protect against the case where the inactivityTimeout can trigger just\n        // before the next user activity is picked up by the activity check loop\n        // causing a flicker\n        if (!this.userActivity_) {\n          this.userActive(false);\n        }\n      }, timeout);\n    }, 250);\n  };\n\n  /**\n   * Gets or sets the current playback rate. A playback rate of\n   * 1.0 represents normal speed and 0.5 would indicate half-speed\n   * playback, for instance.\n   *\n   * @see https://html.spec.whatwg.org/multipage/embedded-content.html#dom-media-playbackrate\n   *\n   * @param {number} [rate]\n   *       New playback rate to set.\n   *\n   * @return {number}\n   *         The current playback rate when getting or 1.0\n   */\n\n\n  Player.prototype.playbackRate = function playbackRate(rate) {\n    if (rate !== undefined) {\n      // NOTE: this.cache_.lastPlaybackRate is set from the tech handler\n      // that is registered above\n      this.techCall_('setPlaybackRate', rate);\n      return;\n    }\n\n    if (this.tech_ && this.tech_.featuresPlaybackRate) {\n      return this.cache_.lastPlaybackRate || this.techGet_('playbackRate');\n    }\n    return 1.0;\n  };\n\n  /**\n   * Gets or sets the current default playback rate. A default playback rate of\n   * 1.0 represents normal speed and 0.5 would indicate half-speed playback, for instance.\n   * defaultPlaybackRate will only represent what the intial playbackRate of a video was, not\n   * not the current playbackRate.\n   *\n   * @see https://html.spec.whatwg.org/multipage/embedded-content.html#dom-media-defaultplaybackrate\n   *\n   * @param {number} [rate]\n   *       New default playback rate to set.\n   *\n   * @return {number|Player}\n   *         - The default playback rate when getting or 1.0\n   *         - the player when setting\n   */\n\n\n  Player.prototype.defaultPlaybackRate = function defaultPlaybackRate(rate) {\n    if (rate !== undefined) {\n      return this.techCall_('setDefaultPlaybackRate', rate);\n    }\n\n    if (this.tech_ && this.tech_.featuresPlaybackRate) {\n      return this.techGet_('defaultPlaybackRate');\n    }\n    return 1.0;\n  };\n\n  /**\n   * Gets or sets the audio flag\n   *\n   * @param {boolean} bool\n   *        - true signals that this is an audio player\n   *        - false signals that this is not an audio player\n   *\n   * @return {boolean}\n   *         The current value of isAudio when getting\n   */\n\n\n  Player.prototype.isAudio = function isAudio(bool) {\n    if (bool !== undefined) {\n      this.isAudio_ = !!bool;\n      return;\n    }\n\n    return !!this.isAudio_;\n  };\n\n  /**\n   * A helper method for adding a {@link TextTrack} to our\n   * {@link TextTrackList}.\n   *\n   * In addition to the W3C settings we allow adding additional info through options.\n   *\n   * @see http://www.w3.org/html/wg/drafts/html/master/embedded-content-0.html#dom-media-addtexttrack\n   *\n   * @param {string} [kind]\n   *        the kind of TextTrack you are adding\n   *\n   * @param {string} [label]\n   *        the label to give the TextTrack label\n   *\n   * @param {string} [language]\n   *        the language to set on the TextTrack\n   *\n   * @return {TextTrack|undefined}\n   *         the TextTrack that was added or undefined\n   *         if there is no tech\n   */\n\n\n  Player.prototype.addTextTrack = function addTextTrack(kind, label, language) {\n    if (this.tech_) {\n      return this.tech_.addTextTrack(kind, label, language);\n    }\n  };\n\n  /**\n   * Create a remote {@link TextTrack} and an {@link HTMLTrackElement}. It will\n   * automatically removed from the video element whenever the source changes, unless\n   * manualCleanup is set to false.\n   *\n   * @param {Object} options\n   *        Options to pass to {@link HTMLTrackElement} during creation. See\n   *        {@link HTMLTrackElement} for object properties that you should use.\n   *\n   * @param {boolean} [manualCleanup=true] if set to false, the TextTrack will be\n   *\n   * @return {HtmlTrackElement}\n   *         the HTMLTrackElement that was created and added\n   *         to the HtmlTrackElementList and the remote\n   *         TextTrackList\n   *\n   * @deprecated The default value of the \"manualCleanup\" parameter will default\n   *             to \"false\" in upcoming versions of Video.js\n   */\n\n\n  Player.prototype.addRemoteTextTrack = function addRemoteTextTrack(options, manualCleanup) {\n    if (this.tech_) {\n      return this.tech_.addRemoteTextTrack(options, manualCleanup);\n    }\n  };\n\n  /**\n   * Remove a remote {@link TextTrack} from the respective\n   * {@link TextTrackList} and {@link HtmlTrackElementList}.\n   *\n   * @param {Object} track\n   *        Remote {@link TextTrack} to remove\n   *\n   * @return {undefined}\n   *         does not return anything\n   */\n\n\n  Player.prototype.removeRemoteTextTrack = function removeRemoteTextTrack() {\n    var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref3$track = _ref3.track,\n        track = _ref3$track === undefined ? arguments[0] : _ref3$track;\n\n    // destructure the input into an object with a track argument, defaulting to arguments[0]\n    // default the whole argument to an empty object if nothing was passed in\n\n    if (this.tech_) {\n      return this.tech_.removeRemoteTextTrack(track);\n    }\n  };\n\n  /**\n   * Gets available media playback quality metrics as specified by the W3C's Media\n   * Playback Quality API.\n   *\n   * @see [Spec]{@link https://wicg.github.io/media-playback-quality}\n   *\n   * @return {Object|undefined}\n   *         An object with supported media playback quality metrics or undefined if there\n   *         is no tech or the tech does not support it.\n   */\n\n\n  Player.prototype.getVideoPlaybackQuality = function getVideoPlaybackQuality() {\n    return this.techGet_('getVideoPlaybackQuality');\n  };\n\n  /**\n   * Get video width\n   *\n   * @return {number}\n   *         current video width\n   */\n\n\n  Player.prototype.videoWidth = function videoWidth() {\n    return this.tech_ && this.tech_.videoWidth && this.tech_.videoWidth() || 0;\n  };\n\n  /**\n   * Get video height\n   *\n   * @return {number}\n   *         current video height\n   */\n\n\n  Player.prototype.videoHeight = function videoHeight() {\n    return this.tech_ && this.tech_.videoHeight && this.tech_.videoHeight() || 0;\n  };\n\n  /**\n   * The player's language code\n   * NOTE: The language should be set in the player options if you want the\n   * the controls to be built with a specific language. Changing the lanugage\n   * later will not update controls text.\n   *\n   * @param {string} [code]\n   *        the language code to set the player to\n   *\n   * @return {string}\n   *         The current language code when getting\n   */\n\n\n  Player.prototype.language = function language(code) {\n    if (code === undefined) {\n      return this.language_;\n    }\n\n    this.language_ = String(code).toLowerCase();\n  };\n\n  /**\n   * Get the player's language dictionary\n   * Merge every time, because a newly added plugin might call videojs.addLanguage() at any time\n   * Languages specified directly in the player options have precedence\n   *\n   * @return {Array}\n   *         An array of of supported languages\n   */\n\n\n  Player.prototype.languages = function languages() {\n    return mergeOptions(Player.prototype.options_.languages, this.languages_);\n  };\n\n  /**\n   * returns a JavaScript object reperesenting the current track\n   * information. **DOES not return it as JSON**\n   *\n   * @return {Object}\n   *         Object representing the current of track info\n   */\n\n\n  Player.prototype.toJSON = function toJSON() {\n    var options = mergeOptions(this.options_);\n    var tracks = options.tracks;\n\n    options.tracks = [];\n\n    for (var i = 0; i < tracks.length; i++) {\n      var track = tracks[i];\n\n      // deep merge tracks and null out player so no circular references\n      track = mergeOptions(track);\n      track.player = undefined;\n      options.tracks[i] = track;\n    }\n\n    return options;\n  };\n\n  /**\n   * Creates a simple modal dialog (an instance of the {@link ModalDialog}\n   * component) that immediately overlays the player with arbitrary\n   * content and removes itself when closed.\n   *\n   * @param {string|Function|Element|Array|null} content\n   *        Same as {@link ModalDialog#content}'s param of the same name.\n   *        The most straight-forward usage is to provide a string or DOM\n   *        element.\n   *\n   * @param {Object} [options]\n   *        Extra options which will be passed on to the {@link ModalDialog}.\n   *\n   * @return {ModalDialog}\n   *         the {@link ModalDialog} that was created\n   */\n\n\n  Player.prototype.createModal = function createModal(content, options) {\n    var _this12 = this;\n\n    options = options || {};\n    options.content = content || '';\n\n    var modal = new ModalDialog(this, options);\n\n    this.addChild(modal);\n    modal.on('dispose', function () {\n      _this12.removeChild(modal);\n    });\n\n    modal.open();\n    return modal;\n  };\n\n  /**\n   * Change breakpoint classes when the player resizes.\n   *\n   * @private\n   */\n\n\n  Player.prototype.updateCurrentBreakpoint_ = function updateCurrentBreakpoint_() {\n    if (!this.responsive()) {\n      return;\n    }\n\n    var currentBreakpoint = this.currentBreakpoint();\n    var currentWidth = this.currentWidth();\n\n    for (var i = 0; i < BREAKPOINT_ORDER.length; i++) {\n      var candidateBreakpoint = BREAKPOINT_ORDER[i];\n      var maxWidth = this.breakpoints_[candidateBreakpoint];\n\n      if (currentWidth <= maxWidth) {\n\n        // The current breakpoint did not change, nothing to do.\n        if (currentBreakpoint === candidateBreakpoint) {\n          return;\n        }\n\n        // Only remove a class if there is a current breakpoint.\n        if (currentBreakpoint) {\n          this.removeClass(BREAKPOINT_CLASSES[currentBreakpoint]);\n        }\n\n        this.addClass(BREAKPOINT_CLASSES[candidateBreakpoint]);\n        this.breakpoint_ = candidateBreakpoint;\n        break;\n      }\n    }\n  };\n\n  /**\n   * Removes the current breakpoint.\n   *\n   * @private\n   */\n\n\n  Player.prototype.removeCurrentBreakpoint_ = function removeCurrentBreakpoint_() {\n    var className = this.currentBreakpointClass();\n\n    this.breakpoint_ = '';\n\n    if (className) {\n      this.removeClass(className);\n    }\n  };\n\n  /**\n   * Get or set breakpoints on the player.\n   *\n   * Calling this method with an object or `true` will remove any previous\n   * custom breakpoints and start from the defaults again.\n   *\n   * @param  {Object|boolean} [breakpoints]\n   *         If an object is given, it can be used to provide custom\n   *         breakpoints. If `true` is given, will set default breakpoints.\n   *         If this argument is not given, will simply return the current\n   *         breakpoints.\n   *\n   * @param  {number} [breakpoints.tiny]\n   *         The maximum width for the \"vjs-layout-tiny\" class.\n   *\n   * @param  {number} [breakpoints.xsmall]\n   *         The maximum width for the \"vjs-layout-x-small\" class.\n   *\n   * @param  {number} [breakpoints.small]\n   *         The maximum width for the \"vjs-layout-small\" class.\n   *\n   * @param  {number} [breakpoints.medium]\n   *         The maximum width for the \"vjs-layout-medium\" class.\n   *\n   * @param  {number} [breakpoints.large]\n   *         The maximum width for the \"vjs-layout-large\" class.\n   *\n   * @param  {number} [breakpoints.xlarge]\n   *         The maximum width for the \"vjs-layout-x-large\" class.\n   *\n   * @param  {number} [breakpoints.huge]\n   *         The maximum width for the \"vjs-layout-huge\" class.\n   *\n   * @return {Object}\n   *         An object mapping breakpoint names to maximum width values.\n   */\n\n\n  Player.prototype.breakpoints = function breakpoints(_breakpoints) {\n\n    // Used as a getter.\n    if (_breakpoints === undefined) {\n      return assign(this.breakpoints_);\n    }\n\n    this.breakpoint_ = '';\n    this.breakpoints_ = assign({}, DEFAULT_BREAKPOINTS, _breakpoints);\n\n    // When breakpoint definitions change, we need to update the currently\n    // selected breakpoint.\n    this.updateCurrentBreakpoint_();\n\n    // Clone the breakpoints before returning.\n    return assign(this.breakpoints_);\n  };\n\n  /**\n   * Get or set a flag indicating whether or not this player should adjust\n   * its UI based on its dimensions.\n   *\n   * @param  {boolean} value\n   *         Should be `true` if the player should adjust its UI based on its\n   *         dimensions; otherwise, should be `false`.\n   *\n   * @return {boolean}\n   *         Will be `true` if this player should adjust its UI based on its\n   *         dimensions; otherwise, will be `false`.\n   */\n\n\n  Player.prototype.responsive = function responsive(value) {\n\n    // Used as a getter.\n    if (value === undefined) {\n      return this.responsive_;\n    }\n\n    value = Boolean(value);\n    var current = this.responsive_;\n\n    // Nothing changed.\n    if (value === current) {\n      return;\n    }\n\n    // The value actually changed, set it.\n    this.responsive_ = value;\n\n    // Start listening for breakpoints and set the initial breakpoint if the\n    // player is now responsive.\n    if (value) {\n      this.on('playerresize', this.updateCurrentBreakpoint_);\n      this.updateCurrentBreakpoint_();\n\n      // Stop listening for breakpoints if the player is no longer responsive.\n    } else {\n      this.off('playerresize', this.updateCurrentBreakpoint_);\n      this.removeCurrentBreakpoint_();\n    }\n\n    return value;\n  };\n\n  /**\n   * Get current breakpoint name, if any.\n   *\n   * @return {string}\n   *         If there is currently a breakpoint set, returns a the key from the\n   *         breakpoints object matching it. Otherwise, returns an empty string.\n   */\n\n\n  Player.prototype.currentBreakpoint = function currentBreakpoint() {\n    return this.breakpoint_;\n  };\n\n  /**\n   * Get the current breakpoint class name.\n   *\n   * @return {string}\n   *         The matching class name (e.g. `\"vjs-layout-tiny\"` or\n   *         `\"vjs-layout-large\"`) for the current breakpoint. Empty string if\n   *         there is no current breakpoint.\n   */\n\n\n  Player.prototype.currentBreakpointClass = function currentBreakpointClass() {\n    return BREAKPOINT_CLASSES[this.breakpoint_] || '';\n  };\n\n  /**\n   * Gets tag settings\n   *\n   * @param {Element} tag\n   *        The player tag\n   *\n   * @return {Object}\n   *         An object containing all of the settings\n   *         for a player tag\n   */\n\n\n  Player.getTagSettings = function getTagSettings(tag) {\n    var baseOptions = {\n      sources: [],\n      tracks: []\n    };\n\n    var tagOptions = getAttributes(tag);\n    var dataSetup = tagOptions['data-setup'];\n\n    if (hasClass(tag, 'vjs-fill')) {\n      tagOptions.fill = true;\n    }\n    if (hasClass(tag, 'vjs-fluid')) {\n      tagOptions.fluid = true;\n    }\n\n    // Check if data-setup attr exists.\n    if (dataSetup !== null) {\n      // Parse options JSON\n      // If empty string, make it a parsable json object.\n      var _safeParseTuple = safeParseTuple(dataSetup || '{}'),\n          err = _safeParseTuple[0],\n          data = _safeParseTuple[1];\n\n      if (err) {\n        log.error(err);\n      }\n      assign(tagOptions, data);\n    }\n\n    assign(baseOptions, tagOptions);\n\n    // Get tag children settings\n    if (tag.hasChildNodes()) {\n      var children = tag.childNodes;\n\n      for (var i = 0, j = children.length; i < j; i++) {\n        var child = children[i];\n        // Change case needed: http://ejohn.org/blog/nodename-case-sensitivity/\n        var childName = child.nodeName.toLowerCase();\n\n        if (childName === 'source') {\n          baseOptions.sources.push(getAttributes(child));\n        } else if (childName === 'track') {\n          baseOptions.tracks.push(getAttributes(child));\n        }\n      }\n    }\n\n    return baseOptions;\n  };\n\n  /**\n   * Determine wether or not flexbox is supported\n   *\n   * @return {boolean}\n   *         - true if flexbox is supported\n   *         - false if flexbox is not supported\n   */\n\n\n  Player.prototype.flexNotSupported_ = function flexNotSupported_() {\n    var elem = document.createElement('i');\n\n    // Note: We don't actually use flexBasis (or flexOrder), but it's one of the more\n    // common flex features that we can rely on when checking for flex support.\n    return !('flexBasis' in elem.style || 'webkitFlexBasis' in elem.style || 'mozFlexBasis' in elem.style || 'msFlexBasis' in elem.style ||\n    // IE10-specific (2012 flex spec)\n    'msFlexOrder' in elem.style);\n  };\n\n  return Player;\n}(Component);\n\n/**\n * Get the {@link VideoTrackList}\n * @link https://html.spec.whatwg.org/multipage/embedded-content.html#videotracklist\n *\n * @return {VideoTrackList}\n *         the current video track list\n *\n * @method Player.prototype.videoTracks\n */\n\n/**\n * Get the {@link AudioTrackList}\n * @link https://html.spec.whatwg.org/multipage/embedded-content.html#audiotracklist\n *\n * @return {AudioTrackList}\n *         the current audio track list\n *\n * @method Player.prototype.audioTracks\n */\n\n/**\n * Get the {@link TextTrackList}\n *\n * @link http://www.w3.org/html/wg/drafts/html/master/embedded-content-0.html#dom-media-texttracks\n *\n * @return {TextTrackList}\n *         the current text track list\n *\n * @method Player.prototype.textTracks\n */\n\n/**\n * Get the remote {@link TextTrackList}\n *\n * @return {TextTrackList}\n *         The current remote text track list\n *\n * @method Player.prototype.remoteTextTracks\n */\n\n/**\n * Get the remote {@link HtmlTrackElementList} tracks.\n *\n * @return {HtmlTrackElementList}\n *         The current remote text track element list\n *\n * @method Player.prototype.remoteTextTrackEls\n */\n\nALL.names.forEach(function (name$$1) {\n  var props = ALL[name$$1];\n\n  Player.prototype[props.getterName] = function () {\n    if (this.tech_) {\n      return this.tech_[props.getterName]();\n    }\n\n    // if we have not yet loadTech_, we create {video,audio,text}Tracks_\n    // these will be passed to the tech during loading\n    this[props.privateName] = this[props.privateName] || new props.ListClass();\n    return this[props.privateName];\n  };\n});\n\n/**\n * Global player list\n *\n * @type {Object}\n */\nPlayer.players = {};\n\nvar navigator = window.navigator;\n\n/*\n * Player instance options, surfaced using options\n * options = Player.prototype.options_\n * Make changes in options, not here.\n *\n * @type {Object}\n * @private\n */\nPlayer.prototype.options_ = {\n  // Default order of fallback technology\n  techOrder: Tech.defaultTechOrder_,\n\n  html5: {},\n  flash: {},\n\n  // default inactivity timeout\n  inactivityTimeout: 2000,\n\n  // default playback rates\n  playbackRates: [],\n  // Add playback rate selection by adding rates\n  // 'playbackRates': [0.5, 1, 1.5, 2],\n\n  // Included control sets\n  children: ['mediaLoader', 'posterImage', 'textTrackDisplay', 'loadingSpinner', 'bigPlayButton', 'controlBar', 'errorDisplay', 'textTrackSettings'],\n\n  language: navigator && (navigator.languages && navigator.languages[0] || navigator.userLanguage || navigator.language) || 'en',\n\n  // locales and their language translations\n  languages: {},\n\n  // Default message to show when a video cannot be played.\n  notSupportedMessage: 'No compatible source was found for this media.',\n\n  breakpoints: {},\n  responsive: false\n};\n\nif (!IS_IE8) {\n  Player.prototype.options_.children.push('resizeManager');\n}\n\n[\n/**\n * Returns whether or not the player is in the \"ended\" state.\n *\n * @return {Boolean} True if the player is in the ended state, false if not.\n * @method Player#ended\n */\n'ended',\n/**\n * Returns whether or not the player is in the \"seeking\" state.\n *\n * @return {Boolean} True if the player is in the seeking state, false if not.\n * @method Player#seeking\n */\n'seeking',\n/**\n * Returns the TimeRanges of the media that are currently available\n * for seeking to.\n *\n * @return {TimeRanges} the seekable intervals of the media timeline\n * @method Player#seekable\n */\n'seekable',\n/**\n * Returns the current state of network activity for the element, from\n * the codes in the list below.\n * - NETWORK_EMPTY (numeric value 0)\n *   The element has not yet been initialised. All attributes are in\n *   their initial states.\n * - NETWORK_IDLE (numeric value 1)\n *   The element's resource selection algorithm is active and has\n *   selected a resource, but it is not actually using the network at\n *   this time.\n * - NETWORK_LOADING (numeric value 2)\n *   The user agent is actively trying to download data.\n * - NETWORK_NO_SOURCE (numeric value 3)\n *   The element's resource selection algorithm is active, but it has\n *   not yet found a resource to use.\n *\n * @see https://html.spec.whatwg.org/multipage/embedded-content.html#network-states\n * @return {number} the current network activity state\n * @method Player#networkState\n */\n'networkState',\n/**\n * Returns a value that expresses the current state of the element\n * with respect to rendering the current playback position, from the\n * codes in the list below.\n * - HAVE_NOTHING (numeric value 0)\n *   No information regarding the media resource is available.\n * - HAVE_METADATA (numeric value 1)\n *   Enough of the resource has been obtained that the duration of the\n *   resource is available.\n * - HAVE_CURRENT_DATA (numeric value 2)\n *   Data for the immediate current playback position is available.\n * - HAVE_FUTURE_DATA (numeric value 3)\n *   Data for the immediate current playback position is available, as\n *   well as enough data for the user agent to advance the current\n *   playback position in the direction of playback.\n * - HAVE_ENOUGH_DATA (numeric value 4)\n *   The user agent estimates that enough data is available for\n *   playback to proceed uninterrupted.\n *\n * @see https://html.spec.whatwg.org/multipage/embedded-content.html#dom-media-readystate\n * @return {number} the current playback rendering state\n * @method Player#readyState\n */\n'readyState'].forEach(function (fn) {\n  Player.prototype[fn] = function () {\n    return this.techGet_(fn);\n  };\n});\n\nTECH_EVENTS_RETRIGGER.forEach(function (event) {\n  Player.prototype['handleTech' + toTitleCase(event) + '_'] = function () {\n    return this.trigger(event);\n  };\n});\n\n/**\n * Fired when the player has initial duration and dimension information\n *\n * @event Player#loadedmetadata\n * @type {EventTarget~Event}\n */\n\n/**\n * Fired when the player has downloaded data at the current playback position\n *\n * @event Player#loadeddata\n * @type {EventTarget~Event}\n */\n\n/**\n * Fired when the current playback position has changed *\n * During playback this is fired every 15-250 milliseconds, depending on the\n * playback technology in use.\n *\n * @event Player#timeupdate\n * @type {EventTarget~Event}\n */\n\n/**\n * Fired when the volume changes\n *\n * @event Player#volumechange\n * @type {EventTarget~Event}\n */\n\n/**\n * Reports whether or not a player has a plugin available.\n *\n * This does not report whether or not the plugin has ever been initialized\n * on this player. For that, [usingPlugin]{@link Player#usingPlugin}.\n *\n * @method Player#hasPlugin\n * @param  {string}  name\n *         The name of a plugin.\n *\n * @return {boolean}\n *         Whether or not this player has the requested plugin available.\n */\n\n/**\n * Reports whether or not a player is using a plugin by name.\n *\n * For basic plugins, this only reports whether the plugin has _ever_ been\n * initialized on this player.\n *\n * @method Player#usingPlugin\n * @param  {string} name\n *         The name of a plugin.\n *\n * @return {boolean}\n *         Whether or not this player is using the requested plugin.\n */\n\nComponent.registerComponent('Player', Player);\n\n/**\n * @file plugin.js\n */\n/**\n * The base plugin name.\n *\n * @private\n * @constant\n * @type {string}\n */\nvar BASE_PLUGIN_NAME = 'plugin';\n\n/**\n * The key on which a player's active plugins cache is stored.\n *\n * @private\n * @constant\n * @type     {string}\n */\nvar PLUGIN_CACHE_KEY = 'activePlugins_';\n\n/**\n * Stores registered plugins in a private space.\n *\n * @private\n * @type    {Object}\n */\nvar pluginStorage = {};\n\n/**\n * Reports whether or not a plugin has been registered.\n *\n * @private\n * @param   {string} name\n *          The name of a plugin.\n *\n * @returns {boolean}\n *          Whether or not the plugin has been registered.\n */\nvar pluginExists = function pluginExists(name) {\n  return pluginStorage.hasOwnProperty(name);\n};\n\n/**\n * Get a single registered plugin by name.\n *\n * @private\n * @param   {string} name\n *          The name of a plugin.\n *\n * @returns {Function|undefined}\n *          The plugin (or undefined).\n */\nvar getPlugin = function getPlugin(name) {\n  return pluginExists(name) ? pluginStorage[name] : undefined;\n};\n\n/**\n * Marks a plugin as \"active\" on a player.\n *\n * Also, ensures that the player has an object for tracking active plugins.\n *\n * @private\n * @param   {Player} player\n *          A Video.js player instance.\n *\n * @param   {string} name\n *          The name of a plugin.\n */\nvar markPluginAsActive = function markPluginAsActive(player, name) {\n  player[PLUGIN_CACHE_KEY] = player[PLUGIN_CACHE_KEY] || {};\n  player[PLUGIN_CACHE_KEY][name] = true;\n};\n\n/**\n * Triggers a pair of plugin setup events.\n *\n * @private\n * @param  {Player} player\n *         A Video.js player instance.\n *\n * @param  {Plugin~PluginEventHash} hash\n *         A plugin event hash.\n *\n * @param  {Boolean} [before]\n *         If true, prefixes the event name with \"before\". In other words,\n *         use this to trigger \"beforepluginsetup\" instead of \"pluginsetup\".\n */\nvar triggerSetupEvent = function triggerSetupEvent(player, hash, before) {\n  var eventName = (before ? 'before' : '') + 'pluginsetup';\n\n  player.trigger(eventName, hash);\n  player.trigger(eventName + ':' + hash.name, hash);\n};\n\n/**\n * Takes a basic plugin function and returns a wrapper function which marks\n * on the player that the plugin has been activated.\n *\n * @private\n * @param   {string} name\n *          The name of the plugin.\n *\n * @param   {Function} plugin\n *          The basic plugin.\n *\n * @returns {Function}\n *          A wrapper function for the given plugin.\n */\nvar createBasicPlugin = function createBasicPlugin(name, plugin) {\n  var basicPluginWrapper = function basicPluginWrapper() {\n\n    // We trigger the \"beforepluginsetup\" and \"pluginsetup\" events on the player\n    // regardless, but we want the hash to be consistent with the hash provided\n    // for advanced plugins.\n    //\n    // The only potentially counter-intuitive thing here is the `instance` in\n    // the \"pluginsetup\" event is the value returned by the `plugin` function.\n    triggerSetupEvent(this, { name: name, plugin: plugin, instance: null }, true);\n\n    var instance = plugin.apply(this, arguments);\n\n    markPluginAsActive(this, name);\n    triggerSetupEvent(this, { name: name, plugin: plugin, instance: instance });\n\n    return instance;\n  };\n\n  Object.keys(plugin).forEach(function (prop) {\n    basicPluginWrapper[prop] = plugin[prop];\n  });\n\n  return basicPluginWrapper;\n};\n\n/**\n * Takes a plugin sub-class and returns a factory function for generating\n * instances of it.\n *\n * This factory function will replace itself with an instance of the requested\n * sub-class of Plugin.\n *\n * @private\n * @param   {string} name\n *          The name of the plugin.\n *\n * @param   {Plugin} PluginSubClass\n *          The advanced plugin.\n *\n * @returns {Function}\n */\nvar createPluginFactory = function createPluginFactory(name, PluginSubClass) {\n\n  // Add a `name` property to the plugin prototype so that each plugin can\n  // refer to itself by name.\n  PluginSubClass.prototype.name = name;\n\n  return function () {\n    triggerSetupEvent(this, { name: name, plugin: PluginSubClass, instance: null }, true);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    var instance = new (Function.prototype.bind.apply(PluginSubClass, [null].concat([this].concat(args))))();\n\n    // The plugin is replaced by a function that returns the current instance.\n    this[name] = function () {\n      return instance;\n    };\n\n    triggerSetupEvent(this, instance.getEventHash());\n\n    return instance;\n  };\n};\n\n/**\n * Parent class for all advanced plugins.\n *\n * @mixes   module:evented~EventedMixin\n * @mixes   module:stateful~StatefulMixin\n * @fires   Player#beforepluginsetup\n * @fires   Player#beforepluginsetup:$name\n * @fires   Player#pluginsetup\n * @fires   Player#pluginsetup:$name\n * @listens Player#dispose\n * @throws  {Error}\n *          If attempting to instantiate the base {@link Plugin} class\n *          directly instead of via a sub-class.\n */\n\nvar Plugin = function () {\n\n  /**\n   * Creates an instance of this class.\n   *\n   * Sub-classes should call `super` to ensure plugins are properly initialized.\n   *\n   * @param {Player} player\n   *        A Video.js player instance.\n   */\n  function Plugin(player) {\n    classCallCheck(this, Plugin);\n\n    if (this.constructor === Plugin) {\n      throw new Error('Plugin must be sub-classed; not directly instantiated.');\n    }\n\n    this.player = player;\n\n    // Make this object evented, but remove the added `trigger` method so we\n    // use the prototype version instead.\n    evented(this);\n    delete this.trigger;\n\n    stateful(this, this.constructor.defaultState);\n    markPluginAsActive(player, this.name);\n\n    // Auto-bind the dispose method so we can use it as a listener and unbind\n    // it later easily.\n    this.dispose = bind(this, this.dispose);\n\n    // If the player is disposed, dispose the plugin.\n    player.on('dispose', this.dispose);\n  }\n\n  /**\n   * Get the version of the plugin that was set on <pluginName>.VERSION\n   */\n\n\n  Plugin.prototype.version = function version() {\n    return this.constructor.VERSION;\n  };\n\n  /**\n   * Each event triggered by plugins includes a hash of additional data with\n   * conventional properties.\n   *\n   * This returns that object or mutates an existing hash.\n   *\n   * @param   {Object} [hash={}]\n   *          An object to be used as event an event hash.\n   *\n   * @returns {Plugin~PluginEventHash}\n   *          An event hash object with provided properties mixed-in.\n   */\n\n\n  Plugin.prototype.getEventHash = function getEventHash() {\n    var hash = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    hash.name = this.name;\n    hash.plugin = this.constructor;\n    hash.instance = this;\n    return hash;\n  };\n\n  /**\n   * Triggers an event on the plugin object and overrides\n   * {@link module:evented~EventedMixin.trigger|EventedMixin.trigger}.\n   *\n   * @param   {string|Object} event\n   *          An event type or an object with a type property.\n   *\n   * @param   {Object} [hash={}]\n   *          Additional data hash to merge with a\n   *          {@link Plugin~PluginEventHash|PluginEventHash}.\n   *\n   * @returns {boolean}\n   *          Whether or not default was prevented.\n   */\n\n\n  Plugin.prototype.trigger = function trigger$$1(event) {\n    var hash = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    return trigger(this.eventBusEl_, event, this.getEventHash(hash));\n  };\n\n  /**\n   * Handles \"statechanged\" events on the plugin. No-op by default, override by\n   * subclassing.\n   *\n   * @abstract\n   * @param    {Event} e\n   *           An event object provided by a \"statechanged\" event.\n   *\n   * @param    {Object} e.changes\n   *           An object describing changes that occurred with the \"statechanged\"\n   *           event.\n   */\n\n\n  Plugin.prototype.handleStateChanged = function handleStateChanged(e) {};\n\n  /**\n   * Disposes a plugin.\n   *\n   * Subclasses can override this if they want, but for the sake of safety,\n   * it's probably best to subscribe the \"dispose\" event.\n   *\n   * @fires Plugin#dispose\n   */\n\n\n  Plugin.prototype.dispose = function dispose() {\n    var name = this.name,\n        player = this.player;\n\n    /**\n     * Signals that a advanced plugin is about to be disposed.\n     *\n     * @event Plugin#dispose\n     * @type  {EventTarget~Event}\n     */\n\n    this.trigger('dispose');\n    this.off();\n    player.off('dispose', this.dispose);\n\n    // Eliminate any possible sources of leaking memory by clearing up\n    // references between the player and the plugin instance and nulling out\n    // the plugin's state and replacing methods with a function that throws.\n    player[PLUGIN_CACHE_KEY][name] = false;\n    this.player = this.state = null;\n\n    // Finally, replace the plugin name on the player with a new factory\n    // function, so that the plugin is ready to be set up again.\n    player[name] = createPluginFactory(name, pluginStorage[name]);\n  };\n\n  /**\n   * Determines if a plugin is a basic plugin (i.e. not a sub-class of `Plugin`).\n   *\n   * @param   {string|Function} plugin\n   *          If a string, matches the name of a plugin. If a function, will be\n   *          tested directly.\n   *\n   * @returns {boolean}\n   *          Whether or not a plugin is a basic plugin.\n   */\n\n\n  Plugin.isBasic = function isBasic(plugin) {\n    var p = typeof plugin === 'string' ? getPlugin(plugin) : plugin;\n\n    return typeof p === 'function' && !Plugin.prototype.isPrototypeOf(p.prototype);\n  };\n\n  /**\n   * Register a Video.js plugin.\n   *\n   * @param   {string} name\n   *          The name of the plugin to be registered. Must be a string and\n   *          must not match an existing plugin or a method on the `Player`\n   *          prototype.\n   *\n   * @param   {Function} plugin\n   *          A sub-class of `Plugin` or a function for basic plugins.\n   *\n   * @returns {Function}\n   *          For advanced plugins, a factory function for that plugin. For\n   *          basic plugins, a wrapper function that initializes the plugin.\n   */\n\n\n  Plugin.registerPlugin = function registerPlugin(name, plugin) {\n    if (typeof name !== 'string') {\n      throw new Error('Illegal plugin name, \"' + name + '\", must be a string, was ' + (typeof name === 'undefined' ? 'undefined' : _typeof(name)) + '.');\n    }\n\n    if (pluginExists(name)) {\n      log.warn('A plugin named \"' + name + '\" already exists. You may want to avoid re-registering plugins!');\n    } else if (Player.prototype.hasOwnProperty(name)) {\n      throw new Error('Illegal plugin name, \"' + name + '\", cannot share a name with an existing player method!');\n    }\n\n    if (typeof plugin !== 'function') {\n      throw new Error('Illegal plugin for \"' + name + '\", must be a function, was ' + (typeof plugin === 'undefined' ? 'undefined' : _typeof(plugin)) + '.');\n    }\n\n    pluginStorage[name] = plugin;\n\n    // Add a player prototype method for all sub-classed plugins (but not for\n    // the base Plugin class).\n    if (name !== BASE_PLUGIN_NAME) {\n      if (Plugin.isBasic(plugin)) {\n        Player.prototype[name] = createBasicPlugin(name, plugin);\n      } else {\n        Player.prototype[name] = createPluginFactory(name, plugin);\n      }\n    }\n\n    return plugin;\n  };\n\n  /**\n   * De-register a Video.js plugin.\n   *\n   * @param {string} name\n   *        The name of the plugin to be deregistered.\n   */\n\n\n  Plugin.deregisterPlugin = function deregisterPlugin(name) {\n    if (name === BASE_PLUGIN_NAME) {\n      throw new Error('Cannot de-register base plugin.');\n    }\n    if (pluginExists(name)) {\n      delete pluginStorage[name];\n      delete Player.prototype[name];\n    }\n  };\n\n  /**\n   * Gets an object containing multiple Video.js plugins.\n   *\n   * @param   {Array} [names]\n   *          If provided, should be an array of plugin names. Defaults to _all_\n   *          plugin names.\n   *\n   * @returns {Object|undefined}\n   *          An object containing plugin(s) associated with their name(s) or\n   *          `undefined` if no matching plugins exist).\n   */\n\n\n  Plugin.getPlugins = function getPlugins() {\n    var names = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Object.keys(pluginStorage);\n\n    var result = void 0;\n\n    names.forEach(function (name) {\n      var plugin = getPlugin(name);\n\n      if (plugin) {\n        result = result || {};\n        result[name] = plugin;\n      }\n    });\n\n    return result;\n  };\n\n  /**\n   * Gets a plugin's version, if available\n   *\n   * @param   {string} name\n   *          The name of a plugin.\n   *\n   * @returns {string}\n   *          The plugin's version or an empty string.\n   */\n\n\n  Plugin.getPluginVersion = function getPluginVersion(name) {\n    var plugin = getPlugin(name);\n\n    return plugin && plugin.VERSION || '';\n  };\n\n  return Plugin;\n}();\n\n/**\n * Gets a plugin by name if it exists.\n *\n * @static\n * @method   getPlugin\n * @memberOf Plugin\n * @param    {string} name\n *           The name of a plugin.\n *\n * @returns  {Function|undefined}\n *           The plugin (or `undefined`).\n */\n\n\nPlugin.getPlugin = getPlugin;\n\n/**\n * The name of the base plugin class as it is registered.\n *\n * @type {string}\n */\nPlugin.BASE_PLUGIN_NAME = BASE_PLUGIN_NAME;\n\nPlugin.registerPlugin(BASE_PLUGIN_NAME, Plugin);\n\n/**\n * Documented in player.js\n *\n * @ignore\n */\nPlayer.prototype.usingPlugin = function (name) {\n  return !!this[PLUGIN_CACHE_KEY] && this[PLUGIN_CACHE_KEY][name] === true;\n};\n\n/**\n * Documented in player.js\n *\n * @ignore\n */\nPlayer.prototype.hasPlugin = function (name) {\n  return !!pluginExists(name);\n};\n\n/**\n * Signals that a plugin is about to be set up on a player.\n *\n * @event    Player#beforepluginsetup\n * @type     {Plugin~PluginEventHash}\n */\n\n/**\n * Signals that a plugin is about to be set up on a player - by name. The name\n * is the name of the plugin.\n *\n * @event    Player#beforepluginsetup:$name\n * @type     {Plugin~PluginEventHash}\n */\n\n/**\n * Signals that a plugin has just been set up on a player.\n *\n * @event    Player#pluginsetup\n * @type     {Plugin~PluginEventHash}\n */\n\n/**\n * Signals that a plugin has just been set up on a player - by name. The name\n * is the name of the plugin.\n *\n * @event    Player#pluginsetup:$name\n * @type     {Plugin~PluginEventHash}\n */\n\n/**\n * @typedef  {Object} Plugin~PluginEventHash\n *\n * @property {string} instance\n *           For basic plugins, the return value of the plugin function. For\n *           advanced plugins, the plugin instance on which the event is fired.\n *\n * @property {string} name\n *           The name of the plugin.\n *\n * @property {string} plugin\n *           For basic plugins, the plugin function. For advanced plugins, the\n *           plugin class/constructor.\n */\n\n/**\n * @file extend.js\n * @module extend\n */\n\n/**\n * A combination of node inherits and babel's inherits (after transpile).\n * Both work the same but node adds `super_` to the subClass\n * and Bable adds the superClass as __proto__. Both seem useful.\n *\n * @param {Object} subClass\n *        The class to inherit to\n *\n * @param {Object} superClass\n *        The class to inherit from\n *\n * @private\n */\nvar _inherits = function _inherits(subClass, superClass) {\n  if (typeof superClass !== 'function' && superClass !== null) {\n    throw new TypeError('Super expression must either be null or a function, not ' + (typeof superClass === 'undefined' ? 'undefined' : _typeof(superClass)));\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n\n  if (superClass) {\n    // node\n    subClass.super_ = superClass;\n  }\n};\n\n/**\n * Function for subclassing using the same inheritance that\n * videojs uses internally\n *\n * @static\n * @const\n *\n * @param {Object} superClass\n *        The class to inherit from\n *\n * @param {Object} [subClassMethods={}]\n *        The class to inherit to\n *\n * @return {Object}\n *         The new object with subClassMethods that inherited superClass.\n */\nvar extendFn = function extendFn(superClass) {\n  var subClassMethods = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  var subClass = function subClass() {\n    superClass.apply(this, arguments);\n  };\n\n  var methods = {};\n\n  if ((typeof subClassMethods === 'undefined' ? 'undefined' : _typeof(subClassMethods)) === 'object') {\n    if (subClassMethods.constructor !== Object.prototype.constructor) {\n      subClass = subClassMethods.constructor;\n    }\n    methods = subClassMethods;\n  } else if (typeof subClassMethods === 'function') {\n    subClass = subClassMethods;\n  }\n\n  _inherits(subClass, superClass);\n\n  // Extend subObj's prototype with functions and other properties from props\n  for (var name in methods) {\n    if (methods.hasOwnProperty(name)) {\n      subClass.prototype[name] = methods[name];\n    }\n  }\n\n  return subClass;\n};\n\n/**\n * @file video.js\n * @module videojs\n */\n// Include the built-in techs\n// HTML5 Element Shim for IE8\nif (typeof HTMLVideoElement === 'undefined' && isReal()) {\n  document.createElement('video');\n  document.createElement('audio');\n  document.createElement('track');\n  document.createElement('video-js');\n}\n\n/**\n * Normalize an `id` value by trimming off a leading `#`\n *\n * @param   {string} id\n *          A string, maybe with a leading `#`.\n *\n * @returns {string}\n *          The string, without any leading `#`.\n */\nvar normalizeId = function normalizeId(id) {\n  return id.indexOf('#') === 0 ? id.slice(1) : id;\n};\n\n/**\n * Doubles as the main function for users to create a player instance and also\n * the main library object.\n * The `videojs` function can be used to initialize or retrieve a player.\n  *\n * @param {string|Element} id\n *        Video element or video element ID\n *\n * @param {Object} [options]\n *        Optional options object for config/settings\n *\n * @param {Component~ReadyCallback} [ready]\n *        Optional ready callback\n *\n * @return {Player}\n *         A player instance\n */\nfunction videojs(id, options, ready) {\n  var player = videojs.getPlayer(id);\n\n  if (player) {\n    if (options) {\n      log.warn('Player \"' + id + '\" is already initialised. Options will not be applied.');\n    }\n    if (ready) {\n      player.ready(ready);\n    }\n    return player;\n  }\n\n  var el = typeof id === 'string' ? $('#' + normalizeId(id)) : id;\n\n  if (!isEl(el)) {\n    throw new TypeError('The element or ID supplied is not valid. (videojs)');\n  }\n\n  if (!document.body.contains(el)) {\n    log.warn('The element supplied is not included in the DOM');\n  }\n\n  options = options || {};\n\n  videojs.hooks('beforesetup').forEach(function (hookFunction) {\n    var opts = hookFunction(el, mergeOptions(options));\n\n    if (!isObject(opts) || Array.isArray(opts)) {\n      log.error('please return an object in beforesetup hooks');\n      return;\n    }\n\n    options = mergeOptions(options, opts);\n  });\n\n  // We get the current \"Player\" component here in case an integration has\n  // replaced it with a custom player.\n  var PlayerComponent = Component.getComponent('Player');\n\n  player = new PlayerComponent(el, options, ready);\n\n  videojs.hooks('setup').forEach(function (hookFunction) {\n    return hookFunction(player);\n  });\n\n  return player;\n}\n\n/**\n * An Object that contains lifecycle hooks as keys which point to an array\n * of functions that are run when a lifecycle is triggered\n */\nvideojs.hooks_ = {};\n\n/**\n * Get a list of hooks for a specific lifecycle\n * @function videojs.hooks\n *\n * @param {string} type\n *        the lifecyle to get hooks from\n *\n * @param {Function|Function[]} [fn]\n *        Optionally add a hook (or hooks) to the lifecycle that your are getting.\n *\n * @return {Array}\n *         an array of hooks, or an empty array if there are none.\n */\nvideojs.hooks = function (type, fn) {\n  videojs.hooks_[type] = videojs.hooks_[type] || [];\n  if (fn) {\n    videojs.hooks_[type] = videojs.hooks_[type].concat(fn);\n  }\n  return videojs.hooks_[type];\n};\n\n/**\n * Add a function hook to a specific videojs lifecycle.\n *\n * @param {string} type\n *        the lifecycle to hook the function to.\n *\n * @param {Function|Function[]}\n *        The function or array of functions to attach.\n */\nvideojs.hook = function (type, fn) {\n  videojs.hooks(type, fn);\n};\n\n/**\n * Add a function hook that will only run once to a specific videojs lifecycle.\n *\n * @param {string} type\n *        the lifecycle to hook the function to.\n *\n * @param {Function|Function[]}\n *        The function or array of functions to attach.\n */\nvideojs.hookOnce = function (type, fn) {\n  videojs.hooks(type, [].concat(fn).map(function (original) {\n    var wrapper = function wrapper() {\n      videojs.removeHook(type, wrapper);\n      return original.apply(undefined, arguments);\n    };\n\n    return wrapper;\n  }));\n};\n\n/**\n * Remove a hook from a specific videojs lifecycle.\n *\n * @param {string} type\n *        the lifecycle that the function hooked to\n *\n * @param {Function} fn\n *        The hooked function to remove\n *\n * @return {boolean}\n *         The function that was removed or undef\n */\nvideojs.removeHook = function (type, fn) {\n  var index = videojs.hooks(type).indexOf(fn);\n\n  if (index <= -1) {\n    return false;\n  }\n\n  videojs.hooks_[type] = videojs.hooks_[type].slice();\n  videojs.hooks_[type].splice(index, 1);\n\n  return true;\n};\n\n// Add default styles\nif (window.VIDEOJS_NO_DYNAMIC_STYLE !== true && isReal()) {\n  var style = $('.vjs-styles-defaults');\n\n  if (!style) {\n    style = createStyleElement('vjs-styles-defaults');\n    var head = $('head');\n\n    if (head) {\n      head.insertBefore(style, head.firstChild);\n    }\n    setTextContent(style, '\\n      .video-js {\\n        width: 300px;\\n        height: 150px;\\n      }\\n\\n      .vjs-fluid {\\n        padding-top: 56.25%\\n      }\\n    ');\n  }\n}\n\n// Run Auto-load players\n// You have to wait at least once in case this script is loaded after your\n// video in the DOM (weird behavior only with minified version)\nautoSetupTimeout(1, videojs);\n\n/**\n * Current software version. Follows semver.\n *\n * @type {string}\n */\nvideojs.VERSION = version;\n\n/**\n * The global options object. These are the settings that take effect\n * if no overrides are specified when the player is created.\n *\n * @type {Object}\n */\nvideojs.options = Player.prototype.options_;\n\n/**\n * Get an object with the currently created players, keyed by player ID\n *\n * @return {Object}\n *         The created players\n */\nvideojs.getPlayers = function () {\n  return Player.players;\n};\n\n/**\n * Get a single player based on an ID or DOM element.\n *\n * This is useful if you want to check if an element or ID has an associated\n * Video.js player, but not create one if it doesn't.\n *\n * @param   {string|Element} id\n *          An HTML element - `<video>`, `<audio>`, or `<video-js>` -\n *          or a string matching the `id` of such an element.\n *\n * @returns {Player|undefined}\n *          A player instance or `undefined` if there is no player instance\n *          matching the argument.\n */\nvideojs.getPlayer = function (id) {\n  var players = Player.players;\n  var tag = void 0;\n\n  if (typeof id === 'string') {\n    var nId = normalizeId(id);\n    var player = players[nId];\n\n    if (player) {\n      return player;\n    }\n\n    tag = $('#' + nId);\n  } else {\n    tag = id;\n  }\n\n  if (isEl(tag)) {\n    var _tag = tag,\n        _player = _tag.player,\n        playerId = _tag.playerId;\n\n    // Element may have a `player` property referring to an already created\n    // player instance. If so, return that.\n\n    if (_player || players[playerId]) {\n      return _player || players[playerId];\n    }\n  }\n};\n\n/**\n * Returns an array of all current players.\n *\n * @return {Array}\n *         An array of all players. The array will be in the order that\n *         `Object.keys` provides, which could potentially vary between\n *         JavaScript engines.\n *\n */\nvideojs.getAllPlayers = function () {\n  return (\n\n    // Disposed players leave a key with a `null` value, so we need to make sure\n    // we filter those out.\n    Object.keys(Player.players).map(function (k) {\n      return Player.players[k];\n    }).filter(Boolean)\n  );\n};\n\n/**\n * Expose players object.\n *\n * @memberOf videojs\n * @property {Object} players\n */\nvideojs.players = Player.players;\n\n/**\n * Get a component class object by name\n *\n * @borrows Component.getComponent as videojs.getComponent\n */\nvideojs.getComponent = Component.getComponent;\n\n/**\n * Register a component so it can referred to by name. Used when adding to other\n * components, either through addChild `component.addChild('myComponent')` or through\n * default children options  `{ children: ['myComponent'] }`.\n *\n * > NOTE: You could also just initialize the component before adding.\n * `component.addChild(new MyComponent());`\n *\n * @param {string} name\n *        The class name of the component\n *\n * @param {Component} comp\n *        The component class\n *\n * @return {Component}\n *         The newly registered component\n */\nvideojs.registerComponent = function (name$$1, comp) {\n  if (Tech.isTech(comp)) {\n    log.warn('The ' + name$$1 + ' tech was registered as a component. It should instead be registered using videojs.registerTech(name, tech)');\n  }\n\n  Component.registerComponent.call(Component, name$$1, comp);\n};\n\n/**\n * Get a Tech class object by name\n *\n * @borrows Tech.getTech as videojs.getTech\n */\nvideojs.getTech = Tech.getTech;\n\n/**\n * Register a Tech so it can referred to by name.\n * This is used in the tech order for the player.\n *\n * @borrows Tech.registerTech as videojs.registerTech\n */\nvideojs.registerTech = Tech.registerTech;\n\n/**\n * Register a middleware to a source type.\n *\n * @param {String} type A string representing a MIME type.\n * @param {function(player):object} middleware A middleware factory that takes a player.\n */\nvideojs.use = use;\n\n/**\n * An object that can be returned by a middleware to signify\n * that the middleware is being terminated.\n *\n * @type {object}\n * @memberOf {videojs}\n * @property {object} middleware.TERMINATOR\n */\n// Object.defineProperty is not available in IE8\nif (!IS_IE8 && Object.defineProperty) {\n  Object.defineProperty(videojs, 'middleware', {\n    value: {},\n    writeable: false,\n    enumerable: true\n  });\n\n  Object.defineProperty(videojs.middleware, 'TERMINATOR', {\n    value: TERMINATOR,\n    writeable: false,\n    enumerable: true\n  });\n} else {\n  videojs.middleware = { TERMINATOR: TERMINATOR };\n}\n\n/**\n * A suite of browser and device tests from {@link browser}.\n *\n * @type {Object}\n * @private\n */\nvideojs.browser = browser;\n\n/**\n * Whether or not the browser supports touch events. Included for backward\n * compatibility with 4.x, but deprecated. Use `videojs.browser.TOUCH_ENABLED`\n * instead going forward.\n *\n * @deprecated since version 5.0\n * @type {boolean}\n */\nvideojs.TOUCH_ENABLED = TOUCH_ENABLED;\n\n/**\n * Subclass an existing class\n * Mimics ES6 subclassing with the `extend` keyword\n *\n * @borrows extend:extendFn as videojs.extend\n */\nvideojs.extend = extendFn;\n\n/**\n * Merge two options objects recursively\n * Performs a deep merge like lodash.merge but **only merges plain objects**\n * (not arrays, elements, anything else)\n * Other values will be copied directly from the second object.\n *\n * @borrows merge-options:mergeOptions as videojs.mergeOptions\n */\nvideojs.mergeOptions = mergeOptions;\n\n/**\n * Change the context (this) of a function\n *\n * > NOTE: as of v5.0 we require an ES5 shim, so you should use the native\n * `function() {}.bind(newContext);` instead of this.\n *\n * @borrows fn:bind as videojs.bind\n */\nvideojs.bind = bind;\n\n/**\n * Register a Video.js plugin.\n *\n * @borrows plugin:registerPlugin as videojs.registerPlugin\n * @method registerPlugin\n *\n * @param  {string} name\n *         The name of the plugin to be registered. Must be a string and\n *         must not match an existing plugin or a method on the `Player`\n *         prototype.\n *\n * @param  {Function} plugin\n *         A sub-class of `Plugin` or a function for basic plugins.\n *\n * @return {Function}\n *         For advanced plugins, a factory function for that plugin. For\n *         basic plugins, a wrapper function that initializes the plugin.\n */\nvideojs.registerPlugin = Plugin.registerPlugin;\n\n/**\n * Deregister a Video.js plugin.\n *\n * @borrows plugin:deregisterPlugin as videojs.deregisterPlugin\n * @method deregisterPlugin\n *\n * @param  {string} name\n *         The name of the plugin to be deregistered. Must be a string and\n *         must match an existing plugin or a method on the `Player`\n *         prototype.\n *\n */\nvideojs.deregisterPlugin = Plugin.deregisterPlugin;\n\n/**\n * Deprecated method to register a plugin with Video.js\n *\n * @deprecated\n *        videojs.plugin() is deprecated; use videojs.registerPlugin() instead\n *\n * @param {string} name\n *        The plugin name\n *\n * @param {Plugin|Function} plugin\n *         The plugin sub-class or function\n */\nvideojs.plugin = function (name$$1, plugin) {\n  log.warn('videojs.plugin() is deprecated; use videojs.registerPlugin() instead');\n  return Plugin.registerPlugin(name$$1, plugin);\n};\n\n/**\n * Gets an object containing multiple Video.js plugins.\n *\n * @param  {Array} [names]\n *         If provided, should be an array of plugin names. Defaults to _all_\n *         plugin names.\n *\n * @return {Object|undefined}\n *         An object containing plugin(s) associated with their name(s) or\n *         `undefined` if no matching plugins exist).\n */\nvideojs.getPlugins = Plugin.getPlugins;\n\n/**\n * Gets a plugin by name if it exists.\n *\n * @param  {string} name\n *         The name of a plugin.\n *\n * @return {Function|undefined}\n *         The plugin (or `undefined`).\n */\nvideojs.getPlugin = Plugin.getPlugin;\n\n/**\n * Gets a plugin's version, if available\n *\n * @param  {string} name\n *         The name of a plugin.\n *\n * @return {string}\n *         The plugin's version or an empty string.\n */\nvideojs.getPluginVersion = Plugin.getPluginVersion;\n\n/**\n * Adding languages so that they're available to all players.\n * Example: `videojs.addLanguage('es', { 'Hello': 'Hola' });`\n *\n * @param {string} code\n *        The language code or dictionary property\n *\n * @param {Object} data\n *        The data values to be translated\n *\n * @return {Object}\n *         The resulting language dictionary object\n */\nvideojs.addLanguage = function (code, data) {\n  var _mergeOptions;\n\n  code = ('' + code).toLowerCase();\n\n  videojs.options.languages = mergeOptions(videojs.options.languages, (_mergeOptions = {}, _mergeOptions[code] = data, _mergeOptions));\n\n  return videojs.options.languages[code];\n};\n\n/**\n * Log messages\n *\n * @borrows log:log as videojs.log\n */\nvideojs.log = log;\nvideojs.createLogger = createLogger;\n\n/**\n * Creates an emulated TimeRange object.\n *\n * @borrows time-ranges:createTimeRanges as videojs.createTimeRange\n */\n/**\n * @borrows time-ranges:createTimeRanges as videojs.createTimeRanges\n */\nvideojs.createTimeRange = videojs.createTimeRanges = createTimeRanges;\n\n/**\n * Format seconds as a time string, H:MM:SS or M:SS\n * Supplying a guide (in seconds) will force a number of leading zeros\n * to cover the length of the guide\n *\n * @borrows format-time:formatTime as videojs.formatTime\n */\nvideojs.formatTime = formatTime;\n\n/**\n * Replaces format-time with a custom implementation, to be used in place of the default.\n *\n * @borrows format-time:setFormatTime as videojs.setFormatTime\n *\n * @method setFormatTime\n *\n * @param {Function} customFn\n *        A custom format-time function which will be called with the current time and guide (in seconds) as arguments.\n *        Passed fn should return a string.\n */\nvideojs.setFormatTime = setFormatTime;\n\n/**\n * Resets format-time to the default implementation.\n *\n * @borrows format-time:resetFormatTime as videojs.resetFormatTime\n *\n * @method resetFormatTime\n */\nvideojs.resetFormatTime = resetFormatTime;\n\n/**\n * Resolve and parse the elements of a URL\n *\n * @borrows url:parseUrl as videojs.parseUrl\n *\n */\nvideojs.parseUrl = parseUrl;\n\n/**\n * Returns whether the url passed is a cross domain request or not.\n *\n * @borrows url:isCrossOrigin as videojs.isCrossOrigin\n */\nvideojs.isCrossOrigin = isCrossOrigin;\n\n/**\n * Event target class.\n *\n * @borrows EventTarget as videojs.EventTarget\n */\nvideojs.EventTarget = EventTarget;\n\n/**\n * Add an event listener to element\n * It stores the handler function in a separate cache object\n * and adds a generic handler to the element's event,\n * along with a unique id (guid) to the element.\n *\n * @borrows events:on as videojs.on\n */\nvideojs.on = on;\n\n/**\n * Trigger a listener only once for an event\n *\n * @borrows events:one as videojs.one\n */\nvideojs.one = one;\n\n/**\n * Removes event listeners from an element\n *\n * @borrows events:off as videojs.off\n */\nvideojs.off = off;\n\n/**\n * Trigger an event for an element\n *\n * @borrows events:trigger as videojs.trigger\n */\nvideojs.trigger = trigger;\n\n/**\n * A cross-browser XMLHttpRequest wrapper. Here's a simple example:\n *\n * @param {Object} options\n *        settings for the request.\n *\n * @return {XMLHttpRequest|XDomainRequest}\n *         The request object.\n *\n * @see https://github.com/Raynos/xhr\n */\nvideojs.xhr = xhr;\n\n/**\n * TextTrack class\n *\n * @borrows TextTrack as videojs.TextTrack\n */\nvideojs.TextTrack = TextTrack;\n\n/**\n * export the AudioTrack class so that source handlers can create\n * AudioTracks and then add them to the players AudioTrackList\n *\n * @borrows AudioTrack as videojs.AudioTrack\n */\nvideojs.AudioTrack = AudioTrack;\n\n/**\n * export the VideoTrack class so that source handlers can create\n * VideoTracks and then add them to the players VideoTrackList\n *\n * @borrows VideoTrack as videojs.VideoTrack\n */\nvideojs.VideoTrack = VideoTrack;\n\n/**\n * Determines, via duck typing, whether or not a value is a DOM element.\n *\n * @borrows dom:isEl as videojs.isEl\n * @deprecated Use videojs.dom.isEl() instead\n */\n\n/**\n * Determines, via duck typing, whether or not a value is a text node.\n *\n * @borrows dom:isTextNode as videojs.isTextNode\n * @deprecated Use videojs.dom.isTextNode() instead\n */\n\n/**\n * Creates an element and applies properties.\n *\n * @borrows dom:createEl as videojs.createEl\n * @deprecated Use videojs.dom.createEl() instead\n */\n\n/**\n * Check if an element has a CSS class\n *\n * @borrows dom:hasElClass as videojs.hasClass\n * @deprecated Use videojs.dom.hasClass() instead\n */\n\n/**\n * Add a CSS class name to an element\n *\n * @borrows dom:addElClass as videojs.addClass\n * @deprecated Use videojs.dom.addClass() instead\n */\n\n/**\n * Remove a CSS class name from an element\n *\n * @borrows dom:removeElClass as videojs.removeClass\n * @deprecated Use videojs.dom.removeClass() instead\n */\n\n/**\n * Adds or removes a CSS class name on an element depending on an optional\n * condition or the presence/absence of the class name.\n *\n * @borrows dom:toggleElClass as videojs.toggleClass\n * @deprecated Use videojs.dom.toggleClass() instead\n */\n\n/**\n * Apply attributes to an HTML element.\n *\n * @borrows dom:setElAttributes as videojs.setAttribute\n * @deprecated Use videojs.dom.setAttributes() instead\n */\n\n/**\n * Get an element's attribute values, as defined on the HTML tag\n * Attributes are not the same as properties. They're defined on the tag\n * or with setAttribute (which shouldn't be used with HTML)\n * This will return true or false for boolean attributes.\n *\n * @borrows dom:getElAttributes as videojs.getAttributes\n * @deprecated Use videojs.dom.getAttributes() instead\n */\n\n/**\n * Empties the contents of an element.\n *\n * @borrows dom:emptyEl as videojs.emptyEl\n * @deprecated Use videojs.dom.emptyEl() instead\n */\n\n/**\n * Normalizes and appends content to an element.\n *\n * The content for an element can be passed in multiple types and\n * combinations, whose behavior is as follows:\n *\n * - String\n *   Normalized into a text node.\n *\n * - Element, TextNode\n *   Passed through.\n *\n * - Array\n *   A one-dimensional array of strings, elements, nodes, or functions (which\n *   return single strings, elements, or nodes).\n *\n * - Function\n *   If the sole argument, is expected to produce a string, element,\n *   node, or array.\n *\n * @borrows dom:appendContents as videojs.appendContet\n * @deprecated Use videojs.dom.appendContent() instead\n */\n\n/**\n * Normalizes and inserts content into an element; this is identical to\n * `appendContent()`, except it empties the element first.\n *\n * The content for an element can be passed in multiple types and\n * combinations, whose behavior is as follows:\n *\n * - String\n *   Normalized into a text node.\n *\n * - Element, TextNode\n *   Passed through.\n *\n * - Array\n *   A one-dimensional array of strings, elements, nodes, or functions (which\n *   return single strings, elements, or nodes).\n *\n * - Function\n *   If the sole argument, is expected to produce a string, element,\n *   node, or array.\n *\n * @borrows dom:insertContent as videojs.insertContent\n * @deprecated Use videojs.dom.insertContent() instead\n */\n['isEl', 'isTextNode', 'createEl', 'hasClass', 'addClass', 'removeClass', 'toggleClass', 'setAttributes', 'getAttributes', 'emptyEl', 'appendContent', 'insertContent'].forEach(function (k) {\n  videojs[k] = function () {\n    log.warn('videojs.' + k + '() is deprecated; use videojs.dom.' + k + '() instead');\n    return Dom[k].apply(null, arguments);\n  };\n});\n\n/**\n * A safe getComputedStyle with an IE8 fallback.\n *\n * This is because in Firefox, if the player is loaded in an iframe with `display:none`,\n * then `getComputedStyle` returns `null`, so, we do a null-check to make sure\n * that the player doesn't break in these cases.\n * See https://bugzilla.mozilla.org/show_bug.cgi?id=548397 for more details.\n *\n * @borrows computed-style:computedStyle as videojs.computedStyle\n */\nvideojs.computedStyle = computedStyle;\n\n/**\n * Export the Dom utilities for use in external plugins\n * and Tech's\n */\nvideojs.dom = Dom;\n\n/**\n * Export the Url utilities for use in external plugins\n * and Tech's\n */\nvideojs.url = Url;\n\nmodule.exports = videojs;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdmlkZW9qcy1jb250cmliLW1lZGlhLXNvdXJjZXMvbm9kZV9tb2R1bGVzL3ZpZGVvLmpzL2Rpc3QvdmlkZW8uY2pzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0NBQWdDOztBQUVoQyw2QkFBNkIsbUJBQU8sQ0FBQyx1R0FBZTtBQUNwRCwrQkFBK0IsbUJBQU8sQ0FBQywyR0FBaUI7QUFDeEQsMkJBQTJCLG1CQUFPLENBQUMsK0NBQU07QUFDekMscUNBQXFDLG1CQUFPLENBQUMsNEVBQXVCO0FBQ3BFLDBCQUEwQixtQkFBTyxDQUFDLDhDQUFLO0FBQ3ZDLDBCQUEwQixtQkFBTyxDQUFDLDJIQUFnQjs7QUFFbEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FB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Q0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxtQkFBbUI7QUFDOUI7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0EsV0FBVyxnQkFBZ0I7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBLFdBQVcsZ0JBQWdCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNB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O0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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Q0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsK0NBQStDLG1DQUFtQztBQUNsRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFD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O0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwrQkFBK0IsUUFBUTtBQUN2Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLGdCQUFnQjtBQUNsQztBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNB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Q0E7QUFDQSxNQUFNLHFCQUFxQjtBQUMzQjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU0sb0JBQW9CO0FBQzFCOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsbUJBQW1CO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2REFBNkQ7QUFDN0Q7QUFDQTtBQUNBLGFBQWEsbUJBQW1CO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0RBQWdEO0FBQ2hELE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7OztBQUdBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGFBQWE7QUFDekM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTSxzQ0FBc0M7QUFDNUM7QUFDQTtBQUNBLGFBQWEsbUJBQW1CO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiwrQkFBK0I7QUFDbEQ7O0FBRUE7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU0sMEJBQTBCO0FBQ2hDO0FBQ0EsYUFBYSxtQkFBbUI7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxtQkFBbUI7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxtQkFBbUI7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsbUJBQW1CO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxtQkFBbUI7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7O0FBR0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFFBQVE7QUFDbEI7QUFDQTtBQUNBLFVBQVUsUUFBUTtBQUNsQjtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsbUJBQW1CO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsbUJBQW1CO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxtQkFBbUI7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsbUJBQW1CO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7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QTs7QUFFQTtBQUNBLG9DQUFvQyx1QkFBdUI7QUFDM0Q7QUFDQSxhQUFhLG1CQUFtQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLG1CQUFtQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBLGFBQWEsUUFBUSxXQUFXO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7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Q0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVksZ0JBQWdCO0FBQzVCO0FBQ0EsYUFBYSxlQUFlO0FBQzVCO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsbUJBQW1CO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsbUJBQW1CO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQSxhQUFhLFFBQVEsV0FBVztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7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O0FBQ0EsVUFBVTtBQUNWO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQSw2REFBNkQsbUJBQW1COztBQUVoRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sbUJBQW1CO0FBQzFCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0Esc0VBQXNFLGFBQWE7QUFDbkY7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7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QSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBLFlBQVksVUFBVTtBQUN0QjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksU0FBUztBQUNyQjtBQUNBO0FBQ0EsWUFBWSxVQUFVO0FBQ3RCO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQix1QkFBdUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUssSUFBSTtBQUNUOztBQUVBO0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRSxhQUFhO0FBQ25GO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBLGFBQWEseUJBQXlCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0Isd0JBQXdCO0FBQzlDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0IsdUJBQXVCO0FBQzdDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLHNCQUFzQiw2Q0FBNkM7QUFDbkU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0IsdUJBQXVCO0FBQy9DOztBQUVBLDBCQUEwQixxQkFBcUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSOztBQUVBO0FBQ0E7QUFDQSx3Q0FBd0M7O0FBRXhDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLDBCQUEwQjtBQUM5QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlDQUF5QyxxQkFBcUI7QUFDOUQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDJDQUEyQyxvQkFBb0I7QUFDL0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FB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O0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLG1CQUFtQjtBQUNwRjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBOztB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Q0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLDZEQUE2RCxXQUFXO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSwwREFBMEQsV0FBVztBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsNERBQTRELFdBQVc7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLDREQUE0RCxXQUFXO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLDREQUE0RCxXQUFXO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSw0REFBNEQsV0FBVztBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsK0RBQStELFdBQVc7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLCtEQUErRCxXQUFXO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSwyREFBMkQsV0FBVztBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsaUVBQWlFLFdBQVc7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLG9FQUFvRSxXQUFXO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDLGlFQUFpRTtBQUNqRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0EsYUFBYSx5QkFBeUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIsb0JBQW9COztBQUV6QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxvQkFBb0Isa0JBQWtCO0FBQ3RDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBLDZEQUE2RCxpQ0FBaUMsbUNBQW1DLFNBQVMsc0NBQXNDLHNEQUFzRCxTQUFTO0FBQy9POztBQUVBO0FBQ0EsMENBQTBDLFlBQVk7QUFDdEQ7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpREFBaUQsV0FBVztBQUM1RDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSx3Q0FBd0MsV0FBVztBQUNuRDtBQUNBO0FBQ0E7QUFDQSxhQUFhLEdBQUc7QUFDaEI7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnRUFBZ0UsV0FBVztBQUMzRSxpQ0FBaUMsd0JBQXdCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7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Y0FBYztBQUNkO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGVBQWU7QUFDNUI7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOzs7QUFHQTtB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RUE7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDBCQUEwQjtBQUN4QztBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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Q3RCO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7O0FBRUE7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7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QTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktdjAtcHJvamVjdC8uL25vZGVfbW9kdWxlcy92aWRlb2pzLWNvbnRyaWItbWVkaWEtc291cmNlcy9ub2RlX21vZHVsZXMvdmlkZW8uanMvZGlzdC92aWRlby5janMuanM/OTYwZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBWaWRlby5qcyA2LjEzLjAgPGh0dHA6Ly92aWRlb2pzLmNvbS8+XG4gKiBDb3B5cmlnaHQgQnJpZ2h0Y292ZSwgSW5jLiA8aHR0cHM6Ly93d3cuYnJpZ2h0Y292ZS5jb20vPlxuICogQXZhaWxhYmxlIHVuZGVyIEFwYWNoZSBMaWNlbnNlIFZlcnNpb24gMi4wXG4gKiA8aHR0cHM6Ly9naXRodWIuY29tL3ZpZGVvanMvdmlkZW8uanMvYmxvYi9tYXN0ZXIvTElDRU5TRT5cbiAqXG4gKiBJbmNsdWRlcyB2dHQuanMgPGh0dHBzOi8vZ2l0aHViLmNvbS9tb3ppbGxhL3Z0dC5qcz5cbiAqIEF2YWlsYWJsZSB1bmRlciBBcGFjaGUgTGljZW5zZSBWZXJzaW9uIDIuMFxuICogPGh0dHBzOi8vZ2l0aHViLmNvbS9tb3ppbGxhL3Z0dC5qcy9ibG9iL21hc3Rlci9MSUNFTlNFPlxuICovXG5cbmZ1bmN0aW9uIF9pbnRlcm9wRGVmYXVsdCAoZXgpIHsgcmV0dXJuIChleCAmJiAodHlwZW9mIGV4ID09PSAnb2JqZWN0JykgJiYgJ2RlZmF1bHQnIGluIGV4KSA/IGV4WydkZWZhdWx0J10gOiBleDsgfVxuXG52YXIgd2luZG93ID0gX2ludGVyb3BEZWZhdWx0KHJlcXVpcmUoJ2dsb2JhbC93aW5kb3cnKSk7XG52YXIgZG9jdW1lbnQgPSBfaW50ZXJvcERlZmF1bHQocmVxdWlyZSgnZ2xvYmFsL2RvY3VtZW50JykpO1xudmFyIHRzbWwgPSBfaW50ZXJvcERlZmF1bHQocmVxdWlyZSgndHNtbCcpKTtcbnZhciBzYWZlUGFyc2VUdXBsZSA9IF9pbnRlcm9wRGVmYXVsdChyZXF1aXJlKCdzYWZlLWpzb24tcGFyc2UvdHVwbGUnKSk7XG52YXIgeGhyID0gX2ludGVyb3BEZWZhdWx0KHJlcXVpcmUoJ3hocicpKTtcbnZhciB2dHQgPSBfaW50ZXJvcERlZmF1bHQocmVxdWlyZSgndmlkZW9qcy12dHQuanMnKSk7XG5cbnZhciB2ZXJzaW9uID0gXCI2LjEzLjBcIjtcblxuLyoqXG4gKiBAZmlsZSBicm93c2VyLmpzXG4gKiBAbW9kdWxlIGJyb3dzZXJcbiAqL1xudmFyIFVTRVJfQUdFTlQgPSB3aW5kb3cubmF2aWdhdG9yICYmIHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50IHx8ICcnO1xudmFyIHdlYmtpdFZlcnNpb25NYXAgPSAvQXBwbGVXZWJLaXRcXC8oW1xcZC5dKykvaS5leGVjKFVTRVJfQUdFTlQpO1xudmFyIGFwcGxlV2Via2l0VmVyc2lvbiA9IHdlYmtpdFZlcnNpb25NYXAgPyBwYXJzZUZsb2F0KHdlYmtpdFZlcnNpb25NYXAucG9wKCkpIDogbnVsbDtcblxuLypcbiAqIERldmljZSBpcyBhbiBpUGhvbmVcbiAqXG4gKiBAdHlwZSB7Qm9vbGVhbn1cbiAqIEBjb25zdGFudFxuICogQHByaXZhdGVcbiAqL1xudmFyIElTX0lQQUQgPSAvaVBhZC9pLnRlc3QoVVNFUl9BR0VOVCk7XG5cbi8vIFRoZSBGYWNlYm9vayBhcHAncyBVSVdlYlZpZXcgaWRlbnRpZmllcyBhcyBib3RoIGFuIGlQaG9uZSBhbmQgaVBhZCwgc29cbi8vIHRvIGlkZW50aWZ5IGlQaG9uZXMsIHdlIG5lZWQgdG8gZXhjbHVkZSBpUGFkcy5cbi8vIGh0dHA6Ly9hcnRzeS5naXRodWIuaW8vYmxvZy8yMDEyLzEwLzE4L3RoZS1wZXJpbHMtb2YtaW9zLXVzZXItYWdlbnQtc25pZmZpbmcvXG52YXIgSVNfSVBIT05FID0gL2lQaG9uZS9pLnRlc3QoVVNFUl9BR0VOVCkgJiYgIUlTX0lQQUQ7XG52YXIgSVNfSVBPRCA9IC9pUG9kL2kudGVzdChVU0VSX0FHRU5UKTtcbnZhciBJU19JT1MgPSBJU19JUEhPTkUgfHwgSVNfSVBBRCB8fCBJU19JUE9EO1xuXG52YXIgSU9TX1ZFUlNJT04gPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBtYXRjaCA9IFVTRVJfQUdFTlQubWF0Y2goL09TIChcXGQrKV8vaSk7XG5cbiAgaWYgKG1hdGNoICYmIG1hdGNoWzFdKSB7XG4gICAgcmV0dXJuIG1hdGNoWzFdO1xuICB9XG4gIHJldHVybiBudWxsO1xufSgpO1xuXG52YXIgSVNfQU5EUk9JRCA9IC9BbmRyb2lkL2kudGVzdChVU0VSX0FHRU5UKTtcbnZhciBBTkRST0lEX1ZFUlNJT04gPSBmdW5jdGlvbiAoKSB7XG4gIC8vIFRoaXMgbWF0Y2hlcyBBbmRyb2lkIE1ham9yLk1pbm9yLlBhdGNoIHZlcnNpb25zXG4gIC8vIEFORFJPSURfVkVSU0lPTiBpcyBNYWpvci5NaW5vciBhcyBhIE51bWJlciwgaWYgTWlub3IgaXNuJ3QgYXZhaWxhYmxlLCB0aGVuIG9ubHkgTWFqb3IgaXMgcmV0dXJuZWRcbiAgdmFyIG1hdGNoID0gVVNFUl9BR0VOVC5tYXRjaCgvQW5kcm9pZCAoXFxkKykoPzpcXC4oXFxkKykpPyg/OlxcLihcXGQrKSkqL2kpO1xuXG4gIGlmICghbWF0Y2gpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBtYWpvciA9IG1hdGNoWzFdICYmIHBhcnNlRmxvYXQobWF0Y2hbMV0pO1xuICB2YXIgbWlub3IgPSBtYXRjaFsyXSAmJiBwYXJzZUZsb2F0KG1hdGNoWzJdKTtcblxuICBpZiAobWFqb3IgJiYgbWlub3IpIHtcbiAgICByZXR1cm4gcGFyc2VGbG9hdChtYXRjaFsxXSArICcuJyArIG1hdGNoWzJdKTtcbiAgfSBlbHNlIGlmIChtYWpvcikge1xuICAgIHJldHVybiBtYWpvcjtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn0oKTtcblxuLy8gT2xkIEFuZHJvaWQgaXMgZGVmaW5lZCBhcyBWZXJzaW9uIG9sZGVyIHRoYW4gMi4zLCBhbmQgcmVxdWlyaW5nIGEgd2Via2l0IHZlcnNpb24gb2YgdGhlIGFuZHJvaWQgYnJvd3NlclxudmFyIElTX09MRF9BTkRST0lEID0gSVNfQU5EUk9JRCAmJiAvd2Via2l0L2kudGVzdChVU0VSX0FHRU5UKSAmJiBBTkRST0lEX1ZFUlNJT04gPCAyLjM7XG52YXIgSVNfTkFUSVZFX0FORFJPSUQgPSBJU19BTkRST0lEICYmIEFORFJPSURfVkVSU0lPTiA8IDUgJiYgYXBwbGVXZWJraXRWZXJzaW9uIDwgNTM3O1xuXG52YXIgSVNfRklSRUZPWCA9IC9GaXJlZm94L2kudGVzdChVU0VSX0FHRU5UKTtcbnZhciBJU19FREdFID0gL0VkZ2UvaS50ZXN0KFVTRVJfQUdFTlQpO1xudmFyIElTX0NIUk9NRSA9ICFJU19FREdFICYmICgvQ2hyb21lL2kudGVzdChVU0VSX0FHRU5UKSB8fCAvQ3JpT1MvaS50ZXN0KFVTRVJfQUdFTlQpKTtcbnZhciBDSFJPTUVfVkVSU0lPTiA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIG1hdGNoID0gVVNFUl9BR0VOVC5tYXRjaCgvKENocm9tZXxDcmlPUylcXC8oXFxkKykvKTtcblxuICBpZiAobWF0Y2ggJiYgbWF0Y2hbMl0pIHtcbiAgICByZXR1cm4gcGFyc2VGbG9hdChtYXRjaFsyXSk7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59KCk7XG52YXIgSVNfSUU4ID0gL01TSUVcXHM4XFwuMC8udGVzdChVU0VSX0FHRU5UKTtcbnZhciBJRV9WRVJTSU9OID0gZnVuY3Rpb24gKCkge1xuICB2YXIgcmVzdWx0ID0gL01TSUVcXHMoXFxkKylcXC5cXGQvLmV4ZWMoVVNFUl9BR0VOVCk7XG4gIHZhciB2ZXJzaW9uID0gcmVzdWx0ICYmIHBhcnNlRmxvYXQocmVzdWx0WzFdKTtcblxuICBpZiAoIXZlcnNpb24gJiYgL1RyaWRlbnRcXC83LjAvaS50ZXN0KFVTRVJfQUdFTlQpICYmIC9ydjoxMS4wLy50ZXN0KFVTRVJfQUdFTlQpKSB7XG4gICAgLy8gSUUgMTEgaGFzIGEgZGlmZmVyZW50IHVzZXIgYWdlbnQgc3RyaW5nIHRoYW4gb3RoZXIgSUUgdmVyc2lvbnNcbiAgICB2ZXJzaW9uID0gMTEuMDtcbiAgfVxuXG4gIHJldHVybiB2ZXJzaW9uO1xufSgpO1xuXG52YXIgSVNfU0FGQVJJID0gL1NhZmFyaS9pLnRlc3QoVVNFUl9BR0VOVCkgJiYgIUlTX0NIUk9NRSAmJiAhSVNfQU5EUk9JRCAmJiAhSVNfRURHRTtcbnZhciBJU19BTllfU0FGQVJJID0gKElTX1NBRkFSSSB8fCBJU19JT1MpICYmICFJU19DSFJPTUU7XG5cbnZhciBUT1VDSF9FTkFCTEVEID0gaXNSZWFsKCkgJiYgKCdvbnRvdWNoc3RhcnQnIGluIHdpbmRvdyB8fCB3aW5kb3cubmF2aWdhdG9yLm1heFRvdWNoUG9pbnRzIHx8IHdpbmRvdy5Eb2N1bWVudFRvdWNoICYmIHdpbmRvdy5kb2N1bWVudCBpbnN0YW5jZW9mIHdpbmRvdy5Eb2N1bWVudFRvdWNoKTtcblxudmFyIEJBQ0tHUk9VTkRfU0laRV9TVVBQT1JURUQgPSBpc1JlYWwoKSAmJiAnYmFja2dyb3VuZFNpemUnIGluIHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCd2aWRlbycpLnN0eWxlO1xuXG52YXIgYnJvd3NlciA9IChPYmplY3QuZnJlZXplIHx8IE9iamVjdCkoe1xuXHRJU19JUEFEOiBJU19JUEFELFxuXHRJU19JUEhPTkU6IElTX0lQSE9ORSxcblx0SVNfSVBPRDogSVNfSVBPRCxcblx0SVNfSU9TOiBJU19JT1MsXG5cdElPU19WRVJTSU9OOiBJT1NfVkVSU0lPTixcblx0SVNfQU5EUk9JRDogSVNfQU5EUk9JRCxcblx0QU5EUk9JRF9WRVJTSU9OOiBBTkRST0lEX1ZFUlNJT04sXG5cdElTX09MRF9BTkRST0lEOiBJU19PTERfQU5EUk9JRCxcblx0SVNfTkFUSVZFX0FORFJPSUQ6IElTX05BVElWRV9BTkRST0lELFxuXHRJU19GSVJFRk9YOiBJU19GSVJFRk9YLFxuXHRJU19FREdFOiBJU19FREdFLFxuXHRJU19DSFJPTUU6IElTX0NIUk9NRSxcblx0Q0hST01FX1ZFUlNJT046IENIUk9NRV9WRVJTSU9OLFxuXHRJU19JRTg6IElTX0lFOCxcblx0SUVfVkVSU0lPTjogSUVfVkVSU0lPTixcblx0SVNfU0FGQVJJOiBJU19TQUZBUkksXG5cdElTX0FOWV9TQUZBUkk6IElTX0FOWV9TQUZBUkksXG5cdFRPVUNIX0VOQUJMRUQ6IFRPVUNIX0VOQUJMRUQsXG5cdEJBQ0tHUk9VTkRfU0laRV9TVVBQT1JURUQ6IEJBQ0tHUk9VTkRfU0laRV9TVVBQT1JURURcbn0pO1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gdHlwZW9mIG9iajtcbn0gOiBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xufTtcblxuXG5cblxuXG5cblxuXG5cblxuXG52YXIgY2xhc3NDYWxsQ2hlY2sgPSBmdW5jdGlvbiAoaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufTtcblxuXG5cblxuXG5cblxuXG5cblxuXG52YXIgaW5oZXJpdHMgPSBmdW5jdGlvbiAoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpO1xuICB9XG5cbiAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgY29uc3RydWN0b3I6IHtcbiAgICAgIHZhbHVlOiBzdWJDbGFzcyxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9XG4gIH0pO1xuICBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7XG59O1xuXG5cblxuXG5cblxuXG5cblxuXG5cbnZhciBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuID0gZnVuY3Rpb24gKHNlbGYsIGNhbGwpIHtcbiAgaWYgKCFzZWxmKSB7XG4gICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICB9XG5cbiAgcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7XG59O1xuXG5cblxuXG5cblxuXG5cblxuXG5cbnZhciB0YWdnZWRUZW1wbGF0ZUxpdGVyYWxMb29zZSA9IGZ1bmN0aW9uIChzdHJpbmdzLCByYXcpIHtcbiAgc3RyaW5ncy5yYXcgPSByYXc7XG4gIHJldHVybiBzdHJpbmdzO1xufTtcblxuLyoqXG4gKiBAZmlsZSBvYmouanNcbiAqIEBtb2R1bGUgb2JqXG4gKi9cblxuLyoqXG4gKiBAY2FsbGJhY2sgb2JqOkVhY2hDYWxsYmFja1xuICpcbiAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gKiAgICAgICAgVGhlIGN1cnJlbnQga2V5IGZvciB0aGUgb2JqZWN0IHRoYXQgaXMgYmVpbmcgaXRlcmF0ZWQgb3Zlci5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gKiAgICAgICAgVGhlIGN1cnJlbnQga2V5LXZhbHVlIGZvciBvYmplY3QgdGhhdCBpcyBiZWluZyBpdGVyYXRlZCBvdmVyXG4gKi9cblxuLyoqXG4gKiBAY2FsbGJhY2sgb2JqOlJlZHVjZUNhbGxiYWNrXG4gKlxuICogQHBhcmFtIHtNaXhlZH0gYWNjdW1cbiAqICAgICAgICBUaGUgdmFsdWUgdGhhdCBpcyBhY2N1bXVsYXRpbmcgb3ZlciB0aGUgcmVkdWNlIGxvb3AuXG4gKlxuICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAqICAgICAgICBUaGUgY3VycmVudCBrZXkgZm9yIHRoZSBvYmplY3QgdGhhdCBpcyBiZWluZyBpdGVyYXRlZCBvdmVyLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAqICAgICAgICBUaGUgY3VycmVudCBrZXktdmFsdWUgZm9yIG9iamVjdCB0aGF0IGlzIGJlaW5nIGl0ZXJhdGVkIG92ZXJcbiAqXG4gKiBAcmV0dXJuIHtNaXhlZH1cbiAqICAgICAgICAgVGhlIG5ldyBhY2N1bXVsYXRlZCB2YWx1ZS5cbiAqL1xudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuLyoqXG4gKiBHZXQgdGhlIGtleXMgb2YgYW4gT2JqZWN0XG4gKlxuICogQHBhcmFtIHtPYmplY3R9XG4gKiAgICAgICAgVGhlIE9iamVjdCB0byBnZXQgdGhlIGtleXMgZnJvbVxuICpcbiAqIEByZXR1cm4ge3N0cmluZ1tdfVxuICogICAgICAgICBBbiBhcnJheSBvZiB0aGUga2V5cyBmcm9tIHRoZSBvYmplY3QuIFJldHVybnMgYW4gZW1wdHkgYXJyYXkgaWYgdGhlXG4gKiAgICAgICAgIG9iamVjdCBwYXNzZWQgaW4gd2FzIGludmFsaWQgb3IgaGFkIG5vIGtleXMuXG4gKlxuICogQHByaXZhdGVcbiAqL1xudmFyIGtleXMgPSBmdW5jdGlvbiBrZXlzKG9iamVjdCkge1xuICByZXR1cm4gaXNPYmplY3Qob2JqZWN0KSA/IE9iamVjdC5rZXlzKG9iamVjdCkgOiBbXTtcbn07XG5cbi8qKlxuICogQXJyYXktbGlrZSBpdGVyYXRpb24gZm9yIG9iamVjdHMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICogICAgICAgIFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyXG4gKlxuICogQHBhcmFtIHtvYmo6RWFjaENhbGxiYWNrfSBmblxuICogICAgICAgIFRoZSBjYWxsYmFjayBmdW5jdGlvbiB3aGljaCBpcyBjYWxsZWQgZm9yIGVhY2gga2V5IGluIHRoZSBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGVhY2gob2JqZWN0LCBmbikge1xuICBrZXlzKG9iamVjdCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIGZuKG9iamVjdFtrZXldLCBrZXkpO1xuICB9KTtcbn1cblxuLyoqXG4gKiBBcnJheS1saWtlIHJlZHVjZSBmb3Igb2JqZWN0cy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gKiAgICAgICAgVGhlIE9iamVjdCB0aGF0IHlvdSB3YW50IHRvIHJlZHVjZS5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogICAgICAgICBBIGNhbGxiYWNrIGZ1bmN0aW9uIHdoaWNoIGlzIGNhbGxlZCBmb3IgZWFjaCBrZXkgaW4gdGhlIG9iamVjdC4gSXRcbiAqICAgICAgICAgcmVjZWl2ZXMgdGhlIGFjY3VtdWxhdGVkIHZhbHVlIGFuZCB0aGUgcGVyLWl0ZXJhdGlvbiB2YWx1ZSBhbmQga2V5XG4gKiAgICAgICAgIGFzIGFyZ3VtZW50cy5cbiAqXG4gKiBAcGFyYW0ge01peGVkfSBbaW5pdGlhbCA9IDBdXG4gKiAgICAgICAgU3RhcnRpbmcgdmFsdWVcbiAqXG4gKiBAcmV0dXJuIHtNaXhlZH1cbiAqICAgICAgICAgVGhlIGZpbmFsIGFjY3VtdWxhdGVkIHZhbHVlLlxuICovXG5mdW5jdGlvbiByZWR1Y2Uob2JqZWN0LCBmbikge1xuICB2YXIgaW5pdGlhbCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogMDtcblxuICByZXR1cm4ga2V5cyhvYmplY3QpLnJlZHVjZShmdW5jdGlvbiAoYWNjdW0sIGtleSkge1xuICAgIHJldHVybiBmbihhY2N1bSwgb2JqZWN0W2tleV0sIGtleSk7XG4gIH0sIGluaXRpYWwpO1xufVxuXG4vKipcbiAqIE9iamVjdC5hc3NpZ24tc3R5bGUgb2JqZWN0IHNoYWxsb3cgbWVyZ2UvZXh0ZW5kLlxuICpcbiAqIEBwYXJhbSAge09iamVjdH0gdGFyZ2V0XG4gKiBAcGFyYW0gIHtPYmplY3R9IC4uLnNvdXJjZXNcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuZnVuY3Rpb24gYXNzaWduKHRhcmdldCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgc291cmNlcyA9IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBzb3VyY2VzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIGlmIChPYmplY3QuYXNzaWduKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24uYXBwbHkoT2JqZWN0LCBbdGFyZ2V0XS5jb25jYXQoc291cmNlcykpO1xuICB9XG5cbiAgc291cmNlcy5mb3JFYWNoKGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICBpZiAoIXNvdXJjZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGVhY2goc291cmNlLCBmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgICAgdGFyZ2V0W2tleV0gPSB2YWx1ZTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgYSB2YWx1ZSBpcyBhbiBvYmplY3Qgb2YgYW55IGtpbmQgLSBpbmNsdWRpbmcgRE9NIG5vZGVzLFxuICogYXJyYXlzLCByZWd1bGFyIGV4cHJlc3Npb25zLCBldGMuIE5vdCBmdW5jdGlvbnMsIHRob3VnaC5cbiAqXG4gKiBUaGlzIGF2b2lkcyB0aGUgZ290Y2hhIHdoZXJlIHVzaW5nIGB0eXBlb2ZgIG9uIGEgYG51bGxgIHZhbHVlXG4gKiByZXN1bHRzIGluIGAnb2JqZWN0J2AuXG4gKlxuICogQHBhcmFtICB7T2JqZWN0fSB2YWx1ZVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuICEhdmFsdWUgJiYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YodmFsdWUpKSA9PT0gJ29iamVjdCc7XG59XG5cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIGFuIG9iamVjdCBhcHBlYXJzIHRvIGJlIGEgXCJwbGFpblwiIG9iamVjdCAtIHRoYXQgaXMsIGFcbiAqIGRpcmVjdCBpbnN0YW5jZSBvZiBgT2JqZWN0YC5cbiAqXG4gKiBAcGFyYW0gIHtPYmplY3R9IHZhbHVlXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5mdW5jdGlvbiBpc1BsYWluKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdCh2YWx1ZSkgJiYgdG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IE9iamVjdF0nICYmIHZhbHVlLmNvbnN0cnVjdG9yID09PSBPYmplY3Q7XG59XG5cbi8qKlxuICogQGZpbGUgY3JlYXRlLWxvZ2dlci5qc1xuICogQG1vZHVsZSBjcmVhdGUtbG9nZ2VyXG4gKi9cbi8vIFRoaXMgaXMgdGhlIHByaXZhdGUgdHJhY2tpbmcgdmFyaWFibGUgZm9yIHRoZSBsb2dnaW5nIGhpc3RvcnkuXG52YXIgaGlzdG9yeSA9IFtdO1xuXG4vKipcbiAqIExvZyBtZXNzYWdlcyB0byB0aGUgY29uc29sZSBhbmQgaGlzdG9yeSBiYXNlZCBvbiB0aGUgdHlwZSBvZiBtZXNzYWdlXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSAge3N0cmluZ30gdHlwZVxuICogICAgICAgICBUaGUgbmFtZSBvZiB0aGUgY29uc29sZSBtZXRob2QgdG8gdXNlLlxuICpcbiAqIEBwYXJhbSAge0FycmF5fSBhcmdzXG4gKiAgICAgICAgIFRoZSBhcmd1bWVudHMgdG8gYmUgcGFzc2VkIHRvIHRoZSBtYXRjaGluZyBjb25zb2xlIG1ldGhvZC5cbiAqL1xudmFyIExvZ0J5VHlwZUZhY3RvcnkgPSBmdW5jdGlvbiBMb2dCeVR5cGVGYWN0b3J5KG5hbWUsIGxvZykge1xuICByZXR1cm4gZnVuY3Rpb24gKHR5cGUsIGxldmVsLCBhcmdzLCBzdHJpbmdpZnkpIHtcbiAgICB2YXIgbHZsID0gbG9nLmxldmVsc1tsZXZlbF07XG4gICAgdmFyIGx2bFJlZ0V4cCA9IG5ldyBSZWdFeHAoJ14oJyArIGx2bCArICcpJCcpO1xuXG4gICAgaWYgKHR5cGUgIT09ICdsb2cnKSB7XG5cbiAgICAgIC8vIEFkZCB0aGUgdHlwZSB0byB0aGUgZnJvbnQgb2YgdGhlIG1lc3NhZ2Ugd2hlbiBpdCdzIG5vdCBcImxvZ1wiLlxuICAgICAgYXJncy51bnNoaWZ0KHR5cGUudG9VcHBlckNhc2UoKSArICc6Jyk7XG4gICAgfVxuXG4gICAgLy8gQWRkIGNvbnNvbGUgcHJlZml4IGFmdGVyIGFkZGluZyB0byBoaXN0b3J5LlxuICAgIGFyZ3MudW5zaGlmdChuYW1lICsgJzonKTtcblxuICAgIC8vIEFkZCBhIGNsb25lIG9mIHRoZSBhcmdzIGF0IHRoaXMgcG9pbnQgdG8gaGlzdG9yeS5cbiAgICBpZiAoaGlzdG9yeSkge1xuICAgICAgaGlzdG9yeS5wdXNoKFtdLmNvbmNhdChhcmdzKSk7XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlcmUncyBubyBjb25zb2xlIHRoZW4gZG9uJ3QgdHJ5IHRvIG91dHB1dCBtZXNzYWdlcywgYnV0IHRoZXkgd2lsbFxuICAgIC8vIHN0aWxsIGJlIHN0b3JlZCBpbiBoaXN0b3J5LlxuICAgIGlmICghd2luZG93LmNvbnNvbGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBXYXMgc2V0dGluZyB0aGVzZSBvbmNlIG91dHNpZGUgb2YgdGhpcyBmdW5jdGlvbiwgYnV0IGNvbnRhaW5pbmcgdGhlbVxuICAgIC8vIGluIHRoZSBmdW5jdGlvbiBtYWtlcyBpdCBlYXNpZXIgdG8gdGVzdCBjYXNlcyB3aGVyZSBjb25zb2xlIGRvZXNuJ3QgZXhpc3RcbiAgICAvLyB3aGVuIHRoZSBtb2R1bGUgaXMgZXhlY3V0ZWQuXG4gICAgdmFyIGZuID0gd2luZG93LmNvbnNvbGVbdHlwZV07XG5cbiAgICBpZiAoIWZuICYmIHR5cGUgPT09ICdkZWJ1ZycpIHtcbiAgICAgIC8vIENlcnRhaW4gYnJvd3NlcnMgZG9uJ3QgaGF2ZSBzdXBwb3J0IGZvciBjb25zb2xlLmRlYnVnLiBGb3IgdGhvc2UsIHdlXG4gICAgICAvLyBzaG91bGQgZGVmYXVsdCB0byB0aGUgY2xvc2VzdCBjb21wYXJhYmxlIGxvZy5cbiAgICAgIGZuID0gd2luZG93LmNvbnNvbGUuaW5mbyB8fCB3aW5kb3cuY29uc29sZS5sb2c7XG4gICAgfVxuXG4gICAgLy8gQmFpbCBvdXQgaWYgdGhlcmUncyBubyBjb25zb2xlIG9yIGlmIHRoaXMgdHlwZSBpcyBub3QgYWxsb3dlZCBieSB0aGVcbiAgICAvLyBjdXJyZW50IGxvZ2dpbmcgbGV2ZWwuXG4gICAgaWYgKCFmbiB8fCAhbHZsIHx8ICFsdmxSZWdFeHAudGVzdCh0eXBlKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIElFcyBwcmV2aW91cyB0byAxMSBsb2cgb2JqZWN0cyB1c2VsZXNzbHkgYXMgXCJbb2JqZWN0IE9iamVjdF1cIjsgc28sIEpTT05pZnlcbiAgICAvLyBvYmplY3RzIGFuZCBhcnJheXMgZm9yIHRob3NlIGxlc3MtY2FwYWJsZSBicm93c2Vycy5cbiAgICBpZiAoc3RyaW5naWZ5KSB7XG4gICAgICBhcmdzID0gYXJncy5tYXAoZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgaWYgKGlzT2JqZWN0KGEpIHx8IEFycmF5LmlzQXJyYXkoYSkpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGEpO1xuICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgIHJldHVybiBTdHJpbmcoYSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2FzdCB0byBzdHJpbmcgYmVmb3JlIGpvaW5pbmcsIHNvIHdlIGdldCBudWxsIGFuZCB1bmRlZmluZWQgZXhwbGljaXRseVxuICAgICAgICAvLyBpbmNsdWRlZCBpbiBvdXRwdXQgKGFzIHdlIHdvdWxkIGluIGEgbW9kZXJuIGNvbnNvbGUpLlxuICAgICAgICByZXR1cm4gU3RyaW5nKGEpO1xuICAgICAgfSkuam9pbignICcpO1xuICAgIH1cblxuICAgIC8vIE9sZCBJRSB2ZXJzaW9ucyBkbyBub3QgYWxsb3cgLmFwcGx5KCkgZm9yIGNvbnNvbGUgbWV0aG9kcyAodGhleSBhcmVcbiAgICAvLyByZXBvcnRlZCBhcyBvYmplY3RzIHJhdGhlciB0aGFuIGZ1bmN0aW9ucykuXG4gICAgaWYgKCFmbi5hcHBseSkge1xuICAgICAgZm4oYXJncyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZuW0FycmF5LmlzQXJyYXkoYXJncykgPyAnYXBwbHknIDogJ2NhbGwnXSh3aW5kb3cuY29uc29sZSwgYXJncyk7XG4gICAgfVxuICB9O1xufTtcblxuZnVuY3Rpb24gY3JlYXRlTG9nZ2VyJDEobmFtZSkge1xuICAvLyBUaGlzIGlzIHRoZSBwcml2YXRlIHRyYWNraW5nIHZhcmlhYmxlIGZvciBsb2dnaW5nIGxldmVsLlxuICB2YXIgbGV2ZWwgPSAnaW5mbyc7XG5cbiAgLy8gdGhlIGN1cnJpZWQgbG9nQnlUeXBlIGJvdW5kIHRvIHRoZSBzcGVjaWZpYyBsb2cgYW5kIGhpc3RvcnlcbiAgdmFyIGxvZ0J5VHlwZSA9IHZvaWQgMDtcblxuICAvKipcbiAgICogTG9ncyBwbGFpbiBkZWJ1ZyBtZXNzYWdlcy4gU2ltaWxhciB0byBgY29uc29sZS5sb2dgLlxuICAgKlxuICAgKiBEdWUgdG8gW2xpbWl0YXRpb25zXShodHRwczovL2dpdGh1Yi5jb20vanNkb2MzL2pzZG9jL2lzc3Vlcy85NTUjaXNzdWVjb21tZW50LTMxMzgyOTE0OSlcbiAgICogb2Ygb3VyIEpTRG9jIHRlbXBsYXRlLCB3ZSBjYW5ub3QgcHJvcGVybHkgZG9jdW1lbnQgdGhpcyBhcyBib3RoIGEgZnVuY3Rpb25cbiAgICogYW5kIGEgbmFtZXNwYWNlLCBzbyBpdHMgZnVuY3Rpb24gc2lnbmF0dXJlIGlzIGRvY3VtZW50ZWQgaGVyZS5cbiAgICpcbiAgICogIyMjIyBBcmd1bWVudHNcbiAgICogIyMjIyMgKmFyZ3NcbiAgICogTWl4ZWRbXVxuICAgKlxuICAgKiBBbnkgY29tYmluYXRpb24gb2YgdmFsdWVzIHRoYXQgY291bGQgYmUgcGFzc2VkIHRvIGBjb25zb2xlLmxvZygpYC5cbiAgICpcbiAgICogIyMjIyBSZXR1cm4gVmFsdWVcbiAgICpcbiAgICogYHVuZGVmaW5lZGBcbiAgICpcbiAgICogQG5hbWVzcGFjZVxuICAgKiBAcGFyYW0gICAge01peGVkW119IGFyZ3NcbiAgICogICAgICAgICAgIE9uZSBvciBtb3JlIG1lc3NhZ2VzIG9yIG9iamVjdHMgdGhhdCBzaG91bGQgYmUgbG9nZ2VkLlxuICAgKi9cbiAgdmFyIGxvZyA9IGZ1bmN0aW9uIGxvZygpIHtcbiAgICB2YXIgc3RyaW5naWZ5ID0gbG9nLnN0cmluZ2lmeSB8fCBJRV9WRVJTSU9OICYmIElFX1ZFUlNJT04gPCAxMTtcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIGxvZ0J5VHlwZSgnbG9nJywgbGV2ZWwsIGFyZ3MsIHN0cmluZ2lmeSk7XG4gIH07XG5cbiAgLy8gVGhpcyBpcyB0aGUgbG9nQnlUeXBlIGhlbHBlciB0aGF0IHRoZSBsb2dnaW5nIG1ldGhvZHMgYmVsb3cgdXNlXG4gIGxvZ0J5VHlwZSA9IExvZ0J5VHlwZUZhY3RvcnkobmFtZSwgbG9nKTtcblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IHN1YmxvZ2dlciB3aGljaCBjaGFpbnMgdGhlIG9sZCBuYW1lIHRvIHRoZSBuZXcgbmFtZS5cbiAgICpcbiAgICogRm9yIGV4YW1wbGUsIGRvaW5nIGB2aWRlb2pzLmxvZy5jcmVhdGVMb2dnZXIoJ3BsYXllcicpYCBhbmQgdGhlbiB1c2luZyB0aGF0IGxvZ2dlciB3aWxsIGxvZyB0aGUgZm9sbG93aW5nOlxuICAgKiBgYGBqc1xuICAgKiAgbXlsb2dnZXIoJ2ZvbycpO1xuICAgKiAgLy8gPiBWSURFT0pTOiBwbGF5ZXI6IGZvb1xuICAgKiBgYGBcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICogICAgICAgIFRoZSBuYW1lIHRvIGFkZCBjYWxsIHRoZSBuZXcgbG9nZ2VyXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG4gIGxvZy5jcmVhdGVMb2dnZXIgPSBmdW5jdGlvbiAoc3VibmFtZSkge1xuICAgIHJldHVybiBjcmVhdGVMb2dnZXIkMShuYW1lICsgJzogJyArIHN1Ym5hbWUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBFbnVtZXJhdGlvbiBvZiBhdmFpbGFibGUgbG9nZ2luZyBsZXZlbHMsIHdoZXJlIHRoZSBrZXlzIGFyZSB0aGUgbGV2ZWwgbmFtZXNcbiAgICogYW5kIHRoZSB2YWx1ZXMgYXJlIGB8YC1zZXBhcmF0ZWQgc3RyaW5ncyBjb250YWluaW5nIGxvZ2dpbmcgbWV0aG9kcyBhbGxvd2VkXG4gICAqIGluIHRoYXQgbG9nZ2luZyBsZXZlbC4gVGhlc2Ugc3RyaW5ncyBhcmUgdXNlZCB0byBjcmVhdGUgYSByZWd1bGFyIGV4cHJlc3Npb25cbiAgICogbWF0Y2hpbmcgdGhlIGZ1bmN0aW9uIG5hbWUgYmVpbmcgY2FsbGVkLlxuICAgKlxuICAgKiBMZXZlbHMgcHJvdmlkZWQgYnkgVmlkZW8uanMgYXJlOlxuICAgKlxuICAgKiAtIGBvZmZgOiBNYXRjaGVzIG5vIGNhbGxzLiBBbnkgdmFsdWUgdGhhdCBjYW4gYmUgY2FzdCB0byBgZmFsc2VgIHdpbGwgaGF2ZVxuICAgKiAgIHRoaXMgZWZmZWN0LiBUaGUgbW9zdCByZXN0cmljdGl2ZS5cbiAgICogLSBgYWxsYDogTWF0Y2hlcyBvbmx5IFZpZGVvLmpzLXByb3ZpZGVkIGZ1bmN0aW9ucyAoYGRlYnVnYCwgYGxvZ2AsXG4gICAqICAgYGxvZy53YXJuYCwgYW5kIGBsb2cuZXJyb3JgKS5cbiAgICogLSBgZGVidWdgOiBNYXRjaGVzIGBsb2cuZGVidWdgLCBgbG9nYCwgYGxvZy53YXJuYCwgYW5kIGBsb2cuZXJyb3JgIGNhbGxzLlxuICAgKiAtIGBpbmZvYCAoZGVmYXVsdCk6IE1hdGNoZXMgYGxvZ2AsIGBsb2cud2FybmAsIGFuZCBgbG9nLmVycm9yYCBjYWxscy5cbiAgICogLSBgd2FybmA6IE1hdGNoZXMgYGxvZy53YXJuYCBhbmQgYGxvZy5lcnJvcmAgY2FsbHMuXG4gICAqIC0gYGVycm9yYDogTWF0Y2hlcyBvbmx5IGBsb2cuZXJyb3JgIGNhbGxzLlxuICAgKlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgbG9nLmxldmVscyA9IHtcbiAgICBhbGw6ICdkZWJ1Z3xsb2d8d2FybnxlcnJvcicsXG4gICAgb2ZmOiAnJyxcbiAgICBkZWJ1ZzogJ2RlYnVnfGxvZ3x3YXJufGVycm9yJyxcbiAgICBpbmZvOiAnbG9nfHdhcm58ZXJyb3InLFxuICAgIHdhcm46ICd3YXJufGVycm9yJyxcbiAgICBlcnJvcjogJ2Vycm9yJyxcbiAgICBERUZBVUxUOiBsZXZlbFxuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgb3Igc2V0IHRoZSBjdXJyZW50IGxvZ2dpbmcgbGV2ZWwuXG4gICAqXG4gICAqIElmIGEgc3RyaW5nIG1hdGNoaW5nIGEga2V5IGZyb20ge0BsaW5rIG1vZHVsZTpsb2cubGV2ZWxzfSBpcyBwcm92aWRlZCwgYWN0c1xuICAgKiBhcyBhIHNldHRlci5cbiAgICpcbiAgICogQHBhcmFtICB7c3RyaW5nfSBbbHZsXVxuICAgKiAgICAgICAgIFBhc3MgYSB2YWxpZCBsZXZlbCB0byBzZXQgYSBuZXcgbG9nZ2luZyBsZXZlbC5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKiAgICAgICAgIFRoZSBjdXJyZW50IGxvZ2dpbmcgbGV2ZWwuXG4gICAqL1xuICBsb2cubGV2ZWwgPSBmdW5jdGlvbiAobHZsKSB7XG4gICAgaWYgKHR5cGVvZiBsdmwgPT09ICdzdHJpbmcnKSB7XG4gICAgICBpZiAoIWxvZy5sZXZlbHMuaGFzT3duUHJvcGVydHkobHZsKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiJyArIGx2bCArICdcIiBpbiBub3QgYSB2YWxpZCBsb2cgbGV2ZWwnKTtcbiAgICAgIH1cbiAgICAgIGxldmVsID0gbHZsO1xuICAgIH1cbiAgICByZXR1cm4gbGV2ZWw7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gYXJyYXkgY29udGFpbmluZyBldmVyeXRoaW5nIHRoYXQgaGFzIGJlZW4gbG9nZ2VkIHRvIHRoZSBoaXN0b3J5LlxuICAgKlxuICAgKiBUaGlzIGFycmF5IGlzIGEgc2hhbGxvdyBjbG9uZSBvZiB0aGUgaW50ZXJuYWwgaGlzdG9yeSByZWNvcmQuIEhvd2V2ZXIsIGl0c1xuICAgKiBjb250ZW50cyBhcmUgX25vdF8gY2xvbmVkOyBzbywgbXV0YXRpbmcgb2JqZWN0cyBpbnNpZGUgdGhpcyBhcnJheSB3aWxsXG4gICAqIG11dGF0ZSB0aGVtIGluIGhpc3RvcnkuXG4gICAqXG4gICAqIEByZXR1cm4ge0FycmF5fVxuICAgKi9cbiAgbG9nLmhpc3RvcnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGhpc3RvcnkgPyBbXS5jb25jYXQoaGlzdG9yeSkgOiBbXTtcbiAgfTtcblxuICAvKipcbiAgICogQWxsb3dzIHlvdSB0byBmaWx0ZXIgdGhlIGhpc3RvcnkgYnkgdGhlIGdpdmVuIGxvZ2dlciBuYW1lXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmbmFtZVxuICAgKiAgICAgICAgVGhlIG5hbWUgdG8gZmlsdGVyIGJ5XG4gICAqXG4gICAqIEByZXR1cm4ge0FycmF5fVxuICAgKiAgICAgICAgIFRoZSBmaWx0ZXJlZCBsaXN0IHRvIHJldHVyblxuICAgKi9cbiAgbG9nLmhpc3RvcnkuZmlsdGVyID0gZnVuY3Rpb24gKGZuYW1lKSB7XG4gICAgcmV0dXJuIChoaXN0b3J5IHx8IFtdKS5maWx0ZXIoZnVuY3Rpb24gKGhpc3RvcnlJdGVtKSB7XG4gICAgICAvLyBpZiB0aGUgZmlyc3QgaXRlbSBpbiBlYWNoIGhpc3RvcnlJdGVtIGluY2x1ZGVzIGBmbmFtZWAsIHRoZW4gaXQncyBhIG1hdGNoXG4gICAgICByZXR1cm4gbmV3IFJlZ0V4cCgnLionICsgZm5hbWUgKyAnLionKS50ZXN0KGhpc3RvcnlJdGVtWzBdKTtcbiAgICB9KTtcbiAgfTtcblxuICAvKipcbiAgICogQ2xlYXJzIHRoZSBpbnRlcm5hbCBoaXN0b3J5IHRyYWNraW5nLCBidXQgZG9lcyBub3QgcHJldmVudCBmdXJ0aGVyIGhpc3RvcnlcbiAgICogdHJhY2tpbmcuXG4gICAqL1xuICBsb2cuaGlzdG9yeS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoaGlzdG9yeSkge1xuICAgICAgaGlzdG9yeS5sZW5ndGggPSAwO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogRGlzYWJsZSBoaXN0b3J5IHRyYWNraW5nIGlmIGl0IGlzIGN1cnJlbnRseSBlbmFibGVkLlxuICAgKi9cbiAgbG9nLmhpc3RvcnkuZGlzYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoaGlzdG9yeSAhPT0gbnVsbCkge1xuICAgICAgaGlzdG9yeS5sZW5ndGggPSAwO1xuICAgICAgaGlzdG9yeSA9IG51bGw7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBFbmFibGUgaGlzdG9yeSB0cmFja2luZyBpZiBpdCBpcyBjdXJyZW50bHkgZGlzYWJsZWQuXG4gICAqL1xuICBsb2cuaGlzdG9yeS5lbmFibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGhpc3RvcnkgPT09IG51bGwpIHtcbiAgICAgIGhpc3RvcnkgPSBbXTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIExvZ3MgZXJyb3IgbWVzc2FnZXMuIFNpbWlsYXIgdG8gYGNvbnNvbGUuZXJyb3JgLlxuICAgKlxuICAgKiBAcGFyYW0ge01peGVkW119IGFyZ3NcbiAgICogICAgICAgIE9uZSBvciBtb3JlIG1lc3NhZ2VzIG9yIG9iamVjdHMgdGhhdCBzaG91bGQgYmUgbG9nZ2VkIGFzIGFuIGVycm9yXG4gICAqL1xuICBsb2cuZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbjIpLCBfa2V5MiA9IDA7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgIGFyZ3NbX2tleTJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICB9XG5cbiAgICByZXR1cm4gbG9nQnlUeXBlKCdlcnJvcicsIGxldmVsLCBhcmdzKTtcbiAgfTtcblxuICAvKipcbiAgICogTG9ncyB3YXJuaW5nIG1lc3NhZ2VzLiBTaW1pbGFyIHRvIGBjb25zb2xlLndhcm5gLlxuICAgKlxuICAgKiBAcGFyYW0ge01peGVkW119IGFyZ3NcbiAgICogICAgICAgIE9uZSBvciBtb3JlIG1lc3NhZ2VzIG9yIG9iamVjdHMgdGhhdCBzaG91bGQgYmUgbG9nZ2VkIGFzIGEgd2FybmluZy5cbiAgICovXG4gIGxvZy53YXJuID0gZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIF9sZW4zID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4zKSwgX2tleTMgPSAwOyBfa2V5MyA8IF9sZW4zOyBfa2V5MysrKSB7XG4gICAgICBhcmdzW19rZXkzXSA9IGFyZ3VtZW50c1tfa2V5M107XG4gICAgfVxuXG4gICAgcmV0dXJuIGxvZ0J5VHlwZSgnd2FybicsIGxldmVsLCBhcmdzKTtcbiAgfTtcblxuICAvKipcbiAgICogTG9ncyBkZWJ1ZyBtZXNzYWdlcy4gU2ltaWxhciB0byBgY29uc29sZS5kZWJ1Z2AsIGJ1dCBtYXkgYWxzbyBhY3QgYXMgYSBjb21wYXJhYmxlXG4gICAqIGxvZyBpZiBgY29uc29sZS5kZWJ1Z2AgaXMgbm90IGF2YWlsYWJsZVxuICAgKlxuICAgKiBAcGFyYW0ge01peGVkW119IGFyZ3NcbiAgICogICAgICAgIE9uZSBvciBtb3JlIG1lc3NhZ2VzIG9yIG9iamVjdHMgdGhhdCBzaG91bGQgYmUgbG9nZ2VkIGFzIGRlYnVnLlxuICAgKi9cbiAgbG9nLmRlYnVnID0gZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIF9sZW40ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW40KSwgX2tleTQgPSAwOyBfa2V5NCA8IF9sZW40OyBfa2V5NCsrKSB7XG4gICAgICBhcmdzW19rZXk0XSA9IGFyZ3VtZW50c1tfa2V5NF07XG4gICAgfVxuXG4gICAgcmV0dXJuIGxvZ0J5VHlwZSgnZGVidWcnLCBsZXZlbCwgYXJncyk7XG4gIH07XG5cbiAgcmV0dXJuIGxvZztcbn1cblxuLyoqXG4gKiBAZmlsZSBsb2cuanNcbiAqIEBtb2R1bGUgbG9nXG4gKi9cbnZhciBsb2cgPSBjcmVhdGVMb2dnZXIkMSgnVklERU9KUycpO1xudmFyIGNyZWF0ZUxvZ2dlciA9IGxvZy5jcmVhdGVMb2dnZXI7XG5cbi8qKlxuICogQGZpbGUgY29tcHV0ZWQtc3R5bGUuanNcbiAqIEBtb2R1bGUgY29tcHV0ZWQtc3R5bGVcbiAqL1xuLyoqXG4gKiBBIHNhZmUgZ2V0Q29tcHV0ZWRTdHlsZSB3aXRoIGFuIElFOCBmYWxsYmFjay5cbiAqXG4gKiBUaGlzIGlzIG5lZWRlZCBiZWNhdXNlIGluIEZpcmVmb3gsIGlmIHRoZSBwbGF5ZXIgaXMgbG9hZGVkIGluIGFuIGlmcmFtZSB3aXRoXG4gKiBgZGlzcGxheTpub25lYCwgdGhlbiBgZ2V0Q29tcHV0ZWRTdHlsZWAgcmV0dXJucyBgbnVsbGAsIHNvLCB3ZSBkbyBhIG51bGwtY2hlY2sgdG9cbiAqIG1ha2Ugc3VyZSAgdGhhdCB0aGUgcGxheWVyIGRvZXNuJ3QgYnJlYWsgaW4gdGhlc2UgY2FzZXMuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogICAgICAgIFRoZSBlbGVtZW50IHlvdSB3YW50IHRoZSBjb21wdXRlZCBzdHlsZSBvZlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wXG4gKiAgICAgICAgVGhlIHByb3BlcnR5IG5hbWUgeW91IHdhbnRcbiAqXG4gKiBAc2VlIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTU0ODM5N1xuICpcbiAqIEBzdGF0aWNcbiAqIEBjb25zdFxuICovXG5mdW5jdGlvbiBjb21wdXRlZFN0eWxlKGVsLCBwcm9wKSB7XG4gIGlmICghZWwgfHwgIXByb3ApIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBpZiAodHlwZW9mIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIGNzID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwpO1xuXG4gICAgcmV0dXJuIGNzID8gY3NbcHJvcF0gOiAnJztcbiAgfVxuXG4gIHJldHVybiBlbC5jdXJyZW50U3R5bGVbcHJvcF0gfHwgJyc7XG59XG5cbnZhciBfdGVtcGxhdGVPYmplY3QgPSB0YWdnZWRUZW1wbGF0ZUxpdGVyYWxMb29zZShbJ1NldHRpbmcgYXR0cmlidXRlcyBpbiB0aGUgc2Vjb25kIGFyZ3VtZW50IG9mIGNyZWF0ZUVsKClcXG4gICAgICAgICAgICAgICAgaGFzIGJlZW4gZGVwcmVjYXRlZC4gVXNlIHRoZSB0aGlyZCBhcmd1bWVudCBpbnN0ZWFkLlxcbiAgICAgICAgICAgICAgICBjcmVhdGVFbCh0eXBlLCBwcm9wZXJ0aWVzLCBhdHRyaWJ1dGVzKS4gQXR0ZW1wdGluZyB0byBzZXQgJywgJyB0byAnLCAnLiddLCBbJ1NldHRpbmcgYXR0cmlidXRlcyBpbiB0aGUgc2Vjb25kIGFyZ3VtZW50IG9mIGNyZWF0ZUVsKClcXG4gICAgICAgICAgICAgICAgaGFzIGJlZW4gZGVwcmVjYXRlZC4gVXNlIHRoZSB0aGlyZCBhcmd1bWVudCBpbnN0ZWFkLlxcbiAgICAgICAgICAgICAgICBjcmVhdGVFbCh0eXBlLCBwcm9wZXJ0aWVzLCBhdHRyaWJ1dGVzKS4gQXR0ZW1wdGluZyB0byBzZXQgJywgJyB0byAnLCAnLiddKTtcblxuLyoqXG4gKiBAZmlsZSBkb20uanNcbiAqIEBtb2R1bGUgZG9tXG4gKi9cbi8qKlxuICogRGV0ZWN0IGlmIGEgdmFsdWUgaXMgYSBzdHJpbmcgd2l0aCBhbnkgbm9uLXdoaXRlc3BhY2UgY2hhcmFjdGVycy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gKiAgICAgICAgVGhlIHN0cmluZyB0byBjaGVja1xuICpcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKiAgICAgICAgIC0gVHJ1ZSBpZiB0aGUgc3RyaW5nIGlzIG5vbi1ibGFua1xuICogICAgICAgICAtIEZhbHNlIG90aGVyd2lzZVxuICpcbiAqL1xuZnVuY3Rpb24gaXNOb25CbGFua1N0cmluZyhzdHIpIHtcbiAgcmV0dXJuIHR5cGVvZiBzdHIgPT09ICdzdHJpbmcnICYmIC9cXFMvLnRlc3Qoc3RyKTtcbn1cblxuLyoqXG4gKiBUaHJvd3MgYW4gZXJyb3IgaWYgdGhlIHBhc3NlZCBzdHJpbmcgaGFzIHdoaXRlc3BhY2UuIFRoaXMgaXMgdXNlZCBieVxuICogY2xhc3MgbWV0aG9kcyB0byBiZSByZWxhdGl2ZWx5IGNvbnNpc3RlbnQgd2l0aCB0aGUgY2xhc3NMaXN0IEFQSS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gKiAgICAgICAgIFRoZSBzdHJpbmcgdG8gY2hlY2sgZm9yIHdoaXRlc3BhY2UuXG4gKlxuICogQHRocm93cyB7RXJyb3J9XG4gKiAgICAgICAgIFRocm93cyBhbiBlcnJvciBpZiB0aGVyZSBpcyB3aGl0ZXNwYWNlIGluIHRoZSBzdHJpbmcuXG4gKlxuICovXG5mdW5jdGlvbiB0aHJvd0lmV2hpdGVzcGFjZShzdHIpIHtcbiAgaWYgKC9cXHMvLnRlc3Qoc3RyKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xhc3MgaGFzIGlsbGVnYWwgd2hpdGVzcGFjZSBjaGFyYWN0ZXJzJyk7XG4gIH1cbn1cblxuLyoqXG4gKiBQcm9kdWNlIGEgcmVndWxhciBleHByZXNzaW9uIGZvciBtYXRjaGluZyBhIGNsYXNzTmFtZSB3aXRoaW4gYW4gZWxlbWVudHMgY2xhc3NOYW1lLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWVcbiAqICAgICAgICAgVGhlIGNsYXNzTmFtZSB0byBnZW5lcmF0ZSB0aGUgUmVnRXhwIGZvci5cbiAqXG4gKiBAcmV0dXJuIHtSZWdFeHB9XG4gKiAgICAgICAgIFRoZSBSZWdFeHAgdGhhdCB3aWxsIGNoZWNrIGZvciBhIHNwZWNpZmljIGBjbGFzc05hbWVgIGluIGFuIGVsZW1lbnRzXG4gKiAgICAgICAgIGNsYXNzTmFtZS5cbiAqL1xuZnVuY3Rpb24gY2xhc3NSZWdFeHAoY2xhc3NOYW1lKSB7XG4gIHJldHVybiBuZXcgUmVnRXhwKCcoXnxcXFxccyknICsgY2xhc3NOYW1lICsgJygkfFxcXFxzKScpO1xufVxuXG4vKipcbiAqIFdoZXRoZXIgdGhlIGN1cnJlbnQgRE9NIGludGVyZmFjZSBhcHBlYXJzIHRvIGJlIHJlYWwuXG4gKlxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNSZWFsKCkge1xuICByZXR1cm4gKFxuXG4gICAgLy8gQm90aCBkb2N1bWVudCBhbmQgd2luZG93IHdpbGwgbmV2ZXIgYmUgdW5kZWZpbmVkIHRoYW5rcyB0byBgZ2xvYmFsYC5cbiAgICBkb2N1bWVudCA9PT0gd2luZG93LmRvY3VtZW50ICYmXG5cbiAgICAvLyBJbiBJRSA8IDksIERPTSBtZXRob2RzIHJldHVybiBcIm9iamVjdFwiIGFzIHRoZWlyIHR5cGUsIHNvIGFsbCB3ZSBjYW5cbiAgICAvLyBjb25maWRlbnRseSBjaGVjayBpcyB0aGF0IGl0IGV4aXN0cy5cbiAgICB0eXBlb2YgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCdcbiAgKTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmVzLCB2aWEgZHVjayB0eXBpbmcsIHdoZXRoZXIgb3Igbm90IGEgdmFsdWUgaXMgYSBET00gZWxlbWVudC5cbiAqXG4gKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICogICAgICAgIFRoZSB0aGluZyB0byBjaGVja1xuICpcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKiAgICAgICAgIC0gVHJ1ZSBpZiBpdCBpcyBhIERPTSBlbGVtZW50XG4gKiAgICAgICAgIC0gRmFsc2Ugb3RoZXJ3aXNlXG4gKi9cbmZ1bmN0aW9uIGlzRWwodmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KHZhbHVlKSAmJiB2YWx1ZS5ub2RlVHlwZSA9PT0gMTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIHRoZSBjdXJyZW50IERPTSBpcyBlbWJlZGRlZCBpbiBhbiBpZnJhbWUuXG4gKlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqXG4gKi9cbmZ1bmN0aW9uIGlzSW5GcmFtZSgpIHtcblxuICAvLyBXZSBuZWVkIGEgdHJ5L2NhdGNoIGhlcmUgYmVjYXVzZSBTYWZhcmkgd2lsbCB0aHJvdyBlcnJvcnMgd2hlbiBhdHRlbXB0aW5nXG4gIC8vIHRvIGdldCBlaXRoZXIgYHBhcmVudGAgb3IgYHNlbGZgXG4gIHRyeSB7XG4gICAgcmV0dXJuIHdpbmRvdy5wYXJlbnQgIT09IHdpbmRvdy5zZWxmO1xuICB9IGNhdGNoICh4KSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cblxuLyoqXG4gKiBDcmVhdGVzIGZ1bmN0aW9ucyB0byBxdWVyeSB0aGUgRE9NIHVzaW5nIGEgZ2l2ZW4gbWV0aG9kLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXRob2RcbiAqICAgICAgICAgVGhlIG1ldGhvZCB0byBjcmVhdGUgdGhlIHF1ZXJ5IHdpdGguXG4gKlxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKiAgICAgICAgIFRoZSBxdWVyeSBtZXRob2RcbiAqL1xuZnVuY3Rpb24gY3JlYXRlUXVlcmllcihtZXRob2QpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChzZWxlY3RvciwgY29udGV4dCkge1xuICAgIGlmICghaXNOb25CbGFua1N0cmluZyhzZWxlY3RvcikpIHtcbiAgICAgIHJldHVybiBkb2N1bWVudFttZXRob2RdKG51bGwpO1xuICAgIH1cbiAgICBpZiAoaXNOb25CbGFua1N0cmluZyhjb250ZXh0KSkge1xuICAgICAgY29udGV4dCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoY29udGV4dCk7XG4gICAgfVxuXG4gICAgdmFyIGN0eCA9IGlzRWwoY29udGV4dCkgPyBjb250ZXh0IDogZG9jdW1lbnQ7XG5cbiAgICByZXR1cm4gY3R4W21ldGhvZF0gJiYgY3R4W21ldGhvZF0oc2VsZWN0b3IpO1xuICB9O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYW4gZWxlbWVudCBhbmQgYXBwbGllcyBwcm9wZXJ0aWVzLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBbdGFnTmFtZT0nZGl2J11cbiAqICAgICAgICAgTmFtZSBvZiB0YWcgdG8gYmUgY3JlYXRlZC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW3Byb3BlcnRpZXM9e31dXG4gKiAgICAgICAgIEVsZW1lbnQgcHJvcGVydGllcyB0byBiZSBhcHBsaWVkLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbYXR0cmlidXRlcz17fV1cbiAqICAgICAgICAgRWxlbWVudCBhdHRyaWJ1dGVzIHRvIGJlIGFwcGxpZWQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8RWxlbWVudHxUZXh0Tm9kZXxBcnJheXxGdW5jdGlvbn0gW2NvbnRlbnRdXG4gKiAgICAgICAgIENvbnRlbnRzIGZvciB0aGUgZWxlbWVudCAoc2VlOiB7QGxpbmsgZG9tOm5vcm1hbGl6ZUNvbnRlbnR9KVxuICpcbiAqIEByZXR1cm4ge0VsZW1lbnR9XG4gKiAgICAgICAgIFRoZSBlbGVtZW50IHRoYXQgd2FzIGNyZWF0ZWQuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUVsKCkge1xuICB2YXIgdGFnTmFtZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogJ2Rpdic7XG4gIHZhciBwcm9wZXJ0aWVzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgdmFyIGF0dHJpYnV0ZXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICB2YXIgY29udGVudCA9IGFyZ3VtZW50c1szXTtcblxuICB2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZ05hbWUpO1xuXG4gIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHByb3BlcnRpZXMpLmZvckVhY2goZnVuY3Rpb24gKHByb3BOYW1lKSB7XG4gICAgdmFyIHZhbCA9IHByb3BlcnRpZXNbcHJvcE5hbWVdO1xuXG4gICAgLy8gU2VlICMyMTc2XG4gICAgLy8gV2Ugb3JpZ2luYWxseSB3ZXJlIGFjY2VwdGluZyBib3RoIHByb3BlcnRpZXMgYW5kIGF0dHJpYnV0ZXMgaW4gdGhlXG4gICAgLy8gc2FtZSBvYmplY3QsIGJ1dCB0aGF0IGRvZXNuJ3Qgd29yayBzbyB3ZWxsLlxuICAgIGlmIChwcm9wTmFtZS5pbmRleE9mKCdhcmlhLScpICE9PSAtMSB8fCBwcm9wTmFtZSA9PT0gJ3JvbGUnIHx8IHByb3BOYW1lID09PSAndHlwZScpIHtcbiAgICAgIGxvZy53YXJuKHRzbWwoX3RlbXBsYXRlT2JqZWN0LCBwcm9wTmFtZSwgdmFsKSk7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUocHJvcE5hbWUsIHZhbCk7XG5cbiAgICAgIC8vIEhhbmRsZSB0ZXh0Q29udGVudCBzaW5jZSBpdCdzIG5vdCBzdXBwb3J0ZWQgZXZlcnl3aGVyZSBhbmQgd2UgaGF2ZSBhXG4gICAgICAvLyBtZXRob2QgZm9yIGl0LlxuICAgIH0gZWxzZSBpZiAocHJvcE5hbWUgPT09ICd0ZXh0Q29udGVudCcpIHtcbiAgICAgIHRleHRDb250ZW50KGVsLCB2YWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbFtwcm9wTmFtZV0gPSB2YWw7XG4gICAgfVxuICB9KTtcblxuICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhhdHRyaWJ1dGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyTmFtZSkge1xuICAgIGVsLnNldEF0dHJpYnV0ZShhdHRyTmFtZSwgYXR0cmlidXRlc1thdHRyTmFtZV0pO1xuICB9KTtcblxuICBpZiAoY29udGVudCkge1xuICAgIGFwcGVuZENvbnRlbnQoZWwsIGNvbnRlbnQpO1xuICB9XG5cbiAgcmV0dXJuIGVsO1xufVxuXG4vKipcbiAqIEluamVjdHMgdGV4dCBpbnRvIGFuIGVsZW1lbnQsIHJlcGxhY2luZyBhbnkgZXhpc3RpbmcgY29udGVudHMgZW50aXJlbHkuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogICAgICAgIFRoZSBlbGVtZW50IHRvIGFkZCB0ZXh0IGNvbnRlbnQgaW50b1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gKiAgICAgICAgVGhlIHRleHQgY29udGVudCB0byBhZGQuXG4gKlxuICogQHJldHVybiB7RWxlbWVudH1cbiAqICAgICAgICAgVGhlIGVsZW1lbnQgd2l0aCBhZGRlZCB0ZXh0IGNvbnRlbnQuXG4gKi9cbmZ1bmN0aW9uIHRleHRDb250ZW50KGVsLCB0ZXh0KSB7XG4gIGlmICh0eXBlb2YgZWwudGV4dENvbnRlbnQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgZWwuaW5uZXJUZXh0ID0gdGV4dDtcbiAgfSBlbHNlIHtcbiAgICBlbC50ZXh0Q29udGVudCA9IHRleHQ7XG4gIH1cbiAgcmV0dXJuIGVsO1xufVxuXG4vKipcbiAqIEluc2VydCBhbiBlbGVtZW50IGFzIHRoZSBmaXJzdCBjaGlsZCBub2RlIG9mIGFub3RoZXJcbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGNoaWxkXG4gKiAgICAgICAgRWxlbWVudCB0byBpbnNlcnRcbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IHBhcmVudFxuICogICAgICAgIEVsZW1lbnQgdG8gaW5zZXJ0IGNoaWxkIGludG9cbiAqL1xuZnVuY3Rpb24gcHJlcGVuZFRvKGNoaWxkLCBwYXJlbnQpIHtcbiAgaWYgKHBhcmVudC5maXJzdENoaWxkKSB7XG4gICAgcGFyZW50Lmluc2VydEJlZm9yZShjaGlsZCwgcGFyZW50LmZpcnN0Q2hpbGQpO1xuICB9IGVsc2Uge1xuICAgIHBhcmVudC5hcHBlbmRDaGlsZChjaGlsZCk7XG4gIH1cbn1cblxuLyoqXG4gKiBDaGVjayBpZiBhbiBlbGVtZW50IGhhcyBhIENTUyBjbGFzc1xuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICogICAgICAgIEVsZW1lbnQgdG8gY2hlY2tcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NUb0NoZWNrXG4gKiAgICAgICAgQ2xhc3MgbmFtZSB0byBjaGVjayBmb3JcbiAqXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICogICAgICAgICAtIFRydWUgaWYgdGhlIGVsZW1lbnQgaGFkIHRoZSBjbGFzc1xuICogICAgICAgICAtIEZhbHNlIG90aGVyd2lzZS5cbiAqXG4gKiBAdGhyb3dzIHtFcnJvcn1cbiAqICAgICAgICAgVGhyb3dzIGFuIGVycm9yIGlmIGBjbGFzc1RvQ2hlY2tgIGhhcyB3aGl0ZSBzcGFjZS5cbiAqL1xuZnVuY3Rpb24gaGFzQ2xhc3MoZWxlbWVudCwgY2xhc3NUb0NoZWNrKSB7XG4gIHRocm93SWZXaGl0ZXNwYWNlKGNsYXNzVG9DaGVjayk7XG4gIGlmIChlbGVtZW50LmNsYXNzTGlzdCkge1xuICAgIHJldHVybiBlbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhjbGFzc1RvQ2hlY2spO1xuICB9XG4gIHJldHVybiBjbGFzc1JlZ0V4cChjbGFzc1RvQ2hlY2spLnRlc3QoZWxlbWVudC5jbGFzc05hbWUpO1xufVxuXG4vKipcbiAqIEFkZCBhIENTUyBjbGFzcyBuYW1lIHRvIGFuIGVsZW1lbnRcbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAqICAgICAgICBFbGVtZW50IHRvIGFkZCBjbGFzcyBuYW1lIHRvLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc1RvQWRkXG4gKiAgICAgICAgQ2xhc3MgbmFtZSB0byBhZGQuXG4gKlxuICogQHJldHVybiB7RWxlbWVudH1cbiAqICAgICAgICAgVGhlIGRvbSBlbGVtZW50IHdpdGggdGhlIGFkZGVkIGNsYXNzIG5hbWUuXG4gKi9cbmZ1bmN0aW9uIGFkZENsYXNzKGVsZW1lbnQsIGNsYXNzVG9BZGQpIHtcbiAgaWYgKGVsZW1lbnQuY2xhc3NMaXN0KSB7XG4gICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKGNsYXNzVG9BZGQpO1xuXG4gICAgLy8gRG9uJ3QgbmVlZCB0byBgdGhyb3dJZldoaXRlc3BhY2VgIGhlcmUgYmVjYXVzZSBgaGFzRWxDbGFzc2Agd2lsbCBkbyBpdFxuICAgIC8vIGluIHRoZSBjYXNlIG9mIGNsYXNzTGlzdCBub3QgYmVpbmcgc3VwcG9ydGVkLlxuICB9IGVsc2UgaWYgKCFoYXNDbGFzcyhlbGVtZW50LCBjbGFzc1RvQWRkKSkge1xuICAgIGVsZW1lbnQuY2xhc3NOYW1lID0gKGVsZW1lbnQuY2xhc3NOYW1lICsgJyAnICsgY2xhc3NUb0FkZCkudHJpbSgpO1xuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnQ7XG59XG5cbi8qKlxuICogUmVtb3ZlIGEgQ1NTIGNsYXNzIG5hbWUgZnJvbSBhbiBlbGVtZW50XG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gKiAgICAgICAgRWxlbWVudCB0byByZW1vdmUgYSBjbGFzcyBuYW1lIGZyb20uXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzVG9SZW1vdmVcbiAqICAgICAgICBDbGFzcyBuYW1lIHRvIHJlbW92ZVxuICpcbiAqIEByZXR1cm4ge0VsZW1lbnR9XG4gKiAgICAgICAgIFRoZSBkb20gZWxlbWVudCB3aXRoIGNsYXNzIG5hbWUgcmVtb3ZlZC5cbiAqL1xuZnVuY3Rpb24gcmVtb3ZlQ2xhc3MoZWxlbWVudCwgY2xhc3NUb1JlbW92ZSkge1xuICBpZiAoZWxlbWVudC5jbGFzc0xpc3QpIHtcbiAgICBlbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoY2xhc3NUb1JlbW92ZSk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3dJZldoaXRlc3BhY2UoY2xhc3NUb1JlbW92ZSk7XG4gICAgZWxlbWVudC5jbGFzc05hbWUgPSBlbGVtZW50LmNsYXNzTmFtZS5zcGxpdCgvXFxzKy8pLmZpbHRlcihmdW5jdGlvbiAoYykge1xuICAgICAgcmV0dXJuIGMgIT09IGNsYXNzVG9SZW1vdmU7XG4gICAgfSkuam9pbignICcpO1xuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnQ7XG59XG5cbi8qKlxuICogVGhlIGNhbGxiYWNrIGRlZmluaXRpb24gZm9yIHRvZ2dsZUVsQ2xhc3MuXG4gKlxuICogQGNhbGxiYWNrIERvbX5QcmVkaWNhdGVDYWxsYmFja1xuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gKiAgICAgICAgVGhlIERPTSBlbGVtZW50IG9mIHRoZSBDb21wb25lbnQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzVG9Ub2dnbGVcbiAqICAgICAgICBUaGUgYGNsYXNzTmFtZWAgdGhhdCB3YW50cyB0byBiZSB0b2dnbGVkXG4gKlxuICogQHJldHVybiB7Ym9vbGVhbnx1bmRlZmluZWR9XG4gKiAgICAgICAgIC0gSWYgdHJ1ZSB0aGUgYGNsYXNzVG9Ub2dnbGVgIHdpbGwgZ2V0IGFkZGVkIHRvIGBlbGVtZW50YC5cbiAqICAgICAgICAgLSBJZiBmYWxzZSB0aGUgYGNsYXNzVG9Ub2dnbGVgIHdpbGwgZ2V0IHJlbW92ZWQgZnJvbSBgZWxlbWVudGAuXG4gKiAgICAgICAgIC0gSWYgdW5kZWZpbmVkIHRoaXMgY2FsbGJhY2sgd2lsbCBiZSBpZ25vcmVkXG4gKi9cblxuLyoqXG4gKiBBZGRzIG9yIHJlbW92ZXMgYSBDU1MgY2xhc3MgbmFtZSBvbiBhbiBlbGVtZW50IGRlcGVuZGluZyBvbiBhbiBvcHRpb25hbFxuICogY29uZGl0aW9uIG9yIHRoZSBwcmVzZW5jZS9hYnNlbmNlIG9mIHRoZSBjbGFzcyBuYW1lLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICogICAgICAgIFRoZSBlbGVtZW50IHRvIHRvZ2dsZSBhIGNsYXNzIG5hbWUgb24uXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzVG9Ub2dnbGVcbiAqICAgICAgICBUaGUgY2xhc3MgdGhhdCBzaG91bGQgYmUgdG9nZ2xlZFxuICpcbiAqIEBwYXJhbSB7Ym9vbGVhbnxQcmVkaWNhdGVDYWxsYmFja30gW3ByZWRpY2F0ZV1cbiAqICAgICAgICBTZWUgdGhlIHJldHVybiB2YWx1ZSBmb3Ige0BsaW5rIERvbX5QcmVkaWNhdGVDYWxsYmFja31cbiAqXG4gKiBAcmV0dXJuIHtFbGVtZW50fVxuICogICAgICAgICBUaGUgZWxlbWVudCB3aXRoIGEgY2xhc3MgdGhhdCBoYXMgYmVlbiB0b2dnbGVkLlxuICovXG5mdW5jdGlvbiB0b2dnbGVDbGFzcyhlbGVtZW50LCBjbGFzc1RvVG9nZ2xlLCBwcmVkaWNhdGUpIHtcblxuICAvLyBUaGlzIENBTk5PVCB1c2UgYGNsYXNzTGlzdGAgaW50ZXJuYWxseSBiZWNhdXNlIElFIGRvZXMgbm90IHN1cHBvcnQgdGhlXG4gIC8vIHNlY29uZCBwYXJhbWV0ZXIgdG8gdGhlIGBjbGFzc0xpc3QudG9nZ2xlKClgIG1ldGhvZCEgV2hpY2ggaXMgZmluZSBiZWNhdXNlXG4gIC8vIGBjbGFzc0xpc3RgIHdpbGwgYmUgdXNlZCBieSB0aGUgYWRkL3JlbW92ZSBmdW5jdGlvbnMuXG4gIHZhciBoYXMgPSBoYXNDbGFzcyhlbGVtZW50LCBjbGFzc1RvVG9nZ2xlKTtcblxuICBpZiAodHlwZW9mIHByZWRpY2F0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHByZWRpY2F0ZSA9IHByZWRpY2F0ZShlbGVtZW50LCBjbGFzc1RvVG9nZ2xlKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgcHJlZGljYXRlICE9PSAnYm9vbGVhbicpIHtcbiAgICBwcmVkaWNhdGUgPSAhaGFzO1xuICB9XG5cbiAgLy8gSWYgdGhlIG5lY2Vzc2FyeSBjbGFzcyBvcGVyYXRpb24gbWF0Y2hlcyB0aGUgY3VycmVudCBzdGF0ZSBvZiB0aGVcbiAgLy8gZWxlbWVudCwgbm8gYWN0aW9uIGlzIHJlcXVpcmVkLlxuICBpZiAocHJlZGljYXRlID09PSBoYXMpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAocHJlZGljYXRlKSB7XG4gICAgYWRkQ2xhc3MoZWxlbWVudCwgY2xhc3NUb1RvZ2dsZSk7XG4gIH0gZWxzZSB7XG4gICAgcmVtb3ZlQ2xhc3MoZWxlbWVudCwgY2xhc3NUb1RvZ2dsZSk7XG4gIH1cblxuICByZXR1cm4gZWxlbWVudDtcbn1cblxuLyoqXG4gKiBBcHBseSBhdHRyaWJ1dGVzIHRvIGFuIEhUTUwgZWxlbWVudC5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiAgICAgICAgRWxlbWVudCB0byBhZGQgYXR0cmlidXRlcyB0by5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW2F0dHJpYnV0ZXNdXG4gKiAgICAgICAgQXR0cmlidXRlcyB0byBiZSBhcHBsaWVkLlxuICovXG5mdW5jdGlvbiBzZXRBdHRyaWJ1dGVzKGVsLCBhdHRyaWJ1dGVzKSB7XG4gIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGF0dHJpYnV0ZXMpLmZvckVhY2goZnVuY3Rpb24gKGF0dHJOYW1lKSB7XG4gICAgdmFyIGF0dHJWYWx1ZSA9IGF0dHJpYnV0ZXNbYXR0ck5hbWVdO1xuXG4gICAgaWYgKGF0dHJWYWx1ZSA9PT0gbnVsbCB8fCB0eXBlb2YgYXR0clZhbHVlID09PSAndW5kZWZpbmVkJyB8fCBhdHRyVmFsdWUgPT09IGZhbHNlKSB7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoYXR0ck5hbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoYXR0ck5hbWUsIGF0dHJWYWx1ZSA9PT0gdHJ1ZSA/ICcnIDogYXR0clZhbHVlKTtcbiAgICB9XG4gIH0pO1xufVxuXG4vKipcbiAqIEdldCBhbiBlbGVtZW50J3MgYXR0cmlidXRlIHZhbHVlcywgYXMgZGVmaW5lZCBvbiB0aGUgSFRNTCB0YWdcbiAqIEF0dHJpYnV0ZXMgYXJlIG5vdCB0aGUgc2FtZSBhcyBwcm9wZXJ0aWVzLiBUaGV5J3JlIGRlZmluZWQgb24gdGhlIHRhZ1xuICogb3Igd2l0aCBzZXRBdHRyaWJ1dGUgKHdoaWNoIHNob3VsZG4ndCBiZSB1c2VkIHdpdGggSFRNTClcbiAqIFRoaXMgd2lsbCByZXR1cm4gdHJ1ZSBvciBmYWxzZSBmb3IgYm9vbGVhbiBhdHRyaWJ1dGVzLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gdGFnXG4gKiAgICAgICAgRWxlbWVudCBmcm9tIHdoaWNoIHRvIGdldCB0YWcgYXR0cmlidXRlcy5cbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKiAgICAgICAgIEFsbCBhdHRyaWJ1dGVzIG9mIHRoZSBlbGVtZW50LlxuICovXG5mdW5jdGlvbiBnZXRBdHRyaWJ1dGVzKHRhZykge1xuICB2YXIgb2JqID0ge307XG5cbiAgLy8ga25vd24gYm9vbGVhbiBhdHRyaWJ1dGVzXG4gIC8vIHdlIGNhbiBjaGVjayBmb3IgbWF0Y2hpbmcgYm9vbGVhbiBwcm9wZXJ0aWVzLCBidXQgb2xkZXIgYnJvd3NlcnNcbiAgLy8gd29uJ3Qga25vdyBhYm91dCBIVE1MNSBib29sZWFuIGF0dHJpYnV0ZXMgdGhhdCB3ZSBzdGlsbCByZWFkIGZyb21cbiAgdmFyIGtub3duQm9vbGVhbnMgPSAnLCcgKyAnYXV0b3BsYXksY29udHJvbHMscGxheXNpbmxpbmUsbG9vcCxtdXRlZCxkZWZhdWx0LGRlZmF1bHRNdXRlZCcgKyAnLCc7XG5cbiAgaWYgKHRhZyAmJiB0YWcuYXR0cmlidXRlcyAmJiB0YWcuYXR0cmlidXRlcy5sZW5ndGggPiAwKSB7XG4gICAgdmFyIGF0dHJzID0gdGFnLmF0dHJpYnV0ZXM7XG5cbiAgICBmb3IgKHZhciBpID0gYXR0cnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciBhdHRyTmFtZSA9IGF0dHJzW2ldLm5hbWU7XG4gICAgICB2YXIgYXR0clZhbCA9IGF0dHJzW2ldLnZhbHVlO1xuXG4gICAgICAvLyBjaGVjayBmb3Iga25vd24gYm9vbGVhbnNcbiAgICAgIC8vIHRoZSBtYXRjaGluZyBlbGVtZW50IHByb3BlcnR5IHdpbGwgcmV0dXJuIGEgdmFsdWUgZm9yIHR5cGVvZlxuICAgICAgaWYgKHR5cGVvZiB0YWdbYXR0ck5hbWVdID09PSAnYm9vbGVhbicgfHwga25vd25Cb29sZWFucy5pbmRleE9mKCcsJyArIGF0dHJOYW1lICsgJywnKSAhPT0gLTEpIHtcbiAgICAgICAgLy8gdGhlIHZhbHVlIG9mIGFuIGluY2x1ZGVkIGJvb2xlYW4gYXR0cmlidXRlIGlzIHR5cGljYWxseSBhbiBlbXB0eVxuICAgICAgICAvLyBzdHJpbmcgKCcnKSB3aGljaCB3b3VsZCBlcXVhbCBmYWxzZSBpZiB3ZSBqdXN0IGNoZWNrIGZvciBhIGZhbHNlIHZhbHVlLlxuICAgICAgICAvLyB3ZSBhbHNvIGRvbid0IHdhbnQgc3VwcG9ydCBiYWQgY29kZSBsaWtlIGF1dG9wbGF5PSdmYWxzZSdcbiAgICAgICAgYXR0clZhbCA9IGF0dHJWYWwgIT09IG51bGwgPyB0cnVlIDogZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIG9ialthdHRyTmFtZV0gPSBhdHRyVmFsO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvYmo7XG59XG5cbi8qKlxuICogR2V0IHRoZSB2YWx1ZSBvZiBhbiBlbGVtZW50J3MgYXR0cmlidXRlXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogICAgICAgIEEgRE9NIGVsZW1lbnRcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYXR0cmlidXRlXG4gKiAgICAgICAgQXR0cmlidXRlIHRvIGdldCB0aGUgdmFsdWUgb2ZcbiAqXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKiAgICAgICAgIHZhbHVlIG9mIHRoZSBhdHRyaWJ1dGVcbiAqL1xuZnVuY3Rpb24gZ2V0QXR0cmlidXRlKGVsLCBhdHRyaWJ1dGUpIHtcbiAgcmV0dXJuIGVsLmdldEF0dHJpYnV0ZShhdHRyaWJ1dGUpO1xufVxuXG4vKipcbiAqIFNldCB0aGUgdmFsdWUgb2YgYW4gZWxlbWVudCdzIGF0dHJpYnV0ZVxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqICAgICAgICBBIERPTSBlbGVtZW50XG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGF0dHJpYnV0ZVxuICogICAgICAgIEF0dHJpYnV0ZSB0byBzZXRcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAqICAgICAgICBWYWx1ZSB0byBzZXQgdGhlIGF0dHJpYnV0ZSB0b1xuICovXG5mdW5jdGlvbiBzZXRBdHRyaWJ1dGUoZWwsIGF0dHJpYnV0ZSwgdmFsdWUpIHtcbiAgZWwuc2V0QXR0cmlidXRlKGF0dHJpYnV0ZSwgdmFsdWUpO1xufVxuXG4vKipcbiAqIFJlbW92ZSBhbiBlbGVtZW50J3MgYXR0cmlidXRlXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogICAgICAgIEEgRE9NIGVsZW1lbnRcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYXR0cmlidXRlXG4gKiAgICAgICAgQXR0cmlidXRlIHRvIHJlbW92ZVxuICovXG5mdW5jdGlvbiByZW1vdmVBdHRyaWJ1dGUoZWwsIGF0dHJpYnV0ZSkge1xuICBlbC5yZW1vdmVBdHRyaWJ1dGUoYXR0cmlidXRlKTtcbn1cblxuLyoqXG4gKiBBdHRlbXB0IHRvIGJsb2NrIHRoZSBhYmlsaXR5IHRvIHNlbGVjdCB0ZXh0IHdoaWxlIGRyYWdnaW5nIGNvbnRyb2xzXG4gKi9cbmZ1bmN0aW9uIGJsb2NrVGV4dFNlbGVjdGlvbigpIHtcbiAgZG9jdW1lbnQuYm9keS5mb2N1cygpO1xuICBkb2N1bWVudC5vbnNlbGVjdHN0YXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcbn1cblxuLyoqXG4gKiBUdXJuIG9mZiB0ZXh0IHNlbGVjdGlvbiBibG9ja2luZ1xuICovXG5mdW5jdGlvbiB1bmJsb2NrVGV4dFNlbGVjdGlvbigpIHtcbiAgZG9jdW1lbnQub25zZWxlY3RzdGFydCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcbn1cblxuLyoqXG4gKiBJZGVudGljYWwgdG8gdGhlIG5hdGl2ZSBgZ2V0Qm91bmRpbmdDbGllbnRSZWN0YCBmdW5jdGlvbiwgYnV0IGVuc3VyZXMgdGhhdFxuICogdGhlIG1ldGhvZCBpcyBzdXBwb3J0ZWQgYXQgYWxsIChpdCBpcyBpbiBhbGwgYnJvd3NlcnMgd2UgY2xhaW0gdG8gc3VwcG9ydClcbiAqIGFuZCB0aGF0IHRoZSBlbGVtZW50IGlzIGluIHRoZSBET00gYmVmb3JlIGNvbnRpbnVpbmcuXG4gKlxuICogVGhpcyB3cmFwcGVyIGZ1bmN0aW9uIGFsc28gc2hpbXMgcHJvcGVydGllcyB3aGljaCBhcmUgbm90IHByb3ZpZGVkIGJ5IHNvbWVcbiAqIG9sZGVyIGJyb3dzZXJzIChuYW1lbHksIElFOCkuXG4gKlxuICogQWRkaXRpb25hbGx5LCBzb21lIGJyb3dzZXJzIGRvIG5vdCBzdXBwb3J0IGFkZGluZyBwcm9wZXJ0aWVzIHRvIGFcbiAqIGBDbGllbnRSZWN0YC9gRE9NUmVjdGAgb2JqZWN0OyBzbywgd2Ugc2hhbGxvdy1jb3B5IGl0IHdpdGggdGhlIHN0YW5kYXJkXG4gKiBwcm9wZXJ0aWVzIChleGNlcHQgYHhgIGFuZCBgeWAgd2hpY2ggYXJlIG5vdCB3aWRlbHkgc3VwcG9ydGVkKS4gVGhpcyBoZWxwc1xuICogYXZvaWQgaW1wbGVtZW50YXRpb25zIHdoZXJlIGtleXMgYXJlIG5vbi1lbnVtZXJhYmxlLlxuICpcbiAqIEBwYXJhbSAge0VsZW1lbnR9IGVsXG4gKiAgICAgICAgIEVsZW1lbnQgd2hvc2UgYENsaWVudFJlY3RgIHdlIHdhbnQgdG8gY2FsY3VsYXRlLlxuICpcbiAqIEByZXR1cm4ge09iamVjdHx1bmRlZmluZWR9XG4gKiAgICAgICAgIEFsd2F5cyByZXR1cm5zIGEgcGxhaW5cbiAqL1xuZnVuY3Rpb24gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGVsKSB7XG4gIGlmIChlbCAmJiBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QgJiYgZWwucGFyZW50Tm9kZSkge1xuICAgIHZhciByZWN0ID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuXG4gICAgWydib3R0b20nLCAnaGVpZ2h0JywgJ2xlZnQnLCAncmlnaHQnLCAndG9wJywgJ3dpZHRoJ10uZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgICAgaWYgKHJlY3Rba10gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXN1bHRba10gPSByZWN0W2tdO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKCFyZXN1bHQuaGVpZ2h0KSB7XG4gICAgICByZXN1bHQuaGVpZ2h0ID0gcGFyc2VGbG9hdChjb21wdXRlZFN0eWxlKGVsLCAnaGVpZ2h0JykpO1xuICAgIH1cblxuICAgIGlmICghcmVzdWx0LndpZHRoKSB7XG4gICAgICByZXN1bHQud2lkdGggPSBwYXJzZUZsb2F0KGNvbXB1dGVkU3R5bGUoZWwsICd3aWR0aCcpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59XG5cbi8qKlxuICogVGhlIHBvc3Rpb24gb2YgYSBET00gZWxlbWVudCBvbiB0aGUgcGFnZS5cbiAqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBtb2R1bGU6ZG9tflBvc2l0aW9uXG4gKlxuICogQHByb3BlcnR5IHtudW1iZXJ9IGxlZnRcbiAqICAgICAgICAgICBQaXhlbHMgdG8gdGhlIGxlZnRcbiAqXG4gKiBAcHJvcGVydHkge251bWJlcn0gdG9wXG4gKiAgICAgICAgICAgUGl4ZWxzIG9uIHRvcFxuICovXG5cbi8qKlxuICogT2Zmc2V0IExlZnQuXG4gKiBnZXRCb3VuZGluZ0NsaWVudFJlY3QgdGVjaG5pcXVlIGZyb21cbiAqIEpvaG4gUmVzaWdcbiAqXG4gKiBAc2VlIGh0dHA6Ly9lam9obi5vcmcvYmxvZy9nZXRib3VuZGluZ2NsaWVudHJlY3QtaXMtYXdlc29tZS9cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiAgICAgICAgRWxlbWVudCBmcm9tIHdoaWNoIHRvIGdldCBvZmZzZXRcbiAqXG4gKiBAcmV0dXJuIHttb2R1bGU6ZG9tflBvc2l0aW9ufVxuICogICAgICAgICBUaGUgcG9zaXRpb24gb2YgdGhlIGVsZW1lbnQgdGhhdCB3YXMgcGFzc2VkIGluLlxuICovXG5mdW5jdGlvbiBmaW5kUG9zaXRpb24oZWwpIHtcbiAgdmFyIGJveCA9IHZvaWQgMDtcblxuICBpZiAoZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0ICYmIGVsLnBhcmVudE5vZGUpIHtcbiAgICBib3ggPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgfVxuXG4gIGlmICghYm94KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxlZnQ6IDAsXG4gICAgICB0b3A6IDBcbiAgICB9O1xuICB9XG5cbiAgdmFyIGRvY0VsID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICB2YXIgYm9keSA9IGRvY3VtZW50LmJvZHk7XG5cbiAgdmFyIGNsaWVudExlZnQgPSBkb2NFbC5jbGllbnRMZWZ0IHx8IGJvZHkuY2xpZW50TGVmdCB8fCAwO1xuICB2YXIgc2Nyb2xsTGVmdCA9IHdpbmRvdy5wYWdlWE9mZnNldCB8fCBib2R5LnNjcm9sbExlZnQ7XG4gIHZhciBsZWZ0ID0gYm94LmxlZnQgKyBzY3JvbGxMZWZ0IC0gY2xpZW50TGVmdDtcblxuICB2YXIgY2xpZW50VG9wID0gZG9jRWwuY2xpZW50VG9wIHx8IGJvZHkuY2xpZW50VG9wIHx8IDA7XG4gIHZhciBzY3JvbGxUb3AgPSB3aW5kb3cucGFnZVlPZmZzZXQgfHwgYm9keS5zY3JvbGxUb3A7XG4gIHZhciB0b3AgPSBib3gudG9wICsgc2Nyb2xsVG9wIC0gY2xpZW50VG9wO1xuXG4gIC8vIEFuZHJvaWQgc29tZXRpbWVzIHJldHVybnMgc2xpZ2h0bHkgb2ZmIGRlY2ltYWwgdmFsdWVzLCBzbyBuZWVkIHRvIHJvdW5kXG4gIHJldHVybiB7XG4gICAgbGVmdDogTWF0aC5yb3VuZChsZWZ0KSxcbiAgICB0b3A6IE1hdGgucm91bmQodG9wKVxuICB9O1xufVxuXG4vKipcbiAqIHggYW5kIHkgY29vcmRpbmF0ZXMgZm9yIGEgZG9tIGVsZW1lbnQgb3IgbW91c2UgcG9pbnRlclxuICpcbiAqIEB0eXBlZGVmIHtPYmplY3R9IERvbX5Db29yZGluYXRlc1xuICpcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB4XG4gKiAgICAgICAgICAgeCBjb29yZGluYXRlIGluIHBpeGVsc1xuICpcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB5XG4gKiAgICAgICAgICAgeSBjb29yZGluYXRlIGluIHBpeGVsc1xuICovXG5cbi8qKlxuICogR2V0IHBvaW50ZXIgcG9zaXRpb24gaW4gZWxlbWVudFxuICogUmV0dXJucyBhbiBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvb3JkaW5hdGVzLlxuICogVGhlIGJhc2Ugb24gdGhlIGNvb3JkaW5hdGVzIGFyZSB0aGUgYm90dG9tIGxlZnQgb2YgdGhlIGVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogICAgICAgIEVsZW1lbnQgb24gd2hpY2ggdG8gZ2V0IHRoZSBwb2ludGVyIHBvc2l0aW9uIG9uXG4gKlxuICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gZXZlbnRcbiAqICAgICAgICBFdmVudCBvYmplY3RcbiAqXG4gKiBAcmV0dXJuIHtEb21+Q29vcmRpbmF0ZXN9XG4gKiAgICAgICAgIEEgQ29vcmRpbmF0ZXMgb2JqZWN0IGNvcnJlc3BvbmRpbmcgdG8gdGhlIG1vdXNlIHBvc2l0aW9uLlxuICpcbiAqL1xuZnVuY3Rpb24gZ2V0UG9pbnRlclBvc2l0aW9uKGVsLCBldmVudCkge1xuICB2YXIgcG9zaXRpb24gPSB7fTtcbiAgdmFyIGJveCA9IGZpbmRQb3NpdGlvbihlbCk7XG4gIHZhciBib3hXID0gZWwub2Zmc2V0V2lkdGg7XG4gIHZhciBib3hIID0gZWwub2Zmc2V0SGVpZ2h0O1xuXG4gIHZhciBib3hZID0gYm94LnRvcDtcbiAgdmFyIGJveFggPSBib3gubGVmdDtcbiAgdmFyIHBhZ2VZID0gZXZlbnQucGFnZVk7XG4gIHZhciBwYWdlWCA9IGV2ZW50LnBhZ2VYO1xuXG4gIGlmIChldmVudC5jaGFuZ2VkVG91Y2hlcykge1xuICAgIHBhZ2VYID0gZXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0ucGFnZVg7XG4gICAgcGFnZVkgPSBldmVudC5jaGFuZ2VkVG91Y2hlc1swXS5wYWdlWTtcbiAgfVxuXG4gIHBvc2l0aW9uLnkgPSBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCAoYm94WSAtIHBhZ2VZICsgYm94SCkgLyBib3hIKSk7XG4gIHBvc2l0aW9uLnggPSBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCAocGFnZVggLSBib3hYKSAvIGJveFcpKTtcblxuICByZXR1cm4gcG9zaXRpb247XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lcywgdmlhIGR1Y2sgdHlwaW5nLCB3aGV0aGVyIG9yIG5vdCBhIHZhbHVlIGlzIGEgdGV4dCBub2RlLlxuICpcbiAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gKiAgICAgICAgQ2hlY2sgaWYgdGhpcyB2YWx1ZSBpcyBhIHRleHQgbm9kZS5cbiAqXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICogICAgICAgICAtIFRydWUgaWYgaXQgaXMgYSB0ZXh0IG5vZGVcbiAqICAgICAgICAgLSBGYWxzZSBvdGhlcndpc2VcbiAqL1xuZnVuY3Rpb24gaXNUZXh0Tm9kZSh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3QodmFsdWUpICYmIHZhbHVlLm5vZGVUeXBlID09PSAzO1xufVxuXG4vKipcbiAqIEVtcHRpZXMgdGhlIGNvbnRlbnRzIG9mIGFuIGVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogICAgICAgIFRoZSBlbGVtZW50IHRvIGVtcHR5IGNoaWxkcmVuIGZyb21cbiAqXG4gKiBAcmV0dXJuIHtFbGVtZW50fVxuICogICAgICAgICBUaGUgZWxlbWVudCB3aXRoIG5vIGNoaWxkcmVuXG4gKi9cbmZ1bmN0aW9uIGVtcHR5RWwoZWwpIHtcbiAgd2hpbGUgKGVsLmZpcnN0Q2hpbGQpIHtcbiAgICBlbC5yZW1vdmVDaGlsZChlbC5maXJzdENoaWxkKTtcbiAgfVxuICByZXR1cm4gZWw7XG59XG5cbi8qKlxuICogTm9ybWFsaXplcyBjb250ZW50IGZvciBldmVudHVhbCBpbnNlcnRpb24gaW50byB0aGUgRE9NLlxuICpcbiAqIFRoaXMgYWxsb3dzIGEgd2lkZSByYW5nZSBvZiBjb250ZW50IGRlZmluaXRpb24gbWV0aG9kcywgYnV0IHByb3RlY3RzXG4gKiBmcm9tIGZhbGxpbmcgaW50byB0aGUgdHJhcCBvZiBzaW1wbHkgd3JpdGluZyB0byBgaW5uZXJIVE1MYCwgd2hpY2ggaXNcbiAqIGFuIFhTUyBjb25jZXJuLlxuICpcbiAqIFRoZSBjb250ZW50IGZvciBhbiBlbGVtZW50IGNhbiBiZSBwYXNzZWQgaW4gbXVsdGlwbGUgdHlwZXMgYW5kXG4gKiBjb21iaW5hdGlvbnMsIHdob3NlIGJlaGF2aW9yIGlzIGFzIGZvbGxvd3M6XG4gKlxuICogQHBhcmFtIHtTdHJpbmd8RWxlbWVudHxUZXh0Tm9kZXxBcnJheXxGdW5jdGlvbn0gY29udGVudFxuICogICAgICAgIC0gU3RyaW5nOiBOb3JtYWxpemVkIGludG8gYSB0ZXh0IG5vZGUuXG4gKiAgICAgICAgLSBFbGVtZW50L1RleHROb2RlOiBQYXNzZWQgdGhyb3VnaC5cbiAqICAgICAgICAtIEFycmF5OiBBIG9uZS1kaW1lbnNpb25hbCBhcnJheSBvZiBzdHJpbmdzLCBlbGVtZW50cywgbm9kZXMsIG9yIGZ1bmN0aW9uc1xuICogICAgICAgICAgKHdoaWNoIHJldHVybiBzaW5nbGUgc3RyaW5ncywgZWxlbWVudHMsIG9yIG5vZGVzKS5cbiAqICAgICAgICAtIEZ1bmN0aW9uOiBJZiB0aGUgc29sZSBhcmd1bWVudCwgaXMgZXhwZWN0ZWQgdG8gcHJvZHVjZSBhIHN0cmluZywgZWxlbWVudCxcbiAqICAgICAgICAgIG5vZGUsIG9yIGFycmF5IGFzIGRlZmluZWQgYWJvdmUuXG4gKlxuICogQHJldHVybiB7QXJyYXl9XG4gKiAgICAgICAgIEFsbCBvZiB0aGUgY29udGVudCB0aGF0IHdhcyBwYXNzZWQgaW4gbm9ybWFsaXplZC5cbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplQ29udGVudChjb250ZW50KSB7XG5cbiAgLy8gRmlyc3QsIGludm9rZSBjb250ZW50IGlmIGl0IGlzIGEgZnVuY3Rpb24uIElmIGl0IHByb2R1Y2VzIGFuIGFycmF5LFxuICAvLyB0aGF0IG5lZWRzIHRvIGhhcHBlbiBiZWZvcmUgbm9ybWFsaXphdGlvbi5cbiAgaWYgKHR5cGVvZiBjb250ZW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY29udGVudCA9IGNvbnRlbnQoKTtcbiAgfVxuXG4gIC8vIE5leHQgdXAsIG5vcm1hbGl6ZSB0byBhbiBhcnJheSwgc28gb25lIG9yIG1hbnkgaXRlbXMgY2FuIGJlIG5vcm1hbGl6ZWQsXG4gIC8vIGZpbHRlcmVkLCBhbmQgcmV0dXJuZWQuXG4gIHJldHVybiAoQXJyYXkuaXNBcnJheShjb250ZW50KSA/IGNvbnRlbnQgOiBbY29udGVudF0pLm1hcChmdW5jdGlvbiAodmFsdWUpIHtcblxuICAgIC8vIEZpcnN0LCBpbnZva2UgdmFsdWUgaWYgaXQgaXMgYSBmdW5jdGlvbiB0byBwcm9kdWNlIGEgbmV3IHZhbHVlLFxuICAgIC8vIHdoaWNoIHdpbGwgYmUgc3Vic2VxdWVudGx5IG5vcm1hbGl6ZWQgdG8gYSBOb2RlIG9mIHNvbWUga2luZC5cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2YWx1ZSA9IHZhbHVlKCk7XG4gICAgfVxuXG4gICAgaWYgKGlzRWwodmFsdWUpIHx8IGlzVGV4dE5vZGUodmFsdWUpKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgL1xcUy8udGVzdCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh2YWx1ZSk7XG4gICAgfVxuICB9KS5maWx0ZXIoZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9KTtcbn1cblxuLyoqXG4gKiBOb3JtYWxpemVzIGFuZCBhcHBlbmRzIGNvbnRlbnQgdG8gYW4gZWxlbWVudC5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiAgICAgICAgRWxlbWVudCB0byBhcHBlbmQgbm9ybWFsaXplZCBjb250ZW50IHRvLlxuICpcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xFbGVtZW50fFRleHROb2RlfEFycmF5fEZ1bmN0aW9ufSBjb250ZW50XG4gKiAgICAgICAgU2VlIHRoZSBgY29udGVudGAgYXJndW1lbnQgb2Yge0BsaW5rIGRvbTpub3JtYWxpemVDb250ZW50fVxuICpcbiAqIEByZXR1cm4ge0VsZW1lbnR9XG4gKiAgICAgICAgIFRoZSBlbGVtZW50IHdpdGggYXBwZW5kZWQgbm9ybWFsaXplZCBjb250ZW50LlxuICovXG5mdW5jdGlvbiBhcHBlbmRDb250ZW50KGVsLCBjb250ZW50KSB7XG4gIG5vcm1hbGl6ZUNvbnRlbnQoY29udGVudCkuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgIHJldHVybiBlbC5hcHBlbmRDaGlsZChub2RlKTtcbiAgfSk7XG4gIHJldHVybiBlbDtcbn1cblxuLyoqXG4gKiBOb3JtYWxpemVzIGFuZCBpbnNlcnRzIGNvbnRlbnQgaW50byBhbiBlbGVtZW50OyB0aGlzIGlzIGlkZW50aWNhbCB0b1xuICogYGFwcGVuZENvbnRlbnQoKWAsIGV4Y2VwdCBpdCBlbXB0aWVzIHRoZSBlbGVtZW50IGZpcnN0LlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqICAgICAgICBFbGVtZW50IHRvIGluc2VydCBub3JtYWxpemVkIGNvbnRlbnQgaW50by5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xFbGVtZW50fFRleHROb2RlfEFycmF5fEZ1bmN0aW9ufSBjb250ZW50XG4gKiAgICAgICAgU2VlIHRoZSBgY29udGVudGAgYXJndW1lbnQgb2Yge0BsaW5rIGRvbTpub3JtYWxpemVDb250ZW50fVxuICpcbiAqIEByZXR1cm4ge0VsZW1lbnR9XG4gKiAgICAgICAgIFRoZSBlbGVtZW50IHdpdGggaW5zZXJ0ZWQgbm9ybWFsaXplZCBjb250ZW50LlxuICpcbiAqL1xuZnVuY3Rpb24gaW5zZXJ0Q29udGVudChlbCwgY29udGVudCkge1xuICByZXR1cm4gYXBwZW5kQ29udGVudChlbXB0eUVsKGVsKSwgY29udGVudCk7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgZXZlbnQgd2FzIGEgc2luZ2xlIGxlZnQgY2xpY2tcbiAqXG4gKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBldmVudFxuICogICAgICAgIEV2ZW50IG9iamVjdFxuICpcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKiAgICAgICAgIC0gVHJ1ZSBpZiBhIGxlZnQgY2xpY2tcbiAqICAgICAgICAgLSBGYWxzZSBpZiBub3QgYSBsZWZ0IGNsaWNrXG4gKi9cbmZ1bmN0aW9uIGlzU2luZ2xlTGVmdENsaWNrKGV2ZW50KSB7XG4gIC8vIE5vdGU6IGlmIHlvdSBjcmVhdGUgc29tZXRoaW5nIGRyYWdnYWJsZSwgYmUgc3VyZSB0b1xuICAvLyBjYWxsIGl0IG9uIGJvdGggYG1vdXNlZG93bmAgYW5kIGBtb3VzZW1vdmVgIGV2ZW50LFxuICAvLyBvdGhlcndpc2UgYG1vdXNlZG93bmAgc2hvdWxkIGJlIGVub3VnaCBmb3IgYSBidXR0b25cblxuICBpZiAoZXZlbnQuYnV0dG9uID09PSB1bmRlZmluZWQgJiYgZXZlbnQuYnV0dG9ucyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gV2h5IGRvIHdlIG5lZWQgYGJ1dHRvbnNgID9cbiAgICAvLyBCZWNhdXNlLCBtaWRkbGUgbW91c2Ugc29tZXRpbWVzIGhhdmUgdGhpczpcbiAgICAvLyBlLmJ1dHRvbiA9PT0gMCBhbmQgZS5idXR0b25zID09PSA0XG4gICAgLy8gRnVydGhlcm1vcmUsIHdlIHdhbnQgdG8gcHJldmVudCBjb21iaW5hdGlvbiBjbGljaywgc29tZXRoaW5nIGxpa2VcbiAgICAvLyBIT0xEIG1pZGRsZW1vdXNlIHRoZW4gbGVmdCBjbGljaywgdGhhdCB3b3VsZCBiZVxuICAgIC8vIGUuYnV0dG9uID09PSAwLCBlLmJ1dHRvbnMgPT09IDVcbiAgICAvLyBqdXN0IGBidXR0b25gIGlzIG5vdCBnb25uYSB3b3JrXG5cbiAgICAvLyBBbHJpZ2h0LCB0aGVuIHdoYXQgdGhpcyBibG9jayBkb2VzID9cbiAgICAvLyB0aGlzIGlzIGZvciBjaHJvbWUgYHNpbXVsYXRlIG1vYmlsZSBkZXZpY2VzYFxuICAgIC8vIEkgd2FudCB0byBzdXBwb3J0IHRoaXMgYXMgd2VsbFxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAoZXZlbnQuYnV0dG9uID09PSAwICYmIGV2ZW50LmJ1dHRvbnMgPT09IHVuZGVmaW5lZCkge1xuICAgIC8vIFRvdWNoIHNjcmVlbiwgc29tZXRpbWVzIG9uIHNvbWUgc3BlY2lmaWMgZGV2aWNlLCBgYnV0dG9uc2BcbiAgICAvLyBkb2Vzbid0IGhhdmUgYW55dGhpbmcgKHNhZmFyaSBvbiBpb3MsIGJsYWNrYmVycnkuLi4pXG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmIChJRV9WRVJTSU9OID09PSA5KSB7XG4gICAgLy8gSWdub3JlIElFOVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAoZXZlbnQuYnV0dG9uICE9PSAwIHx8IGV2ZW50LmJ1dHRvbnMgIT09IDEpIHtcbiAgICAvLyBUaGlzIGlzIHRoZSByZWFzb24gd2UgaGF2ZSB0aG9zZSBpZiBlbHNlIGJsb2NrIGFib3ZlXG4gICAgLy8gaWYgYW55IHNwZWNpYWwgY2FzZSB3ZSBjYW4gY2F0Y2ggYW5kIGxldCBpdCBzbGlkZVxuICAgIC8vIHdlIGRvIGl0IGFib3ZlLCB3aGVuIGdldCB0byBoZXJlLCB0aGlzIGRlZmluaXRlbHlcbiAgICAvLyBpcy1ub3QtbGVmdC1jbGlja1xuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogRmluZHMgYSBzaW5nbGUgRE9NIGVsZW1lbnQgbWF0Y2hpbmcgYHNlbGVjdG9yYCB3aXRoaW4gdGhlIG9wdGlvbmFsXG4gKiBgY29udGV4dGAgb2YgYW5vdGhlciBET00gZWxlbWVudCAoZGVmYXVsdGluZyB0byBgZG9jdW1lbnRgKS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc2VsZWN0b3JcbiAqICAgICAgICBBIHZhbGlkIENTUyBzZWxlY3Rvciwgd2hpY2ggd2lsbCBiZSBwYXNzZWQgdG8gYHF1ZXJ5U2VsZWN0b3JgLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudHxTdHJpbmd9IFtjb250ZXh0PWRvY3VtZW50XVxuICogICAgICAgIEEgRE9NIGVsZW1lbnQgd2l0aGluIHdoaWNoIHRvIHF1ZXJ5LiBDYW4gYWxzbyBiZSBhIHNlbGVjdG9yXG4gKiAgICAgICAgc3RyaW5nIGluIHdoaWNoIGNhc2UgdGhlIGZpcnN0IG1hdGNoaW5nIGVsZW1lbnQgd2lsbCBiZSB1c2VkXG4gKiAgICAgICAgYXMgY29udGV4dC4gSWYgbWlzc2luZyAob3Igbm8gZWxlbWVudCBtYXRjaGVzIHNlbGVjdG9yKSwgZmFsbHNcbiAqICAgICAgICBiYWNrIHRvIGBkb2N1bWVudGAuXG4gKlxuICogQHJldHVybiB7RWxlbWVudHxudWxsfVxuICogICAgICAgICBUaGUgZWxlbWVudCB0aGF0IHdhcyBmb3VuZCBvciBudWxsLlxuICovXG52YXIgJCA9IGNyZWF0ZVF1ZXJpZXIoJ3F1ZXJ5U2VsZWN0b3InKTtcblxuLyoqXG4gKiBGaW5kcyBhIGFsbCBET00gZWxlbWVudHMgbWF0Y2hpbmcgYHNlbGVjdG9yYCB3aXRoaW4gdGhlIG9wdGlvbmFsXG4gKiBgY29udGV4dGAgb2YgYW5vdGhlciBET00gZWxlbWVudCAoZGVmYXVsdGluZyB0byBgZG9jdW1lbnRgKS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc2VsZWN0b3JcbiAqICAgICAgICAgICBBIHZhbGlkIENTUyBzZWxlY3Rvciwgd2hpY2ggd2lsbCBiZSBwYXNzZWQgdG8gYHF1ZXJ5U2VsZWN0b3JBbGxgLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudHxTdHJpbmd9IFtjb250ZXh0PWRvY3VtZW50XVxuICogICAgICAgICAgIEEgRE9NIGVsZW1lbnQgd2l0aGluIHdoaWNoIHRvIHF1ZXJ5LiBDYW4gYWxzbyBiZSBhIHNlbGVjdG9yXG4gKiAgICAgICAgICAgc3RyaW5nIGluIHdoaWNoIGNhc2UgdGhlIGZpcnN0IG1hdGNoaW5nIGVsZW1lbnQgd2lsbCBiZSB1c2VkXG4gKiAgICAgICAgICAgYXMgY29udGV4dC4gSWYgbWlzc2luZyAob3Igbm8gZWxlbWVudCBtYXRjaGVzIHNlbGVjdG9yKSwgZmFsbHNcbiAqICAgICAgICAgICBiYWNrIHRvIGBkb2N1bWVudGAuXG4gKlxuICogQHJldHVybiB7Tm9kZUxpc3R9XG4gKiAgICAgICAgIEEgZWxlbWVudCBsaXN0IG9mIGVsZW1lbnRzIHRoYXQgd2VyZSBmb3VuZC4gV2lsbCBiZSBlbXB0eSBpZiBub25lIHdlcmUgZm91bmQuXG4gKlxuICovXG52YXIgJCQgPSBjcmVhdGVRdWVyaWVyKCdxdWVyeVNlbGVjdG9yQWxsJyk7XG5cblxuXG52YXIgRG9tID0gKE9iamVjdC5mcmVlemUgfHwgT2JqZWN0KSh7XG5cdGlzUmVhbDogaXNSZWFsLFxuXHRpc0VsOiBpc0VsLFxuXHRpc0luRnJhbWU6IGlzSW5GcmFtZSxcblx0Y3JlYXRlRWw6IGNyZWF0ZUVsLFxuXHR0ZXh0Q29udGVudDogdGV4dENvbnRlbnQsXG5cdHByZXBlbmRUbzogcHJlcGVuZFRvLFxuXHRoYXNDbGFzczogaGFzQ2xhc3MsXG5cdGFkZENsYXNzOiBhZGRDbGFzcyxcblx0cmVtb3ZlQ2xhc3M6IHJlbW92ZUNsYXNzLFxuXHR0b2dnbGVDbGFzczogdG9nZ2xlQ2xhc3MsXG5cdHNldEF0dHJpYnV0ZXM6IHNldEF0dHJpYnV0ZXMsXG5cdGdldEF0dHJpYnV0ZXM6IGdldEF0dHJpYnV0ZXMsXG5cdGdldEF0dHJpYnV0ZTogZ2V0QXR0cmlidXRlLFxuXHRzZXRBdHRyaWJ1dGU6IHNldEF0dHJpYnV0ZSxcblx0cmVtb3ZlQXR0cmlidXRlOiByZW1vdmVBdHRyaWJ1dGUsXG5cdGJsb2NrVGV4dFNlbGVjdGlvbjogYmxvY2tUZXh0U2VsZWN0aW9uLFxuXHR1bmJsb2NrVGV4dFNlbGVjdGlvbjogdW5ibG9ja1RleHRTZWxlY3Rpb24sXG5cdGdldEJvdW5kaW5nQ2xpZW50UmVjdDogZ2V0Qm91bmRpbmdDbGllbnRSZWN0LFxuXHRmaW5kUG9zaXRpb246IGZpbmRQb3NpdGlvbixcblx0Z2V0UG9pbnRlclBvc2l0aW9uOiBnZXRQb2ludGVyUG9zaXRpb24sXG5cdGlzVGV4dE5vZGU6IGlzVGV4dE5vZGUsXG5cdGVtcHR5RWw6IGVtcHR5RWwsXG5cdG5vcm1hbGl6ZUNvbnRlbnQ6IG5vcm1hbGl6ZUNvbnRlbnQsXG5cdGFwcGVuZENvbnRlbnQ6IGFwcGVuZENvbnRlbnQsXG5cdGluc2VydENvbnRlbnQ6IGluc2VydENvbnRlbnQsXG5cdGlzU2luZ2xlTGVmdENsaWNrOiBpc1NpbmdsZUxlZnRDbGljayxcblx0JDogJCxcblx0JCQ6ICQkXG59KTtcblxuLyoqXG4gKiBAZmlsZSBndWlkLmpzXG4gKiBAbW9kdWxlIGd1aWRcbiAqL1xuXG4vKipcbiAqIFVuaXF1ZSBJRCBmb3IgYW4gZWxlbWVudCBvciBmdW5jdGlvblxuICogQHR5cGUge051bWJlcn1cbiAqL1xudmFyIF9ndWlkID0gMTtcblxuLyoqXG4gKiBHZXQgYSB1bmlxdWUgYXV0by1pbmNyZW1lbnRpbmcgSUQgYnkgbnVtYmVyIHRoYXQgaGFzIG5vdCBiZWVuIHJldHVybmVkIGJlZm9yZS5cbiAqXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKiAgICAgICAgIEEgbmV3IHVuaXF1ZSBJRC5cbiAqL1xuZnVuY3Rpb24gbmV3R1VJRCgpIHtcbiAgcmV0dXJuIF9ndWlkKys7XG59XG5cbi8qKlxuICogQGZpbGUgZG9tLWRhdGEuanNcbiAqIEBtb2R1bGUgZG9tLWRhdGFcbiAqL1xuLyoqXG4gKiBFbGVtZW50IERhdGEgU3RvcmUuXG4gKlxuICogQWxsb3dzIGZvciBiaW5kaW5nIGRhdGEgdG8gYW4gZWxlbWVudCB3aXRob3V0IHB1dHRpbmcgaXQgZGlyZWN0bHkgb24gdGhlXG4gKiBlbGVtZW50LiBFeC4gRXZlbnQgbGlzdGVuZXJzIGFyZSBzdG9yZWQgaGVyZS5cbiAqIChhbHNvIGZyb20ganNuaW5qYS5jb20sIHNsaWdodGx5IG1vZGlmaWVkIGFuZCB1cGRhdGVkIGZvciBjbG9zdXJlIGNvbXBpbGVyKVxuICpcbiAqIEB0eXBlIHtPYmplY3R9XG4gKiBAcHJpdmF0ZVxuICovXG52YXIgZWxEYXRhID0ge307XG5cbi8qXG4gKiBVbmlxdWUgYXR0cmlidXRlIG5hbWUgdG8gc3RvcmUgYW4gZWxlbWVudCdzIGd1aWQgaW5cbiAqXG4gKiBAdHlwZSB7U3RyaW5nfVxuICogQGNvbnN0YW50XG4gKiBAcHJpdmF0ZVxuICovXG52YXIgZWxJZEF0dHIgPSAndmRhdGEnICsgbmV3IERhdGUoKS5nZXRUaW1lKCk7XG5cbi8qKlxuICogUmV0dXJucyB0aGUgY2FjaGUgb2JqZWN0IHdoZXJlIGRhdGEgZm9yIGFuIGVsZW1lbnQgaXMgc3RvcmVkXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogICAgICAgIEVsZW1lbnQgdG8gc3RvcmUgZGF0YSBmb3IuXG4gKlxuICogQHJldHVybiB7T2JqZWN0fVxuICogICAgICAgICBUaGUgY2FjaGUgb2JqZWN0IGZvciB0aGF0IGVsIHRoYXQgd2FzIHBhc3NlZCBpbi5cbiAqL1xuZnVuY3Rpb24gZ2V0RGF0YShlbCkge1xuICB2YXIgaWQgPSBlbFtlbElkQXR0cl07XG5cbiAgaWYgKCFpZCkge1xuICAgIGlkID0gZWxbZWxJZEF0dHJdID0gbmV3R1VJRCgpO1xuICB9XG5cbiAgaWYgKCFlbERhdGFbaWRdKSB7XG4gICAgZWxEYXRhW2lkXSA9IHt9O1xuICB9XG5cbiAgcmV0dXJuIGVsRGF0YVtpZF07XG59XG5cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCBhbiBlbGVtZW50IGhhcyBjYWNoZWQgZGF0YVxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqICAgICAgICBDaGVjayBpZiB0aGlzIGVsZW1lbnQgaGFzIGNhY2hlZCBkYXRhLlxuICpcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKiAgICAgICAgIC0gVHJ1ZSBpZiB0aGUgRE9NIGVsZW1lbnQgaGFzIGNhY2hlZCBkYXRhLlxuICogICAgICAgICAtIEZhbHNlIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gaGFzRGF0YShlbCkge1xuICB2YXIgaWQgPSBlbFtlbElkQXR0cl07XG5cbiAgaWYgKCFpZCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiAhIU9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGVsRGF0YVtpZF0pLmxlbmd0aDtcbn1cblxuLyoqXG4gKiBEZWxldGUgZGF0YSBmb3IgdGhlIGVsZW1lbnQgZnJvbSB0aGUgY2FjaGUgYW5kIHRoZSBndWlkIGF0dHIgZnJvbSBnZXRFbGVtZW50QnlJZFxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqICAgICAgICBSZW1vdmUgY2FjaGVkIGRhdGEgZm9yIHRoaXMgZWxlbWVudC5cbiAqL1xuZnVuY3Rpb24gcmVtb3ZlRGF0YShlbCkge1xuICB2YXIgaWQgPSBlbFtlbElkQXR0cl07XG5cbiAgaWYgKCFpZCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIFJlbW92ZSBhbGwgc3RvcmVkIGRhdGFcbiAgZGVsZXRlIGVsRGF0YVtpZF07XG5cbiAgLy8gUmVtb3ZlIHRoZSBlbElkQXR0ciBwcm9wZXJ0eSBmcm9tIHRoZSBET00gbm9kZVxuICB0cnkge1xuICAgIGRlbGV0ZSBlbFtlbElkQXR0cl07XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAoZWwucmVtb3ZlQXR0cmlidXRlKSB7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoZWxJZEF0dHIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJRSBkb2Vzbid0IGFwcGVhciB0byBzdXBwb3J0IHJlbW92ZUF0dHJpYnV0ZSBvbiB0aGUgZG9jdW1lbnQgZWxlbWVudFxuICAgICAgZWxbZWxJZEF0dHJdID0gbnVsbDtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBAZmlsZSBldmVudHMuanMuIEFuIEV2ZW50IFN5c3RlbSAoSm9obiBSZXNpZyAtIFNlY3JldHMgb2YgYSBKUyBOaW5qYSBodHRwOi8vanNuaW5qYS5jb20vKVxuICogKE9yaWdpbmFsIGJvb2sgdmVyc2lvbiB3YXNuJ3QgY29tcGxldGVseSB1c2FibGUsIHNvIGZpeGVkIHNvbWUgdGhpbmdzIGFuZCBtYWRlIENsb3N1cmUgQ29tcGlsZXIgY29tcGF0aWJsZSlcbiAqIFRoaXMgc2hvdWxkIHdvcmsgdmVyeSBzaW1pbGFybHkgdG8galF1ZXJ5J3MgZXZlbnRzLCBob3dldmVyIGl0J3MgYmFzZWQgb2ZmIHRoZSBib29rIHZlcnNpb24gd2hpY2ggaXNuJ3QgYXNcbiAqIHJvYnVzdCBhcyBqcXVlcnkncywgc28gdGhlcmUncyBwcm9iYWJseSBzb21lIGRpZmZlcmVuY2VzLlxuICpcbiAqIEBtb2R1bGUgZXZlbnRzXG4gKi9cblxuLyoqXG4gKiBDbGVhbiB1cCB0aGUgbGlzdGVuZXIgY2FjaGUgYW5kIGRpc3BhdGNoZXJzXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fE9iamVjdH0gZWxlbVxuICogICAgICAgIEVsZW1lbnQgdG8gY2xlYW4gdXBcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICogICAgICAgIFR5cGUgb2YgZXZlbnQgdG8gY2xlYW4gdXBcbiAqL1xuZnVuY3Rpb24gX2NsZWFuVXBFdmVudHMoZWxlbSwgdHlwZSkge1xuICB2YXIgZGF0YSA9IGdldERhdGEoZWxlbSk7XG5cbiAgLy8gUmVtb3ZlIHRoZSBldmVudHMgb2YgYSBwYXJ0aWN1bGFyIHR5cGUgaWYgdGhlcmUgYXJlIG5vbmUgbGVmdFxuICBpZiAoZGF0YS5oYW5kbGVyc1t0eXBlXS5sZW5ndGggPT09IDApIHtcbiAgICBkZWxldGUgZGF0YS5oYW5kbGVyc1t0eXBlXTtcbiAgICAvLyBkYXRhLmhhbmRsZXJzW3R5cGVdID0gbnVsbDtcbiAgICAvLyBTZXR0aW5nIHRvIG51bGwgd2FzIGNhdXNpbmcgYW4gZXJyb3Igd2l0aCBkYXRhLmhhbmRsZXJzXG5cbiAgICAvLyBSZW1vdmUgdGhlIG1ldGEtaGFuZGxlciBmcm9tIHRoZSBlbGVtZW50XG4gICAgaWYgKGVsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lcikge1xuICAgICAgZWxlbS5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGRhdGEuZGlzcGF0Y2hlciwgZmFsc2UpO1xuICAgIH0gZWxzZSBpZiAoZWxlbS5kZXRhY2hFdmVudCkge1xuICAgICAgZWxlbS5kZXRhY2hFdmVudCgnb24nICsgdHlwZSwgZGF0YS5kaXNwYXRjaGVyKTtcbiAgICB9XG4gIH1cblxuICAvLyBSZW1vdmUgdGhlIGV2ZW50cyBvYmplY3QgaWYgdGhlcmUgYXJlIG5vIHR5cGVzIGxlZnRcbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGRhdGEuaGFuZGxlcnMpLmxlbmd0aCA8PSAwKSB7XG4gICAgZGVsZXRlIGRhdGEuaGFuZGxlcnM7XG4gICAgZGVsZXRlIGRhdGEuZGlzcGF0Y2hlcjtcbiAgICBkZWxldGUgZGF0YS5kaXNhYmxlZDtcbiAgfVxuXG4gIC8vIEZpbmFsbHkgcmVtb3ZlIHRoZSBlbGVtZW50IGRhdGEgaWYgdGhlcmUgaXMgbm8gZGF0YSBsZWZ0XG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhkYXRhKS5sZW5ndGggPT09IDApIHtcbiAgICByZW1vdmVEYXRhKGVsZW0pO1xuICB9XG59XG5cbi8qKlxuICogTG9vcHMgdGhyb3VnaCBhbiBhcnJheSBvZiBldmVudCB0eXBlcyBhbmQgY2FsbHMgdGhlIHJlcXVlc3RlZCBtZXRob2QgZm9yIGVhY2ggdHlwZS5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogICAgICAgIFRoZSBldmVudCBtZXRob2Qgd2Ugd2FudCB0byB1c2UuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fE9iamVjdH0gZWxlbVxuICogICAgICAgIEVsZW1lbnQgb3Igb2JqZWN0IHRvIGJpbmQgbGlzdGVuZXJzIHRvXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAqICAgICAgICBUeXBlIG9mIGV2ZW50IHRvIGJpbmQgdG8uXG4gKlxuICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudExpc3RlbmVyfSBjYWxsYmFja1xuICogICAgICAgIEV2ZW50IGxpc3RlbmVyLlxuICovXG5mdW5jdGlvbiBfaGFuZGxlTXVsdGlwbGVFdmVudHMoZm4sIGVsZW0sIHR5cGVzLCBjYWxsYmFjaykge1xuICB0eXBlcy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgLy8gQ2FsbCB0aGUgZXZlbnQgbWV0aG9kIGZvciBlYWNoIG9uZSBvZiB0aGUgdHlwZXNcbiAgICBmbihlbGVtLCB0eXBlLCBjYWxsYmFjayk7XG4gIH0pO1xufVxuXG4vKipcbiAqIEZpeCBhIG5hdGl2ZSBldmVudCB0byBoYXZlIHN0YW5kYXJkIHByb3BlcnR5IHZhbHVlc1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBldmVudFxuICogICAgICAgIEV2ZW50IG9iamVjdCB0byBmaXguXG4gKlxuICogQHJldHVybiB7T2JqZWN0fVxuICogICAgICAgICBGaXhlZCBldmVudCBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGZpeEV2ZW50KGV2ZW50KSB7XG5cbiAgZnVuY3Rpb24gcmV0dXJuVHJ1ZSgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJldHVybkZhbHNlKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIFRlc3QgaWYgZml4aW5nIHVwIGlzIG5lZWRlZFxuICAvLyBVc2VkIHRvIGNoZWNrIGlmICFldmVudC5zdG9wUHJvcGFnYXRpb24gaW5zdGVhZCBvZiBpc1Byb3BhZ2F0aW9uU3RvcHBlZFxuICAvLyBCdXQgbmF0aXZlIGV2ZW50cyByZXR1cm4gdHJ1ZSBmb3Igc3RvcFByb3BhZ2F0aW9uLCBidXQgZG9uJ3QgaGF2ZVxuICAvLyBvdGhlciBleHBlY3RlZCBtZXRob2RzIGxpa2UgaXNQcm9wYWdhdGlvblN0b3BwZWQuIFNlZW1zIHRvIGJlIGEgcHJvYmxlbVxuICAvLyB3aXRoIHRoZSBKYXZhc2NyaXB0IE5pbmphIGNvZGUuIFNvIHdlJ3JlIGp1c3Qgb3ZlcnJpZGluZyBhbGwgZXZlbnRzIG5vdy5cbiAgaWYgKCFldmVudCB8fCAhZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQpIHtcbiAgICB2YXIgb2xkID0gZXZlbnQgfHwgd2luZG93LmV2ZW50O1xuXG4gICAgZXZlbnQgPSB7fTtcbiAgICAvLyBDbG9uZSB0aGUgb2xkIG9iamVjdCBzbyB0aGF0IHdlIGNhbiBtb2RpZnkgdGhlIHZhbHVlcyBldmVudCA9IHt9O1xuICAgIC8vIElFOCBEb2Vzbid0IGxpa2Ugd2hlbiB5b3UgbWVzcyB3aXRoIG5hdGl2ZSBldmVudCBwcm9wZXJ0aWVzXG4gICAgLy8gRmlyZWZveCByZXR1cm5zIGZhbHNlIGZvciBldmVudC5oYXNPd25Qcm9wZXJ0eSgndHlwZScpIGFuZCBvdGhlciBwcm9wc1xuICAgIC8vICB3aGljaCBtYWtlcyBjb3B5aW5nIG1vcmUgZGlmZmljdWx0LlxuICAgIC8vIFRPRE86IFByb2JhYmx5IGJlc3QgdG8gY3JlYXRlIGEgd2hpdGVsaXN0IG9mIGV2ZW50IHByb3BzXG4gICAgZm9yICh2YXIga2V5IGluIG9sZCkge1xuICAgICAgLy8gU2FmYXJpIDYuMC4zIHdhcm5zIHlvdSBpZiB5b3UgdHJ5IHRvIGNvcHkgZGVwcmVjYXRlZCBsYXllclgvWVxuICAgICAgLy8gQ2hyb21lIHdhcm5zIHlvdSBpZiB5b3UgdHJ5IHRvIGNvcHkgZGVwcmVjYXRlZCBrZXlib2FyZEV2ZW50LmtleUxvY2F0aW9uXG4gICAgICAvLyBhbmQgd2Via2l0TW92ZW1lbnRYL1lcbiAgICAgIGlmIChrZXkgIT09ICdsYXllclgnICYmIGtleSAhPT0gJ2xheWVyWScgJiYga2V5ICE9PSAna2V5TG9jYXRpb24nICYmIGtleSAhPT0gJ3dlYmtpdE1vdmVtZW50WCcgJiYga2V5ICE9PSAnd2Via2l0TW92ZW1lbnRZJykge1xuICAgICAgICAvLyBDaHJvbWUgMzIrIHdhcm5zIGlmIHlvdSB0cnkgdG8gY29weSBkZXByZWNhdGVkIHJldHVyblZhbHVlLCBidXRcbiAgICAgICAgLy8gd2Ugc3RpbGwgd2FudCB0byBpZiBwcmV2ZW50RGVmYXVsdCBpc24ndCBzdXBwb3J0ZWQgKElFOCkuXG4gICAgICAgIGlmICghKGtleSA9PT0gJ3JldHVyblZhbHVlJyAmJiBvbGQucHJldmVudERlZmF1bHQpKSB7XG4gICAgICAgICAgZXZlbnRba2V5XSA9IG9sZFtrZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gVGhlIGV2ZW50IG9jY3VycmVkIG9uIHRoaXMgZWxlbWVudFxuICAgIGlmICghZXZlbnQudGFyZ2V0KSB7XG4gICAgICBldmVudC50YXJnZXQgPSBldmVudC5zcmNFbGVtZW50IHx8IGRvY3VtZW50O1xuICAgIH1cblxuICAgIC8vIEhhbmRsZSB3aGljaCBvdGhlciBlbGVtZW50IHRoZSBldmVudCBpcyByZWxhdGVkIHRvXG4gICAgaWYgKCFldmVudC5yZWxhdGVkVGFyZ2V0KSB7XG4gICAgICBldmVudC5yZWxhdGVkVGFyZ2V0ID0gZXZlbnQuZnJvbUVsZW1lbnQgPT09IGV2ZW50LnRhcmdldCA/IGV2ZW50LnRvRWxlbWVudCA6IGV2ZW50LmZyb21FbGVtZW50O1xuICAgIH1cblxuICAgIC8vIFN0b3AgdGhlIGRlZmF1bHQgYnJvd3NlciBhY3Rpb25cbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChvbGQucHJldmVudERlZmF1bHQpIHtcbiAgICAgICAgb2xkLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9XG4gICAgICBldmVudC5yZXR1cm5WYWx1ZSA9IGZhbHNlO1xuICAgICAgb2xkLnJldHVyblZhbHVlID0gZmFsc2U7XG4gICAgICBldmVudC5kZWZhdWx0UHJldmVudGVkID0gdHJ1ZTtcbiAgICB9O1xuXG4gICAgZXZlbnQuZGVmYXVsdFByZXZlbnRlZCA9IGZhbHNlO1xuXG4gICAgLy8gU3RvcCB0aGUgZXZlbnQgZnJvbSBidWJibGluZ1xuICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChvbGQuc3RvcFByb3BhZ2F0aW9uKSB7XG4gICAgICAgIG9sZC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIH1cbiAgICAgIGV2ZW50LmNhbmNlbEJ1YmJsZSA9IHRydWU7XG4gICAgICBvbGQuY2FuY2VsQnViYmxlID0gdHJ1ZTtcbiAgICAgIGV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkID0gcmV0dXJuVHJ1ZTtcbiAgICB9O1xuXG4gICAgZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQgPSByZXR1cm5GYWxzZTtcblxuICAgIC8vIFN0b3AgdGhlIGV2ZW50IGZyb20gYnViYmxpbmcgYW5kIGV4ZWN1dGluZyBvdGhlciBoYW5kbGVyc1xuICAgIGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChvbGQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKSB7XG4gICAgICAgIG9sZC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICAgIH1cbiAgICAgIGV2ZW50LmlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkID0gcmV0dXJuVHJ1ZTtcbiAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH07XG5cbiAgICBldmVudC5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCA9IHJldHVybkZhbHNlO1xuXG4gICAgLy8gSGFuZGxlIG1vdXNlIHBvc2l0aW9uXG4gICAgaWYgKGV2ZW50LmNsaWVudFggIT09IG51bGwgJiYgZXZlbnQuY2xpZW50WCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YXIgZG9jID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgdmFyIGJvZHkgPSBkb2N1bWVudC5ib2R5O1xuXG4gICAgICBldmVudC5wYWdlWCA9IGV2ZW50LmNsaWVudFggKyAoZG9jICYmIGRvYy5zY3JvbGxMZWZ0IHx8IGJvZHkgJiYgYm9keS5zY3JvbGxMZWZ0IHx8IDApIC0gKGRvYyAmJiBkb2MuY2xpZW50TGVmdCB8fCBib2R5ICYmIGJvZHkuY2xpZW50TGVmdCB8fCAwKTtcbiAgICAgIGV2ZW50LnBhZ2VZID0gZXZlbnQuY2xpZW50WSArIChkb2MgJiYgZG9jLnNjcm9sbFRvcCB8fCBib2R5ICYmIGJvZHkuc2Nyb2xsVG9wIHx8IDApIC0gKGRvYyAmJiBkb2MuY2xpZW50VG9wIHx8IGJvZHkgJiYgYm9keS5jbGllbnRUb3AgfHwgMCk7XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIGtleSBwcmVzc2VzXG4gICAgZXZlbnQud2hpY2ggPSBldmVudC5jaGFyQ29kZSB8fCBldmVudC5rZXlDb2RlO1xuXG4gICAgLy8gRml4IGJ1dHRvbiBmb3IgbW91c2UgY2xpY2tzOlxuICAgIC8vIDAgPT0gbGVmdDsgMSA9PSBtaWRkbGU7IDIgPT0gcmlnaHRcbiAgICBpZiAoZXZlbnQuYnV0dG9uICE9PSBudWxsICYmIGV2ZW50LmJ1dHRvbiAhPT0gdW5kZWZpbmVkKSB7XG5cbiAgICAgIC8vIFRoZSBmb2xsb3dpbmcgaXMgZGlzYWJsZWQgYmVjYXVzZSBpdCBkb2VzIG5vdCBwYXNzIHZpZGVvanMtc3RhbmRhcmRcbiAgICAgIC8vIGFuZC4uLiB5aWtlcy5cbiAgICAgIC8qIGVzbGludC1kaXNhYmxlICovXG4gICAgICBldmVudC5idXR0b24gPSBldmVudC5idXR0b24gJiAxID8gMCA6IGV2ZW50LmJ1dHRvbiAmIDQgPyAxIDogZXZlbnQuYnV0dG9uICYgMiA/IDIgOiAwO1xuICAgICAgLyogZXNsaW50LWVuYWJsZSAqL1xuICAgIH1cbiAgfVxuXG4gIC8vIFJldHVybnMgZml4ZWQtdXAgaW5zdGFuY2VcbiAgcmV0dXJuIGV2ZW50O1xufVxuXG4vKipcbiAqIFdoZXRoZXIgcGFzc2l2ZSBldmVudCBsaXN0ZW5lcnMgYXJlIHN1cHBvcnRlZFxuICovXG52YXIgX3N1cHBvcnRzUGFzc2l2ZSA9IGZhbHNlO1xuXG4oZnVuY3Rpb24gKCkge1xuICB0cnkge1xuICAgIHZhciBvcHRzID0gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAncGFzc2l2ZScsIHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICBfc3VwcG9ydHNQYXNzaXZlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0ZXN0JywgbnVsbCwgb3B0cyk7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Rlc3QnLCBudWxsLCBvcHRzKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIGRpc3JlZ2FyZFxuICB9XG59KSgpO1xuXG4vKipcbiAqIFRvdWNoIGV2ZW50cyBDaHJvbWUgZXhwZWN0cyB0byBiZSBwYXNzaXZlXG4gKi9cbnZhciBwYXNzaXZlRXZlbnRzID0gWyd0b3VjaHN0YXJ0JywgJ3RvdWNobW92ZSddO1xuXG4vKipcbiAqIEFkZCBhbiBldmVudCBsaXN0ZW5lciB0byBlbGVtZW50XG4gKiBJdCBzdG9yZXMgdGhlIGhhbmRsZXIgZnVuY3Rpb24gaW4gYSBzZXBhcmF0ZSBjYWNoZSBvYmplY3RcbiAqIGFuZCBhZGRzIGEgZ2VuZXJpYyBoYW5kbGVyIHRvIHRoZSBlbGVtZW50J3MgZXZlbnQsXG4gKiBhbG9uZyB3aXRoIGEgdW5pcXVlIGlkIChndWlkKSB0byB0aGUgZWxlbWVudC5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR8T2JqZWN0fSBlbGVtXG4gKiAgICAgICAgRWxlbWVudCBvciBvYmplY3QgdG8gYmluZCBsaXN0ZW5lcnMgdG9cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXX0gdHlwZVxuICogICAgICAgIFR5cGUgb2YgZXZlbnQgdG8gYmluZCB0by5cbiAqXG4gKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50TGlzdGVuZXJ9IGZuXG4gKiAgICAgICAgRXZlbnQgbGlzdGVuZXIuXG4gKi9cbmZ1bmN0aW9uIG9uKGVsZW0sIHR5cGUsIGZuKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHR5cGUpKSB7XG4gICAgcmV0dXJuIF9oYW5kbGVNdWx0aXBsZUV2ZW50cyhvbiwgZWxlbSwgdHlwZSwgZm4pO1xuICB9XG5cbiAgdmFyIGRhdGEgPSBnZXREYXRhKGVsZW0pO1xuXG4gIC8vIFdlIG5lZWQgYSBwbGFjZSB0byBzdG9yZSBhbGwgb3VyIGhhbmRsZXIgZGF0YVxuICBpZiAoIWRhdGEuaGFuZGxlcnMpIHtcbiAgICBkYXRhLmhhbmRsZXJzID0ge307XG4gIH1cblxuICBpZiAoIWRhdGEuaGFuZGxlcnNbdHlwZV0pIHtcbiAgICBkYXRhLmhhbmRsZXJzW3R5cGVdID0gW107XG4gIH1cblxuICBpZiAoIWZuLmd1aWQpIHtcbiAgICBmbi5ndWlkID0gbmV3R1VJRCgpO1xuICB9XG5cbiAgZGF0YS5oYW5kbGVyc1t0eXBlXS5wdXNoKGZuKTtcblxuICBpZiAoIWRhdGEuZGlzcGF0Y2hlcikge1xuICAgIGRhdGEuZGlzYWJsZWQgPSBmYWxzZTtcblxuICAgIGRhdGEuZGlzcGF0Y2hlciA9IGZ1bmN0aW9uIChldmVudCwgaGFzaCkge1xuXG4gICAgICBpZiAoZGF0YS5kaXNhYmxlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGV2ZW50ID0gZml4RXZlbnQoZXZlbnQpO1xuXG4gICAgICB2YXIgaGFuZGxlcnMgPSBkYXRhLmhhbmRsZXJzW2V2ZW50LnR5cGVdO1xuXG4gICAgICBpZiAoaGFuZGxlcnMpIHtcbiAgICAgICAgLy8gQ29weSBoYW5kbGVycyBzbyBpZiBoYW5kbGVycyBhcmUgYWRkZWQvcmVtb3ZlZCBkdXJpbmcgdGhlIHByb2Nlc3MgaXQgZG9lc24ndCB0aHJvdyBldmVyeXRoaW5nIG9mZi5cbiAgICAgICAgdmFyIGhhbmRsZXJzQ29weSA9IGhhbmRsZXJzLnNsaWNlKDApO1xuXG4gICAgICAgIGZvciAodmFyIG0gPSAwLCBuID0gaGFuZGxlcnNDb3B5Lmxlbmd0aDsgbSA8IG47IG0rKykge1xuICAgICAgICAgIGlmIChldmVudC5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCgpKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgaGFuZGxlcnNDb3B5W21dLmNhbGwoZWxlbSwgZXZlbnQsIGhhc2gpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICBsb2cuZXJyb3IoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIGlmIChkYXRhLmhhbmRsZXJzW3R5cGVdLmxlbmd0aCA9PT0gMSkge1xuICAgIGlmIChlbGVtLmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgIHZhciBvcHRpb25zID0gZmFsc2U7XG5cbiAgICAgIGlmIChfc3VwcG9ydHNQYXNzaXZlICYmIHBhc3NpdmVFdmVudHMuaW5kZXhPZih0eXBlKSA+IC0xKSB7XG4gICAgICAgIG9wdGlvbnMgPSB7IHBhc3NpdmU6IHRydWUgfTtcbiAgICAgIH1cbiAgICAgIGVsZW0uYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBkYXRhLmRpc3BhdGNoZXIsIG9wdGlvbnMpO1xuICAgIH0gZWxzZSBpZiAoZWxlbS5hdHRhY2hFdmVudCkge1xuICAgICAgZWxlbS5hdHRhY2hFdmVudCgnb24nICsgdHlwZSwgZGF0YS5kaXNwYXRjaGVyKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBSZW1vdmVzIGV2ZW50IGxpc3RlbmVycyBmcm9tIGFuIGVsZW1lbnRcbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR8T2JqZWN0fSBlbGVtXG4gKiAgICAgICAgT2JqZWN0IHRvIHJlbW92ZSBsaXN0ZW5lcnMgZnJvbS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXX0gW3R5cGVdXG4gKiAgICAgICAgVHlwZSBvZiBsaXN0ZW5lciB0byByZW1vdmUuIERvbid0IGluY2x1ZGUgdG8gcmVtb3ZlIGFsbCBldmVudHMgZnJvbSBlbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnRMaXN0ZW5lcn0gW2ZuXVxuICogICAgICAgIFNwZWNpZmljIGxpc3RlbmVyIHRvIHJlbW92ZS4gRG9uJ3QgaW5jbHVkZSB0byByZW1vdmUgbGlzdGVuZXJzIGZvciBhbiBldmVudFxuICogICAgICAgIHR5cGUuXG4gKi9cbmZ1bmN0aW9uIG9mZihlbGVtLCB0eXBlLCBmbikge1xuICAvLyBEb24ndCB3YW50IHRvIGFkZCBhIGNhY2hlIG9iamVjdCB0aHJvdWdoIGdldEVsRGF0YSBpZiBub3QgbmVlZGVkXG4gIGlmICghaGFzRGF0YShlbGVtKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBkYXRhID0gZ2V0RGF0YShlbGVtKTtcblxuICAvLyBJZiBubyBldmVudHMgZXhpc3QsIG5vdGhpbmcgdG8gdW5iaW5kXG4gIGlmICghZGF0YS5oYW5kbGVycykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KHR5cGUpKSB7XG4gICAgcmV0dXJuIF9oYW5kbGVNdWx0aXBsZUV2ZW50cyhvZmYsIGVsZW0sIHR5cGUsIGZuKTtcbiAgfVxuXG4gIC8vIFV0aWxpdHkgZnVuY3Rpb25cbiAgdmFyIHJlbW92ZVR5cGUgPSBmdW5jdGlvbiByZW1vdmVUeXBlKGVsLCB0KSB7XG4gICAgZGF0YS5oYW5kbGVyc1t0XSA9IFtdO1xuICAgIF9jbGVhblVwRXZlbnRzKGVsLCB0KTtcbiAgfTtcblxuICAvLyBBcmUgd2UgcmVtb3ZpbmcgYWxsIGJvdW5kIGV2ZW50cz9cbiAgaWYgKHR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgIGZvciAodmFyIHQgaW4gZGF0YS5oYW5kbGVycykge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLmhhbmRsZXJzIHx8IHt9LCB0KSkge1xuICAgICAgICByZW1vdmVUeXBlKGVsZW0sIHQpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgaGFuZGxlcnMgPSBkYXRhLmhhbmRsZXJzW3R5cGVdO1xuXG4gIC8vIElmIG5vIGhhbmRsZXJzIGV4aXN0LCBub3RoaW5nIHRvIHVuYmluZFxuICBpZiAoIWhhbmRsZXJzKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gSWYgbm8gbGlzdGVuZXIgd2FzIHByb3ZpZGVkLCByZW1vdmUgYWxsIGxpc3RlbmVycyBmb3IgdHlwZVxuICBpZiAoIWZuKSB7XG4gICAgcmVtb3ZlVHlwZShlbGVtLCB0eXBlKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBXZSdyZSBvbmx5IHJlbW92aW5nIGEgc2luZ2xlIGhhbmRsZXJcbiAgaWYgKGZuLmd1aWQpIHtcbiAgICBmb3IgKHZhciBuID0gMDsgbiA8IGhhbmRsZXJzLmxlbmd0aDsgbisrKSB7XG4gICAgICBpZiAoaGFuZGxlcnNbbl0uZ3VpZCA9PT0gZm4uZ3VpZCkge1xuICAgICAgICBoYW5kbGVycy5zcGxpY2Uobi0tLCAxKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBfY2xlYW5VcEV2ZW50cyhlbGVtLCB0eXBlKTtcbn1cblxuLyoqXG4gKiBUcmlnZ2VyIGFuIGV2ZW50IGZvciBhbiBlbGVtZW50XG4gKlxuICogQHBhcmFtIHtFbGVtZW50fE9iamVjdH0gZWxlbVxuICogICAgICAgIEVsZW1lbnQgdG8gdHJpZ2dlciBhbiBldmVudCBvblxuICpcbiAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR8c3RyaW5nfSBldmVudFxuICogICAgICAgIEEgc3RyaW5nICh0aGUgdHlwZSkgb3IgYW4gZXZlbnQgb2JqZWN0IHdpdGggYSB0eXBlIGF0dHJpYnV0ZVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbaGFzaF1cbiAqICAgICAgICBkYXRhIGhhc2ggdG8gcGFzcyBhbG9uZyB3aXRoIHRoZSBldmVudFxuICpcbiAqIEByZXR1cm4ge2Jvb2xlYW58dW5kZWZpbmVkfVxuICogICAgICAgICAtIFJldHVybnMgdGhlIG9wcG9zaXRlIG9mIGBkZWZhdWx0UHJldmVudGVkYCBpZiBkZWZhdWx0IHdhcyBwcmV2ZW50ZWRcbiAqICAgICAgICAgLSBPdGhlcndpc2UgcmV0dXJucyB1bmRlZmluZWRcbiAqL1xuZnVuY3Rpb24gdHJpZ2dlcihlbGVtLCBldmVudCwgaGFzaCkge1xuICAvLyBGZXRjaGVzIGVsZW1lbnQgZGF0YSBhbmQgYSByZWZlcmVuY2UgdG8gdGhlIHBhcmVudCAoZm9yIGJ1YmJsaW5nKS5cbiAgLy8gRG9uJ3Qgd2FudCB0byBhZGQgYSBkYXRhIG9iamVjdCB0byBjYWNoZSBmb3IgZXZlcnkgcGFyZW50LFxuICAvLyBzbyBjaGVja2luZyBoYXNFbERhdGEgZmlyc3QuXG4gIHZhciBlbGVtRGF0YSA9IGhhc0RhdGEoZWxlbSkgPyBnZXREYXRhKGVsZW0pIDoge307XG4gIHZhciBwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGUgfHwgZWxlbS5vd25lckRvY3VtZW50O1xuICAvLyB0eXBlID0gZXZlbnQudHlwZSB8fCBldmVudCxcbiAgLy8gaGFuZGxlcjtcblxuICAvLyBJZiBhbiBldmVudCBuYW1lIHdhcyBwYXNzZWQgYXMgYSBzdHJpbmcsIGNyZWF0ZXMgYW4gZXZlbnQgb3V0IG9mIGl0XG4gIGlmICh0eXBlb2YgZXZlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgZXZlbnQgPSB7IHR5cGU6IGV2ZW50LCB0YXJnZXQ6IGVsZW0gfTtcbiAgfSBlbHNlIGlmICghZXZlbnQudGFyZ2V0KSB7XG4gICAgZXZlbnQudGFyZ2V0ID0gZWxlbTtcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZXMgdGhlIGV2ZW50IHByb3BlcnRpZXMuXG4gIGV2ZW50ID0gZml4RXZlbnQoZXZlbnQpO1xuXG4gIC8vIElmIHRoZSBwYXNzZWQgZWxlbWVudCBoYXMgYSBkaXNwYXRjaGVyLCBleGVjdXRlcyB0aGUgZXN0YWJsaXNoZWQgaGFuZGxlcnMuXG4gIGlmIChlbGVtRGF0YS5kaXNwYXRjaGVyKSB7XG4gICAgZWxlbURhdGEuZGlzcGF0Y2hlci5jYWxsKGVsZW0sIGV2ZW50LCBoYXNoKTtcbiAgfVxuXG4gIC8vIFVubGVzcyBleHBsaWNpdGx5IHN0b3BwZWQgb3IgdGhlIGV2ZW50IGRvZXMgbm90IGJ1YmJsZSAoZS5nLiBtZWRpYSBldmVudHMpXG4gIC8vIHJlY3Vyc2l2ZWx5IGNhbGxzIHRoaXMgZnVuY3Rpb24gdG8gYnViYmxlIHRoZSBldmVudCB1cCB0aGUgRE9NLlxuICBpZiAocGFyZW50ICYmICFldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpICYmIGV2ZW50LmJ1YmJsZXMgPT09IHRydWUpIHtcbiAgICB0cmlnZ2VyLmNhbGwobnVsbCwgcGFyZW50LCBldmVudCwgaGFzaCk7XG5cbiAgICAvLyBJZiBhdCB0aGUgdG9wIG9mIHRoZSBET00sIHRyaWdnZXJzIHRoZSBkZWZhdWx0IGFjdGlvbiB1bmxlc3MgZGlzYWJsZWQuXG4gIH0gZWxzZSBpZiAoIXBhcmVudCAmJiAhZXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgIHZhciB0YXJnZXREYXRhID0gZ2V0RGF0YShldmVudC50YXJnZXQpO1xuXG4gICAgLy8gQ2hlY2tzIGlmIHRoZSB0YXJnZXQgaGFzIGEgZGVmYXVsdCBhY3Rpb24gZm9yIHRoaXMgZXZlbnQuXG4gICAgaWYgKGV2ZW50LnRhcmdldFtldmVudC50eXBlXSkge1xuICAgICAgLy8gVGVtcG9yYXJpbHkgZGlzYWJsZXMgZXZlbnQgZGlzcGF0Y2hpbmcgb24gdGhlIHRhcmdldCBhcyB3ZSBoYXZlIGFscmVhZHkgZXhlY3V0ZWQgdGhlIGhhbmRsZXIuXG4gICAgICB0YXJnZXREYXRhLmRpc2FibGVkID0gdHJ1ZTtcbiAgICAgIC8vIEV4ZWN1dGVzIHRoZSBkZWZhdWx0IGFjdGlvbi5cbiAgICAgIGlmICh0eXBlb2YgZXZlbnQudGFyZ2V0W2V2ZW50LnR5cGVdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGV2ZW50LnRhcmdldFtldmVudC50eXBlXSgpO1xuICAgICAgfVxuICAgICAgLy8gUmUtZW5hYmxlcyBldmVudCBkaXNwYXRjaGluZy5cbiAgICAgIHRhcmdldERhdGEuZGlzYWJsZWQgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICAvLyBJbmZvcm0gdGhlIHRyaWdnZXJlciBpZiB0aGUgZGVmYXVsdCB3YXMgcHJldmVudGVkIGJ5IHJldHVybmluZyBmYWxzZVxuICByZXR1cm4gIWV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQ7XG59XG5cbi8qKlxuICogVHJpZ2dlciBhIGxpc3RlbmVyIG9ubHkgb25jZSBmb3IgYW4gZXZlbnRcbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR8T2JqZWN0fSBlbGVtXG4gKiAgICAgICAgRWxlbWVudCBvciBvYmplY3QgdG8gYmluZCB0by5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXX0gdHlwZVxuICogICAgICAgIE5hbWUvdHlwZSBvZiBldmVudFxuICpcbiAqIEBwYXJhbSB7RXZlbnR+RXZlbnRMaXN0ZW5lcn0gZm5cbiAqICAgICAgICBFdmVudCBMaXN0ZW5lciBmdW5jdGlvblxuICovXG5mdW5jdGlvbiBvbmUoZWxlbSwgdHlwZSwgZm4pIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodHlwZSkpIHtcbiAgICByZXR1cm4gX2hhbmRsZU11bHRpcGxlRXZlbnRzKG9uZSwgZWxlbSwgdHlwZSwgZm4pO1xuICB9XG4gIHZhciBmdW5jID0gZnVuY3Rpb24gZnVuYygpIHtcbiAgICBvZmYoZWxlbSwgdHlwZSwgZnVuYyk7XG4gICAgZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcblxuICAvLyBjb3B5IHRoZSBndWlkIHRvIHRoZSBuZXcgZnVuY3Rpb24gc28gaXQgY2FuIHJlbW92ZWQgdXNpbmcgdGhlIG9yaWdpbmFsIGZ1bmN0aW9uJ3MgSURcbiAgZnVuYy5ndWlkID0gZm4uZ3VpZCA9IGZuLmd1aWQgfHwgbmV3R1VJRCgpO1xuICBvbihlbGVtLCB0eXBlLCBmdW5jKTtcbn1cblxudmFyIEV2ZW50cyA9IChPYmplY3QuZnJlZXplIHx8IE9iamVjdCkoe1xuXHRmaXhFdmVudDogZml4RXZlbnQsXG5cdG9uOiBvbixcblx0b2ZmOiBvZmYsXG5cdHRyaWdnZXI6IHRyaWdnZXIsXG5cdG9uZTogb25lXG59KTtcblxuLyoqXG4gKiBAZmlsZSBzZXR1cC5qcyAtIEZ1bmN0aW9ucyBmb3Igc2V0dGluZyB1cCBhIHBsYXllciB3aXRob3V0XG4gKiB1c2VyIGludGVyYWN0aW9uIGJhc2VkIG9uIHRoZSBkYXRhLXNldHVwIGBhdHRyaWJ1dGVgIG9mIHRoZSB2aWRlbyB0YWcuXG4gKlxuICogQG1vZHVsZSBzZXR1cFxuICovXG52YXIgX3dpbmRvd0xvYWRlZCA9IGZhbHNlO1xudmFyIHZpZGVvanMkMiA9IHZvaWQgMDtcblxuLyoqXG4gKiBTZXQgdXAgYW55IHRhZ3MgdGhhdCBoYXZlIGEgZGF0YS1zZXR1cCBgYXR0cmlidXRlYCB3aGVuIHRoZSBwbGF5ZXIgaXMgc3RhcnRlZC5cbiAqL1xudmFyIGF1dG9TZXR1cCA9IGZ1bmN0aW9uIGF1dG9TZXR1cCgpIHtcblxuICAvLyBQcm90ZWN0IGFnYWluc3QgYnJlYWthZ2UgaW4gbm9uLWJyb3dzZXIgZW52aXJvbm1lbnRzIGFuZCBjaGVjayBnbG9iYWwgYXV0b1NldHVwIG9wdGlvbi5cbiAgaWYgKCFpc1JlYWwoKSB8fCB2aWRlb2pzJDIub3B0aW9ucy5hdXRvU2V0dXAgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gT25lIGRheSwgd2hlbiB3ZSBzdG9wIHN1cHBvcnRpbmcgSUU4LCBnbyBiYWNrIHRvIHRoaXMsIGJ1dCBpbiB0aGUgbWVhbnRpbWUuLi4qaGFjayBoYWNrIGhhY2sqXG4gIC8vIHZhciB2aWRzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3ZpZGVvJykpO1xuICAvLyB2YXIgYXVkaW9zID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2F1ZGlvJykpO1xuICAvLyB2YXIgbWVkaWFFbHMgPSB2aWRzLmNvbmNhdChhdWRpb3MpO1xuXG4gIC8vIEJlY2F1c2UgSUU4IGRvZXNuJ3Qgc3VwcG9ydCBjYWxsaW5nIHNsaWNlIG9uIGEgbm9kZSBsaXN0LCB3ZSBuZWVkIHRvIGxvb3BcbiAgLy8gdGhyb3VnaCBlYWNoIGxpc3Qgb2YgZWxlbWVudHMgdG8gYnVpbGQgdXAgYSBuZXcsIGNvbWJpbmVkIGxpc3Qgb2YgZWxlbWVudHMuXG4gIHZhciB2aWRzID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3ZpZGVvJyk7XG4gIHZhciBhdWRpb3MgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnYXVkaW8nKTtcbiAgdmFyIGRpdnMgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgndmlkZW8tanMnKTtcbiAgdmFyIG1lZGlhRWxzID0gW107XG5cbiAgaWYgKHZpZHMgJiYgdmlkcy5sZW5ndGggPiAwKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGUgPSB2aWRzLmxlbmd0aDsgaSA8IGU7IGkrKykge1xuICAgICAgbWVkaWFFbHMucHVzaCh2aWRzW2ldKTtcbiAgICB9XG4gIH1cblxuICBpZiAoYXVkaW9zICYmIGF1ZGlvcy5sZW5ndGggPiAwKSB7XG4gICAgZm9yICh2YXIgX2kgPSAwLCBfZSA9IGF1ZGlvcy5sZW5ndGg7IF9pIDwgX2U7IF9pKyspIHtcbiAgICAgIG1lZGlhRWxzLnB1c2goYXVkaW9zW19pXSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGRpdnMgJiYgZGl2cy5sZW5ndGggPiAwKSB7XG4gICAgZm9yICh2YXIgX2kyID0gMCwgX2UyID0gZGl2cy5sZW5ndGg7IF9pMiA8IF9lMjsgX2kyKyspIHtcbiAgICAgIG1lZGlhRWxzLnB1c2goZGl2c1tfaTJdKTtcbiAgICB9XG4gIH1cblxuICAvLyBDaGVjayBpZiBhbnkgbWVkaWEgZWxlbWVudHMgZXhpc3RcbiAgaWYgKG1lZGlhRWxzICYmIG1lZGlhRWxzLmxlbmd0aCA+IDApIHtcblxuICAgIGZvciAodmFyIF9pMyA9IDAsIF9lMyA9IG1lZGlhRWxzLmxlbmd0aDsgX2kzIDwgX2UzOyBfaTMrKykge1xuICAgICAgdmFyIG1lZGlhRWwgPSBtZWRpYUVsc1tfaTNdO1xuXG4gICAgICAvLyBDaGVjayBpZiBlbGVtZW50IGV4aXN0cywgaGFzIGdldEF0dHJpYnV0ZSBmdW5jLlxuICAgICAgLy8gSUUgc2VlbXMgdG8gY29uc2lkZXIgdHlwZW9mIGVsLmdldEF0dHJpYnV0ZSA9PSAnb2JqZWN0JyBpbnN0ZWFkIG9mXG4gICAgICAvLyAnZnVuY3Rpb24nIGxpa2UgZXhwZWN0ZWQsIGF0IGxlYXN0IHdoZW4gbG9hZGluZyB0aGUgcGxheWVyIGltbWVkaWF0ZWx5LlxuICAgICAgaWYgKG1lZGlhRWwgJiYgbWVkaWFFbC5nZXRBdHRyaWJ1dGUpIHtcblxuICAgICAgICAvLyBNYWtlIHN1cmUgdGhpcyBwbGF5ZXIgaGFzbid0IGFscmVhZHkgYmVlbiBzZXQgdXAuXG4gICAgICAgIGlmIChtZWRpYUVsLnBsYXllciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdmFyIG9wdGlvbnMgPSBtZWRpYUVsLmdldEF0dHJpYnV0ZSgnZGF0YS1zZXR1cCcpO1xuXG4gICAgICAgICAgLy8gQ2hlY2sgaWYgZGF0YS1zZXR1cCBhdHRyIGV4aXN0cy5cbiAgICAgICAgICAvLyBXZSBvbmx5IGF1dG8tc2V0dXAgaWYgdGhleSd2ZSBhZGRlZCB0aGUgZGF0YS1zZXR1cCBhdHRyLlxuICAgICAgICAgIGlmIChvcHRpb25zICE9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBDcmVhdGUgbmV3IHZpZGVvLmpzIGluc3RhbmNlLlxuICAgICAgICAgICAgdmlkZW9qcyQyKG1lZGlhRWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIGdldEF0dHJpYnV0ZSBpc24ndCBkZWZpbmVkLCB3ZSBuZWVkIHRvIHdhaXQgZm9yIHRoZSBET00uXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhdXRvU2V0dXBUaW1lb3V0KDEpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBObyB2aWRlb3Mgd2VyZSBmb3VuZCwgc28ga2VlcCBsb29waW5nIHVubGVzcyBwYWdlIGlzIGZpbmlzaGVkIGxvYWRpbmcuXG4gIH0gZWxzZSBpZiAoIV93aW5kb3dMb2FkZWQpIHtcbiAgICBhdXRvU2V0dXBUaW1lb3V0KDEpO1xuICB9XG59O1xuXG4vKipcbiAqIFdhaXQgdW50aWwgdGhlIHBhZ2UgaXMgbG9hZGVkIGJlZm9yZSBydW5uaW5nIGF1dG9TZXR1cC4gVGhpcyB3aWxsIGJlIGNhbGxlZCBpblxuICogYXV0b1NldHVwIGlmIGBoYXNMb2FkZWRgIHJldHVybnMgZmFsc2UuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IHdhaXRcbiAqICAgICAgICBIb3cgbG9uZyB0byB3YWl0IGluIG1zXG4gKlxuICogQHBhcmFtIHttb2R1bGU6dmlkZW9qc30gW3Zqc11cbiAqICAgICAgICBUaGUgdmlkZW9qcyBsaWJyYXJ5IGZ1bmN0aW9uXG4gKi9cbmZ1bmN0aW9uIGF1dG9TZXR1cFRpbWVvdXQod2FpdCwgdmpzKSB7XG4gIGlmICh2anMpIHtcbiAgICB2aWRlb2pzJDIgPSB2anM7XG4gIH1cblxuICB3aW5kb3cuc2V0VGltZW91dChhdXRvU2V0dXAsIHdhaXQpO1xufVxuXG5pZiAoaXNSZWFsKCkgJiYgZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gJ2NvbXBsZXRlJykge1xuICBfd2luZG93TG9hZGVkID0gdHJ1ZTtcbn0gZWxzZSB7XG4gIC8qKlxuICAgKiBMaXN0ZW4gZm9yIHRoZSBsb2FkIGV2ZW50IG9uIHdpbmRvdywgYW5kIHNldCBfd2luZG93TG9hZGVkIHRvIHRydWUuXG4gICAqXG4gICAqIEBsaXN0ZW5zIGxvYWRcbiAgICovXG4gIG9uZSh3aW5kb3csICdsb2FkJywgZnVuY3Rpb24gKCkge1xuICAgIF93aW5kb3dMb2FkZWQgPSB0cnVlO1xuICB9KTtcbn1cblxuLyoqXG4gKiBAZmlsZSBzdHlsZXNoZWV0LmpzXG4gKiBAbW9kdWxlIHN0eWxlc2hlZXRcbiAqL1xuLyoqXG4gKiBDcmVhdGUgYSBET00gc3lsZSBlbGVtZW50IGdpdmVuIGEgY2xhc3NOYW1lIGZvciBpdC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lXG4gKiAgICAgICAgVGhlIGNsYXNzTmFtZSB0byBhZGQgdG8gdGhlIGNyZWF0ZWQgc3R5bGUgZWxlbWVudC5cbiAqXG4gKiBAcmV0dXJuIHtFbGVtZW50fVxuICogICAgICAgICBUaGUgZWxlbWVudCB0aGF0IHdhcyBjcmVhdGVkLlxuICovXG52YXIgY3JlYXRlU3R5bGVFbGVtZW50ID0gZnVuY3Rpb24gY3JlYXRlU3R5bGVFbGVtZW50KGNsYXNzTmFtZSkge1xuICB2YXIgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuXG4gIHN0eWxlLmNsYXNzTmFtZSA9IGNsYXNzTmFtZTtcblxuICByZXR1cm4gc3R5bGU7XG59O1xuXG4vKipcbiAqIEFkZCB0ZXh0IHRvIGEgRE9NIGVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogICAgICAgIFRoZSBFbGVtZW50IHRvIGFkZCB0ZXh0IGNvbnRlbnQgdG8uXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbnRlbnRcbiAqICAgICAgICBUaGUgdGV4dCB0byBhZGQgdG8gdGhlIGVsZW1lbnQuXG4gKi9cbnZhciBzZXRUZXh0Q29udGVudCA9IGZ1bmN0aW9uIHNldFRleHRDb250ZW50KGVsLCBjb250ZW50KSB7XG4gIGlmIChlbC5zdHlsZVNoZWV0KSB7XG4gICAgZWwuc3R5bGVTaGVldC5jc3NUZXh0ID0gY29udGVudDtcbiAgfSBlbHNlIHtcbiAgICBlbC50ZXh0Q29udGVudCA9IGNvbnRlbnQ7XG4gIH1cbn07XG5cbi8qKlxuICogQGZpbGUgZm4uanNcbiAqIEBtb2R1bGUgZm5cbiAqL1xuLyoqXG4gKiBCaW5kIChhLmsuYSBwcm94eSBvciBDb250ZXh0KS4gQSBzaW1wbGUgbWV0aG9kIGZvciBjaGFuZ2luZyB0aGUgY29udGV4dCBvZiBhIGZ1bmN0aW9uXG4gKiBJdCBhbHNvIHN0b3JlcyBhIHVuaXF1ZSBpZCBvbiB0aGUgZnVuY3Rpb24gc28gaXQgY2FuIGJlIGVhc2lseSByZW1vdmVkIGZyb20gZXZlbnRzLlxuICpcbiAqIEBwYXJhbSB7TWl4ZWR9IGNvbnRleHRcbiAqICAgICAgICBUaGUgb2JqZWN0IHRvIGJpbmQgYXMgc2NvcGUuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqICAgICAgICBUaGUgZnVuY3Rpb24gdG8gYmUgYm91bmQgdG8gYSBzY29wZS5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gW3VpZF1cbiAqICAgICAgICBBbiBvcHRpb25hbCB1bmlxdWUgSUQgZm9yIHRoZSBmdW5jdGlvbiB0byBiZSBzZXRcbiAqXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqICAgICAgICAgVGhlIG5ldyBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgYm91bmQgaW50byB0aGUgY29udGV4dCBnaXZlblxuICovXG52YXIgYmluZCA9IGZ1bmN0aW9uIGJpbmQoY29udGV4dCwgZm4sIHVpZCkge1xuICAvLyBNYWtlIHN1cmUgdGhlIGZ1bmN0aW9uIGhhcyBhIHVuaXF1ZSBJRFxuICBpZiAoIWZuLmd1aWQpIHtcbiAgICBmbi5ndWlkID0gbmV3R1VJRCgpO1xuICB9XG5cbiAgLy8gQ3JlYXRlIHRoZSBuZXcgZnVuY3Rpb24gdGhhdCBjaGFuZ2VzIHRoZSBjb250ZXh0XG4gIHZhciBib3VuZCA9IGZ1bmN0aW9uIGJvdW5kKCkge1xuICAgIHJldHVybiBmbi5hcHBseShjb250ZXh0LCBhcmd1bWVudHMpO1xuICB9O1xuXG4gIC8vIEFsbG93IGZvciB0aGUgYWJpbGl0eSB0byBpbmRpdmlkdWFsaXplIHRoaXMgZnVuY3Rpb25cbiAgLy8gTmVlZGVkIGluIHRoZSBjYXNlIHdoZXJlIG11bHRpcGxlIG9iamVjdHMgbWlnaHQgc2hhcmUgdGhlIHNhbWUgcHJvdG90eXBlXG4gIC8vIElGIGJvdGggaXRlbXMgYWRkIGFuIGV2ZW50IGxpc3RlbmVyIHdpdGggdGhlIHNhbWUgZnVuY3Rpb24sIHRoZW4geW91IHRyeSB0byByZW1vdmUganVzdCBvbmVcbiAgLy8gaXQgd2lsbCByZW1vdmUgYm90aCBiZWNhdXNlIHRoZXkgYm90aCBoYXZlIHRoZSBzYW1lIGd1aWQuXG4gIC8vIHdoZW4gdXNpbmcgdGhpcywgeW91IG5lZWQgdG8gdXNlIHRoZSBiaW5kIG1ldGhvZCB3aGVuIHlvdSByZW1vdmUgdGhlIGxpc3RlbmVyIGFzIHdlbGwuXG4gIC8vIGN1cnJlbnRseSB1c2VkIGluIHRleHQgdHJhY2tzXG4gIGJvdW5kLmd1aWQgPSB1aWQgPyB1aWQgKyAnXycgKyBmbi5ndWlkIDogZm4uZ3VpZDtcblxuICByZXR1cm4gYm91bmQ7XG59O1xuXG4vKipcbiAqIFdyYXBzIHRoZSBnaXZlbiBmdW5jdGlvbiwgYGZuYCwgd2l0aCBhIG5ldyBmdW5jdGlvbiB0aGF0IG9ubHkgaW52b2tlcyBgZm5gXG4gKiBhdCBtb3N0IG9uY2UgcGVyIGV2ZXJ5IGB3YWl0YCBtaWxsaXNlY29uZHMuXG4gKlxuICogQHBhcmFtICB7RnVuY3Rpb259IGZuXG4gKiAgICAgICAgIFRoZSBmdW5jdGlvbiB0byBiZSB0aHJvdHRsZWQuXG4gKlxuICogQHBhcmFtICB7TnVtYmVyfSAgIHdhaXRcbiAqICAgICAgICAgVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgYnkgd2hpY2ggdG8gdGhyb3R0bGUuXG4gKlxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKi9cbnZhciB0aHJvdHRsZSA9IGZ1bmN0aW9uIHRocm90dGxlKGZuLCB3YWl0KSB7XG4gIHZhciBsYXN0ID0gRGF0ZS5ub3coKTtcblxuICB2YXIgdGhyb3R0bGVkID0gZnVuY3Rpb24gdGhyb3R0bGVkKCkge1xuICAgIHZhciBub3cgPSBEYXRlLm5vdygpO1xuXG4gICAgaWYgKG5vdyAtIGxhc3QgPj0gd2FpdCkge1xuICAgICAgZm4uYXBwbHkodW5kZWZpbmVkLCBhcmd1bWVudHMpO1xuICAgICAgbGFzdCA9IG5vdztcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIHRocm90dGxlZDtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIGRlYm91bmNlZCBmdW5jdGlvbiB0aGF0IGRlbGF5cyBpbnZva2luZyBgZnVuY2AgdW50aWwgYWZ0ZXIgYHdhaXRgXG4gKiBtaWxsaXNlY29uZHMgaGF2ZSBlbGFwc2VkIHNpbmNlIHRoZSBsYXN0IHRpbWUgdGhlIGRlYm91bmNlZCBmdW5jdGlvbiB3YXNcbiAqIGludm9rZWQuXG4gKlxuICogSW5zcGlyZWQgYnkgbG9kYXNoIGFuZCB1bmRlcnNjb3JlIGltcGxlbWVudGF0aW9ucy5cbiAqXG4gKiBAcGFyYW0gIHtGdW5jdGlvbn0gZnVuY1xuICogICAgICAgICBUaGUgZnVuY3Rpb24gdG8gd3JhcCB3aXRoIGRlYm91bmNlIGJlaGF2aW9yLlxuICpcbiAqIEBwYXJhbSAge251bWJlcn0gd2FpdFxuICogICAgICAgICBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byB3YWl0IGFmdGVyIHRoZSBsYXN0IGludm9jYXRpb24uXG4gKlxuICogQHBhcmFtICB7Ym9vbGVhbn0gW2ltbWVkaWF0ZV1cbiAqICAgICAgICAgV2hldGhlciBvciBub3QgdG8gaW52b2tlIHRoZSBmdW5jdGlvbiBpbW1lZGlhdGVseSB1cG9uIGNyZWF0aW9uLlxuICpcbiAqIEBwYXJhbSAge09iamVjdH0gW2NvbnRleHQ9d2luZG93XVxuICogICAgICAgICBUaGUgXCJjb250ZXh0XCIgaW4gd2hpY2ggdGhlIGRlYm91bmNlZCBmdW5jdGlvbiBzaG91bGQgZGVib3VuY2UuIEZvclxuICogICAgICAgICBleGFtcGxlLCBpZiB0aGlzIGZ1bmN0aW9uIHNob3VsZCBiZSB0aWVkIHRvIGEgVmlkZW8uanMgcGxheWVyLFxuICogICAgICAgICB0aGUgcGxheWVyIGNhbiBiZSBwYXNzZWQgaGVyZS4gQWx0ZXJuYXRpdmVseSwgZGVmYXVsdHMgdG8gdGhlXG4gKiAgICAgICAgIGdsb2JhbCBgd2luZG93YCBvYmplY3QuXG4gKlxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKiAgICAgICAgIEEgZGVib3VuY2VkIGZ1bmN0aW9uLlxuICovXG52YXIgZGVib3VuY2UgPSBmdW5jdGlvbiBkZWJvdW5jZShmdW5jLCB3YWl0LCBpbW1lZGlhdGUpIHtcbiAgdmFyIGNvbnRleHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IHdpbmRvdztcblxuICB2YXIgdGltZW91dCA9IHZvaWQgMDtcblxuICB2YXIgY2FuY2VsID0gZnVuY3Rpb24gY2FuY2VsKCkge1xuICAgIGNvbnRleHQuY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgIHRpbWVvdXQgPSBudWxsO1xuICB9O1xuXG4gIC8qIGVzbGludC1kaXNhYmxlIGNvbnNpc3RlbnQtdGhpcyAqL1xuICB2YXIgZGVib3VuY2VkID0gZnVuY3Rpb24gZGVib3VuY2VkKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcblxuICAgIHZhciBfbGF0ZXIgPSBmdW5jdGlvbiBsYXRlcigpIHtcbiAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgX2xhdGVyID0gbnVsbDtcbiAgICAgIGlmICghaW1tZWRpYXRlKSB7XG4gICAgICAgIGZ1bmMuYXBwbHkoc2VsZiwgYXJncyk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGlmICghdGltZW91dCAmJiBpbW1lZGlhdGUpIHtcbiAgICAgIGZ1bmMuYXBwbHkoc2VsZiwgYXJncyk7XG4gICAgfVxuXG4gICAgY29udGV4dC5jbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgdGltZW91dCA9IGNvbnRleHQuc2V0VGltZW91dChfbGF0ZXIsIHdhaXQpO1xuICB9O1xuICAvKiBlc2xpbnQtZW5hYmxlIGNvbnNpc3RlbnQtdGhpcyAqL1xuXG4gIGRlYm91bmNlZC5jYW5jZWwgPSBjYW5jZWw7XG5cbiAgcmV0dXJuIGRlYm91bmNlZDtcbn07XG5cbi8qKlxuICogQGZpbGUgc3JjL2pzL2V2ZW50LXRhcmdldC5qc1xuICovXG4vKipcbiAqIGBFdmVudFRhcmdldGAgaXMgYSBjbGFzcyB0aGF0IGNhbiBoYXZlIHRoZSBzYW1lIEFQSSBhcyB0aGUgRE9NIGBFdmVudFRhcmdldGAuIEl0XG4gKiBhZGRzIHNob3J0aGFuZCBmdW5jdGlvbnMgdGhhdCB3cmFwIGFyb3VuZCBsZW5ndGh5IGZ1bmN0aW9ucy4gRm9yIGV4YW1wbGU6XG4gKiB0aGUgYG9uYCBmdW5jdGlvbiBpcyBhIHdyYXBwZXIgYXJvdW5kIGBhZGRFdmVudExpc3RlbmVyYC5cbiAqXG4gKiBAc2VlIFtFdmVudFRhcmdldCBTcGVjXXtAbGluayBodHRwczovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTItRXZlbnRzL2V2ZW50cy5odG1sI0V2ZW50cy1FdmVudFRhcmdldH1cbiAqIEBjbGFzcyBFdmVudFRhcmdldFxuICovXG52YXIgRXZlbnRUYXJnZXQgPSBmdW5jdGlvbiBFdmVudFRhcmdldCgpIHt9O1xuXG4vKipcbiAqIEEgQ3VzdG9tIERPTSBldmVudC5cbiAqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBFdmVudFRhcmdldH5FdmVudFxuICogQHNlZSBbUHJvcGVydGllc117QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0N1c3RvbUV2ZW50fVxuICovXG5cbi8qKlxuICogQWxsIGV2ZW50IGxpc3RlbmVycyBzaG91bGQgZm9sbG93IHRoZSBmb2xsb3dpbmcgZm9ybWF0LlxuICpcbiAqIEBjYWxsYmFjayBFdmVudFRhcmdldH5FdmVudExpc3RlbmVyXG4gKiBAdGhpcyB7RXZlbnRUYXJnZXR9XG4gKlxuICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gZXZlbnRcbiAqICAgICAgICB0aGUgZXZlbnQgdGhhdCB0cmlnZ2VyZWQgdGhpcyBmdW5jdGlvblxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbaGFzaF1cbiAqICAgICAgICBoYXNoIG9mIGRhdGEgc2VudCBkdXJpbmcgdGhlIGV2ZW50XG4gKi9cblxuLyoqXG4gKiBBbiBvYmplY3QgY29udGFpbmluZyBldmVudCBuYW1lcyBhcyBrZXlzIGFuZCBib29sZWFucyBhcyB2YWx1ZXMuXG4gKlxuICogPiBOT1RFOiBJZiBhbiBldmVudCBuYW1lIGlzIHNldCB0byBhIHRydWUgdmFsdWUgaGVyZSB7QGxpbmsgRXZlbnRUYXJnZXQjdHJpZ2dlcn1cbiAqICAgICAgICAgd2lsbCBoYXZlIGV4dHJhIGZ1bmN0aW9uYWxpdHkuIFNlZSB0aGF0IGZ1bmN0aW9uIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICpcbiAqIEBwcm9wZXJ0eSBFdmVudFRhcmdldC5wcm90b3R5cGUuYWxsb3dlZEV2ZW50c19cbiAqIEBwcml2YXRlXG4gKi9cbkV2ZW50VGFyZ2V0LnByb3RvdHlwZS5hbGxvd2VkRXZlbnRzXyA9IHt9O1xuXG4vKipcbiAqIEFkZHMgYW4gYGV2ZW50IGxpc3RlbmVyYCB0byBhbiBpbnN0YW5jZSBvZiBhbiBgRXZlbnRUYXJnZXRgLiBBbiBgZXZlbnQgbGlzdGVuZXJgIGlzIGFcbiAqIGZ1bmN0aW9uIHRoYXQgd2lsbCBnZXQgY2FsbGVkIHdoZW4gYW4gZXZlbnQgd2l0aCBhIGNlcnRhaW4gbmFtZSBnZXRzIHRyaWdnZXJlZC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXX0gdHlwZVxuICogICAgICAgIEFuIGV2ZW50IG5hbWUgb3IgYW4gYXJyYXkgb2YgZXZlbnQgbmFtZXMuXG4gKlxuICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudExpc3RlbmVyfSBmblxuICogICAgICAgIFRoZSBmdW5jdGlvbiB0byBjYWxsIHdpdGggYEV2ZW50VGFyZ2V0YHNcbiAqL1xuRXZlbnRUYXJnZXQucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gKHR5cGUsIGZuKSB7XG4gIC8vIFJlbW92ZSB0aGUgYWRkRXZlbnRMaXN0ZW5lciBhbGlhcyBiZWZvcmUgY2FsbGluZyBFdmVudHMub25cbiAgLy8gc28gd2UgZG9uJ3QgZ2V0IGludG8gYW4gaW5maW5pdGUgdHlwZSBsb29wXG4gIHZhciBhZWwgPSB0aGlzLmFkZEV2ZW50TGlzdGVuZXI7XG5cbiAgdGhpcy5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gKCkge307XG4gIG9uKHRoaXMsIHR5cGUsIGZuKTtcbiAgdGhpcy5hZGRFdmVudExpc3RlbmVyID0gYWVsO1xufTtcblxuLyoqXG4gKiBBbiBhbGlhcyBvZiB7QGxpbmsgRXZlbnRUYXJnZXQjb259LiBBbGxvd3MgYEV2ZW50VGFyZ2V0YCB0byBtaW1pY1xuICogdGhlIHN0YW5kYXJkIERPTSBBUEkuXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAc2VlIHtAbGluayBFdmVudFRhcmdldCNvbn1cbiAqL1xuRXZlbnRUYXJnZXQucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXIgPSBFdmVudFRhcmdldC5wcm90b3R5cGUub247XG5cbi8qKlxuICogUmVtb3ZlcyBhbiBgZXZlbnQgbGlzdGVuZXJgIGZvciBhIHNwZWNpZmljIGV2ZW50IGZyb20gYW4gaW5zdGFuY2Ugb2YgYEV2ZW50VGFyZ2V0YC5cbiAqIFRoaXMgbWFrZXMgaXQgc28gdGhhdCB0aGUgYGV2ZW50IGxpc3RlbmVyYCB3aWxsIG5vIGxvbmdlciBnZXQgY2FsbGVkIHdoZW4gdGhlXG4gKiBuYW1lZCBldmVudCBoYXBwZW5zLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSB0eXBlXG4gKiAgICAgICAgQW4gZXZlbnQgbmFtZSBvciBhbiBhcnJheSBvZiBldmVudCBuYW1lcy5cbiAqXG4gKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50TGlzdGVuZXJ9IGZuXG4gKiAgICAgICAgVGhlIGZ1bmN0aW9uIHRvIHJlbW92ZS5cbiAqL1xuRXZlbnRUYXJnZXQucHJvdG90eXBlLm9mZiA9IGZ1bmN0aW9uICh0eXBlLCBmbikge1xuICBvZmYodGhpcywgdHlwZSwgZm4pO1xufTtcblxuLyoqXG4gKiBBbiBhbGlhcyBvZiB7QGxpbmsgRXZlbnRUYXJnZXQjb2ZmfS4gQWxsb3dzIGBFdmVudFRhcmdldGAgdG8gbWltaWNcbiAqIHRoZSBzdGFuZGFyZCBET00gQVBJLlxuICpcbiAqIEBmdW5jdGlvblxuICogQHNlZSB7QGxpbmsgRXZlbnRUYXJnZXQjb2ZmfVxuICovXG5FdmVudFRhcmdldC5wcm90b3R5cGUucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IEV2ZW50VGFyZ2V0LnByb3RvdHlwZS5vZmY7XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiB3aWxsIGFkZCBhbiBgZXZlbnQgbGlzdGVuZXJgIHRoYXQgZ2V0cyB0cmlnZ2VyZWQgb25seSBvbmNlLiBBZnRlciB0aGVcbiAqIGZpcnN0IHRyaWdnZXIgaXQgd2lsbCBnZXQgcmVtb3ZlZC4gVGhpcyBpcyBsaWtlIGFkZGluZyBhbiBgZXZlbnQgbGlzdGVuZXJgXG4gKiB3aXRoIHtAbGluayBFdmVudFRhcmdldCNvbn0gdGhhdCBjYWxscyB7QGxpbmsgRXZlbnRUYXJnZXQjb2ZmfSBvbiBpdHNlbGYuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IHR5cGVcbiAqICAgICAgICBBbiBldmVudCBuYW1lIG9yIGFuIGFycmF5IG9mIGV2ZW50IG5hbWVzLlxuICpcbiAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnRMaXN0ZW5lcn0gZm5cbiAqICAgICAgICBUaGUgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIG9uY2UgZm9yIGVhY2ggZXZlbnQgbmFtZS5cbiAqL1xuRXZlbnRUYXJnZXQucHJvdG90eXBlLm9uZSA9IGZ1bmN0aW9uICh0eXBlLCBmbikge1xuICAvLyBSZW1vdmUgdGhlIGFkZEV2ZW50TGlzdGVuZXIgYWxpYWxpbmcgRXZlbnRzLm9uXG4gIC8vIHNvIHdlIGRvbid0IGdldCBpbnRvIGFuIGluZmluaXRlIHR5cGUgbG9vcFxuICB2YXIgYWVsID0gdGhpcy5hZGRFdmVudExpc3RlbmVyO1xuXG4gIHRoaXMuYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uICgpIHt9O1xuICBvbmUodGhpcywgdHlwZSwgZm4pO1xuICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIgPSBhZWw7XG59O1xuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gY2F1c2VzIGFuIGV2ZW50IHRvIGhhcHBlbi4gVGhpcyB3aWxsIHRoZW4gY2F1c2UgYW55IGBldmVudCBsaXN0ZW5lcnNgXG4gKiB0aGF0IGFyZSB3YWl0aW5nIGZvciB0aGF0IGV2ZW50LCB0byBnZXQgY2FsbGVkLiBJZiB0aGVyZSBhcmUgbm8gYGV2ZW50IGxpc3RlbmVyc2BcbiAqIGZvciBhbiBldmVudCB0aGVuIG5vdGhpbmcgd2lsbCBoYXBwZW4uXG4gKlxuICogSWYgdGhlIG5hbWUgb2YgdGhlIGBFdmVudGAgdGhhdCBpcyBiZWluZyB0cmlnZ2VyZWQgaXMgaW4gYEV2ZW50VGFyZ2V0LmFsbG93ZWRFdmVudHNfYC5cbiAqIFRyaWdnZXIgd2lsbCBhbHNvIGNhbGwgdGhlIGBvbmAgKyBgdXBwZXJjYXNlRXZlbnROYW1lYCBmdW5jdGlvbi5cbiAqXG4gKiBFeGFtcGxlOlxuICogJ2NsaWNrJyBpcyBpbiBgRXZlbnRUYXJnZXQuYWxsb3dlZEV2ZW50c19gLCBzbywgdHJpZ2dlciB3aWxsIGF0dGVtcHQgdG8gY2FsbFxuICogYG9uQ2xpY2tgIGlmIGl0IGV4aXN0cy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ3xFdmVudFRhcmdldH5FdmVudHxPYmplY3R9IGV2ZW50XG4gKiAgICAgICAgVGhlIG5hbWUgb2YgdGhlIGV2ZW50LCBhbiBgRXZlbnRgLCBvciBhbiBvYmplY3Qgd2l0aCBhIGtleSBvZiB0eXBlIHNldCB0b1xuICogICAgICAgIGFuIGV2ZW50IG5hbWUuXG4gKi9cbkV2ZW50VGFyZ2V0LnByb3RvdHlwZS50cmlnZ2VyID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gIHZhciB0eXBlID0gZXZlbnQudHlwZSB8fCBldmVudDtcblxuICBpZiAodHlwZW9mIGV2ZW50ID09PSAnc3RyaW5nJykge1xuICAgIGV2ZW50ID0geyB0eXBlOiB0eXBlIH07XG4gIH1cbiAgZXZlbnQgPSBmaXhFdmVudChldmVudCk7XG5cbiAgaWYgKHRoaXMuYWxsb3dlZEV2ZW50c19bdHlwZV0gJiYgdGhpc1snb24nICsgdHlwZV0pIHtcbiAgICB0aGlzWydvbicgKyB0eXBlXShldmVudCk7XG4gIH1cblxuICB0cmlnZ2VyKHRoaXMsIGV2ZW50KTtcbn07XG5cbi8qKlxuICogQW4gYWxpYXMgb2Yge0BsaW5rIEV2ZW50VGFyZ2V0I3RyaWdnZXJ9LiBBbGxvd3MgYEV2ZW50VGFyZ2V0YCB0byBtaW1pY1xuICogdGhlIHN0YW5kYXJkIERPTSBBUEkuXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAc2VlIHtAbGluayBFdmVudFRhcmdldCN0cmlnZ2VyfVxuICovXG5FdmVudFRhcmdldC5wcm90b3R5cGUuZGlzcGF0Y2hFdmVudCA9IEV2ZW50VGFyZ2V0LnByb3RvdHlwZS50cmlnZ2VyO1xuXG4vKipcbiAqIEBmaWxlIG1peGlucy9ldmVudGVkLmpzXG4gKiBAbW9kdWxlIGV2ZW50ZWRcbiAqL1xuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IGFuIG9iamVjdCBoYXMgaGFkIHRoZSBldmVudGVkIG1peGluIGFwcGxpZWQuXG4gKlxuICogQHBhcmFtICB7T2JqZWN0fSBvYmplY3RcbiAqICAgICAgICAgQW4gb2JqZWN0IHRvIHRlc3QuXG4gKlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqICAgICAgICAgV2hldGhlciBvciBub3QgdGhlIG9iamVjdCBhcHBlYXJzIHRvIGJlIGV2ZW50ZWQuXG4gKi9cbnZhciBpc0V2ZW50ZWQgPSBmdW5jdGlvbiBpc0V2ZW50ZWQob2JqZWN0KSB7XG4gIHJldHVybiBvYmplY3QgaW5zdGFuY2VvZiBFdmVudFRhcmdldCB8fCAhIW9iamVjdC5ldmVudEJ1c0VsXyAmJiBbJ29uJywgJ29uZScsICdvZmYnLCAndHJpZ2dlciddLmV2ZXJ5KGZ1bmN0aW9uIChrKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBvYmplY3Rba10gPT09ICdmdW5jdGlvbic7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBXaGV0aGVyIGEgdmFsdWUgaXMgYSB2YWxpZCBldmVudCB0eXBlIC0gbm9uLWVtcHR5IHN0cmluZyBvciBhcnJheS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtICB7c3RyaW5nfEFycmF5fSB0eXBlXG4gKiAgICAgICAgIFRoZSB0eXBlIHZhbHVlIHRvIHRlc3QuXG4gKlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqICAgICAgICAgV2hldGhlciBvciBub3QgdGhlIHR5cGUgaXMgYSB2YWxpZCBldmVudCB0eXBlLlxuICovXG52YXIgaXNWYWxpZEV2ZW50VHlwZSA9IGZ1bmN0aW9uIGlzVmFsaWRFdmVudFR5cGUodHlwZSkge1xuICByZXR1cm4gKFxuICAgIC8vIFRoZSByZWdleCBoZXJlIHZlcmlmaWVzIHRoYXQgdGhlIGB0eXBlYCBjb250YWlucyBhdCBsZWFzdCBvbmUgbm9uLVxuICAgIC8vIHdoaXRlc3BhY2UgY2hhcmFjdGVyLlxuICAgIHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyAmJiAvXFxTLy50ZXN0KHR5cGUpIHx8IEFycmF5LmlzQXJyYXkodHlwZSkgJiYgISF0eXBlLmxlbmd0aFxuICApO1xufTtcblxuLyoqXG4gKiBWYWxpZGF0ZXMgYSB2YWx1ZSB0byBkZXRlcm1pbmUgaWYgaXQgaXMgYSB2YWxpZCBldmVudCB0YXJnZXQuIFRocm93cyBpZiBub3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEB0aHJvd3Mge0Vycm9yfVxuICogICAgICAgICBJZiB0aGUgdGFyZ2V0IGRvZXMgbm90IGFwcGVhciB0byBiZSBhIHZhbGlkIGV2ZW50IHRhcmdldC5cbiAqXG4gKiBAcGFyYW0gIHtPYmplY3R9IHRhcmdldFxuICogICAgICAgICBUaGUgb2JqZWN0IHRvIHRlc3QuXG4gKi9cbnZhciB2YWxpZGF0ZVRhcmdldCA9IGZ1bmN0aW9uIHZhbGlkYXRlVGFyZ2V0KHRhcmdldCkge1xuICBpZiAoIXRhcmdldC5ub2RlTmFtZSAmJiAhaXNFdmVudGVkKHRhcmdldCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdGFyZ2V0OyBtdXN0IGJlIGEgRE9NIG5vZGUgb3IgZXZlbnRlZCBvYmplY3QuJyk7XG4gIH1cbn07XG5cbi8qKlxuICogVmFsaWRhdGVzIGEgdmFsdWUgdG8gZGV0ZXJtaW5lIGlmIGl0IGlzIGEgdmFsaWQgZXZlbnQgdGFyZ2V0LiBUaHJvd3MgaWYgbm90LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAdGhyb3dzIHtFcnJvcn1cbiAqICAgICAgICAgSWYgdGhlIHR5cGUgZG9lcyBub3QgYXBwZWFyIHRvIGJlIGEgdmFsaWQgZXZlbnQgdHlwZS5cbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd8QXJyYXl9IHR5cGVcbiAqICAgICAgICAgVGhlIHR5cGUgdG8gdGVzdC5cbiAqL1xudmFyIHZhbGlkYXRlRXZlbnRUeXBlID0gZnVuY3Rpb24gdmFsaWRhdGVFdmVudFR5cGUodHlwZSkge1xuICBpZiAoIWlzVmFsaWRFdmVudFR5cGUodHlwZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgZXZlbnQgdHlwZTsgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcgb3IgYXJyYXkuJyk7XG4gIH1cbn07XG5cbi8qKlxuICogVmFsaWRhdGVzIGEgdmFsdWUgdG8gZGV0ZXJtaW5lIGlmIGl0IGlzIGEgdmFsaWQgbGlzdGVuZXIuIFRocm93cyBpZiBub3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEB0aHJvd3Mge0Vycm9yfVxuICogICAgICAgICBJZiB0aGUgbGlzdGVuZXIgaXMgbm90IGEgZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtICB7RnVuY3Rpb259IGxpc3RlbmVyXG4gKiAgICAgICAgIFRoZSBsaXN0ZW5lciB0byB0ZXN0LlxuICovXG52YXIgdmFsaWRhdGVMaXN0ZW5lciA9IGZ1bmN0aW9uIHZhbGlkYXRlTGlzdGVuZXIobGlzdGVuZXIpIHtcbiAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBsaXN0ZW5lcjsgbXVzdCBiZSBhIGZ1bmN0aW9uLicpO1xuICB9XG59O1xuXG4vKipcbiAqIFRha2VzIGFuIGFycmF5IG9mIGFyZ3VtZW50cyBnaXZlbiB0byBgb24oKWAgb3IgYG9uZSgpYCwgdmFsaWRhdGVzIHRoZW0sIGFuZFxuICogbm9ybWFsaXplcyB0aGVtIGludG8gYW4gb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0gIHtPYmplY3R9IHNlbGZcbiAqICAgICAgICAgVGhlIGV2ZW50ZWQgb2JqZWN0IG9uIHdoaWNoIGBvbigpYCBvciBgb25lKClgIHdhcyBjYWxsZWQuIFRoaXNcbiAqICAgICAgICAgb2JqZWN0IHdpbGwgYmUgYm91bmQgYXMgdGhlIGB0aGlzYCB2YWx1ZSBmb3IgdGhlIGxpc3RlbmVyLlxuICpcbiAqIEBwYXJhbSAge0FycmF5fSBhcmdzXG4gKiAgICAgICAgIEFuIGFycmF5IG9mIGFyZ3VtZW50cyBwYXNzZWQgdG8gYG9uKClgIG9yIGBvbmUoKWAuXG4gKlxuICogQHJldHVybiB7T2JqZWN0fVxuICogICAgICAgICBBbiBvYmplY3QgY29udGFpbmluZyB1c2VmdWwgdmFsdWVzIGZvciBgb24oKWAgb3IgYG9uZSgpYCBjYWxscy5cbiAqL1xudmFyIG5vcm1hbGl6ZUxpc3RlbkFyZ3MgPSBmdW5jdGlvbiBub3JtYWxpemVMaXN0ZW5BcmdzKHNlbGYsIGFyZ3MpIHtcblxuICAvLyBJZiB0aGUgbnVtYmVyIG9mIGFyZ3VtZW50cyBpcyBsZXNzIHRoYW4gMywgdGhlIHRhcmdldCBpcyBhbHdheXMgdGhlXG4gIC8vIGV2ZW50ZWQgb2JqZWN0IGl0c2VsZi5cbiAgdmFyIGlzVGFyZ2V0aW5nU2VsZiA9IGFyZ3MubGVuZ3RoIDwgMyB8fCBhcmdzWzBdID09PSBzZWxmIHx8IGFyZ3NbMF0gPT09IHNlbGYuZXZlbnRCdXNFbF87XG4gIHZhciB0YXJnZXQgPSB2b2lkIDA7XG4gIHZhciB0eXBlID0gdm9pZCAwO1xuICB2YXIgbGlzdGVuZXIgPSB2b2lkIDA7XG5cbiAgaWYgKGlzVGFyZ2V0aW5nU2VsZikge1xuICAgIHRhcmdldCA9IHNlbGYuZXZlbnRCdXNFbF87XG5cbiAgICAvLyBEZWFsIHdpdGggY2FzZXMgd2hlcmUgd2UgZ290IDMgYXJndW1lbnRzLCBidXQgd2UgYXJlIHN0aWxsIGxpc3RlbmluZyB0b1xuICAgIC8vIHRoZSBldmVudGVkIG9iamVjdCBpdHNlbGYuXG4gICAgaWYgKGFyZ3MubGVuZ3RoID49IDMpIHtcbiAgICAgIGFyZ3Muc2hpZnQoKTtcbiAgICB9XG5cbiAgICB0eXBlID0gYXJnc1swXTtcbiAgICBsaXN0ZW5lciA9IGFyZ3NbMV07XG4gIH0gZWxzZSB7XG4gICAgdGFyZ2V0ID0gYXJnc1swXTtcbiAgICB0eXBlID0gYXJnc1sxXTtcbiAgICBsaXN0ZW5lciA9IGFyZ3NbMl07XG4gIH1cblxuICB2YWxpZGF0ZVRhcmdldCh0YXJnZXQpO1xuICB2YWxpZGF0ZUV2ZW50VHlwZSh0eXBlKTtcbiAgdmFsaWRhdGVMaXN0ZW5lcihsaXN0ZW5lcik7XG5cbiAgbGlzdGVuZXIgPSBiaW5kKHNlbGYsIGxpc3RlbmVyKTtcblxuICByZXR1cm4geyBpc1RhcmdldGluZ1NlbGY6IGlzVGFyZ2V0aW5nU2VsZiwgdGFyZ2V0OiB0YXJnZXQsIHR5cGU6IHR5cGUsIGxpc3RlbmVyOiBsaXN0ZW5lciB9O1xufTtcblxuLyoqXG4gKiBBZGRzIHRoZSBsaXN0ZW5lciB0byB0aGUgZXZlbnQgdHlwZShzKSBvbiB0aGUgdGFyZ2V0LCBub3JtYWxpemluZyBmb3JcbiAqIHRoZSB0eXBlIG9mIHRhcmdldC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtICB7RWxlbWVudHxPYmplY3R9IHRhcmdldFxuICogICAgICAgICBBIERPTSBub2RlIG9yIGV2ZW50ZWQgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gbWV0aG9kXG4gKiAgICAgICAgIFRoZSBldmVudCBiaW5kaW5nIG1ldGhvZCB0byB1c2UgKFwib25cIiBvciBcIm9uZVwiKS5cbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd8QXJyYXl9IHR5cGVcbiAqICAgICAgICAgT25lIG9yIG1vcmUgZXZlbnQgdHlwZShzKS5cbiAqXG4gKiBAcGFyYW0gIHtGdW5jdGlvbn0gbGlzdGVuZXJcbiAqICAgICAgICAgQSBsaXN0ZW5lciBmdW5jdGlvbi5cbiAqL1xudmFyIGxpc3RlbiA9IGZ1bmN0aW9uIGxpc3Rlbih0YXJnZXQsIG1ldGhvZCwgdHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFsaWRhdGVUYXJnZXQodGFyZ2V0KTtcblxuICBpZiAodGFyZ2V0Lm5vZGVOYW1lKSB7XG4gICAgRXZlbnRzW21ldGhvZF0odGFyZ2V0LCB0eXBlLCBsaXN0ZW5lcik7XG4gIH0gZWxzZSB7XG4gICAgdGFyZ2V0W21ldGhvZF0odHlwZSwgbGlzdGVuZXIpO1xuICB9XG59O1xuXG4vKipcbiAqIENvbnRhaW5zIG1ldGhvZHMgdGhhdCBwcm92aWRlIGV2ZW50IGNhcGFiaWxpdGVzIHRvIGFuIG9iamVjdCB3aGljaCBpcyBwYXNzZWRcbiAqIHRvIHtAbGluayBtb2R1bGU6ZXZlbnRlZHxldmVudGVkfS5cbiAqXG4gKiBAbWl4aW4gRXZlbnRlZE1peGluXG4gKi9cbnZhciBFdmVudGVkTWl4aW4gPSB7XG5cbiAgLyoqXG4gICAqIEFkZCBhIGxpc3RlbmVyIHRvIGFuIGV2ZW50IChvciBldmVudHMpIG9uIHRoaXMgb2JqZWN0IG9yIGFub3RoZXIgZXZlbnRlZFxuICAgKiBvYmplY3QuXG4gICAqXG4gICAqIEBwYXJhbSAge3N0cmluZ3xBcnJheXxFbGVtZW50fE9iamVjdH0gdGFyZ2V0T3JUeXBlXG4gICAqICAgICAgICAgSWYgdGhpcyBpcyBhIHN0cmluZyBvciBhcnJheSwgaXQgcmVwcmVzZW50cyB0aGUgZXZlbnQgdHlwZShzKVxuICAgKiAgICAgICAgIHRoYXQgd2lsbCB0cmlnZ2VyIHRoZSBsaXN0ZW5lci5cbiAgICpcbiAgICogICAgICAgICBBbm90aGVyIGV2ZW50ZWQgb2JqZWN0IGNhbiBiZSBwYXNzZWQgaGVyZSBpbnN0ZWFkLCB3aGljaCB3aWxsXG4gICAqICAgICAgICAgY2F1c2UgdGhlIGxpc3RlbmVyIHRvIGxpc3RlbiBmb3IgZXZlbnRzIG9uIF90aGF0XyBvYmplY3QuXG4gICAqXG4gICAqICAgICAgICAgSW4gZWl0aGVyIGNhc2UsIHRoZSBsaXN0ZW5lcidzIGB0aGlzYCB2YWx1ZSB3aWxsIGJlIGJvdW5kIHRvXG4gICAqICAgICAgICAgdGhpcyBvYmplY3QuXG4gICAqXG4gICAqIEBwYXJhbSAge3N0cmluZ3xBcnJheXxGdW5jdGlvbn0gdHlwZU9yTGlzdGVuZXJcbiAgICogICAgICAgICBJZiB0aGUgZmlyc3QgYXJndW1lbnQgd2FzIGEgc3RyaW5nIG9yIGFycmF5LCB0aGlzIHNob3VsZCBiZSB0aGVcbiAgICogICAgICAgICBsaXN0ZW5lciBmdW5jdGlvbi4gT3RoZXJ3aXNlLCB0aGlzIGlzIGEgc3RyaW5nIG9yIGFycmF5IG9mIGV2ZW50XG4gICAqICAgICAgICAgdHlwZShzKS5cbiAgICpcbiAgICogQHBhcmFtICB7RnVuY3Rpb259IFtsaXN0ZW5lcl1cbiAgICogICAgICAgICBJZiB0aGUgZmlyc3QgYXJndW1lbnQgd2FzIGFub3RoZXIgZXZlbnRlZCBvYmplY3QsIHRoaXMgd2lsbCBiZVxuICAgKiAgICAgICAgIHRoZSBsaXN0ZW5lciBmdW5jdGlvbi5cbiAgICovXG4gIG9uOiBmdW5jdGlvbiBvbiQkMSgpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgdmFyIF9ub3JtYWxpemVMaXN0ZW5BcmdzID0gbm9ybWFsaXplTGlzdGVuQXJncyh0aGlzLCBhcmdzKSxcbiAgICAgICAgaXNUYXJnZXRpbmdTZWxmID0gX25vcm1hbGl6ZUxpc3RlbkFyZ3MuaXNUYXJnZXRpbmdTZWxmLFxuICAgICAgICB0YXJnZXQgPSBfbm9ybWFsaXplTGlzdGVuQXJncy50YXJnZXQsXG4gICAgICAgIHR5cGUgPSBfbm9ybWFsaXplTGlzdGVuQXJncy50eXBlLFxuICAgICAgICBsaXN0ZW5lciA9IF9ub3JtYWxpemVMaXN0ZW5BcmdzLmxpc3RlbmVyO1xuXG4gICAgbGlzdGVuKHRhcmdldCwgJ29uJywgdHlwZSwgbGlzdGVuZXIpO1xuXG4gICAgLy8gSWYgdGhpcyBvYmplY3QgaXMgbGlzdGVuaW5nIHRvIGFub3RoZXIgZXZlbnRlZCBvYmplY3QuXG4gICAgaWYgKCFpc1RhcmdldGluZ1NlbGYpIHtcblxuICAgICAgLy8gSWYgdGhpcyBvYmplY3QgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgbGlzdGVuZXIuXG4gICAgICB2YXIgcmVtb3ZlTGlzdGVuZXJPbkRpc3Bvc2UgPSBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lck9uRGlzcG9zZSgpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzLm9mZih0YXJnZXQsIHR5cGUsIGxpc3RlbmVyKTtcbiAgICAgIH07XG5cbiAgICAgIC8vIFVzZSB0aGUgc2FtZSBmdW5jdGlvbiBJRCBhcyB0aGUgbGlzdGVuZXIgc28gd2UgY2FuIHJlbW92ZSBpdCBsYXRlciBpdFxuICAgICAgLy8gdXNpbmcgdGhlIElEIG9mIHRoZSBvcmlnaW5hbCBsaXN0ZW5lci5cbiAgICAgIHJlbW92ZUxpc3RlbmVyT25EaXNwb3NlLmd1aWQgPSBsaXN0ZW5lci5ndWlkO1xuXG4gICAgICAvLyBBZGQgYSBsaXN0ZW5lciB0byB0aGUgdGFyZ2V0J3MgZGlzcG9zZSBldmVudCBhcyB3ZWxsLiBUaGlzIGVuc3VyZXNcbiAgICAgIC8vIHRoYXQgaWYgdGhlIHRhcmdldCBpcyBkaXNwb3NlZCBCRUZPUkUgdGhpcyBvYmplY3QsIHdlIHJlbW92ZSB0aGVcbiAgICAgIC8vIHJlbW92YWwgbGlzdGVuZXIgdGhhdCB3YXMganVzdCBhZGRlZC4gT3RoZXJ3aXNlLCB3ZSBjcmVhdGUgYSBtZW1vcnkgbGVhay5cbiAgICAgIHZhciByZW1vdmVSZW1vdmVyT25UYXJnZXREaXNwb3NlID0gZnVuY3Rpb24gcmVtb3ZlUmVtb3Zlck9uVGFyZ2V0RGlzcG9zZSgpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzLm9mZignZGlzcG9zZScsIHJlbW92ZUxpc3RlbmVyT25EaXNwb3NlKTtcbiAgICAgIH07XG5cbiAgICAgIC8vIFVzZSB0aGUgc2FtZSBmdW5jdGlvbiBJRCBhcyB0aGUgbGlzdGVuZXIgc28gd2UgY2FuIHJlbW92ZSBpdCBsYXRlclxuICAgICAgLy8gaXQgdXNpbmcgdGhlIElEIG9mIHRoZSBvcmlnaW5hbCBsaXN0ZW5lci5cbiAgICAgIHJlbW92ZVJlbW92ZXJPblRhcmdldERpc3Bvc2UuZ3VpZCA9IGxpc3RlbmVyLmd1aWQ7XG5cbiAgICAgIGxpc3Rlbih0aGlzLCAnb24nLCAnZGlzcG9zZScsIHJlbW92ZUxpc3RlbmVyT25EaXNwb3NlKTtcbiAgICAgIGxpc3Rlbih0YXJnZXQsICdvbicsICdkaXNwb3NlJywgcmVtb3ZlUmVtb3Zlck9uVGFyZ2V0RGlzcG9zZSk7XG4gICAgfVxuICB9LFxuXG5cbiAgLyoqXG4gICAqIEFkZCBhIGxpc3RlbmVyIHRvIGFuIGV2ZW50IChvciBldmVudHMpIG9uIHRoaXMgb2JqZWN0IG9yIGFub3RoZXIgZXZlbnRlZFxuICAgKiBvYmplY3QuIFRoZSBsaXN0ZW5lciB3aWxsIG9ubHkgYmUgY2FsbGVkIG9uY2UgYW5kIHRoZW4gcmVtb3ZlZC5cbiAgICpcbiAgICogQHBhcmFtICB7c3RyaW5nfEFycmF5fEVsZW1lbnR8T2JqZWN0fSB0YXJnZXRPclR5cGVcbiAgICogICAgICAgICBJZiB0aGlzIGlzIGEgc3RyaW5nIG9yIGFycmF5LCBpdCByZXByZXNlbnRzIHRoZSBldmVudCB0eXBlKHMpXG4gICAqICAgICAgICAgdGhhdCB3aWxsIHRyaWdnZXIgdGhlIGxpc3RlbmVyLlxuICAgKlxuICAgKiAgICAgICAgIEFub3RoZXIgZXZlbnRlZCBvYmplY3QgY2FuIGJlIHBhc3NlZCBoZXJlIGluc3RlYWQsIHdoaWNoIHdpbGxcbiAgICogICAgICAgICBjYXVzZSB0aGUgbGlzdGVuZXIgdG8gbGlzdGVuIGZvciBldmVudHMgb24gX3RoYXRfIG9iamVjdC5cbiAgICpcbiAgICogICAgICAgICBJbiBlaXRoZXIgY2FzZSwgdGhlIGxpc3RlbmVyJ3MgYHRoaXNgIHZhbHVlIHdpbGwgYmUgYm91bmQgdG9cbiAgICogICAgICAgICB0aGlzIG9iamVjdC5cbiAgICpcbiAgICogQHBhcmFtICB7c3RyaW5nfEFycmF5fEZ1bmN0aW9ufSB0eXBlT3JMaXN0ZW5lclxuICAgKiAgICAgICAgIElmIHRoZSBmaXJzdCBhcmd1bWVudCB3YXMgYSBzdHJpbmcgb3IgYXJyYXksIHRoaXMgc2hvdWxkIGJlIHRoZVxuICAgKiAgICAgICAgIGxpc3RlbmVyIGZ1bmN0aW9uLiBPdGhlcndpc2UsIHRoaXMgaXMgYSBzdHJpbmcgb3IgYXJyYXkgb2YgZXZlbnRcbiAgICogICAgICAgICB0eXBlKHMpLlxuICAgKlxuICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gW2xpc3RlbmVyXVxuICAgKiAgICAgICAgIElmIHRoZSBmaXJzdCBhcmd1bWVudCB3YXMgYW5vdGhlciBldmVudGVkIG9iamVjdCwgdGhpcyB3aWxsIGJlXG4gICAqICAgICAgICAgdGhlIGxpc3RlbmVyIGZ1bmN0aW9uLlxuICAgKi9cbiAgb25lOiBmdW5jdGlvbiBvbmUkJDEoKSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuMiksIF9rZXkyID0gMDsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgYXJnc1tfa2V5Ml0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgIH1cblxuICAgIHZhciBfbm9ybWFsaXplTGlzdGVuQXJnczIgPSBub3JtYWxpemVMaXN0ZW5BcmdzKHRoaXMsIGFyZ3MpLFxuICAgICAgICBpc1RhcmdldGluZ1NlbGYgPSBfbm9ybWFsaXplTGlzdGVuQXJnczIuaXNUYXJnZXRpbmdTZWxmLFxuICAgICAgICB0YXJnZXQgPSBfbm9ybWFsaXplTGlzdGVuQXJnczIudGFyZ2V0LFxuICAgICAgICB0eXBlID0gX25vcm1hbGl6ZUxpc3RlbkFyZ3MyLnR5cGUsXG4gICAgICAgIGxpc3RlbmVyID0gX25vcm1hbGl6ZUxpc3RlbkFyZ3MyLmxpc3RlbmVyO1xuXG4gICAgLy8gVGFyZ2V0aW5nIHRoaXMgZXZlbnRlZCBvYmplY3QuXG5cblxuICAgIGlmIChpc1RhcmdldGluZ1NlbGYpIHtcbiAgICAgIGxpc3Rlbih0YXJnZXQsICdvbmUnLCB0eXBlLCBsaXN0ZW5lcik7XG5cbiAgICAgIC8vIFRhcmdldGluZyBhbm90aGVyIGV2ZW50ZWQgb2JqZWN0LlxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgd3JhcHBlciA9IGZ1bmN0aW9uIHdyYXBwZXIoKSB7XG4gICAgICAgIGZvciAodmFyIF9sZW4zID0gYXJndW1lbnRzLmxlbmd0aCwgbGFyZ3MgPSBBcnJheShfbGVuMyksIF9rZXkzID0gMDsgX2tleTMgPCBfbGVuMzsgX2tleTMrKykge1xuICAgICAgICAgIGxhcmdzW19rZXkzXSA9IGFyZ3VtZW50c1tfa2V5M107XG4gICAgICAgIH1cblxuICAgICAgICBfdGhpczIub2ZmKHRhcmdldCwgdHlwZSwgd3JhcHBlcik7XG4gICAgICAgIGxpc3RlbmVyLmFwcGx5KG51bGwsIGxhcmdzKTtcbiAgICAgIH07XG5cbiAgICAgIC8vIFVzZSB0aGUgc2FtZSBmdW5jdGlvbiBJRCBhcyB0aGUgbGlzdGVuZXIgc28gd2UgY2FuIHJlbW92ZSBpdCBsYXRlclxuICAgICAgLy8gaXQgdXNpbmcgdGhlIElEIG9mIHRoZSBvcmlnaW5hbCBsaXN0ZW5lci5cbiAgICAgIHdyYXBwZXIuZ3VpZCA9IGxpc3RlbmVyLmd1aWQ7XG4gICAgICBsaXN0ZW4odGFyZ2V0LCAnb25lJywgdHlwZSwgd3JhcHBlcik7XG4gICAgfVxuICB9LFxuXG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgbGlzdGVuZXIocykgZnJvbSBldmVudChzKSBvbiBhbiBldmVudGVkIG9iamVjdC5cbiAgICpcbiAgICogQHBhcmFtICB7c3RyaW5nfEFycmF5fEVsZW1lbnR8T2JqZWN0fSBbdGFyZ2V0T3JUeXBlXVxuICAgKiAgICAgICAgIElmIHRoaXMgaXMgYSBzdHJpbmcgb3IgYXJyYXksIGl0IHJlcHJlc2VudHMgdGhlIGV2ZW50IHR5cGUocykuXG4gICAqXG4gICAqICAgICAgICAgQW5vdGhlciBldmVudGVkIG9iamVjdCBjYW4gYmUgcGFzc2VkIGhlcmUgaW5zdGVhZCwgaW4gd2hpY2ggY2FzZVxuICAgKiAgICAgICAgIEFMTCAzIGFyZ3VtZW50cyBhcmUgX3JlcXVpcmVkXy5cbiAgICpcbiAgICogQHBhcmFtICB7c3RyaW5nfEFycmF5fEZ1bmN0aW9ufSBbdHlwZU9yTGlzdGVuZXJdXG4gICAqICAgICAgICAgSWYgdGhlIGZpcnN0IGFyZ3VtZW50IHdhcyBhIHN0cmluZyBvciBhcnJheSwgdGhpcyBtYXkgYmUgdGhlXG4gICAqICAgICAgICAgbGlzdGVuZXIgZnVuY3Rpb24uIE90aGVyd2lzZSwgdGhpcyBpcyBhIHN0cmluZyBvciBhcnJheSBvZiBldmVudFxuICAgKiAgICAgICAgIHR5cGUocykuXG4gICAqXG4gICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBbbGlzdGVuZXJdXG4gICAqICAgICAgICAgSWYgdGhlIGZpcnN0IGFyZ3VtZW50IHdhcyBhbm90aGVyIGV2ZW50ZWQgb2JqZWN0LCB0aGlzIHdpbGwgYmVcbiAgICogICAgICAgICB0aGUgbGlzdGVuZXIgZnVuY3Rpb247IG90aGVyd2lzZSwgX2FsbF8gbGlzdGVuZXJzIGJvdW5kIHRvIHRoZVxuICAgKiAgICAgICAgIGV2ZW50IHR5cGUocykgd2lsbCBiZSByZW1vdmVkLlxuICAgKi9cbiAgb2ZmOiBmdW5jdGlvbiBvZmYkJDEodGFyZ2V0T3JUeXBlLCB0eXBlT3JMaXN0ZW5lciwgbGlzdGVuZXIpIHtcblxuICAgIC8vIFRhcmdldGluZyB0aGlzIGV2ZW50ZWQgb2JqZWN0LlxuICAgIGlmICghdGFyZ2V0T3JUeXBlIHx8IGlzVmFsaWRFdmVudFR5cGUodGFyZ2V0T3JUeXBlKSkge1xuICAgICAgb2ZmKHRoaXMuZXZlbnRCdXNFbF8sIHRhcmdldE9yVHlwZSwgdHlwZU9yTGlzdGVuZXIpO1xuXG4gICAgICAvLyBUYXJnZXRpbmcgYW5vdGhlciBldmVudGVkIG9iamVjdC5cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHRhcmdldCA9IHRhcmdldE9yVHlwZTtcbiAgICAgIHZhciB0eXBlID0gdHlwZU9yTGlzdGVuZXI7XG5cbiAgICAgIC8vIEZhaWwgZmFzdCBhbmQgaW4gYSBtZWFuaW5nZnVsIHdheSFcbiAgICAgIHZhbGlkYXRlVGFyZ2V0KHRhcmdldCk7XG4gICAgICB2YWxpZGF0ZUV2ZW50VHlwZSh0eXBlKTtcbiAgICAgIHZhbGlkYXRlTGlzdGVuZXIobGlzdGVuZXIpO1xuXG4gICAgICAvLyBFbnN1cmUgdGhlcmUncyBhdCBsZWFzdCBhIGd1aWQsIGV2ZW4gaWYgdGhlIGZ1bmN0aW9uIGhhc24ndCBiZWVuIHVzZWRcbiAgICAgIGxpc3RlbmVyID0gYmluZCh0aGlzLCBsaXN0ZW5lcik7XG5cbiAgICAgIC8vIFJlbW92ZSB0aGUgZGlzcG9zZSBsaXN0ZW5lciBvbiB0aGlzIGV2ZW50ZWQgb2JqZWN0LCB3aGljaCB3YXMgZ2l2ZW5cbiAgICAgIC8vIHRoZSBzYW1lIGd1aWQgYXMgdGhlIGV2ZW50IGxpc3RlbmVyIGluIG9uKCkuXG4gICAgICB0aGlzLm9mZignZGlzcG9zZScsIGxpc3RlbmVyKTtcblxuICAgICAgaWYgKHRhcmdldC5ub2RlTmFtZSkge1xuICAgICAgICBvZmYodGFyZ2V0LCB0eXBlLCBsaXN0ZW5lcik7XG4gICAgICAgIG9mZih0YXJnZXQsICdkaXNwb3NlJywgbGlzdGVuZXIpO1xuICAgICAgfSBlbHNlIGlmIChpc0V2ZW50ZWQodGFyZ2V0KSkge1xuICAgICAgICB0YXJnZXQub2ZmKHR5cGUsIGxpc3RlbmVyKTtcbiAgICAgICAgdGFyZ2V0Lm9mZignZGlzcG9zZScsIGxpc3RlbmVyKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cblxuICAvKipcbiAgICogRmlyZSBhbiBldmVudCBvbiB0aGlzIGV2ZW50ZWQgb2JqZWN0LCBjYXVzaW5nIGl0cyBsaXN0ZW5lcnMgdG8gYmUgY2FsbGVkLlxuICAgKlxuICAgKiBAcGFyYW0gICB7c3RyaW5nfE9iamVjdH0gZXZlbnRcbiAgICogICAgICAgICAgQW4gZXZlbnQgdHlwZSBvciBhbiBvYmplY3Qgd2l0aCBhIHR5cGUgcHJvcGVydHkuXG4gICAqXG4gICAqIEBwYXJhbSAgIHtPYmplY3R9IFtoYXNoXVxuICAgKiAgICAgICAgICBBbiBhZGRpdGlvbmFsIG9iamVjdCB0byBwYXNzIGFsb25nIHRvIGxpc3RlbmVycy5cbiAgICpcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqICAgICAgICAgIFdoZXRoZXIgb3Igbm90IHRoZSBkZWZhdWx0IGJlaGF2aW9yIHdhcyBwcmV2ZW50ZWQuXG4gICAqL1xuICB0cmlnZ2VyOiBmdW5jdGlvbiB0cmlnZ2VyJCQxKGV2ZW50LCBoYXNoKSB7XG4gICAgcmV0dXJuIHRyaWdnZXIodGhpcy5ldmVudEJ1c0VsXywgZXZlbnQsIGhhc2gpO1xuICB9XG59O1xuXG4vKipcbiAqIEFwcGxpZXMge0BsaW5rIG1vZHVsZTpldmVudGVkfkV2ZW50ZWRNaXhpbnxFdmVudGVkTWl4aW59IHRvIGEgdGFyZ2V0IG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gIHtPYmplY3R9IHRhcmdldFxuICogICAgICAgICBUaGUgb2JqZWN0IHRvIHdoaWNoIHRvIGFkZCBldmVudCBtZXRob2RzLlxuICpcbiAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnM9e31dXG4gKiAgICAgICAgIE9wdGlvbnMgZm9yIGN1c3RvbWl6aW5nIHRoZSBtaXhpbiBiZWhhdmlvci5cbiAqXG4gKiBAcGFyYW0gIHtTdHJpbmd9IFtvcHRpb25zLmV2ZW50QnVzS2V5XVxuICogICAgICAgICBCeSBkZWZhdWx0LCBhZGRzIGEgYGV2ZW50QnVzRWxfYCBET00gZWxlbWVudCB0byB0aGUgdGFyZ2V0IG9iamVjdCxcbiAqICAgICAgICAgd2hpY2ggaXMgdXNlZCBhcyBhbiBldmVudCBidXMuIElmIHRoZSB0YXJnZXQgb2JqZWN0IGFscmVhZHkgaGFzIGFcbiAqICAgICAgICAgRE9NIGVsZW1lbnQgdGhhdCBzaG91bGQgYmUgdXNlZCwgcGFzcyBpdHMga2V5IGhlcmUuXG4gKlxuICogQHJldHVybiB7T2JqZWN0fVxuICogICAgICAgICBUaGUgdGFyZ2V0IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gZXZlbnRlZCh0YXJnZXQpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICB2YXIgZXZlbnRCdXNLZXkgPSBvcHRpb25zLmV2ZW50QnVzS2V5O1xuXG4gIC8vIFNldCBvciBjcmVhdGUgdGhlIGV2ZW50QnVzRWxfLlxuXG4gIGlmIChldmVudEJ1c0tleSkge1xuICAgIGlmICghdGFyZ2V0W2V2ZW50QnVzS2V5XS5ub2RlTmFtZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgZXZlbnRCdXNLZXkgXCInICsgZXZlbnRCdXNLZXkgKyAnXCIgZG9lcyBub3QgcmVmZXIgdG8gYW4gZWxlbWVudC4nKTtcbiAgICB9XG4gICAgdGFyZ2V0LmV2ZW50QnVzRWxfID0gdGFyZ2V0W2V2ZW50QnVzS2V5XTtcbiAgfSBlbHNlIHtcbiAgICB0YXJnZXQuZXZlbnRCdXNFbF8gPSBjcmVhdGVFbCgnc3BhbicsIHsgY2xhc3NOYW1lOiAndmpzLWV2ZW50LWJ1cycgfSk7XG4gIH1cblxuICBhc3NpZ24odGFyZ2V0LCBFdmVudGVkTWl4aW4pO1xuXG4gIC8vIFdoZW4gYW55IGV2ZW50ZWQgb2JqZWN0IGlzIGRpc3Bvc2VkLCBpdCByZW1vdmVzIGFsbCBpdHMgbGlzdGVuZXJzLlxuICB0YXJnZXQub24oJ2Rpc3Bvc2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgdGFyZ2V0Lm9mZigpO1xuICAgIHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHRhcmdldC5ldmVudEJ1c0VsXyA9IG51bGw7XG4gICAgfSwgMCk7XG4gIH0pO1xuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbi8qKlxuICogQGZpbGUgbWl4aW5zL3N0YXRlZnVsLmpzXG4gKiBAbW9kdWxlIHN0YXRlZnVsXG4gKi9cbi8qKlxuICogQ29udGFpbnMgbWV0aG9kcyB0aGF0IHByb3ZpZGUgc3RhdGVmdWxuZXNzIHRvIGFuIG9iamVjdCB3aGljaCBpcyBwYXNzZWRcbiAqIHRvIHtAbGluayBtb2R1bGU6c3RhdGVmdWx9LlxuICpcbiAqIEBtaXhpbiBTdGF0ZWZ1bE1peGluXG4gKi9cbnZhciBTdGF0ZWZ1bE1peGluID0ge1xuXG4gIC8qKlxuICAgKiBBIGhhc2ggY29udGFpbmluZyBhcmJpdHJhcnkga2V5cyBhbmQgdmFsdWVzIHJlcHJlc2VudGluZyB0aGUgc3RhdGUgb2ZcbiAgICogdGhlIG9iamVjdC5cbiAgICpcbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIHN0YXRlOiB7fSxcblxuICAvKipcbiAgICogU2V0IHRoZSBzdGF0ZSBvZiBhbiBvYmplY3QgYnkgbXV0YXRpbmcgaXRzXG4gICAqIHtAbGluayBtb2R1bGU6c3RhdGVmdWx+U3RhdGVmdWxNaXhpbi5zdGF0ZXxzdGF0ZX0gb2JqZWN0IGluIHBsYWNlLlxuICAgKlxuICAgKiBAZmlyZXMgICBtb2R1bGU6c3RhdGVmdWx+U3RhdGVmdWxNaXhpbiNzdGF0ZWNoYW5nZWRcbiAgICogQHBhcmFtICAge09iamVjdHxGdW5jdGlvbn0gc3RhdGVVcGRhdGVzXG4gICAqICAgICAgICAgIEEgbmV3IHNldCBvZiBwcm9wZXJ0aWVzIHRvIHNoYWxsb3ctbWVyZ2UgaW50byB0aGUgcGx1Z2luIHN0YXRlLlxuICAgKiAgICAgICAgICBDYW4gYmUgYSBwbGFpbiBvYmplY3Qgb3IgYSBmdW5jdGlvbiByZXR1cm5pbmcgYSBwbGFpbiBvYmplY3QuXG4gICAqXG4gICAqIEByZXR1cm5zIHtPYmplY3R8dW5kZWZpbmVkfVxuICAgKiAgICAgICAgICBBbiBvYmplY3QgY29udGFpbmluZyBjaGFuZ2VzIHRoYXQgb2NjdXJyZWQuIElmIG5vIGNoYW5nZXNcbiAgICogICAgICAgICAgb2NjdXJyZWQsIHJldHVybnMgYHVuZGVmaW5lZGAuXG4gICAqL1xuICBzZXRTdGF0ZTogZnVuY3Rpb24gc2V0U3RhdGUoc3RhdGVVcGRhdGVzKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIC8vIFN1cHBvcnQgcHJvdmlkaW5nIHRoZSBgc3RhdGVVcGRhdGVzYCBzdGF0ZSBhcyBhIGZ1bmN0aW9uLlxuICAgIGlmICh0eXBlb2Ygc3RhdGVVcGRhdGVzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBzdGF0ZVVwZGF0ZXMgPSBzdGF0ZVVwZGF0ZXMoKTtcbiAgICB9XG5cbiAgICB2YXIgY2hhbmdlcyA9IHZvaWQgMDtcblxuICAgIGVhY2goc3RhdGVVcGRhdGVzLCBmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuXG4gICAgICAvLyBSZWNvcmQgdGhlIGNoYW5nZSBpZiB0aGUgdmFsdWUgaXMgZGlmZmVyZW50IGZyb20gd2hhdCdzIGluIHRoZVxuICAgICAgLy8gY3VycmVudCBzdGF0ZS5cbiAgICAgIGlmIChfdGhpcy5zdGF0ZVtrZXldICE9PSB2YWx1ZSkge1xuICAgICAgICBjaGFuZ2VzID0gY2hhbmdlcyB8fCB7fTtcbiAgICAgICAgY2hhbmdlc1trZXldID0ge1xuICAgICAgICAgIGZyb206IF90aGlzLnN0YXRlW2tleV0sXG4gICAgICAgICAgdG86IHZhbHVlXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIF90aGlzLnN0YXRlW2tleV0gPSB2YWx1ZTtcbiAgICB9KTtcblxuICAgIC8vIE9ubHkgdHJpZ2dlciBcInN0YXRlY2hhbmdlXCIgaWYgdGhlcmUgd2VyZSBjaGFuZ2VzIEFORCB3ZSBoYXZlIGEgdHJpZ2dlclxuICAgIC8vIGZ1bmN0aW9uLiBUaGlzIGFsbG93cyB1cyB0byBub3QgcmVxdWlyZSB0aGF0IHRoZSB0YXJnZXQgb2JqZWN0IGJlIGFuXG4gICAgLy8gZXZlbnRlZCBvYmplY3QuXG4gICAgaWYgKGNoYW5nZXMgJiYgaXNFdmVudGVkKHRoaXMpKSB7XG5cbiAgICAgIC8qKlxuICAgICAgICogQW4gZXZlbnQgdHJpZ2dlcmVkIG9uIGFuIG9iamVjdCB0aGF0IGlzIGJvdGhcbiAgICAgICAqIHtAbGluayBtb2R1bGU6c3RhdGVmdWx8c3RhdGVmdWx9IGFuZCB7QGxpbmsgbW9kdWxlOmV2ZW50ZWR8ZXZlbnRlZH1cbiAgICAgICAqIGluZGljYXRpbmcgdGhhdCBpdHMgc3RhdGUgaGFzIGNoYW5nZWQuXG4gICAgICAgKlxuICAgICAgICogQGV2ZW50ICAgIG1vZHVsZTpzdGF0ZWZ1bH5TdGF0ZWZ1bE1peGluI3N0YXRlY2hhbmdlZFxuICAgICAgICogQHR5cGUgICAgIHtPYmplY3R9XG4gICAgICAgKiBAcHJvcGVydHkge09iamVjdH0gY2hhbmdlc1xuICAgICAgICogICAgICAgICAgIEEgaGFzaCBjb250YWluaW5nIHRoZSBwcm9wZXJ0aWVzIHRoYXQgd2VyZSBjaGFuZ2VkIGFuZFxuICAgICAgICogICAgICAgICAgIHRoZSB2YWx1ZXMgdGhleSB3ZXJlIGNoYW5nZWQgYGZyb21gIGFuZCBgdG9gLlxuICAgICAgICovXG4gICAgICB0aGlzLnRyaWdnZXIoe1xuICAgICAgICBjaGFuZ2VzOiBjaGFuZ2VzLFxuICAgICAgICB0eXBlOiAnc3RhdGVjaGFuZ2VkJ1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNoYW5nZXM7XG4gIH1cbn07XG5cbi8qKlxuICogQXBwbGllcyB7QGxpbmsgbW9kdWxlOnN0YXRlZnVsflN0YXRlZnVsTWl4aW58U3RhdGVmdWxNaXhpbn0gdG8gYSB0YXJnZXRcbiAqIG9iamVjdC5cbiAqXG4gKiBJZiB0aGUgdGFyZ2V0IG9iamVjdCBpcyB7QGxpbmsgbW9kdWxlOmV2ZW50ZWR8ZXZlbnRlZH0gYW5kIGhhcyBhXG4gKiBgaGFuZGxlU3RhdGVDaGFuZ2VkYCBtZXRob2QsIHRoYXQgbWV0aG9kIHdpbGwgYmUgYXV0b21hdGljYWxseSBib3VuZCB0byB0aGVcbiAqIGBzdGF0ZWNoYW5nZWRgIGV2ZW50IG9uIGl0c2VsZi5cbiAqXG4gKiBAcGFyYW0gICB7T2JqZWN0fSB0YXJnZXRcbiAqICAgICAgICAgIFRoZSBvYmplY3QgdG8gYmUgbWFkZSBzdGF0ZWZ1bC5cbiAqXG4gKiBAcGFyYW0gICB7T2JqZWN0fSBbZGVmYXVsdFN0YXRlXVxuICogICAgICAgICAgQSBkZWZhdWx0IHNldCBvZiBwcm9wZXJ0aWVzIHRvIHBvcHVsYXRlIHRoZSBuZXdseS1zdGF0ZWZ1bCBvYmplY3Qnc1xuICogICAgICAgICAgYHN0YXRlYCBwcm9wZXJ0eS5cbiAqXG4gKiBAcmV0dXJucyB7T2JqZWN0fVxuICogICAgICAgICAgUmV0dXJucyB0aGUgYHRhcmdldGAuXG4gKi9cbmZ1bmN0aW9uIHN0YXRlZnVsKHRhcmdldCwgZGVmYXVsdFN0YXRlKSB7XG4gIGFzc2lnbih0YXJnZXQsIFN0YXRlZnVsTWl4aW4pO1xuXG4gIC8vIFRoaXMgaGFwcGVucyBhZnRlciB0aGUgbWl4aW5nLWluIGJlY2F1c2Ugd2UgbmVlZCB0byByZXBsYWNlIHRoZSBgc3RhdGVgXG4gIC8vIGFkZGVkIGluIHRoYXQgc3RlcC5cbiAgdGFyZ2V0LnN0YXRlID0gYXNzaWduKHt9LCB0YXJnZXQuc3RhdGUsIGRlZmF1bHRTdGF0ZSk7XG5cbiAgLy8gQXV0by1iaW5kIHRoZSBgaGFuZGxlU3RhdGVDaGFuZ2VkYCBtZXRob2Qgb2YgdGhlIHRhcmdldCBvYmplY3QgaWYgaXQgZXhpc3RzLlxuICBpZiAodHlwZW9mIHRhcmdldC5oYW5kbGVTdGF0ZUNoYW5nZWQgPT09ICdmdW5jdGlvbicgJiYgaXNFdmVudGVkKHRhcmdldCkpIHtcbiAgICB0YXJnZXQub24oJ3N0YXRlY2hhbmdlZCcsIHRhcmdldC5oYW5kbGVTdGF0ZUNoYW5nZWQpO1xuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuLyoqXG4gKiBAZmlsZSB0by10aXRsZS1jYXNlLmpzXG4gKiBAbW9kdWxlIHRvLXRpdGxlLWNhc2VcbiAqL1xuXG4vKipcbiAqIFVwcGVyY2FzZSB0aGUgZmlyc3QgbGV0dGVyIG9mIGEgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmdcbiAqICAgICAgICBTdHJpbmcgdG8gYmUgdXBwZXJjYXNlZFxuICpcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqICAgICAgICAgVGhlIHN0cmluZyB3aXRoIGFuIHVwcGVyY2FzZWQgZmlyc3QgbGV0dGVyXG4gKi9cbmZ1bmN0aW9uIHRvVGl0bGVDYXNlKHN0cmluZykge1xuICBpZiAodHlwZW9mIHN0cmluZyAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gc3RyaW5nO1xuICB9XG5cbiAgcmV0dXJuIHN0cmluZy5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0cmluZy5zbGljZSgxKTtcbn1cblxuLyoqXG4gKiBDb21wYXJlcyB0aGUgVGl0bGVDYXNlIHZlcnNpb25zIG9mIHRoZSB0d28gc3RyaW5ncyBmb3IgZXF1YWxpdHkuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0cjFcbiAqICAgICAgICBUaGUgZmlyc3Qgc3RyaW5nIHRvIGNvbXBhcmVcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyMlxuICogICAgICAgIFRoZSBzZWNvbmQgc3RyaW5nIHRvIGNvbXBhcmVcbiAqXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICogICAgICAgICBXaGV0aGVyIHRoZSBUaXRsZUNhc2UgdmVyc2lvbnMgb2YgdGhlIHN0cmluZ3MgYXJlIGVxdWFsXG4gKi9cbmZ1bmN0aW9uIHRpdGxlQ2FzZUVxdWFscyhzdHIxLCBzdHIyKSB7XG4gIHJldHVybiB0b1RpdGxlQ2FzZShzdHIxKSA9PT0gdG9UaXRsZUNhc2Uoc3RyMik7XG59XG5cbi8qKlxuICogQGZpbGUgbWVyZ2Utb3B0aW9ucy5qc1xuICogQG1vZHVsZSBtZXJnZS1vcHRpb25zXG4gKi9cbi8qKlxuICogRGVlcC1tZXJnZSBvbmUgb3IgbW9yZSBvcHRpb25zIG9iamVjdHMsIHJlY3Vyc2l2ZWx5IG1lcmdpbmcgKipvbmx5KiogcGxhaW5cbiAqIG9iamVjdCBwcm9wZXJ0aWVzLlxuICpcbiAqIEBwYXJhbSAgIHtPYmplY3RbXX0gc291cmNlc1xuICogICAgICAgICAgT25lIG9yIG1vcmUgb2JqZWN0cyB0byBtZXJnZSBpbnRvIGEgbmV3IG9iamVjdC5cbiAqXG4gKiBAcmV0dXJucyB7T2JqZWN0fVxuICogICAgICAgICAgQSBuZXcgb2JqZWN0IHRoYXQgaXMgdGhlIG1lcmdlZCByZXN1bHQgb2YgYWxsIHNvdXJjZXMuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlT3B0aW9ucygpIHtcbiAgdmFyIHJlc3VsdCA9IHt9O1xuXG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBzb3VyY2VzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgc291cmNlc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIHNvdXJjZXMuZm9yRWFjaChmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgaWYgKCFzb3VyY2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBlYWNoKHNvdXJjZSwgZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICAgIGlmICghaXNQbGFpbih2YWx1ZSkpIHtcbiAgICAgICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWlzUGxhaW4ocmVzdWx0W2tleV0pKSB7XG4gICAgICAgIHJlc3VsdFtrZXldID0ge307XG4gICAgICB9XG5cbiAgICAgIHJlc3VsdFtrZXldID0gbWVyZ2VPcHRpb25zKHJlc3VsdFtrZXldLCB2YWx1ZSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogUGxheWVyIENvbXBvbmVudCAtIEJhc2UgY2xhc3MgZm9yIGFsbCBVSSBvYmplY3RzXG4gKlxuICogQGZpbGUgY29tcG9uZW50LmpzXG4gKi9cbi8qKlxuICogQmFzZSBjbGFzcyBmb3IgYWxsIFVJIENvbXBvbmVudHMuXG4gKiBDb21wb25lbnRzIGFyZSBVSSBvYmplY3RzIHdoaWNoIHJlcHJlc2VudCBib3RoIGEgamF2YXNjcmlwdCBvYmplY3QgYW5kIGFuIGVsZW1lbnRcbiAqIGluIHRoZSBET00uIFRoZXkgY2FuIGJlIGNoaWxkcmVuIG9mIG90aGVyIGNvbXBvbmVudHMsIGFuZCBjYW4gaGF2ZVxuICogY2hpbGRyZW4gdGhlbXNlbHZlcy5cbiAqXG4gKiBDb21wb25lbnRzIGNhbiBhbHNvIHVzZSBtZXRob2RzIGZyb20ge0BsaW5rIEV2ZW50VGFyZ2V0fVxuICovXG5cbnZhciBDb21wb25lbnQgPSBmdW5jdGlvbiAoKSB7XG5cbiAgLyoqXG4gICAqIEEgY2FsbGJhY2sgdGhhdCBpcyBjYWxsZWQgd2hlbiBhIGNvbXBvbmVudCBpcyByZWFkeS4gRG9lcyBub3QgaGF2ZSBhbnlcbiAgICogcGFyYW10ZXJzIGFuZCBhbnkgY2FsbGJhY2sgdmFsdWUgd2lsbCBiZSBpZ25vcmVkLlxuICAgKlxuICAgKiBAY2FsbGJhY2sgQ29tcG9uZW50flJlYWR5Q2FsbGJhY2tcbiAgICogQHRoaXMgQ29tcG9uZW50XG4gICAqL1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7UGxheWVyfSBwbGF5ZXJcbiAgICogICAgICAgIFRoZSBgUGxheWVyYCB0aGF0IHRoaXMgY2xhc3Mgc2hvdWxkIGJlIGF0dGFjaGVkIHRvLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgICAgICBUaGUga2V5L3ZhbHVlIHN0b3JlIG9mIHBsYXllciBvcHRpb25zLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdFtdfSBbb3B0aW9ucy5jaGlsZHJlbl1cbiAgICogICAgICAgIEFuIGFycmF5IG9mIGNoaWxkcmVuIG9iamVjdHMgdG8gaW50aWFsaXplIHRoaXMgY29tcG9uZW50IHdpdGguIENoaWxkcmVuIG9iamVjdHMgaGF2ZVxuICAgKiAgICAgICAgYSBuYW1lIHByb3BlcnR5IHRoYXQgd2lsbCBiZSB1c2VkIGlmIG1vcmUgdGhhbiBvbmUgY29tcG9uZW50IG9mIHRoZSBzYW1lIHR5cGUgbmVlZHMgdG8gYmVcbiAgICogICAgICAgIGFkZGVkLlxuICAgKlxuICAgKiBAcGFyYW0ge0NvbXBvbmVudH5SZWFkeUNhbGxiYWNrfSBbcmVhZHldXG4gICAqICAgICAgICBGdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIHdoZW4gdGhlIGBDb21wb25lbnRgIGlzIHJlYWR5LlxuICAgKi9cbiAgZnVuY3Rpb24gQ29tcG9uZW50KHBsYXllciwgb3B0aW9ucywgcmVhZHkpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBDb21wb25lbnQpO1xuXG5cbiAgICAvLyBUaGUgY29tcG9uZW50IG1pZ2h0IGJlIHRoZSBwbGF5ZXIgaXRzZWxmIGFuZCB3ZSBjYW4ndCBwYXNzIGB0aGlzYCB0byBzdXBlclxuICAgIGlmICghcGxheWVyICYmIHRoaXMucGxheSkge1xuICAgICAgdGhpcy5wbGF5ZXJfID0gcGxheWVyID0gdGhpczsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnBsYXllcl8gPSBwbGF5ZXI7XG4gICAgfVxuXG4gICAgLy8gTWFrZSBhIGNvcHkgb2YgcHJvdG90eXBlLm9wdGlvbnNfIHRvIHByb3RlY3QgYWdhaW5zdCBvdmVycmlkaW5nIGRlZmF1bHRzXG4gICAgdGhpcy5vcHRpb25zXyA9IG1lcmdlT3B0aW9ucyh7fSwgdGhpcy5vcHRpb25zXyk7XG5cbiAgICAvLyBVcGRhdGVkIG9wdGlvbnMgd2l0aCBzdXBwbGllZCBvcHRpb25zXG4gICAgb3B0aW9ucyA9IHRoaXMub3B0aW9uc18gPSBtZXJnZU9wdGlvbnModGhpcy5vcHRpb25zXywgb3B0aW9ucyk7XG5cbiAgICAvLyBHZXQgSUQgZnJvbSBvcHRpb25zIG9yIG9wdGlvbnMgZWxlbWVudCBpZiBvbmUgaXMgc3VwcGxpZWRcbiAgICB0aGlzLmlkXyA9IG9wdGlvbnMuaWQgfHwgb3B0aW9ucy5lbCAmJiBvcHRpb25zLmVsLmlkO1xuXG4gICAgLy8gSWYgdGhlcmUgd2FzIG5vIElEIGZyb20gdGhlIG9wdGlvbnMsIGdlbmVyYXRlIG9uZVxuICAgIGlmICghdGhpcy5pZF8pIHtcbiAgICAgIC8vIERvbid0IHJlcXVpcmUgdGhlIHBsYXllciBJRCBmdW5jdGlvbiBpbiB0aGUgY2FzZSBvZiBtb2NrIHBsYXllcnNcbiAgICAgIHZhciBpZCA9IHBsYXllciAmJiBwbGF5ZXIuaWQgJiYgcGxheWVyLmlkKCkgfHwgJ25vX3BsYXllcic7XG5cbiAgICAgIHRoaXMuaWRfID0gaWQgKyAnX2NvbXBvbmVudF8nICsgbmV3R1VJRCgpO1xuICAgIH1cblxuICAgIHRoaXMubmFtZV8gPSBvcHRpb25zLm5hbWUgfHwgbnVsbDtcblxuICAgIC8vIENyZWF0ZSBlbGVtZW50IGlmIG9uZSB3YXNuJ3QgcHJvdmlkZWQgaW4gb3B0aW9uc1xuICAgIGlmIChvcHRpb25zLmVsKSB7XG4gICAgICB0aGlzLmVsXyA9IG9wdGlvbnMuZWw7XG4gICAgfSBlbHNlIGlmIChvcHRpb25zLmNyZWF0ZUVsICE9PSBmYWxzZSkge1xuICAgICAgdGhpcy5lbF8gPSB0aGlzLmNyZWF0ZUVsKCk7XG4gICAgfVxuXG4gICAgLy8gaWYgZXZlbnRlZCBpcyBhbnl0aGluZyBleGNlcHQgZmFsc2UsIHdlIHdhbnQgdG8gbWl4aW4gaW4gZXZlbnRlZFxuICAgIGlmIChvcHRpb25zLmV2ZW50ZWQgIT09IGZhbHNlKSB7XG4gICAgICAvLyBNYWtlIHRoaXMgYW4gZXZlbnRlZCBvYmplY3QgYW5kIHVzZSBgZWxfYCwgaWYgYXZhaWxhYmxlLCBhcyBpdHMgZXZlbnQgYnVzXG4gICAgICBldmVudGVkKHRoaXMsIHsgZXZlbnRCdXNLZXk6IHRoaXMuZWxfID8gJ2VsXycgOiBudWxsIH0pO1xuICAgIH1cbiAgICBzdGF0ZWZ1bCh0aGlzLCB0aGlzLmNvbnN0cnVjdG9yLmRlZmF1bHRTdGF0ZSk7XG5cbiAgICB0aGlzLmNoaWxkcmVuXyA9IFtdO1xuICAgIHRoaXMuY2hpbGRJbmRleF8gPSB7fTtcbiAgICB0aGlzLmNoaWxkTmFtZUluZGV4XyA9IHt9O1xuXG4gICAgLy8gQWRkIGFueSBjaGlsZCBjb21wb25lbnRzIGluIG9wdGlvbnNcbiAgICBpZiAob3B0aW9ucy5pbml0Q2hpbGRyZW4gIT09IGZhbHNlKSB7XG4gICAgICB0aGlzLmluaXRDaGlsZHJlbigpO1xuICAgIH1cblxuICAgIHRoaXMucmVhZHkocmVhZHkpO1xuICAgIC8vIERvbid0IHdhbnQgdG8gdHJpZ2dlciByZWFkeSBoZXJlIG9yIGl0IHdpbGwgYmVmb3JlIGluaXQgaXMgYWN0dWFsbHlcbiAgICAvLyBmaW5pc2hlZCBmb3IgYWxsIGNoaWxkcmVuIHRoYXQgcnVuIHRoaXMgY29uc3RydWN0b3JcblxuICAgIGlmIChvcHRpb25zLnJlcG9ydFRvdWNoQWN0aXZpdHkgIT09IGZhbHNlKSB7XG4gICAgICB0aGlzLmVuYWJsZVRvdWNoQWN0aXZpdHkoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRGlzcG9zZSBvZiB0aGUgYENvbXBvbmVudGAgYW5kIGFsbCBjaGlsZCBjb21wb25lbnRzLlxuICAgKlxuICAgKiBAZmlyZXMgQ29tcG9uZW50I2Rpc3Bvc2VcbiAgICovXG5cblxuICBDb21wb25lbnQucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiBkaXNwb3NlKCkge1xuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIHdoZW4gYSBgQ29tcG9uZW50YCBpcyBkaXNwb3NlZC5cbiAgICAgKlxuICAgICAqIEBldmVudCBDb21wb25lbnQjZGlzcG9zZVxuICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2J1YmJsZXM9ZmFsc2VdXG4gICAgICogICAgICAgICAgIHNldCB0byBmYWxzZSBzbyB0aGF0IHRoZSBjbG9zZSBldmVudCBkb2VzIG5vdFxuICAgICAqICAgICAgICAgICBidWJibGUgdXBcbiAgICAgKi9cbiAgICB0aGlzLnRyaWdnZXIoeyB0eXBlOiAnZGlzcG9zZScsIGJ1YmJsZXM6IGZhbHNlIH0pO1xuXG4gICAgLy8gRGlzcG9zZSBhbGwgY2hpbGRyZW4uXG4gICAgaWYgKHRoaXMuY2hpbGRyZW5fKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy5jaGlsZHJlbl8ubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgaWYgKHRoaXMuY2hpbGRyZW5fW2ldLmRpc3Bvc2UpIHtcbiAgICAgICAgICB0aGlzLmNoaWxkcmVuX1tpXS5kaXNwb3NlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBEZWxldGUgY2hpbGQgcmVmZXJlbmNlc1xuICAgIHRoaXMuY2hpbGRyZW5fID0gbnVsbDtcbiAgICB0aGlzLmNoaWxkSW5kZXhfID0gbnVsbDtcbiAgICB0aGlzLmNoaWxkTmFtZUluZGV4XyA9IG51bGw7XG5cbiAgICBpZiAodGhpcy5lbF8pIHtcbiAgICAgIC8vIFJlbW92ZSBlbGVtZW50IGZyb20gRE9NXG4gICAgICBpZiAodGhpcy5lbF8ucGFyZW50Tm9kZSkge1xuICAgICAgICB0aGlzLmVsXy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuZWxfKTtcbiAgICAgIH1cblxuICAgICAgcmVtb3ZlRGF0YSh0aGlzLmVsXyk7XG4gICAgICB0aGlzLmVsXyA9IG51bGw7XG4gICAgfVxuXG4gICAgLy8gcmVtb3ZlIHJlZmVyZW5jZSB0byB0aGUgcGxheWVyIGFmdGVyIGRpc3Bvc2luZyBvZiB0aGUgZWxlbWVudFxuICAgIHRoaXMucGxheWVyXyA9IG51bGw7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUge0BsaW5rIFBsYXllcn0gdGhhdCB0aGUgYENvbXBvbmVudGAgaGFzIGF0dGFjaGVkIHRvLlxuICAgKlxuICAgKiBAcmV0dXJuIHtQbGF5ZXJ9XG4gICAqICAgICAgICAgVGhlIHBsYXllciB0aGF0IHRoaXMgYENvbXBvbmVudGAgaGFzIGF0dGFjaGVkIHRvLlxuICAgKi9cblxuXG4gIENvbXBvbmVudC5wcm90b3R5cGUucGxheWVyID0gZnVuY3Rpb24gcGxheWVyKCkge1xuICAgIHJldHVybiB0aGlzLnBsYXllcl87XG4gIH07XG5cbiAgLyoqXG4gICAqIERlZXAgbWVyZ2Ugb2Ygb3B0aW9ucyBvYmplY3RzIHdpdGggbmV3IG9wdGlvbnMuXG4gICAqID4gTm90ZTogV2hlbiBib3RoIGBvYmpgIGFuZCBgb3B0aW9uc2AgY29udGFpbiBwcm9wZXJ0aWVzIHdob3NlIHZhbHVlcyBhcmUgb2JqZWN0cy5cbiAgICogICAgICAgICBUaGUgdHdvIHByb3BlcnRpZXMgZ2V0IG1lcmdlZCB1c2luZyB7QGxpbmsgbW9kdWxlOm1lcmdlT3B0aW9uc31cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG9ialxuICAgKiAgICAgICAgVGhlIG9iamVjdCB0aGF0IGNvbnRhaW5zIG5ldyBvcHRpb25zLlxuICAgKlxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqICAgICAgICAgQSBuZXcgb2JqZWN0IG9mIGB0aGlzLm9wdGlvbnNfYCBhbmQgYG9iamAgbWVyZ2VkIHRvZ2V0aGVyLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDVcbiAgICovXG5cblxuICBDb21wb25lbnQucHJvdG90eXBlLm9wdGlvbnMgPSBmdW5jdGlvbiBvcHRpb25zKG9iaikge1xuICAgIGxvZy53YXJuKCd0aGlzLm9wdGlvbnMoKSBoYXMgYmVlbiBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIG1vdmVkIHRvIHRoZSBjb25zdHJ1Y3RvciBpbiA2LjAnKTtcblxuICAgIGlmICghb2JqKSB7XG4gICAgICByZXR1cm4gdGhpcy5vcHRpb25zXztcbiAgICB9XG5cbiAgICB0aGlzLm9wdGlvbnNfID0gbWVyZ2VPcHRpb25zKHRoaXMub3B0aW9uc18sIG9iaik7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9uc187XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgYENvbXBvbmVudGBzIERPTSBlbGVtZW50XG4gICAqXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9XG4gICAqICAgICAgICAgVGhlIERPTSBlbGVtZW50IGZvciB0aGlzIGBDb21wb25lbnRgLlxuICAgKi9cblxuXG4gIENvbXBvbmVudC5wcm90b3R5cGUuZWwgPSBmdW5jdGlvbiBlbCgpIHtcbiAgICByZXR1cm4gdGhpcy5lbF87XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSB0aGUgYENvbXBvbmVudGBzIERPTSBlbGVtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW3RhZ05hbWVdXG4gICAqICAgICAgICBFbGVtZW50J3MgRE9NIG5vZGUgdHlwZS4gZS5nLiAnZGl2J1xuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW3Byb3BlcnRpZXNdXG4gICAqICAgICAgICBBbiBvYmplY3Qgb2YgcHJvcGVydGllcyB0aGF0IHNob3VsZCBiZSBzZXQuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbYXR0cmlidXRlc11cbiAgICogICAgICAgIEFuIG9iamVjdCBvZiBhdHRyaWJ1dGVzIHRoYXQgc2hvdWxkIGJlIHNldC5cbiAgICpcbiAgICogQHJldHVybiB7RWxlbWVudH1cbiAgICogICAgICAgICBUaGUgZWxlbWVudCB0aGF0IGdldHMgY3JlYXRlZC5cbiAgICovXG5cblxuICBDb21wb25lbnQucHJvdG90eXBlLmNyZWF0ZUVsID0gZnVuY3Rpb24gY3JlYXRlRWwkJDEodGFnTmFtZSwgcHJvcGVydGllcywgYXR0cmlidXRlcykge1xuICAgIHJldHVybiBjcmVhdGVFbCh0YWdOYW1lLCBwcm9wZXJ0aWVzLCBhdHRyaWJ1dGVzKTtcbiAgfTtcblxuICAvKipcbiAgICogTG9jYWxpemUgYSBzdHJpbmcgZ2l2ZW4gdGhlIHN0cmluZyBpbiBlbmdsaXNoLlxuICAgKlxuICAgKiBJZiB0b2tlbnMgYXJlIHByb3ZpZGVkLCBpdCdsbCB0cnkgYW5kIHJ1biBhIHNpbXBsZSB0b2tlbiByZXBsYWNlbWVudCBvbiB0aGUgcHJvdmlkZWQgc3RyaW5nLlxuICAgKiBUaGUgdG9rZW5zIGl0IGxvb2tzIGZvciBsb29rIGxpa2UgYHsxfWAgd2l0aCB0aGUgaW5kZXggYmVpbmcgMS1pbmRleGVkIGludG8gdGhlIHRva2VucyBhcnJheS5cbiAgICpcbiAgICogSWYgYSBgZGVmYXVsdFZhbHVlYCBpcyBwcm92aWRlZCwgaXQnbGwgdXNlIHRoYXQgb3ZlciBgc3RyaW5nYCxcbiAgICogaWYgYSB2YWx1ZSBpc24ndCBmb3VuZCBpbiBwcm92aWRlZCBsYW5ndWFnZSBmaWxlcy5cbiAgICogVGhpcyBpcyB1c2VmdWwgaWYgeW91IHdhbnQgdG8gaGF2ZSBhIGRlc2NyaXB0aXZlIGtleSBmb3IgdG9rZW4gcmVwbGFjZW1lbnRcbiAgICogYnV0IGhhdmUgYSBzdWNjaW5jdCBsb2NhbGl6ZWQgc3RyaW5nIGFuZCBub3QgcmVxdWlyZSBgZW4uanNvbmAgdG8gYmUgaW5jbHVkZWQuXG4gICAqXG4gICAqIEN1cnJlbnRseSwgaXQgaXMgdXNlZCBmb3IgdGhlIHByb2dyZXNzIGJhciB0aW1pbmcuXG4gICAqIGBgYGpzXG4gICAqIHtcbiAgICogICBcInByb2dyZXNzIGJhciB0aW1pbmc6IGN1cnJlbnRUaW1lPXsxfSBkdXJhdGlvbj17Mn1cIjogXCJ7MX0gb2YgezJ9XCJcbiAgICogfVxuICAgKiBgYGBcbiAgICogSXQgaXMgdGhlbiB1c2VkIGxpa2Ugc286XG4gICAqIGBgYGpzXG4gICAqIHRoaXMubG9jYWxpemUoJ3Byb2dyZXNzIGJhciB0aW1pbmc6IGN1cnJlbnRUaW1lPXsxfSBkdXJhdGlvbnsyfScsXG4gICAqICAgICAgICAgICAgICAgW3RoaXMucGxheWVyXy5jdXJyZW50VGltZSgpLCB0aGlzLnBsYXllcl8uZHVyYXRpb24oKV0sXG4gICAqICAgICAgICAgICAgICAgJ3sxfSBvZiB7Mn0nKTtcbiAgICogYGBgXG4gICAqXG4gICAqIFdoaWNoIG91dHB1dHMgc29tZXRoaW5nIGxpa2U6IGAwMToyMyBvZiAyNDo1NmAuXG4gICAqXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmdcbiAgICogICAgICAgIFRoZSBzdHJpbmcgdG8gbG9jYWxpemUgYW5kIHRoZSBrZXkgdG8gbG9va3VwIGluIHRoZSBsYW5ndWFnZSBmaWxlcy5cbiAgICogQHBhcmFtIHtzdHJpbmdbXX0gW3Rva2Vuc11cbiAgICogICAgICAgIElmIHRoZSBjdXJyZW50IGl0ZW0gaGFzIHRva2VuIHJlcGxhY2VtZW50cywgcHJvdmlkZSB0aGUgdG9rZW5zIGhlcmUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbZGVmYXVsdFZhbHVlXVxuICAgKiAgICAgICAgRGVmYXVsdHMgdG8gYHN0cmluZ2AuIENhbiBiZSBhIGRlZmF1bHQgdmFsdWUgdG8gdXNlIGZvciB0b2tlbiByZXBsYWNlbWVudFxuICAgKiAgICAgICAgaWYgdGhlIGxvb2t1cCBrZXkgaXMgbmVlZGVkIHRvIGJlIHNlcGFyYXRlLlxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqICAgICAgICAgVGhlIGxvY2FsaXplZCBzdHJpbmcgb3IgaWYgbm8gbG9jYWxpemF0aW9uIGV4aXN0cyB0aGUgZW5nbGlzaCBzdHJpbmcuXG4gICAqL1xuXG5cbiAgQ29tcG9uZW50LnByb3RvdHlwZS5sb2NhbGl6ZSA9IGZ1bmN0aW9uIGxvY2FsaXplKHN0cmluZywgdG9rZW5zKSB7XG4gICAgdmFyIGRlZmF1bHRWYWx1ZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogc3RyaW5nO1xuXG4gICAgdmFyIGNvZGUgPSB0aGlzLnBsYXllcl8ubGFuZ3VhZ2UgJiYgdGhpcy5wbGF5ZXJfLmxhbmd1YWdlKCk7XG4gICAgdmFyIGxhbmd1YWdlcyA9IHRoaXMucGxheWVyXy5sYW5ndWFnZXMgJiYgdGhpcy5wbGF5ZXJfLmxhbmd1YWdlcygpO1xuICAgIHZhciBsYW5ndWFnZSA9IGxhbmd1YWdlcyAmJiBsYW5ndWFnZXNbY29kZV07XG4gICAgdmFyIHByaW1hcnlDb2RlID0gY29kZSAmJiBjb2RlLnNwbGl0KCctJylbMF07XG4gICAgdmFyIHByaW1hcnlMYW5nID0gbGFuZ3VhZ2VzICYmIGxhbmd1YWdlc1twcmltYXJ5Q29kZV07XG5cbiAgICB2YXIgbG9jYWxpemVkU3RyaW5nID0gZGVmYXVsdFZhbHVlO1xuXG4gICAgaWYgKGxhbmd1YWdlICYmIGxhbmd1YWdlW3N0cmluZ10pIHtcbiAgICAgIGxvY2FsaXplZFN0cmluZyA9IGxhbmd1YWdlW3N0cmluZ107XG4gICAgfSBlbHNlIGlmIChwcmltYXJ5TGFuZyAmJiBwcmltYXJ5TGFuZ1tzdHJpbmddKSB7XG4gICAgICBsb2NhbGl6ZWRTdHJpbmcgPSBwcmltYXJ5TGFuZ1tzdHJpbmddO1xuICAgIH1cblxuICAgIGlmICh0b2tlbnMpIHtcbiAgICAgIGxvY2FsaXplZFN0cmluZyA9IGxvY2FsaXplZFN0cmluZy5yZXBsYWNlKC9cXHsoXFxkKylcXH0vZywgZnVuY3Rpb24gKG1hdGNoLCBpbmRleCkge1xuICAgICAgICB2YXIgdmFsdWUgPSB0b2tlbnNbaW5kZXggLSAxXTtcbiAgICAgICAgdmFyIHJldCA9IHZhbHVlO1xuXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgcmV0ID0gbWF0Y2g7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGxvY2FsaXplZFN0cmluZztcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBgQ29tcG9uZW50YHMgRE9NIGVsZW1lbnQuIFRoaXMgaXMgd2hlcmUgY2hpbGRyZW4gZ2V0IGluc2VydGVkLlxuICAgKiBUaGlzIHdpbGwgdXN1YWxseSBiZSB0aGUgdGhlIHNhbWUgYXMgdGhlIGVsZW1lbnQgcmV0dXJuZWQgaW4ge0BsaW5rIENvbXBvbmVudCNlbH0uXG4gICAqXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9XG4gICAqICAgICAgICAgVGhlIGNvbnRlbnQgZWxlbWVudCBmb3IgdGhpcyBgQ29tcG9uZW50YC5cbiAgICovXG5cblxuICBDb21wb25lbnQucHJvdG90eXBlLmNvbnRlbnRFbCA9IGZ1bmN0aW9uIGNvbnRlbnRFbCgpIHtcbiAgICByZXR1cm4gdGhpcy5jb250ZW50RWxfIHx8IHRoaXMuZWxfO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhpcyBgQ29tcG9uZW50YHMgSURcbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKiAgICAgICAgIFRoZSBpZCBvZiB0aGlzIGBDb21wb25lbnRgXG4gICAqL1xuXG5cbiAgQ29tcG9uZW50LnByb3RvdHlwZS5pZCA9IGZ1bmN0aW9uIGlkKCkge1xuICAgIHJldHVybiB0aGlzLmlkXztcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSBgQ29tcG9uZW50YHMgbmFtZS4gVGhlIG5hbWUgZ2V0cyB1c2VkIHRvIHJlZmVyZW5jZSB0aGUgYENvbXBvbmVudGBcbiAgICogYW5kIGlzIHNldCBkdXJpbmcgcmVnaXN0cmF0aW9uLlxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqICAgICAgICAgVGhlIG5hbWUgb2YgdGhpcyBgQ29tcG9uZW50YC5cbiAgICovXG5cblxuICBDb21wb25lbnQucHJvdG90eXBlLm5hbWUgPSBmdW5jdGlvbiBuYW1lKCkge1xuICAgIHJldHVybiB0aGlzLm5hbWVfO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgYW4gYXJyYXkgb2YgYWxsIGNoaWxkIGNvbXBvbmVudHNcbiAgICpcbiAgICogQHJldHVybiB7QXJyYXl9XG4gICAqICAgICAgICAgVGhlIGNoaWxkcmVuXG4gICAqL1xuXG5cbiAgQ29tcG9uZW50LnByb3RvdHlwZS5jaGlsZHJlbiA9IGZ1bmN0aW9uIGNoaWxkcmVuKCkge1xuICAgIHJldHVybiB0aGlzLmNoaWxkcmVuXztcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY2hpbGQgYENvbXBvbmVudGAgd2l0aCB0aGUgZ2l2ZW4gYGlkYC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGlkXG4gICAqICAgICAgICBUaGUgaWQgb2YgdGhlIGNoaWxkIGBDb21wb25lbnRgIHRvIGdldC5cbiAgICpcbiAgICogQHJldHVybiB7Q29tcG9uZW50fHVuZGVmaW5lZH1cbiAgICogICAgICAgICBUaGUgY2hpbGQgYENvbXBvbmVudGAgd2l0aCB0aGUgZ2l2ZW4gYGlkYCBvciB1bmRlZmluZWQuXG4gICAqL1xuXG5cbiAgQ29tcG9uZW50LnByb3RvdHlwZS5nZXRDaGlsZEJ5SWQgPSBmdW5jdGlvbiBnZXRDaGlsZEJ5SWQoaWQpIHtcbiAgICByZXR1cm4gdGhpcy5jaGlsZEluZGV4X1tpZF07XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGNoaWxkIGBDb21wb25lbnRgIHdpdGggdGhlIGdpdmVuIGBuYW1lYC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICogICAgICAgIFRoZSBuYW1lIG9mIHRoZSBjaGlsZCBgQ29tcG9uZW50YCB0byBnZXQuXG4gICAqXG4gICAqIEByZXR1cm4ge0NvbXBvbmVudHx1bmRlZmluZWR9XG4gICAqICAgICAgICAgVGhlIGNoaWxkIGBDb21wb25lbnRgIHdpdGggdGhlIGdpdmVuIGBuYW1lYCBvciB1bmRlZmluZWQuXG4gICAqL1xuXG5cbiAgQ29tcG9uZW50LnByb3RvdHlwZS5nZXRDaGlsZCA9IGZ1bmN0aW9uIGdldENoaWxkKG5hbWUpIHtcbiAgICBpZiAoIW5hbWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBuYW1lID0gdG9UaXRsZUNhc2UobmFtZSk7XG5cbiAgICByZXR1cm4gdGhpcy5jaGlsZE5hbWVJbmRleF9bbmFtZV07XG4gIH07XG5cbiAgLyoqXG4gICAqIEFkZCBhIGNoaWxkIGBDb21wb25lbnRgIGluc2lkZSB0aGUgY3VycmVudCBgQ29tcG9uZW50YC5cbiAgICpcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd8Q29tcG9uZW50fSBjaGlsZFxuICAgKiAgICAgICAgVGhlIG5hbWUgb3IgaW5zdGFuY2Ugb2YgYSBjaGlsZCB0byBhZGQuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV1cbiAgICogICAgICAgIFRoZSBrZXkvdmFsdWUgc3RvcmUgb2Ygb3B0aW9ucyB0aGF0IHdpbGwgZ2V0IHBhc3NlZCB0byBjaGlsZHJlbiBvZlxuICAgKiAgICAgICAgdGhlIGNoaWxkLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gW2luZGV4PXRoaXMuY2hpbGRyZW5fLmxlbmd0aF1cbiAgICogICAgICAgIFRoZSBpbmRleCB0byBhdHRlbXB0IHRvIGFkZCBhIGNoaWxkIGludG8uXG4gICAqXG4gICAqIEByZXR1cm4ge0NvbXBvbmVudH1cbiAgICogICAgICAgICBUaGUgYENvbXBvbmVudGAgdGhhdCBnZXRzIGFkZGVkIGFzIGEgY2hpbGQuIFdoZW4gdXNpbmcgYSBzdHJpbmcgdGhlXG4gICAqICAgICAgICAgYENvbXBvbmVudGAgd2lsbCBnZXQgY3JlYXRlZCBieSB0aGlzIHByb2Nlc3MuXG4gICAqL1xuXG5cbiAgQ29tcG9uZW50LnByb3RvdHlwZS5hZGRDaGlsZCA9IGZ1bmN0aW9uIGFkZENoaWxkKGNoaWxkKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIHZhciBpbmRleCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogdGhpcy5jaGlsZHJlbl8ubGVuZ3RoO1xuXG4gICAgdmFyIGNvbXBvbmVudCA9IHZvaWQgMDtcbiAgICB2YXIgY29tcG9uZW50TmFtZSA9IHZvaWQgMDtcblxuICAgIC8vIElmIGNoaWxkIGlzIGEgc3RyaW5nLCBjcmVhdGUgY29tcG9uZW50IHdpdGggb3B0aW9uc1xuICAgIGlmICh0eXBlb2YgY2hpbGQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBjb21wb25lbnROYW1lID0gdG9UaXRsZUNhc2UoY2hpbGQpO1xuXG4gICAgICB2YXIgY29tcG9uZW50Q2xhc3NOYW1lID0gb3B0aW9ucy5jb21wb25lbnRDbGFzcyB8fCBjb21wb25lbnROYW1lO1xuXG4gICAgICAvLyBTZXQgbmFtZSB0aHJvdWdoIG9wdGlvbnNcbiAgICAgIG9wdGlvbnMubmFtZSA9IGNvbXBvbmVudE5hbWU7XG5cbiAgICAgIC8vIENyZWF0ZSBhIG5ldyBvYmplY3QgJiBlbGVtZW50IGZvciB0aGlzIGNvbnRyb2xzIHNldFxuICAgICAgLy8gSWYgdGhlcmUncyBubyAucGxheWVyXywgdGhpcyBpcyBhIHBsYXllclxuICAgICAgdmFyIENvbXBvbmVudENsYXNzID0gQ29tcG9uZW50LmdldENvbXBvbmVudChjb21wb25lbnRDbGFzc05hbWUpO1xuXG4gICAgICBpZiAoIUNvbXBvbmVudENsYXNzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ29tcG9uZW50ICcgKyBjb21wb25lbnRDbGFzc05hbWUgKyAnIGRvZXMgbm90IGV4aXN0Jyk7XG4gICAgICB9XG5cbiAgICAgIC8vIGRhdGEgc3RvcmVkIGRpcmVjdGx5IG9uIHRoZSB2aWRlb2pzIG9iamVjdCBtYXkgYmVcbiAgICAgIC8vIG1pc2lkZW50aWZpZWQgYXMgYSBjb21wb25lbnQgdG8gcmV0YWluXG4gICAgICAvLyBiYWNrd2FyZHMtY29tcGF0aWJpbGl0eSB3aXRoIDQueC4gY2hlY2sgdG8gbWFrZSBzdXJlIHRoZVxuICAgICAgLy8gY29tcG9uZW50IGNsYXNzIGNhbiBiZSBpbnN0YW50aWF0ZWQuXG4gICAgICBpZiAodHlwZW9mIENvbXBvbmVudENsYXNzICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICBjb21wb25lbnQgPSBuZXcgQ29tcG9uZW50Q2xhc3ModGhpcy5wbGF5ZXJfIHx8IHRoaXMsIG9wdGlvbnMpO1xuXG4gICAgICAvLyBjaGlsZCBpcyBhIGNvbXBvbmVudCBpbnN0YW5jZVxuICAgIH0gZWxzZSB7XG4gICAgICBjb21wb25lbnQgPSBjaGlsZDtcbiAgICB9XG5cbiAgICB0aGlzLmNoaWxkcmVuXy5zcGxpY2UoaW5kZXgsIDAsIGNvbXBvbmVudCk7XG5cbiAgICBpZiAodHlwZW9mIGNvbXBvbmVudC5pZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpcy5jaGlsZEluZGV4X1tjb21wb25lbnQuaWQoKV0gPSBjb21wb25lbnQ7XG4gICAgfVxuXG4gICAgLy8gSWYgYSBuYW1lIHdhc24ndCB1c2VkIHRvIGNyZWF0ZSB0aGUgY29tcG9uZW50LCBjaGVjayBpZiB3ZSBjYW4gdXNlIHRoZVxuICAgIC8vIG5hbWUgZnVuY3Rpb24gb2YgdGhlIGNvbXBvbmVudFxuICAgIGNvbXBvbmVudE5hbWUgPSBjb21wb25lbnROYW1lIHx8IGNvbXBvbmVudC5uYW1lICYmIHRvVGl0bGVDYXNlKGNvbXBvbmVudC5uYW1lKCkpO1xuXG4gICAgaWYgKGNvbXBvbmVudE5hbWUpIHtcbiAgICAgIHRoaXMuY2hpbGROYW1lSW5kZXhfW2NvbXBvbmVudE5hbWVdID0gY29tcG9uZW50O1xuICAgIH1cblxuICAgIC8vIEFkZCB0aGUgVUkgb2JqZWN0J3MgZWxlbWVudCB0byB0aGUgY29udGFpbmVyIGRpdiAoYm94KVxuICAgIC8vIEhhdmluZyBhbiBlbGVtZW50IGlzIG5vdCByZXF1aXJlZFxuICAgIGlmICh0eXBlb2YgY29tcG9uZW50LmVsID09PSAnZnVuY3Rpb24nICYmIGNvbXBvbmVudC5lbCgpKSB7XG4gICAgICB2YXIgY2hpbGROb2RlcyA9IHRoaXMuY29udGVudEVsKCkuY2hpbGRyZW47XG4gICAgICB2YXIgcmVmTm9kZSA9IGNoaWxkTm9kZXNbaW5kZXhdIHx8IG51bGw7XG5cbiAgICAgIHRoaXMuY29udGVudEVsKCkuaW5zZXJ0QmVmb3JlKGNvbXBvbmVudC5lbCgpLCByZWZOb2RlKTtcbiAgICB9XG5cbiAgICAvLyBSZXR1cm4gc28gaXQgY2FuIHN0b3JlZCBvbiBwYXJlbnQgb2JqZWN0IGlmIGRlc2lyZWQuXG4gICAgcmV0dXJuIGNvbXBvbmVudDtcbiAgfTtcblxuICAvKipcbiAgICogUmVtb3ZlIGEgY2hpbGQgYENvbXBvbmVudGAgZnJvbSB0aGlzIGBDb21wb25lbnRgcyBsaXN0IG9mIGNoaWxkcmVuLiBBbHNvIHJlbW92ZXNcbiAgICogdGhlIGNoaWxkIGBDb21wb25lbnRgcyBlbGVtZW50IGZyb20gdGhpcyBgQ29tcG9uZW50YHMgZWxlbWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtDb21wb25lbnR9IGNvbXBvbmVudFxuICAgKiAgICAgICAgVGhlIGNoaWxkIGBDb21wb25lbnRgIHRvIHJlbW92ZS5cbiAgICovXG5cblxuICBDb21wb25lbnQucHJvdG90eXBlLnJlbW92ZUNoaWxkID0gZnVuY3Rpb24gcmVtb3ZlQ2hpbGQoY29tcG9uZW50KSB7XG4gICAgaWYgKHR5cGVvZiBjb21wb25lbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBjb21wb25lbnQgPSB0aGlzLmdldENoaWxkKGNvbXBvbmVudCk7XG4gICAgfVxuXG4gICAgaWYgKCFjb21wb25lbnQgfHwgIXRoaXMuY2hpbGRyZW5fKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGNoaWxkRm91bmQgPSBmYWxzZTtcblxuICAgIGZvciAodmFyIGkgPSB0aGlzLmNoaWxkcmVuXy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgaWYgKHRoaXMuY2hpbGRyZW5fW2ldID09PSBjb21wb25lbnQpIHtcbiAgICAgICAgY2hpbGRGb3VuZCA9IHRydWU7XG4gICAgICAgIHRoaXMuY2hpbGRyZW5fLnNwbGljZShpLCAxKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFjaGlsZEZvdW5kKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5jaGlsZEluZGV4X1tjb21wb25lbnQuaWQoKV0gPSBudWxsO1xuICAgIHRoaXMuY2hpbGROYW1lSW5kZXhfW2NvbXBvbmVudC5uYW1lKCldID0gbnVsbDtcblxuICAgIHZhciBjb21wRWwgPSBjb21wb25lbnQuZWwoKTtcblxuICAgIGlmIChjb21wRWwgJiYgY29tcEVsLnBhcmVudE5vZGUgPT09IHRoaXMuY29udGVudEVsKCkpIHtcbiAgICAgIHRoaXMuY29udGVudEVsKCkucmVtb3ZlQ2hpbGQoY29tcG9uZW50LmVsKCkpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQWRkIGFuZCBpbml0aWFsaXplIGRlZmF1bHQgY2hpbGQgYENvbXBvbmVudGBzIGJhc2VkIHVwb24gb3B0aW9ucy5cbiAgICovXG5cblxuICBDb21wb25lbnQucHJvdG90eXBlLmluaXRDaGlsZHJlbiA9IGZ1bmN0aW9uIGluaXRDaGlsZHJlbigpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy5vcHRpb25zXy5jaGlsZHJlbjtcblxuICAgIGlmIChjaGlsZHJlbikge1xuICAgICAgLy8gYHRoaXNgIGlzIGBwYXJlbnRgXG4gICAgICB2YXIgcGFyZW50T3B0aW9ucyA9IHRoaXMub3B0aW9uc187XG5cbiAgICAgIHZhciBoYW5kbGVBZGQgPSBmdW5jdGlvbiBoYW5kbGVBZGQoY2hpbGQpIHtcbiAgICAgICAgdmFyIG5hbWUgPSBjaGlsZC5uYW1lO1xuICAgICAgICB2YXIgb3B0cyA9IGNoaWxkLm9wdHM7XG5cbiAgICAgICAgLy8gQWxsb3cgb3B0aW9ucyBmb3IgY2hpbGRyZW4gdG8gYmUgc2V0IGF0IHRoZSBwYXJlbnQgb3B0aW9uc1xuICAgICAgICAvLyBlLmcuIHZpZGVvanMoaWQsIHsgY29udHJvbEJhcjogZmFsc2UgfSk7XG4gICAgICAgIC8vIGluc3RlYWQgb2YgdmlkZW9qcyhpZCwgeyBjaGlsZHJlbjogeyBjb250cm9sQmFyOiBmYWxzZSB9KTtcbiAgICAgICAgaWYgKHBhcmVudE9wdGlvbnNbbmFtZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIG9wdHMgPSBwYXJlbnRPcHRpb25zW25hbWVdO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQWxsb3cgZm9yIGRpc2FibGluZyBkZWZhdWx0IGNvbXBvbmVudHNcbiAgICAgICAgLy8gZS5nLiBvcHRpb25zWydjaGlsZHJlbiddWydwb3N0ZXJJbWFnZSddID0gZmFsc2VcbiAgICAgICAgaWYgKG9wdHMgPT09IGZhbHNlKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQWxsb3cgb3B0aW9ucyB0byBiZSBwYXNzZWQgYXMgYSBzaW1wbGUgYm9vbGVhbiBpZiBubyBjb25maWd1cmF0aW9uXG4gICAgICAgIC8vIGlzIG5lY2Vzc2FyeS5cbiAgICAgICAgaWYgKG9wdHMgPT09IHRydWUpIHtcbiAgICAgICAgICBvcHRzID0ge307XG4gICAgICAgIH1cblxuICAgICAgICAvLyBXZSBhbHNvIHdhbnQgdG8gcGFzcyB0aGUgb3JpZ2luYWwgcGxheWVyIG9wdGlvbnNcbiAgICAgICAgLy8gdG8gZWFjaCBjb21wb25lbnQgYXMgd2VsbCBzbyB0aGV5IGRvbid0IG5lZWQgdG9cbiAgICAgICAgLy8gcmVhY2ggYmFjayBpbnRvIHRoZSBwbGF5ZXIgZm9yIG9wdGlvbnMgbGF0ZXIuXG4gICAgICAgIG9wdHMucGxheWVyT3B0aW9ucyA9IF90aGlzLm9wdGlvbnNfLnBsYXllck9wdGlvbnM7XG5cbiAgICAgICAgLy8gQ3JlYXRlIGFuZCBhZGQgdGhlIGNoaWxkIGNvbXBvbmVudC5cbiAgICAgICAgLy8gQWRkIGEgZGlyZWN0IHJlZmVyZW5jZSB0byB0aGUgY2hpbGQgYnkgbmFtZSBvbiB0aGUgcGFyZW50IGluc3RhbmNlLlxuICAgICAgICAvLyBJZiB0d28gb2YgdGhlIHNhbWUgY29tcG9uZW50IGFyZSB1c2VkLCBkaWZmZXJlbnQgbmFtZXMgc2hvdWxkIGJlIHN1cHBsaWVkXG4gICAgICAgIC8vIGZvciBlYWNoXG4gICAgICAgIHZhciBuZXdDaGlsZCA9IF90aGlzLmFkZENoaWxkKG5hbWUsIG9wdHMpO1xuXG4gICAgICAgIGlmIChuZXdDaGlsZCkge1xuICAgICAgICAgIF90aGlzW25hbWVdID0gbmV3Q2hpbGQ7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIC8vIEFsbG93IGZvciBhbiBhcnJheSBvZiBjaGlsZHJlbiBkZXRhaWxzIHRvIHBhc3NlZCBpbiB0aGUgb3B0aW9uc1xuICAgICAgdmFyIHdvcmtpbmdDaGlsZHJlbiA9IHZvaWQgMDtcbiAgICAgIHZhciBUZWNoID0gQ29tcG9uZW50LmdldENvbXBvbmVudCgnVGVjaCcpO1xuXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICAgICAgd29ya2luZ0NoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3b3JraW5nQ2hpbGRyZW4gPSBPYmplY3Qua2V5cyhjaGlsZHJlbik7XG4gICAgICB9XG5cbiAgICAgIHdvcmtpbmdDaGlsZHJlblxuICAgICAgLy8gY2hpbGRyZW4gdGhhdCBhcmUgaW4gdGhpcy5vcHRpb25zXyBidXQgYWxzbyBpbiB3b3JraW5nQ2hpbGRyZW4gIHdvdWxkXG4gICAgICAvLyBnaXZlIHVzIGV4dHJhIGNoaWxkcmVuIHdlIGRvIG5vdCB3YW50LiBTbywgd2Ugd2FudCB0byBmaWx0ZXIgdGhlbSBvdXQuXG4gICAgICAuY29uY2F0KE9iamVjdC5rZXlzKHRoaXMub3B0aW9uc18pLmZpbHRlcihmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgcmV0dXJuICF3b3JraW5nQ2hpbGRyZW4uc29tZShmdW5jdGlvbiAod2NoaWxkKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiB3Y2hpbGQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gY2hpbGQgPT09IHdjaGlsZDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGNoaWxkID09PSB3Y2hpbGQubmFtZTtcbiAgICAgICAgfSk7XG4gICAgICB9KSkubWFwKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICB2YXIgbmFtZSA9IHZvaWQgMDtcbiAgICAgICAgdmFyIG9wdHMgPSB2b2lkIDA7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBjaGlsZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBuYW1lID0gY2hpbGQ7XG4gICAgICAgICAgb3B0cyA9IGNoaWxkcmVuW25hbWVdIHx8IF90aGlzLm9wdGlvbnNfW25hbWVdIHx8IHt9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5hbWUgPSBjaGlsZC5uYW1lO1xuICAgICAgICAgIG9wdHMgPSBjaGlsZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7IG5hbWU6IG5hbWUsIG9wdHM6IG9wdHMgfTtcbiAgICAgIH0pLmZpbHRlcihmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgLy8gd2UgaGF2ZSB0byBtYWtlIHN1cmUgdGhhdCBjaGlsZC5uYW1lIGlzbid0IGluIHRoZSB0ZWNoT3JkZXIgc2luY2VcbiAgICAgICAgLy8gdGVjaHMgYXJlIHJlZ2lzdGVyZCBhcyBDb21wb25lbnRzIGJ1dCBjYW4ndCBhcmVuJ3QgY29tcGF0aWJsZVxuICAgICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3ZpZGVvanMvdmlkZW8uanMvaXNzdWVzLzI3NzJcbiAgICAgICAgdmFyIGMgPSBDb21wb25lbnQuZ2V0Q29tcG9uZW50KGNoaWxkLm9wdHMuY29tcG9uZW50Q2xhc3MgfHwgdG9UaXRsZUNhc2UoY2hpbGQubmFtZSkpO1xuXG4gICAgICAgIHJldHVybiBjICYmICFUZWNoLmlzVGVjaChjKTtcbiAgICAgIH0pLmZvckVhY2goaGFuZGxlQWRkKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEJ1aWxkcyB0aGUgZGVmYXVsdCBET00gY2xhc3MgbmFtZS4gU2hvdWxkIGJlIG92ZXJyaWRlbiBieSBzdWItY29tcG9uZW50cy5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKiAgICAgICAgIFRoZSBET00gY2xhc3MgbmFtZSBmb3IgdGhpcyBvYmplY3QuXG4gICAqXG4gICAqIEBhYnN0cmFjdFxuICAgKi9cblxuXG4gIENvbXBvbmVudC5wcm90b3R5cGUuYnVpbGRDU1NDbGFzcyA9IGZ1bmN0aW9uIGJ1aWxkQ1NTQ2xhc3MoKSB7XG4gICAgLy8gQ2hpbGQgY2xhc3NlcyBjYW4gaW5jbHVkZSBhIGZ1bmN0aW9uIHRoYXQgZG9lczpcbiAgICAvLyByZXR1cm4gJ0NMQVNTIE5BTUUnICsgdGhpcy5fc3VwZXIoKTtcbiAgICByZXR1cm4gJyc7XG4gIH07XG5cbiAgLyoqXG4gICAqIEJpbmQgYSBsaXN0ZW5lciB0byB0aGUgY29tcG9uZW50J3MgcmVhZHkgc3RhdGUuXG4gICAqIERpZmZlcmVudCBmcm9tIGV2ZW50IGxpc3RlbmVycyBpbiB0aGF0IGlmIHRoZSByZWFkeSBldmVudCBoYXMgYWxyZWFkeSBoYXBwZW5lZFxuICAgKiBpdCB3aWxsIHRyaWdnZXIgdGhlIGZ1bmN0aW9uIGltbWVkaWF0ZWx5LlxuICAgKlxuICAgKiBAcmV0dXJuIHtDb21wb25lbnR9XG4gICAqICAgICAgICAgUmV0dXJucyBpdHNlbGY7IG1ldGhvZCBjYW4gYmUgY2hhaW5lZC5cbiAgICovXG5cblxuICBDb21wb25lbnQucHJvdG90eXBlLnJlYWR5ID0gZnVuY3Rpb24gcmVhZHkoZm4pIHtcbiAgICB2YXIgc3luYyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2U7XG5cbiAgICBpZiAoIWZuKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmlzUmVhZHlfKSB7XG4gICAgICB0aGlzLnJlYWR5UXVldWVfID0gdGhpcy5yZWFkeVF1ZXVlXyB8fCBbXTtcbiAgICAgIHRoaXMucmVhZHlRdWV1ZV8ucHVzaChmbik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHN5bmMpIHtcbiAgICAgIGZuLmNhbGwodGhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIENhbGwgdGhlIGZ1bmN0aW9uIGFzeW5jaHJvbm91c2x5IGJ5IGRlZmF1bHQgZm9yIGNvbnNpc3RlbmN5XG4gICAgICB0aGlzLnNldFRpbWVvdXQoZm4sIDEpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogVHJpZ2dlciBhbGwgdGhlIHJlYWR5IGxpc3RlbmVycyBmb3IgdGhpcyBgQ29tcG9uZW50YC5cbiAgICpcbiAgICogQGZpcmVzIENvbXBvbmVudCNyZWFkeVxuICAgKi9cblxuXG4gIENvbXBvbmVudC5wcm90b3R5cGUudHJpZ2dlclJlYWR5ID0gZnVuY3Rpb24gdHJpZ2dlclJlYWR5KCkge1xuICAgIHRoaXMuaXNSZWFkeV8gPSB0cnVlO1xuXG4gICAgLy8gRW5zdXJlIHJlYWR5IGlzIHRyaWdnZXJlZCBhc3luY2hyb25vdXNseVxuICAgIHRoaXMuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgcmVhZHlRdWV1ZSA9IHRoaXMucmVhZHlRdWV1ZV87XG5cbiAgICAgIC8vIFJlc2V0IFJlYWR5IFF1ZXVlXG4gICAgICB0aGlzLnJlYWR5UXVldWVfID0gW107XG5cbiAgICAgIGlmIChyZWFkeVF1ZXVlICYmIHJlYWR5UXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgICByZWFkeVF1ZXVlLmZvckVhY2goZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgICAgZm4uY2FsbCh0aGlzKTtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgICB9XG5cbiAgICAgIC8vIEFsbG93IGZvciB1c2luZyBldmVudCBsaXN0ZW5lcnMgYWxzb1xuICAgICAgLyoqXG4gICAgICAgKiBUcmlnZ2VyZWQgd2hlbiBhIGBDb21wb25lbnRgIGlzIHJlYWR5LlxuICAgICAgICpcbiAgICAgICAqIEBldmVudCBDb21wb25lbnQjcmVhZHlcbiAgICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAgICAgICAqL1xuICAgICAgdGhpcy50cmlnZ2VyKCdyZWFkeScpO1xuICAgIH0sIDEpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBGaW5kIGEgc2luZ2xlIERPTSBlbGVtZW50IG1hdGNoaW5nIGEgYHNlbGVjdG9yYC4gVGhpcyBjYW4gYmUgd2l0aGluIHRoZSBgQ29tcG9uZW50YHNcbiAgICogYGNvbnRlbnRFbCgpYCBvciBhbm90aGVyIGN1c3RvbSBjb250ZXh0LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc2VsZWN0b3JcbiAgICogICAgICAgIEEgdmFsaWQgQ1NTIHNlbGVjdG9yLCB3aGljaCB3aWxsIGJlIHBhc3NlZCB0byBgcXVlcnlTZWxlY3RvcmAuXG4gICAqXG4gICAqIEBwYXJhbSB7RWxlbWVudHxzdHJpbmd9IFtjb250ZXh0PXRoaXMuY29udGVudEVsKCldXG4gICAqICAgICAgICBBIERPTSBlbGVtZW50IHdpdGhpbiB3aGljaCB0byBxdWVyeS4gQ2FuIGFsc28gYmUgYSBzZWxlY3RvciBzdHJpbmcgaW5cbiAgICogICAgICAgIHdoaWNoIGNhc2UgdGhlIGZpcnN0IG1hdGNoaW5nIGVsZW1lbnQgd2lsbCBnZXQgdXNlZCBhcyBjb250ZXh0LiBJZlxuICAgKiAgICAgICAgbWlzc2luZyBgdGhpcy5jb250ZW50RWwoKWAgZ2V0cyB1c2VkLiBJZiAgYHRoaXMuY29udGVudEVsKClgIHJldHVybnNcbiAgICogICAgICAgIG5vdGhpbmcgaXQgZmFsbHMgYmFjayB0byBgZG9jdW1lbnRgLlxuICAgKlxuICAgKiBAcmV0dXJuIHtFbGVtZW50fG51bGx9XG4gICAqICAgICAgICAgdGhlIGRvbSBlbGVtZW50IHRoYXQgd2FzIGZvdW5kLCBvciBudWxsXG4gICAqXG4gICAqIEBzZWUgW0luZm9ybWF0aW9uIG9uIENTUyBTZWxlY3RvcnNdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0d1aWRlL0NTUy9HZXR0aW5nX1N0YXJ0ZWQvU2VsZWN0b3JzKVxuICAgKi9cblxuXG4gIENvbXBvbmVudC5wcm90b3R5cGUuJCA9IGZ1bmN0aW9uICQkJDEoc2VsZWN0b3IsIGNvbnRleHQpIHtcbiAgICByZXR1cm4gJChzZWxlY3RvciwgY29udGV4dCB8fCB0aGlzLmNvbnRlbnRFbCgpKTtcbiAgfTtcblxuICAvKipcbiAgICogRmluZHMgYWxsIERPTSBlbGVtZW50IG1hdGNoaW5nIGEgYHNlbGVjdG9yYC4gVGhpcyBjYW4gYmUgd2l0aGluIHRoZSBgQ29tcG9uZW50YHNcbiAgICogYGNvbnRlbnRFbCgpYCBvciBhbm90aGVyIGN1c3RvbSBjb250ZXh0LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc2VsZWN0b3JcbiAgICogICAgICAgIEEgdmFsaWQgQ1NTIHNlbGVjdG9yLCB3aGljaCB3aWxsIGJlIHBhc3NlZCB0byBgcXVlcnlTZWxlY3RvckFsbGAuXG4gICAqXG4gICAqIEBwYXJhbSB7RWxlbWVudHxzdHJpbmd9IFtjb250ZXh0PXRoaXMuY29udGVudEVsKCldXG4gICAqICAgICAgICBBIERPTSBlbGVtZW50IHdpdGhpbiB3aGljaCB0byBxdWVyeS4gQ2FuIGFsc28gYmUgYSBzZWxlY3RvciBzdHJpbmcgaW5cbiAgICogICAgICAgIHdoaWNoIGNhc2UgdGhlIGZpcnN0IG1hdGNoaW5nIGVsZW1lbnQgd2lsbCBnZXQgdXNlZCBhcyBjb250ZXh0LiBJZlxuICAgKiAgICAgICAgbWlzc2luZyBgdGhpcy5jb250ZW50RWwoKWAgZ2V0cyB1c2VkLiBJZiAgYHRoaXMuY29udGVudEVsKClgIHJldHVybnNcbiAgICogICAgICAgIG5vdGhpbmcgaXQgZmFsbHMgYmFjayB0byBgZG9jdW1lbnRgLlxuICAgKlxuICAgKiBAcmV0dXJuIHtOb2RlTGlzdH1cbiAgICogICAgICAgICBhIGxpc3Qgb2YgZG9tIGVsZW1lbnRzIHRoYXQgd2VyZSBmb3VuZFxuICAgKlxuICAgKiBAc2VlIFtJbmZvcm1hdGlvbiBvbiBDU1MgU2VsZWN0b3JzXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9HdWlkZS9DU1MvR2V0dGluZ19TdGFydGVkL1NlbGVjdG9ycylcbiAgICovXG5cblxuICBDb21wb25lbnQucHJvdG90eXBlLiQkID0gZnVuY3Rpb24gJCQkJDEoc2VsZWN0b3IsIGNvbnRleHQpIHtcbiAgICByZXR1cm4gJCQoc2VsZWN0b3IsIGNvbnRleHQgfHwgdGhpcy5jb250ZW50RWwoKSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGEgY29tcG9uZW50J3MgZWxlbWVudCBoYXMgYSBDU1MgY2xhc3MgbmFtZS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzVG9DaGVja1xuICAgKiAgICAgICAgQ1NTIGNsYXNzIG5hbWUgdG8gY2hlY2suXG4gICAqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqICAgICAgICAgLSBUcnVlIGlmIHRoZSBgQ29tcG9uZW50YCBoYXMgdGhlIGNsYXNzLlxuICAgKiAgICAgICAgIC0gRmFsc2UgaWYgdGhlIGBDb21wb25lbnRgIGRvZXMgbm90IGhhdmUgdGhlIGNsYXNzYFxuICAgKi9cblxuXG4gIENvbXBvbmVudC5wcm90b3R5cGUuaGFzQ2xhc3MgPSBmdW5jdGlvbiBoYXNDbGFzcyQkMShjbGFzc1RvQ2hlY2spIHtcbiAgICByZXR1cm4gaGFzQ2xhc3ModGhpcy5lbF8sIGNsYXNzVG9DaGVjayk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEFkZCBhIENTUyBjbGFzcyBuYW1lIHRvIHRoZSBgQ29tcG9uZW50YHMgZWxlbWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzVG9BZGRcbiAgICogICAgICAgIENTUyBjbGFzcyBuYW1lIHRvIGFkZFxuICAgKi9cblxuXG4gIENvbXBvbmVudC5wcm90b3R5cGUuYWRkQ2xhc3MgPSBmdW5jdGlvbiBhZGRDbGFzcyQkMShjbGFzc1RvQWRkKSB7XG4gICAgYWRkQ2xhc3ModGhpcy5lbF8sIGNsYXNzVG9BZGQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZW1vdmUgYSBDU1MgY2xhc3MgbmFtZSBmcm9tIHRoZSBgQ29tcG9uZW50YHMgZWxlbWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzVG9SZW1vdmVcbiAgICogICAgICAgIENTUyBjbGFzcyBuYW1lIHRvIHJlbW92ZVxuICAgKi9cblxuXG4gIENvbXBvbmVudC5wcm90b3R5cGUucmVtb3ZlQ2xhc3MgPSBmdW5jdGlvbiByZW1vdmVDbGFzcyQkMShjbGFzc1RvUmVtb3ZlKSB7XG4gICAgcmVtb3ZlQ2xhc3ModGhpcy5lbF8sIGNsYXNzVG9SZW1vdmUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBZGQgb3IgcmVtb3ZlIGEgQ1NTIGNsYXNzIG5hbWUgZnJvbSB0aGUgY29tcG9uZW50J3MgZWxlbWVudC5cbiAgICogLSBgY2xhc3NUb1RvZ2dsZWAgZ2V0cyBhZGRlZCB3aGVuIHtAbGluayBDb21wb25lbnQjaGFzQ2xhc3N9IHdvdWxkIHJldHVybiBmYWxzZS5cbiAgICogLSBgY2xhc3NUb1RvZ2dsZWAgZ2V0cyByZW1vdmVkIHdoZW4ge0BsaW5rIENvbXBvbmVudCNoYXNDbGFzc30gd291bGQgcmV0dXJuIHRydWUuXG4gICAqXG4gICAqIEBwYXJhbSAge3N0cmluZ30gY2xhc3NUb1RvZ2dsZVxuICAgKiAgICAgICAgIFRoZSBjbGFzcyB0byBhZGQgb3IgcmVtb3ZlIGJhc2VkIG9uIChAbGluayBDb21wb25lbnQjaGFzQ2xhc3N9XG4gICAqXG4gICAqIEBwYXJhbSAge2Jvb2xlYW58RG9tfnByZWRpY2F0ZX0gW3ByZWRpY2F0ZV1cbiAgICogICAgICAgICBBbiB7QGxpbmsgRG9tfnByZWRpY2F0ZX0gZnVuY3Rpb24gb3IgYSBib29sZWFuXG4gICAqL1xuXG5cbiAgQ29tcG9uZW50LnByb3RvdHlwZS50b2dnbGVDbGFzcyA9IGZ1bmN0aW9uIHRvZ2dsZUNsYXNzJCQxKGNsYXNzVG9Ub2dnbGUsIHByZWRpY2F0ZSkge1xuICAgIHRvZ2dsZUNsYXNzKHRoaXMuZWxfLCBjbGFzc1RvVG9nZ2xlLCBwcmVkaWNhdGUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTaG93IHRoZSBgQ29tcG9uZW50YHMgZWxlbWVudCBpZiBpdCBpcyBoaWRkZW4gYnkgcmVtb3ZpbmcgdGhlXG4gICAqICd2anMtaGlkZGVuJyBjbGFzcyBuYW1lIGZyb20gaXQuXG4gICAqL1xuXG5cbiAgQ29tcG9uZW50LnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24gc2hvdygpIHtcbiAgICB0aGlzLnJlbW92ZUNsYXNzKCd2anMtaGlkZGVuJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEhpZGUgdGhlIGBDb21wb25lbnRgcyBlbGVtZW50IGlmIGl0IGlzIGN1cnJlbnRseSBzaG93aW5nIGJ5IGFkZGluZyB0aGVcbiAgICogJ3Zqcy1oaWRkZW5gIGNsYXNzIG5hbWUgdG8gaXQuXG4gICAqL1xuXG5cbiAgQ29tcG9uZW50LnByb3RvdHlwZS5oaWRlID0gZnVuY3Rpb24gaGlkZSgpIHtcbiAgICB0aGlzLmFkZENsYXNzKCd2anMtaGlkZGVuJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIExvY2sgYSBgQ29tcG9uZW50YHMgZWxlbWVudCBpbiBpdHMgdmlzaWJsZSBzdGF0ZSBieSBhZGRpbmcgdGhlICd2anMtbG9jay1zaG93aW5nJ1xuICAgKiBjbGFzcyBuYW1lIHRvIGl0LiBVc2VkIGR1cmluZyBmYWRlSW4vZmFkZU91dC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBDb21wb25lbnQucHJvdG90eXBlLmxvY2tTaG93aW5nID0gZnVuY3Rpb24gbG9ja1Nob3dpbmcoKSB7XG4gICAgdGhpcy5hZGRDbGFzcygndmpzLWxvY2stc2hvd2luZycpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBVbmxvY2sgYSBgQ29tcG9uZW50YHMgZWxlbWVudCBmcm9tIGl0cyB2aXNpYmxlIHN0YXRlIGJ5IHJlbW92aW5nIHRoZSAndmpzLWxvY2stc2hvd2luZydcbiAgICogY2xhc3MgbmFtZSBmcm9tIGl0LiBVc2VkIGR1cmluZyBmYWRlSW4vZmFkZU91dC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBDb21wb25lbnQucHJvdG90eXBlLnVubG9ja1Nob3dpbmcgPSBmdW5jdGlvbiB1bmxvY2tTaG93aW5nKCkge1xuICAgIHRoaXMucmVtb3ZlQ2xhc3MoJ3Zqcy1sb2NrLXNob3dpbmcnKTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSB2YWx1ZSBvZiBhbiBhdHRyaWJ1dGUgb24gdGhlIGBDb21wb25lbnRgcyBlbGVtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gYXR0cmlidXRlXG4gICAqICAgICAgICBOYW1lIG9mIHRoZSBhdHRyaWJ1dGUgdG8gZ2V0IHRoZSB2YWx1ZSBmcm9tLlxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd8bnVsbH1cbiAgICogICAgICAgICAtIFRoZSB2YWx1ZSBvZiB0aGUgYXR0cmlidXRlIHRoYXQgd2FzIGFza2VkIGZvci5cbiAgICogICAgICAgICAtIENhbiBiZSBhbiBlbXB0eSBzdHJpbmcgb24gc29tZSBicm93c2VycyBpZiB0aGUgYXR0cmlidXRlIGRvZXMgbm90IGV4aXN0XG4gICAqICAgICAgICAgICBvciBoYXMgbm8gdmFsdWVcbiAgICogICAgICAgICAtIE1vc3QgYnJvd3NlcnMgd2lsbCByZXR1cm4gbnVsbCBpZiB0aGUgYXR0aWJ1dGUgZG9lcyBub3QgZXhpc3Qgb3IgaGFzXG4gICAqICAgICAgICAgICBubyB2YWx1ZS5cbiAgICpcbiAgICogQHNlZSBbRE9NIEFQSV17QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0VsZW1lbnQvZ2V0QXR0cmlidXRlfVxuICAgKi9cblxuXG4gIENvbXBvbmVudC5wcm90b3R5cGUuZ2V0QXR0cmlidXRlID0gZnVuY3Rpb24gZ2V0QXR0cmlidXRlJCQxKGF0dHJpYnV0ZSkge1xuICAgIHJldHVybiBnZXRBdHRyaWJ1dGUodGhpcy5lbF8sIGF0dHJpYnV0ZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgdmFsdWUgb2YgYW4gYXR0cmlidXRlIG9uIHRoZSBgQ29tcG9uZW50YCdzIGVsZW1lbnRcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGF0dHJpYnV0ZVxuICAgKiAgICAgICAgTmFtZSBvZiB0aGUgYXR0cmlidXRlIHRvIHNldC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gICAqICAgICAgICBWYWx1ZSB0byBzZXQgdGhlIGF0dHJpYnV0ZSB0by5cbiAgICpcbiAgICogQHNlZSBbRE9NIEFQSV17QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0VsZW1lbnQvc2V0QXR0cmlidXRlfVxuICAgKi9cblxuXG4gIENvbXBvbmVudC5wcm90b3R5cGUuc2V0QXR0cmlidXRlID0gZnVuY3Rpb24gc2V0QXR0cmlidXRlJCQxKGF0dHJpYnV0ZSwgdmFsdWUpIHtcbiAgICBzZXRBdHRyaWJ1dGUodGhpcy5lbF8sIGF0dHJpYnV0ZSwgdmFsdWUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZW1vdmUgYW4gYXR0cmlidXRlIGZyb20gdGhlIGBDb21wb25lbnRgcyBlbGVtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gYXR0cmlidXRlXG4gICAqICAgICAgICBOYW1lIG9mIHRoZSBhdHRyaWJ1dGUgdG8gcmVtb3ZlLlxuICAgKlxuICAgKiBAc2VlIFtET00gQVBJXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRWxlbWVudC9yZW1vdmVBdHRyaWJ1dGV9XG4gICAqL1xuXG5cbiAgQ29tcG9uZW50LnByb3RvdHlwZS5yZW1vdmVBdHRyaWJ1dGUgPSBmdW5jdGlvbiByZW1vdmVBdHRyaWJ1dGUkJDEoYXR0cmlidXRlKSB7XG4gICAgcmVtb3ZlQXR0cmlidXRlKHRoaXMuZWxfLCBhdHRyaWJ1dGUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgb3Igc2V0IHRoZSB3aWR0aCBvZiB0aGUgY29tcG9uZW50IGJhc2VkIHVwb24gdGhlIENTUyBzdHlsZXMuXG4gICAqIFNlZSB7QGxpbmsgQ29tcG9uZW50I2RpbWVuc2lvbn0gZm9yIG1vcmUgZGV0YWlsZWQgaW5mb3JtYXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gW251bV1cbiAgICogICAgICAgIFRoZSB3aWR0aCB0aGF0IHlvdSB3YW50IHRvIHNldCBwb3N0Zml4ZWQgd2l0aCAnJScsICdweCcgb3Igbm90aGluZy5cbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSBbc2tpcExpc3RlbmVyc11cbiAgICogICAgICAgIFNraXAgdGhlIGNvbXBvbmVudHJlc2l6ZSBldmVudCB0cmlnZ2VyXG4gICAqXG4gICAqIEByZXR1cm4ge251bWJlcnxzdHJpbmd9XG4gICAqICAgICAgICAgVGhlIHdpZHRoIHdoZW4gZ2V0dGluZywgemVybyBpZiB0aGVyZSBpcyBubyB3aWR0aC4gQ2FuIGJlIGEgc3RyaW5nXG4gICAqICAgICAgICAgICBwb3N0cGl4ZWQgd2l0aCAnJScgb3IgJ3B4Jy5cbiAgICovXG5cblxuICBDb21wb25lbnQucHJvdG90eXBlLndpZHRoID0gZnVuY3Rpb24gd2lkdGgobnVtLCBza2lwTGlzdGVuZXJzKSB7XG4gICAgcmV0dXJuIHRoaXMuZGltZW5zaW9uKCd3aWR0aCcsIG51bSwgc2tpcExpc3RlbmVycyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBvciBzZXQgdGhlIGhlaWdodCBvZiB0aGUgY29tcG9uZW50IGJhc2VkIHVwb24gdGhlIENTUyBzdHlsZXMuXG4gICAqIFNlZSB7QGxpbmsgQ29tcG9uZW50I2RpbWVuc2lvbn0gZm9yIG1vcmUgZGV0YWlsZWQgaW5mb3JtYXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gW251bV1cbiAgICogICAgICAgIFRoZSBoZWlnaHQgdGhhdCB5b3Ugd2FudCB0byBzZXQgcG9zdGZpeGVkIHdpdGggJyUnLCAncHgnIG9yIG5vdGhpbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3NraXBMaXN0ZW5lcnNdXG4gICAqICAgICAgICBTa2lwIHRoZSBjb21wb25lbnRyZXNpemUgZXZlbnQgdHJpZ2dlclxuICAgKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ8c3RyaW5nfVxuICAgKiAgICAgICAgIFRoZSB3aWR0aCB3aGVuIGdldHRpbmcsIHplcm8gaWYgdGhlcmUgaXMgbm8gd2lkdGguIENhbiBiZSBhIHN0cmluZ1xuICAgKiAgICAgICAgIHBvc3RwaXhlZCB3aXRoICclJyBvciAncHgnLlxuICAgKi9cblxuXG4gIENvbXBvbmVudC5wcm90b3R5cGUuaGVpZ2h0ID0gZnVuY3Rpb24gaGVpZ2h0KG51bSwgc2tpcExpc3RlbmVycykge1xuICAgIHJldHVybiB0aGlzLmRpbWVuc2lvbignaGVpZ2h0JywgbnVtLCBza2lwTGlzdGVuZXJzKTtcbiAgfTtcblxuICAvKipcbiAgICogU2V0IGJvdGggdGhlIHdpZHRoIGFuZCBoZWlnaHQgb2YgdGhlIGBDb21wb25lbnRgIGVsZW1lbnQgYXQgdGhlIHNhbWUgdGltZS5cbiAgICpcbiAgICogQHBhcmFtICB7bnVtYmVyfHN0cmluZ30gd2lkdGhcbiAgICogICAgICAgICBXaWR0aCB0byBzZXQgdGhlIGBDb21wb25lbnRgcyBlbGVtZW50IHRvLlxuICAgKlxuICAgKiBAcGFyYW0gIHtudW1iZXJ8c3RyaW5nfSBoZWlnaHRcbiAgICogICAgICAgICBIZWlnaHQgdG8gc2V0IHRoZSBgQ29tcG9uZW50YHMgZWxlbWVudCB0by5cbiAgICovXG5cblxuICBDb21wb25lbnQucHJvdG90eXBlLmRpbWVuc2lvbnMgPSBmdW5jdGlvbiBkaW1lbnNpb25zKHdpZHRoLCBoZWlnaHQpIHtcbiAgICAvLyBTa2lwIGNvbXBvbmVudHJlc2l6ZSBsaXN0ZW5lcnMgb24gd2lkdGggZm9yIG9wdGltaXphdGlvblxuICAgIHRoaXMud2lkdGgod2lkdGgsIHRydWUpO1xuICAgIHRoaXMuaGVpZ2h0KGhlaWdodCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBvciBzZXQgd2lkdGggb3IgaGVpZ2h0IG9mIHRoZSBgQ29tcG9uZW50YCBlbGVtZW50LiBUaGlzIGlzIHRoZSBzaGFyZWQgY29kZVxuICAgKiBmb3IgdGhlIHtAbGluayBDb21wb25lbnQjd2lkdGh9IGFuZCB7QGxpbmsgQ29tcG9uZW50I2hlaWdodH0uXG4gICAqXG4gICAqIFRoaW5ncyB0byBrbm93OlxuICAgKiAtIElmIHRoZSB3aWR0aCBvciBoZWlnaHQgaW4gYW4gbnVtYmVyIHRoaXMgd2lsbCByZXR1cm4gdGhlIG51bWJlciBwb3N0Zml4ZWQgd2l0aCAncHgnLlxuICAgKiAtIElmIHRoZSB3aWR0aC9oZWlnaHQgaXMgYSBwZXJjZW50IHRoaXMgd2lsbCByZXR1cm4gdGhlIHBlcmNlbnQgcG9zdGZpeGVkIHdpdGggJyUnXG4gICAqIC0gSGlkZGVuIGVsZW1lbnRzIGhhdmUgYSB3aWR0aCBvZiAwIHdpdGggYHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlYC4gVGhpcyBmdW5jdGlvblxuICAgKiAgIGRlZmF1bHRzIHRvIHRoZSBgQ29tcG9uZW50YHMgYHN0eWxlLndpZHRoYCBhbmQgZmFsbHMgYmFjayB0byBgd2luZG93LmdldENvbXB1dGVkU3R5bGVgLlxuICAgKiAgIFNlZSBbdGhpc117QGxpbmsgaHR0cDovL3d3dy5mb2xpb3Rlay5jb20vZGV2YmxvZy9nZXR0aW5nLXRoZS13aWR0aC1vZi1hLWhpZGRlbi1lbGVtZW50LXdpdGgtanF1ZXJ5LXVzaW5nLXdpZHRoL31cbiAgICogICBmb3IgbW9yZSBpbmZvcm1hdGlvblxuICAgKiAtIElmIHlvdSB3YW50IHRoZSBjb21wdXRlZCBzdHlsZSBvZiB0aGUgY29tcG9uZW50LCB1c2Uge0BsaW5rIENvbXBvbmVudCNjdXJyZW50V2lkdGh9XG4gICAqICAgYW5kIHtAbGluayB7Q29tcG9uZW50I2N1cnJlbnRIZWlnaHR9XG4gICAqXG4gICAqIEBmaXJlcyBDb21wb25lbnQjY29tcG9uZW50cmVzaXplXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB3aWR0aE9ySGVpZ2h0XG4gICA4ICAgICAgICAnd2lkdGgnIG9yICdoZWlnaHQnXG4gICAqXG4gICAqIEBwYXJhbSAge251bWJlcnxzdHJpbmd9IFtudW1dXG4gICA4ICAgICAgICAgTmV3IGRpbWVuc2lvblxuICAgKlxuICAgKiBAcGFyYW0gIHtib29sZWFufSBbc2tpcExpc3RlbmVyc11cbiAgICogICAgICAgICBTa2lwIGNvbXBvbmVudHJlc2l6ZSBldmVudCB0cmlnZ2VyXG4gICAqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICogICAgICAgICBUaGUgZGltZW5zaW9uIHdoZW4gZ2V0dGluZyBvciAwIGlmIHVuc2V0XG4gICAqL1xuXG5cbiAgQ29tcG9uZW50LnByb3RvdHlwZS5kaW1lbnNpb24gPSBmdW5jdGlvbiBkaW1lbnNpb24od2lkdGhPckhlaWdodCwgbnVtLCBza2lwTGlzdGVuZXJzKSB7XG4gICAgaWYgKG51bSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBTZXQgdG8gemVybyBpZiBudWxsIG9yIGxpdGVyYWxseSBOYU4gKE5hTiAhPT0gTmFOKVxuICAgICAgaWYgKG51bSA9PT0gbnVsbCB8fCBudW0gIT09IG51bSkge1xuICAgICAgICBudW0gPSAwO1xuICAgICAgfVxuXG4gICAgICAvLyBDaGVjayBpZiB1c2luZyBjc3Mgd2lkdGgvaGVpZ2h0ICglIG9yIHB4KSBhbmQgYWRqdXN0XG4gICAgICBpZiAoKCcnICsgbnVtKS5pbmRleE9mKCclJykgIT09IC0xIHx8ICgnJyArIG51bSkuaW5kZXhPZigncHgnKSAhPT0gLTEpIHtcbiAgICAgICAgdGhpcy5lbF8uc3R5bGVbd2lkdGhPckhlaWdodF0gPSBudW07XG4gICAgICB9IGVsc2UgaWYgKG51bSA9PT0gJ2F1dG8nKSB7XG4gICAgICAgIHRoaXMuZWxfLnN0eWxlW3dpZHRoT3JIZWlnaHRdID0gJyc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmVsXy5zdHlsZVt3aWR0aE9ySGVpZ2h0XSA9IG51bSArICdweCc7XG4gICAgICB9XG5cbiAgICAgIC8vIHNraXBMaXN0ZW5lcnMgYWxsb3dzIHVzIHRvIGF2b2lkIHRyaWdnZXJpbmcgdGhlIHJlc2l6ZSBldmVudCB3aGVuIHNldHRpbmcgYm90aCB3aWR0aCBhbmQgaGVpZ2h0XG4gICAgICBpZiAoIXNraXBMaXN0ZW5lcnMpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRyaWdnZXJlZCB3aGVuIGEgY29tcG9uZW50IGlzIHJlc2l6ZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBldmVudCBDb21wb25lbnQjY29tcG9uZW50cmVzaXplXG4gICAgICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudHJpZ2dlcignY29tcG9uZW50cmVzaXplJyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBOb3Qgc2V0dGluZyBhIHZhbHVlLCBzbyBnZXR0aW5nIGl0XG4gICAgLy8gTWFrZSBzdXJlIGVsZW1lbnQgZXhpc3RzXG4gICAgaWYgKCF0aGlzLmVsXykge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgLy8gR2V0IGRpbWVuc2lvbiB2YWx1ZSBmcm9tIHN0eWxlXG4gICAgdmFyIHZhbCA9IHRoaXMuZWxfLnN0eWxlW3dpZHRoT3JIZWlnaHRdO1xuICAgIHZhciBweEluZGV4ID0gdmFsLmluZGV4T2YoJ3B4Jyk7XG5cbiAgICBpZiAocHhJbmRleCAhPT0gLTEpIHtcbiAgICAgIC8vIFJldHVybiB0aGUgcGl4ZWwgdmFsdWUgd2l0aCBubyAncHgnXG4gICAgICByZXR1cm4gcGFyc2VJbnQodmFsLnNsaWNlKDAsIHB4SW5kZXgpLCAxMCk7XG4gICAgfVxuXG4gICAgLy8gTm8gcHggc28gdXNpbmcgJSBvciBubyBzdHlsZSB3YXMgc2V0LCBzbyBmYWxsaW5nIGJhY2sgdG8gb2Zmc2V0V2lkdGgvaGVpZ2h0XG4gICAgLy8gSWYgY29tcG9uZW50IGhhcyBkaXNwbGF5Om5vbmUsIG9mZnNldCB3aWxsIHJldHVybiAwXG4gICAgLy8gVE9ETzogaGFuZGxlIGRpc3BsYXk6bm9uZSBhbmQgbm8gZGltZW5zaW9uIHN0eWxlIHVzaW5nIHB4XG4gICAgcmV0dXJuIHBhcnNlSW50KHRoaXMuZWxfWydvZmZzZXQnICsgdG9UaXRsZUNhc2Uod2lkdGhPckhlaWdodCldLCAxMCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgY29tcHV0ZWQgd2lkdGggb3IgdGhlIGhlaWdodCBvZiB0aGUgY29tcG9uZW50J3MgZWxlbWVudC5cbiAgICpcbiAgICogVXNlcyBgd2luZG93LmdldENvbXB1dGVkU3R5bGVgLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gd2lkdGhPckhlaWdodFxuICAgKiAgICAgICAgQSBzdHJpbmcgY29udGFpbmluZyAnd2lkdGgnIG9yICdoZWlnaHQnLiBXaGljaGV2ZXIgb25lIHlvdSB3YW50IHRvIGdldC5cbiAgICpcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKiAgICAgICAgIFRoZSBkaW1lbnNpb24gdGhhdCBnZXRzIGFza2VkIGZvciBvciAwIGlmIG5vdGhpbmcgd2FzIHNldFxuICAgKiAgICAgICAgIGZvciB0aGF0IGRpbWVuc2lvbi5cbiAgICovXG5cblxuICBDb21wb25lbnQucHJvdG90eXBlLmN1cnJlbnREaW1lbnNpb24gPSBmdW5jdGlvbiBjdXJyZW50RGltZW5zaW9uKHdpZHRoT3JIZWlnaHQpIHtcbiAgICB2YXIgY29tcHV0ZWRXaWR0aE9ySGVpZ2h0ID0gMDtcblxuICAgIGlmICh3aWR0aE9ySGVpZ2h0ICE9PSAnd2lkdGgnICYmIHdpZHRoT3JIZWlnaHQgIT09ICdoZWlnaHQnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2N1cnJlbnREaW1lbnNpb24gb25seSBhY2NlcHRzIHdpZHRoIG9yIGhlaWdodCB2YWx1ZScpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygd2luZG93LmdldENvbXB1dGVkU3R5bGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHZhciBjb21wdXRlZFN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUodGhpcy5lbF8pO1xuXG4gICAgICBjb21wdXRlZFdpZHRoT3JIZWlnaHQgPSBjb21wdXRlZFN0eWxlLmdldFByb3BlcnR5VmFsdWUod2lkdGhPckhlaWdodCkgfHwgY29tcHV0ZWRTdHlsZVt3aWR0aE9ySGVpZ2h0XTtcbiAgICB9XG5cbiAgICAvLyByZW1vdmUgJ3B4JyBmcm9tIHZhcmlhYmxlIGFuZCBwYXJzZSBhcyBpbnRlZ2VyXG4gICAgY29tcHV0ZWRXaWR0aE9ySGVpZ2h0ID0gcGFyc2VGbG9hdChjb21wdXRlZFdpZHRoT3JIZWlnaHQpO1xuXG4gICAgLy8gaWYgdGhlIGNvbXB1dGVkIHZhbHVlIGlzIHN0aWxsIDAsIGl0J3MgcG9zc2libGUgdGhhdCB0aGUgYnJvd3NlciBpcyBseWluZ1xuICAgIC8vIGFuZCB3ZSB3YW50IHRvIGNoZWNrIHRoZSBvZmZzZXQgdmFsdWVzLlxuICAgIC8vIFRoaXMgY29kZSBhbHNvIHJ1bnMgb24gSUU4IGFuZCB3aGVyZXZlciBnZXRDb21wdXRlZFN0eWxlIGRvZXNuJ3QgZXhpc3QuXG4gICAgaWYgKGNvbXB1dGVkV2lkdGhPckhlaWdodCA9PT0gMCkge1xuICAgICAgdmFyIHJ1bGUgPSAnb2Zmc2V0JyArIHRvVGl0bGVDYXNlKHdpZHRoT3JIZWlnaHQpO1xuXG4gICAgICBjb21wdXRlZFdpZHRoT3JIZWlnaHQgPSB0aGlzLmVsX1tydWxlXTtcbiAgICB9XG5cbiAgICByZXR1cm4gY29tcHV0ZWRXaWR0aE9ySGVpZ2h0O1xuICB9O1xuXG4gIC8qKlxuICAgKiBBbiBvYmplY3QgdGhhdCBjb250YWlucyB3aWR0aCBhbmQgaGVpZ2h0IHZhbHVlcyBvZiB0aGUgYENvbXBvbmVudGBzXG4gICAqIGNvbXB1dGVkIHN0eWxlLiBVc2VzIGB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZWAuXG4gICAqXG4gICAqIEB0eXBlZGVmIHtPYmplY3R9IENvbXBvbmVudH5EaW1lbnNpb25PYmplY3RcbiAgICpcbiAgICogQHByb3BlcnR5IHtudW1iZXJ9IHdpZHRoXG4gICAqICAgICAgICAgICBUaGUgd2lkdGggb2YgdGhlIGBDb21wb25lbnRgcyBjb21wdXRlZCBzdHlsZS5cbiAgICpcbiAgICogQHByb3BlcnR5IHtudW1iZXJ9IGhlaWdodFxuICAgKiAgICAgICAgICAgVGhlIGhlaWdodCBvZiB0aGUgYENvbXBvbmVudGBzIGNvbXB1dGVkIHN0eWxlLlxuICAgKi9cblxuICAvKipcbiAgICogR2V0IGFuIG9iamVjdCB0aGF0IGNvbnRhaW5zIGNvbXB1dGVkIHdpZHRoIGFuZCBoZWlnaHQgdmFsdWVzIG9mIHRoZVxuICAgKiBjb21wb25lbnQncyBlbGVtZW50LlxuICAgKlxuICAgKiBVc2VzIGB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZWAuXG4gICAqXG4gICAqIEByZXR1cm4ge0NvbXBvbmVudH5EaW1lbnNpb25PYmplY3R9XG4gICAqICAgICAgICAgVGhlIGNvbXB1dGVkIGRpbWVuc2lvbnMgb2YgdGhlIGNvbXBvbmVudCdzIGVsZW1lbnQuXG4gICAqL1xuXG5cbiAgQ29tcG9uZW50LnByb3RvdHlwZS5jdXJyZW50RGltZW5zaW9ucyA9IGZ1bmN0aW9uIGN1cnJlbnREaW1lbnNpb25zKCkge1xuICAgIHJldHVybiB7XG4gICAgICB3aWR0aDogdGhpcy5jdXJyZW50RGltZW5zaW9uKCd3aWR0aCcpLFxuICAgICAgaGVpZ2h0OiB0aGlzLmN1cnJlbnREaW1lbnNpb24oJ2hlaWdodCcpXG4gICAgfTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSBjb21wdXRlZCB3aWR0aCBvZiB0aGUgY29tcG9uZW50J3MgZWxlbWVudC5cbiAgICpcbiAgICogVXNlcyBgd2luZG93LmdldENvbXB1dGVkU3R5bGVgLlxuICAgKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqICAgICAgICAgVGhlIGNvbXB1dGVkIHdpZHRoIG9mIHRoZSBjb21wb25lbnQncyBlbGVtZW50LlxuICAgKi9cblxuXG4gIENvbXBvbmVudC5wcm90b3R5cGUuY3VycmVudFdpZHRoID0gZnVuY3Rpb24gY3VycmVudFdpZHRoKCkge1xuICAgIHJldHVybiB0aGlzLmN1cnJlbnREaW1lbnNpb24oJ3dpZHRoJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgY29tcHV0ZWQgaGVpZ2h0IG9mIHRoZSBjb21wb25lbnQncyBlbGVtZW50LlxuICAgKlxuICAgKiBVc2VzIGB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZWAuXG4gICAqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICogICAgICAgICBUaGUgY29tcHV0ZWQgaGVpZ2h0IG9mIHRoZSBjb21wb25lbnQncyBlbGVtZW50LlxuICAgKi9cblxuXG4gIENvbXBvbmVudC5wcm90b3R5cGUuY3VycmVudEhlaWdodCA9IGZ1bmN0aW9uIGN1cnJlbnRIZWlnaHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuY3VycmVudERpbWVuc2lvbignaGVpZ2h0Jyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgZm9jdXMgdG8gdGhpcyBjb21wb25lbnRcbiAgICovXG5cblxuICBDb21wb25lbnQucHJvdG90eXBlLmZvY3VzID0gZnVuY3Rpb24gZm9jdXMoKSB7XG4gICAgdGhpcy5lbF8uZm9jdXMoKTtcbiAgfTtcblxuICAvKipcbiAgICogUmVtb3ZlIHRoZSBmb2N1cyBmcm9tIHRoaXMgY29tcG9uZW50XG4gICAqL1xuXG5cbiAgQ29tcG9uZW50LnByb3RvdHlwZS5ibHVyID0gZnVuY3Rpb24gYmx1cigpIHtcbiAgICB0aGlzLmVsXy5ibHVyKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEVtaXQgYSAndGFwJyBldmVudHMgd2hlbiB0b3VjaCBldmVudCBzdXBwb3J0IGdldHMgZGV0ZWN0ZWQuIFRoaXMgZ2V0cyB1c2VkIHRvXG4gICAqIHN1cHBvcnQgdG9nZ2xpbmcgdGhlIGNvbnRyb2xzIHRocm91Z2ggYSB0YXAgb24gdGhlIHZpZGVvLiBUaGV5IGdldCBlbmFibGVkXG4gICAqIGJlY2F1c2UgZXZlcnkgc3ViLWNvbXBvbmVudCB3b3VsZCBoYXZlIGV4dHJhIG92ZXJoZWFkIG90aGVyd2lzZS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQGZpcmVzIENvbXBvbmVudCN0YXBcbiAgICogQGxpc3RlbnMgQ29tcG9uZW50I3RvdWNoc3RhcnRcbiAgICogQGxpc3RlbnMgQ29tcG9uZW50I3RvdWNobW92ZVxuICAgKiBAbGlzdGVucyBDb21wb25lbnQjdG91Y2hsZWF2ZVxuICAgKiBAbGlzdGVucyBDb21wb25lbnQjdG91Y2hjYW5jZWxcbiAgICogQGxpc3RlbnMgQ29tcG9uZW50I3RvdWNoZW5kXG4gICAgKi9cblxuXG4gIENvbXBvbmVudC5wcm90b3R5cGUuZW1pdFRhcEV2ZW50cyA9IGZ1bmN0aW9uIGVtaXRUYXBFdmVudHMoKSB7XG4gICAgLy8gVHJhY2sgdGhlIHN0YXJ0IHRpbWUgc28gd2UgY2FuIGRldGVybWluZSBob3cgbG9uZyB0aGUgdG91Y2ggbGFzdGVkXG4gICAgdmFyIHRvdWNoU3RhcnQgPSAwO1xuICAgIHZhciBmaXJzdFRvdWNoID0gbnVsbDtcblxuICAgIC8vIE1heGltdW0gbW92ZW1lbnQgYWxsb3dlZCBkdXJpbmcgYSB0b3VjaCBldmVudCB0byBzdGlsbCBiZSBjb25zaWRlcmVkIGEgdGFwXG4gICAgLy8gT3RoZXIgcG9wdWxhciBsaWJzIHVzZSBhbnl3aGVyZSBmcm9tIDIgKGhhbW1lci5qcykgdG8gMTUsXG4gICAgLy8gc28gMTAgc2VlbXMgbGlrZSBhIG5pY2UsIHJvdW5kIG51bWJlci5cbiAgICB2YXIgdGFwTW92ZW1lbnRUaHJlc2hvbGQgPSAxMDtcblxuICAgIC8vIFRoZSBtYXhpbXVtIGxlbmd0aCBhIHRvdWNoIGNhbiBiZSB3aGlsZSBzdGlsbCBiZWluZyBjb25zaWRlcmVkIGEgdGFwXG4gICAgdmFyIHRvdWNoVGltZVRocmVzaG9sZCA9IDIwMDtcblxuICAgIHZhciBjb3VsZEJlVGFwID0gdm9pZCAwO1xuXG4gICAgdGhpcy5vbigndG91Y2hzdGFydCcsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgLy8gSWYgbW9yZSB0aGFuIG9uZSBmaW5nZXIsIGRvbid0IGNvbnNpZGVyIHRyZWF0aW5nIHRoaXMgYXMgYSBjbGlja1xuICAgICAgaWYgKGV2ZW50LnRvdWNoZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIC8vIENvcHkgcGFnZVgvcGFnZVkgZnJvbSB0aGUgb2JqZWN0XG4gICAgICAgIGZpcnN0VG91Y2ggPSB7XG4gICAgICAgICAgcGFnZVg6IGV2ZW50LnRvdWNoZXNbMF0ucGFnZVgsXG4gICAgICAgICAgcGFnZVk6IGV2ZW50LnRvdWNoZXNbMF0ucGFnZVlcbiAgICAgICAgfTtcbiAgICAgICAgLy8gUmVjb3JkIHN0YXJ0IHRpbWUgc28gd2UgY2FuIGRldGVjdCBhIHRhcCB2cy4gXCJ0b3VjaCBhbmQgaG9sZFwiXG4gICAgICAgIHRvdWNoU3RhcnQgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgLy8gUmVzZXQgY291bGRCZVRhcCB0cmFja2luZ1xuICAgICAgICBjb3VsZEJlVGFwID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHRoaXMub24oJ3RvdWNobW92ZScsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgLy8gSWYgbW9yZSB0aGFuIG9uZSBmaW5nZXIsIGRvbid0IGNvbnNpZGVyIHRyZWF0aW5nIHRoaXMgYXMgYSBjbGlja1xuICAgICAgaWYgKGV2ZW50LnRvdWNoZXMubGVuZ3RoID4gMSkge1xuICAgICAgICBjb3VsZEJlVGFwID0gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKGZpcnN0VG91Y2gpIHtcbiAgICAgICAgLy8gU29tZSBkZXZpY2VzIHdpbGwgdGhyb3cgdG91Y2htb3ZlcyBmb3IgYWxsIGJ1dCB0aGUgc2xpZ2h0ZXN0IG9mIHRhcHMuXG4gICAgICAgIC8vIFNvLCBpZiB3ZSBtb3ZlZCBvbmx5IGEgc21hbGwgZGlzdGFuY2UsIHRoaXMgY291bGQgc3RpbGwgYmUgYSB0YXBcbiAgICAgICAgdmFyIHhkaWZmID0gZXZlbnQudG91Y2hlc1swXS5wYWdlWCAtIGZpcnN0VG91Y2gucGFnZVg7XG4gICAgICAgIHZhciB5ZGlmZiA9IGV2ZW50LnRvdWNoZXNbMF0ucGFnZVkgLSBmaXJzdFRvdWNoLnBhZ2VZO1xuICAgICAgICB2YXIgdG91Y2hEaXN0YW5jZSA9IE1hdGguc3FydCh4ZGlmZiAqIHhkaWZmICsgeWRpZmYgKiB5ZGlmZik7XG5cbiAgICAgICAgaWYgKHRvdWNoRGlzdGFuY2UgPiB0YXBNb3ZlbWVudFRocmVzaG9sZCkge1xuICAgICAgICAgIGNvdWxkQmVUYXAgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdmFyIG5vVGFwID0gZnVuY3Rpb24gbm9UYXAoKSB7XG4gICAgICBjb3VsZEJlVGFwID0gZmFsc2U7XG4gICAgfTtcblxuICAgIC8vIFRPRE86IExpc3RlbiB0byB0aGUgb3JpZ2luYWwgdGFyZ2V0LiBodHRwOi8veW91dHUuYmUvRHVqZnBYT0tVcDg/dD0xM204c1xuICAgIHRoaXMub24oJ3RvdWNobGVhdmUnLCBub1RhcCk7XG4gICAgdGhpcy5vbigndG91Y2hjYW5jZWwnLCBub1RhcCk7XG5cbiAgICAvLyBXaGVuIHRoZSB0b3VjaCBlbmRzLCBtZWFzdXJlIGhvdyBsb25nIGl0IHRvb2sgYW5kIHRyaWdnZXIgdGhlIGFwcHJvcHJpYXRlXG4gICAgLy8gZXZlbnRcbiAgICB0aGlzLm9uKCd0b3VjaGVuZCcsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgZmlyc3RUb3VjaCA9IG51bGw7XG4gICAgICAvLyBQcm9jZWVkIG9ubHkgaWYgdGhlIHRvdWNobW92ZS9sZWF2ZS9jYW5jZWwgZXZlbnQgZGlkbid0IGhhcHBlblxuICAgICAgaWYgKGNvdWxkQmVUYXAgPT09IHRydWUpIHtcbiAgICAgICAgLy8gTWVhc3VyZSBob3cgbG9uZyB0aGUgdG91Y2ggbGFzdGVkXG4gICAgICAgIHZhciB0b3VjaFRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKSAtIHRvdWNoU3RhcnQ7XG5cbiAgICAgICAgLy8gTWFrZSBzdXJlIHRoZSB0b3VjaCB3YXMgbGVzcyB0aGFuIHRoZSB0aHJlc2hvbGQgdG8gYmUgY29uc2lkZXJlZCBhIHRhcFxuICAgICAgICBpZiAodG91Y2hUaW1lIDwgdG91Y2hUaW1lVGhyZXNob2xkKSB7XG4gICAgICAgICAgLy8gRG9uJ3QgbGV0IGJyb3dzZXIgdHVybiB0aGlzIGludG8gYSBjbGlja1xuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogVHJpZ2dlcmVkIHdoZW4gYSBgQ29tcG9uZW50YCBpcyB0YXBwZWQuXG4gICAgICAgICAgICpcbiAgICAgICAgICAgKiBAZXZlbnQgQ29tcG9uZW50I3RhcFxuICAgICAgICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAgICAgICAgICAgKi9cbiAgICAgICAgICB0aGlzLnRyaWdnZXIoJ3RhcCcpO1xuICAgICAgICAgIC8vIEl0IG1heSBiZSBnb29kIHRvIGNvcHkgdGhlIHRvdWNoZW5kIGV2ZW50IG9iamVjdCBhbmQgY2hhbmdlIHRoZVxuICAgICAgICAgIC8vIHR5cGUgdG8gdGFwLCBpZiB0aGUgb3RoZXIgZXZlbnQgcHJvcGVydGllcyBhcmVuJ3QgZXhhY3QgYWZ0ZXJcbiAgICAgICAgICAvLyBFdmVudHMuZml4RXZlbnQgcnVucyAoZS5nLiBldmVudC50YXJnZXQpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICAvKipcbiAgICogVGhpcyBmdW5jdGlvbiByZXBvcnRzIHVzZXIgYWN0aXZpdHkgd2hlbmV2ZXIgdG91Y2ggZXZlbnRzIGhhcHBlbi4gVGhpcyBjYW4gZ2V0XG4gICAqIHR1cm5lZCBvZmYgYnkgYW55IHN1Yi1jb21wb25lbnRzIHRoYXQgd2FudHMgdG91Y2ggZXZlbnRzIHRvIGFjdCBhbm90aGVyIHdheS5cbiAgICpcbiAgICogUmVwb3J0IHVzZXIgdG91Y2ggYWN0aXZpdHkgd2hlbiB0b3VjaCBldmVudHMgb2NjdXIuIFVzZXIgYWN0aXZpdHkgZ2V0cyB1c2VkIHRvXG4gICAqIGRldGVybWluZSB3aGVuIGNvbnRyb2xzIHNob3VsZCBzaG93L2hpZGUuIEl0IGlzIHNpbXBsZSB3aGVuIGl0IGNvbWVzIHRvIG1vdXNlXG4gICAqIGV2ZW50cywgYmVjYXVzZSBhbnkgbW91c2UgZXZlbnQgc2hvdWxkIHNob3cgdGhlIGNvbnRyb2xzLiBTbyB3ZSBjYXB0dXJlIG1vdXNlXG4gICAqIGV2ZW50cyB0aGF0IGJ1YmJsZSB1cCB0byB0aGUgcGxheWVyIGFuZCByZXBvcnQgYWN0aXZpdHkgd2hlbiB0aGF0IGhhcHBlbnMuXG4gICAqIFdpdGggdG91Y2ggZXZlbnRzIGl0IGlzbid0IGFzIGVhc3kgYXMgYHRvdWNoc3RhcnRgIGFuZCBgdG91Y2hlbmRgIHRvZ2dsZSBwbGF5ZXJcbiAgICogY29udHJvbHMuIFNvIHRvdWNoIGV2ZW50cyBjYW4ndCBoZWxwIHVzIGF0IHRoZSBwbGF5ZXIgbGV2ZWwgZWl0aGVyLlxuICAgKlxuICAgKiBVc2VyIGFjdGl2aXR5IGdldHMgY2hlY2tlZCBhc3luY2hyb25vdXNseS4gU28gd2hhdCBjb3VsZCBoYXBwZW4gaXMgYSB0YXAgZXZlbnRcbiAgICogb24gdGhlIHZpZGVvIHR1cm5zIHRoZSBjb250cm9scyBvZmYuIFRoZW4gdGhlIGB0b3VjaGVuZGAgZXZlbnQgYnViYmxlcyB1cCB0b1xuICAgKiB0aGUgcGxheWVyLiBXaGljaCwgaWYgaXQgcmVwb3J0ZWQgdXNlciBhY3Rpdml0eSwgd291bGQgdHVybiB0aGUgY29udHJvbHMgcmlnaHRcbiAgICogYmFjayBvbi4gV2UgYWxzbyBkb24ndCB3YW50IHRvIGNvbXBsZXRlbHkgYmxvY2sgdG91Y2ggZXZlbnRzIGZyb20gYnViYmxpbmcgdXAuXG4gICAqIEZ1cnRoZXJtb3JlIGEgYHRvdWNobW92ZWAgZXZlbnQgYW5kIGFueXRoaW5nIG90aGVyIHRoYW4gYSB0YXAsIHNob3VsZCBub3QgdHVyblxuICAgKiBjb250cm9scyBiYWNrIG9uLlxuICAgKlxuICAgKiBAbGlzdGVucyBDb21wb25lbnQjdG91Y2hzdGFydFxuICAgKiBAbGlzdGVucyBDb21wb25lbnQjdG91Y2htb3ZlXG4gICAqIEBsaXN0ZW5zIENvbXBvbmVudCN0b3VjaGVuZFxuICAgKiBAbGlzdGVucyBDb21wb25lbnQjdG91Y2hjYW5jZWxcbiAgICovXG5cblxuICBDb21wb25lbnQucHJvdG90eXBlLmVuYWJsZVRvdWNoQWN0aXZpdHkgPSBmdW5jdGlvbiBlbmFibGVUb3VjaEFjdGl2aXR5KCkge1xuICAgIC8vIERvbid0IGNvbnRpbnVlIGlmIHRoZSByb290IHBsYXllciBkb2Vzbid0IHN1cHBvcnQgcmVwb3J0aW5nIHVzZXIgYWN0aXZpdHlcbiAgICBpZiAoIXRoaXMucGxheWVyKCkgfHwgIXRoaXMucGxheWVyKCkucmVwb3J0VXNlckFjdGl2aXR5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gbGlzdGVuZXIgZm9yIHJlcG9ydGluZyB0aGF0IHRoZSB1c2VyIGlzIGFjdGl2ZVxuICAgIHZhciByZXBvcnQgPSBiaW5kKHRoaXMucGxheWVyKCksIHRoaXMucGxheWVyKCkucmVwb3J0VXNlckFjdGl2aXR5KTtcblxuICAgIHZhciB0b3VjaEhvbGRpbmcgPSB2b2lkIDA7XG5cbiAgICB0aGlzLm9uKCd0b3VjaHN0YXJ0JywgZnVuY3Rpb24gKCkge1xuICAgICAgcmVwb3J0KCk7XG4gICAgICAvLyBGb3IgYXMgbG9uZyBhcyB0aGUgdGhleSBhcmUgdG91Y2hpbmcgdGhlIGRldmljZSBvciBoYXZlIHRoZWlyIG1vdXNlIGRvd24sXG4gICAgICAvLyB3ZSBjb25zaWRlciB0aGVtIGFjdGl2ZSBldmVuIGlmIHRoZXkncmUgbm90IG1vdmluZyB0aGVpciBmaW5nZXIgb3IgbW91c2UuXG4gICAgICAvLyBTbyB3ZSB3YW50IHRvIGNvbnRpbnVlIHRvIHVwZGF0ZSB0aGF0IHRoZXkgYXJlIGFjdGl2ZVxuICAgICAgdGhpcy5jbGVhckludGVydmFsKHRvdWNoSG9sZGluZyk7XG4gICAgICAvLyByZXBvcnQgYXQgdGhlIHNhbWUgaW50ZXJ2YWwgYXMgYWN0aXZpdHlDaGVja1xuICAgICAgdG91Y2hIb2xkaW5nID0gdGhpcy5zZXRJbnRlcnZhbChyZXBvcnQsIDI1MCk7XG4gICAgfSk7XG5cbiAgICB2YXIgdG91Y2hFbmQgPSBmdW5jdGlvbiB0b3VjaEVuZChldmVudCkge1xuICAgICAgcmVwb3J0KCk7XG4gICAgICAvLyBzdG9wIHRoZSBpbnRlcnZhbCB0aGF0IG1haW50YWlucyBhY3Rpdml0eSBpZiB0aGUgdG91Y2ggaXMgaG9sZGluZ1xuICAgICAgdGhpcy5jbGVhckludGVydmFsKHRvdWNoSG9sZGluZyk7XG4gICAgfTtcblxuICAgIHRoaXMub24oJ3RvdWNobW92ZScsIHJlcG9ydCk7XG4gICAgdGhpcy5vbigndG91Y2hlbmQnLCB0b3VjaEVuZCk7XG4gICAgdGhpcy5vbigndG91Y2hjYW5jZWwnLCB0b3VjaEVuZCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEEgY2FsbGJhY2sgdGhhdCBoYXMgbm8gcGFyYW1ldGVycyBhbmQgaXMgYm91bmQgaW50byBgQ29tcG9uZW50YHMgY29udGV4dC5cbiAgICpcbiAgICogQGNhbGxiYWNrIENvbXBvbmVudH5HZW5lcmljQ2FsbGJhY2tcbiAgICogQHRoaXMgQ29tcG9uZW50XG4gICAqL1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBydW5zIGFmdGVyIGFuIGB4YCBtaWxsaXNlY29uZCB0aW1lb3V0LiBUaGlzIGZ1bmN0aW9uIGlzIGFcbiAgICogd3JhcHBlciBhcm91bmQgYHdpbmRvdy5zZXRUaW1lb3V0YC4gVGhlcmUgYXJlIGEgZmV3IHJlYXNvbnMgdG8gdXNlIHRoaXMgb25lXG4gICAqIGluc3RlYWQgdGhvdWdoOlxuICAgKiAxLiBJdCBnZXRzIGNsZWFyZWQgdmlhICB7QGxpbmsgQ29tcG9uZW50I2NsZWFyVGltZW91dH0gd2hlblxuICAgKiAgICB7QGxpbmsgQ29tcG9uZW50I2Rpc3Bvc2V9IGdldHMgY2FsbGVkLlxuICAgKiAyLiBUaGUgZnVuY3Rpb24gY2FsbGJhY2sgd2lsbCBnZXRzIHR1cm5lZCBpbnRvIGEge0BsaW5rIENvbXBvbmVudH5HZW5lcmljQ2FsbGJhY2t9XG4gICAqXG4gICAqID4gTm90ZTogWW91IGNhbid0IHVzZSBgd2luZG93LmNsZWFyVGltZW91dGAgb24gdGhlIGlkIHJldHVybmVkIGJ5IHRoaXMgZnVuY3Rpb24uIFRoaXNcbiAgICogICAgICAgICB3aWxsIGNhdXNlIGl0cyBkaXNwb3NlIGxpc3RlbmVyIG5vdCB0byBnZXQgY2xlYW5lZCB1cCEgUGxlYXNlIHVzZVxuICAgKiAgICAgICAgIHtAbGluayBDb21wb25lbnQjY2xlYXJUaW1lb3V0fSBvciB7QGxpbmsgQ29tcG9uZW50I2Rpc3Bvc2V9IGluc3RlYWQuXG4gICAqXG4gICAqIEBwYXJhbSB7Q29tcG9uZW50fkdlbmVyaWNDYWxsYmFja30gZm5cbiAgICogICAgICAgIFRoZSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgcnVuIGFmdGVyIGB0aW1lb3V0YC5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IHRpbWVvdXRcbiAgICogICAgICAgIFRpbWVvdXQgaW4gbWlsbGlzZWNvbmRzIHRvIGRlbGF5IGJlZm9yZSBleGVjdXRpbmcgdGhlIHNwZWNpZmllZCBmdW5jdGlvbi5cbiAgICpcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKiAgICAgICAgIFJldHVybnMgYSB0aW1lb3V0IElEIHRoYXQgZ2V0cyB1c2VkIHRvIGlkZW50aWZ5IHRoZSB0aW1lb3V0LiBJdCBjYW4gYWxzb1xuICAgKiAgICAgICAgIGdldCB1c2VkIGluIHtAbGluayBDb21wb25lbnQjY2xlYXJUaW1lb3V0fSB0byBjbGVhciB0aGUgdGltZW91dCB0aGF0XG4gICAqICAgICAgICAgd2FzIHNldC5cbiAgICpcbiAgICogQGxpc3RlbnMgQ29tcG9uZW50I2Rpc3Bvc2VcbiAgICogQHNlZSBbU2ltaWxhciB0b117QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1dpbmRvd1RpbWVycy9zZXRUaW1lb3V0fVxuICAgKi9cblxuXG4gIENvbXBvbmVudC5wcm90b3R5cGUuc2V0VGltZW91dCA9IGZ1bmN0aW9uIHNldFRpbWVvdXQoZm4sIHRpbWVvdXQpIHtcbiAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgIC8vIGRlY2xhcmUgYXMgdmFyaWFibGVzIHNvIHRoZXkgYXJlIHByb3Blcmx5IGF2YWlsYWJsZSBpbiB0aW1lb3V0IGZ1bmN0aW9uXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgdmFyIHRpbWVvdXRJZCwgZGlzcG9zZUZuO1xuXG4gICAgZm4gPSBiaW5kKHRoaXMsIGZuKTtcblxuICAgIHRpbWVvdXRJZCA9IHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzMi5vZmYoJ2Rpc3Bvc2UnLCBkaXNwb3NlRm4pO1xuICAgICAgZm4oKTtcbiAgICB9LCB0aW1lb3V0KTtcblxuICAgIGRpc3Bvc2VGbiA9IGZ1bmN0aW9uIGRpc3Bvc2VGbigpIHtcbiAgICAgIHJldHVybiBfdGhpczIuY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgfTtcblxuICAgIGRpc3Bvc2VGbi5ndWlkID0gJ3Zqcy10aW1lb3V0LScgKyB0aW1lb3V0SWQ7XG5cbiAgICB0aGlzLm9uKCdkaXNwb3NlJywgZGlzcG9zZUZuKTtcblxuICAgIHJldHVybiB0aW1lb3V0SWQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIENsZWFycyBhIHRpbWVvdXQgdGhhdCBnZXRzIGNyZWF0ZWQgdmlhIGB3aW5kb3cuc2V0VGltZW91dGAgb3JcbiAgICoge0BsaW5rIENvbXBvbmVudCNzZXRUaW1lb3V0fS4gSWYgeW91IHNldCBhIHRpbWVvdXQgdmlhIHtAbGluayBDb21wb25lbnQjc2V0VGltZW91dH1cbiAgICogdXNlIHRoaXMgZnVuY3Rpb24gaW5zdGVhZCBvZiBgd2luZG93LmNsZWFyVGltb3V0YC4gSWYgeW91IGRvbid0IHlvdXIgZGlzcG9zZVxuICAgKiBsaXN0ZW5lciB3aWxsIG5vdCBnZXQgY2xlYW5lZCB1cCB1bnRpbCB7QGxpbmsgQ29tcG9uZW50I2Rpc3Bvc2V9IVxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gdGltZW91dElkXG4gICAqICAgICAgICBUaGUgaWQgb2YgdGhlIHRpbWVvdXQgdG8gY2xlYXIuIFRoZSByZXR1cm4gdmFsdWUgb2ZcbiAgICogICAgICAgIHtAbGluayBDb21wb25lbnQjc2V0VGltZW91dH0gb3IgYHdpbmRvdy5zZXRUaW1lb3V0YC5cbiAgICpcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKiAgICAgICAgIFJldHVybnMgdGhlIHRpbWVvdXQgaWQgdGhhdCB3YXMgY2xlYXJlZC5cbiAgICpcbiAgICogQHNlZSBbU2ltaWxhciB0b117QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1dpbmRvd1RpbWVycy9jbGVhclRpbWVvdXR9XG4gICAqL1xuXG5cbiAgQ29tcG9uZW50LnByb3RvdHlwZS5jbGVhclRpbWVvdXQgPSBmdW5jdGlvbiBjbGVhclRpbWVvdXQodGltZW91dElkKSB7XG4gICAgd2luZG93LmNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuXG4gICAgdmFyIGRpc3Bvc2VGbiA9IGZ1bmN0aW9uIGRpc3Bvc2VGbigpIHt9O1xuXG4gICAgZGlzcG9zZUZuLmd1aWQgPSAndmpzLXRpbWVvdXQtJyArIHRpbWVvdXRJZDtcblxuICAgIHRoaXMub2ZmKCdkaXNwb3NlJywgZGlzcG9zZUZuKTtcblxuICAgIHJldHVybiB0aW1lb3V0SWQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGdldHMgcnVuIGV2ZXJ5IGB4YCBtaWxsaXNlY29uZHMuIFRoaXMgZnVuY3Rpb24gaXMgYSB3cmFwcGVyXG4gICAqIGFyb3VuZCBgd2luZG93LnNldEludGVydmFsYC4gVGhlcmUgYXJlIGEgZmV3IHJlYXNvbnMgdG8gdXNlIHRoaXMgb25lIGluc3RlYWQgdGhvdWdoLlxuICAgKiAxLiBJdCBnZXRzIGNsZWFyZWQgdmlhICB7QGxpbmsgQ29tcG9uZW50I2NsZWFySW50ZXJ2YWx9IHdoZW5cbiAgICogICAge0BsaW5rIENvbXBvbmVudCNkaXNwb3NlfSBnZXRzIGNhbGxlZC5cbiAgICogMi4gVGhlIGZ1bmN0aW9uIGNhbGxiYWNrIHdpbGwgYmUgYSB7QGxpbmsgQ29tcG9uZW50fkdlbmVyaWNDYWxsYmFja31cbiAgICpcbiAgICogQHBhcmFtIHtDb21wb25lbnR+R2VuZXJpY0NhbGxiYWNrfSBmblxuICAgKiAgICAgICAgVGhlIGZ1bmN0aW9uIHRvIHJ1biBldmVyeSBgeGAgc2Vjb25kcy5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IGludGVydmFsXG4gICAqICAgICAgICBFeGVjdXRlIHRoZSBzcGVjaWZpZWQgZnVuY3Rpb24gZXZlcnkgYHhgIG1pbGxpc2Vjb25kcy5cbiAgICpcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKiAgICAgICAgIFJldHVybnMgYW4gaWQgdGhhdCBjYW4gYmUgdXNlZCB0byBpZGVudGlmeSB0aGUgaW50ZXJ2YWwuIEl0IGNhbiBhbHNvIGJlIGJlIHVzZWQgaW5cbiAgICogICAgICAgICB7QGxpbmsgQ29tcG9uZW50I2NsZWFySW50ZXJ2YWx9IHRvIGNsZWFyIHRoZSBpbnRlcnZhbC5cbiAgICpcbiAgICogQGxpc3RlbnMgQ29tcG9uZW50I2Rpc3Bvc2VcbiAgICogQHNlZSBbU2ltaWxhciB0b117QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1dpbmRvd1RpbWVycy9zZXRJbnRlcnZhbH1cbiAgICovXG5cblxuICBDb21wb25lbnQucHJvdG90eXBlLnNldEludGVydmFsID0gZnVuY3Rpb24gc2V0SW50ZXJ2YWwoZm4sIGludGVydmFsKSB7XG4gICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICBmbiA9IGJpbmQodGhpcywgZm4pO1xuXG4gICAgdmFyIGludGVydmFsSWQgPSB3aW5kb3cuc2V0SW50ZXJ2YWwoZm4sIGludGVydmFsKTtcblxuICAgIHZhciBkaXNwb3NlRm4gPSBmdW5jdGlvbiBkaXNwb3NlRm4oKSB7XG4gICAgICByZXR1cm4gX3RoaXMzLmNsZWFySW50ZXJ2YWwoaW50ZXJ2YWxJZCk7XG4gICAgfTtcblxuICAgIGRpc3Bvc2VGbi5ndWlkID0gJ3Zqcy1pbnRlcnZhbC0nICsgaW50ZXJ2YWxJZDtcblxuICAgIHRoaXMub24oJ2Rpc3Bvc2UnLCBkaXNwb3NlRm4pO1xuXG4gICAgcmV0dXJuIGludGVydmFsSWQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIENsZWFycyBhbiBpbnRlcnZhbCB0aGF0IGdldHMgY3JlYXRlZCB2aWEgYHdpbmRvdy5zZXRJbnRlcnZhbGAgb3JcbiAgICoge0BsaW5rIENvbXBvbmVudCNzZXRJbnRlcnZhbH0uIElmIHlvdSBzZXQgYW4gaW50ZXZhbCB2aWEge0BsaW5rIENvbXBvbmVudCNzZXRJbnRlcnZhbH1cbiAgICogdXNlIHRoaXMgZnVuY3Rpb24gaW5zdGVhZCBvZiBgd2luZG93LmNsZWFySW50ZXJ2YWxgLiBJZiB5b3UgZG9uJ3QgeW91ciBkaXNwb3NlXG4gICAqIGxpc3RlbmVyIHdpbGwgbm90IGdldCBjbGVhbmVkIHVwIHVudGlsIHtAbGluayBDb21wb25lbnQjZGlzcG9zZX0hXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbnRlcnZhbElkXG4gICAqICAgICAgICBUaGUgaWQgb2YgdGhlIGludGVydmFsIHRvIGNsZWFyLiBUaGUgcmV0dXJuIHZhbHVlIG9mXG4gICAqICAgICAgICB7QGxpbmsgQ29tcG9uZW50I3NldEludGVydmFsfSBvciBgd2luZG93LnNldEludGVydmFsYC5cbiAgICpcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKiAgICAgICAgIFJldHVybnMgdGhlIGludGVydmFsIGlkIHRoYXQgd2FzIGNsZWFyZWQuXG4gICAqXG4gICAqIEBzZWUgW1NpbWlsYXIgdG9de0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9XaW5kb3dUaW1lcnMvY2xlYXJJbnRlcnZhbH1cbiAgICovXG5cblxuICBDb21wb25lbnQucHJvdG90eXBlLmNsZWFySW50ZXJ2YWwgPSBmdW5jdGlvbiBjbGVhckludGVydmFsKGludGVydmFsSWQpIHtcbiAgICB3aW5kb3cuY2xlYXJJbnRlcnZhbChpbnRlcnZhbElkKTtcblxuICAgIHZhciBkaXNwb3NlRm4gPSBmdW5jdGlvbiBkaXNwb3NlRm4oKSB7fTtcblxuICAgIGRpc3Bvc2VGbi5ndWlkID0gJ3Zqcy1pbnRlcnZhbC0nICsgaW50ZXJ2YWxJZDtcblxuICAgIHRoaXMub2ZmKCdkaXNwb3NlJywgZGlzcG9zZUZuKTtcblxuICAgIHJldHVybiBpbnRlcnZhbElkO1xuICB9O1xuXG4gIC8qKlxuICAgKiBRdWV1ZXMgdXAgYSBjYWxsYmFjayB0byBiZSBwYXNzZWQgdG8gcmVxdWVzdEFuaW1hdGlvbkZyYW1lIChyQUYpLCBidXRcbiAgICogd2l0aCBhIGZldyBleHRyYSBib251c2VzOlxuICAgKlxuICAgKiAtIFN1cHBvcnRzIGJyb3dzZXJzIHRoYXQgZG8gbm90IHN1cHBvcnQgckFGIGJ5IGZhbGxpbmcgYmFjayB0b1xuICAgKiAgIHtAbGluayBDb21wb25lbnQjc2V0VGltZW91dH0uXG4gICAqXG4gICAqIC0gVGhlIGNhbGxiYWNrIGlzIHR1cm5lZCBpbnRvIGEge0BsaW5rIENvbXBvbmVudH5HZW5lcmljQ2FsbGJhY2t9IChpLmUuXG4gICAqICAgYm91bmQgdG8gdGhlIGNvbXBvbmVudCkuXG4gICAqXG4gICAqIC0gQXV0b21hdGljIGNhbmNlbGxhdGlvbiBvZiB0aGUgckFGIGNhbGxiYWNrIGlzIGhhbmRsZWQgaWYgdGhlIGNvbXBvbmVudFxuICAgKiAgIGlzIGRpc3Bvc2VkIGJlZm9yZSBpdCBpcyBjYWxsZWQuXG4gICAqXG4gICAqIEBwYXJhbSAge0NvbXBvbmVudH5HZW5lcmljQ2FsbGJhY2t9IGZuXG4gICAqICAgICAgICAgQSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgYm91bmQgdG8gdGhpcyBjb21wb25lbnQgYW5kIGV4ZWN1dGVkIGp1c3RcbiAgICogICAgICAgICBiZWZvcmUgdGhlIGJyb3dzZXIncyBuZXh0IHJlcGFpbnQuXG4gICAqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICogICAgICAgICBSZXR1cm5zIGFuIHJBRiBJRCB0aGF0IGdldHMgdXNlZCB0byBpZGVudGlmeSB0aGUgdGltZW91dC4gSXQgY2FuXG4gICAqICAgICAgICAgYWxzbyBiZSB1c2VkIGluIHtAbGluayBDb21wb25lbnQjY2FuY2VsQW5pbWF0aW9uRnJhbWV9IHRvIGNhbmNlbFxuICAgKiAgICAgICAgIHRoZSBhbmltYXRpb24gZnJhbWUgY2FsbGJhY2suXG4gICAqXG4gICAqIEBsaXN0ZW5zIENvbXBvbmVudCNkaXNwb3NlXG4gICAqIEBzZWUgW1NpbWlsYXIgdG9de0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS93aW5kb3cvcmVxdWVzdEFuaW1hdGlvbkZyYW1lfVxuICAgKi9cblxuXG4gIENvbXBvbmVudC5wcm90b3R5cGUucmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gZnVuY3Rpb24gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZuKSB7XG4gICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICAvLyBkZWNsYXJlIGFzIHZhcmlhYmxlcyBzbyB0aGV5IGFyZSBwcm9wZXJseSBhdmFpbGFibGUgaW4gckFGIGZ1bmN0aW9uXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgdmFyIGlkLCBkaXNwb3NlRm47XG5cbiAgICBpZiAodGhpcy5zdXBwb3J0c1JhZl8pIHtcbiAgICAgIGZuID0gYmluZCh0aGlzLCBmbik7XG5cbiAgICAgIGlkID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzNC5vZmYoJ2Rpc3Bvc2UnLCBkaXNwb3NlRm4pO1xuICAgICAgICBmbigpO1xuICAgICAgfSk7XG5cbiAgICAgIGRpc3Bvc2VGbiA9IGZ1bmN0aW9uIGRpc3Bvc2VGbigpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzNC5jYW5jZWxBbmltYXRpb25GcmFtZShpZCk7XG4gICAgICB9O1xuXG4gICAgICBkaXNwb3NlRm4uZ3VpZCA9ICd2anMtcmFmLScgKyBpZDtcbiAgICAgIHRoaXMub24oJ2Rpc3Bvc2UnLCBkaXNwb3NlRm4pO1xuXG4gICAgICByZXR1cm4gaWQ7XG4gICAgfVxuXG4gICAgLy8gRmFsbCBiYWNrIHRvIHVzaW5nIGEgdGltZXIuXG4gICAgcmV0dXJuIHRoaXMuc2V0VGltZW91dChmbiwgMTAwMCAvIDYwKTtcbiAgfTtcblxuICAvKipcbiAgICogQ2FuY2VscyBhIHF1ZXVlZCBjYWxsYmFjayBwYXNzZWQgdG8ge0BsaW5rIENvbXBvbmVudCNyZXF1ZXN0QW5pbWF0aW9uRnJhbWV9XG4gICAqIChyQUYpLlxuICAgKlxuICAgKiBJZiB5b3UgcXVldWUgYW4gckFGIGNhbGxiYWNrIHZpYSB7QGxpbmsgQ29tcG9uZW50I3JlcXVlc3RBbmltYXRpb25GcmFtZX0sXG4gICAqIHVzZSB0aGlzIGZ1bmN0aW9uIGluc3RlYWQgb2YgYHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZWAuIElmIHlvdSBkb24ndCxcbiAgICogeW91ciBkaXNwb3NlIGxpc3RlbmVyIHdpbGwgbm90IGdldCBjbGVhbmVkIHVwIHVudGlsIHtAbGluayBDb21wb25lbnQjZGlzcG9zZX0hXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpZFxuICAgKiAgICAgICAgVGhlIHJBRiBJRCB0byBjbGVhci4gVGhlIHJldHVybiB2YWx1ZSBvZiB7QGxpbmsgQ29tcG9uZW50I3JlcXVlc3RBbmltYXRpb25GcmFtZX0uXG4gICAqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICogICAgICAgICBSZXR1cm5zIHRoZSByQUYgSUQgdGhhdCB3YXMgY2xlYXJlZC5cbiAgICpcbiAgICogQHNlZSBbU2ltaWxhciB0b117QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL3dpbmRvdy9jYW5jZWxBbmltYXRpb25GcmFtZX1cbiAgICovXG5cblxuICBDb21wb25lbnQucHJvdG90eXBlLmNhbmNlbEFuaW1hdGlvbkZyYW1lID0gZnVuY3Rpb24gY2FuY2VsQW5pbWF0aW9uRnJhbWUoaWQpIHtcbiAgICBpZiAodGhpcy5zdXBwb3J0c1JhZl8pIHtcbiAgICAgIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZShpZCk7XG5cbiAgICAgIHZhciBkaXNwb3NlRm4gPSBmdW5jdGlvbiBkaXNwb3NlRm4oKSB7fTtcblxuICAgICAgZGlzcG9zZUZuLmd1aWQgPSAndmpzLXJhZi0nICsgaWQ7XG5cbiAgICAgIHRoaXMub2ZmKCdkaXNwb3NlJywgZGlzcG9zZUZuKTtcblxuICAgICAgcmV0dXJuIGlkO1xuICAgIH1cblxuICAgIC8vIEZhbGwgYmFjayB0byB1c2luZyBhIHRpbWVyLlxuICAgIHJldHVybiB0aGlzLmNsZWFyVGltZW91dChpZCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIGEgYENvbXBvbmVudGAgd2l0aCBgdmlkZW9qc2AgZ2l2ZW4gdGhlIG5hbWUgYW5kIHRoZSBjb21wb25lbnQuXG4gICAqXG4gICAqID4gTk9URToge0BsaW5rIFRlY2h9cyBzaG91bGQgbm90IGJlIHJlZ2lzdGVyZWQgYXMgYSBgQ29tcG9uZW50YC4ge0BsaW5rIFRlY2h9c1xuICAgKiAgICAgICAgIHNob3VsZCBiZSByZWdpc3RlcmVkIHVzaW5nIHtAbGluayBUZWNoLnJlZ2lzdGVyVGVjaH0gb3JcbiAgICogICAgICAgICB7QGxpbmsgdmlkZW9qczp2aWRlb2pzLnJlZ2lzdGVyVGVjaH0uXG4gICAqXG4gICAqID4gTk9URTogVGhpcyBmdW5jdGlvbiBjYW4gYWxzbyBiZSBzZWVuIG9uIHZpZGVvanMgYXNcbiAgICogICAgICAgICB7QGxpbmsgdmlkZW9qczp2aWRlb2pzLnJlZ2lzdGVyQ29tcG9uZW50fS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICogICAgICAgIFRoZSBuYW1lIG9mIHRoZSBgQ29tcG9uZW50YCB0byByZWdpc3Rlci5cbiAgICpcbiAgICogQHBhcmFtIHtDb21wb25lbnR9IENvbXBvbmVudFRvUmVnaXN0ZXJcbiAgICogICAgICAgIFRoZSBgQ29tcG9uZW50YCBjbGFzcyB0byByZWdpc3Rlci5cbiAgICpcbiAgICogQHJldHVybiB7Q29tcG9uZW50fVxuICAgKiAgICAgICAgIFRoZSBgQ29tcG9uZW50YCB0aGF0IHdhcyByZWdpc3RlcmVkLlxuICAgKi9cblxuXG4gIENvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCA9IGZ1bmN0aW9uIHJlZ2lzdGVyQ29tcG9uZW50KG5hbWUsIENvbXBvbmVudFRvUmVnaXN0ZXIpIHtcbiAgICBpZiAodHlwZW9mIG5hbWUgIT09ICdzdHJpbmcnIHx8ICFuYW1lKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lsbGVnYWwgY29tcG9uZW50IG5hbWUsIFwiJyArIG5hbWUgKyAnXCI7IG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nLicpO1xuICAgIH1cblxuICAgIHZhciBUZWNoID0gQ29tcG9uZW50LmdldENvbXBvbmVudCgnVGVjaCcpO1xuXG4gICAgLy8gV2UgbmVlZCB0byBtYWtlIHN1cmUgdGhpcyBjaGVjayBpcyBvbmx5IGRvbmUgaWYgVGVjaCBoYXMgYmVlbiByZWdpc3RlcmVkLlxuICAgIHZhciBpc1RlY2ggPSBUZWNoICYmIFRlY2guaXNUZWNoKENvbXBvbmVudFRvUmVnaXN0ZXIpO1xuICAgIHZhciBpc0NvbXAgPSBDb21wb25lbnQgPT09IENvbXBvbmVudFRvUmVnaXN0ZXIgfHwgQ29tcG9uZW50LnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKENvbXBvbmVudFRvUmVnaXN0ZXIucHJvdG90eXBlKTtcblxuICAgIGlmIChpc1RlY2ggfHwgIWlzQ29tcCkge1xuICAgICAgdmFyIHJlYXNvbiA9IHZvaWQgMDtcblxuICAgICAgaWYgKGlzVGVjaCkge1xuICAgICAgICByZWFzb24gPSAndGVjaHMgbXVzdCBiZSByZWdpc3RlcmVkIHVzaW5nIFRlY2gucmVnaXN0ZXJUZWNoKCknO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVhc29uID0gJ211c3QgYmUgYSBDb21wb25lbnQgc3ViY2xhc3MnO1xuICAgICAgfVxuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lsbGVnYWwgY29tcG9uZW50LCBcIicgKyBuYW1lICsgJ1wiOyAnICsgcmVhc29uICsgJy4nKTtcbiAgICB9XG5cbiAgICBuYW1lID0gdG9UaXRsZUNhc2UobmFtZSk7XG5cbiAgICBpZiAoIUNvbXBvbmVudC5jb21wb25lbnRzXykge1xuICAgICAgQ29tcG9uZW50LmNvbXBvbmVudHNfID0ge307XG4gICAgfVxuXG4gICAgdmFyIFBsYXllciA9IENvbXBvbmVudC5nZXRDb21wb25lbnQoJ1BsYXllcicpO1xuXG4gICAgaWYgKG5hbWUgPT09ICdQbGF5ZXInICYmIFBsYXllciAmJiBQbGF5ZXIucGxheWVycykge1xuICAgICAgdmFyIHBsYXllcnMgPSBQbGF5ZXIucGxheWVycztcbiAgICAgIHZhciBwbGF5ZXJOYW1lcyA9IE9iamVjdC5rZXlzKHBsYXllcnMpO1xuXG4gICAgICAvLyBJZiB3ZSBoYXZlIHBsYXllcnMgdGhhdCB3ZXJlIGRpc3Bvc2VkLCB0aGVuIHRoZWlyIG5hbWUgd2lsbCBzdGlsbCBiZVxuICAgICAgLy8gaW4gUGxheWVycy5wbGF5ZXJzLiBTbywgd2UgbXVzdCBsb29wIHRocm91Z2ggYW5kIHZlcmlmeSB0aGF0IHRoZSB2YWx1ZVxuICAgICAgLy8gZm9yIGVhY2ggaXRlbSBpcyBub3QgbnVsbC4gVGhpcyBhbGxvd3MgcmVnaXN0cmF0aW9uIG9mIHRoZSBQbGF5ZXIgY29tcG9uZW50XG4gICAgICAvLyBhZnRlciBhbGwgcGxheWVycyBoYXZlIGJlZW4gZGlzcG9zZWQgb3IgYmVmb3JlIGFueSB3ZXJlIGNyZWF0ZWQuXG4gICAgICBpZiAocGxheWVycyAmJiBwbGF5ZXJOYW1lcy5sZW5ndGggPiAwICYmIHBsYXllck5hbWVzLm1hcChmdW5jdGlvbiAocG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHBsYXllcnNbcG5hbWVdO1xuICAgICAgfSkuZXZlcnkoQm9vbGVhbikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW4gbm90IHJlZ2lzdGVyIFBsYXllciBjb21wb25lbnQgYWZ0ZXIgcGxheWVyIGhhcyBiZWVuIGNyZWF0ZWQuJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgQ29tcG9uZW50LmNvbXBvbmVudHNfW25hbWVdID0gQ29tcG9uZW50VG9SZWdpc3RlcjtcblxuICAgIHJldHVybiBDb21wb25lbnRUb1JlZ2lzdGVyO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgYSBgQ29tcG9uZW50YCBiYXNlZCBvbiB0aGUgbmFtZSBpdCB3YXMgcmVnaXN0ZXJlZCB3aXRoLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgKiAgICAgICAgVGhlIE5hbWUgb2YgdGhlIGNvbXBvbmVudCB0byBnZXQuXG4gICAqXG4gICAqIEByZXR1cm4ge0NvbXBvbmVudH1cbiAgICogICAgICAgICBUaGUgYENvbXBvbmVudGAgdGhhdCBnb3QgcmVnaXN0ZXJlZCB1bmRlciB0aGUgZ2l2ZW4gbmFtZS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgSW4gYHZpZGVvanNgIDYgdGhpcyB3aWxsIG5vdCByZXR1cm4gYENvbXBvbmVudGBzIHRoYXQgd2VyZSBub3RcbiAgICogICAgICAgICAgICAgcmVnaXN0ZXJlZCB1c2luZyB7QGxpbmsgQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50fS4gQ3VycmVudGx5IHdlXG4gICAqICAgICAgICAgICAgIGNoZWNrIHRoZSBnbG9iYWwgYHZpZGVvanNgIG9iamVjdCBmb3IgYSBgQ29tcG9uZW50YCBuYW1lIGFuZFxuICAgKiAgICAgICAgICAgICByZXR1cm4gdGhhdCBpZiBpdCBleGlzdHMuXG4gICAqL1xuXG5cbiAgQ29tcG9uZW50LmdldENvbXBvbmVudCA9IGZ1bmN0aW9uIGdldENvbXBvbmVudChuYW1lKSB7XG4gICAgaWYgKCFuYW1lKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbmFtZSA9IHRvVGl0bGVDYXNlKG5hbWUpO1xuXG4gICAgaWYgKENvbXBvbmVudC5jb21wb25lbnRzXyAmJiBDb21wb25lbnQuY29tcG9uZW50c19bbmFtZV0pIHtcbiAgICAgIHJldHVybiBDb21wb25lbnQuY29tcG9uZW50c19bbmFtZV07XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBDb21wb25lbnQ7XG59KCk7XG5cbi8qKlxuICogV2hldGhlciBvciBub3QgdGhpcyBjb21wb25lbnQgc3VwcG9ydHMgYHJlcXVlc3RBbmltYXRpb25GcmFtZWAuXG4gKlxuICogVGhpcyBpcyBleHBvc2VkIHByaW1hcmlseSBmb3IgdGVzdGluZyBwdXJwb3Nlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHR5cGUge0Jvb2xlYW59XG4gKi9cblxuXG5Db21wb25lbnQucHJvdG90eXBlLnN1cHBvcnRzUmFmXyA9IHR5cGVvZiB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUgPT09ICdmdW5jdGlvbic7XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnQ29tcG9uZW50JywgQ29tcG9uZW50KTtcblxuLyoqXG4gKiBAZmlsZSB0aW1lLXJhbmdlcy5qc1xuICogQG1vZHVsZSB0aW1lLXJhbmdlc1xuICovXG5cbi8qKlxuICogUmV0dXJucyB0aGUgdGltZSBmb3IgdGhlIHNwZWNpZmllZCBpbmRleCBhdCB0aGUgc3RhcnQgb3IgZW5kXG4gKiBvZiBhIFRpbWVSYW5nZSBvYmplY3QuXG4gKlxuICogQGZ1bmN0aW9uIHRpbWUtcmFuZ2VzOmluZGV4RnVuY3Rpb25cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gW2luZGV4PTBdXG4gKiAgICAgICAgVGhlIHJhbmdlIG51bWJlciB0byByZXR1cm4gdGhlIHRpbWUgZm9yLlxuICpcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqICAgICAgICAgVGhlIHRpbWUgdGhhdCBvZmZzZXQgYXQgdGhlIHNwZWNpZmllZCBpbmRleC5cbiAqXG4gKiBAZGVwcmljYXRlZCBpbmRleCBtdXN0IGJlIHNldCB0byBhIHZhbHVlLCBpbiB0aGUgZnV0dXJlIHRoaXMgd2lsbCB0aHJvdyBhbiBlcnJvci5cbiAqL1xuXG4vKipcbiAqIEFuIG9iamVjdCB0aGF0IGNvbnRhaW5zIHJhbmdlcyBvZiB0aW1lIGZvciB2YXJpb3VzIHJlYXNvbnMuXG4gKlxuICogQHR5cGVkZWYge09iamVjdH0gVGltZVJhbmdlXG4gKlxuICogQHByb3BlcnR5IHtudW1iZXJ9IGxlbmd0aFxuICogICAgICAgICAgIFRoZSBudW1iZXIgb2YgdGltZSByYW5nZXMgcmVwcmVzZW50ZWQgYnkgdGhpcyBPYmplY3RcbiAqXG4gKiBAcHJvcGVydHkge3RpbWUtcmFuZ2VzOmluZGV4RnVuY3Rpb259IHN0YXJ0XG4gKiAgICAgICAgICAgUmV0dXJucyB0aGUgdGltZSBvZmZzZXQgYXQgd2hpY2ggYSBzcGVjaWZpZWQgdGltZSByYW5nZSBiZWdpbnMuXG4gKlxuICogQHByb3BlcnR5IHt0aW1lLXJhbmdlczppbmRleEZ1bmN0aW9ufSBlbmRcbiAqICAgICAgICAgICBSZXR1cm5zIHRoZSB0aW1lIG9mZnNldCBhdCB3aGljaCBhIHNwZWNpZmllZCB0aW1lIHJhbmdlIGVuZHMuXG4gKlxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvVGltZVJhbmdlc1xuICovXG5cbi8qKlxuICogQ2hlY2sgaWYgYW55IG9mIHRoZSB0aW1lIHJhbmdlcyBhcmUgb3ZlciB0aGUgbWF4aW11bSBpbmRleC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZm5OYW1lXG4gKiAgICAgICAgVGhlIGZ1bmN0aW9uIG5hbWUgdG8gdXNlIGZvciBsb2dnaW5nXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gKiAgICAgICAgVGhlIGluZGV4IHRvIGNoZWNrXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IG1heEluZGV4XG4gKiAgICAgICAgVGhlIG1heGltdW0gcG9zc2libGUgaW5kZXhcbiAqXG4gKiBAdGhyb3dzIHtFcnJvcn0gaWYgdGhlIHRpbWVSYW5nZXMgcHJvdmlkZWQgYXJlIG92ZXIgdGhlIG1heEluZGV4XG4gKi9cbmZ1bmN0aW9uIHJhbmdlQ2hlY2soZm5OYW1lLCBpbmRleCwgbWF4SW5kZXgpIHtcbiAgaWYgKHR5cGVvZiBpbmRleCAhPT0gJ251bWJlcicgfHwgaW5kZXggPCAwIHx8IGluZGV4ID4gbWF4SW5kZXgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBleGVjdXRlIFxcJycgKyBmbk5hbWUgKyAnXFwnIG9uIFxcJ1RpbWVSYW5nZXNcXCc6IFRoZSBpbmRleCBwcm92aWRlZCAoJyArIGluZGV4ICsgJykgaXMgbm9uLW51bWVyaWMgb3Igb3V0IG9mIGJvdW5kcyAoMC0nICsgbWF4SW5kZXggKyAnKS4nKTtcbiAgfVxufVxuXG4vKipcbiAqIEdldCB0aGUgdGltZSBmb3IgdGhlIHNwZWNpZmllZCBpbmRleCBhdCB0aGUgc3RhcnQgb3IgZW5kXG4gKiBvZiBhIFRpbWVSYW5nZSBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGZuTmFtZVxuICogICAgICAgIFRoZSBmdW5jdGlvbiBuYW1lIHRvIHVzZSBmb3IgbG9nZ2luZ1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZUluZGV4XG4gKiAgICAgICAgVGhlIHByb3ByZXR5IHRoYXQgc2hvdWxkIGJlIHVzZWQgdG8gZ2V0IHRoZSB0aW1lLiBzaG91bGQgYmUgJ3N0YXJ0JyBvciAnZW5kJ1xuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHJhbmdlc1xuICogICAgICAgIEFuIGFycmF5IG9mIHRpbWUgcmFuZ2VzXG4gKlxuICogQHBhcmFtIHtBcnJheX0gW3JhbmdlSW5kZXg9MF1cbiAqICAgICAgICBUaGUgaW5kZXggdG8gc3RhcnQgdGhlIHNlYXJjaCBhdFxuICpcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqICAgICAgICAgVGhlIHRpbWUgdGhhdCBvZmZzZXQgYXQgdGhlIHNwZWNpZmllZCBpbmRleC5cbiAqXG4gKlxuICogQGRlcHJpY2F0ZWQgcmFuZ2VJbmRleCBtdXN0IGJlIHNldCB0byBhIHZhbHVlLCBpbiB0aGUgZnV0dXJlIHRoaXMgd2lsbCB0aHJvdyBhbiBlcnJvci5cbiAqIEB0aHJvd3Mge0Vycm9yfSBpZiByYW5nZUluZGV4IGlzIG1vcmUgdGhhbiB0aGUgbGVuZ3RoIG9mIHJhbmdlc1xuICovXG5mdW5jdGlvbiBnZXRSYW5nZShmbk5hbWUsIHZhbHVlSW5kZXgsIHJhbmdlcywgcmFuZ2VJbmRleCkge1xuICByYW5nZUNoZWNrKGZuTmFtZSwgcmFuZ2VJbmRleCwgcmFuZ2VzLmxlbmd0aCAtIDEpO1xuICByZXR1cm4gcmFuZ2VzW3JhbmdlSW5kZXhdW3ZhbHVlSW5kZXhdO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIHRpbWUgcmFuZ2Ugb2JqZWN0IGdpdmVuIHJhbmdlcyBvZiB0aW1lLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IFtyYW5nZXNdXG4gKiAgICAgICAgQW4gYXJyYXkgb2YgdGltZSByYW5nZXMuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVRpbWVSYW5nZXNPYmoocmFuZ2VzKSB7XG4gIGlmIChyYW5nZXMgPT09IHVuZGVmaW5lZCB8fCByYW5nZXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxlbmd0aDogMCxcbiAgICAgIHN0YXJ0OiBmdW5jdGlvbiBzdGFydCgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIFRpbWVSYW5nZXMgb2JqZWN0IGlzIGVtcHR5Jyk7XG4gICAgICB9LFxuICAgICAgZW5kOiBmdW5jdGlvbiBlbmQoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBUaW1lUmFuZ2VzIG9iamVjdCBpcyBlbXB0eScpO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBsZW5ndGg6IHJhbmdlcy5sZW5ndGgsXG4gICAgc3RhcnQ6IGdldFJhbmdlLmJpbmQobnVsbCwgJ3N0YXJ0JywgMCwgcmFuZ2VzKSxcbiAgICBlbmQ6IGdldFJhbmdlLmJpbmQobnVsbCwgJ2VuZCcsIDEsIHJhbmdlcylcbiAgfTtcbn1cblxuLyoqXG4gKiBTaG91bGQgY3JlYXRlIGEgZmFrZSBgVGltZVJhbmdlYCBvYmplY3Qgd2hpY2ggbWltaWNzIGFuIEhUTUw1IHRpbWUgcmFuZ2UgaW5zdGFuY2UuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ8QXJyYXl9IHN0YXJ0XG4gKiAgICAgICAgVGhlIHN0YXJ0IG9mIGEgc2luZ2xlIHJhbmdlIG9yIGFuIGFycmF5IG9mIHJhbmdlc1xuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmRcbiAqICAgICAgICBUaGUgZW5kIG9mIGEgc2luZ2xlIHJhbmdlLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVRpbWVSYW5nZXMoc3RhcnQsIGVuZCkge1xuICBpZiAoQXJyYXkuaXNBcnJheShzdGFydCkpIHtcbiAgICByZXR1cm4gY3JlYXRlVGltZVJhbmdlc09iaihzdGFydCk7XG4gIH0gZWxzZSBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCB8fCBlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBjcmVhdGVUaW1lUmFuZ2VzT2JqKCk7XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZVRpbWVSYW5nZXNPYmooW1tzdGFydCwgZW5kXV0pO1xufVxuXG4vKipcbiAqIEBmaWxlIGJ1ZmZlci5qc1xuICogQG1vZHVsZSBidWZmZXJcbiAqL1xuLyoqXG4gKiBDb21wdXRlIHRoZSBwZXJjZW50YWdlIG9mIHRoZSBtZWRpYSB0aGF0IGhhcyBiZWVuIGJ1ZmZlcmVkLlxuICpcbiAqIEBwYXJhbSB7VGltZVJhbmdlfSBidWZmZXJlZFxuICogICAgICAgIFRoZSBjdXJyZW50IGBUaW1lUmFuZ2VgIG9iamVjdCByZXByZXNlbnRpbmcgYnVmZmVyZWQgdGltZSByYW5nZXNcbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gZHVyYXRpb25cbiAqICAgICAgICBUb3RhbCBkdXJhdGlvbiBvZiB0aGUgbWVkaWFcbiAqXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKiAgICAgICAgIFBlcmNlbnQgYnVmZmVyZWQgb2YgdGhlIHRvdGFsIGR1cmF0aW9uIGluIGRlY2ltYWwgZm9ybS5cbiAqL1xuZnVuY3Rpb24gYnVmZmVyZWRQZXJjZW50KGJ1ZmZlcmVkLCBkdXJhdGlvbikge1xuICB2YXIgYnVmZmVyZWREdXJhdGlvbiA9IDA7XG4gIHZhciBzdGFydCA9IHZvaWQgMDtcbiAgdmFyIGVuZCA9IHZvaWQgMDtcblxuICBpZiAoIWR1cmF0aW9uKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICBpZiAoIWJ1ZmZlcmVkIHx8ICFidWZmZXJlZC5sZW5ndGgpIHtcbiAgICBidWZmZXJlZCA9IGNyZWF0ZVRpbWVSYW5nZXMoMCwgMCk7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ1ZmZlcmVkLmxlbmd0aDsgaSsrKSB7XG4gICAgc3RhcnQgPSBidWZmZXJlZC5zdGFydChpKTtcbiAgICBlbmQgPSBidWZmZXJlZC5lbmQoaSk7XG5cbiAgICAvLyBidWZmZXJlZCBlbmQgY2FuIGJlIGJpZ2dlciB0aGFuIGR1cmF0aW9uIGJ5IGEgdmVyeSBzbWFsbCBmcmFjdGlvblxuICAgIGlmIChlbmQgPiBkdXJhdGlvbikge1xuICAgICAgZW5kID0gZHVyYXRpb247XG4gICAgfVxuXG4gICAgYnVmZmVyZWREdXJhdGlvbiArPSBlbmQgLSBzdGFydDtcbiAgfVxuXG4gIHJldHVybiBidWZmZXJlZER1cmF0aW9uIC8gZHVyYXRpb247XG59XG5cbi8qKlxuICogQGZpbGUgZnVsbHNjcmVlbi1hcGkuanNcbiAqIEBtb2R1bGUgZnVsbHNjcmVlbi1hcGlcbiAqIEBwcml2YXRlXG4gKi9cbi8qKlxuICogU3RvcmUgdGhlIGJyb3dzZXItc3BlY2lmaWMgbWV0aG9kcyBmb3IgdGhlIGZ1bGxzY3JlZW4gQVBJLlxuICpcbiAqIEB0eXBlIHtPYmplY3R9XG4gKiBAc2VlIFtTcGVjaWZpY2F0aW9uXXtAbGluayBodHRwczovL2Z1bGxzY3JlZW4uc3BlYy53aGF0d2cub3JnfVxuICogQHNlZSBbTWFwIEFwcHJvYWNoIEZyb20gU2NyZWVuZnVsbC5qc117QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL3NpbmRyZXNvcmh1cy9zY3JlZW5mdWxsLmpzfVxuICovXG52YXIgRnVsbHNjcmVlbkFwaSA9IHt9O1xuXG4vLyBicm93c2VyIEFQSSBtZXRob2RzXG52YXIgYXBpTWFwID0gW1sncmVxdWVzdEZ1bGxzY3JlZW4nLCAnZXhpdEZ1bGxzY3JlZW4nLCAnZnVsbHNjcmVlbkVsZW1lbnQnLCAnZnVsbHNjcmVlbkVuYWJsZWQnLCAnZnVsbHNjcmVlbmNoYW5nZScsICdmdWxsc2NyZWVuZXJyb3InXSxcbi8vIFdlYktpdFxuWyd3ZWJraXRSZXF1ZXN0RnVsbHNjcmVlbicsICd3ZWJraXRFeGl0RnVsbHNjcmVlbicsICd3ZWJraXRGdWxsc2NyZWVuRWxlbWVudCcsICd3ZWJraXRGdWxsc2NyZWVuRW5hYmxlZCcsICd3ZWJraXRmdWxsc2NyZWVuY2hhbmdlJywgJ3dlYmtpdGZ1bGxzY3JlZW5lcnJvciddLFxuLy8gT2xkIFdlYktpdCAoU2FmYXJpIDUuMSlcblsnd2Via2l0UmVxdWVzdEZ1bGxTY3JlZW4nLCAnd2Via2l0Q2FuY2VsRnVsbFNjcmVlbicsICd3ZWJraXRDdXJyZW50RnVsbFNjcmVlbkVsZW1lbnQnLCAnd2Via2l0Q2FuY2VsRnVsbFNjcmVlbicsICd3ZWJraXRmdWxsc2NyZWVuY2hhbmdlJywgJ3dlYmtpdGZ1bGxzY3JlZW5lcnJvciddLFxuLy8gTW96aWxsYVxuWydtb3pSZXF1ZXN0RnVsbFNjcmVlbicsICdtb3pDYW5jZWxGdWxsU2NyZWVuJywgJ21vekZ1bGxTY3JlZW5FbGVtZW50JywgJ21vekZ1bGxTY3JlZW5FbmFibGVkJywgJ21vemZ1bGxzY3JlZW5jaGFuZ2UnLCAnbW96ZnVsbHNjcmVlbmVycm9yJ10sXG4vLyBNaWNyb3NvZnRcblsnbXNSZXF1ZXN0RnVsbHNjcmVlbicsICdtc0V4aXRGdWxsc2NyZWVuJywgJ21zRnVsbHNjcmVlbkVsZW1lbnQnLCAnbXNGdWxsc2NyZWVuRW5hYmxlZCcsICdNU0Z1bGxzY3JlZW5DaGFuZ2UnLCAnTVNGdWxsc2NyZWVuRXJyb3InXV07XG5cbnZhciBzcGVjQXBpID0gYXBpTWFwWzBdO1xudmFyIGJyb3dzZXJBcGkgPSB2b2lkIDA7XG5cbi8vIGRldGVybWluZSB0aGUgc3VwcG9ydGVkIHNldCBvZiBmdW5jdGlvbnNcbmZvciAodmFyIGkgPSAwOyBpIDwgYXBpTWFwLmxlbmd0aDsgaSsrKSB7XG4gIC8vIGNoZWNrIGZvciBleGl0RnVsbHNjcmVlbiBmdW5jdGlvblxuICBpZiAoYXBpTWFwW2ldWzFdIGluIGRvY3VtZW50KSB7XG4gICAgYnJvd3NlckFwaSA9IGFwaU1hcFtpXTtcbiAgICBicmVhaztcbiAgfVxufVxuXG4vLyBtYXAgdGhlIGJyb3dzZXIgQVBJIG5hbWVzIHRvIHRoZSBzcGVjIEFQSSBuYW1lc1xuaWYgKGJyb3dzZXJBcGkpIHtcbiAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGJyb3dzZXJBcGkubGVuZ3RoOyBfaSsrKSB7XG4gICAgRnVsbHNjcmVlbkFwaVtzcGVjQXBpW19pXV0gPSBicm93c2VyQXBpW19pXTtcbiAgfVxufVxuXG4vKipcbiAqIEBmaWxlIG1lZGlhLWVycm9yLmpzXG4gKi9cbi8qKlxuICogQSBDdXN0b20gYE1lZGlhRXJyb3JgIGNsYXNzIHdoaWNoIG1pbWljcyB0aGUgc3RhbmRhcmQgSFRNTDUgYE1lZGlhRXJyb3JgIGNsYXNzLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ3xPYmplY3R8TWVkaWFFcnJvcn0gdmFsdWVcbiAqICAgICAgICBUaGlzIGNhbiBiZSBvZiBtdWx0aXBsZSB0eXBlczpcbiAqICAgICAgICAtIG51bWJlcjogc2hvdWxkIGJlIGEgc3RhbmRhcmQgZXJyb3IgY29kZVxuICogICAgICAgIC0gc3RyaW5nOiBhbiBlcnJvciBtZXNzYWdlICh0aGUgY29kZSB3aWxsIGJlIDApXG4gKiAgICAgICAgLSBPYmplY3Q6IGFyYml0cmFyeSBwcm9wZXJ0aWVzXG4gKiAgICAgICAgLSBgTWVkaWFFcnJvcmAgKG5hdGl2ZSk6IHVzZWQgdG8gcG9wdWxhdGUgYSB2aWRlby5qcyBgTWVkaWFFcnJvcmAgb2JqZWN0XG4gKiAgICAgICAgLSBgTWVkaWFFcnJvcmAgKHZpZGVvLmpzKTogd2lsbCByZXR1cm4gaXRzZWxmIGlmIGl0J3MgYWxyZWFkeSBhXG4gKiAgICAgICAgICB2aWRlby5qcyBgTWVkaWFFcnJvcmAgb2JqZWN0LlxuICpcbiAqIEBzZWUgW01lZGlhRXJyb3IgU3BlY117QGxpbmsgaHR0cHM6Ly9kZXYudzMub3JnL2h0bWw1L3NwZWMtYXV0aG9yLXZpZXcvdmlkZW8uaHRtbCNtZWRpYWVycm9yfVxuICogQHNlZSBbRW5jcnlwdGVkIE1lZGlhRXJyb3IgU3BlY117QGxpbmsgaHR0cHM6Ly93d3cudzMub3JnL1RSLzIwMTMvV0QtZW5jcnlwdGVkLW1lZGlhLTIwMTMwNTEwLyNlcnJvci1jb2Rlc31cbiAqXG4gKiBAY2xhc3MgTWVkaWFFcnJvclxuICovXG5mdW5jdGlvbiBNZWRpYUVycm9yKHZhbHVlKSB7XG5cbiAgLy8gQWxsb3cgcmVkdW5kYW50IGNhbGxzIHRvIHRoaXMgY29uc3RydWN0b3IgdG8gYXZvaWQgaGF2aW5nIGBpbnN0YW5jZW9mYFxuICAvLyBjaGVja3MgcGVwcGVyZWQgYXJvdW5kIHRoZSBjb2RlLlxuICBpZiAodmFsdWUgaW5zdGFuY2VvZiBNZWRpYUVycm9yKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICB0aGlzLmNvZGUgPSB2YWx1ZTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgLy8gZGVmYXVsdCBjb2RlIGlzIHplcm8sIHNvIHRoaXMgaXMgYSBjdXN0b20gZXJyb3JcbiAgICB0aGlzLm1lc3NhZ2UgPSB2YWx1ZTtcbiAgfSBlbHNlIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcblxuICAgIC8vIFdlIGFzc2lnbiB0aGUgYGNvZGVgIHByb3BlcnR5IG1hbnVhbGx5IGJlY2F1c2UgbmF0aXZlIGBNZWRpYUVycm9yYCBvYmplY3RzXG4gICAgLy8gZG8gbm90IGV4cG9zZSBpdCBhcyBhbiBvd24vZW51bWVyYWJsZSBwcm9wZXJ0eSBvZiB0aGUgb2JqZWN0LlxuICAgIGlmICh0eXBlb2YgdmFsdWUuY29kZSA9PT0gJ251bWJlcicpIHtcbiAgICAgIHRoaXMuY29kZSA9IHZhbHVlLmNvZGU7XG4gICAgfVxuXG4gICAgYXNzaWduKHRoaXMsIHZhbHVlKTtcbiAgfVxuXG4gIGlmICghdGhpcy5tZXNzYWdlKSB7XG4gICAgdGhpcy5tZXNzYWdlID0gTWVkaWFFcnJvci5kZWZhdWx0TWVzc2FnZXNbdGhpcy5jb2RlXSB8fCAnJztcbiAgfVxufVxuXG4vKipcbiAqIFRoZSBlcnJvciBjb2RlIHRoYXQgcmVmZXJzIHR3byBvbmUgb2YgdGhlIGRlZmluZWQgYE1lZGlhRXJyb3JgIHR5cGVzXG4gKlxuICogQHR5cGUge051bWJlcn1cbiAqL1xuTWVkaWFFcnJvci5wcm90b3R5cGUuY29kZSA9IDA7XG5cbi8qKlxuICogQW4gb3B0aW9uYWwgbWVzc2FnZSB0aGF0IHRvIHNob3cgd2l0aCB0aGUgZXJyb3IuIE1lc3NhZ2UgaXMgbm90IHBhcnQgb2YgdGhlIEhUTUw1XG4gKiB2aWRlbyBzcGVjIGJ1dCBhbGxvd3MgZm9yIG1vcmUgaW5mb3JtYXRpdmUgY3VzdG9tIGVycm9ycy5cbiAqXG4gKiBAdHlwZSB7U3RyaW5nfVxuICovXG5NZWRpYUVycm9yLnByb3RvdHlwZS5tZXNzYWdlID0gJyc7XG5cbi8qKlxuICogQW4gb3B0aW9uYWwgc3RhdHVzIGNvZGUgdGhhdCBjYW4gYmUgc2V0IGJ5IHBsdWdpbnMgdG8gYWxsb3cgZXZlbiBtb3JlIGRldGFpbCBhYm91dFxuICogdGhlIGVycm9yLiBGb3IgZXhhbXBsZSBhIHBsdWdpbiBtaWdodCBwcm92aWRlIGEgc3BlY2lmaWMgSFRUUCBzdGF0dXMgY29kZSBhbmQgYW5cbiAqIGVycm9yIG1lc3NhZ2UgZm9yIHRoYXQgY29kZS4gVGhlbiB3aGVuIHRoZSBwbHVnaW4gZ2V0cyB0aGF0IGVycm9yIHRoaXMgY2xhc3Mgd2lsbFxuICoga25vdyBob3cgdG8gZGlzcGxheSBhbiBlcnJvciBtZXNzYWdlIGZvciBpdC4gVGhpcyBhbGxvd3MgYSBjdXN0b20gbWVzc2FnZSB0byBzaG93XG4gKiB1cCBvbiB0aGUgYFBsYXllcmAgZXJyb3Igb3ZlcmxheS5cbiAqXG4gKiBAdHlwZSB7QXJyYXl9XG4gKi9cbk1lZGlhRXJyb3IucHJvdG90eXBlLnN0YXR1cyA9IG51bGw7XG5cbi8qKlxuICogRXJyb3JzIGluZGV4ZWQgYnkgdGhlIFczQyBzdGFuZGFyZC4gVGhlIG9yZGVyICoqQ0FOTk9UIENIQU5HRSoqISBTZWUgdGhlXG4gKiBzcGVjaWZpY2F0aW9uIGxpc3RlZCB1bmRlciB7QGxpbmsgTWVkaWFFcnJvcn0gZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gKlxuICogQGVudW0ge2FycmF5fVxuICogQHJlYWRvbmx5XG4gKiBAcHJvcGVydHkge3N0cmluZ30gMCAtIE1FRElBX0VSUl9DVVNUT01cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSAxIC0gTUVESUFfRVJSX0NVU1RPTVxuICogQHByb3BlcnR5IHtzdHJpbmd9IDIgLSBNRURJQV9FUlJfQUJPUlRFRFxuICogQHByb3BlcnR5IHtzdHJpbmd9IDMgLSBNRURJQV9FUlJfTkVUV09SS1xuICogQHByb3BlcnR5IHtzdHJpbmd9IDQgLSBNRURJQV9FUlJfU1JDX05PVF9TVVBQT1JURURcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSA1IC0gTUVESUFfRVJSX0VOQ1JZUFRFRFxuICovXG5NZWRpYUVycm9yLmVycm9yVHlwZXMgPSBbJ01FRElBX0VSUl9DVVNUT00nLCAnTUVESUFfRVJSX0FCT1JURUQnLCAnTUVESUFfRVJSX05FVFdPUksnLCAnTUVESUFfRVJSX0RFQ09ERScsICdNRURJQV9FUlJfU1JDX05PVF9TVVBQT1JURUQnLCAnTUVESUFfRVJSX0VOQ1JZUFRFRCddO1xuXG4vKipcbiAqIFRoZSBkZWZhdWx0IGBNZWRpYUVycm9yYCBtZXNzYWdlcyBiYXNlZCBvbiB0aGUge0BsaW5rIE1lZGlhRXJyb3IuZXJyb3JUeXBlc30uXG4gKlxuICogQHR5cGUge0FycmF5fVxuICogQGNvbnN0YW50XG4gKi9cbk1lZGlhRXJyb3IuZGVmYXVsdE1lc3NhZ2VzID0ge1xuICAxOiAnWW91IGFib3J0ZWQgdGhlIG1lZGlhIHBsYXliYWNrJyxcbiAgMjogJ0EgbmV0d29yayBlcnJvciBjYXVzZWQgdGhlIG1lZGlhIGRvd25sb2FkIHRvIGZhaWwgcGFydC13YXkuJyxcbiAgMzogJ1RoZSBtZWRpYSBwbGF5YmFjayB3YXMgYWJvcnRlZCBkdWUgdG8gYSBjb3JydXB0aW9uIHByb2JsZW0gb3IgYmVjYXVzZSB0aGUgbWVkaWEgdXNlZCBmZWF0dXJlcyB5b3VyIGJyb3dzZXIgZGlkIG5vdCBzdXBwb3J0LicsXG4gIDQ6ICdUaGUgbWVkaWEgY291bGQgbm90IGJlIGxvYWRlZCwgZWl0aGVyIGJlY2F1c2UgdGhlIHNlcnZlciBvciBuZXR3b3JrIGZhaWxlZCBvciBiZWNhdXNlIHRoZSBmb3JtYXQgaXMgbm90IHN1cHBvcnRlZC4nLFxuICA1OiAnVGhlIG1lZGlhIGlzIGVuY3J5cHRlZCBhbmQgd2UgZG8gbm90IGhhdmUgdGhlIGtleXMgdG8gZGVjcnlwdCBpdC4nXG59O1xuXG4vLyBBZGQgdHlwZXMgYXMgcHJvcGVydGllcyBvbiBNZWRpYUVycm9yXG4vLyBlLmcuIE1lZGlhRXJyb3IuTUVESUFfRVJSX1NSQ19OT1RfU1VQUE9SVEVEID0gNDtcbmZvciAodmFyIGVyck51bSA9IDA7IGVyck51bSA8IE1lZGlhRXJyb3IuZXJyb3JUeXBlcy5sZW5ndGg7IGVyck51bSsrKSB7XG4gIE1lZGlhRXJyb3JbTWVkaWFFcnJvci5lcnJvclR5cGVzW2Vyck51bV1dID0gZXJyTnVtO1xuICAvLyB2YWx1ZXMgc2hvdWxkIGJlIGFjY2Vzc2libGUgb24gYm90aCB0aGUgY2xhc3MgYW5kIGluc3RhbmNlXG4gIE1lZGlhRXJyb3IucHJvdG90eXBlW01lZGlhRXJyb3IuZXJyb3JUeXBlc1tlcnJOdW1dXSA9IGVyck51bTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgYW4gb2JqZWN0IGlzIGBQcm9taXNlYC1saWtlIChpLmUuIGhhcyBhIGB0aGVuYCBtZXRob2QpLlxuICpcbiAqIEBwYXJhbSAge09iamVjdH0gIHZhbHVlXG4gKiAgICAgICAgIEFuIG9iamVjdCB0aGF0IG1heSBvciBtYXkgbm90IGJlIGBQcm9taXNlYC1saWtlLlxuICpcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiAgICAgICAgIFdoZXRoZXIgb3Igbm90IHRoZSBvYmplY3QgaXMgYFByb21pc2VgLWxpa2UuXG4gKi9cbmZ1bmN0aW9uIGlzUHJvbWlzZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUudGhlbiA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuLyoqXG4gKiBTaWxlbmNlIGEgUHJvbWlzZS1saWtlIG9iamVjdC5cbiAqXG4gKiBUaGlzIGlzIHVzZWZ1bCBmb3IgYXZvaWRpbmcgbm9uLWhhcm1mdWwsIGJ1dCBwb3RlbnRpYWxseSBjb25mdXNpbmcgXCJ1bmNhdWdodFxuICogcGxheSBwcm9taXNlXCIgcmVqZWN0aW9uIGVycm9yIG1lc3NhZ2VzLlxuICpcbiAqIEBwYXJhbSAge09iamVjdH0gdmFsdWVcbiAqICAgICAgICAgQW4gb2JqZWN0IHRoYXQgbWF5IG9yIG1heSBub3QgYmUgYFByb21pc2VgLWxpa2UuXG4gKi9cbmZ1bmN0aW9uIHNpbGVuY2VQcm9taXNlKHZhbHVlKSB7XG4gIGlmIChpc1Byb21pc2UodmFsdWUpKSB7XG4gICAgdmFsdWUudGhlbihudWxsLCBmdW5jdGlvbiAoZSkge30pO1xuICB9XG59XG5cbi8qKlxuICogQGZpbGUgdGV4dC10cmFjay1saXN0LWNvbnZlcnRlci5qcyBVdGlsaXRpZXMgZm9yIGNhcHR1cmluZyB0ZXh0IHRyYWNrIHN0YXRlIGFuZFxuICogcmUtY3JlYXRpbmcgdHJhY2tzIGJhc2VkIG9uIGEgY2FwdHVyZS5cbiAqXG4gKiBAbW9kdWxlIHRleHQtdHJhY2stbGlzdC1jb252ZXJ0ZXJcbiAqL1xuXG4vKipcbiAqIEV4YW1pbmUgYSBzaW5nbGUge0BsaW5rIFRleHRUcmFja30gYW5kIHJldHVybiBhIEpTT04tY29tcGF0aWJsZSBqYXZhc2NyaXB0IG9iamVjdCB0aGF0XG4gKiByZXByZXNlbnRzIHRoZSB7QGxpbmsgVGV4dFRyYWNrfSdzIHN0YXRlLlxuICpcbiAqIEBwYXJhbSB7VGV4dFRyYWNrfSB0cmFja1xuICogICAgICAgIFRoZSB0ZXh0IHRyYWNrIHRvIHF1ZXJ5LlxuICpcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqICAgICAgICAgQSBzZXJpYWxpemFibGUgamF2YXNjcmlwdCByZXByZXNlbnRhdGlvbiBvZiB0aGUgVGV4dFRyYWNrLlxuICogQHByaXZhdGVcbiAqL1xudmFyIHRyYWNrVG9Kc29uXyA9IGZ1bmN0aW9uIHRyYWNrVG9Kc29uXyh0cmFjaykge1xuICB2YXIgcmV0ID0gWydraW5kJywgJ2xhYmVsJywgJ2xhbmd1YWdlJywgJ2lkJywgJ2luQmFuZE1ldGFkYXRhVHJhY2tEaXNwYXRjaFR5cGUnLCAnbW9kZScsICdzcmMnXS5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgcHJvcCwgaSkge1xuXG4gICAgaWYgKHRyYWNrW3Byb3BdKSB7XG4gICAgICBhY2NbcHJvcF0gPSB0cmFja1twcm9wXTtcbiAgICB9XG5cbiAgICByZXR1cm4gYWNjO1xuICB9LCB7XG4gICAgY3VlczogdHJhY2suY3VlcyAmJiBBcnJheS5wcm90b3R5cGUubWFwLmNhbGwodHJhY2suY3VlcywgZnVuY3Rpb24gKGN1ZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3RhcnRUaW1lOiBjdWUuc3RhcnRUaW1lLFxuICAgICAgICBlbmRUaW1lOiBjdWUuZW5kVGltZSxcbiAgICAgICAgdGV4dDogY3VlLnRleHQsXG4gICAgICAgIGlkOiBjdWUuaWRcbiAgICAgIH07XG4gICAgfSlcbiAgfSk7XG5cbiAgcmV0dXJuIHJldDtcbn07XG5cbi8qKlxuICogRXhhbWluZSBhIHtAbGluayBUZWNofSBhbmQgcmV0dXJuIGEgSlNPTi1jb21wYXRpYmxlIGphdmFzY3JpcHQgYXJyYXkgdGhhdCByZXByZXNlbnRzIHRoZVxuICogc3RhdGUgb2YgYWxsIHtAbGluayBUZXh0VHJhY2t9cyBjdXJyZW50bHkgY29uZmlndXJlZC4gVGhlIHJldHVybiBhcnJheSBpcyBjb21wYXRpYmxlIHdpdGhcbiAqIHtAbGluayB0ZXh0LXRyYWNrLWxpc3QtY29udmVydGVyOmpzb25Ub1RleHRUcmFja3N9LlxuICpcbiAqIEBwYXJhbSB7VGVjaH0gdGVjaFxuICogICAgICAgIFRoZSB0ZWNoIG9iamVjdCB0byBxdWVyeVxuICpcbiAqIEByZXR1cm4ge0FycmF5fVxuICogICAgICAgICBBIHNlcmlhbGl6YWJsZSBqYXZhc2NyaXB0IHJlcHJlc2VudGF0aW9uIG9mIHRoZSB7QGxpbmsgVGVjaH1zXG4gKiAgICAgICAgIHtAbGluayBUZXh0VHJhY2tMaXN0fS5cbiAqL1xudmFyIHRleHRUcmFja3NUb0pzb24gPSBmdW5jdGlvbiB0ZXh0VHJhY2tzVG9Kc29uKHRlY2gpIHtcblxuICB2YXIgdHJhY2tFbHMgPSB0ZWNoLiQkKCd0cmFjaycpO1xuXG4gIHZhciB0cmFja09ianMgPSBBcnJheS5wcm90b3R5cGUubWFwLmNhbGwodHJhY2tFbHMsIGZ1bmN0aW9uICh0KSB7XG4gICAgcmV0dXJuIHQudHJhY2s7XG4gIH0pO1xuICB2YXIgdHJhY2tzID0gQXJyYXkucHJvdG90eXBlLm1hcC5jYWxsKHRyYWNrRWxzLCBmdW5jdGlvbiAodHJhY2tFbCkge1xuICAgIHZhciBqc29uID0gdHJhY2tUb0pzb25fKHRyYWNrRWwudHJhY2spO1xuXG4gICAgaWYgKHRyYWNrRWwuc3JjKSB7XG4gICAgICBqc29uLnNyYyA9IHRyYWNrRWwuc3JjO1xuICAgIH1cbiAgICByZXR1cm4ganNvbjtcbiAgfSk7XG5cbiAgcmV0dXJuIHRyYWNrcy5jb25jYXQoQXJyYXkucHJvdG90eXBlLmZpbHRlci5jYWxsKHRlY2gudGV4dFRyYWNrcygpLCBmdW5jdGlvbiAodHJhY2spIHtcbiAgICByZXR1cm4gdHJhY2tPYmpzLmluZGV4T2YodHJhY2spID09PSAtMTtcbiAgfSkubWFwKHRyYWNrVG9Kc29uXykpO1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYSBzZXQgb2YgcmVtb3RlIHtAbGluayBUZXh0VHJhY2t9cyBvbiBhIHtAbGluayBUZWNofSBiYXNlZCBvbiBhbiBhcnJheSBvZiBqYXZhc2NyaXB0XG4gKiBvYmplY3Qge0BsaW5rIFRleHRUcmFja30gcmVwcmVzZW50YXRpb25zLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGpzb25cbiAqICAgICAgICBBbiBhcnJheSBvZiBgVGV4dFRyYWNrYCByZXByZXNlbnRhdGlvbiBvYmplY3RzLCBsaWtlIHRob3NlIHRoYXQgd291bGQgYmVcbiAqICAgICAgICBwcm9kdWNlZCBieSBgdGV4dFRyYWNrc1RvSnNvbmAuXG4gKlxuICogQHBhcmFtIHtUZWNofSB0ZWNoXG4gKiAgICAgICAgVGhlIGBUZWNoYCB0byBjcmVhdGUgdGhlIGBUZXh0VHJhY2tgcyBvbi5cbiAqL1xudmFyIGpzb25Ub1RleHRUcmFja3MgPSBmdW5jdGlvbiBqc29uVG9UZXh0VHJhY2tzKGpzb24sIHRlY2gpIHtcbiAganNvbi5mb3JFYWNoKGZ1bmN0aW9uICh0cmFjaykge1xuICAgIHZhciBhZGRlZFRyYWNrID0gdGVjaC5hZGRSZW1vdGVUZXh0VHJhY2sodHJhY2spLnRyYWNrO1xuXG4gICAgaWYgKCF0cmFjay5zcmMgJiYgdHJhY2suY3Vlcykge1xuICAgICAgdHJhY2suY3Vlcy5mb3JFYWNoKGZ1bmN0aW9uIChjdWUpIHtcbiAgICAgICAgcmV0dXJuIGFkZGVkVHJhY2suYWRkQ3VlKGN1ZSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiB0ZWNoLnRleHRUcmFja3MoKTtcbn07XG5cbnZhciB0ZXh0VHJhY2tDb252ZXJ0ZXIgPSB7IHRleHRUcmFja3NUb0pzb246IHRleHRUcmFja3NUb0pzb24sIGpzb25Ub1RleHRUcmFja3M6IGpzb25Ub1RleHRUcmFja3MsIHRyYWNrVG9Kc29uXzogdHJhY2tUb0pzb25fIH07XG5cbi8qKlxuICogQGZpbGUgbW9kYWwtZGlhbG9nLmpzXG4gKi9cbnZhciBNT0RBTF9DTEFTU19OQU1FID0gJ3Zqcy1tb2RhbC1kaWFsb2cnO1xudmFyIEVTQyA9IDI3O1xuXG4vKipcbiAqIFRoZSBgTW9kYWxEaWFsb2dgIGRpc3BsYXlzIG92ZXIgdGhlIHZpZGVvIGFuZCBpdHMgY29udHJvbHMsIHdoaWNoIGJsb2Nrc1xuICogaW50ZXJhY3Rpb24gd2l0aCB0aGUgcGxheWVyIHVudGlsIGl0IGlzIGNsb3NlZC5cbiAqXG4gKiBNb2RhbCBkaWFsb2dzIGluY2x1ZGUgYSBcIkNsb3NlXCIgYnV0dG9uIGFuZCB3aWxsIGNsb3NlIHdoZW4gdGhhdCBidXR0b25cbiAqIGlzIGFjdGl2YXRlZCAtIG9yIHdoZW4gRVNDIGlzIHByZXNzZWQgYW55d2hlcmUuXG4gKlxuICogQGV4dGVuZHMgQ29tcG9uZW50XG4gKi9cblxudmFyIE1vZGFsRGlhbG9nID0gZnVuY3Rpb24gKF9Db21wb25lbnQpIHtcbiAgaW5oZXJpdHMoTW9kYWxEaWFsb2csIF9Db21wb25lbnQpO1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcy5cbiAgICpcbiAgICogQHBhcmFtIHtQbGF5ZXJ9IHBsYXllclxuICAgKiAgICAgICAgVGhlIGBQbGF5ZXJgIHRoYXQgdGhpcyBjbGFzcyBzaG91bGQgYmUgYXR0YWNoZWQgdG8uXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICAgICAgIFRoZSBrZXkvdmFsdWUgc3RvcmUgb2YgcGxheWVyIG9wdGlvbnMuXG4gICAqXG4gICAqIEBwYXJhbSB7TWl4ZWR9IFtvcHRpb25zLmNvbnRlbnQ9dW5kZWZpbmVkXVxuICAgKiAgICAgICAgUHJvdmlkZSBjdXN0b21pemVkIGNvbnRlbnQgZm9yIHRoaXMgbW9kYWwuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5kZXNjcmlwdGlvbl1cbiAgICogICAgICAgIEEgdGV4dCBkZXNjcmlwdGlvbiBmb3IgdGhlIG1vZGFsLCBwcmltYXJpbHkgZm9yIGFjY2Vzc2liaWxpdHkuXG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuZmlsbEFsd2F5cz1mYWxzZV1cbiAgICogICAgICAgIE5vcm1hbGx5LCBtb2RhbHMgYXJlIGF1dG9tYXRpY2FsbHkgZmlsbGVkIG9ubHkgdGhlIGZpcnN0IHRpbWVcbiAgICogICAgICAgIHRoZXkgb3Blbi4gVGhpcyB0ZWxscyB0aGUgbW9kYWwgdG8gcmVmcmVzaCBpdHMgY29udGVudFxuICAgKiAgICAgICAgZXZlcnkgdGltZSBpdCBvcGVucy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmxhYmVsXVxuICAgKiAgICAgICAgQSB0ZXh0IGxhYmVsIGZvciB0aGUgbW9kYWwsIHByaW1hcmlseSBmb3IgYWNjZXNzaWJpbGl0eS5cbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy50ZW1wb3Jhcnk9dHJ1ZV1cbiAgICogICAgICAgIElmIGB0cnVlYCwgdGhlIG1vZGFsIGNhbiBvbmx5IGJlIG9wZW5lZCBvbmNlOyBpdCB3aWxsIGJlXG4gICAqICAgICAgICBkaXNwb3NlZCBhcyBzb29uIGFzIGl0J3MgY2xvc2VkLlxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnVuY2xvc2VhYmxlPWZhbHNlXVxuICAgKiAgICAgICAgSWYgYHRydWVgLCB0aGUgdXNlciB3aWxsIG5vdCBiZSBhYmxlIHRvIGNsb3NlIHRoZSBtb2RhbFxuICAgKiAgICAgICAgdGhyb3VnaCB0aGUgVUkgaW4gdGhlIG5vcm1hbCB3YXlzLiBQcm9ncmFtbWF0aWMgY2xvc2luZyBpc1xuICAgKiAgICAgICAgc3RpbGwgcG9zc2libGUuXG4gICAqL1xuICBmdW5jdGlvbiBNb2RhbERpYWxvZyhwbGF5ZXIsIG9wdGlvbnMpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBNb2RhbERpYWxvZyk7XG5cbiAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9Db21wb25lbnQuY2FsbCh0aGlzLCBwbGF5ZXIsIG9wdGlvbnMpKTtcblxuICAgIF90aGlzLm9wZW5lZF8gPSBfdGhpcy5oYXNCZWVuT3BlbmVkXyA9IF90aGlzLmhhc0JlZW5GaWxsZWRfID0gZmFsc2U7XG5cbiAgICBfdGhpcy5jbG9zZWFibGUoIV90aGlzLm9wdGlvbnNfLnVuY2xvc2VhYmxlKTtcbiAgICBfdGhpcy5jb250ZW50KF90aGlzLm9wdGlvbnNfLmNvbnRlbnQpO1xuXG4gICAgLy8gTWFrZSBzdXJlIHRoZSBjb250ZW50RWwgaXMgZGVmaW5lZCBBRlRFUiBhbnkgY2hpbGRyZW4gYXJlIGluaXRpYWxpemVkXG4gICAgLy8gYmVjYXVzZSB3ZSBvbmx5IHdhbnQgdGhlIGNvbnRlbnRzIG9mIHRoZSBtb2RhbCBpbiB0aGUgY29udGVudEVsXG4gICAgLy8gKG5vdCB0aGUgVUkgZWxlbWVudHMgbGlrZSB0aGUgY2xvc2UgYnV0dG9uKS5cbiAgICBfdGhpcy5jb250ZW50RWxfID0gY3JlYXRlRWwoJ2RpdicsIHtcbiAgICAgIGNsYXNzTmFtZTogTU9EQUxfQ0xBU1NfTkFNRSArICctY29udGVudCdcbiAgICB9LCB7XG4gICAgICByb2xlOiAnZG9jdW1lbnQnXG4gICAgfSk7XG5cbiAgICBfdGhpcy5kZXNjRWxfID0gY3JlYXRlRWwoJ3AnLCB7XG4gICAgICBjbGFzc05hbWU6IE1PREFMX0NMQVNTX05BTUUgKyAnLWRlc2NyaXB0aW9uIHZqcy1jb250cm9sLXRleHQnLFxuICAgICAgaWQ6IF90aGlzLmVsKCkuZ2V0QXR0cmlidXRlKCdhcmlhLWRlc2NyaWJlZGJ5JylcbiAgICB9KTtcblxuICAgIHRleHRDb250ZW50KF90aGlzLmRlc2NFbF8sIF90aGlzLmRlc2NyaXB0aW9uKCkpO1xuICAgIF90aGlzLmVsXy5hcHBlbmRDaGlsZChfdGhpcy5kZXNjRWxfKTtcbiAgICBfdGhpcy5lbF8uYXBwZW5kQ2hpbGQoX3RoaXMuY29udGVudEVsXyk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSB0aGUgYE1vZGFsRGlhbG9nYCdzIERPTSBlbGVtZW50XG4gICAqXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9XG4gICAqICAgICAgICAgVGhlIERPTSBlbGVtZW50IHRoYXQgZ2V0cyBjcmVhdGVkLlxuICAgKi9cblxuXG4gIE1vZGFsRGlhbG9nLnByb3RvdHlwZS5jcmVhdGVFbCA9IGZ1bmN0aW9uIGNyZWF0ZUVsJCQxKCkge1xuICAgIHJldHVybiBfQ29tcG9uZW50LnByb3RvdHlwZS5jcmVhdGVFbC5jYWxsKHRoaXMsICdkaXYnLCB7XG4gICAgICBjbGFzc05hbWU6IHRoaXMuYnVpbGRDU1NDbGFzcygpLFxuICAgICAgdGFiSW5kZXg6IC0xXG4gICAgfSwge1xuICAgICAgJ2FyaWEtZGVzY3JpYmVkYnknOiB0aGlzLmlkKCkgKyAnX2Rlc2NyaXB0aW9uJyxcbiAgICAgICdhcmlhLWhpZGRlbic6ICd0cnVlJyxcbiAgICAgICdhcmlhLWxhYmVsJzogdGhpcy5sYWJlbCgpLFxuICAgICAgJ3JvbGUnOiAnZGlhbG9nJ1xuICAgIH0pO1xuICB9O1xuXG4gIE1vZGFsRGlhbG9nLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gZGlzcG9zZSgpIHtcbiAgICB0aGlzLmNvbnRlbnRFbF8gPSBudWxsO1xuICAgIHRoaXMuZGVzY0VsXyA9IG51bGw7XG4gICAgdGhpcy5wcmV2aW91c2x5QWN0aXZlRWxfID0gbnVsbDtcblxuICAgIF9Db21wb25lbnQucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcbiAgfTtcblxuICAvKipcbiAgICogQnVpbGRzIHRoZSBkZWZhdWx0IERPTSBgY2xhc3NOYW1lYC5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKiAgICAgICAgIFRoZSBET00gYGNsYXNzTmFtZWAgZm9yIHRoaXMgb2JqZWN0LlxuICAgKi9cblxuXG4gIE1vZGFsRGlhbG9nLnByb3RvdHlwZS5idWlsZENTU0NsYXNzID0gZnVuY3Rpb24gYnVpbGRDU1NDbGFzcygpIHtcbiAgICByZXR1cm4gTU9EQUxfQ0xBU1NfTkFNRSArICcgdmpzLWhpZGRlbiAnICsgX0NvbXBvbmVudC5wcm90b3R5cGUuYnVpbGRDU1NDbGFzcy5jYWxsKHRoaXMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBIYW5kbGVzIGBrZXlkb3duYCBldmVudHMgb24gdGhlIGRvY3VtZW50LCBsb29raW5nIGZvciBFU0MsIHdoaWNoIGNsb3Nlc1xuICAgKiB0aGUgbW9kYWwuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IGVcbiAgICogICAgICAgIFRoZSBrZXlwcmVzcyB0aGF0IHRyaWdnZXJlZCB0aGlzIGV2ZW50LlxuICAgKlxuICAgKiBAbGlzdGVucyBrZXlkb3duXG4gICAqL1xuXG5cbiAgTW9kYWxEaWFsb2cucHJvdG90eXBlLmhhbmRsZUtleVByZXNzID0gZnVuY3Rpb24gaGFuZGxlS2V5UHJlc3MoZSkge1xuICAgIGlmIChlLndoaWNoID09PSBFU0MgJiYgdGhpcy5jbG9zZWFibGUoKSkge1xuICAgICAgdGhpcy5jbG9zZSgpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbGFiZWwgc3RyaW5nIGZvciB0aGlzIG1vZGFsLiBQcmltYXJpbHkgdXNlZCBmb3IgYWNjZXNzaWJpbGl0eS5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKiAgICAgICAgIHRoZSBsb2NhbGl6ZWQgb3IgcmF3IGxhYmVsIG9mIHRoaXMgbW9kYWwuXG4gICAqL1xuXG5cbiAgTW9kYWxEaWFsb2cucHJvdG90eXBlLmxhYmVsID0gZnVuY3Rpb24gbGFiZWwoKSB7XG4gICAgcmV0dXJuIHRoaXMubG9jYWxpemUodGhpcy5vcHRpb25zXy5sYWJlbCB8fCAnTW9kYWwgV2luZG93Jyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGRlc2NyaXB0aW9uIHN0cmluZyBmb3IgdGhpcyBtb2RhbC4gUHJpbWFyaWx5IHVzZWQgZm9yXG4gICAqIGFjY2Vzc2liaWxpdHkuXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICogICAgICAgICBUaGUgbG9jYWxpemVkIG9yIHJhdyBkZXNjcmlwdGlvbiBvZiB0aGlzIG1vZGFsLlxuICAgKi9cblxuXG4gIE1vZGFsRGlhbG9nLnByb3RvdHlwZS5kZXNjcmlwdGlvbiA9IGZ1bmN0aW9uIGRlc2NyaXB0aW9uKCkge1xuICAgIHZhciBkZXNjID0gdGhpcy5vcHRpb25zXy5kZXNjcmlwdGlvbiB8fCB0aGlzLmxvY2FsaXplKCdUaGlzIGlzIGEgbW9kYWwgd2luZG93LicpO1xuXG4gICAgLy8gQXBwZW5kIGEgdW5pdmVyc2FsIGNsb3NlYWJpbGl0eSBtZXNzYWdlIGlmIHRoZSBtb2RhbCBpcyBjbG9zZWFibGUuXG4gICAgaWYgKHRoaXMuY2xvc2VhYmxlKCkpIHtcbiAgICAgIGRlc2MgKz0gJyAnICsgdGhpcy5sb2NhbGl6ZSgnVGhpcyBtb2RhbCBjYW4gYmUgY2xvc2VkIGJ5IHByZXNzaW5nIHRoZSBFc2NhcGUga2V5IG9yIGFjdGl2YXRpbmcgdGhlIGNsb3NlIGJ1dHRvbi4nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGVzYztcbiAgfTtcblxuICAvKipcbiAgICogT3BlbnMgdGhlIG1vZGFsLlxuICAgKlxuICAgKiBAZmlyZXMgTW9kYWxEaWFsb2cjYmVmb3JlbW9kYWxvcGVuXG4gICAqIEBmaXJlcyBNb2RhbERpYWxvZyNtb2RhbG9wZW5cbiAgICovXG5cblxuICBNb2RhbERpYWxvZy5wcm90b3R5cGUub3BlbiA9IGZ1bmN0aW9uIG9wZW4oKSB7XG4gICAgaWYgKCF0aGlzLm9wZW5lZF8pIHtcbiAgICAgIHZhciBwbGF5ZXIgPSB0aGlzLnBsYXllcigpO1xuXG4gICAgICAvKipcbiAgICAgICAgKiBGaXJlZCBqdXN0IGJlZm9yZSBhIGBNb2RhbERpYWxvZ2AgaXMgb3BlbmVkLlxuICAgICAgICAqXG4gICAgICAgICogQGV2ZW50IE1vZGFsRGlhbG9nI2JlZm9yZW1vZGFsb3BlblxuICAgICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAgICAgICAgKi9cbiAgICAgIHRoaXMudHJpZ2dlcignYmVmb3JlbW9kYWxvcGVuJyk7XG4gICAgICB0aGlzLm9wZW5lZF8gPSB0cnVlO1xuXG4gICAgICAvLyBGaWxsIGNvbnRlbnQgaWYgdGhlIG1vZGFsIGhhcyBuZXZlciBvcGVuZWQgYmVmb3JlIGFuZFxuICAgICAgLy8gbmV2ZXIgYmVlbiBmaWxsZWQuXG4gICAgICBpZiAodGhpcy5vcHRpb25zXy5maWxsQWx3YXlzIHx8ICF0aGlzLmhhc0JlZW5PcGVuZWRfICYmICF0aGlzLmhhc0JlZW5GaWxsZWRfKSB7XG4gICAgICAgIHRoaXMuZmlsbCgpO1xuICAgICAgfVxuXG4gICAgICAvLyBJZiB0aGUgcGxheWVyIHdhcyBwbGF5aW5nLCBwYXVzZSBpdCBhbmQgdGFrZSBub3RlIG9mIGl0cyBwcmV2aW91c2x5XG4gICAgICAvLyBwbGF5aW5nIHN0YXRlLlxuICAgICAgdGhpcy53YXNQbGF5aW5nXyA9ICFwbGF5ZXIucGF1c2VkKCk7XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnNfLnBhdXNlT25PcGVuICYmIHRoaXMud2FzUGxheWluZ18pIHtcbiAgICAgICAgcGxheWVyLnBhdXNlKCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmNsb3NlYWJsZSgpKSB7XG4gICAgICAgIHRoaXMub24odGhpcy5lbF8ub3duZXJEb2N1bWVudCwgJ2tleWRvd24nLCBiaW5kKHRoaXMsIHRoaXMuaGFuZGxlS2V5UHJlc3MpKTtcbiAgICAgIH1cblxuICAgICAgLy8gSGlkZSBjb250cm9scyBhbmQgbm90ZSBpZiB0aGV5IHdlcmUgZW5hYmxlZC5cbiAgICAgIHRoaXMuaGFkQ29udHJvbHNfID0gcGxheWVyLmNvbnRyb2xzKCk7XG4gICAgICBwbGF5ZXIuY29udHJvbHMoZmFsc2UpO1xuXG4gICAgICB0aGlzLnNob3coKTtcbiAgICAgIHRoaXMuY29uZGl0aW9uYWxGb2N1c18oKTtcbiAgICAgIHRoaXMuZWwoKS5zZXRBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJywgJ2ZhbHNlJyk7XG5cbiAgICAgIC8qKlxuICAgICAgICAqIEZpcmVkIGp1c3QgYWZ0ZXIgYSBgTW9kYWxEaWFsb2dgIGlzIG9wZW5lZC5cbiAgICAgICAgKlxuICAgICAgICAqIEBldmVudCBNb2RhbERpYWxvZyNtb2RhbG9wZW5cbiAgICAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gICAgICAgICovXG4gICAgICB0aGlzLnRyaWdnZXIoJ21vZGFsb3BlbicpO1xuICAgICAgdGhpcy5oYXNCZWVuT3BlbmVkXyA9IHRydWU7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBJZiB0aGUgYE1vZGFsRGlhbG9nYCBpcyBjdXJyZW50bHkgb3BlbiBvciBjbG9zZWQuXG4gICAqXG4gICAqIEBwYXJhbSAge2Jvb2xlYW59IFt2YWx1ZV1cbiAgICogICAgICAgICBJZiBnaXZlbiwgaXQgd2lsbCBvcGVuIChgdHJ1ZWApIG9yIGNsb3NlIChgZmFsc2VgKSB0aGUgbW9kYWwuXG4gICAqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqICAgICAgICAgdGhlIGN1cnJlbnQgb3BlbiBzdGF0ZSBvZiB0aGUgbW9kYWxkaWFsb2dcbiAgICovXG5cblxuICBNb2RhbERpYWxvZy5wcm90b3R5cGUub3BlbmVkID0gZnVuY3Rpb24gb3BlbmVkKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICB0aGlzW3ZhbHVlID8gJ29wZW4nIDogJ2Nsb3NlJ10oKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMub3BlbmVkXztcbiAgfTtcblxuICAvKipcbiAgICogQ2xvc2VzIHRoZSBtb2RhbCwgZG9lcyBub3RoaW5nIGlmIHRoZSBgTW9kYWxEaWFsb2dgIGlzXG4gICAqIG5vdCBvcGVuLlxuICAgKlxuICAgKiBAZmlyZXMgTW9kYWxEaWFsb2cjYmVmb3JlbW9kYWxjbG9zZVxuICAgKiBAZmlyZXMgTW9kYWxEaWFsb2cjbW9kYWxjbG9zZVxuICAgKi9cblxuXG4gIE1vZGFsRGlhbG9nLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uIGNsb3NlKCkge1xuICAgIGlmICghdGhpcy5vcGVuZWRfKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBwbGF5ZXIgPSB0aGlzLnBsYXllcigpO1xuXG4gICAgLyoqXG4gICAgICAqIEZpcmVkIGp1c3QgYmVmb3JlIGEgYE1vZGFsRGlhbG9nYCBpcyBjbG9zZWQuXG4gICAgICAqXG4gICAgICAqIEBldmVudCBNb2RhbERpYWxvZyNiZWZvcmVtb2RhbGNsb3NlXG4gICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAgICAgICovXG4gICAgdGhpcy50cmlnZ2VyKCdiZWZvcmVtb2RhbGNsb3NlJyk7XG4gICAgdGhpcy5vcGVuZWRfID0gZmFsc2U7XG5cbiAgICBpZiAodGhpcy53YXNQbGF5aW5nXyAmJiB0aGlzLm9wdGlvbnNfLnBhdXNlT25PcGVuKSB7XG4gICAgICBwbGF5ZXIucGxheSgpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmNsb3NlYWJsZSgpKSB7XG4gICAgICB0aGlzLm9mZih0aGlzLmVsXy5vd25lckRvY3VtZW50LCAna2V5ZG93bicsIGJpbmQodGhpcywgdGhpcy5oYW5kbGVLZXlQcmVzcykpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmhhZENvbnRyb2xzXykge1xuICAgICAgcGxheWVyLmNvbnRyb2xzKHRydWUpO1xuICAgIH1cblxuICAgIHRoaXMuaGlkZSgpO1xuICAgIHRoaXMuZWwoKS5zZXRBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJywgJ3RydWUnKTtcblxuICAgIC8qKlxuICAgICAgKiBGaXJlZCBqdXN0IGFmdGVyIGEgYE1vZGFsRGlhbG9nYCBpcyBjbG9zZWQuXG4gICAgICAqXG4gICAgICAqIEBldmVudCBNb2RhbERpYWxvZyNtb2RhbGNsb3NlXG4gICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAgICAgICovXG4gICAgdGhpcy50cmlnZ2VyKCdtb2RhbGNsb3NlJyk7XG4gICAgdGhpcy5jb25kaXRpb25hbEJsdXJfKCk7XG5cbiAgICBpZiAodGhpcy5vcHRpb25zXy50ZW1wb3JhcnkpIHtcbiAgICAgIHRoaXMuZGlzcG9zZSgpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQ2hlY2sgdG8gc2VlIGlmIHRoZSBgTW9kYWxEaWFsb2dgIGlzIGNsb3NlYWJsZSB2aWEgdGhlIFVJLlxuICAgKlxuICAgKiBAcGFyYW0gIHtib29sZWFufSBbdmFsdWVdXG4gICAqICAgICAgICAgSWYgZ2l2ZW4gYXMgYSBib29sZWFuLCBpdCB3aWxsIHNldCB0aGUgYGNsb3NlYWJsZWAgb3B0aW9uLlxuICAgKlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKiAgICAgICAgIFJldHVybnMgdGhlIGZpbmFsIHZhbHVlIG9mIHRoZSBjbG9zYWJsZSBvcHRpb24uXG4gICAqL1xuXG5cbiAgTW9kYWxEaWFsb2cucHJvdG90eXBlLmNsb3NlYWJsZSA9IGZ1bmN0aW9uIGNsb3NlYWJsZSh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgdmFyIGNsb3NlYWJsZSA9IHRoaXMuY2xvc2VhYmxlXyA9ICEhdmFsdWU7XG4gICAgICB2YXIgY2xvc2UgPSB0aGlzLmdldENoaWxkKCdjbG9zZUJ1dHRvbicpO1xuXG4gICAgICAvLyBJZiB0aGlzIGlzIGJlaW5nIG1hZGUgY2xvc2VhYmxlIGFuZCBoYXMgbm8gY2xvc2UgYnV0dG9uLCBhZGQgb25lLlxuICAgICAgaWYgKGNsb3NlYWJsZSAmJiAhY2xvc2UpIHtcblxuICAgICAgICAvLyBUaGUgY2xvc2UgYnV0dG9uIHNob3VsZCBiZSBhIGNoaWxkIG9mIHRoZSBtb2RhbCAtIG5vdCBpdHNcbiAgICAgICAgLy8gY29udGVudCBlbGVtZW50LCBzbyB0ZW1wb3JhcmlseSBjaGFuZ2UgdGhlIGNvbnRlbnQgZWxlbWVudC5cbiAgICAgICAgdmFyIHRlbXAgPSB0aGlzLmNvbnRlbnRFbF87XG5cbiAgICAgICAgdGhpcy5jb250ZW50RWxfID0gdGhpcy5lbF87XG4gICAgICAgIGNsb3NlID0gdGhpcy5hZGRDaGlsZCgnY2xvc2VCdXR0b24nLCB7IGNvbnRyb2xUZXh0OiAnQ2xvc2UgTW9kYWwgRGlhbG9nJyB9KTtcbiAgICAgICAgdGhpcy5jb250ZW50RWxfID0gdGVtcDtcbiAgICAgICAgdGhpcy5vbihjbG9zZSwgJ2Nsb3NlJywgdGhpcy5jbG9zZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIElmIHRoaXMgaXMgYmVpbmcgbWFkZSB1bmNsb3NlYWJsZSBhbmQgaGFzIGEgY2xvc2UgYnV0dG9uLCByZW1vdmUgaXQuXG4gICAgICBpZiAoIWNsb3NlYWJsZSAmJiBjbG9zZSkge1xuICAgICAgICB0aGlzLm9mZihjbG9zZSwgJ2Nsb3NlJywgdGhpcy5jbG9zZSk7XG4gICAgICAgIHRoaXMucmVtb3ZlQ2hpbGQoY2xvc2UpO1xuICAgICAgICBjbG9zZS5kaXNwb3NlKCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNsb3NlYWJsZV87XG4gIH07XG5cbiAgLyoqXG4gICAqIEZpbGwgdGhlIG1vZGFsJ3MgY29udGVudCBlbGVtZW50IHdpdGggdGhlIG1vZGFsJ3MgXCJjb250ZW50XCIgb3B0aW9uLlxuICAgKiBUaGUgY29udGVudCBlbGVtZW50IHdpbGwgYmUgZW1wdGllZCBiZWZvcmUgdGhpcyBjaGFuZ2UgdGFrZXMgcGxhY2UuXG4gICAqL1xuXG5cbiAgTW9kYWxEaWFsb2cucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiBmaWxsKCkge1xuICAgIHRoaXMuZmlsbFdpdGgodGhpcy5jb250ZW50KCkpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBGaWxsIHRoZSBtb2RhbCdzIGNvbnRlbnQgZWxlbWVudCB3aXRoIGFyYml0cmFyeSBjb250ZW50LlxuICAgKiBUaGUgY29udGVudCBlbGVtZW50IHdpbGwgYmUgZW1wdGllZCBiZWZvcmUgdGhpcyBjaGFuZ2UgdGFrZXMgcGxhY2UuXG4gICAqXG4gICAqIEBmaXJlcyBNb2RhbERpYWxvZyNiZWZvcmVtb2RhbGZpbGxcbiAgICogQGZpcmVzIE1vZGFsRGlhbG9nI21vZGFsZmlsbFxuICAgKlxuICAgKiBAcGFyYW0ge01peGVkfSBbY29udGVudF1cbiAgICogICAgICAgIFRoZSBzYW1lIHJ1bGVzIGFwcGx5IHRvIHRoaXMgYXMgYXBwbHkgdG8gdGhlIGBjb250ZW50YCBvcHRpb24uXG4gICAqL1xuXG5cbiAgTW9kYWxEaWFsb2cucHJvdG90eXBlLmZpbGxXaXRoID0gZnVuY3Rpb24gZmlsbFdpdGgoY29udGVudCkge1xuICAgIHZhciBjb250ZW50RWwgPSB0aGlzLmNvbnRlbnRFbCgpO1xuICAgIHZhciBwYXJlbnRFbCA9IGNvbnRlbnRFbC5wYXJlbnROb2RlO1xuICAgIHZhciBuZXh0U2libGluZ0VsID0gY29udGVudEVsLm5leHRTaWJsaW5nO1xuXG4gICAgLyoqXG4gICAgICogRmlyZWQganVzdCBiZWZvcmUgYSBgTW9kYWxEaWFsb2dgIGlzIGZpbGxlZCB3aXRoIGNvbnRlbnQuXG4gICAgICpcbiAgICAgKiBAZXZlbnQgTW9kYWxEaWFsb2cjYmVmb3JlbW9kYWxmaWxsXG4gICAgICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICAgICAqL1xuICAgIHRoaXMudHJpZ2dlcignYmVmb3JlbW9kYWxmaWxsJyk7XG4gICAgdGhpcy5oYXNCZWVuRmlsbGVkXyA9IHRydWU7XG5cbiAgICAvLyBEZXRhY2ggdGhlIGNvbnRlbnQgZWxlbWVudCBmcm9tIHRoZSBET00gYmVmb3JlIHBlcmZvcm1pbmdcbiAgICAvLyBtYW5pcHVsYXRpb24gdG8gYXZvaWQgbW9kaWZ5aW5nIHRoZSBsaXZlIERPTSBtdWx0aXBsZSB0aW1lcy5cbiAgICBwYXJlbnRFbC5yZW1vdmVDaGlsZChjb250ZW50RWwpO1xuICAgIHRoaXMuZW1wdHkoKTtcbiAgICBpbnNlcnRDb250ZW50KGNvbnRlbnRFbCwgY29udGVudCk7XG4gICAgLyoqXG4gICAgICogRmlyZWQganVzdCBhZnRlciBhIGBNb2RhbERpYWxvZ2AgaXMgZmlsbGVkIHdpdGggY29udGVudC5cbiAgICAgKlxuICAgICAqIEBldmVudCBNb2RhbERpYWxvZyNtb2RhbGZpbGxcbiAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gICAgICovXG4gICAgdGhpcy50cmlnZ2VyKCdtb2RhbGZpbGwnKTtcblxuICAgIC8vIFJlLWluamVjdCB0aGUgcmUtZmlsbGVkIGNvbnRlbnQgZWxlbWVudC5cbiAgICBpZiAobmV4dFNpYmxpbmdFbCkge1xuICAgICAgcGFyZW50RWwuaW5zZXJ0QmVmb3JlKGNvbnRlbnRFbCwgbmV4dFNpYmxpbmdFbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhcmVudEVsLmFwcGVuZENoaWxkKGNvbnRlbnRFbCk7XG4gICAgfVxuXG4gICAgLy8gbWFrZSBzdXJlIHRoYXQgdGhlIGNsb3NlIGJ1dHRvbiBpcyBsYXN0IGluIHRoZSBkaWFsb2cgRE9NXG4gICAgdmFyIGNsb3NlQnV0dG9uID0gdGhpcy5nZXRDaGlsZCgnY2xvc2VCdXR0b24nKTtcblxuICAgIGlmIChjbG9zZUJ1dHRvbikge1xuICAgICAgcGFyZW50RWwuYXBwZW5kQ2hpbGQoY2xvc2VCdXR0b24uZWxfKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEVtcHRpZXMgdGhlIGNvbnRlbnQgZWxlbWVudC4gVGhpcyBoYXBwZW5zIGFueXRpbWUgdGhlIG1vZGFsIGlzIGZpbGxlZC5cbiAgICpcbiAgICogQGZpcmVzIE1vZGFsRGlhbG9nI2JlZm9yZW1vZGFsZW1wdHlcbiAgICogQGZpcmVzIE1vZGFsRGlhbG9nI21vZGFsZW1wdHlcbiAgICovXG5cblxuICBNb2RhbERpYWxvZy5wcm90b3R5cGUuZW1wdHkgPSBmdW5jdGlvbiBlbXB0eSgpIHtcbiAgICAvKipcbiAgICAgKiBGaXJlZCBqdXN0IGJlZm9yZSBhIGBNb2RhbERpYWxvZ2AgaXMgZW1wdGllZC5cbiAgICAgKlxuICAgICAqIEBldmVudCBNb2RhbERpYWxvZyNiZWZvcmVtb2RhbGVtcHR5XG4gICAgICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICAgICAqL1xuICAgIHRoaXMudHJpZ2dlcignYmVmb3JlbW9kYWxlbXB0eScpO1xuICAgIGVtcHR5RWwodGhpcy5jb250ZW50RWwoKSk7XG5cbiAgICAvKipcbiAgICAgKiBGaXJlZCBqdXN0IGFmdGVyIGEgYE1vZGFsRGlhbG9nYCBpcyBlbXB0aWVkLlxuICAgICAqXG4gICAgICogQGV2ZW50IE1vZGFsRGlhbG9nI21vZGFsZW1wdHlcbiAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gICAgICovXG4gICAgdGhpcy50cmlnZ2VyKCdtb2RhbGVtcHR5Jyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldHMgb3Igc2V0cyB0aGUgbW9kYWwgY29udGVudCwgd2hpY2ggZ2V0cyBub3JtYWxpemVkIGJlZm9yZSBiZWluZ1xuICAgKiByZW5kZXJlZCBpbnRvIHRoZSBET00uXG4gICAqXG4gICAqIFRoaXMgZG9lcyBub3QgdXBkYXRlIHRoZSBET00gb3IgZmlsbCB0aGUgbW9kYWwsIGJ1dCBpdCBpcyBjYWxsZWQgZHVyaW5nXG4gICAqIHRoYXQgcHJvY2Vzcy5cbiAgICpcbiAgICogQHBhcmFtICB7TWl4ZWR9IFt2YWx1ZV1cbiAgICogICAgICAgICBJZiBkZWZpbmVkLCBzZXRzIHRoZSBpbnRlcm5hbCBjb250ZW50IHZhbHVlIHRvIGJlIHVzZWQgb24gdGhlXG4gICAqICAgICAgICAgbmV4dCBjYWxsKHMpIHRvIGBmaWxsYC4gVGhpcyB2YWx1ZSBpcyBub3JtYWxpemVkIGJlZm9yZSBiZWluZ1xuICAgKiAgICAgICAgIGluc2VydGVkLiBUbyBcImNsZWFyXCIgdGhlIGludGVybmFsIGNvbnRlbnQgdmFsdWUsIHBhc3MgYG51bGxgLlxuICAgKlxuICAgKiBAcmV0dXJuIHtNaXhlZH1cbiAgICogICAgICAgICBUaGUgY3VycmVudCBjb250ZW50IG9mIHRoZSBtb2RhbCBkaWFsb2dcbiAgICovXG5cblxuICBNb2RhbERpYWxvZy5wcm90b3R5cGUuY29udGVudCA9IGZ1bmN0aW9uIGNvbnRlbnQodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhpcy5jb250ZW50XyA9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jb250ZW50XztcbiAgfTtcblxuICAvKipcbiAgICogY29uZGl0aW9uYWxseSBmb2N1cyB0aGUgbW9kYWwgZGlhbG9nIGlmIGZvY3VzIHdhcyBwcmV2aW91c2x5IG9uIHRoZSBwbGF5ZXIuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgTW9kYWxEaWFsb2cucHJvdG90eXBlLmNvbmRpdGlvbmFsRm9jdXNfID0gZnVuY3Rpb24gY29uZGl0aW9uYWxGb2N1c18oKSB7XG4gICAgdmFyIGFjdGl2ZUVsID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcbiAgICB2YXIgcGxheWVyRWwgPSB0aGlzLnBsYXllcl8uZWxfO1xuXG4gICAgdGhpcy5wcmV2aW91c2x5QWN0aXZlRWxfID0gbnVsbDtcblxuICAgIGlmIChwbGF5ZXJFbC5jb250YWlucyhhY3RpdmVFbCkgfHwgcGxheWVyRWwgPT09IGFjdGl2ZUVsKSB7XG4gICAgICB0aGlzLnByZXZpb3VzbHlBY3RpdmVFbF8gPSBhY3RpdmVFbDtcblxuICAgICAgdGhpcy5mb2N1cygpO1xuXG4gICAgICB0aGlzLm9uKGRvY3VtZW50LCAna2V5ZG93bicsIHRoaXMuaGFuZGxlS2V5RG93bik7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBjb25kaXRpb25hbGx5IGJsdXIgdGhlIGVsZW1lbnQgYW5kIHJlZm9jdXMgdGhlIGxhc3QgZm9jdXNlZCBlbGVtZW50XG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgTW9kYWxEaWFsb2cucHJvdG90eXBlLmNvbmRpdGlvbmFsQmx1cl8gPSBmdW5jdGlvbiBjb25kaXRpb25hbEJsdXJfKCkge1xuICAgIGlmICh0aGlzLnByZXZpb3VzbHlBY3RpdmVFbF8pIHtcbiAgICAgIHRoaXMucHJldmlvdXNseUFjdGl2ZUVsXy5mb2N1cygpO1xuICAgICAgdGhpcy5wcmV2aW91c2x5QWN0aXZlRWxfID0gbnVsbDtcbiAgICB9XG5cbiAgICB0aGlzLm9mZihkb2N1bWVudCwgJ2tleWRvd24nLCB0aGlzLmhhbmRsZUtleURvd24pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBLZXlkb3duIGhhbmRsZXIuIEF0dGFjaGVkIHdoZW4gbW9kYWwgaXMgZm9jdXNlZC5cbiAgICpcbiAgICogQGxpc3RlbnMga2V5ZG93blxuICAgKi9cblxuXG4gIE1vZGFsRGlhbG9nLnByb3RvdHlwZS5oYW5kbGVLZXlEb3duID0gZnVuY3Rpb24gaGFuZGxlS2V5RG93bihldmVudCkge1xuICAgIC8vIGV4aXQgZWFybHkgaWYgaXQgaXNuJ3QgYSB0YWIga2V5XG4gICAgaWYgKGV2ZW50LndoaWNoICE9PSA5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGZvY3VzYWJsZUVscyA9IHRoaXMuZm9jdXNhYmxlRWxzXygpO1xuICAgIHZhciBhY3RpdmVFbCA9IHRoaXMuZWxfLnF1ZXJ5U2VsZWN0b3IoJzpmb2N1cycpO1xuICAgIHZhciBmb2N1c0luZGV4ID0gdm9pZCAwO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmb2N1c2FibGVFbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChhY3RpdmVFbCA9PT0gZm9jdXNhYmxlRWxzW2ldKSB7XG4gICAgICAgIGZvY3VzSW5kZXggPSBpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA9PT0gdGhpcy5lbF8pIHtcbiAgICAgIGZvY3VzSW5kZXggPSAwO1xuICAgIH1cblxuICAgIGlmIChldmVudC5zaGlmdEtleSAmJiBmb2N1c0luZGV4ID09PSAwKSB7XG4gICAgICBmb2N1c2FibGVFbHNbZm9jdXNhYmxlRWxzLmxlbmd0aCAtIDFdLmZvY3VzKCk7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH0gZWxzZSBpZiAoIWV2ZW50LnNoaWZ0S2V5ICYmIGZvY3VzSW5kZXggPT09IGZvY3VzYWJsZUVscy5sZW5ndGggLSAxKSB7XG4gICAgICBmb2N1c2FibGVFbHNbMF0uZm9jdXMoKTtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBnZXQgYWxsIGZvY3VzYWJsZSBlbGVtZW50c1xuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIE1vZGFsRGlhbG9nLnByb3RvdHlwZS5mb2N1c2FibGVFbHNfID0gZnVuY3Rpb24gZm9jdXNhYmxlRWxzXygpIHtcbiAgICB2YXIgYWxsQ2hpbGRyZW4gPSB0aGlzLmVsXy5xdWVyeVNlbGVjdG9yQWxsKCcqJyk7XG5cbiAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmZpbHRlci5jYWxsKGFsbENoaWxkcmVuLCBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgIHJldHVybiAoY2hpbGQgaW5zdGFuY2VvZiB3aW5kb3cuSFRNTEFuY2hvckVsZW1lbnQgfHwgY2hpbGQgaW5zdGFuY2VvZiB3aW5kb3cuSFRNTEFyZWFFbGVtZW50KSAmJiBjaGlsZC5oYXNBdHRyaWJ1dGUoJ2hyZWYnKSB8fCAoY2hpbGQgaW5zdGFuY2VvZiB3aW5kb3cuSFRNTElucHV0RWxlbWVudCB8fCBjaGlsZCBpbnN0YW5jZW9mIHdpbmRvdy5IVE1MU2VsZWN0RWxlbWVudCB8fCBjaGlsZCBpbnN0YW5jZW9mIHdpbmRvdy5IVE1MVGV4dEFyZWFFbGVtZW50IHx8IGNoaWxkIGluc3RhbmNlb2Ygd2luZG93LkhUTUxCdXR0b25FbGVtZW50KSAmJiAhY2hpbGQuaGFzQXR0cmlidXRlKCdkaXNhYmxlZCcpIHx8IGNoaWxkIGluc3RhbmNlb2Ygd2luZG93LkhUTUxJRnJhbWVFbGVtZW50IHx8IGNoaWxkIGluc3RhbmNlb2Ygd2luZG93LkhUTUxPYmplY3RFbGVtZW50IHx8IGNoaWxkIGluc3RhbmNlb2Ygd2luZG93LkhUTUxFbWJlZEVsZW1lbnQgfHwgY2hpbGQuaGFzQXR0cmlidXRlKCd0YWJpbmRleCcpICYmIGNoaWxkLmdldEF0dHJpYnV0ZSgndGFiaW5kZXgnKSAhPT0gLTEgfHwgY2hpbGQuaGFzQXR0cmlidXRlKCdjb250ZW50ZWRpdGFibGUnKTtcbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4gTW9kYWxEaWFsb2c7XG59KENvbXBvbmVudCk7XG5cbi8qKlxuICogRGVmYXVsdCBvcHRpb25zIGZvciBgTW9kYWxEaWFsb2dgIGRlZmF1bHQgb3B0aW9ucy5cbiAqXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQHByaXZhdGVcbiAqL1xuXG5cbk1vZGFsRGlhbG9nLnByb3RvdHlwZS5vcHRpb25zXyA9IHtcbiAgcGF1c2VPbk9wZW46IHRydWUsXG4gIHRlbXBvcmFyeTogdHJ1ZVxufTtcblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdNb2RhbERpYWxvZycsIE1vZGFsRGlhbG9nKTtcblxuLyoqXG4gKiBAZmlsZSB0cmFjay1saXN0LmpzXG4gKi9cbi8qKlxuICogQ29tbW9uIGZ1bmN0aW9uYWxpeSBiZXR3ZWVuIHtAbGluayBUZXh0VHJhY2tMaXN0fSwge0BsaW5rIEF1ZGlvVHJhY2tMaXN0fSwgYW5kXG4gKiB7QGxpbmsgVmlkZW9UcmFja0xpc3R9XG4gKlxuICogQGV4dGVuZHMgRXZlbnRUYXJnZXRcbiAqL1xuXG52YXIgVHJhY2tMaXN0ID0gZnVuY3Rpb24gKF9FdmVudFRhcmdldCkge1xuICBpbmhlcml0cyhUcmFja0xpc3QsIF9FdmVudFRhcmdldCk7XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzXG4gICAqXG4gICAqIEBwYXJhbSB7VHJhY2tbXX0gdHJhY2tzXG4gICAqICAgICAgICBBIGxpc3Qgb2YgdHJhY2tzIHRvIGluaXRpYWxpemUgdGhlIGxpc3Qgd2l0aC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtsaXN0XVxuICAgKiAgICAgICAgVGhlIGNoaWxkIG9iamVjdCB3aXRoIGluaGVyaXRhbmNlIGRvbmUgbWFudWFsbHkgZm9yIGllOC5cbiAgICpcbiAgICogQGFic3RyYWN0XG4gICAqL1xuICBmdW5jdGlvbiBUcmFja0xpc3QoKSB7XG4gICAgdmFyIHRyYWNrcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogW107XG5cbiAgICB2YXIgX3JldDtcblxuICAgIHZhciBsaXN0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBudWxsO1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFRyYWNrTGlzdCk7XG5cbiAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9FdmVudFRhcmdldC5jYWxsKHRoaXMpKTtcblxuICAgIGlmICghbGlzdCkge1xuICAgICAgbGlzdCA9IF90aGlzOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICBpZiAoSVNfSUU4KSB7XG4gICAgICAgIGxpc3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjdXN0b20nKTtcbiAgICAgICAgZm9yICh2YXIgcHJvcCBpbiBUcmFja0xpc3QucHJvdG90eXBlKSB7XG4gICAgICAgICAgaWYgKHByb3AgIT09ICdjb25zdHJ1Y3RvcicpIHtcbiAgICAgICAgICAgIGxpc3RbcHJvcF0gPSBUcmFja0xpc3QucHJvdG90eXBlW3Byb3BdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGxpc3QudHJhY2tzXyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlcm9mIFRyYWNrTGlzdFxuICAgICAqIEBtZW1iZXIge251bWJlcn0gbGVuZ3RoXG4gICAgICogICAgICAgICBUaGUgY3VycmVudCBudW1iZXIgb2YgYFRyYWNrYHMgaW4gdGhlIHRoaXMgVHJhY2tpc3QuXG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGxpc3QsICdsZW5ndGgnLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhY2tzXy5sZW5ndGg7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyYWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgbGlzdC5hZGRUcmFjayh0cmFja3NbaV0pO1xuICAgIH1cblxuICAgIC8vIG11c3QgcmV0dXJuIHRoZSBvYmplY3QsIGFzIGZvciBpZTggaXQgd2lsbCBub3QgYmUgdGhpc1xuICAgIC8vIGJ1dCBhIHJlZmVyZW5jZSB0byBhIGRvY3VtZW50IG9iamVjdFxuICAgIHJldHVybiBfcmV0ID0gbGlzdCwgcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcywgX3JldCk7XG4gIH1cblxuICAvKipcbiAgICogQWRkIGEge0BsaW5rIFRyYWNrfSB0byB0aGUgYFRyYWNrTGlzdGBcbiAgICpcbiAgICogQHBhcmFtIHtUcmFja30gdHJhY2tcbiAgICogICAgICAgIFRoZSBhdWRpbywgdmlkZW8sIG9yIHRleHQgdHJhY2sgdG8gYWRkIHRvIHRoZSBsaXN0LlxuICAgKlxuICAgKiBAZmlyZXMgVHJhY2tMaXN0I2FkZHRyYWNrXG4gICAqL1xuXG5cbiAgVHJhY2tMaXN0LnByb3RvdHlwZS5hZGRUcmFjayA9IGZ1bmN0aW9uIGFkZFRyYWNrKHRyYWNrKSB7XG4gICAgdmFyIGluZGV4ID0gdGhpcy50cmFja3NfLmxlbmd0aDtcblxuICAgIGlmICghKCcnICsgaW5kZXggaW4gdGhpcykpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBpbmRleCwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy50cmFja3NfW2luZGV4XTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gRG8gbm90IGFkZCBkdXBsaWNhdGUgdHJhY2tzXG4gICAgaWYgKHRoaXMudHJhY2tzXy5pbmRleE9mKHRyYWNrKSA9PT0gLTEpIHtcbiAgICAgIHRoaXMudHJhY2tzXy5wdXNoKHRyYWNrKTtcbiAgICAgIC8qKlxuICAgICAgICogVHJpZ2dlcmVkIHdoZW4gYSB0cmFjayBpcyBhZGRlZCB0byBhIHRyYWNrIGxpc3QuXG4gICAgICAgKlxuICAgICAgICogQGV2ZW50IFRyYWNrTGlzdCNhZGR0cmFja1xuICAgICAgICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICAgICAgICogQHByb3BlcnR5IHtUcmFja30gdHJhY2tcbiAgICAgICAqICAgICAgICAgICBBIHJlZmVyZW5jZSB0byB0cmFjayB0aGF0IHdhcyBhZGRlZC5cbiAgICAgICAqL1xuICAgICAgdGhpcy50cmlnZ2VyKHtcbiAgICAgICAgdHJhY2s6IHRyYWNrLFxuICAgICAgICB0eXBlOiAnYWRkdHJhY2snXG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhIHtAbGluayBUcmFja30gZnJvbSB0aGUgYFRyYWNrTGlzdGBcbiAgICpcbiAgICogQHBhcmFtIHtUcmFja30gcnRyYWNrXG4gICAqICAgICAgICBUaGUgYXVkaW8sIHZpZGVvLCBvciB0ZXh0IHRyYWNrIHRvIHJlbW92ZSBmcm9tIHRoZSBsaXN0LlxuICAgKlxuICAgKiBAZmlyZXMgVHJhY2tMaXN0I3JlbW92ZXRyYWNrXG4gICAqL1xuXG5cbiAgVHJhY2tMaXN0LnByb3RvdHlwZS5yZW1vdmVUcmFjayA9IGZ1bmN0aW9uIHJlbW92ZVRyYWNrKHJ0cmFjaykge1xuICAgIHZhciB0cmFjayA9IHZvaWQgMDtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGlmICh0aGlzW2ldID09PSBydHJhY2spIHtcbiAgICAgICAgdHJhY2sgPSB0aGlzW2ldO1xuICAgICAgICBpZiAodHJhY2sub2ZmKSB7XG4gICAgICAgICAgdHJhY2sub2ZmKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnRyYWNrc18uc3BsaWNlKGksIDEpO1xuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghdHJhY2spIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgd2hlbiBhIHRyYWNrIGlzIHJlbW92ZWQgZnJvbSB0cmFjayBsaXN0LlxuICAgICAqXG4gICAgICogQGV2ZW50IFRyYWNrTGlzdCNyZW1vdmV0cmFja1xuICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAgICAgKiBAcHJvcGVydHkge1RyYWNrfSB0cmFja1xuICAgICAqICAgICAgICAgICBBIHJlZmVyZW5jZSB0byB0cmFjayB0aGF0IHdhcyByZW1vdmVkLlxuICAgICAqL1xuICAgIHRoaXMudHJpZ2dlcih7XG4gICAgICB0cmFjazogdHJhY2ssXG4gICAgICB0eXBlOiAncmVtb3ZldHJhY2snXG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBhIFRyYWNrIGZyb20gdGhlIFRyYWNrTGlzdCBieSBhIHRyYWNrcyBpZFxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gaWQgLSB0aGUgaWQgb2YgdGhlIHRyYWNrIHRvIGdldFxuICAgKiBAbWV0aG9kIGdldFRyYWNrQnlJZFxuICAgKiBAcmV0dXJuIHtUcmFja31cbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBUcmFja0xpc3QucHJvdG90eXBlLmdldFRyYWNrQnlJZCA9IGZ1bmN0aW9uIGdldFRyYWNrQnlJZChpZCkge1xuICAgIHZhciByZXN1bHQgPSBudWxsO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIHRyYWNrID0gdGhpc1tpXTtcblxuICAgICAgaWYgKHRyYWNrLmlkID09PSBpZCkge1xuICAgICAgICByZXN1bHQgPSB0cmFjaztcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICByZXR1cm4gVHJhY2tMaXN0O1xufShFdmVudFRhcmdldCk7XG5cbi8qKlxuICogVHJpZ2dlcmVkIHdoZW4gYSBkaWZmZXJlbnQgdHJhY2sgaXMgc2VsZWN0ZWQvZW5hYmxlZC5cbiAqXG4gKiBAZXZlbnQgVHJhY2tMaXN0I2NoYW5nZVxuICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICovXG5cbi8qKlxuICogRXZlbnRzIHRoYXQgY2FuIGJlIGNhbGxlZCB3aXRoIG9uICsgZXZlbnROYW1lLiBTZWUge0BsaW5rIEV2ZW50SGFuZGxlcn0uXG4gKlxuICogQHByb3BlcnR5IHtPYmplY3R9IFRyYWNrTGlzdCNhbGxvd2VkRXZlbnRzX1xuICogQHByaXZhdGVcbiAqL1xuXG5cblRyYWNrTGlzdC5wcm90b3R5cGUuYWxsb3dlZEV2ZW50c18gPSB7XG4gIGNoYW5nZTogJ2NoYW5nZScsXG4gIGFkZHRyYWNrOiAnYWRkdHJhY2snLFxuICByZW1vdmV0cmFjazogJ3JlbW92ZXRyYWNrJ1xufTtcblxuLy8gZW11bGF0ZSBhdHRyaWJ1dGUgRXZlbnRIYW5kbGVyIHN1cHBvcnQgdG8gYWxsb3cgZm9yIGZlYXR1cmUgZGV0ZWN0aW9uXG5mb3IgKHZhciBldmVudCBpbiBUcmFja0xpc3QucHJvdG90eXBlLmFsbG93ZWRFdmVudHNfKSB7XG4gIFRyYWNrTGlzdC5wcm90b3R5cGVbJ29uJyArIGV2ZW50XSA9IG51bGw7XG59XG5cbi8qKlxuICogQGZpbGUgYXVkaW8tdHJhY2stbGlzdC5qc1xuICovXG4vKipcbiAqIEFueXdoZXJlIHdlIGNhbGwgdGhpcyBmdW5jdGlvbiB3ZSBkaXZlcmdlIGZyb20gdGhlIHNwZWNcbiAqIGFzIHdlIG9ubHkgc3VwcG9ydCBvbmUgZW5hYmxlZCBhdWRpb3RyYWNrIGF0IGEgdGltZVxuICpcbiAqIEBwYXJhbSB7QXVkaW9UcmFja0xpc3R9IGxpc3RcbiAqICAgICAgICBsaXN0IHRvIHdvcmsgb25cbiAqXG4gKiBAcGFyYW0ge0F1ZGlvVHJhY2t9IHRyYWNrXG4gKiAgICAgICAgVGhlIHRyYWNrIHRvIHNraXBcbiAqXG4gKiBAcHJpdmF0ZVxuICovXG52YXIgZGlzYWJsZU90aGVycyA9IGZ1bmN0aW9uIGRpc2FibGVPdGhlcnMobGlzdCwgdHJhY2spIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKCFPYmplY3Qua2V5cyhsaXN0W2ldKS5sZW5ndGggfHwgdHJhY2suaWQgPT09IGxpc3RbaV0uaWQpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICAvLyBhbm90aGVyIGF1ZGlvIHRyYWNrIGlzIGVuYWJsZWQsIGRpc2FibGUgaXRcbiAgICBsaXN0W2ldLmVuYWJsZWQgPSBmYWxzZTtcbiAgfVxufTtcblxuLyoqXG4gKiBUaGUgY3VycmVudCBsaXN0IG9mIHtAbGluayBBdWRpb1RyYWNrfSBmb3IgYSBtZWRpYSBmaWxlLlxuICpcbiAqIEBzZWUgW1NwZWNde0BsaW5rIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2VtYmVkZGVkLWNvbnRlbnQuaHRtbCNhdWRpb3RyYWNrbGlzdH1cbiAqIEBleHRlbmRzIFRyYWNrTGlzdFxuICovXG5cbnZhciBBdWRpb1RyYWNrTGlzdCA9IGZ1bmN0aW9uIChfVHJhY2tMaXN0KSB7XG4gIGluaGVyaXRzKEF1ZGlvVHJhY2tMaXN0LCBfVHJhY2tMaXN0KTtcblxuICAvKipcbiAgICogQ3JlYXRlIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7QXVkaW9UcmFja1tdfSBbdHJhY2tzPVtdXVxuICAgKiAgICAgICAgQSBsaXN0IG9mIGBBdWRpb1RyYWNrYCB0byBpbnN0YW50aWF0ZSB0aGUgbGlzdCB3aXRoLlxuICAgKi9cbiAgZnVuY3Rpb24gQXVkaW9UcmFja0xpc3QoKSB7XG4gICAgdmFyIF90aGlzLCBfcmV0O1xuXG4gICAgdmFyIHRyYWNrcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogW107XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgQXVkaW9UcmFja0xpc3QpO1xuXG4gICAgdmFyIGxpc3QgPSB2b2lkIDA7XG5cbiAgICAvLyBtYWtlIHN1cmUgb25seSAxIHRyYWNrIGlzIGVuYWJsZWRcbiAgICAvLyBzb3J0ZWQgZnJvbSBsYXN0IGluZGV4IHRvIGZpcnN0IGluZGV4XG4gICAgZm9yICh2YXIgaSA9IHRyYWNrcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgaWYgKHRyYWNrc1tpXS5lbmFibGVkKSB7XG4gICAgICAgIGRpc2FibGVPdGhlcnModHJhY2tzLCB0cmFja3NbaV0pO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJRTggZm9yY2VzIHVzIHRvIGltcGxlbWVudCBpbmhlcml0YW5jZSBvdXJzZWx2ZXNcbiAgICAvLyBhcyBpdCBkb2VzIG5vdCBzdXBwb3J0IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSBwcm9wZXJseVxuICAgIGlmIChJU19JRTgpIHtcbiAgICAgIGxpc3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjdXN0b20nKTtcbiAgICAgIGZvciAodmFyIHByb3AgaW4gVHJhY2tMaXN0LnByb3RvdHlwZSkge1xuICAgICAgICBpZiAocHJvcCAhPT0gJ2NvbnN0cnVjdG9yJykge1xuICAgICAgICAgIGxpc3RbcHJvcF0gPSBUcmFja0xpc3QucHJvdG90eXBlW3Byb3BdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBfcHJvcCBpbiBBdWRpb1RyYWNrTGlzdC5wcm90b3R5cGUpIHtcbiAgICAgICAgaWYgKF9wcm9wICE9PSAnY29uc3RydWN0b3InKSB7XG4gICAgICAgICAgbGlzdFtfcHJvcF0gPSBBdWRpb1RyYWNrTGlzdC5wcm90b3R5cGVbX3Byb3BdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGlzdCA9IChfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1RyYWNrTGlzdC5jYWxsKHRoaXMsIHRyYWNrcywgbGlzdCkpLCBfdGhpcyk7XG4gICAgbGlzdC5jaGFuZ2luZ18gPSBmYWxzZTtcblxuICAgIHJldHVybiBfcmV0ID0gbGlzdCwgcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcywgX3JldCk7XG4gIH1cblxuICAvKipcbiAgICogQWRkIGFuIHtAbGluayBBdWRpb1RyYWNrfSB0byB0aGUgYEF1ZGlvVHJhY2tMaXN0YC5cbiAgICpcbiAgICogQHBhcmFtIHtBdWRpb1RyYWNrfSB0cmFja1xuICAgKiAgICAgICAgVGhlIEF1ZGlvVHJhY2sgdG8gYWRkIHRvIHRoZSBsaXN0XG4gICAqXG4gICAqIEBmaXJlcyBUcmFja0xpc3QjYWRkdHJhY2tcbiAgICovXG5cblxuICBBdWRpb1RyYWNrTGlzdC5wcm90b3R5cGUuYWRkVHJhY2sgPSBmdW5jdGlvbiBhZGRUcmFjayh0cmFjaykge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgaWYgKHRyYWNrLmVuYWJsZWQpIHtcbiAgICAgIGRpc2FibGVPdGhlcnModGhpcywgdHJhY2spO1xuICAgIH1cblxuICAgIF9UcmFja0xpc3QucHJvdG90eXBlLmFkZFRyYWNrLmNhbGwodGhpcywgdHJhY2spO1xuICAgIC8vIG5hdGl2ZSB0cmFja3MgZG9uJ3QgaGF2ZSB0aGlzXG4gICAgaWYgKCF0cmFjay5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGxpc3RlbnMgQXVkaW9UcmFjayNlbmFibGVkY2hhbmdlXG4gICAgICogQGZpcmVzIFRyYWNrTGlzdCNjaGFuZ2VcbiAgICAgKi9cbiAgICB0cmFjay5hZGRFdmVudExpc3RlbmVyKCdlbmFibGVkY2hhbmdlJywgZnVuY3Rpb24gKCkge1xuICAgICAgLy8gd2hlbiB3ZSBhcmUgZGlzYWJsaW5nIG90aGVyIHRyYWNrcyAoc2luY2Ugd2UgZG9uJ3Qgc3VwcG9ydFxuICAgICAgLy8gbW9yZSB0aGFuIG9uZSB0cmFjayBhdCBhIHRpbWUpIHdlIHdpbGwgc2V0IGNoYW5naW5nX1xuICAgICAgLy8gdG8gdHJ1ZSBzbyB0aGF0IHdlIGRvbid0IHRyaWdnZXIgYWRkaXRpb25hbCBjaGFuZ2UgZXZlbnRzXG4gICAgICBpZiAoX3RoaXMyLmNoYW5naW5nXykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBfdGhpczIuY2hhbmdpbmdfID0gdHJ1ZTtcbiAgICAgIGRpc2FibGVPdGhlcnMoX3RoaXMyLCB0cmFjayk7XG4gICAgICBfdGhpczIuY2hhbmdpbmdfID0gZmFsc2U7XG4gICAgICBfdGhpczIudHJpZ2dlcignY2hhbmdlJyk7XG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIEF1ZGlvVHJhY2tMaXN0O1xufShUcmFja0xpc3QpO1xuXG4vKipcbiAqIEBmaWxlIHZpZGVvLXRyYWNrLWxpc3QuanNcbiAqL1xuLyoqXG4gKiBVbi1zZWxlY3QgYWxsIG90aGVyIHtAbGluayBWaWRlb1RyYWNrfXMgdGhhdCBhcmUgc2VsZWN0ZWQuXG4gKlxuICogQHBhcmFtIHtWaWRlb1RyYWNrTGlzdH0gbGlzdFxuICogICAgICAgIGxpc3QgdG8gd29yayBvblxuICpcbiAqIEBwYXJhbSB7VmlkZW9UcmFja30gdHJhY2tcbiAqICAgICAgICBUaGUgdHJhY2sgdG8gc2tpcFxuICpcbiAqIEBwcml2YXRlXG4gKi9cbnZhciBkaXNhYmxlT3RoZXJzJDEgPSBmdW5jdGlvbiBkaXNhYmxlT3RoZXJzKGxpc3QsIHRyYWNrKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIGlmICghT2JqZWN0LmtleXMobGlzdFtpXSkubGVuZ3RoIHx8IHRyYWNrLmlkID09PSBsaXN0W2ldLmlkKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgLy8gYW5vdGhlciB2aWRlbyB0cmFjayBpcyBlbmFibGVkLCBkaXNhYmxlIGl0XG4gICAgbGlzdFtpXS5zZWxlY3RlZCA9IGZhbHNlO1xuICB9XG59O1xuXG4vKipcbiAqIFRoZSBjdXJyZW50IGxpc3Qgb2Yge0BsaW5rIFZpZGVvVHJhY2t9IGZvciBhIHZpZGVvLlxuICpcbiAqIEBzZWUgW1NwZWNde0BsaW5rIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2VtYmVkZGVkLWNvbnRlbnQuaHRtbCN2aWRlb3RyYWNrbGlzdH1cbiAqIEBleHRlbmRzIFRyYWNrTGlzdFxuICovXG5cbnZhciBWaWRlb1RyYWNrTGlzdCA9IGZ1bmN0aW9uIChfVHJhY2tMaXN0KSB7XG4gIGluaGVyaXRzKFZpZGVvVHJhY2tMaXN0LCBfVHJhY2tMaXN0KTtcblxuICAvKipcbiAgICogQ3JlYXRlIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7VmlkZW9UcmFja1tdfSBbdHJhY2tzPVtdXVxuICAgKiAgICAgICAgQSBsaXN0IG9mIGBWaWRlb1RyYWNrYCB0byBpbnN0YW50aWF0ZSB0aGUgbGlzdCB3aXRoLlxuICAgKi9cbiAgZnVuY3Rpb24gVmlkZW9UcmFja0xpc3QoKSB7XG4gICAgdmFyIF90aGlzLCBfcmV0O1xuXG4gICAgdmFyIHRyYWNrcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogW107XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgVmlkZW9UcmFja0xpc3QpO1xuXG4gICAgdmFyIGxpc3QgPSB2b2lkIDA7XG5cbiAgICAvLyBtYWtlIHN1cmUgb25seSAxIHRyYWNrIGlzIGVuYWJsZWRcbiAgICAvLyBzb3J0ZWQgZnJvbSBsYXN0IGluZGV4IHRvIGZpcnN0IGluZGV4XG4gICAgZm9yICh2YXIgaSA9IHRyYWNrcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgaWYgKHRyYWNrc1tpXS5zZWxlY3RlZCkge1xuICAgICAgICBkaXNhYmxlT3RoZXJzJDEodHJhY2tzLCB0cmFja3NbaV0pO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJRTggZm9yY2VzIHVzIHRvIGltcGxlbWVudCBpbmhlcml0YW5jZSBvdXJzZWx2ZXNcbiAgICAvLyBhcyBpdCBkb2VzIG5vdCBzdXBwb3J0IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSBwcm9wZXJseVxuICAgIGlmIChJU19JRTgpIHtcbiAgICAgIGxpc3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjdXN0b20nKTtcbiAgICAgIGZvciAodmFyIHByb3AgaW4gVHJhY2tMaXN0LnByb3RvdHlwZSkge1xuICAgICAgICBpZiAocHJvcCAhPT0gJ2NvbnN0cnVjdG9yJykge1xuICAgICAgICAgIGxpc3RbcHJvcF0gPSBUcmFja0xpc3QucHJvdG90eXBlW3Byb3BdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBfcHJvcCBpbiBWaWRlb1RyYWNrTGlzdC5wcm90b3R5cGUpIHtcbiAgICAgICAgaWYgKF9wcm9wICE9PSAnY29uc3RydWN0b3InKSB7XG4gICAgICAgICAgbGlzdFtfcHJvcF0gPSBWaWRlb1RyYWNrTGlzdC5wcm90b3R5cGVbX3Byb3BdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGlzdCA9IChfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1RyYWNrTGlzdC5jYWxsKHRoaXMsIHRyYWNrcywgbGlzdCkpLCBfdGhpcyk7XG4gICAgbGlzdC5jaGFuZ2luZ18gPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge251bWJlcn0gVmlkZW9UcmFja0xpc3Qjc2VsZWN0ZWRJbmRleFxuICAgICAqICAgICAgICAgVGhlIGN1cnJlbnQgaW5kZXggb2YgdGhlIHNlbGVjdGVkIHtAbGluayBWaWRlb1RyYWNrYH0uXG4gICAgICovXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGxpc3QsICdzZWxlY3RlZEluZGV4Jywge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCB0aGlzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgIGlmICh0aGlzW19pXS5zZWxlY3RlZCkge1xuICAgICAgICAgICAgcmV0dXJuIF9pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQkJDEoKSB7fVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIF9yZXQgPSBsaXN0LCBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKF90aGlzLCBfcmV0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgYSB7QGxpbmsgVmlkZW9UcmFja30gdG8gdGhlIGBWaWRlb1RyYWNrTGlzdGAuXG4gICAqXG4gICAqIEBwYXJhbSB7VmlkZW9UcmFja30gdHJhY2tcbiAgICogICAgICAgIFRoZSBWaWRlb1RyYWNrIHRvIGFkZCB0byB0aGUgbGlzdFxuICAgKlxuICAgKiBAZmlyZXMgVHJhY2tMaXN0I2FkZHRyYWNrXG4gICAqL1xuXG5cbiAgVmlkZW9UcmFja0xpc3QucHJvdG90eXBlLmFkZFRyYWNrID0gZnVuY3Rpb24gYWRkVHJhY2sodHJhY2spIHtcbiAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgIGlmICh0cmFjay5zZWxlY3RlZCkge1xuICAgICAgZGlzYWJsZU90aGVycyQxKHRoaXMsIHRyYWNrKTtcbiAgICB9XG5cbiAgICBfVHJhY2tMaXN0LnByb3RvdHlwZS5hZGRUcmFjay5jYWxsKHRoaXMsIHRyYWNrKTtcbiAgICAvLyBuYXRpdmUgdHJhY2tzIGRvbid0IGhhdmUgdGhpc1xuICAgIGlmICghdHJhY2suYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBsaXN0ZW5zIFZpZGVvVHJhY2sjc2VsZWN0ZWRjaGFuZ2VcbiAgICAgKiBAZmlyZXMgVHJhY2tMaXN0I2NoYW5nZVxuICAgICAqL1xuICAgIHRyYWNrLmFkZEV2ZW50TGlzdGVuZXIoJ3NlbGVjdGVkY2hhbmdlJywgZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKF90aGlzMi5jaGFuZ2luZ18pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgX3RoaXMyLmNoYW5naW5nXyA9IHRydWU7XG4gICAgICBkaXNhYmxlT3RoZXJzJDEoX3RoaXMyLCB0cmFjayk7XG4gICAgICBfdGhpczIuY2hhbmdpbmdfID0gZmFsc2U7XG4gICAgICBfdGhpczIudHJpZ2dlcignY2hhbmdlJyk7XG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIFZpZGVvVHJhY2tMaXN0O1xufShUcmFja0xpc3QpO1xuXG4vKipcbiAqIEBmaWxlIHRleHQtdHJhY2stbGlzdC5qc1xuICovXG4vKipcbiAqIFRoZSBjdXJyZW50IGxpc3Qgb2Yge0BsaW5rIFRleHRUcmFja30gZm9yIGEgbWVkaWEgZmlsZS5cbiAqXG4gKiBAc2VlIFtTcGVjXXtAbGluayBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9lbWJlZGRlZC1jb250ZW50Lmh0bWwjdGV4dHRyYWNrbGlzdH1cbiAqIEBleHRlbmRzIFRyYWNrTGlzdFxuICovXG5cbnZhciBUZXh0VHJhY2tMaXN0ID0gZnVuY3Rpb24gKF9UcmFja0xpc3QpIHtcbiAgaW5oZXJpdHMoVGV4dFRyYWNrTGlzdCwgX1RyYWNrTGlzdCk7XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge1RleHRUcmFja1tdfSBbdHJhY2tzPVtdXVxuICAgKiAgICAgICAgQSBsaXN0IG9mIGBUZXh0VHJhY2tgIHRvIGluc3RhbnRpYXRlIHRoZSBsaXN0IHdpdGguXG4gICAqL1xuICBmdW5jdGlvbiBUZXh0VHJhY2tMaXN0KCkge1xuICAgIHZhciBfdGhpcywgX3JldDtcblxuICAgIHZhciB0cmFja3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IFtdO1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFRleHRUcmFja0xpc3QpO1xuXG4gICAgdmFyIGxpc3QgPSB2b2lkIDA7XG5cbiAgICAvLyBJRTggZm9yY2VzIHVzIHRvIGltcGxlbWVudCBpbmhlcml0YW5jZSBvdXJzZWx2ZXNcbiAgICAvLyBhcyBpdCBkb2VzIG5vdCBzdXBwb3J0IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSBwcm9wZXJseVxuICAgIGlmIChJU19JRTgpIHtcbiAgICAgIGxpc3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjdXN0b20nKTtcbiAgICAgIGZvciAodmFyIHByb3AgaW4gVHJhY2tMaXN0LnByb3RvdHlwZSkge1xuICAgICAgICBpZiAocHJvcCAhPT0gJ2NvbnN0cnVjdG9yJykge1xuICAgICAgICAgIGxpc3RbcHJvcF0gPSBUcmFja0xpc3QucHJvdG90eXBlW3Byb3BdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBfcHJvcCBpbiBUZXh0VHJhY2tMaXN0LnByb3RvdHlwZSkge1xuICAgICAgICBpZiAoX3Byb3AgIT09ICdjb25zdHJ1Y3RvcicpIHtcbiAgICAgICAgICBsaXN0W19wcm9wXSA9IFRleHRUcmFja0xpc3QucHJvdG90eXBlW19wcm9wXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGxpc3QgPSAoX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9UcmFja0xpc3QuY2FsbCh0aGlzLCB0cmFja3MsIGxpc3QpKSwgX3RoaXMpO1xuICAgIHJldHVybiBfcmV0ID0gbGlzdCwgcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcywgX3JldCk7XG4gIH1cblxuICAvKipcbiAgICogQWRkIGEge0BsaW5rIFRleHRUcmFja30gdG8gdGhlIGBUZXh0VHJhY2tMaXN0YFxuICAgKlxuICAgKiBAcGFyYW0ge1RleHRUcmFja30gdHJhY2tcbiAgICogICAgICAgIFRoZSB0ZXh0IHRyYWNrIHRvIGFkZCB0byB0aGUgbGlzdC5cbiAgICpcbiAgICogQGZpcmVzIFRyYWNrTGlzdCNhZGR0cmFja1xuICAgKi9cblxuXG4gIFRleHRUcmFja0xpc3QucHJvdG90eXBlLmFkZFRyYWNrID0gZnVuY3Rpb24gYWRkVHJhY2sodHJhY2spIHtcbiAgICBfVHJhY2tMaXN0LnByb3RvdHlwZS5hZGRUcmFjay5jYWxsKHRoaXMsIHRyYWNrKTtcblxuICAgIC8qKlxuICAgICAqIEBsaXN0ZW5zIFRleHRUcmFjayNtb2RlY2hhbmdlXG4gICAgICogQGZpcmVzIFRyYWNrTGlzdCNjaGFuZ2VcbiAgICAgKi9cbiAgICB0cmFjay5hZGRFdmVudExpc3RlbmVyKCdtb2RlY2hhbmdlJywgYmluZCh0aGlzLCBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLnRyaWdnZXIoJ2NoYW5nZScpO1xuICAgIH0pKTtcblxuICAgIHZhciBub25MYW5ndWFnZVRleHRUcmFja0tpbmQgPSBbJ21ldGFkYXRhJywgJ2NoYXB0ZXJzJ107XG5cbiAgICBpZiAobm9uTGFuZ3VhZ2VUZXh0VHJhY2tLaW5kLmluZGV4T2YodHJhY2sua2luZCkgPT09IC0xKSB7XG4gICAgICB0cmFjay5hZGRFdmVudExpc3RlbmVyKCdtb2RlY2hhbmdlJywgYmluZCh0aGlzLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudHJpZ2dlcignc2VsZWN0ZWRsYW5ndWFnZWNoYW5nZScpO1xuICAgICAgfSkpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gVGV4dFRyYWNrTGlzdDtcbn0oVHJhY2tMaXN0KTtcblxuLyoqXG4gKiBAZmlsZSBodG1sLXRyYWNrLWVsZW1lbnQtbGlzdC5qc1xuICovXG5cbi8qKlxuICogVGhlIGN1cnJlbnQgbGlzdCBvZiB7QGxpbmsgSHRtbFRyYWNrRWxlbWVudH1zLlxuICovXG5cbnZhciBIdG1sVHJhY2tFbGVtZW50TGlzdCA9IGZ1bmN0aW9uICgpIHtcblxuICAvKipcbiAgICogQ3JlYXRlIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7SHRtbFRyYWNrRWxlbWVudFtdfSBbdHJhY2tzPVtdXVxuICAgKiAgICAgICAgQSBsaXN0IG9mIGBIdG1sVHJhY2tFbGVtZW50YCB0byBpbnN0YW50aWF0ZSB0aGUgbGlzdCB3aXRoLlxuICAgKi9cbiAgZnVuY3Rpb24gSHRtbFRyYWNrRWxlbWVudExpc3QoKSB7XG4gICAgdmFyIHRyYWNrRWxlbWVudHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IFtdO1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIEh0bWxUcmFja0VsZW1lbnRMaXN0KTtcblxuICAgIHZhciBsaXN0ID0gdGhpczsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG4gICAgaWYgKElTX0lFOCkge1xuICAgICAgbGlzdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2N1c3RvbScpO1xuXG4gICAgICBmb3IgKHZhciBwcm9wIGluIEh0bWxUcmFja0VsZW1lbnRMaXN0LnByb3RvdHlwZSkge1xuICAgICAgICBpZiAocHJvcCAhPT0gJ2NvbnN0cnVjdG9yJykge1xuICAgICAgICAgIGxpc3RbcHJvcF0gPSBIdG1sVHJhY2tFbGVtZW50TGlzdC5wcm90b3R5cGVbcHJvcF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBsaXN0LnRyYWNrRWxlbWVudHNfID0gW107XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyb2YgSHRtbFRyYWNrRWxlbWVudExpc3RcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9IGxlbmd0aFxuICAgICAqICAgICAgICAgVGhlIGN1cnJlbnQgbnVtYmVyIG9mIGBUcmFja2BzIGluIHRoZSB0aGlzIFRyYWNraXN0LlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShsaXN0LCAnbGVuZ3RoJywge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYWNrRWxlbWVudHNfLmxlbmd0aDtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSB0cmFja0VsZW1lbnRzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBsaXN0LmFkZFRyYWNrRWxlbWVudF8odHJhY2tFbGVtZW50c1tpXSk7XG4gICAgfVxuXG4gICAgaWYgKElTX0lFOCkge1xuICAgICAgcmV0dXJuIGxpc3Q7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhbiB7QGxpbmsgSHRtbFRyYWNrRWxlbWVudH0gdG8gdGhlIGBIdG1sVHJhY2tFbGVtZW50TGlzdGBcbiAgICpcbiAgICogQHBhcmFtIHtIdG1sVHJhY2tFbGVtZW50fSB0cmFja0VsZW1lbnRcbiAgICogICAgICAgIFRoZSB0cmFjayBlbGVtZW50IHRvIGFkZCB0byB0aGUgbGlzdC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBIdG1sVHJhY2tFbGVtZW50TGlzdC5wcm90b3R5cGUuYWRkVHJhY2tFbGVtZW50XyA9IGZ1bmN0aW9uIGFkZFRyYWNrRWxlbWVudF8odHJhY2tFbGVtZW50KSB7XG4gICAgdmFyIGluZGV4ID0gdGhpcy50cmFja0VsZW1lbnRzXy5sZW5ndGg7XG5cbiAgICBpZiAoISgnJyArIGluZGV4IGluIHRoaXMpKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgaW5kZXgsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudHJhY2tFbGVtZW50c19baW5kZXhdO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBEbyBub3QgYWRkIGR1cGxpY2F0ZSBlbGVtZW50c1xuICAgIGlmICh0aGlzLnRyYWNrRWxlbWVudHNfLmluZGV4T2YodHJhY2tFbGVtZW50KSA9PT0gLTEpIHtcbiAgICAgIHRoaXMudHJhY2tFbGVtZW50c18ucHVzaCh0cmFja0VsZW1lbnQpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogR2V0IGFuIHtAbGluayBIdG1sVHJhY2tFbGVtZW50fSBmcm9tIHRoZSBgSHRtbFRyYWNrRWxlbWVudExpc3RgIGdpdmVuIGFuXG4gICAqIHtAbGluayBUZXh0VHJhY2t9LlxuICAgKlxuICAgKiBAcGFyYW0ge1RleHRUcmFja30gdHJhY2tcbiAgICogICAgICAgIFRoZSB0cmFjayBhc3NvY2lhdGVkIHdpdGggYSB0cmFjayBlbGVtZW50LlxuICAgKlxuICAgKiBAcmV0dXJuIHtIdG1sVHJhY2tFbGVtZW50fHVuZGVmaW5lZH1cbiAgICogICAgICAgICBUaGUgdHJhY2sgZWxlbWVudCB0aGF0IHdhcyBmb3VuZCBvciB1bmRlZmluZWQuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgSHRtbFRyYWNrRWxlbWVudExpc3QucHJvdG90eXBlLmdldFRyYWNrRWxlbWVudEJ5VHJhY2tfID0gZnVuY3Rpb24gZ2V0VHJhY2tFbGVtZW50QnlUcmFja18odHJhY2spIHtcbiAgICB2YXIgdHJhY2tFbGVtZW50XyA9IHZvaWQgMDtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSB0aGlzLnRyYWNrRWxlbWVudHNfLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAodHJhY2sgPT09IHRoaXMudHJhY2tFbGVtZW50c19baV0udHJhY2spIHtcbiAgICAgICAgdHJhY2tFbGVtZW50XyA9IHRoaXMudHJhY2tFbGVtZW50c19baV07XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRyYWNrRWxlbWVudF87XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhIHtAbGluayBIdG1sVHJhY2tFbGVtZW50fSBmcm9tIHRoZSBgSHRtbFRyYWNrRWxlbWVudExpc3RgXG4gICAqXG4gICAqIEBwYXJhbSB7SHRtbFRyYWNrRWxlbWVudH0gdHJhY2tFbGVtZW50XG4gICAqICAgICAgICBUaGUgdHJhY2sgZWxlbWVudCB0byByZW1vdmUgZnJvbSB0aGUgbGlzdC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBIdG1sVHJhY2tFbGVtZW50TGlzdC5wcm90b3R5cGUucmVtb3ZlVHJhY2tFbGVtZW50XyA9IGZ1bmN0aW9uIHJlbW92ZVRyYWNrRWxlbWVudF8odHJhY2tFbGVtZW50KSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHRoaXMudHJhY2tFbGVtZW50c18ubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh0cmFja0VsZW1lbnQgPT09IHRoaXMudHJhY2tFbGVtZW50c19baV0pIHtcbiAgICAgICAgdGhpcy50cmFja0VsZW1lbnRzXy5zcGxpY2UoaSwgMSk7XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBIdG1sVHJhY2tFbGVtZW50TGlzdDtcbn0oKTtcblxuLyoqXG4gKiBAZmlsZSB0ZXh0LXRyYWNrLWN1ZS1saXN0LmpzXG4gKi9cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gVGV4dFRyYWNrQ3VlTGlzdH5UZXh0VHJhY2tDdWVcbiAqXG4gKiBAcHJvcGVydHkge3N0cmluZ30gaWRcbiAqICAgICAgICAgICBUaGUgdW5pcXVlIGlkIGZvciB0aGlzIHRleHQgdHJhY2sgY3VlXG4gKlxuICogQHByb3BlcnR5IHtudW1iZXJ9IHN0YXJ0VGltZVxuICogICAgICAgICAgIFRoZSBzdGFydCB0aW1lIGZvciB0aGlzIHRleHQgdHJhY2sgY3VlXG4gKlxuICogQHByb3BlcnR5IHtudW1iZXJ9IGVuZFRpbWVcbiAqICAgICAgICAgICBUaGUgZW5kIHRpbWUgZm9yIHRoaXMgdGV4dCB0cmFjayBjdWVcbiAqXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IHBhdXNlT25FeGl0XG4gKiAgICAgICAgICAgUGF1c2Ugd2hlbiB0aGUgZW5kIHRpbWUgaXMgcmVhY2hlZCBpZiB0cnVlLlxuICpcbiAqIEBzZWUgW1NwZWNde0BsaW5rIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2VtYmVkZGVkLWNvbnRlbnQuaHRtbCN0ZXh0dHJhY2tjdWV9XG4gKi9cblxuLyoqXG4gKiBBIExpc3Qgb2YgVGV4dFRyYWNrQ3Vlcy5cbiAqXG4gKiBAc2VlIFtTcGVjXXtAbGluayBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9lbWJlZGRlZC1jb250ZW50Lmh0bWwjdGV4dHRyYWNrY3VlbGlzdH1cbiAqL1xuXG52YXIgVGV4dFRyYWNrQ3VlTGlzdCA9IGZ1bmN0aW9uICgpIHtcblxuICAvKipcbiAgICogQ3JlYXRlIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fSBjdWVzXG4gICAqICAgICAgICBBIGxpc3Qgb2YgY3VlcyB0byBiZSBpbml0aWFsaXplZCB3aXRoXG4gICAqL1xuICBmdW5jdGlvbiBUZXh0VHJhY2tDdWVMaXN0KGN1ZXMpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBUZXh0VHJhY2tDdWVMaXN0KTtcblxuICAgIHZhciBsaXN0ID0gdGhpczsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG4gICAgaWYgKElTX0lFOCkge1xuICAgICAgbGlzdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2N1c3RvbScpO1xuXG4gICAgICBmb3IgKHZhciBwcm9wIGluIFRleHRUcmFja0N1ZUxpc3QucHJvdG90eXBlKSB7XG4gICAgICAgIGlmIChwcm9wICE9PSAnY29uc3RydWN0b3InKSB7XG4gICAgICAgICAgbGlzdFtwcm9wXSA9IFRleHRUcmFja0N1ZUxpc3QucHJvdG90eXBlW3Byb3BdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgVGV4dFRyYWNrQ3VlTGlzdC5wcm90b3R5cGUuc2V0Q3Vlc18uY2FsbChsaXN0LCBjdWVzKTtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJvZiBUZXh0VHJhY2tDdWVMaXN0XG4gICAgICogQG1lbWJlciB7bnVtYmVyfSBsZW5ndGhcbiAgICAgKiAgICAgICAgIFRoZSBjdXJyZW50IG51bWJlciBvZiBgVGV4dFRyYWNrQ3VlYHMgaW4gdGhlIFRleHRUcmFja0N1ZUxpc3QuXG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGxpc3QsICdsZW5ndGgnLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGVuZ3RoXztcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmIChJU19JRTgpIHtcbiAgICAgIHJldHVybiBsaXN0O1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBIHNldHRlciBmb3IgY3VlcyBpbiB0aGlzIGxpc3QuIENyZWF0ZXMgZ2V0dGVyc1xuICAgKiBhbiBhbiBpbmRleCBmb3IgdGhlIGN1ZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXl9IGN1ZXNcbiAgICogICAgICAgIEFuIGFycmF5IG9mIGN1ZXMgdG8gc2V0XG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgVGV4dFRyYWNrQ3VlTGlzdC5wcm90b3R5cGUuc2V0Q3Vlc18gPSBmdW5jdGlvbiBzZXRDdWVzXyhjdWVzKSB7XG4gICAgdmFyIG9sZExlbmd0aCA9IHRoaXMubGVuZ3RoIHx8IDA7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBsID0gY3Vlcy5sZW5ndGg7XG5cbiAgICB0aGlzLmN1ZXNfID0gY3VlcztcbiAgICB0aGlzLmxlbmd0aF8gPSBjdWVzLmxlbmd0aDtcblxuICAgIHZhciBkZWZpbmVQcm9wID0gZnVuY3Rpb24gZGVmaW5lUHJvcChpbmRleCkge1xuICAgICAgaWYgKCEoJycgKyBpbmRleCBpbiB0aGlzKSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJycgKyBpbmRleCwge1xuICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3Vlc19baW5kZXhdO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGlmIChvbGRMZW5ndGggPCBsKSB7XG4gICAgICBpID0gb2xkTGVuZ3RoO1xuXG4gICAgICBmb3IgKDsgaSA8IGw7IGkrKykge1xuICAgICAgICBkZWZpbmVQcm9wLmNhbGwodGhpcywgaSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgYSBgVGV4dFRyYWNrQ3VlYCB0aGF0IGlzIGN1cnJlbnRseSBpbiB0aGUgYFRleHRUcmFja0N1ZUxpc3RgIGJ5IGlkLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaWRcbiAgICogICAgICAgIFRoZSBpZCBvZiB0aGUgY3VlIHRoYXQgc2hvdWxkIGJlIHNlYXJjaGVkIGZvci5cbiAgICpcbiAgICogQHJldHVybiB7VGV4dFRyYWNrQ3VlTGlzdH5UZXh0VHJhY2tDdWV8bnVsbH1cbiAgICogICAgICAgICBBIHNpbmdsZSBjdWUgb3IgbnVsbCBpZiBub25lIHdhcyBmb3VuZC5cbiAgICovXG5cblxuICBUZXh0VHJhY2tDdWVMaXN0LnByb3RvdHlwZS5nZXRDdWVCeUlkID0gZnVuY3Rpb24gZ2V0Q3VlQnlJZChpZCkge1xuICAgIHZhciByZXN1bHQgPSBudWxsO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGN1ZSA9IHRoaXNbaV07XG5cbiAgICAgIGlmIChjdWUuaWQgPT09IGlkKSB7XG4gICAgICAgIHJlc3VsdCA9IGN1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICByZXR1cm4gVGV4dFRyYWNrQ3VlTGlzdDtcbn0oKTtcblxuLyoqXG4gKiBAZmlsZSB0cmFjay1raW5kcy5qc1xuICovXG5cbi8qKlxuICogQWxsIHBvc3NpYmxlIGBWaWRlb1RyYWNrS2luZGBzXG4gKlxuICogQHNlZSBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9lbWJlZGRlZC1jb250ZW50Lmh0bWwjZG9tLXZpZGVvdHJhY2sta2luZFxuICogQHR5cGVkZWYgVmlkZW9UcmFja35LaW5kXG4gKiBAZW51bVxuICovXG52YXIgVmlkZW9UcmFja0tpbmQgPSB7XG4gIGFsdGVybmF0aXZlOiAnYWx0ZXJuYXRpdmUnLFxuICBjYXB0aW9uczogJ2NhcHRpb25zJyxcbiAgbWFpbjogJ21haW4nLFxuICBzaWduOiAnc2lnbicsXG4gIHN1YnRpdGxlczogJ3N1YnRpdGxlcycsXG4gIGNvbW1lbnRhcnk6ICdjb21tZW50YXJ5J1xufTtcblxuLyoqXG4gKiBBbGwgcG9zc2libGUgYEF1ZGlvVHJhY2tLaW5kYHNcbiAqXG4gKiBAc2VlIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2VtYmVkZGVkLWNvbnRlbnQuaHRtbCNkb20tYXVkaW90cmFjay1raW5kXG4gKiBAdHlwZWRlZiBBdWRpb1RyYWNrfktpbmRcbiAqIEBlbnVtXG4gKi9cbnZhciBBdWRpb1RyYWNrS2luZCA9IHtcbiAgJ2FsdGVybmF0aXZlJzogJ2FsdGVybmF0aXZlJyxcbiAgJ2Rlc2NyaXB0aW9ucyc6ICdkZXNjcmlwdGlvbnMnLFxuICAnbWFpbic6ICdtYWluJyxcbiAgJ21haW4tZGVzYyc6ICdtYWluLWRlc2MnLFxuICAndHJhbnNsYXRpb24nOiAndHJhbnNsYXRpb24nLFxuICAnY29tbWVudGFyeSc6ICdjb21tZW50YXJ5J1xufTtcblxuLyoqXG4gKiBBbGwgcG9zc2libGUgYFRleHRUcmFja0tpbmRgc1xuICpcbiAqIEBzZWUgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZW1iZWRkZWQtY29udGVudC5odG1sI2RvbS10ZXh0dHJhY2sta2luZFxuICogQHR5cGVkZWYgVGV4dFRyYWNrfktpbmRcbiAqIEBlbnVtXG4gKi9cbnZhciBUZXh0VHJhY2tLaW5kID0ge1xuICBzdWJ0aXRsZXM6ICdzdWJ0aXRsZXMnLFxuICBjYXB0aW9uczogJ2NhcHRpb25zJyxcbiAgZGVzY3JpcHRpb25zOiAnZGVzY3JpcHRpb25zJyxcbiAgY2hhcHRlcnM6ICdjaGFwdGVycycsXG4gIG1ldGFkYXRhOiAnbWV0YWRhdGEnXG59O1xuXG4vKipcbiAqIEFsbCBwb3NzaWJsZSBgVGV4dFRyYWNrTW9kZWBzXG4gKlxuICogQHNlZSBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9lbWJlZGRlZC1jb250ZW50Lmh0bWwjdGV4dHRyYWNrbW9kZVxuICogQHR5cGVkZWYgVGV4dFRyYWNrfk1vZGVcbiAqIEBlbnVtXG4gKi9cbnZhciBUZXh0VHJhY2tNb2RlID0ge1xuICBkaXNhYmxlZDogJ2Rpc2FibGVkJyxcbiAgaGlkZGVuOiAnaGlkZGVuJyxcbiAgc2hvd2luZzogJ3Nob3dpbmcnXG59O1xuXG4vKipcbiAqIEBmaWxlIHRyYWNrLmpzXG4gKi9cbi8qKlxuICogQSBUcmFjayBjbGFzcyB0aGF0IGNvbnRhaW5zIGFsbCBvZiB0aGUgY29tbW9uIGZ1bmN0aW9uYWxpdHkgZm9yIHtAbGluayBBdWRpb1RyYWNrfSxcbiAqIHtAbGluayBWaWRlb1RyYWNrfSwgYW5kIHtAbGluayBUZXh0VHJhY2t9LlxuICpcbiAqID4gTm90ZTogVGhpcyBjbGFzcyBzaG91bGQgbm90IGJlIHVzZWQgZGlyZWN0bHlcbiAqXG4gKiBAc2VlIHtAbGluayBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9lbWJlZGRlZC1jb250ZW50Lmh0bWx9XG4gKiBAZXh0ZW5kcyBFdmVudFRhcmdldFxuICogQGFic3RyYWN0XG4gKi9cblxudmFyIFRyYWNrID0gZnVuY3Rpb24gKF9FdmVudFRhcmdldCkge1xuICBpbmhlcml0cyhUcmFjaywgX0V2ZW50VGFyZ2V0KTtcblxuICAvKipcbiAgICogQ3JlYXRlIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV1cbiAgICogICAgICAgIE9iamVjdCBvZiBvcHRpb24gbmFtZXMgYW5kIHZhbHVlc1xuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMua2luZD0nJ11cbiAgICogICAgICAgIEEgdmFsaWQga2luZCBmb3IgdGhlIHRyYWNrIHR5cGUgeW91IGFyZSBjcmVhdGluZy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmlkPSd2anNfdHJhY2tfJyArIEd1aWQubmV3R1VJRCgpXVxuICAgKiAgICAgICAgQSB1bmlxdWUgaWQgZm9yIHRoaXMgQXVkaW9UcmFjay5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmxhYmVsPScnXVxuICAgKiAgICAgICAgVGhlIG1lbnUgbGFiZWwgZm9yIHRoaXMgdHJhY2suXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5sYW5ndWFnZT0nJ11cbiAgICogICAgICAgIEEgdmFsaWQgdHdvIGNoYXJhY3RlciBsYW5ndWFnZSBjb2RlLlxuICAgKlxuICAgKiBAYWJzdHJhY3RcbiAgICovXG4gIGZ1bmN0aW9uIFRyYWNrKCkge1xuICAgIHZhciBfcmV0O1xuXG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFRyYWNrKTtcblxuICAgIHZhciBfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX0V2ZW50VGFyZ2V0LmNhbGwodGhpcykpO1xuXG4gICAgdmFyIHRyYWNrID0gX3RoaXM7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuICAgIGlmIChJU19JRTgpIHtcbiAgICAgIHRyYWNrID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY3VzdG9tJyk7XG4gICAgICBmb3IgKHZhciBwcm9wIGluIFRyYWNrLnByb3RvdHlwZSkge1xuICAgICAgICBpZiAocHJvcCAhPT0gJ2NvbnN0cnVjdG9yJykge1xuICAgICAgICAgIHRyYWNrW3Byb3BdID0gVHJhY2sucHJvdG90eXBlW3Byb3BdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHRyYWNrUHJvcHMgPSB7XG4gICAgICBpZDogb3B0aW9ucy5pZCB8fCAndmpzX3RyYWNrXycgKyBuZXdHVUlEKCksXG4gICAgICBraW5kOiBvcHRpb25zLmtpbmQgfHwgJycsXG4gICAgICBsYWJlbDogb3B0aW9ucy5sYWJlbCB8fCAnJyxcbiAgICAgIGxhbmd1YWdlOiBvcHRpb25zLmxhbmd1YWdlIHx8ICcnXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJvZiBUcmFja1xuICAgICAqIEBtZW1iZXIge3N0cmluZ30gaWRcbiAgICAgKiAgICAgICAgIFRoZSBpZCBvZiB0aGlzIHRyYWNrLiBDYW5ub3QgYmUgY2hhbmdlZCBhZnRlciBjcmVhdGlvbi5cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKlxuICAgICAqIEByZWFkb25seVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlcm9mIFRyYWNrXG4gICAgICogQG1lbWJlciB7c3RyaW5nfSBraW5kXG4gICAgICogICAgICAgICBUaGUga2luZCBvZiB0cmFjayB0aGF0IHRoaXMgaXMuIENhbm5vdCBiZSBjaGFuZ2VkIGFmdGVyIGNyZWF0aW9uLlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqXG4gICAgICogQHJlYWRvbmx5XG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyb2YgVHJhY2tcbiAgICAgKiBAbWVtYmVyIHtzdHJpbmd9IGxhYmVsXG4gICAgICogICAgICAgICBUaGUgbGFiZWwgb2YgdGhpcyB0cmFjay4gQ2Fubm90IGJlIGNoYW5nZWQgYWZ0ZXIgY3JlYXRpb24uXG4gICAgICogQGluc3RhbmNlXG4gICAgICpcbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJvZiBUcmFja1xuICAgICAqIEBtZW1iZXIge3N0cmluZ30gbGFuZ3VhZ2VcbiAgICAgKiAgICAgICAgIFRoZSB0d28gbGV0dGVyIGxhbmd1YWdlIGNvZGUgZm9yIHRoaXMgdHJhY2suIENhbm5vdCBiZSBjaGFuZ2VkIGFmdGVyXG4gICAgICogICAgICAgICBjcmVhdGlvbi5cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKlxuICAgICAqIEByZWFkb25seVxuICAgICAqL1xuXG4gICAgdmFyIF9sb29wID0gZnVuY3Rpb24gX2xvb3Aoa2V5KSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodHJhY2ssIGtleSwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgICAgICByZXR1cm4gdHJhY2tQcm9wc1trZXldO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCQkMSgpIHt9XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgZm9yICh2YXIga2V5IGluIHRyYWNrUHJvcHMpIHtcbiAgICAgIF9sb29wKGtleSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9yZXQgPSB0cmFjaywgcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcywgX3JldCk7XG4gIH1cblxuICByZXR1cm4gVHJhY2s7XG59KEV2ZW50VGFyZ2V0KTtcblxuLyoqXG4gKiBAZmlsZSB1cmwuanNcbiAqIEBtb2R1bGUgdXJsXG4gKi9cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gdXJsOlVSTE9iamVjdFxuICpcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBwcm90b2NvbFxuICogICAgICAgICAgIFRoZSBwcm90b2NvbCBvZiB0aGUgdXJsIHRoYXQgd2FzIHBhcnNlZC5cbiAqXG4gKiBAcHJvcGVydHkge3N0cmluZ30gaG9zdG5hbWVcbiAqICAgICAgICAgICBUaGUgaG9zdG5hbWUgb2YgdGhlIHVybCB0aGF0IHdhcyBwYXJzZWQuXG4gKlxuICogQHByb3BlcnR5IHtzdHJpbmd9IHBvcnRcbiAqICAgICAgICAgICBUaGUgcG9ydCBvZiB0aGUgdXJsIHRoYXQgd2FzIHBhcnNlZC5cbiAqXG4gKiBAcHJvcGVydHkge3N0cmluZ30gcGF0aG5hbWVcbiAqICAgICAgICAgICBUaGUgcGF0aG5hbWUgb2YgdGhlIHVybCB0aGF0IHdhcyBwYXJzZWQuXG4gKlxuICogQHByb3BlcnR5IHtzdHJpbmd9IHNlYXJjaFxuICogICAgICAgICAgIFRoZSBzZWFyY2ggcXVlcnkgb2YgdGhlIHVybCB0aGF0IHdhcyBwYXJzZWQuXG4gKlxuICogQHByb3BlcnR5IHtzdHJpbmd9IGhhc2hcbiAqICAgICAgICAgICBUaGUgaGFzaCBvZiB0aGUgdXJsIHRoYXQgd2FzIHBhcnNlZC5cbiAqXG4gKiBAcHJvcGVydHkge3N0cmluZ30gaG9zdFxuICogICAgICAgICAgIFRoZSBob3N0IG9mIHRoZSB1cmwgdGhhdCB3YXMgcGFyc2VkLlxuICovXG5cbi8qKlxuICogUmVzb2x2ZSBhbmQgcGFyc2UgdGhlIGVsZW1lbnRzIG9mIGEgVVJMLlxuICpcbiAqIEBwYXJhbSAge1N0cmluZ30gdXJsXG4gKiAgICAgICAgIFRoZSB1cmwgdG8gcGFyc2VcbiAqXG4gKiBAcmV0dXJuIHt1cmw6VVJMT2JqZWN0fVxuICogICAgICAgICBBbiBvYmplY3Qgb2YgdXJsIGRldGFpbHNcbiAqL1xudmFyIHBhcnNlVXJsID0gZnVuY3Rpb24gcGFyc2VVcmwodXJsKSB7XG4gIHZhciBwcm9wcyA9IFsncHJvdG9jb2wnLCAnaG9zdG5hbWUnLCAncG9ydCcsICdwYXRobmFtZScsICdzZWFyY2gnLCAnaGFzaCcsICdob3N0J107XG5cbiAgLy8gYWRkIHRoZSB1cmwgdG8gYW4gYW5jaG9yIGFuZCBsZXQgdGhlIGJyb3dzZXIgcGFyc2UgdGhlIFVSTFxuICB2YXIgYSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcblxuICBhLmhyZWYgPSB1cmw7XG5cbiAgLy8gSUU4IChhbmQgOT8pIEZpeFxuICAvLyBpZTggZG9lc24ndCBwYXJzZSB0aGUgVVJMIGNvcnJlY3RseSB1bnRpbCB0aGUgYW5jaG9yIGlzIGFjdHVhbGx5XG4gIC8vIGFkZGVkIHRvIHRoZSBib2R5LCBhbmQgYW4gaW5uZXJIVE1MIGlzIG5lZWRlZCB0byB0cmlnZ2VyIHRoZSBwYXJzaW5nXG4gIHZhciBhZGRUb0JvZHkgPSBhLmhvc3QgPT09ICcnICYmIGEucHJvdG9jb2wgIT09ICdmaWxlOic7XG4gIHZhciBkaXYgPSB2b2lkIDA7XG5cbiAgaWYgKGFkZFRvQm9keSkge1xuICAgIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGRpdi5pbm5lckhUTUwgPSAnPGEgaHJlZj1cIicgKyB1cmwgKyAnXCI+PC9hPic7XG4gICAgYSA9IGRpdi5maXJzdENoaWxkO1xuICAgIC8vIHByZXZlbnQgdGhlIGRpdiBmcm9tIGFmZmVjdGluZyBsYXlvdXRcbiAgICBkaXYuc2V0QXR0cmlidXRlKCdzdHlsZScsICdkaXNwbGF5Om5vbmU7IHBvc2l0aW9uOmFic29sdXRlOycpO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZGl2KTtcbiAgfVxuXG4gIC8vIENvcHkgdGhlIHNwZWNpZmljIFVSTCBwcm9wZXJ0aWVzIHRvIGEgbmV3IG9iamVjdFxuICAvLyBUaGlzIGlzIGFsc28gbmVlZGVkIGZvciBJRTggYmVjYXVzZSB0aGUgYW5jaG9yIGxvc2VzIGl0c1xuICAvLyBwcm9wZXJ0aWVzIHdoZW4gaXQncyByZW1vdmVkIGZyb20gdGhlIGRvbVxuICB2YXIgZGV0YWlscyA9IHt9O1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICBkZXRhaWxzW3Byb3BzW2ldXSA9IGFbcHJvcHNbaV1dO1xuICB9XG5cbiAgLy8gSUU5IGFkZHMgdGhlIHBvcnQgdG8gdGhlIGhvc3QgcHJvcGVydHkgdW5saWtlIGV2ZXJ5b25lIGVsc2UuIElmXG4gIC8vIGEgcG9ydCBpZGVudGlmaWVyIGlzIGFkZGVkIGZvciBzdGFuZGFyZCBwb3J0cywgc3RyaXAgaXQuXG4gIGlmIChkZXRhaWxzLnByb3RvY29sID09PSAnaHR0cDonKSB7XG4gICAgZGV0YWlscy5ob3N0ID0gZGV0YWlscy5ob3N0LnJlcGxhY2UoLzo4MCQvLCAnJyk7XG4gIH1cblxuICBpZiAoZGV0YWlscy5wcm90b2NvbCA9PT0gJ2h0dHBzOicpIHtcbiAgICBkZXRhaWxzLmhvc3QgPSBkZXRhaWxzLmhvc3QucmVwbGFjZSgvOjQ0MyQvLCAnJyk7XG4gIH1cblxuICBpZiAoIWRldGFpbHMucHJvdG9jb2wpIHtcbiAgICBkZXRhaWxzLnByb3RvY29sID0gd2luZG93LmxvY2F0aW9uLnByb3RvY29sO1xuICB9XG5cbiAgaWYgKGFkZFRvQm9keSkge1xuICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoZGl2KTtcbiAgfVxuXG4gIHJldHVybiBkZXRhaWxzO1xufTtcblxuLyoqXG4gKiBHZXQgYWJzb2x1dGUgdmVyc2lvbiBvZiByZWxhdGl2ZSBVUkwuIFVzZWQgdG8gdGVsbCBmbGFzaCBjb3JyZWN0IFVSTC5cbiAqXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfSB1cmxcbiAqICAgICAgICAgVVJMIHRvIG1ha2UgYWJzb2x1dGVcbiAqXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKiAgICAgICAgIEFic29sdXRlIFVSTFxuICpcbiAqIEBzZWUgaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy80NzA4MzIvZ2V0dGluZy1hbi1hYnNvbHV0ZS11cmwtZnJvbS1hLXJlbGF0aXZlLW9uZS1pZTYtaXNzdWVcbiAqL1xudmFyIGdldEFic29sdXRlVVJMID0gZnVuY3Rpb24gZ2V0QWJzb2x1dGVVUkwodXJsKSB7XG4gIC8vIENoZWNrIGlmIGFic29sdXRlIFVSTFxuICBpZiAoIXVybC5tYXRjaCgvXmh0dHBzPzpcXC9cXC8vKSkge1xuICAgIC8vIENvbnZlcnQgdG8gYWJzb2x1dGUgVVJMLiBGbGFzaCBob3N0ZWQgb2ZmLXNpdGUgbmVlZHMgYW4gYWJzb2x1dGUgVVJMLlxuICAgIHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblxuICAgIGRpdi5pbm5lckhUTUwgPSAnPGEgaHJlZj1cIicgKyB1cmwgKyAnXCI+eDwvYT4nO1xuICAgIHVybCA9IGRpdi5maXJzdENoaWxkLmhyZWY7XG4gIH1cblxuICByZXR1cm4gdXJsO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBleHRlbnNpb24gb2YgdGhlIHBhc3NlZCBmaWxlIG5hbWUuIEl0IHdpbGwgcmV0dXJuIGFuIGVtcHR5IHN0cmluZ1xuICogaWYgcGFzc2VkIGFuIGludmFsaWQgcGF0aC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aFxuICogICAgICAgIFRoZSBmaWxlTmFtZSBwYXRoIGxpa2UgJy9wYXRoL3RvL2ZpbGUubXA0J1xuICpcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKiAgICAgICAgICBUaGUgZXh0ZW5zaW9uIGluIGxvd2VyIGNhc2Ugb3IgYW4gZW1wdHkgc3RyaW5nIGlmIG5vXG4gKiAgICAgICAgICBleHRlbnNpb24gY291bGQgYmUgZm91bmQuXG4gKi9cbnZhciBnZXRGaWxlRXh0ZW5zaW9uID0gZnVuY3Rpb24gZ2V0RmlsZUV4dGVuc2lvbihwYXRoKSB7XG4gIGlmICh0eXBlb2YgcGF0aCA9PT0gJ3N0cmluZycpIHtcbiAgICB2YXIgc3BsaXRQYXRoUmUgPSAvXihcXC8/KShbXFxzXFxTXSo/KSgoPzpcXC57MSwyfXxbXlxcL10rPykoXFwuKFteXFwuXFwvXFw/XSspKSkoPzpbXFwvXSp8W1xcP10uKikkL2k7XG4gICAgdmFyIHBhdGhQYXJ0cyA9IHNwbGl0UGF0aFJlLmV4ZWMocGF0aCk7XG5cbiAgICBpZiAocGF0aFBhcnRzKSB7XG4gICAgICByZXR1cm4gcGF0aFBhcnRzLnBvcCgpLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuICcnO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgdGhlIHVybCBwYXNzZWQgaXMgYSBjcm9zcyBkb21haW4gcmVxdWVzdCBvciBub3QuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHVybFxuICogICAgICAgIFRoZSB1cmwgdG8gY2hlY2suXG4gKlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqICAgICAgICAgV2hldGhlciBpdCBpcyBhIGNyb3NzIGRvbWFpbiByZXF1ZXN0IG9yIG5vdC5cbiAqL1xudmFyIGlzQ3Jvc3NPcmlnaW4gPSBmdW5jdGlvbiBpc0Nyb3NzT3JpZ2luKHVybCkge1xuICB2YXIgd2luTG9jID0gd2luZG93LmxvY2F0aW9uO1xuICB2YXIgdXJsSW5mbyA9IHBhcnNlVXJsKHVybCk7XG5cbiAgLy8gSUU4IHByb3RvY29sIHJlbGF0aXZlIHVybHMgd2lsbCByZXR1cm4gJzonIGZvciBwcm90b2NvbFxuICB2YXIgc3JjUHJvdG9jb2wgPSB1cmxJbmZvLnByb3RvY29sID09PSAnOicgPyB3aW5Mb2MucHJvdG9jb2wgOiB1cmxJbmZvLnByb3RvY29sO1xuXG4gIC8vIENoZWNrIGlmIHVybCBpcyBmb3IgYW5vdGhlciBkb21haW4vb3JpZ2luXG4gIC8vIElFOCBkb2Vzbid0IGtub3cgbG9jYXRpb24ub3JpZ2luLCBzbyB3ZSB3b24ndCByZWx5IG9uIGl0IGhlcmVcbiAgdmFyIGNyb3NzT3JpZ2luID0gc3JjUHJvdG9jb2wgKyB1cmxJbmZvLmhvc3QgIT09IHdpbkxvYy5wcm90b2NvbCArIHdpbkxvYy5ob3N0O1xuXG4gIHJldHVybiBjcm9zc09yaWdpbjtcbn07XG5cbnZhciBVcmwgPSAoT2JqZWN0LmZyZWV6ZSB8fCBPYmplY3QpKHtcblx0cGFyc2VVcmw6IHBhcnNlVXJsLFxuXHRnZXRBYnNvbHV0ZVVSTDogZ2V0QWJzb2x1dGVVUkwsXG5cdGdldEZpbGVFeHRlbnNpb246IGdldEZpbGVFeHRlbnNpb24sXG5cdGlzQ3Jvc3NPcmlnaW46IGlzQ3Jvc3NPcmlnaW5cbn0pO1xuXG4vKipcbiAqIEBmaWxlIHRleHQtdHJhY2suanNcbiAqL1xuLyoqXG4gKiBUYWtlcyBhIHdlYnZ0dCBmaWxlIGNvbnRlbnRzIGFuZCBwYXJzZXMgaXQgaW50byBjdWVzXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHNyY0NvbnRlbnRcbiAqICAgICAgICB3ZWJWVFQgZmlsZSBjb250ZW50c1xuICpcbiAqIEBwYXJhbSB7VGV4dFRyYWNrfSB0cmFja1xuICogICAgICAgIFRleHRUcmFjayB0byBhZGQgY3VlcyB0by4gQ3VlcyBjb21lIGZyb20gdGhlIHNyY0NvbnRlbnQuXG4gKlxuICogQHByaXZhdGVcbiAqL1xudmFyIHBhcnNlQ3VlcyA9IGZ1bmN0aW9uIHBhcnNlQ3VlcyhzcmNDb250ZW50LCB0cmFjaykge1xuICB2YXIgcGFyc2VyID0gbmV3IHdpbmRvdy5XZWJWVFQuUGFyc2VyKHdpbmRvdywgd2luZG93LnZ0dGpzLCB3aW5kb3cuV2ViVlRULlN0cmluZ0RlY29kZXIoKSk7XG4gIHZhciBlcnJvcnMgPSBbXTtcblxuICBwYXJzZXIub25jdWUgPSBmdW5jdGlvbiAoY3VlKSB7XG4gICAgdHJhY2suYWRkQ3VlKGN1ZSk7XG4gIH07XG5cbiAgcGFyc2VyLm9ucGFyc2luZ2Vycm9yID0gZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgZXJyb3JzLnB1c2goZXJyb3IpO1xuICB9O1xuXG4gIHBhcnNlci5vbmZsdXNoID0gZnVuY3Rpb24gKCkge1xuICAgIHRyYWNrLnRyaWdnZXIoe1xuICAgICAgdHlwZTogJ2xvYWRlZGRhdGEnLFxuICAgICAgdGFyZ2V0OiB0cmFja1xuICAgIH0pO1xuICB9O1xuXG4gIHBhcnNlci5wYXJzZShzcmNDb250ZW50KTtcbiAgaWYgKGVycm9ycy5sZW5ndGggPiAwKSB7XG4gICAgaWYgKHdpbmRvdy5jb25zb2xlICYmIHdpbmRvdy5jb25zb2xlLmdyb3VwQ29sbGFwc2VkKSB7XG4gICAgICB3aW5kb3cuY29uc29sZS5ncm91cENvbGxhcHNlZCgnVGV4dCBUcmFjayBwYXJzaW5nIGVycm9ycyBmb3IgJyArIHRyYWNrLnNyYyk7XG4gICAgfVxuICAgIGVycm9ycy5mb3JFYWNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgcmV0dXJuIGxvZy5lcnJvcihlcnJvcik7XG4gICAgfSk7XG4gICAgaWYgKHdpbmRvdy5jb25zb2xlICYmIHdpbmRvdy5jb25zb2xlLmdyb3VwRW5kKSB7XG4gICAgICB3aW5kb3cuY29uc29sZS5ncm91cEVuZCgpO1xuICAgIH1cbiAgfVxuXG4gIHBhcnNlci5mbHVzaCgpO1xufTtcblxuLyoqXG4gKiBMb2FkIGEgYFRleHRUcmFja2AgZnJvbSBhIHNwZWNpZmVkIHVybC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3JjXG4gKiAgICAgICAgVXJsIHRvIGxvYWQgdHJhY2sgZnJvbS5cbiAqXG4gKiBAcGFyYW0ge1RleHRUcmFja30gdHJhY2tcbiAqICAgICAgICBUcmFjayB0byBhZGQgY3VlcyB0by4gQ29tZXMgZnJvbSB0aGUgY29udGVudCBhdCB0aGUgZW5kIG9mIGB1cmxgLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbnZhciBsb2FkVHJhY2sgPSBmdW5jdGlvbiBsb2FkVHJhY2soc3JjLCB0cmFjaykge1xuICB2YXIgb3B0cyA9IHtcbiAgICB1cmk6IHNyY1xuICB9O1xuICB2YXIgY3Jvc3NPcmlnaW4gPSBpc0Nyb3NzT3JpZ2luKHNyYyk7XG5cbiAgaWYgKGNyb3NzT3JpZ2luKSB7XG4gICAgb3B0cy5jb3JzID0gY3Jvc3NPcmlnaW47XG4gIH1cblxuICB4aHIob3B0cywgYmluZCh0aGlzLCBmdW5jdGlvbiAoZXJyLCByZXNwb25zZSwgcmVzcG9uc2VCb2R5KSB7XG4gICAgaWYgKGVycikge1xuICAgICAgcmV0dXJuIGxvZy5lcnJvcihlcnIsIHJlc3BvbnNlKTtcbiAgICB9XG5cbiAgICB0cmFjay5sb2FkZWRfID0gdHJ1ZTtcblxuICAgIC8vIE1ha2Ugc3VyZSB0aGF0IHZ0dGpzIGhhcyBsb2FkZWQsIG90aGVyd2lzZSwgd2FpdCB0aWxsIGl0IGZpbmlzaGVkIGxvYWRpbmdcbiAgICAvLyBOT1RFOiB0aGlzIGlzIG9ubHkgdXNlZCBmb3IgdGhlIGFsdC92aWRlby5ub3Z0dC5qcyBidWlsZFxuICAgIGlmICh0eXBlb2Ygd2luZG93LldlYlZUVCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKHRyYWNrLnRlY2hfKSB7XG4gICAgICAgIHZhciBsb2FkSGFuZGxlciA9IGZ1bmN0aW9uIGxvYWRIYW5kbGVyKCkge1xuICAgICAgICAgIHJldHVybiBwYXJzZUN1ZXMocmVzcG9uc2VCb2R5LCB0cmFjayk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdHJhY2sudGVjaF8ub24oJ3Z0dGpzbG9hZGVkJywgbG9hZEhhbmRsZXIpO1xuICAgICAgICB0cmFjay50ZWNoXy5vbigndnR0anNlcnJvcicsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBsb2cuZXJyb3IoJ3Z0dGpzIGZhaWxlZCB0byBsb2FkLCBzdG9wcGluZyB0cnlpbmcgdG8gcHJvY2VzcyAnICsgdHJhY2suc3JjKTtcbiAgICAgICAgICB0cmFjay50ZWNoXy5vZmYoJ3Z0dGpzbG9hZGVkJywgbG9hZEhhbmRsZXIpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcGFyc2VDdWVzKHJlc3BvbnNlQm9keSwgdHJhY2spO1xuICAgIH1cbiAgfSkpO1xufTtcblxuLyoqXG4gKiBBIHJlcHJlc2VudGF0aW9uIG9mIGEgc2luZ2xlIGBUZXh0VHJhY2tgLlxuICpcbiAqIEBzZWUgW1NwZWNde0BsaW5rIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2VtYmVkZGVkLWNvbnRlbnQuaHRtbCN0ZXh0dHJhY2t9XG4gKiBAZXh0ZW5kcyBUcmFja1xuICovXG5cbnZhciBUZXh0VHJhY2sgPSBmdW5jdGlvbiAoX1RyYWNrKSB7XG4gIGluaGVyaXRzKFRleHRUcmFjaywgX1RyYWNrKTtcblxuICAvKipcbiAgICogQ3JlYXRlIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zPXt9XG4gICAqICAgICAgICBPYmplY3Qgb2Ygb3B0aW9uIG5hbWVzIGFuZCB2YWx1ZXNcbiAgICpcbiAgICogQHBhcmFtIHtUZWNofSBvcHRpb25zLnRlY2hcbiAgICogICAgICAgIEEgcmVmZXJlbmNlIHRvIHRoZSB0ZWNoIHRoYXQgb3ducyB0aGlzIFRleHRUcmFjay5cbiAgICpcbiAgICogQHBhcmFtIHtUZXh0VHJhY2t+S2luZH0gW29wdGlvbnMua2luZD0nc3VidGl0bGVzJ11cbiAgICogICAgICAgIEEgdmFsaWQgdGV4dCB0cmFjayBraW5kLlxuICAgKlxuICAgKiBAcGFyYW0ge1RleHRUcmFja35Nb2RlfSBbb3B0aW9ucy5tb2RlPSdkaXNhYmxlZCddXG4gICAqICAgICAgICBBIHZhbGlkIHRleHQgdHJhY2sgbW9kZS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmlkPSd2anNfdHJhY2tfJyArIEd1aWQubmV3R1VJRCgpXVxuICAgKiAgICAgICAgQSB1bmlxdWUgaWQgZm9yIHRoaXMgVGV4dFRyYWNrLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMubGFiZWw9JyddXG4gICAqICAgICAgICBUaGUgbWVudSBsYWJlbCBmb3IgdGhpcyB0cmFjay5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmxhbmd1YWdlPScnXVxuICAgKiAgICAgICAgQSB2YWxpZCB0d28gY2hhcmFjdGVyIGxhbmd1YWdlIGNvZGUuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5zcmNsYW5nPScnXVxuICAgKiAgICAgICAgQSB2YWxpZCB0d28gY2hhcmFjdGVyIGxhbmd1YWdlIGNvZGUuIEFuIGFsdGVybmF0aXZlLCBidXQgZGVwcmlvcml0aXplZFxuICAgKiAgICAgICAgdmVzaW9uIG9mIGBvcHRpb25zLmxhbmd1YWdlYFxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuc3JjXVxuICAgKiAgICAgICAgQSB1cmwgdG8gVGV4dFRyYWNrIGN1ZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuZGVmYXVsdF1cbiAgICogICAgICAgIElmIHRoaXMgdHJhY2sgc2hvdWxkIGRlZmF1bHQgdG8gb24gb3Igb2ZmLlxuICAgKi9cbiAgZnVuY3Rpb24gVGV4dFRyYWNrKCkge1xuICAgIHZhciBfdGhpcywgX3JldDtcblxuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBUZXh0VHJhY2spO1xuXG4gICAgaWYgKCFvcHRpb25zLnRlY2gpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQSB0ZWNoIHdhcyBub3QgcHJvdmlkZWQuJyk7XG4gICAgfVxuXG4gICAgdmFyIHNldHRpbmdzID0gbWVyZ2VPcHRpb25zKG9wdGlvbnMsIHtcbiAgICAgIGtpbmQ6IFRleHRUcmFja0tpbmRbb3B0aW9ucy5raW5kXSB8fCAnc3VidGl0bGVzJyxcbiAgICAgIGxhbmd1YWdlOiBvcHRpb25zLmxhbmd1YWdlIHx8IG9wdGlvbnMuc3JjbGFuZyB8fCAnJ1xuICAgIH0pO1xuICAgIHZhciBtb2RlID0gVGV4dFRyYWNrTW9kZVtzZXR0aW5ncy5tb2RlXSB8fCAnZGlzYWJsZWQnO1xuICAgIHZhciBkZWZhdWx0XyA9IHNldHRpbmdzWydkZWZhdWx0J107XG5cbiAgICBpZiAoc2V0dGluZ3Mua2luZCA9PT0gJ21ldGFkYXRhJyB8fCBzZXR0aW5ncy5raW5kID09PSAnY2hhcHRlcnMnKSB7XG4gICAgICBtb2RlID0gJ2hpZGRlbic7XG4gICAgfVxuICAgIC8vIG9uIElFOCB0aGlzIHdpbGwgYmUgYSBkb2N1bWVudCBlbGVtZW50XG4gICAgLy8gZm9yIGV2ZXJ5IG90aGVyIGJyb3dzZXIgdGhpcyB3aWxsIGJlIGEgbm9ybWFsIG9iamVjdFxuICAgIHZhciB0dCA9IChfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1RyYWNrLmNhbGwodGhpcywgc2V0dGluZ3MpKSwgX3RoaXMpO1xuXG4gICAgdHQudGVjaF8gPSBzZXR0aW5ncy50ZWNoO1xuXG4gICAgaWYgKElTX0lFOCkge1xuICAgICAgZm9yICh2YXIgcHJvcCBpbiBUZXh0VHJhY2sucHJvdG90eXBlKSB7XG4gICAgICAgIGlmIChwcm9wICE9PSAnY29uc3RydWN0b3InKSB7XG4gICAgICAgICAgdHRbcHJvcF0gPSBUZXh0VHJhY2sucHJvdG90eXBlW3Byb3BdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdHQuY3Vlc18gPSBbXTtcbiAgICB0dC5hY3RpdmVDdWVzXyA9IFtdO1xuXG4gICAgdmFyIGN1ZXMgPSBuZXcgVGV4dFRyYWNrQ3VlTGlzdCh0dC5jdWVzXyk7XG4gICAgdmFyIGFjdGl2ZUN1ZXMgPSBuZXcgVGV4dFRyYWNrQ3VlTGlzdCh0dC5hY3RpdmVDdWVzXyk7XG4gICAgdmFyIGNoYW5nZWQgPSBmYWxzZTtcbiAgICB2YXIgdGltZXVwZGF0ZUhhbmRsZXIgPSBiaW5kKHR0LCBmdW5jdGlvbiAoKSB7XG5cbiAgICAgIC8vIEFjY2Vzc2luZyB0aGlzLmFjdGl2ZUN1ZXMgZm9yIHRoZSBzaWRlLWVmZmVjdHMgb2YgdXBkYXRpbmcgaXRzZWxmXG4gICAgICAvLyBkdWUgdG8gaXQncyBuYXR1cmUgYXMgYSBnZXR0ZXIgZnVuY3Rpb24uIERvIG5vdCByZW1vdmUgb3IgY3VlcyB3aWxsXG4gICAgICAvLyBzdG9wIHVwZGF0aW5nIVxuICAgICAgLy8gVXNlIHRoZSBzZXR0ZXIgdG8gcHJldmVudCBkZWxldGlvbiBmcm9tIHVnbGlmeSAocHVyZV9nZXR0ZXJzIHJ1bGUpXG4gICAgICB0aGlzLmFjdGl2ZUN1ZXMgPSB0aGlzLmFjdGl2ZUN1ZXM7XG4gICAgICBpZiAoY2hhbmdlZCkge1xuICAgICAgICB0aGlzLnRyaWdnZXIoJ2N1ZWNoYW5nZScpO1xuICAgICAgICBjaGFuZ2VkID0gZmFsc2U7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAobW9kZSAhPT0gJ2Rpc2FibGVkJykge1xuICAgICAgdHQudGVjaF8ucmVhZHkoZnVuY3Rpb24gKCkge1xuICAgICAgICB0dC50ZWNoXy5vbigndGltZXVwZGF0ZScsIHRpbWV1cGRhdGVIYW5kbGVyKTtcbiAgICAgIH0sIHRydWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJvZiBUZXh0VHJhY2tcbiAgICAgKiBAbWVtYmVyIHtib29sZWFufSBkZWZhdWx0XG4gICAgICogICAgICAgICBJZiB0aGlzIHRyYWNrIHdhcyBzZXQgdG8gYmUgb24gb3Igb2ZmIGJ5IGRlZmF1bHQuIENhbm5vdCBiZSBjaGFuZ2VkIGFmdGVyXG4gICAgICogICAgICAgICBjcmVhdGlvbi5cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKlxuICAgICAqIEByZWFkb25seVxuICAgICAqL1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0dCwgJ2RlZmF1bHQnLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRfO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0JCQxKCkge31cbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJvZiBUZXh0VHJhY2tcbiAgICAgKiBAbWVtYmVyIHtzdHJpbmd9IG1vZGVcbiAgICAgKiAgICAgICAgIFNldCB0aGUgbW9kZSBvZiB0aGlzIFRleHRUcmFjayB0byBhIHZhbGlkIHtAbGluayBUZXh0VHJhY2t+TW9kZX0uIFdpbGxcbiAgICAgKiAgICAgICAgIG5vdCBiZSBzZXQgaWYgc2V0dGluZyB0byBhbiBpbnZhbGlkIG1vZGUuXG4gICAgICogQGluc3RhbmNlXG4gICAgICpcbiAgICAgKiBAZmlyZXMgVGV4dFRyYWNrI21vZGVjaGFuZ2VcbiAgICAgKi9cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodHQsICdtb2RlJywge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICAgIHJldHVybiBtb2RlO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0JCQxKG5ld01vZGUpIHtcbiAgICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgICAgaWYgKCFUZXh0VHJhY2tNb2RlW25ld01vZGVdKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIG1vZGUgPSBuZXdNb2RlO1xuICAgICAgICBpZiAobW9kZSAhPT0gJ2Rpc2FibGVkJykge1xuXG4gICAgICAgICAgdGhpcy50ZWNoXy5yZWFkeShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpczIudGVjaF8ub24oJ3RpbWV1cGRhdGUnLCB0aW1ldXBkYXRlSGFuZGxlcik7XG4gICAgICAgICAgfSwgdHJ1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy50ZWNoXy5vZmYoJ3RpbWV1cGRhdGUnLCB0aW1ldXBkYXRlSGFuZGxlcik7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFuIGV2ZW50IHRoYXQgZmlyZXMgd2hlbiBtb2RlIGNoYW5nZXMgb24gdGhpcyB0cmFjay4gVGhpcyBhbGxvd3NcbiAgICAgICAgICogdGhlIFRleHRUcmFja0xpc3QgdGhhdCBob2xkcyB0aGlzIHRyYWNrIHRvIGFjdCBhY2NvcmRpbmdseS5cbiAgICAgICAgICpcbiAgICAgICAgICogPiBOb3RlOiBUaGlzIGlzIG5vdCBwYXJ0IG9mIHRoZSBzcGVjIVxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXZlbnQgVGV4dFRyYWNrI21vZGVjaGFuZ2VcbiAgICAgICAgICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50cmlnZ2VyKCdtb2RlY2hhbmdlJyk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyb2YgVGV4dFRyYWNrXG4gICAgICogQG1lbWJlciB7VGV4dFRyYWNrQ3VlTGlzdH0gY3Vlc1xuICAgICAqICAgICAgICAgVGhlIHRleHQgdHJhY2sgY3VlIGxpc3QgZm9yIHRoaXMgVGV4dFRyYWNrLlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0dCwgJ2N1ZXMnLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmxvYWRlZF8pIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjdWVzO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0JCQxKCkge31cbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJvZiBUZXh0VHJhY2tcbiAgICAgKiBAbWVtYmVyIHtUZXh0VHJhY2tDdWVMaXN0fSBhY3RpdmVDdWVzXG4gICAgICogICAgICAgICBUaGUgbGlzdCB0ZXh0IHRyYWNrIGN1ZXMgdGhhdCBhcmUgY3VycmVudGx5IGFjdGl2ZSBmb3IgdGhpcyBUZXh0VHJhY2suXG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHR0LCAnYWN0aXZlQ3VlcycsIHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgICBpZiAoIXRoaXMubG9hZGVkXykge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbm90aGluZyB0byBkb1xuICAgICAgICBpZiAodGhpcy5jdWVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiBhY3RpdmVDdWVzO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGN0ID0gdGhpcy50ZWNoXy5jdXJyZW50VGltZSgpO1xuICAgICAgICB2YXIgYWN0aXZlID0gW107XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLmN1ZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGN1ZSA9IHRoaXMuY3Vlc1tpXTtcblxuICAgICAgICAgIGlmIChjdWUuc3RhcnRUaW1lIDw9IGN0ICYmIGN1ZS5lbmRUaW1lID49IGN0KSB7XG4gICAgICAgICAgICBhY3RpdmUucHVzaChjdWUpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY3VlLnN0YXJ0VGltZSA9PT0gY3VlLmVuZFRpbWUgJiYgY3VlLnN0YXJ0VGltZSA8PSBjdCAmJiBjdWUuc3RhcnRUaW1lICsgMC41ID49IGN0KSB7XG4gICAgICAgICAgICBhY3RpdmUucHVzaChjdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNoYW5nZWQgPSBmYWxzZTtcblxuICAgICAgICBpZiAoYWN0aXZlLmxlbmd0aCAhPT0gdGhpcy5hY3RpdmVDdWVzXy5sZW5ndGgpIHtcbiAgICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYWN0aXZlLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgaWYgKHRoaXMuYWN0aXZlQ3Vlc18uaW5kZXhPZihhY3RpdmVbX2ldKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgY2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5hY3RpdmVDdWVzXyA9IGFjdGl2ZTtcbiAgICAgICAgYWN0aXZlQ3Vlcy5zZXRDdWVzXyh0aGlzLmFjdGl2ZUN1ZXNfKTtcblxuICAgICAgICByZXR1cm4gYWN0aXZlQ3VlcztcbiAgICAgIH0sXG5cblxuICAgICAgLy8gLyFcXCBLZWVwIHRoaXMgc2V0dGVyIGVtcHR5IChzZWUgdGhlIHRpbWV1cGRhdGUgaGFuZGxlciBhYm92ZSlcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0JCQxKCkge31cbiAgICB9KTtcblxuICAgIGlmIChzZXR0aW5ncy5zcmMpIHtcbiAgICAgIHR0LnNyYyA9IHNldHRpbmdzLnNyYztcbiAgICAgIGxvYWRUcmFjayhzZXR0aW5ncy5zcmMsIHR0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdHQubG9hZGVkXyA9IHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9yZXQgPSB0dCwgcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcywgX3JldCk7XG4gIH1cblxuICAvKipcbiAgICogQWRkIGEgY3VlIHRvIHRoZSBpbnRlcm5hbCBsaXN0IG9mIGN1ZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7VGV4dFRyYWNrfkN1ZX0gY3VlXG4gICAqICAgICAgICBUaGUgY3VlIHRvIGFkZCB0byBvdXIgaW50ZXJuYWwgbGlzdFxuICAgKi9cblxuXG4gIFRleHRUcmFjay5wcm90b3R5cGUuYWRkQ3VlID0gZnVuY3Rpb24gYWRkQ3VlKG9yaWdpbmFsQ3VlKSB7XG4gICAgdmFyIGN1ZSA9IG9yaWdpbmFsQ3VlO1xuXG4gICAgaWYgKHdpbmRvdy52dHRqcyAmJiAhKG9yaWdpbmFsQ3VlIGluc3RhbmNlb2Ygd2luZG93LnZ0dGpzLlZUVEN1ZSkpIHtcbiAgICAgIGN1ZSA9IG5ldyB3aW5kb3cudnR0anMuVlRUQ3VlKG9yaWdpbmFsQ3VlLnN0YXJ0VGltZSwgb3JpZ2luYWxDdWUuZW5kVGltZSwgb3JpZ2luYWxDdWUudGV4dCk7XG5cbiAgICAgIGZvciAodmFyIHByb3AgaW4gb3JpZ2luYWxDdWUpIHtcbiAgICAgICAgaWYgKCEocHJvcCBpbiBjdWUpKSB7XG4gICAgICAgICAgY3VlW3Byb3BdID0gb3JpZ2luYWxDdWVbcHJvcF07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gbWFrZSBzdXJlIHRoYXQgYGlkYCBpcyBjb3BpZWQgb3ZlclxuICAgICAgY3VlLmlkID0gb3JpZ2luYWxDdWUuaWQ7XG4gICAgICBjdWUub3JpZ2luYWxDdWVfID0gb3JpZ2luYWxDdWU7XG4gICAgfVxuXG4gICAgdmFyIHRyYWNrcyA9IHRoaXMudGVjaF8udGV4dFRyYWNrcygpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh0cmFja3NbaV0gIT09IHRoaXMpIHtcbiAgICAgICAgdHJhY2tzW2ldLnJlbW92ZUN1ZShjdWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuY3Vlc18ucHVzaChjdWUpO1xuICAgIHRoaXMuY3Vlcy5zZXRDdWVzXyh0aGlzLmN1ZXNfKTtcbiAgfTtcblxuICAvKipcbiAgICogUmVtb3ZlIGEgY3VlIGZyb20gb3VyIGludGVybmFsIGxpc3RcbiAgICpcbiAgICogQHBhcmFtIHtUZXh0VHJhY2t+Q3VlfSByZW1vdmVDdWVcbiAgICogICAgICAgIFRoZSBjdWUgdG8gcmVtb3ZlIGZyb20gb3VyIGludGVybmFsIGxpc3RcbiAgICovXG5cblxuICBUZXh0VHJhY2sucHJvdG90eXBlLnJlbW92ZUN1ZSA9IGZ1bmN0aW9uIHJlbW92ZUN1ZShfcmVtb3ZlQ3VlKSB7XG4gICAgdmFyIGkgPSB0aGlzLmN1ZXNfLmxlbmd0aDtcblxuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHZhciBjdWUgPSB0aGlzLmN1ZXNfW2ldO1xuXG4gICAgICBpZiAoY3VlID09PSBfcmVtb3ZlQ3VlIHx8IGN1ZS5vcmlnaW5hbEN1ZV8gJiYgY3VlLm9yaWdpbmFsQ3VlXyA9PT0gX3JlbW92ZUN1ZSkge1xuICAgICAgICB0aGlzLmN1ZXNfLnNwbGljZShpLCAxKTtcbiAgICAgICAgdGhpcy5jdWVzLnNldEN1ZXNfKHRoaXMuY3Vlc18pO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIFRleHRUcmFjaztcbn0oVHJhY2spO1xuXG4vKipcbiAqIGN1ZWNoYW5nZSAtIE9uZSBvciBtb3JlIGN1ZXMgaW4gdGhlIHRyYWNrIGhhdmUgYmVjb21lIGFjdGl2ZSBvciBzdG9wcGVkIGJlaW5nIGFjdGl2ZS5cbiAqL1xuXG5cblRleHRUcmFjay5wcm90b3R5cGUuYWxsb3dlZEV2ZW50c18gPSB7XG4gIGN1ZWNoYW5nZTogJ2N1ZWNoYW5nZSdcbn07XG5cbi8qKlxuICogQSByZXByZXNlbnRhdGlvbiBvZiBhIHNpbmdsZSBgQXVkaW9UcmFja2AuIElmIGl0IGlzIHBhcnQgb2YgYW4ge0BsaW5rIEF1ZGlvVHJhY2tMaXN0fVxuICogb25seSBvbmUgYEF1ZGlvVHJhY2tgIGluIHRoZSBsaXN0IHdpbGwgYmUgZW5hYmxlZCBhdCBhIHRpbWUuXG4gKlxuICogQHNlZSBbU3BlY117QGxpbmsgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZW1iZWRkZWQtY29udGVudC5odG1sI2F1ZGlvdHJhY2t9XG4gKiBAZXh0ZW5kcyBUcmFja1xuICovXG5cbnZhciBBdWRpb1RyYWNrID0gZnVuY3Rpb24gKF9UcmFjaykge1xuICBpbmhlcml0cyhBdWRpb1RyYWNrLCBfVHJhY2spO1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcy5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XVxuICAgKiAgICAgICAgT2JqZWN0IG9mIG9wdGlvbiBuYW1lcyBhbmQgdmFsdWVzXG4gICAqXG4gICAqIEBwYXJhbSB7QXVkaW9UcmFja35LaW5kfSBbb3B0aW9ucy5raW5kPScnXVxuICAgKiAgICAgICAgQSB2YWxpZCBhdWRpbyB0cmFjayBraW5kXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5pZD0ndmpzX3RyYWNrXycgKyBHdWlkLm5ld0dVSUQoKV1cbiAgICogICAgICAgIEEgdW5pcXVlIGlkIGZvciB0aGlzIEF1ZGlvVHJhY2suXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5sYWJlbD0nJ11cbiAgICogICAgICAgIFRoZSBtZW51IGxhYmVsIGZvciB0aGlzIHRyYWNrLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMubGFuZ3VhZ2U9JyddXG4gICAqICAgICAgICBBIHZhbGlkIHR3byBjaGFyYWN0ZXIgbGFuZ3VhZ2UgY29kZS5cbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5lbmFibGVkXVxuICAgKiAgICAgICAgSWYgdGhpcyB0cmFjayBpcyB0aGUgb25lIHRoYXQgaXMgY3VycmVudGx5IHBsYXlpbmcuIElmIHRoaXMgdHJhY2sgaXMgcGFydCBvZlxuICAgKiAgICAgICAgYW4ge0BsaW5rIEF1ZGlvVHJhY2tMaXN0fSwgb25seSBvbmUge0BsaW5rIEF1ZGlvVHJhY2t9IHdpbGwgYmUgZW5hYmxlZC5cbiAgICovXG4gIGZ1bmN0aW9uIEF1ZGlvVHJhY2soKSB7XG4gICAgdmFyIF90aGlzLCBfcmV0O1xuXG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIEF1ZGlvVHJhY2spO1xuXG4gICAgdmFyIHNldHRpbmdzID0gbWVyZ2VPcHRpb25zKG9wdGlvbnMsIHtcbiAgICAgIGtpbmQ6IEF1ZGlvVHJhY2tLaW5kW29wdGlvbnMua2luZF0gfHwgJydcbiAgICB9KTtcbiAgICAvLyBvbiBJRTggdGhpcyB3aWxsIGJlIGEgZG9jdW1lbnQgZWxlbWVudFxuICAgIC8vIGZvciBldmVyeSBvdGhlciBicm93c2VyIHRoaXMgd2lsbCBiZSBhIG5vcm1hbCBvYmplY3RcbiAgICB2YXIgdHJhY2sgPSAoX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9UcmFjay5jYWxsKHRoaXMsIHNldHRpbmdzKSksIF90aGlzKTtcbiAgICB2YXIgZW5hYmxlZCA9IGZhbHNlO1xuXG4gICAgaWYgKElTX0lFOCkge1xuICAgICAgZm9yICh2YXIgcHJvcCBpbiBBdWRpb1RyYWNrLnByb3RvdHlwZSkge1xuICAgICAgICBpZiAocHJvcCAhPT0gJ2NvbnN0cnVjdG9yJykge1xuICAgICAgICAgIHRyYWNrW3Byb3BdID0gQXVkaW9UcmFjay5wcm90b3R5cGVbcHJvcF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQG1lbWJlcm9mIEF1ZGlvVHJhY2tcbiAgICAgKiBAbWVtYmVyIHtib29sZWFufSBlbmFibGVkXG4gICAgICogICAgICAgICBJZiB0aGlzIGBBdWRpb1RyYWNrYCBpcyBlbmFibGVkIG9yIG5vdC4gV2hlbiBzZXR0aW5nIHRoaXMgd2lsbFxuICAgICAqICAgICAgICAgZmlyZSB7QGxpbmsgQXVkaW9UcmFjayNlbmFibGVkY2hhbmdlfSBpZiB0aGUgc3RhdGUgb2YgZW5hYmxlZCBpcyBjaGFuZ2VkLlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqXG4gICAgICogQGZpcmVzIFZpZGVvVHJhY2sjc2VsZWN0ZWRjaGFuZ2VcbiAgICAgKi9cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodHJhY2ssICdlbmFibGVkJywge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICAgIHJldHVybiBlbmFibGVkO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0JCQxKG5ld0VuYWJsZWQpIHtcbiAgICAgICAgLy8gYW4gaW52YWxpZCBvciB1bmNoYW5nZWQgdmFsdWVcbiAgICAgICAgaWYgKHR5cGVvZiBuZXdFbmFibGVkICE9PSAnYm9vbGVhbicgfHwgbmV3RW5hYmxlZCA9PT0gZW5hYmxlZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBlbmFibGVkID0gbmV3RW5hYmxlZDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQW4gZXZlbnQgdGhhdCBmaXJlcyB3aGVuIGVuYWJsZWQgY2hhbmdlcyBvbiB0aGlzIHRyYWNrLiBUaGlzIGFsbG93c1xuICAgICAgICAgKiB0aGUgQXVkaW9UcmFja0xpc3QgdGhhdCBob2xkcyB0aGlzIHRyYWNrIHRvIGFjdCBhY2NvcmRpbmdseS5cbiAgICAgICAgICpcbiAgICAgICAgICogPiBOb3RlOiBUaGlzIGlzIG5vdCBwYXJ0IG9mIHRoZSBzcGVjISBOYXRpdmUgdHJhY2tzIHdpbGwgZG9cbiAgICAgICAgICogICAgICAgICB0aGlzIGludGVybmFsbHkgd2l0aG91dCBhbiBldmVudC5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV2ZW50IEF1ZGlvVHJhY2sjZW5hYmxlZGNoYW5nZVxuICAgICAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnRyaWdnZXIoJ2VuYWJsZWRjaGFuZ2UnKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIGlmIHRoZSB1c2VyIHNldHMgdGhpcyB0cmFjayB0byBzZWxlY3RlZCB0aGVuXG4gICAgLy8gc2V0IHNlbGVjdGVkIHRvIHRoYXQgdHJ1ZSB2YWx1ZSBvdGhlcndpc2VcbiAgICAvLyB3ZSBrZWVwIGl0IGZhbHNlXG4gICAgaWYgKHNldHRpbmdzLmVuYWJsZWQpIHtcbiAgICAgIHRyYWNrLmVuYWJsZWQgPSBzZXR0aW5ncy5lbmFibGVkO1xuICAgIH1cbiAgICB0cmFjay5sb2FkZWRfID0gdHJ1ZTtcblxuICAgIHJldHVybiBfcmV0ID0gdHJhY2ssIHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oX3RoaXMsIF9yZXQpO1xuICB9XG5cbiAgcmV0dXJuIEF1ZGlvVHJhY2s7XG59KFRyYWNrKTtcblxuLyoqXG4gKiBBIHJlcHJlc2VudGF0aW9uIG9mIGEgc2luZ2xlIGBWaWRlb1RyYWNrYC5cbiAqXG4gKiBAc2VlIFtTcGVjXXtAbGluayBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9lbWJlZGRlZC1jb250ZW50Lmh0bWwjdmlkZW90cmFja31cbiAqIEBleHRlbmRzIFRyYWNrXG4gKi9cblxudmFyIFZpZGVvVHJhY2sgPSBmdW5jdGlvbiAoX1RyYWNrKSB7XG4gIGluaGVyaXRzKFZpZGVvVHJhY2ssIF9UcmFjayk7XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dXG4gICAqICAgICAgICBPYmplY3Qgb2Ygb3B0aW9uIG5hbWVzIGFuZCB2YWx1ZXNcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmtpbmQ9JyddXG4gICAqICAgICAgICBBIHZhbGlkIHtAbGluayBWaWRlb1RyYWNrfktpbmR9XG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5pZD0ndmpzX3RyYWNrXycgKyBHdWlkLm5ld0dVSUQoKV1cbiAgICogICAgICAgIEEgdW5pcXVlIGlkIGZvciB0aGlzIEF1ZGlvVHJhY2suXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5sYWJlbD0nJ11cbiAgICogICAgICAgIFRoZSBtZW51IGxhYmVsIGZvciB0aGlzIHRyYWNrLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMubGFuZ3VhZ2U9JyddXG4gICAqICAgICAgICBBIHZhbGlkIHR3byBjaGFyYWN0ZXIgbGFuZ3VhZ2UgY29kZS5cbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5zZWxlY3RlZF1cbiAgICogICAgICAgIElmIHRoaXMgdHJhY2sgaXMgdGhlIG9uZSB0aGF0IGlzIGN1cnJlbnRseSBwbGF5aW5nLlxuICAgKi9cbiAgZnVuY3Rpb24gVmlkZW9UcmFjaygpIHtcbiAgICB2YXIgX3RoaXMsIF9yZXQ7XG5cbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgVmlkZW9UcmFjayk7XG5cbiAgICB2YXIgc2V0dGluZ3MgPSBtZXJnZU9wdGlvbnMob3B0aW9ucywge1xuICAgICAga2luZDogVmlkZW9UcmFja0tpbmRbb3B0aW9ucy5raW5kXSB8fCAnJ1xuICAgIH0pO1xuXG4gICAgLy8gb24gSUU4IHRoaXMgd2lsbCBiZSBhIGRvY3VtZW50IGVsZW1lbnRcbiAgICAvLyBmb3IgZXZlcnkgb3RoZXIgYnJvd3NlciB0aGlzIHdpbGwgYmUgYSBub3JtYWwgb2JqZWN0XG4gICAgdmFyIHRyYWNrID0gKF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfVHJhY2suY2FsbCh0aGlzLCBzZXR0aW5ncykpLCBfdGhpcyk7XG4gICAgdmFyIHNlbGVjdGVkID0gZmFsc2U7XG5cbiAgICBpZiAoSVNfSUU4KSB7XG4gICAgICBmb3IgKHZhciBwcm9wIGluIFZpZGVvVHJhY2sucHJvdG90eXBlKSB7XG4gICAgICAgIGlmIChwcm9wICE9PSAnY29uc3RydWN0b3InKSB7XG4gICAgICAgICAgdHJhY2tbcHJvcF0gPSBWaWRlb1RyYWNrLnByb3RvdHlwZVtwcm9wXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJvZiBWaWRlb1RyYWNrXG4gICAgICogQG1lbWJlciB7Ym9vbGVhbn0gc2VsZWN0ZWRcbiAgICAgKiAgICAgICAgIElmIHRoaXMgYFZpZGVvVHJhY2tgIGlzIHNlbGVjdGVkIG9yIG5vdC4gV2hlbiBzZXR0aW5nIHRoaXMgd2lsbFxuICAgICAqICAgICAgICAgZmlyZSB7QGxpbmsgVmlkZW9UcmFjayNzZWxlY3RlZGNoYW5nZX0gaWYgdGhlIHN0YXRlIG9mIHNlbGVjdGVkIGNoYW5nZWQuXG4gICAgICogQGluc3RhbmNlXG4gICAgICpcbiAgICAgKiBAZmlyZXMgVmlkZW9UcmFjayNzZWxlY3RlZGNoYW5nZVxuICAgICAqL1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0cmFjaywgJ3NlbGVjdGVkJywge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICAgIHJldHVybiBzZWxlY3RlZDtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCQkMShuZXdTZWxlY3RlZCkge1xuICAgICAgICAvLyBhbiBpbnZhbGlkIG9yIHVuY2hhbmdlZCB2YWx1ZVxuICAgICAgICBpZiAodHlwZW9mIG5ld1NlbGVjdGVkICE9PSAnYm9vbGVhbicgfHwgbmV3U2VsZWN0ZWQgPT09IHNlbGVjdGVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHNlbGVjdGVkID0gbmV3U2VsZWN0ZWQ7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFuIGV2ZW50IHRoYXQgZmlyZXMgd2hlbiBzZWxlY3RlZCBjaGFuZ2VzIG9uIHRoaXMgdHJhY2suIFRoaXMgYWxsb3dzXG4gICAgICAgICAqIHRoZSBWaWRlb1RyYWNrTGlzdCB0aGF0IGhvbGRzIHRoaXMgdHJhY2sgdG8gYWN0IGFjY29yZGluZ2x5LlxuICAgICAgICAgKlxuICAgICAgICAgKiA+IE5vdGU6IFRoaXMgaXMgbm90IHBhcnQgb2YgdGhlIHNwZWMhIE5hdGl2ZSB0cmFja3Mgd2lsbCBkb1xuICAgICAgICAgKiAgICAgICAgIHRoaXMgaW50ZXJuYWxseSB3aXRob3V0IGFuIGV2ZW50LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXZlbnQgVmlkZW9UcmFjayNzZWxlY3RlZGNoYW5nZVxuICAgICAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnRyaWdnZXIoJ3NlbGVjdGVkY2hhbmdlJyk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBpZiB0aGUgdXNlciBzZXRzIHRoaXMgdHJhY2sgdG8gc2VsZWN0ZWQgdGhlblxuICAgIC8vIHNldCBzZWxlY3RlZCB0byB0aGF0IHRydWUgdmFsdWUgb3RoZXJ3aXNlXG4gICAgLy8gd2Uga2VlcCBpdCBmYWxzZVxuICAgIGlmIChzZXR0aW5ncy5zZWxlY3RlZCkge1xuICAgICAgdHJhY2suc2VsZWN0ZWQgPSBzZXR0aW5ncy5zZWxlY3RlZDtcbiAgICB9XG5cbiAgICByZXR1cm4gX3JldCA9IHRyYWNrLCBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKF90aGlzLCBfcmV0KTtcbiAgfVxuXG4gIHJldHVybiBWaWRlb1RyYWNrO1xufShUcmFjayk7XG5cbi8qKlxuICogQGZpbGUgaHRtbC10cmFjay1lbGVtZW50LmpzXG4gKi9cblxuLyoqXG4gKiBAbWVtYmVyb2YgSFRNTFRyYWNrRWxlbWVudFxuICogQHR5cGVkZWYge0hUTUxUcmFja0VsZW1lbnR+UmVhZHlTdGF0ZX1cbiAqIEBlbnVtIHtudW1iZXJ9XG4gKi9cbnZhciBOT05FID0gMDtcbnZhciBMT0FESU5HID0gMTtcbnZhciBMT0FERUQgPSAyO1xudmFyIEVSUk9SID0gMztcblxuLyoqXG4gKiBBIHNpbmdsZSB0cmFjayByZXByZXNlbnRlZCBpbiB0aGUgRE9NLlxuICpcbiAqIEBzZWUgW1NwZWNde0BsaW5rIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2VtYmVkZGVkLWNvbnRlbnQuaHRtbCNodG1sdHJhY2tlbGVtZW50fVxuICogQGV4dGVuZHMgRXZlbnRUYXJnZXRcbiAqL1xuXG52YXIgSFRNTFRyYWNrRWxlbWVudCA9IGZ1bmN0aW9uIChfRXZlbnRUYXJnZXQpIHtcbiAgaW5oZXJpdHMoSFRNTFRyYWNrRWxlbWVudCwgX0V2ZW50VGFyZ2V0KTtcblxuICAvKipcbiAgICogQ3JlYXRlIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zPXt9XG4gICAqICAgICAgICBPYmplY3Qgb2Ygb3B0aW9uIG5hbWVzIGFuZCB2YWx1ZXNcbiAgICpcbiAgICogQHBhcmFtIHtUZWNofSBvcHRpb25zLnRlY2hcbiAgICogICAgICAgIEEgcmVmZXJlbmNlIHRvIHRoZSB0ZWNoIHRoYXQgb3ducyB0aGlzIEhUTUxUcmFja0VsZW1lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7VGV4dFRyYWNrfktpbmR9IFtvcHRpb25zLmtpbmQ9J3N1YnRpdGxlcyddXG4gICAqICAgICAgICBBIHZhbGlkIHRleHQgdHJhY2sga2luZC5cbiAgICpcbiAgICogQHBhcmFtIHtUZXh0VHJhY2t+TW9kZX0gW29wdGlvbnMubW9kZT0nZGlzYWJsZWQnXVxuICAgKiAgICAgICAgQSB2YWxpZCB0ZXh0IHRyYWNrIG1vZGUuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5pZD0ndmpzX3RyYWNrXycgKyBHdWlkLm5ld0dVSUQoKV1cbiAgICogICAgICAgIEEgdW5pcXVlIGlkIGZvciB0aGlzIFRleHRUcmFjay5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmxhYmVsPScnXVxuICAgKiAgICAgICAgVGhlIG1lbnUgbGFiZWwgZm9yIHRoaXMgdHJhY2suXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5sYW5ndWFnZT0nJ11cbiAgICogICAgICAgIEEgdmFsaWQgdHdvIGNoYXJhY3RlciBsYW5ndWFnZSBjb2RlLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuc3JjbGFuZz0nJ11cbiAgICogICAgICAgIEEgdmFsaWQgdHdvIGNoYXJhY3RlciBsYW5ndWFnZSBjb2RlLiBBbiBhbHRlcm5hdGl2ZSwgYnV0IGRlcHJpb3JpdGl6ZWRcbiAgICogICAgICAgIHZlc2lvbiBvZiBgb3B0aW9ucy5sYW5ndWFnZWBcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnNyY11cbiAgICogICAgICAgIEEgdXJsIHRvIFRleHRUcmFjayBjdWVzLlxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmRlZmF1bHRdXG4gICAqICAgICAgICBJZiB0aGlzIHRyYWNrIHNob3VsZCBkZWZhdWx0IHRvIG9uIG9yIG9mZi5cbiAgICovXG4gIGZ1bmN0aW9uIEhUTUxUcmFja0VsZW1lbnQoKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIEhUTUxUcmFja0VsZW1lbnQpO1xuXG4gICAgdmFyIF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfRXZlbnRUYXJnZXQuY2FsbCh0aGlzKSk7XG5cbiAgICB2YXIgcmVhZHlTdGF0ZSA9IHZvaWQgMDtcbiAgICB2YXIgdHJhY2tFbGVtZW50ID0gX3RoaXM7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuICAgIGlmIChJU19JRTgpIHtcbiAgICAgIHRyYWNrRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2N1c3RvbScpO1xuXG4gICAgICBmb3IgKHZhciBwcm9wIGluIEhUTUxUcmFja0VsZW1lbnQucHJvdG90eXBlKSB7XG4gICAgICAgIGlmIChwcm9wICE9PSAnY29uc3RydWN0b3InKSB7XG4gICAgICAgICAgdHJhY2tFbGVtZW50W3Byb3BdID0gSFRNTFRyYWNrRWxlbWVudC5wcm90b3R5cGVbcHJvcF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgdHJhY2sgPSBuZXcgVGV4dFRyYWNrKG9wdGlvbnMpO1xuXG4gICAgdHJhY2tFbGVtZW50LmtpbmQgPSB0cmFjay5raW5kO1xuICAgIHRyYWNrRWxlbWVudC5zcmMgPSB0cmFjay5zcmM7XG4gICAgdHJhY2tFbGVtZW50LnNyY2xhbmcgPSB0cmFjay5sYW5ndWFnZTtcbiAgICB0cmFja0VsZW1lbnQubGFiZWwgPSB0cmFjay5sYWJlbDtcbiAgICB0cmFja0VsZW1lbnRbJ2RlZmF1bHQnXSA9IHRyYWNrWydkZWZhdWx0J107XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyb2YgSFRNTFRyYWNrRWxlbWVudFxuICAgICAqIEBtZW1iZXIge0hUTUxUcmFja0VsZW1lbnR+UmVhZHlTdGF0ZX0gcmVhZHlTdGF0ZVxuICAgICAqICAgICAgICAgVGhlIGN1cnJlbnQgcmVhZHkgc3RhdGUgb2YgdGhlIHRyYWNrIGVsZW1lbnQuXG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRyYWNrRWxlbWVudCwgJ3JlYWR5U3RhdGUnLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgICAgcmV0dXJuIHJlYWR5U3RhdGU7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyb2YgSFRNTFRyYWNrRWxlbWVudFxuICAgICAqIEBtZW1iZXIge1RleHRUcmFja30gdHJhY2tcbiAgICAgKiAgICAgICAgIFRoZSB1bmRlcmx5aW5nIFRleHRUcmFjayBvYmplY3QuXG4gICAgICogQGluc3RhbmNlXG4gICAgICpcbiAgICAgKi9cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodHJhY2tFbGVtZW50LCAndHJhY2snLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgICAgcmV0dXJuIHRyYWNrO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmVhZHlTdGF0ZSA9IE5PTkU7XG5cbiAgICAvKipcbiAgICAgKiBAbGlzdGVucyBUZXh0VHJhY2sjbG9hZGVkZGF0YVxuICAgICAqIEBmaXJlcyBIVE1MVHJhY2tFbGVtZW50I2xvYWRcbiAgICAgKi9cbiAgICB0cmFjay5hZGRFdmVudExpc3RlbmVyKCdsb2FkZWRkYXRhJywgZnVuY3Rpb24gKCkge1xuICAgICAgcmVhZHlTdGF0ZSA9IExPQURFRDtcblxuICAgICAgdHJhY2tFbGVtZW50LnRyaWdnZXIoe1xuICAgICAgICB0eXBlOiAnbG9hZCcsXG4gICAgICAgIHRhcmdldDogdHJhY2tFbGVtZW50XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGlmIChJU19JRTgpIHtcbiAgICAgIHZhciBfcmV0O1xuXG4gICAgICByZXR1cm4gX3JldCA9IHRyYWNrRWxlbWVudCwgcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcywgX3JldCk7XG4gICAgfVxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHJldHVybiBIVE1MVHJhY2tFbGVtZW50O1xufShFdmVudFRhcmdldCk7XG5cbkhUTUxUcmFja0VsZW1lbnQucHJvdG90eXBlLmFsbG93ZWRFdmVudHNfID0ge1xuICBsb2FkOiAnbG9hZCdcbn07XG5cbkhUTUxUcmFja0VsZW1lbnQuTk9ORSA9IE5PTkU7XG5IVE1MVHJhY2tFbGVtZW50LkxPQURJTkcgPSBMT0FESU5HO1xuSFRNTFRyYWNrRWxlbWVudC5MT0FERUQgPSBMT0FERUQ7XG5IVE1MVHJhY2tFbGVtZW50LkVSUk9SID0gRVJST1I7XG5cbi8qXG4gKiBUaGlzIGZpbGUgY29udGFpbnMgYWxsIHRyYWNrIHByb3BlcnRpZXMgdGhhdCBhcmUgdXNlZCBpblxuICogcGxheWVyLmpzLCB0ZWNoLmpzLCBodG1sNS5qcyBhbmQgcG9zc2libHkgb3RoZXIgdGVjaHMgaW4gdGhlIGZ1dHVyZS5cbiAqL1xuXG52YXIgTk9STUFMID0ge1xuICBhdWRpbzoge1xuICAgIExpc3RDbGFzczogQXVkaW9UcmFja0xpc3QsXG4gICAgVHJhY2tDbGFzczogQXVkaW9UcmFjayxcbiAgICBjYXBpdGFsTmFtZTogJ0F1ZGlvJ1xuICB9LFxuICB2aWRlbzoge1xuICAgIExpc3RDbGFzczogVmlkZW9UcmFja0xpc3QsXG4gICAgVHJhY2tDbGFzczogVmlkZW9UcmFjayxcbiAgICBjYXBpdGFsTmFtZTogJ1ZpZGVvJ1xuICB9LFxuICB0ZXh0OiB7XG4gICAgTGlzdENsYXNzOiBUZXh0VHJhY2tMaXN0LFxuICAgIFRyYWNrQ2xhc3M6IFRleHRUcmFjayxcbiAgICBjYXBpdGFsTmFtZTogJ1RleHQnXG4gIH1cbn07XG5cbk9iamVjdC5rZXlzKE5PUk1BTCkuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICBOT1JNQUxbdHlwZV0uZ2V0dGVyTmFtZSA9IHR5cGUgKyAnVHJhY2tzJztcbiAgTk9STUFMW3R5cGVdLnByaXZhdGVOYW1lID0gdHlwZSArICdUcmFja3NfJztcbn0pO1xuXG52YXIgUkVNT1RFID0ge1xuICByZW1vdGVUZXh0OiB7XG4gICAgTGlzdENsYXNzOiBUZXh0VHJhY2tMaXN0LFxuICAgIFRyYWNrQ2xhc3M6IFRleHRUcmFjayxcbiAgICBjYXBpdGFsTmFtZTogJ1JlbW90ZVRleHQnLFxuICAgIGdldHRlck5hbWU6ICdyZW1vdGVUZXh0VHJhY2tzJyxcbiAgICBwcml2YXRlTmFtZTogJ3JlbW90ZVRleHRUcmFja3NfJ1xuICB9LFxuICByZW1vdGVUZXh0RWw6IHtcbiAgICBMaXN0Q2xhc3M6IEh0bWxUcmFja0VsZW1lbnRMaXN0LFxuICAgIFRyYWNrQ2xhc3M6IEhUTUxUcmFja0VsZW1lbnQsXG4gICAgY2FwaXRhbE5hbWU6ICdSZW1vdGVUZXh0VHJhY2tFbHMnLFxuICAgIGdldHRlck5hbWU6ICdyZW1vdGVUZXh0VHJhY2tFbHMnLFxuICAgIHByaXZhdGVOYW1lOiAncmVtb3RlVGV4dFRyYWNrRWxzXydcbiAgfVxufTtcblxudmFyIEFMTCA9IG1lcmdlT3B0aW9ucyhOT1JNQUwsIFJFTU9URSk7XG5cblJFTU9URS5uYW1lcyA9IE9iamVjdC5rZXlzKFJFTU9URSk7XG5OT1JNQUwubmFtZXMgPSBPYmplY3Qua2V5cyhOT1JNQUwpO1xuQUxMLm5hbWVzID0gW10uY29uY2F0KFJFTU9URS5uYW1lcykuY29uY2F0KE5PUk1BTC5uYW1lcyk7XG5cbi8qKlxuICogQGZpbGUgdGVjaC5qc1xuICovXG5cbi8qKlxuICogQW4gT2JqZWN0IGNvbnRhaW5pbmcgYSBzdHJ1Y3R1cmUgbGlrZTogYHtzcmM6ICd1cmwnLCB0eXBlOiAnbWltZXR5cGUnfWAgb3Igc3RyaW5nXG4gKiB0aGF0IGp1c3QgY29udGFpbnMgdGhlIHNyYyB1cmwgYWxvbmUuXG4gKiAqIGB2YXIgU291cmNlT2JqZWN0ID0ge3NyYzogJ2h0dHA6Ly9leC5jb20vdmlkZW8ubXA0JywgdHlwZTogJ3ZpZGVvL21wNCd9O2BcbiAgICogYHZhciBTb3VyY2VTdHJpbmcgPSAnaHR0cDovL2V4YW1wbGUuY29tL3NvbWUtdmlkZW8ubXA0JztgXG4gKlxuICogQHR5cGVkZWYge09iamVjdHxzdHJpbmd9IFRlY2h+U291cmNlT2JqZWN0XG4gKlxuICogQHByb3BlcnR5IHtzdHJpbmd9IHNyY1xuICogICAgICAgICAgIFRoZSB1cmwgdG8gdGhlIHNvdXJjZVxuICpcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB0eXBlXG4gKiAgICAgICAgICAgVGhlIG1pbWUgdHlwZSBvZiB0aGUgc291cmNlXG4gKi9cblxuLyoqXG4gKiBBIGZ1bmN0aW9uIHVzZWQgYnkge0BsaW5rIFRlY2h9IHRvIGNyZWF0ZSBhIG5ldyB7QGxpbmsgVGV4dFRyYWNrfS5cbiAqXG4gKiBAcHJpdmF0ZVxuICpcbiAqIEBwYXJhbSB7VGVjaH0gc2VsZlxuICogICAgICAgIEFuIGluc3RhbmNlIG9mIHRoZSBUZWNoIGNsYXNzLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBraW5kXG4gKiAgICAgICAgYFRleHRUcmFja2Aga2luZCAoc3VidGl0bGVzLCBjYXB0aW9ucywgZGVzY3JpcHRpb25zLCBjaGFwdGVycywgb3IgbWV0YWRhdGEpXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IFtsYWJlbF1cbiAqICAgICAgICBMYWJlbCB0byBpZGVudGlmeSB0aGUgdGV4dCB0cmFja1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBbbGFuZ3VhZ2VdXG4gKiAgICAgICAgVHdvIGxldHRlciBsYW5ndWFnZSBhYmJyZXZpYXRpb25cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dXG4gKiAgICAgICAgQW4gb2JqZWN0IHdpdGggYWRkaXRpb25hbCB0ZXh0IHRyYWNrIG9wdGlvbnNcbiAqXG4gKiBAcmV0dXJuIHtUZXh0VHJhY2t9XG4gKiAgICAgICAgICBUaGUgdGV4dCB0cmFjayB0aGF0IHdhcyBjcmVhdGVkLlxuICovXG5mdW5jdGlvbiBjcmVhdGVUcmFja0hlbHBlcihzZWxmLCBraW5kLCBsYWJlbCwgbGFuZ3VhZ2UpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gNCAmJiBhcmd1bWVudHNbNF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s0XSA6IHt9O1xuXG4gIHZhciB0cmFja3MgPSBzZWxmLnRleHRUcmFja3MoKTtcblxuICBvcHRpb25zLmtpbmQgPSBraW5kO1xuXG4gIGlmIChsYWJlbCkge1xuICAgIG9wdGlvbnMubGFiZWwgPSBsYWJlbDtcbiAgfVxuICBpZiAobGFuZ3VhZ2UpIHtcbiAgICBvcHRpb25zLmxhbmd1YWdlID0gbGFuZ3VhZ2U7XG4gIH1cbiAgb3B0aW9ucy50ZWNoID0gc2VsZjtcblxuICB2YXIgdHJhY2sgPSBuZXcgQUxMLnRleHQuVHJhY2tDbGFzcyhvcHRpb25zKTtcblxuICB0cmFja3MuYWRkVHJhY2sodHJhY2spO1xuXG4gIHJldHVybiB0cmFjaztcbn1cblxuLyoqXG4gKiBUaGlzIGlzIHRoZSBiYXNlIGNsYXNzIGZvciBtZWRpYSBwbGF5YmFjayB0ZWNobm9sb2d5IGNvbnRyb2xsZXJzLCBzdWNoIGFzXG4gKiB7QGxpbmsgRmxhc2h9IGFuZCB7QGxpbmsgSFRNTDV9XG4gKlxuICogQGV4dGVuZHMgQ29tcG9uZW50XG4gKi9cblxudmFyIFRlY2ggPSBmdW5jdGlvbiAoX0NvbXBvbmVudCkge1xuICBpbmhlcml0cyhUZWNoLCBfQ29tcG9uZW50KTtcblxuICAvKipcbiAgICogQ3JlYXRlIGFuIGluc3RhbmNlIG9mIHRoaXMgVGVjaC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgICAgICAgVGhlIGtleS92YWx1ZSBzdG9yZSBvZiBwbGF5ZXIgb3B0aW9ucy5cbiAgICpcbiAgICogQHBhcmFtIHtDb21wb25lbnR+UmVhZHlDYWxsYmFja30gcmVhZHlcbiAgICogICAgICAgIENhbGxiYWNrIGZ1bmN0aW9uIHRvIGNhbGwgd2hlbiB0aGUgYEhUTUw1YCBUZWNoIGlzIHJlYWR5LlxuICAgKi9cbiAgZnVuY3Rpb24gVGVjaCgpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgdmFyIHJlYWR5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmdW5jdGlvbiAoKSB7fTtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBUZWNoKTtcblxuICAgIC8vIHdlIGRvbid0IHdhbnQgdGhlIHRlY2ggdG8gcmVwb3J0IHVzZXIgYWN0aXZpdHkgYXV0b21hdGljYWxseS5cbiAgICAvLyBUaGlzIGlzIGRvbmUgbWFudWFsbHkgaW4gYWRkQ29udHJvbHNMaXN0ZW5lcnNcbiAgICBvcHRpb25zLnJlcG9ydFRvdWNoQWN0aXZpdHkgPSBmYWxzZTtcblxuICAgIC8vIGtlZXAgdHJhY2sgb2Ygd2hldGhlciB0aGUgY3VycmVudCBzb3VyY2UgaGFzIHBsYXllZCBhdCBhbGwgdG9cbiAgICAvLyBpbXBsZW1lbnQgYSB2ZXJ5IGxpbWl0ZWQgcGxheWVkKClcbiAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9Db21wb25lbnQuY2FsbCh0aGlzLCBudWxsLCBvcHRpb25zLCByZWFkeSkpO1xuXG4gICAgX3RoaXMuaGFzU3RhcnRlZF8gPSBmYWxzZTtcbiAgICBfdGhpcy5vbigncGxheWluZycsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuaGFzU3RhcnRlZF8gPSB0cnVlO1xuICAgIH0pO1xuICAgIF90aGlzLm9uKCdsb2Fkc3RhcnQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLmhhc1N0YXJ0ZWRfID0gZmFsc2U7XG4gICAgfSk7XG5cbiAgICBBTEwubmFtZXMuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgdmFyIHByb3BzID0gQUxMW25hbWVdO1xuXG4gICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zW3Byb3BzLmdldHRlck5hbWVdKSB7XG4gICAgICAgIF90aGlzW3Byb3BzLnByaXZhdGVOYW1lXSA9IG9wdGlvbnNbcHJvcHMuZ2V0dGVyTmFtZV07XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBNYW51YWxseSB0cmFjayBwcm9ncmVzcyBpbiBjYXNlcyB3aGVyZSB0aGUgYnJvd3Nlci9mbGFzaCBwbGF5ZXIgZG9lc24ndCByZXBvcnQgaXQuXG4gICAgaWYgKCFfdGhpcy5mZWF0dXJlc1Byb2dyZXNzRXZlbnRzKSB7XG4gICAgICBfdGhpcy5tYW51YWxQcm9ncmVzc09uKCk7XG4gICAgfVxuXG4gICAgLy8gTWFudWFsbHkgdHJhY2sgdGltZXVwZGF0ZXMgaW4gY2FzZXMgd2hlcmUgdGhlIGJyb3dzZXIvZmxhc2ggcGxheWVyIGRvZXNuJ3QgcmVwb3J0IGl0LlxuICAgIGlmICghX3RoaXMuZmVhdHVyZXNUaW1ldXBkYXRlRXZlbnRzKSB7XG4gICAgICBfdGhpcy5tYW51YWxUaW1lVXBkYXRlc09uKCk7XG4gICAgfVxuXG4gICAgWydUZXh0JywgJ0F1ZGlvJywgJ1ZpZGVvJ10uZm9yRWFjaChmdW5jdGlvbiAodHJhY2spIHtcbiAgICAgIGlmIChvcHRpb25zWyduYXRpdmUnICsgdHJhY2sgKyAnVHJhY2tzJ10gPT09IGZhbHNlKSB7XG4gICAgICAgIF90aGlzWydmZWF0dXJlc05hdGl2ZScgKyB0cmFjayArICdUcmFja3MnXSA9IGZhbHNlO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKG9wdGlvbnMubmF0aXZlQ2FwdGlvbnMgPT09IGZhbHNlIHx8IG9wdGlvbnMubmF0aXZlVGV4dFRyYWNrcyA9PT0gZmFsc2UpIHtcbiAgICAgIF90aGlzLmZlYXR1cmVzTmF0aXZlVGV4dFRyYWNrcyA9IGZhbHNlO1xuICAgIH0gZWxzZSBpZiAob3B0aW9ucy5uYXRpdmVDYXB0aW9ucyA9PT0gdHJ1ZSB8fCBvcHRpb25zLm5hdGl2ZVRleHRUcmFja3MgPT09IHRydWUpIHtcbiAgICAgIF90aGlzLmZlYXR1cmVzTmF0aXZlVGV4dFRyYWNrcyA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKCFfdGhpcy5mZWF0dXJlc05hdGl2ZVRleHRUcmFja3MpIHtcbiAgICAgIF90aGlzLmVtdWxhdGVUZXh0VHJhY2tzKCk7XG4gICAgfVxuXG4gICAgX3RoaXMuYXV0b1JlbW90ZVRleHRUcmFja3NfID0gbmV3IEFMTC50ZXh0Lkxpc3RDbGFzcygpO1xuXG4gICAgX3RoaXMuaW5pdFRyYWNrTGlzdGVuZXJzKCk7XG5cbiAgICAvLyBUdXJuIG9uIGNvbXBvbmVudCB0YXAgZXZlbnRzIG9ubHkgaWYgbm90IHVzaW5nIG5hdGl2ZSBjb250cm9sc1xuICAgIGlmICghb3B0aW9ucy5uYXRpdmVDb250cm9sc0ZvclRvdWNoKSB7XG4gICAgICBfdGhpcy5lbWl0VGFwRXZlbnRzKCk7XG4gICAgfVxuXG4gICAgaWYgKF90aGlzLmNvbnN0cnVjdG9yKSB7XG4gICAgICBfdGhpcy5uYW1lXyA9IF90aGlzLmNvbnN0cnVjdG9yLm5hbWUgfHwgJ1Vua25vd24gVGVjaCc7XG4gICAgfVxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHNwZWNpYWwgZnVuY3Rpb24gdG8gdHJpZ2dlciBzb3VyY2Ugc2V0IGluIGEgd2F5IHRoYXQgd2lsbCBhbGxvdyBwbGF5ZXJcbiAgICogdG8gcmUtdHJpZ2dlciBpZiB0aGUgcGxheWVyIG9yIHRlY2ggYXJlIG5vdCByZWFkeSB5ZXQuXG4gICAqXG4gICAqIEBmaXJlcyBUZWNoI3NvdXJjZXNldFxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3JjIFRoZSBzb3VyY2Ugc3RyaW5nIGF0IHRoZSB0aW1lIG9mIHRoZSBzb3VyY2UgY2hhbmdpbmcuXG4gICAqL1xuXG5cbiAgVGVjaC5wcm90b3R5cGUudHJpZ2dlclNvdXJjZXNldCA9IGZ1bmN0aW9uIHRyaWdnZXJTb3VyY2VzZXQoc3JjKSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICBpZiAoIXRoaXMuaXNSZWFkeV8pIHtcbiAgICAgIC8vIG9uIGluaXRpYWwgcmVhZHkgd2UgaGF2ZSB0byB0cmlnZ2VyIHNvdXJjZSBzZXRcbiAgICAgIC8vIDFtcyBhZnRlciByZWFkeSBzbyB0aGF0IHBsYXllciBjYW4gd2F0Y2ggZm9yIGl0LlxuICAgICAgdGhpcy5vbmUoJ3JlYWR5JywgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3RoaXMyLnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBfdGhpczIudHJpZ2dlclNvdXJjZXNldChzcmMpO1xuICAgICAgICB9LCAxKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZpcmVkIHdoZW4gdGhlIHNvdXJjZSBpcyBzZXQgb24gdGhlIHRlY2ggY2F1c2luZyB0aGUgbWVkaWEgZWxlbWVudFxuICAgICAqIHRvIHJlbG9hZC5cbiAgICAgKlxuICAgICAqIEBzZWUge0BsaW5rIFBsYXllciNldmVudDpzb3VyY2VzZXR9XG4gICAgICogQGV2ZW50IFRlY2gjc291cmNlc2V0XG4gICAgICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICAgICAqL1xuICAgIHRoaXMudHJpZ2dlcih7XG4gICAgICBzcmM6IHNyYyxcbiAgICAgIHR5cGU6ICdzb3VyY2VzZXQnXG4gICAgfSk7XG4gIH07XG5cbiAgLyogRmFsbGJhY2tzIGZvciB1bnN1cHBvcnRlZCBldmVudCB0eXBlc1xuICA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xuXG4gIC8qKlxuICAgKiBQb2x5ZmlsbCB0aGUgYHByb2dyZXNzYCBldmVudCBmb3IgYnJvd3NlcnMgdGhhdCBkb24ndCBzdXBwb3J0IGl0IG5hdGl2ZWx5LlxuICAgKlxuICAgKiBAc2VlIHtAbGluayBUZWNoI3RyYWNrUHJvZ3Jlc3N9XG4gICAqL1xuXG5cbiAgVGVjaC5wcm90b3R5cGUubWFudWFsUHJvZ3Jlc3NPbiA9IGZ1bmN0aW9uIG1hbnVhbFByb2dyZXNzT24oKSB7XG4gICAgdGhpcy5vbignZHVyYXRpb25jaGFuZ2UnLCB0aGlzLm9uRHVyYXRpb25DaGFuZ2UpO1xuXG4gICAgdGhpcy5tYW51YWxQcm9ncmVzcyA9IHRydWU7XG5cbiAgICAvLyBUcmlnZ2VyIHByb2dyZXNzIHdhdGNoaW5nIHdoZW4gYSBzb3VyY2UgYmVnaW5zIGxvYWRpbmdcbiAgICB0aGlzLm9uZSgncmVhZHknLCB0aGlzLnRyYWNrUHJvZ3Jlc3MpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUdXJuIG9mZiB0aGUgcG9seWZpbGwgZm9yIGBwcm9ncmVzc2AgZXZlbnRzIHRoYXQgd2FzIGNyZWF0ZWQgaW5cbiAgICoge0BsaW5rIFRlY2gjbWFudWFsUHJvZ3Jlc3NPbn1cbiAgICovXG5cblxuICBUZWNoLnByb3RvdHlwZS5tYW51YWxQcm9ncmVzc09mZiA9IGZ1bmN0aW9uIG1hbnVhbFByb2dyZXNzT2ZmKCkge1xuICAgIHRoaXMubWFudWFsUHJvZ3Jlc3MgPSBmYWxzZTtcbiAgICB0aGlzLnN0b3BUcmFja2luZ1Byb2dyZXNzKCk7XG5cbiAgICB0aGlzLm9mZignZHVyYXRpb25jaGFuZ2UnLCB0aGlzLm9uRHVyYXRpb25DaGFuZ2UpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUaGlzIGlzIHVzZWQgdG8gdHJpZ2dlciBhIGBwcm9ncmVzc2AgZXZlbnQgd2hlbiB0aGUgYnVmZmVyZWQgcGVyY2VudCBjaGFuZ2VzLiBJdFxuICAgKiBzZXRzIGFuIGludGVydmFsIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBjYWxsZWQgZXZlcnkgNTAwIG1pbGxpc2Vjb25kcyB0byBjaGVjayBpZiB0aGVcbiAgICogYnVmZmVyIGVuZCBwZXJjZW50IGhhcyBjaGFuZ2VkLlxuICAgKlxuICAgKiA+IFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIGJ5IHtAbGluayBUZWNoI21hbnVhbFByb2dyZXNzT259XG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IGV2ZW50XG4gICAqICAgICAgICBUaGUgYHJlYWR5YCBldmVudCB0aGF0IGNhdXNlZCB0aGlzIHRvIHJ1bi5cbiAgICpcbiAgICogQGxpc3RlbnMgVGVjaCNyZWFkeVxuICAgKiBAZmlyZXMgVGVjaCNwcm9ncmVzc1xuICAgKi9cblxuXG4gIFRlY2gucHJvdG90eXBlLnRyYWNrUHJvZ3Jlc3MgPSBmdW5jdGlvbiB0cmFja1Byb2dyZXNzKGV2ZW50KSB7XG4gICAgdGhpcy5zdG9wVHJhY2tpbmdQcm9ncmVzcygpO1xuICAgIHRoaXMucHJvZ3Jlc3NJbnRlcnZhbCA9IHRoaXMuc2V0SW50ZXJ2YWwoYmluZCh0aGlzLCBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBEb24ndCB0cmlnZ2VyIHVubGVzcyBidWZmZXJlZCBhbW91bnQgaXMgZ3JlYXRlciB0aGFuIGxhc3QgdGltZVxuXG4gICAgICB2YXIgbnVtQnVmZmVyZWRQZXJjZW50ID0gdGhpcy5idWZmZXJlZFBlcmNlbnQoKTtcblxuICAgICAgaWYgKHRoaXMuYnVmZmVyZWRQZXJjZW50XyAhPT0gbnVtQnVmZmVyZWRQZXJjZW50KSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZWUge0BsaW5rIFBsYXllciNwcm9ncmVzc31cbiAgICAgICAgICpcbiAgICAgICAgICogQGV2ZW50IFRlY2gjcHJvZ3Jlc3NcbiAgICAgICAgICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50cmlnZ2VyKCdwcm9ncmVzcycpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmJ1ZmZlcmVkUGVyY2VudF8gPSBudW1CdWZmZXJlZFBlcmNlbnQ7XG5cbiAgICAgIGlmIChudW1CdWZmZXJlZFBlcmNlbnQgPT09IDEpIHtcbiAgICAgICAgdGhpcy5zdG9wVHJhY2tpbmdQcm9ncmVzcygpO1xuICAgICAgfVxuICAgIH0pLCA1MDApO1xuICB9O1xuXG4gIC8qKlxuICAgKiBVcGRhdGUgb3VyIGludGVybmFsIGR1cmF0aW9uIG9uIGEgYGR1cmF0aW9uY2hhbmdlYCBldmVudCBieSBjYWxsaW5nXG4gICAqIHtAbGluayBUZWNoI2R1cmF0aW9ufS5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gZXZlbnRcbiAgICogICAgICAgIFRoZSBgZHVyYXRpb25jaGFuZ2VgIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgdG8gcnVuLlxuICAgKlxuICAgKiBAbGlzdGVucyBUZWNoI2R1cmF0aW9uY2hhbmdlXG4gICAqL1xuXG5cbiAgVGVjaC5wcm90b3R5cGUub25EdXJhdGlvbkNoYW5nZSA9IGZ1bmN0aW9uIG9uRHVyYXRpb25DaGFuZ2UoZXZlbnQpIHtcbiAgICB0aGlzLmR1cmF0aW9uXyA9IHRoaXMuZHVyYXRpb24oKTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IGFuZCBjcmVhdGUgYSBgVGltZVJhbmdlYCBvYmplY3QgZm9yIGJ1ZmZlcmluZy5cbiAgICpcbiAgICogQHJldHVybiB7VGltZVJhbmdlfVxuICAgKiAgICAgICAgIFRoZSB0aW1lIHJhbmdlIG9iamVjdCB0aGF0IHdhcyBjcmVhdGVkLlxuICAgKi9cblxuXG4gIFRlY2gucHJvdG90eXBlLmJ1ZmZlcmVkID0gZnVuY3Rpb24gYnVmZmVyZWQoKSB7XG4gICAgcmV0dXJuIGNyZWF0ZVRpbWVSYW5nZXMoMCwgMCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgcGVyY2VudGFnZSBvZiB0aGUgY3VycmVudCB2aWRlbyB0aGF0IGlzIGN1cnJlbnRseSBidWZmZXJlZC5cbiAgICpcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKiAgICAgICAgIEEgbnVtYmVyIGZyb20gMCB0byAxIHRoYXQgcmVwcmVzZW50cyB0aGUgZGVjaW1hbCBwZXJjZW50YWdlIG9mIHRoZVxuICAgKiAgICAgICAgIHZpZGVvIHRoYXQgaXMgYnVmZmVyZWQuXG4gICAqXG4gICAqL1xuXG5cbiAgVGVjaC5wcm90b3R5cGUuYnVmZmVyZWRQZXJjZW50ID0gZnVuY3Rpb24gYnVmZmVyZWRQZXJjZW50JCQxKCkge1xuICAgIHJldHVybiBidWZmZXJlZFBlcmNlbnQodGhpcy5idWZmZXJlZCgpLCB0aGlzLmR1cmF0aW9uXyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFR1cm4gb2ZmIHRoZSBwb2x5ZmlsbCBmb3IgYHByb2dyZXNzYCBldmVudHMgdGhhdCB3YXMgY3JlYXRlZCBpblxuICAgKiB7QGxpbmsgVGVjaCNtYW51YWxQcm9ncmVzc09ufVxuICAgKiBTdG9wIG1hbnVhbGx5IHRyYWNraW5nIHByb2dyZXNzIGV2ZW50cyBieSBjbGVhcmluZyB0aGUgaW50ZXJ2YWwgdGhhdCB3YXMgc2V0IGluXG4gICAqIHtAbGluayBUZWNoI3RyYWNrUHJvZ3Jlc3N9LlxuICAgKi9cblxuXG4gIFRlY2gucHJvdG90eXBlLnN0b3BUcmFja2luZ1Byb2dyZXNzID0gZnVuY3Rpb24gc3RvcFRyYWNraW5nUHJvZ3Jlc3MoKSB7XG4gICAgdGhpcy5jbGVhckludGVydmFsKHRoaXMucHJvZ3Jlc3NJbnRlcnZhbCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFBvbHlmaWxsIHRoZSBgdGltZXVwZGF0ZWAgZXZlbnQgZm9yIGJyb3dzZXJzIHRoYXQgZG9uJ3Qgc3VwcG9ydCBpdC5cbiAgICpcbiAgICogQHNlZSB7QGxpbmsgVGVjaCN0cmFja0N1cnJlbnRUaW1lfVxuICAgKi9cblxuXG4gIFRlY2gucHJvdG90eXBlLm1hbnVhbFRpbWVVcGRhdGVzT24gPSBmdW5jdGlvbiBtYW51YWxUaW1lVXBkYXRlc09uKCkge1xuICAgIHRoaXMubWFudWFsVGltZVVwZGF0ZXMgPSB0cnVlO1xuXG4gICAgdGhpcy5vbigncGxheScsIHRoaXMudHJhY2tDdXJyZW50VGltZSk7XG4gICAgdGhpcy5vbigncGF1c2UnLCB0aGlzLnN0b3BUcmFja2luZ0N1cnJlbnRUaW1lKTtcbiAgfTtcblxuICAvKipcbiAgICogVHVybiBvZmYgdGhlIHBvbHlmaWxsIGZvciBgdGltZXVwZGF0ZWAgZXZlbnRzIHRoYXQgd2FzIGNyZWF0ZWQgaW5cbiAgICoge0BsaW5rIFRlY2gjbWFudWFsVGltZVVwZGF0ZXNPbn1cbiAgICovXG5cblxuICBUZWNoLnByb3RvdHlwZS5tYW51YWxUaW1lVXBkYXRlc09mZiA9IGZ1bmN0aW9uIG1hbnVhbFRpbWVVcGRhdGVzT2ZmKCkge1xuICAgIHRoaXMubWFudWFsVGltZVVwZGF0ZXMgPSBmYWxzZTtcbiAgICB0aGlzLnN0b3BUcmFja2luZ0N1cnJlbnRUaW1lKCk7XG4gICAgdGhpcy5vZmYoJ3BsYXknLCB0aGlzLnRyYWNrQ3VycmVudFRpbWUpO1xuICAgIHRoaXMub2ZmKCdwYXVzZScsIHRoaXMuc3RvcFRyYWNraW5nQ3VycmVudFRpbWUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXRzIHVwIGFuIGludGVydmFsIGZ1bmN0aW9uIHRvIHRyYWNrIGN1cnJlbnQgdGltZSBhbmQgdHJpZ2dlciBgdGltZXVwZGF0ZWAgZXZlcnlcbiAgICogMjUwIG1pbGxpc2Vjb25kcy5cbiAgICpcbiAgICogQGxpc3RlbnMgVGVjaCNwbGF5XG4gICAqIEB0cmlnZ2VycyBUZWNoI3RpbWV1cGRhdGVcbiAgICovXG5cblxuICBUZWNoLnByb3RvdHlwZS50cmFja0N1cnJlbnRUaW1lID0gZnVuY3Rpb24gdHJhY2tDdXJyZW50VGltZSgpIHtcbiAgICBpZiAodGhpcy5jdXJyZW50VGltZUludGVydmFsKSB7XG4gICAgICB0aGlzLnN0b3BUcmFja2luZ0N1cnJlbnRUaW1lKCk7XG4gICAgfVxuICAgIHRoaXMuY3VycmVudFRpbWVJbnRlcnZhbCA9IHRoaXMuc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKCkge1xuICAgICAgLyoqXG4gICAgICAgKiBUcmlnZ2VyZWQgYXQgYW4gaW50ZXJ2YWwgb2YgMjUwbXMgdG8gaW5kaWNhdGVkIHRoYXQgdGltZSBpcyBwYXNzaW5nIGluIHRoZSB2aWRlby5cbiAgICAgICAqXG4gICAgICAgKiBAZXZlbnQgVGVjaCN0aW1ldXBkYXRlXG4gICAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gICAgICAgKi9cbiAgICAgIHRoaXMudHJpZ2dlcih7IHR5cGU6ICd0aW1ldXBkYXRlJywgdGFyZ2V0OiB0aGlzLCBtYW51YWxseVRyaWdnZXJlZDogdHJ1ZSB9KTtcblxuICAgICAgLy8gNDIgPSAyNCBmcHMgLy8gMjUwIGlzIHdoYXQgV2Via2l0IHVzZXMgLy8gRkYgdXNlcyAxNVxuICAgIH0sIDI1MCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFN0b3AgdGhlIGludGVydmFsIGZ1bmN0aW9uIGNyZWF0ZWQgaW4ge0BsaW5rIFRlY2gjdHJhY2tDdXJyZW50VGltZX0gc28gdGhhdCB0aGVcbiAgICogYHRpbWV1cGRhdGVgIGV2ZW50IGlzIG5vIGxvbmdlciB0cmlnZ2VyZWQuXG4gICAqXG4gICAqIEBsaXN0ZW5zIHtUZWNoI3BhdXNlfVxuICAgKi9cblxuXG4gIFRlY2gucHJvdG90eXBlLnN0b3BUcmFja2luZ0N1cnJlbnRUaW1lID0gZnVuY3Rpb24gc3RvcFRyYWNraW5nQ3VycmVudFRpbWUoKSB7XG4gICAgdGhpcy5jbGVhckludGVydmFsKHRoaXMuY3VycmVudFRpbWVJbnRlcnZhbCk7XG5cbiAgICAvLyAjMTAwMiAtIGlmIHRoZSB2aWRlbyBlbmRzIHJpZ2h0IGJlZm9yZSB0aGUgbmV4dCB0aW1ldXBkYXRlIHdvdWxkIGhhcHBlbixcbiAgICAvLyB0aGUgcHJvZ3Jlc3MgYmFyIHdvbid0IG1ha2UgaXQgYWxsIHRoZSB3YXkgdG8gdGhlIGVuZFxuICAgIHRoaXMudHJpZ2dlcih7IHR5cGU6ICd0aW1ldXBkYXRlJywgdGFyZ2V0OiB0aGlzLCBtYW51YWxseVRyaWdnZXJlZDogdHJ1ZSB9KTtcbiAgfTtcblxuICAvKipcbiAgICogVHVybiBvZmYgYWxsIGV2ZW50IHBvbHlmaWxscywgY2xlYXIgdGhlIGBUZWNoYHMge0BsaW5rIEF1ZGlvVHJhY2tMaXN0fSxcbiAgICoge0BsaW5rIFZpZGVvVHJhY2tMaXN0fSwgYW5kIHtAbGluayBUZXh0VHJhY2tMaXN0fSwgYW5kIGRpc3Bvc2Ugb2YgdGhpcyBUZWNoLlxuICAgKlxuICAgKiBAZmlyZXMgQ29tcG9uZW50I2Rpc3Bvc2VcbiAgICovXG5cblxuICBUZWNoLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gZGlzcG9zZSgpIHtcblxuICAgIC8vIGNsZWFyIG91dCBhbGwgdHJhY2tzIGJlY2F1c2Ugd2UgY2FuJ3QgcmV1c2UgdGhlbSBiZXR3ZWVuIHRlY2hzXG4gICAgdGhpcy5jbGVhclRyYWNrcyhOT1JNQUwubmFtZXMpO1xuXG4gICAgLy8gVHVybiBvZmYgYW55IG1hbnVhbCBwcm9ncmVzcyBvciB0aW1ldXBkYXRlIHRyYWNraW5nXG4gICAgaWYgKHRoaXMubWFudWFsUHJvZ3Jlc3MpIHtcbiAgICAgIHRoaXMubWFudWFsUHJvZ3Jlc3NPZmYoKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5tYW51YWxUaW1lVXBkYXRlcykge1xuICAgICAgdGhpcy5tYW51YWxUaW1lVXBkYXRlc09mZigpO1xuICAgIH1cblxuICAgIF9Db21wb25lbnQucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcbiAgfTtcblxuICAvKipcbiAgICogQ2xlYXIgb3V0IGEgc2luZ2xlIGBUcmFja0xpc3RgIG9yIGFuIGFycmF5IG9mIGBUcmFja0xpc3RzYCBnaXZlbiB0aGVpciBuYW1lcy5cbiAgICpcbiAgICogPiBOb3RlOiBUZWNocyB3aXRob3V0IHNvdXJjZSBoYW5kbGVycyBzaG91bGQgY2FsbCB0aGlzIGJldHdlZW4gc291cmNlcyBmb3IgYHZpZGVvYFxuICAgKiAgICAgICAgICYgYGF1ZGlvYCB0cmFja3MuIFlvdSBkb24ndCB3YW50IHRvIHVzZSB0aGVtIGJldHdlZW4gdHJhY2tzIVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ1tdfHN0cmluZ30gdHlwZXNcbiAgICogICAgICAgIFRyYWNrTGlzdCBuYW1lcyB0byBjbGVhciwgdmFsaWQgbmFtZXMgYXJlIGB2aWRlb2AsIGBhdWRpb2AsIGFuZFxuICAgKiAgICAgICAgYHRleHRgLlxuICAgKi9cblxuXG4gIFRlY2gucHJvdG90eXBlLmNsZWFyVHJhY2tzID0gZnVuY3Rpb24gY2xlYXJUcmFja3ModHlwZXMpIHtcbiAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgIHR5cGVzID0gW10uY29uY2F0KHR5cGVzKTtcbiAgICAvLyBjbGVhciBvdXQgYWxsIHRyYWNrcyBiZWNhdXNlIHdlIGNhbid0IHJldXNlIHRoZW0gYmV0d2VlbiB0ZWNoc1xuICAgIHR5cGVzLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgIHZhciBsaXN0ID0gX3RoaXMzW3R5cGUgKyAnVHJhY2tzJ10oKSB8fCBbXTtcbiAgICAgIHZhciBpID0gbGlzdC5sZW5ndGg7XG5cbiAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgdmFyIHRyYWNrID0gbGlzdFtpXTtcblxuICAgICAgICBpZiAodHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICAgICAgX3RoaXMzLnJlbW92ZVJlbW90ZVRleHRUcmFjayh0cmFjayk7XG4gICAgICAgIH1cbiAgICAgICAgbGlzdC5yZW1vdmVUcmFjayh0cmFjayk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhbnkgVGV4dFRyYWNrcyBhZGRlZCB2aWEgYWRkUmVtb3RlVGV4dFRyYWNrIHRoYXQgYXJlXG4gICAqIGZsYWdnZWQgZm9yIGF1dG9tYXRpYyBnYXJiYWdlIGNvbGxlY3Rpb25cbiAgICovXG5cblxuICBUZWNoLnByb3RvdHlwZS5jbGVhbnVwQXV0b1RleHRUcmFja3MgPSBmdW5jdGlvbiBjbGVhbnVwQXV0b1RleHRUcmFja3MoKSB7XG4gICAgdmFyIGxpc3QgPSB0aGlzLmF1dG9SZW1vdGVUZXh0VHJhY2tzXyB8fCBbXTtcbiAgICB2YXIgaSA9IGxpc3QubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgdmFyIHRyYWNrID0gbGlzdFtpXTtcblxuICAgICAgdGhpcy5yZW1vdmVSZW1vdGVUZXh0VHJhY2sodHJhY2spO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUmVzZXQgdGhlIHRlY2gsIHdoaWNoIHdpbGwgcmVtb3ZlcyBhbGwgc291cmNlcyBhbmQgcmVzZXQgdGhlIGludGVybmFsIHJlYWR5U3RhdGUuXG4gICAqXG4gICAqIEBhYnN0cmFjdFxuICAgKi9cblxuXG4gIFRlY2gucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gcmVzZXQoKSB7fTtcblxuICAvKipcbiAgICogR2V0IG9yIHNldCBhbiBlcnJvciBvbiB0aGUgVGVjaC5cbiAgICpcbiAgICogQHBhcmFtIHtNZWRpYUVycm9yfSBbZXJyXVxuICAgKiAgICAgICAgRXJyb3IgdG8gc2V0IG9uIHRoZSBUZWNoXG4gICAqXG4gICAqIEByZXR1cm4ge01lZGlhRXJyb3J8bnVsbH1cbiAgICogICAgICAgICBUaGUgY3VycmVudCBlcnJvciBvYmplY3Qgb24gdGhlIHRlY2gsIG9yIG51bGwgaWYgdGhlcmUgaXNuJ3Qgb25lLlxuICAgKi9cblxuXG4gIFRlY2gucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gZXJyb3IoZXJyKSB7XG4gICAgaWYgKGVyciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLmVycm9yXyA9IG5ldyBNZWRpYUVycm9yKGVycik7XG4gICAgICB0aGlzLnRyaWdnZXIoJ2Vycm9yJyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmVycm9yXztcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgYFRpbWVSYW5nZWBzIHRoYXQgaGF2ZSBiZWVuIHBsYXllZCB0aHJvdWdoIGZvciB0aGUgY3VycmVudCBzb3VyY2UuXG4gICAqXG4gICAqID4gTk9URTogVGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBpbmNvbXBsZXRlLiBJdCBkb2VzIG5vdCB0cmFjayB0aGUgcGxheWVkIGBUaW1lUmFuZ2VgLlxuICAgKiAgICAgICAgIEl0IG9ubHkgY2hlY2tzIHdldGhlciB0aGUgc291cmNlIGhhcyBwbGF5ZWQgYXQgYWxsIG9yIG5vdC5cbiAgICpcbiAgICogQHJldHVybiB7VGltZVJhbmdlfVxuICAgKiAgICAgICAgIC0gQSBzaW5nbGUgdGltZSByYW5nZSBpZiB0aGlzIHZpZGVvIGhhcyBwbGF5ZWRcbiAgICogICAgICAgICAtIEFuIGVtcHR5IHNldCBvZiByYW5nZXMgaWYgbm90LlxuICAgKi9cblxuXG4gIFRlY2gucHJvdG90eXBlLnBsYXllZCA9IGZ1bmN0aW9uIHBsYXllZCgpIHtcbiAgICBpZiAodGhpcy5oYXNTdGFydGVkXykge1xuICAgICAgcmV0dXJuIGNyZWF0ZVRpbWVSYW5nZXMoMCwgMCk7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVUaW1lUmFuZ2VzKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENhdXNlcyBhIG1hbnVhbCB0aW1lIHVwZGF0ZSB0byBvY2N1ciBpZiB7QGxpbmsgVGVjaCNtYW51YWxUaW1lVXBkYXRlc09ufSB3YXNcbiAgICogcHJldmlvdXNseSBjYWxsZWQuXG4gICAqXG4gICAqIEBmaXJlcyBUZWNoI3RpbWV1cGRhdGVcbiAgICovXG5cblxuICBUZWNoLnByb3RvdHlwZS5zZXRDdXJyZW50VGltZSA9IGZ1bmN0aW9uIHNldEN1cnJlbnRUaW1lKCkge1xuICAgIC8vIGltcHJvdmUgdGhlIGFjY3VyYWN5IG9mIG1hbnVhbCB0aW1ldXBkYXRlc1xuICAgIGlmICh0aGlzLm1hbnVhbFRpbWVVcGRhdGVzKSB7XG4gICAgICAvKipcbiAgICAgICAqIEEgbWFudWFsIGB0aW1ldXBkYXRlYCBldmVudC5cbiAgICAgICAqXG4gICAgICAgKiBAZXZlbnQgVGVjaCN0aW1ldXBkYXRlXG4gICAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gICAgICAgKi9cbiAgICAgIHRoaXMudHJpZ2dlcih7IHR5cGU6ICd0aW1ldXBkYXRlJywgdGFyZ2V0OiB0aGlzLCBtYW51YWxseVRyaWdnZXJlZDogdHJ1ZSB9KTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFR1cm4gb24gbGlzdGVuZXJzIGZvciB7QGxpbmsgVmlkZW9UcmFja0xpc3R9LCB7QGxpbmsge0F1ZGlvVHJhY2tMaXN0fSwgYW5kXG4gICAqIHtAbGluayBUZXh0VHJhY2tMaXN0fSBldmVudHMuXG4gICAqXG4gICAqIFRoaXMgYWRkcyB7QGxpbmsgRXZlbnRUYXJnZXR+RXZlbnRMaXN0ZW5lcnN9IGZvciBgYWRkdHJhY2tgLCBhbmQgIGByZW1vdmV0cmFja2AuXG4gICAqXG4gICAqIEBmaXJlcyBUZWNoI2F1ZGlvdHJhY2tjaGFuZ2VcbiAgICogQGZpcmVzIFRlY2gjdmlkZW90cmFja2NoYW5nZVxuICAgKiBAZmlyZXMgVGVjaCN0ZXh0dHJhY2tjaGFuZ2VcbiAgICovXG5cblxuICBUZWNoLnByb3RvdHlwZS5pbml0VHJhY2tMaXN0ZW5lcnMgPSBmdW5jdGlvbiBpbml0VHJhY2tMaXN0ZW5lcnMoKSB7XG4gICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgd2hlbiB0cmFja3MgYXJlIGFkZGVkIG9yIHJlbW92ZWQgb24gdGhlIFRlY2gge0BsaW5rIEF1ZGlvVHJhY2tMaXN0fVxuICAgICAqXG4gICAgICogQGV2ZW50IFRlY2gjYXVkaW90cmFja2NoYW5nZVxuICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCB3aGVuIHRyYWNrcyBhcmUgYWRkZWQgb3IgcmVtb3ZlZCBvbiB0aGUgVGVjaCB7QGxpbmsgVmlkZW9UcmFja0xpc3R9XG4gICAgICpcbiAgICAgKiBAZXZlbnQgVGVjaCN2aWRlb3RyYWNrY2hhbmdlXG4gICAgICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIHdoZW4gdHJhY2tzIGFyZSBhZGRlZCBvciByZW1vdmVkIG9uIHRoZSBUZWNoIHtAbGluayBUZXh0VHJhY2tMaXN0fVxuICAgICAqXG4gICAgICogQGV2ZW50IFRlY2gjdGV4dHRyYWNrY2hhbmdlXG4gICAgICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICAgICAqL1xuICAgIE5PUk1BTC5uYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICB2YXIgcHJvcHMgPSBOT1JNQUxbbmFtZV07XG4gICAgICB2YXIgdHJhY2tMaXN0Q2hhbmdlcyA9IGZ1bmN0aW9uIHRyYWNrTGlzdENoYW5nZXMoKSB7XG4gICAgICAgIF90aGlzNC50cmlnZ2VyKG5hbWUgKyAndHJhY2tjaGFuZ2UnKTtcbiAgICAgIH07XG5cbiAgICAgIHZhciB0cmFja3MgPSBfdGhpczRbcHJvcHMuZ2V0dGVyTmFtZV0oKTtcblxuICAgICAgdHJhY2tzLmFkZEV2ZW50TGlzdGVuZXIoJ3JlbW92ZXRyYWNrJywgdHJhY2tMaXN0Q2hhbmdlcyk7XG4gICAgICB0cmFja3MuYWRkRXZlbnRMaXN0ZW5lcignYWRkdHJhY2snLCB0cmFja0xpc3RDaGFuZ2VzKTtcblxuICAgICAgX3RoaXM0Lm9uKCdkaXNwb3NlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICB0cmFja3MucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVtb3ZldHJhY2snLCB0cmFja0xpc3RDaGFuZ2VzKTtcbiAgICAgICAgdHJhY2tzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2FkZHRyYWNrJywgdHJhY2tMaXN0Q2hhbmdlcyk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcblxuICAvKipcbiAgICogRW11bGF0ZSBUZXh0VHJhY2tzIHVzaW5nIHZ0dC5qcyBpZiBuZWNlc3NhcnlcbiAgICpcbiAgICogQGZpcmVzIFRlY2gjdnR0anNsb2FkZWRcbiAgICogQGZpcmVzIFRlY2gjdnR0anNlcnJvclxuICAgKi9cblxuXG4gIFRlY2gucHJvdG90eXBlLmFkZFdlYlZ0dFNjcmlwdF8gPSBmdW5jdGlvbiBhZGRXZWJWdHRTY3JpcHRfKCkge1xuICAgIHZhciBfdGhpczUgPSB0aGlzO1xuXG4gICAgaWYgKHdpbmRvdy5XZWJWVFQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBJbml0aWFsbHksIFRlY2guZWxfIGlzIGEgY2hpbGQgb2YgYSBkdW1teS1kaXYgd2FpdCB1bnRpbCB0aGUgQ29tcG9uZW50IHN5c3RlbVxuICAgIC8vIHNpZ25hbHMgdGhhdCB0aGUgVGVjaCBpcyByZWFkeSBhdCB3aGljaCBwb2ludCBUZWNoLmVsXyBpcyBwYXJ0IG9mIHRoZSBET01cbiAgICAvLyBiZWZvcmUgaW5zZXJ0aW5nIHRoZSBXZWJWVFQgc2NyaXB0XG4gICAgaWYgKGRvY3VtZW50LmJvZHkuY29udGFpbnModGhpcy5lbCgpKSkge1xuXG4gICAgICAvLyBsb2FkIHZpYSByZXF1aXJlIGlmIGF2YWlsYWJsZSBhbmQgdnR0LmpzIHNjcmlwdCBsb2NhdGlvbiB3YXMgbm90IHBhc3NlZCBpblxuICAgICAgLy8gYXMgYW4gb3B0aW9uLiBub3Z0dCBidWlsZHMgd2lsbCB0dXJuIHRoZSBhYm92ZSByZXF1aXJlIGNhbGwgaW50byBhbiBlbXB0eSBvYmplY3RcbiAgICAgIC8vIHdoaWNoIHdpbGwgY2F1c2UgdGhpcyBpZiBjaGVjayB0byBhbHdheXMgZmFpbC5cbiAgICAgIGlmICghdGhpcy5vcHRpb25zX1sndnR0LmpzJ10gJiYgaXNQbGFpbih2dHQpICYmIE9iamVjdC5rZXlzKHZ0dCkubGVuZ3RoID4gMCkge1xuICAgICAgICB0aGlzLnRyaWdnZXIoJ3Z0dGpzbG9hZGVkJyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gbG9hZCB2dHQuanMgdmlhIHRoZSBzY3JpcHQgbG9jYXRpb24gb3B0aW9uIG9yIHRoZSBjZG4gb2Ygbm8gbG9jYXRpb24gd2FzXG4gICAgICAvLyBwYXNzZWQgaW5cbiAgICAgIHZhciBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcblxuICAgICAgc2NyaXB0LnNyYyA9IHRoaXMub3B0aW9uc19bJ3Z0dC5qcyddIHx8ICdodHRwczovL3Zqcy56ZW5jZG4ubmV0L3Z0dGpzLzAuMTIuNC92dHQubWluLmpzJztcbiAgICAgIHNjcmlwdC5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlZCB3aGVuIHZ0dC5qcyBpcyBsb2FkZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBldmVudCBUZWNoI3Z0dGpzbG9hZGVkXG4gICAgICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAgICAgICAgICovXG4gICAgICAgIF90aGlzNS50cmlnZ2VyKCd2dHRqc2xvYWRlZCcpO1xuICAgICAgfTtcbiAgICAgIHNjcmlwdC5vbmVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZWQgd2hlbiB2dHQuanMgd2FzIG5vdCBsb2FkZWQgZHVlIHRvIGFuIGVycm9yXG4gICAgICAgICAqXG4gICAgICAgICAqIEBldmVudCBUZWNoI3Z0dGpzbG9hZGVkXG4gICAgICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAgICAgICAgICovXG4gICAgICAgIF90aGlzNS50cmlnZ2VyKCd2dHRqc2Vycm9yJyk7XG4gICAgICB9O1xuICAgICAgdGhpcy5vbignZGlzcG9zZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2NyaXB0Lm9ubG9hZCA9IG51bGw7XG4gICAgICAgIHNjcmlwdC5vbmVycm9yID0gbnVsbDtcbiAgICAgIH0pO1xuICAgICAgLy8gYnV0IGhhdmUgbm90IGxvYWRlZCB5ZXQgYW5kIHdlIHNldCBpdCB0byB0cnVlIGJlZm9yZSB0aGUgaW5qZWN0IHNvIHRoYXRcbiAgICAgIC8vIHdlIGRvbid0IG92ZXJ3cml0ZSB0aGUgaW5qZWN0ZWQgd2luZG93LldlYlZUVCBpZiBpdCBsb2FkcyByaWdodCBhd2F5XG4gICAgICB3aW5kb3cuV2ViVlRUID0gdHJ1ZTtcbiAgICAgIHRoaXMuZWwoKS5wYXJlbnROb2RlLmFwcGVuZENoaWxkKHNjcmlwdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVhZHkodGhpcy5hZGRXZWJWdHRTY3JpcHRfKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEVtdWxhdGUgdGV4dHRyYWNrc1xuICAgKlxuICAgKi9cblxuXG4gIFRlY2gucHJvdG90eXBlLmVtdWxhdGVUZXh0VHJhY2tzID0gZnVuY3Rpb24gZW11bGF0ZVRleHRUcmFja3MoKSB7XG4gICAgdmFyIF90aGlzNiA9IHRoaXM7XG5cbiAgICB2YXIgdHJhY2tzID0gdGhpcy50ZXh0VHJhY2tzKCk7XG4gICAgdmFyIHJlbW90ZVRyYWNrcyA9IHRoaXMucmVtb3RlVGV4dFRyYWNrcygpO1xuICAgIHZhciBoYW5kbGVBZGRUcmFjayA9IGZ1bmN0aW9uIGhhbmRsZUFkZFRyYWNrKGUpIHtcbiAgICAgIHJldHVybiB0cmFja3MuYWRkVHJhY2soZS50cmFjayk7XG4gICAgfTtcbiAgICB2YXIgaGFuZGxlUmVtb3ZlVHJhY2sgPSBmdW5jdGlvbiBoYW5kbGVSZW1vdmVUcmFjayhlKSB7XG4gICAgICByZXR1cm4gdHJhY2tzLnJlbW92ZVRyYWNrKGUudHJhY2spO1xuICAgIH07XG5cbiAgICByZW1vdGVUcmFja3Mub24oJ2FkZHRyYWNrJywgaGFuZGxlQWRkVHJhY2spO1xuICAgIHJlbW90ZVRyYWNrcy5vbigncmVtb3ZldHJhY2snLCBoYW5kbGVSZW1vdmVUcmFjayk7XG5cbiAgICB0aGlzLmFkZFdlYlZ0dFNjcmlwdF8oKTtcblxuICAgIHZhciB1cGRhdGVEaXNwbGF5ID0gZnVuY3Rpb24gdXBkYXRlRGlzcGxheSgpIHtcbiAgICAgIHJldHVybiBfdGhpczYudHJpZ2dlcigndGV4dHRyYWNrY2hhbmdlJyk7XG4gICAgfTtcblxuICAgIHZhciB0ZXh0VHJhY2tzQ2hhbmdlcyA9IGZ1bmN0aW9uIHRleHRUcmFja3NDaGFuZ2VzKCkge1xuICAgICAgdXBkYXRlRGlzcGxheSgpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyYWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgdHJhY2sgPSB0cmFja3NbaV07XG5cbiAgICAgICAgdHJhY2sucmVtb3ZlRXZlbnRMaXN0ZW5lcignY3VlY2hhbmdlJywgdXBkYXRlRGlzcGxheSk7XG4gICAgICAgIGlmICh0cmFjay5tb2RlID09PSAnc2hvd2luZycpIHtcbiAgICAgICAgICB0cmFjay5hZGRFdmVudExpc3RlbmVyKCdjdWVjaGFuZ2UnLCB1cGRhdGVEaXNwbGF5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICB0ZXh0VHJhY2tzQ2hhbmdlcygpO1xuICAgIHRyYWNrcy5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCB0ZXh0VHJhY2tzQ2hhbmdlcyk7XG4gICAgdHJhY2tzLmFkZEV2ZW50TGlzdGVuZXIoJ2FkZHRyYWNrJywgdGV4dFRyYWNrc0NoYW5nZXMpO1xuICAgIHRyYWNrcy5hZGRFdmVudExpc3RlbmVyKCdyZW1vdmV0cmFjaycsIHRleHRUcmFja3NDaGFuZ2VzKTtcblxuICAgIHRoaXMub24oJ2Rpc3Bvc2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgICByZW1vdGVUcmFja3Mub2ZmKCdhZGR0cmFjaycsIGhhbmRsZUFkZFRyYWNrKTtcbiAgICAgIHJlbW90ZVRyYWNrcy5vZmYoJ3JlbW92ZXRyYWNrJywgaGFuZGxlUmVtb3ZlVHJhY2spO1xuICAgICAgdHJhY2tzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHRleHRUcmFja3NDaGFuZ2VzKTtcbiAgICAgIHRyYWNrcy5yZW1vdmVFdmVudExpc3RlbmVyKCdhZGR0cmFjaycsIHRleHRUcmFja3NDaGFuZ2VzKTtcbiAgICAgIHRyYWNrcy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZW1vdmV0cmFjaycsIHRleHRUcmFja3NDaGFuZ2VzKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHRyYWNrID0gdHJhY2tzW2ldO1xuXG4gICAgICAgIHRyYWNrLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2N1ZWNoYW5nZScsIHVwZGF0ZURpc3BsYXkpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW5kIHJldHVybnMgYSByZW1vdGUge0BsaW5rIFRleHRUcmFja30gb2JqZWN0LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2luZFxuICAgKiAgICAgICAgYFRleHRUcmFja2Aga2luZCAoc3VidGl0bGVzLCBjYXB0aW9ucywgZGVzY3JpcHRpb25zLCBjaGFwdGVycywgb3IgbWV0YWRhdGEpXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbbGFiZWxdXG4gICAqICAgICAgICBMYWJlbCB0byBpZGVudGlmeSB0aGUgdGV4dCB0cmFja1xuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2xhbmd1YWdlXVxuICAgKiAgICAgICAgVHdvIGxldHRlciBsYW5ndWFnZSBhYmJyZXZpYXRpb25cbiAgICpcbiAgICogQHJldHVybiB7VGV4dFRyYWNrfVxuICAgKiAgICAgICAgIFRoZSBUZXh0VHJhY2sgdGhhdCBnZXRzIGNyZWF0ZWQuXG4gICAqL1xuXG5cbiAgVGVjaC5wcm90b3R5cGUuYWRkVGV4dFRyYWNrID0gZnVuY3Rpb24gYWRkVGV4dFRyYWNrKGtpbmQsIGxhYmVsLCBsYW5ndWFnZSkge1xuICAgIGlmICgha2luZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUZXh0VHJhY2sga2luZCBpcyByZXF1aXJlZCBidXQgd2FzIG5vdCBwcm92aWRlZCcpO1xuICAgIH1cblxuICAgIHJldHVybiBjcmVhdGVUcmFja0hlbHBlcih0aGlzLCBraW5kLCBsYWJlbCwgbGFuZ3VhZ2UpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gZW11bGF0ZWQgVGV4dFRyYWNrIGZvciB1c2UgYnkgYWRkUmVtb3RlVGV4dFRyYWNrXG4gICAqXG4gICAqIFRoaXMgaXMgaW50ZW5kZWQgdG8gYmUgb3ZlcnJpZGRlbiBieSBjbGFzc2VzIHRoYXQgaW5oZXJpdCBmcm9tXG4gICAqIFRlY2ggaW4gb3JkZXIgdG8gY3JlYXRlIG5hdGl2ZSBvciBjdXN0b20gVGV4dFRyYWNrcy5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogICAgICAgIFRoZSBvYmplY3Qgc2hvdWxkIGNvbnRhaW4gdGhlIG9wdGlvbnMgdG8gaW5pdGlhbGl6ZSB0aGUgVGV4dFRyYWNrIHdpdGguXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5raW5kXVxuICAgKiAgICAgICAgYFRleHRUcmFja2Aga2luZCAoc3VidGl0bGVzLCBjYXB0aW9ucywgZGVzY3JpcHRpb25zLCBjaGFwdGVycywgb3IgbWV0YWRhdGEpLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMubGFiZWxdLlxuICAgKiAgICAgICAgTGFiZWwgdG8gaWRlbnRpZnkgdGhlIHRleHQgdHJhY2tcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmxhbmd1YWdlXVxuICAgKiAgICAgICAgVHdvIGxldHRlciBsYW5ndWFnZSBhYmJyZXZpYXRpb24uXG4gICAqXG4gICAqIEByZXR1cm4ge0hUTUxUcmFja0VsZW1lbnR9XG4gICAqICAgICAgICAgVGhlIHRyYWNrIGVsZW1lbnQgdGhhdCBnZXRzIGNyZWF0ZWQuXG4gICAqL1xuXG5cbiAgVGVjaC5wcm90b3R5cGUuY3JlYXRlUmVtb3RlVGV4dFRyYWNrID0gZnVuY3Rpb24gY3JlYXRlUmVtb3RlVGV4dFRyYWNrKG9wdGlvbnMpIHtcbiAgICB2YXIgdHJhY2sgPSBtZXJnZU9wdGlvbnMob3B0aW9ucywge1xuICAgICAgdGVjaDogdGhpc1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIG5ldyBSRU1PVEUucmVtb3RlVGV4dEVsLlRyYWNrQ2xhc3ModHJhY2spO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgcmVtb3RlIHRleHQgdHJhY2sgb2JqZWN0IGFuZCByZXR1cm5zIGFuIGh0bWwgdHJhY2sgZWxlbWVudC5cbiAgICpcbiAgICogPiBOb3RlOiBUaGlzIGNhbiBiZSBhbiBlbXVsYXRlZCB7QGxpbmsgSFRNTFRyYWNrRWxlbWVudH0gb3IgYSBuYXRpdmUgb25lLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiAgICAgICAgU2VlIHtAbGluayBUZWNoI2NyZWF0ZVJlbW90ZVRleHRUcmFja30gZm9yIG1vcmUgZGV0YWlsZWQgcHJvcGVydGllcy5cbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSBbbWFudWFsQ2xlYW51cD10cnVlXVxuICAgKiAgICAgICAgLSBXaGVuIGZhbHNlOiB0aGUgVGV4dFRyYWNrIHdpbGwgYmUgYXV0b21hdGljYWxseSByZW1vdmVkIGZyb20gdGhlIHZpZGVvXG4gICAqICAgICAgICAgIGVsZW1lbnQgd2hlbmV2ZXIgdGhlIHNvdXJjZSBjaGFuZ2VzXG4gICAqICAgICAgICAtIFdoZW4gVHJ1ZTogVGhlIFRleHRUcmFjayB3aWxsIGhhdmUgdG8gYmUgY2xlYW5lZCB1cCBtYW51YWxseVxuICAgKlxuICAgKiBAcmV0dXJuIHtIVE1MVHJhY2tFbGVtZW50fVxuICAgKiAgICAgICAgIEFuIEh0bWwgVHJhY2sgRWxlbWVudC5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVGhlIGRlZmF1bHQgZnVuY3Rpb25hbGl0eSBmb3IgdGhpcyBmdW5jdGlvbiB3aWxsIGJlIGVxdWl2YWxlbnRcbiAgICogICAgICAgICAgICAgdG8gXCJtYW51YWxDbGVhbnVwPWZhbHNlXCIgaW4gdGhlIGZ1dHVyZS4gVGhlIG1hbnVhbENsZWFudXAgcGFyYW1ldGVyIHdpbGxcbiAgICogICAgICAgICAgICAgYWxzbyBiZSByZW1vdmVkLlxuICAgKi9cblxuXG4gIFRlY2gucHJvdG90eXBlLmFkZFJlbW90ZVRleHRUcmFjayA9IGZ1bmN0aW9uIGFkZFJlbW90ZVRleHRUcmFjaygpIHtcbiAgICB2YXIgX3RoaXM3ID0gdGhpcztcblxuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICB2YXIgbWFudWFsQ2xlYW51cCA9IGFyZ3VtZW50c1sxXTtcblxuICAgIHZhciBodG1sVHJhY2tFbGVtZW50ID0gdGhpcy5jcmVhdGVSZW1vdGVUZXh0VHJhY2sob3B0aW9ucyk7XG5cbiAgICBpZiAobWFudWFsQ2xlYW51cCAhPT0gdHJ1ZSAmJiBtYW51YWxDbGVhbnVwICE9PSBmYWxzZSkge1xuICAgICAgLy8gZGVwcmVjYXRpb24gd2FybmluZ1xuICAgICAgbG9nLndhcm4oJ0NhbGxpbmcgYWRkUmVtb3RlVGV4dFRyYWNrIHdpdGhvdXQgZXhwbGljaXRseSBzZXR0aW5nIHRoZSBcIm1hbnVhbENsZWFudXBcIiBwYXJhbWV0ZXIgdG8gYHRydWVgIGlzIGRlcHJlY2F0ZWQgYW5kIGRlZmF1bHQgdG8gYGZhbHNlYCBpbiBmdXR1cmUgdmVyc2lvbiBvZiB2aWRlby5qcycpO1xuICAgICAgbWFudWFsQ2xlYW51cCA9IHRydWU7XG4gICAgfVxuXG4gICAgLy8gc3RvcmUgSFRNTFRyYWNrRWxlbWVudCBhbmQgVGV4dFRyYWNrIHRvIHJlbW90ZSBsaXN0XG4gICAgdGhpcy5yZW1vdGVUZXh0VHJhY2tFbHMoKS5hZGRUcmFja0VsZW1lbnRfKGh0bWxUcmFja0VsZW1lbnQpO1xuICAgIHRoaXMucmVtb3RlVGV4dFRyYWNrcygpLmFkZFRyYWNrKGh0bWxUcmFja0VsZW1lbnQudHJhY2spO1xuXG4gICAgaWYgKG1hbnVhbENsZWFudXAgIT09IHRydWUpIHtcbiAgICAgIC8vIGNyZWF0ZSB0aGUgVGV4dFRyYWNrTGlzdCBpZiBpdCBkb2Vzbid0IGV4aXN0XG4gICAgICB0aGlzLnJlYWR5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzNy5hdXRvUmVtb3RlVGV4dFRyYWNrc18uYWRkVHJhY2soaHRtbFRyYWNrRWxlbWVudC50cmFjayk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gaHRtbFRyYWNrRWxlbWVudDtcbiAgfTtcblxuICAvKipcbiAgICogUmVtb3ZlIGEgcmVtb3RlIHRleHQgdHJhY2sgZnJvbSB0aGUgcmVtb3RlIGBUZXh0VHJhY2tMaXN0YC5cbiAgICpcbiAgICogQHBhcmFtIHtUZXh0VHJhY2t9IHRyYWNrXG4gICAqICAgICAgICBgVGV4dFRyYWNrYCB0byByZW1vdmUgZnJvbSB0aGUgYFRleHRUcmFja0xpc3RgXG4gICAqL1xuXG5cbiAgVGVjaC5wcm90b3R5cGUucmVtb3ZlUmVtb3RlVGV4dFRyYWNrID0gZnVuY3Rpb24gcmVtb3ZlUmVtb3RlVGV4dFRyYWNrKHRyYWNrKSB7XG4gICAgdmFyIHRyYWNrRWxlbWVudCA9IHRoaXMucmVtb3RlVGV4dFRyYWNrRWxzKCkuZ2V0VHJhY2tFbGVtZW50QnlUcmFja18odHJhY2spO1xuXG4gICAgLy8gcmVtb3ZlIEhUTUxUcmFja0VsZW1lbnQgYW5kIFRleHRUcmFjayBmcm9tIHJlbW90ZSBsaXN0XG4gICAgdGhpcy5yZW1vdGVUZXh0VHJhY2tFbHMoKS5yZW1vdmVUcmFja0VsZW1lbnRfKHRyYWNrRWxlbWVudCk7XG4gICAgdGhpcy5yZW1vdGVUZXh0VHJhY2tzKCkucmVtb3ZlVHJhY2sodHJhY2spO1xuICAgIHRoaXMuYXV0b1JlbW90ZVRleHRUcmFja3NfLnJlbW92ZVRyYWNrKHRyYWNrKTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0cyBhdmFpbGFibGUgbWVkaWEgcGxheWJhY2sgcXVhbGl0eSBtZXRyaWNzIGFzIHNwZWNpZmllZCBieSB0aGUgVzNDJ3MgTWVkaWFcbiAgICogUGxheWJhY2sgUXVhbGl0eSBBUEkuXG4gICAqXG4gICAqIEBzZWUgW1NwZWNde0BsaW5rIGh0dHBzOi8vd2ljZy5naXRodWIuaW8vbWVkaWEtcGxheWJhY2stcXVhbGl0eX1cbiAgICpcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKiAgICAgICAgIEFuIG9iamVjdCB3aXRoIHN1cHBvcnRlZCBtZWRpYSBwbGF5YmFjayBxdWFsaXR5IG1ldHJpY3NcbiAgICpcbiAgICogQGFic3RyYWN0XG4gICAqL1xuXG5cbiAgVGVjaC5wcm90b3R5cGUuZ2V0VmlkZW9QbGF5YmFja1F1YWxpdHkgPSBmdW5jdGlvbiBnZXRWaWRlb1BsYXliYWNrUXVhbGl0eSgpIHtcbiAgICByZXR1cm4ge307XG4gIH07XG5cbiAgLyoqXG4gICAqIEEgbWV0aG9kIHRvIHNldCBhIHBvc3RlciBmcm9tIGEgYFRlY2hgLlxuICAgKlxuICAgKiBAYWJzdHJhY3RcbiAgICovXG5cblxuICBUZWNoLnByb3RvdHlwZS5zZXRQb3N0ZXIgPSBmdW5jdGlvbiBzZXRQb3N0ZXIoKSB7fTtcblxuICAvKipcbiAgICogQSBtZXRob2QgdG8gY2hlY2sgZm9yIHRoZSBwcmVzZW5jZSBvZiB0aGUgJ3BsYXlzaW5pbmUnIDx2aWRlbz4gYXR0cmlidXRlLlxuICAgKlxuICAgKiBAYWJzdHJhY3RcbiAgICovXG5cblxuICBUZWNoLnByb3RvdHlwZS5wbGF5c2lubGluZSA9IGZ1bmN0aW9uIHBsYXlzaW5saW5lKCkge307XG5cbiAgLyoqXG4gICAqIEEgbWV0aG9kIHRvIHNldCBvciB1bnNldCB0aGUgJ3BsYXlzaW5pbmUnIDx2aWRlbz4gYXR0cmlidXRlLlxuICAgKlxuICAgKiBAYWJzdHJhY3RcbiAgICovXG5cblxuICBUZWNoLnByb3RvdHlwZS5zZXRQbGF5c2lubGluZSA9IGZ1bmN0aW9uIHNldFBsYXlzaW5saW5lKCkge307XG5cbiAgLypcbiAgICogQ2hlY2sgaWYgdGhlIHRlY2ggY2FuIHN1cHBvcnQgdGhlIGdpdmVuIG1pbWUtdHlwZS5cbiAgICpcbiAgICogVGhlIGJhc2UgdGVjaCBkb2VzIG5vdCBzdXBwb3J0IGFueSB0eXBlLCBidXQgc291cmNlIGhhbmRsZXJzIG1pZ2h0XG4gICAqIG92ZXJ3cml0ZSB0aGlzLlxuICAgKlxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IHR5cGVcbiAgICogICAgICAgICBUaGUgbWltZXR5cGUgdG8gY2hlY2sgZm9yIHN1cHBvcnRcbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKiAgICAgICAgICdwcm9iYWJseScsICdtYXliZScsIG9yIGVtcHR5IHN0cmluZ1xuICAgKlxuICAgKiBAc2VlIFtTcGVjXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvSFRNTE1lZGlhRWxlbWVudC9jYW5QbGF5VHlwZX1cbiAgICpcbiAgICogQGFic3RyYWN0XG4gICAqL1xuXG5cbiAgVGVjaC5wcm90b3R5cGUuY2FuUGxheVR5cGUgPSBmdW5jdGlvbiBjYW5QbGF5VHlwZSgpIHtcbiAgICByZXR1cm4gJyc7XG4gIH07XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIHRoZSB0eXBlIGlzIHN1cHBvcnRlZCBieSB0aGlzIHRlY2guXG4gICAqXG4gICAqIFRoZSBiYXNlIHRlY2ggZG9lcyBub3Qgc3VwcG9ydCBhbnkgdHlwZSwgYnV0IHNvdXJjZSBoYW5kbGVycyBtaWdodFxuICAgKiBvdmVyd3JpdGUgdGhpcy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAgICogICAgICAgIFRoZSBtZWRpYSB0eXBlIHRvIGNoZWNrXG4gICAqIEByZXR1cm4ge3N0cmluZ30gUmV0dXJucyB0aGUgbmF0aXZlIHZpZGVvIGVsZW1lbnQncyByZXNwb25zZVxuICAgKi9cblxuXG4gIFRlY2guY2FuUGxheVR5cGUgPSBmdW5jdGlvbiBjYW5QbGF5VHlwZSgpIHtcbiAgICByZXR1cm4gJyc7XG4gIH07XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIHRoZSB0ZWNoIGNhbiBzdXBwb3J0IHRoZSBnaXZlbiBzb3VyY2VcbiAgICogQHBhcmFtIHtPYmplY3R9IHNyY09ialxuICAgKiAgICAgICAgVGhlIHNvdXJjZSBvYmplY3RcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogICAgICAgIFRoZSBvcHRpb25zIHBhc3NlZCB0byB0aGUgdGVjaFxuICAgKiBAcmV0dXJuIHtzdHJpbmd9ICdwcm9iYWJseScsICdtYXliZScsIG9yICcnIChlbXB0eSBzdHJpbmcpXG4gICAqL1xuXG5cbiAgVGVjaC5jYW5QbGF5U291cmNlID0gZnVuY3Rpb24gY2FuUGxheVNvdXJjZShzcmNPYmosIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gVGVjaC5jYW5QbGF5VHlwZShzcmNPYmoudHlwZSk7XG4gIH07XG5cbiAgLypcbiAgICogUmV0dXJuIHdoZXRoZXIgdGhlIGFyZ3VtZW50IGlzIGEgVGVjaCBvciBub3QuXG4gICAqIENhbiBiZSBwYXNzZWQgZWl0aGVyIGEgQ2xhc3MgbGlrZSBgSHRtbDVgIG9yIGEgaW5zdGFuY2UgbGlrZSBgcGxheWVyLnRlY2hfYFxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gY29tcG9uZW50XG4gICAqICAgICAgICBUaGUgaXRlbSB0byBjaGVja1xuICAgKlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKiAgICAgICAgIFdoZXRoZXIgaXQgaXMgYSB0ZWNoIG9yIG5vdFxuICAgKiAgICAgICAgIC0gVHJ1ZSBpZiBpdCBpcyBhIHRlY2hcbiAgICogICAgICAgICAtIEZhbHNlIGlmIGl0IGlzIG5vdFxuICAgKi9cblxuXG4gIFRlY2guaXNUZWNoID0gZnVuY3Rpb24gaXNUZWNoKGNvbXBvbmVudCkge1xuICAgIHJldHVybiBjb21wb25lbnQucHJvdG90eXBlIGluc3RhbmNlb2YgVGVjaCB8fCBjb21wb25lbnQgaW5zdGFuY2VvZiBUZWNoIHx8IGNvbXBvbmVudCA9PT0gVGVjaDtcbiAgfTtcblxuICAvKipcbiAgICogUmVnaXN0ZXJzIGEgYFRlY2hgIGludG8gYSBzaGFyZWQgbGlzdCBmb3IgdmlkZW9qcy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICogICAgICAgIE5hbWUgb2YgdGhlIGBUZWNoYCB0byByZWdpc3Rlci5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHRlY2hcbiAgICogICAgICAgIFRoZSBgVGVjaGAgY2xhc3MgdG8gcmVnaXN0ZXIuXG4gICAqL1xuXG5cbiAgVGVjaC5yZWdpc3RlclRlY2ggPSBmdW5jdGlvbiByZWdpc3RlclRlY2gobmFtZSwgdGVjaCkge1xuICAgIGlmICghVGVjaC50ZWNoc18pIHtcbiAgICAgIFRlY2gudGVjaHNfID0ge307XG4gICAgfVxuXG4gICAgaWYgKCFUZWNoLmlzVGVjaCh0ZWNoKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUZWNoICcgKyBuYW1lICsgJyBtdXN0IGJlIGEgVGVjaCcpO1xuICAgIH1cblxuICAgIGlmICghVGVjaC5jYW5QbGF5VHlwZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUZWNocyBtdXN0IGhhdmUgYSBzdGF0aWMgY2FuUGxheVR5cGUgbWV0aG9kIG9uIHRoZW0nKTtcbiAgICB9XG4gICAgaWYgKCFUZWNoLmNhblBsYXlTb3VyY2UpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGVjaHMgbXVzdCBoYXZlIGEgc3RhdGljIGNhblBsYXlTb3VyY2UgbWV0aG9kIG9uIHRoZW0nKTtcbiAgICB9XG5cbiAgICBuYW1lID0gdG9UaXRsZUNhc2UobmFtZSk7XG5cbiAgICBUZWNoLnRlY2hzX1tuYW1lXSA9IHRlY2g7XG4gICAgaWYgKG5hbWUgIT09ICdUZWNoJykge1xuICAgICAgLy8gY2FtZWwgY2FzZSB0aGUgdGVjaE5hbWUgZm9yIHVzZSBpbiB0ZWNoT3JkZXJcbiAgICAgIFRlY2guZGVmYXVsdFRlY2hPcmRlcl8ucHVzaChuYW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIHRlY2g7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBhIGBUZWNoYCBmcm9tIHRoZSBzaGFyZWQgbGlzdCBieSBuYW1lLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgKiAgICAgICAgYGNhbWVsQ2FzZWAgb3IgYFRpdGxlQ2FzZWAgbmFtZSBvZiB0aGUgVGVjaCB0byBnZXRcbiAgICpcbiAgICogQHJldHVybiB7VGVjaHx1bmRlZmluZWR9XG4gICAqICAgICAgICAgVGhlIGBUZWNoYCBvciB1bmRlZmluZWQgaWYgdGhlcmUgd2FzIG5vIHRlY2ggd2l0aCB0aGUgbmFtZSByZXF1c3RlZC5cbiAgICovXG5cblxuICBUZWNoLmdldFRlY2ggPSBmdW5jdGlvbiBnZXRUZWNoKG5hbWUpIHtcbiAgICBpZiAoIW5hbWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBuYW1lID0gdG9UaXRsZUNhc2UobmFtZSk7XG5cbiAgICBpZiAoVGVjaC50ZWNoc18gJiYgVGVjaC50ZWNoc19bbmFtZV0pIHtcbiAgICAgIHJldHVybiBUZWNoLnRlY2hzX1tuYW1lXTtcbiAgICB9XG5cbiAgICBpZiAod2luZG93ICYmIHdpbmRvdy52aWRlb2pzICYmIHdpbmRvdy52aWRlb2pzW25hbWVdKSB7XG4gICAgICBsb2cud2FybignVGhlICcgKyBuYW1lICsgJyB0ZWNoIHdhcyBhZGRlZCB0byB0aGUgdmlkZW9qcyBvYmplY3Qgd2hlbiBpdCBzaG91bGQgYmUgcmVnaXN0ZXJlZCB1c2luZyB2aWRlb2pzLnJlZ2lzdGVyVGVjaChuYW1lLCB0ZWNoKScpO1xuICAgICAgcmV0dXJuIHdpbmRvdy52aWRlb2pzW25hbWVdO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gVGVjaDtcbn0oQ29tcG9uZW50KTtcblxuLyoqXG4gKiBHZXQgdGhlIHtAbGluayBWaWRlb1RyYWNrTGlzdH1cbiAqXG4gKiBAcmV0dXJucyB7VmlkZW9UcmFja0xpc3R9XG4gKiBAbWV0aG9kIFRlY2gucHJvdG90eXBlLnZpZGVvVHJhY2tzXG4gKi9cblxuLyoqXG4gKiBHZXQgdGhlIHtAbGluayBBdWRpb1RyYWNrTGlzdH1cbiAqXG4gKiBAcmV0dXJucyB7QXVkaW9UcmFja0xpc3R9XG4gKiBAbWV0aG9kIFRlY2gucHJvdG90eXBlLmF1ZGlvVHJhY2tzXG4gKi9cblxuLyoqXG4gKiBHZXQgdGhlIHtAbGluayBUZXh0VHJhY2tMaXN0fVxuICpcbiAqIEByZXR1cm5zIHtUZXh0VHJhY2tMaXN0fVxuICogQG1ldGhvZCBUZWNoLnByb3RvdHlwZS50ZXh0VHJhY2tzXG4gKi9cblxuLyoqXG4gKiBHZXQgdGhlIHJlbW90ZSBlbGVtZW50IHtAbGluayBUZXh0VHJhY2tMaXN0fVxuICpcbiAqIEByZXR1cm5zIHtUZXh0VHJhY2tMaXN0fVxuICogQG1ldGhvZCBUZWNoLnByb3RvdHlwZS5yZW1vdGVUZXh0VHJhY2tzXG4gKi9cblxuLyoqXG4gKiBHZXQgdGhlIHJlbW90ZSBlbGVtZW50IHtAbGluayBIdG1sVHJhY2tFbGVtZW50TGlzdH1cbiAqXG4gKiBAcmV0dXJucyB7SHRtbFRyYWNrRWxlbWVudExpc3R9XG4gKiBAbWV0aG9kIFRlY2gucHJvdG90eXBlLnJlbW90ZVRleHRUcmFja0Vsc1xuICovXG5cbkFMTC5uYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gIHZhciBwcm9wcyA9IEFMTFtuYW1lXTtcblxuICBUZWNoLnByb3RvdHlwZVtwcm9wcy5nZXR0ZXJOYW1lXSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzW3Byb3BzLnByaXZhdGVOYW1lXSA9IHRoaXNbcHJvcHMucHJpdmF0ZU5hbWVdIHx8IG5ldyBwcm9wcy5MaXN0Q2xhc3MoKTtcbiAgICByZXR1cm4gdGhpc1twcm9wcy5wcml2YXRlTmFtZV07XG4gIH07XG59KTtcblxuLyoqXG4gKiBMaXN0IG9mIGFzc29jaWF0ZWQgdGV4dCB0cmFja3NcbiAqXG4gKiBAdHlwZSB7VGV4dFRyYWNrTGlzdH1cbiAqIEBwcml2YXRlXG4gKiBAcHJvcGVydHkgVGVjaCN0ZXh0VHJhY2tzX1xuICovXG5cbi8qKlxuICogTGlzdCBvZiBhc3NvY2lhdGVkIGF1ZGlvIHRyYWNrcy5cbiAqXG4gKiBAdHlwZSB7QXVkaW9UcmFja0xpc3R9XG4gKiBAcHJpdmF0ZVxuICogQHByb3BlcnR5IFRlY2gjYXVkaW9UcmFja3NfXG4gKi9cblxuLyoqXG4gKiBMaXN0IG9mIGFzc29jaWF0ZWQgdmlkZW8gdHJhY2tzLlxuICpcbiAqIEB0eXBlIHtWaWRlb1RyYWNrTGlzdH1cbiAqIEBwcml2YXRlXG4gKiBAcHJvcGVydHkgVGVjaCN2aWRlb1RyYWNrc19cbiAqL1xuXG4vKipcbiAqIEJvb2xlYW4gaW5kaWNhdGluZyB3ZXRoZXIgdGhlIGBUZWNoYCBzdXBwb3J0cyB2b2x1bWUgY29udHJvbC5cbiAqXG4gKiBAdHlwZSB7Ym9vbGVhbn1cbiAqIEBkZWZhdWx0XG4gKi9cblRlY2gucHJvdG90eXBlLmZlYXR1cmVzVm9sdW1lQ29udHJvbCA9IHRydWU7XG5cbi8qKlxuICogQm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIGBUZWNoYCBzdXBwb3J0cyBtdXRpbmcgdm9sdW1lLlxuICpcbiAqIEB0eXBlIHtib2xlYW59XG4gKiBAZGVmYXVsdFxuICovXG5UZWNoLnByb3RvdHlwZS5mZWF0dXJlc011dGVDb250cm9sID0gdHJ1ZTtcblxuLyoqXG4gKiBCb29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0aGUgYFRlY2hgIHN1cHBvcnRzIGZ1bGxzY3JlZW4gcmVzaXplIGNvbnRyb2wuXG4gKiBSZXNpemluZyBwbHVnaW5zIHVzaW5nIHJlcXVlc3QgZnVsbHNjcmVlbiByZWxvYWRzIHRoZSBwbHVnaW5cbiAqXG4gKiBAdHlwZSB7Ym9vbGVhbn1cbiAqIEBkZWZhdWx0XG4gKi9cblRlY2gucHJvdG90eXBlLmZlYXR1cmVzRnVsbHNjcmVlblJlc2l6ZSA9IGZhbHNlO1xuXG4vKipcbiAqIEJvb2xlYW4gaW5kaWNhdGluZyB3ZXRoZXIgdGhlIGBUZWNoYCBzdXBwb3J0cyBjaGFuZ2luZyB0aGUgc3BlZWQgYXQgd2hpY2ggdGhlIHZpZGVvXG4gKiBwbGF5cy4gRXhhbXBsZXM6XG4gKiAgIC0gU2V0IHBsYXllciB0byBwbGF5IDJ4ICh0d2ljZSkgYXMgZmFzdFxuICogICAtIFNldCBwbGF5ZXIgdG8gcGxheSAwLjV4IChoYWxmKSBhcyBmYXN0XG4gKlxuICogQHR5cGUge2Jvb2xlYW59XG4gKiBAZGVmYXVsdFxuICovXG5UZWNoLnByb3RvdHlwZS5mZWF0dXJlc1BsYXliYWNrUmF0ZSA9IGZhbHNlO1xuXG4vKipcbiAqIEJvb2xlYW4gaW5kaWNhdGluZyB3ZXRoZXIgdGhlIGBUZWNoYCBzdXBwb3J0cyB0aGUgYHByb2dyZXNzYCBldmVudC4gVGhpcyBpcyBjdXJyZW50bHlcbiAqIG5vdCB0cmlnZ2VyZWQgYnkgdmlkZW8tanMtc3dmLiBUaGlzIHdpbGwgYmUgdXNlZCB0byBkZXRlcm1pbmUgaWZcbiAqIHtAbGluayBUZWNoI21hbnVhbFByb2dyZXNzT259IHNob3VsZCBiZSBjYWxsZWQuXG4gKlxuICogQHR5cGUge2Jvb2xlYW59XG4gKiBAZGVmYXVsdFxuICovXG5UZWNoLnByb3RvdHlwZS5mZWF0dXJlc1Byb2dyZXNzRXZlbnRzID0gZmFsc2U7XG5cbi8qKlxuICogQm9vbGVhbiBpbmRpY2F0aW5nIHdldGhlciB0aGUgYFRlY2hgIHN1cHBvcnRzIHRoZSBgc291cmNlc2V0YCBldmVudC5cbiAqXG4gKiBBIHRlY2ggc2hvdWxkIHNldCB0aGlzIHRvIGB0cnVlYCBhbmQgdGhlbiB1c2Uge0BsaW5rIFRlY2gjdHJpZ2dlclNvdXJjZXNldH1cbiAqIHRvIHRyaWdnZXIgYSB7QGxpbmsgVGVjaCNldmVudDpzb3VyY2VzZXR9IGF0IHRoZSBlYXJsaWVzdCB0aW1lIGFmdGVyIGdldHRpbmdcbiAqIGEgbmV3IHNvdXJjZS5cbiAqXG4gKiBAdHlwZSB7Ym9vbGVhbn1cbiAqIEBkZWZhdWx0XG4gKi9cblRlY2gucHJvdG90eXBlLmZlYXR1cmVzU291cmNlc2V0ID0gZmFsc2U7XG5cbi8qKlxuICogQm9vbGVhbiBpbmRpY2F0aW5nIHdldGhlciB0aGUgYFRlY2hgIHN1cHBvcnRzIHRoZSBgdGltZXVwZGF0ZWAgZXZlbnQuIFRoaXMgaXMgY3VycmVudGx5XG4gKiBub3QgdHJpZ2dlcmVkIGJ5IHZpZGVvLWpzLXN3Zi4gVGhpcyB3aWxsIGJlIHVzZWQgdG8gZGV0ZXJtaW5lIGlmXG4gKiB7QGxpbmsgVGVjaCNtYW51YWxUaW1lVXBkYXRlc30gc2hvdWxkIGJlIGNhbGxlZC5cbiAqXG4gKiBAdHlwZSB7Ym9vbGVhbn1cbiAqIEBkZWZhdWx0XG4gKi9cblRlY2gucHJvdG90eXBlLmZlYXR1cmVzVGltZXVwZGF0ZUV2ZW50cyA9IGZhbHNlO1xuXG4vKipcbiAqIEJvb2xlYW4gaW5kaWNhdGluZyB3ZXRoZXIgdGhlIGBUZWNoYCBzdXBwb3J0cyB0aGUgbmF0aXZlIGBUZXh0VHJhY2tgcy5cbiAqIFRoaXMgd2lsbCBoZWxwIHVzIGludGVncmF0ZSB3aXRoIG5hdGl2ZSBgVGV4dFRyYWNrYHMgaWYgdGhlIGJyb3dzZXIgc3VwcG9ydHMgdGhlbS5cbiAqXG4gKiBAdHlwZSB7Ym9vbGVhbn1cbiAqIEBkZWZhdWx0XG4gKi9cblRlY2gucHJvdG90eXBlLmZlYXR1cmVzTmF0aXZlVGV4dFRyYWNrcyA9IGZhbHNlO1xuXG4vKipcbiAqIEEgZnVuY3Rpb25hbCBtaXhpbiBmb3IgdGVjaHMgdGhhdCB3YW50IHRvIHVzZSB0aGUgU291cmNlIEhhbmRsZXIgcGF0dGVybi5cbiAqIFNvdXJjZSBoYW5kbGVycyBhcmUgc2NyaXB0cyBmb3IgaGFuZGxpbmcgc3BlY2lmaWMgZm9ybWF0cy5cbiAqIFRoZSBzb3VyY2UgaGFuZGxlciBwYXR0ZXJuIGlzIHVzZWQgZm9yIGFkYXB0aXZlIGZvcm1hdHMgKEhMUywgREFTSCkgdGhhdFxuICogbWFudWFsbHkgbG9hZCB2aWRlbyBkYXRhIGFuZCBmZWVkIGl0IGludG8gYSBTb3VyY2UgQnVmZmVyIChNZWRpYSBTb3VyY2UgRXh0ZW5zaW9ucylcbiAqIEV4YW1wbGU6IGBUZWNoLndpdGhTb3VyY2VIYW5kbGVycy5jYWxsKE15VGVjaCk7YFxuICpcbiAqIEBwYXJhbSB7VGVjaH0gX1RlY2hcbiAqICAgICAgICBUaGUgdGVjaCB0byBhZGQgc291cmNlIGhhbmRsZXIgZnVuY3Rpb25zIHRvLlxuICpcbiAqIEBtaXhlcyBUZWNoflNvdXJjZUhhbmRsZXJBZGRpdGlvbnNcbiAqL1xuVGVjaC53aXRoU291cmNlSGFuZGxlcnMgPSBmdW5jdGlvbiAoX1RlY2gpIHtcblxuICAvKipcbiAgICogUmVnaXN0ZXIgYSBzb3VyY2UgaGFuZGxlclxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyXG4gICAqICAgICAgICBUaGUgc291cmNlIGhhbmRsZXIgY2xhc3NcbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtpbmRleF1cbiAgICogICAgICAgIFJlZ2lzdGVyIGl0IGF0IHRoZSBmb2xsb3dpbmcgaW5kZXhcbiAgICovXG4gIF9UZWNoLnJlZ2lzdGVyU291cmNlSGFuZGxlciA9IGZ1bmN0aW9uIChoYW5kbGVyLCBpbmRleCkge1xuICAgIHZhciBoYW5kbGVycyA9IF9UZWNoLnNvdXJjZUhhbmRsZXJzO1xuXG4gICAgaWYgKCFoYW5kbGVycykge1xuICAgICAgaGFuZGxlcnMgPSBfVGVjaC5zb3VyY2VIYW5kbGVycyA9IFtdO1xuICAgIH1cblxuICAgIGlmIChpbmRleCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBhZGQgdG8gdGhlIGVuZCBvZiB0aGUgbGlzdFxuICAgICAgaW5kZXggPSBoYW5kbGVycy5sZW5ndGg7XG4gICAgfVxuXG4gICAgaGFuZGxlcnMuc3BsaWNlKGluZGV4LCAwLCBoYW5kbGVyKTtcbiAgfTtcblxuICAvKipcbiAgICogQ2hlY2sgaWYgdGhlIHRlY2ggY2FuIHN1cHBvcnQgdGhlIGdpdmVuIHR5cGUuIEFsc28gY2hlY2tzIHRoZVxuICAgKiBUZWNocyBzb3VyY2VIYW5kbGVycy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAgICogICAgICAgICBUaGUgbWltZXR5cGUgdG8gY2hlY2suXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICogICAgICAgICAncHJvYmFibHknLCAnbWF5YmUnLCBvciAnJyAoZW1wdHkgc3RyaW5nKVxuICAgKi9cbiAgX1RlY2guY2FuUGxheVR5cGUgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgIHZhciBoYW5kbGVycyA9IF9UZWNoLnNvdXJjZUhhbmRsZXJzIHx8IFtdO1xuICAgIHZhciBjYW4gPSB2b2lkIDA7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhhbmRsZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjYW4gPSBoYW5kbGVyc1tpXS5jYW5QbGF5VHlwZSh0eXBlKTtcblxuICAgICAgaWYgKGNhbikge1xuICAgICAgICByZXR1cm4gY2FuO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAnJztcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZmlyc3Qgc291cmNlIGhhbmRsZXIgdGhhdCBzdXBwb3J0cyB0aGUgc291cmNlLlxuICAgKlxuICAgKiBUT0RPOiBBbnN3ZXIgcXVlc3Rpb246IHNob3VsZCAncHJvYmFibHknIGJlIHByaW9yaXRpemVkIG92ZXIgJ21heWJlJ1xuICAgKlxuICAgKiBAcGFyYW0ge1RlY2h+U291cmNlT2JqZWN0fSBzb3VyY2VcbiAgICogICAgICAgIFRoZSBzb3VyY2Ugb2JqZWN0XG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqICAgICAgICBUaGUgb3B0aW9ucyBwYXNzZWQgdG8gdGhlIHRlY2hcbiAgICpcbiAgICogQHJldHVybiB7U291cmNlSGFuZGxlcnxudWxsfVxuICAgKiAgICAgICAgICBUaGUgZmlyc3Qgc291cmNlIGhhbmRsZXIgdGhhdCBzdXBwb3J0cyB0aGUgc291cmNlIG9yIG51bGwgaWZcbiAgICogICAgICAgICAgbm8gU291cmNlSGFuZGxlciBzdXBwb3J0cyB0aGUgc291cmNlXG4gICAqL1xuICBfVGVjaC5zZWxlY3RTb3VyY2VIYW5kbGVyID0gZnVuY3Rpb24gKHNvdXJjZSwgb3B0aW9ucykge1xuICAgIHZhciBoYW5kbGVycyA9IF9UZWNoLnNvdXJjZUhhbmRsZXJzIHx8IFtdO1xuICAgIHZhciBjYW4gPSB2b2lkIDA7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhhbmRsZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjYW4gPSBoYW5kbGVyc1tpXS5jYW5IYW5kbGVTb3VyY2Uoc291cmNlLCBvcHRpb25zKTtcblxuICAgICAgaWYgKGNhbikge1xuICAgICAgICByZXR1cm4gaGFuZGxlcnNbaV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIHRoZSB0ZWNoIGNhbiBzdXBwb3J0IHRoZSBnaXZlbiBzb3VyY2UuXG4gICAqXG4gICAqIEBwYXJhbSB7VGVjaH5Tb3VyY2VPYmplY3R9IHNyY09ialxuICAgKiAgICAgICAgVGhlIHNvdXJjZSBvYmplY3RcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogICAgICAgIFRoZSBvcHRpb25zIHBhc3NlZCB0byB0aGUgdGVjaFxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqICAgICAgICAgJ3Byb2JhYmx5JywgJ21heWJlJywgb3IgJycgKGVtcHR5IHN0cmluZylcbiAgICovXG4gIF9UZWNoLmNhblBsYXlTb3VyY2UgPSBmdW5jdGlvbiAoc3JjT2JqLCBvcHRpb25zKSB7XG4gICAgdmFyIHNoID0gX1RlY2guc2VsZWN0U291cmNlSGFuZGxlcihzcmNPYmosIG9wdGlvbnMpO1xuXG4gICAgaWYgKHNoKSB7XG4gICAgICByZXR1cm4gc2guY2FuSGFuZGxlU291cmNlKHNyY09iaiwgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgcmV0dXJuICcnO1xuICB9O1xuXG4gIC8qKlxuICAgKiBXaGVuIHVzaW5nIGEgc291cmNlIGhhbmRsZXIsIHByZWZlciBpdHMgaW1wbGVtZW50YXRpb24gb2ZcbiAgICogYW55IGZ1bmN0aW9uIG5vcm1hbGx5IHByb3ZpZGVkIGJ5IHRoZSB0ZWNoLlxuICAgKi9cbiAgdmFyIGRlZmVycmFibGUgPSBbJ3NlZWthYmxlJywgJ3NlZWtpbmcnLCAnZHVyYXRpb24nXTtcblxuICAvKipcbiAgICogQSB3cmFwcGVyIGFyb3VuZCB7QGxpbmsgVGVjaCNzZWVrYWJsZX0gdGhhdCB3aWxsIGNhbGwgYSBgU291cmNlSGFuZGxlcmBzIHNlZWthYmxlXG4gICAqIGZ1bmN0aW9uIGlmIGl0IGV4aXN0cywgd2l0aCBhIGZhbGxiYWNrIHRvIHRoZSBUZWNocyBzZWVrYWJsZSBmdW5jdGlvbi5cbiAgICpcbiAgICogQG1ldGhvZCBfVGVjaC5zZWVrYWJsZVxuICAgKi9cblxuICAvKipcbiAgICogQSB3cmFwcGVyIGFyb3VuZCB7QGxpbmsgVGVjaCNkdXJhdGlvbn0gdGhhdCB3aWxsIGNhbGwgYSBgU291cmNlSGFuZGxlcmBzIGR1cmF0aW9uXG4gICAqIGZ1bmN0aW9uIGlmIGl0IGV4aXN0cywgb3RoZXJ3aXNlIGl0IHdpbGwgZmFsbGJhY2sgdG8gdGhlIHRlY2hzIGR1cmF0aW9uIGZ1bmN0aW9uLlxuICAgKlxuICAgKiBAbWV0aG9kIF9UZWNoLmR1cmF0aW9uXG4gICAqL1xuXG4gIGRlZmVycmFibGUuZm9yRWFjaChmdW5jdGlvbiAoZm5OYW1lKSB7XG4gICAgdmFyIG9yaWdpbmFsRm4gPSB0aGlzW2ZuTmFtZV07XG5cbiAgICBpZiAodHlwZW9mIG9yaWdpbmFsRm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzW2ZuTmFtZV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAodGhpcy5zb3VyY2VIYW5kbGVyXyAmJiB0aGlzLnNvdXJjZUhhbmRsZXJfW2ZuTmFtZV0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlSGFuZGxlcl9bZm5OYW1lXS5hcHBseSh0aGlzLnNvdXJjZUhhbmRsZXJfLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9yaWdpbmFsRm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9LCBfVGVjaC5wcm90b3R5cGUpO1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBmdW5jdGlvbiBmb3Igc2V0dGluZyB0aGUgc291cmNlIHVzaW5nIGEgc291cmNlIG9iamVjdFxuICAgKiBhbmQgc291cmNlIGhhbmRsZXJzLlxuICAgKiBTaG91bGQgbmV2ZXIgYmUgY2FsbGVkIHVubGVzcyBhIHNvdXJjZSBoYW5kbGVyIHdhcyBmb3VuZC5cbiAgICpcbiAgICogQHBhcmFtIHtUZWNoflNvdXJjZU9iamVjdH0gc291cmNlXG4gICAqICAgICAgICBBIHNvdXJjZSBvYmplY3Qgd2l0aCBzcmMgYW5kIHR5cGUga2V5c1xuICAgKi9cbiAgX1RlY2gucHJvdG90eXBlLnNldFNvdXJjZSA9IGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICB2YXIgc2ggPSBfVGVjaC5zZWxlY3RTb3VyY2VIYW5kbGVyKHNvdXJjZSwgdGhpcy5vcHRpb25zXyk7XG5cbiAgICBpZiAoIXNoKSB7XG4gICAgICAvLyBGYWxsIGJhY2sgdG8gYSBuYXRpdmUgc291cmNlIGhhbmRlciB3aGVuIHVuc3VwcG9ydGVkIHNvdXJjZXMgYXJlXG4gICAgICAvLyBkZWxpYmVyYXRlbHkgc2V0XG4gICAgICBpZiAoX1RlY2gubmF0aXZlU291cmNlSGFuZGxlcikge1xuICAgICAgICBzaCA9IF9UZWNoLm5hdGl2ZVNvdXJjZUhhbmRsZXI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsb2cuZXJyb3IoJ05vIHNvdXJjZSBoYW5kZXIgZm91bmQgZm9yIHRoZSBjdXJyZW50IHNvdXJjZS4nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBEaXNwb3NlIGFueSBleGlzdGluZyBzb3VyY2UgaGFuZGxlclxuICAgIHRoaXMuZGlzcG9zZVNvdXJjZUhhbmRsZXIoKTtcbiAgICB0aGlzLm9mZignZGlzcG9zZScsIHRoaXMuZGlzcG9zZVNvdXJjZUhhbmRsZXIpO1xuXG4gICAgaWYgKHNoICE9PSBfVGVjaC5uYXRpdmVTb3VyY2VIYW5kbGVyKSB7XG4gICAgICB0aGlzLmN1cnJlbnRTb3VyY2VfID0gc291cmNlO1xuICAgIH1cblxuICAgIHRoaXMuc291cmNlSGFuZGxlcl8gPSBzaC5oYW5kbGVTb3VyY2Uoc291cmNlLCB0aGlzLCB0aGlzLm9wdGlvbnNfKTtcbiAgICB0aGlzLm9uKCdkaXNwb3NlJywgdGhpcy5kaXNwb3NlU291cmNlSGFuZGxlcik7XG4gIH07XG5cbiAgLyoqXG4gICAqIENsZWFuIHVwIGFueSBleGlzdGluZyBTb3VyY2VIYW5kbGVycyBhbmQgbGlzdGVuZXJzIHdoZW4gdGhlIFRlY2ggaXMgZGlzcG9zZWQuXG4gICAqXG4gICAqIEBsaXN0ZW5zIFRlY2gjZGlzcG9zZVxuICAgKi9cbiAgX1RlY2gucHJvdG90eXBlLmRpc3Bvc2VTb3VyY2VIYW5kbGVyID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIGlmIHdlIGhhdmUgYSBzb3VyY2UgYW5kIGdldCBhbm90aGVyIG9uZVxuICAgIC8vIHRoZW4gd2UgYXJlIGxvYWRpbmcgc29tZXRoaW5nIG5ld1xuICAgIC8vIHRoYW4gY2xlYXIgYWxsIG9mIG91ciBjdXJyZW50IHRyYWNrc1xuICAgIGlmICh0aGlzLmN1cnJlbnRTb3VyY2VfKSB7XG4gICAgICB0aGlzLmNsZWFyVHJhY2tzKFsnYXVkaW8nLCAndmlkZW8nXSk7XG4gICAgICB0aGlzLmN1cnJlbnRTb3VyY2VfID0gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBhbHdheXMgY2xlYW4gdXAgYXV0by10ZXh0IHRyYWNrc1xuICAgIHRoaXMuY2xlYW51cEF1dG9UZXh0VHJhY2tzKCk7XG5cbiAgICBpZiAodGhpcy5zb3VyY2VIYW5kbGVyXykge1xuXG4gICAgICBpZiAodGhpcy5zb3VyY2VIYW5kbGVyXy5kaXNwb3NlKSB7XG4gICAgICAgIHRoaXMuc291cmNlSGFuZGxlcl8uZGlzcG9zZSgpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnNvdXJjZUhhbmRsZXJfID0gbnVsbDtcbiAgICB9XG4gIH07XG59O1xuXG4vLyBUaGUgYmFzZSBUZWNoIGNsYXNzIG5lZWRzIHRvIGJlIHJlZ2lzdGVyZWQgYXMgYSBDb21wb25lbnQuIEl0IGlzIHRoZSBvbmx5XG4vLyBUZWNoIHRoYXQgY2FuIGJlIHJlZ2lzdGVyZWQgYXMgYSBDb21wb25lbnQuXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ1RlY2gnLCBUZWNoKTtcblRlY2gucmVnaXN0ZXJUZWNoKCdUZWNoJywgVGVjaCk7XG5cbi8qKlxuICogQSBsaXN0IG9mIHRlY2hzIHRoYXQgc2hvdWxkIGJlIGFkZGVkIHRvIHRlY2hPcmRlciBvbiBQbGF5ZXJzXG4gKlxuICogQHByaXZhdGVcbiAqL1xuVGVjaC5kZWZhdWx0VGVjaE9yZGVyXyA9IFtdO1xuXG52YXIgbWlkZGxld2FyZXMgPSB7fTtcbnZhciBtaWRkbGV3YXJlSW5zdGFuY2VzID0ge307XG5cbnZhciBURVJNSU5BVE9SID0ge307XG5cbmZ1bmN0aW9uIHVzZSh0eXBlLCBtaWRkbGV3YXJlKSB7XG4gIG1pZGRsZXdhcmVzW3R5cGVdID0gbWlkZGxld2FyZXNbdHlwZV0gfHwgW107XG4gIG1pZGRsZXdhcmVzW3R5cGVdLnB1c2gobWlkZGxld2FyZSk7XG59XG5cblxuXG5mdW5jdGlvbiBzZXRTb3VyY2UocGxheWVyLCBzcmMsIG5leHQpIHtcbiAgcGxheWVyLnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBzZXRTb3VyY2VIZWxwZXIoc3JjLCBtaWRkbGV3YXJlc1tzcmMudHlwZV0sIG5leHQsIHBsYXllcik7XG4gIH0sIDEpO1xufVxuXG5mdW5jdGlvbiBzZXRUZWNoKG1pZGRsZXdhcmUsIHRlY2gpIHtcbiAgbWlkZGxld2FyZS5mb3JFYWNoKGZ1bmN0aW9uIChtdykge1xuICAgIHJldHVybiBtdy5zZXRUZWNoICYmIG13LnNldFRlY2godGVjaCk7XG4gIH0pO1xufVxuXG4vKipcbiAqIENhbGxzIGEgZ2V0dGVyIG9uIHRoZSB0ZWNoIGZpcnN0LCB0aHJvdWdoIGVhY2ggbWlkZGxld2FyZVxuICogZnJvbSByaWdodCB0byBsZWZ0IHRvIHRoZSBwbGF5ZXIuXG4gKi9cbmZ1bmN0aW9uIGdldCQxKG1pZGRsZXdhcmUsIHRlY2gsIG1ldGhvZCkge1xuICByZXR1cm4gbWlkZGxld2FyZS5yZWR1Y2VSaWdodChtaWRkbGV3YXJlSXRlcmF0b3IobWV0aG9kKSwgdGVjaFttZXRob2RdKCkpO1xufVxuXG4vKipcbiAqIFRha2VzIHRoZSBhcmd1bWVudCBnaXZlbiB0byB0aGUgcGxheWVyIGFuZCBjYWxscyB0aGUgc2V0dGVyIG1ldGhvZCBvbiBlYWNoXG4gKiBtaWRkbHdhcmUgZnJvbSBsZWZ0IHRvIHJpZ2h0IHRvIHRoZSB0ZWNoLlxuICovXG5mdW5jdGlvbiBzZXQkMShtaWRkbGV3YXJlLCB0ZWNoLCBtZXRob2QsIGFyZykge1xuICByZXR1cm4gdGVjaFttZXRob2RdKG1pZGRsZXdhcmUucmVkdWNlKG1pZGRsZXdhcmVJdGVyYXRvcihtZXRob2QpLCBhcmcpKTtcbn1cblxuLyoqXG4gKiBUYWtlcyB0aGUgYXJndW1lbnQgZ2l2ZW4gdG8gdGhlIHBsYXllciBhbmQgY2FsbHMgdGhlIGBjYWxsYCB2ZXJzaW9uIG9mIHRoZSBtZXRob2RcbiAqIG9uIGVhY2ggbWlkZGxld2FyZSBmcm9tIGxlZnQgdG8gcmlnaHQuXG4gKiBUaGVuLCBjYWxsIHRoZSBwYXNzZWQgaW4gbWV0aG9kIG9uIHRoZSB0ZWNoIGFuZCByZXR1cm4gdGhlIHJlc3VsdCB1bmNoYW5nZWRcbiAqIGJhY2sgdG8gdGhlIHBsYXllciwgdGhyb3VnaCBtaWRkbGV3YXJlLCB0aGlzIHRpbWUgZnJvbSByaWdodCB0byBsZWZ0LlxuICovXG5mdW5jdGlvbiBtZWRpYXRlKG1pZGRsZXdhcmUsIHRlY2gsIG1ldGhvZCkge1xuICB2YXIgYXJnID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiBudWxsO1xuXG4gIHZhciBjYWxsTWV0aG9kID0gJ2NhbGwnICsgdG9UaXRsZUNhc2UobWV0aG9kKTtcbiAgdmFyIG1pZGRsZXdhcmVWYWx1ZSA9IG1pZGRsZXdhcmUucmVkdWNlKG1pZGRsZXdhcmVJdGVyYXRvcihjYWxsTWV0aG9kKSwgYXJnKTtcbiAgdmFyIHRlcm1pbmF0ZWQgPSBtaWRkbGV3YXJlVmFsdWUgPT09IFRFUk1JTkFUT1I7XG4gIHZhciByZXR1cm5WYWx1ZSA9IHRlcm1pbmF0ZWQgPyBudWxsIDogdGVjaFttZXRob2RdKG1pZGRsZXdhcmVWYWx1ZSk7XG5cbiAgZXhlY3V0ZVJpZ2h0KG1pZGRsZXdhcmUsIG1ldGhvZCwgcmV0dXJuVmFsdWUsIHRlcm1pbmF0ZWQpO1xuXG4gIHJldHVybiByZXR1cm5WYWx1ZTtcbn1cblxudmFyIGFsbG93ZWRHZXR0ZXJzID0ge1xuICBidWZmZXJlZDogMSxcbiAgY3VycmVudFRpbWU6IDEsXG4gIGR1cmF0aW9uOiAxLFxuICBzZWVrYWJsZTogMSxcbiAgcGxheWVkOiAxLFxuICBwYXVzZWQ6IDFcbn07XG5cbnZhciBhbGxvd2VkU2V0dGVycyA9IHtcbiAgc2V0Q3VycmVudFRpbWU6IDFcbn07XG5cbnZhciBhbGxvd2VkTWVkaWF0b3JzID0ge1xuICBwbGF5OiAxLFxuICBwYXVzZTogMVxufTtcblxuZnVuY3Rpb24gbWlkZGxld2FyZUl0ZXJhdG9yKG1ldGhvZCkge1xuICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlLCBtdykge1xuICAgIC8vIGlmIHRoZSBwcmV2aW91cyBtaWRkbGV3YXJlIHRlcm1pbmF0ZWQsIHBhc3MgYWxvbmcgdGhlIHRlcm1pbmF0aW9uXG4gICAgaWYgKHZhbHVlID09PSBURVJNSU5BVE9SKSB7XG4gICAgICByZXR1cm4gVEVSTUlOQVRPUjtcbiAgICB9XG5cbiAgICBpZiAobXdbbWV0aG9kXSkge1xuICAgICAgcmV0dXJuIG13W21ldGhvZF0odmFsdWUpO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gZXhlY3V0ZVJpZ2h0KG13cywgbWV0aG9kLCB2YWx1ZSwgdGVybWluYXRlZCkge1xuICBmb3IgKHZhciBpID0gbXdzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgdmFyIG13ID0gbXdzW2ldO1xuXG4gICAgaWYgKG13W21ldGhvZF0pIHtcbiAgICAgIG13W21ldGhvZF0odGVybWluYXRlZCwgdmFsdWUpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjbGVhckNhY2hlRm9yUGxheWVyKHBsYXllcikge1xuICBtaWRkbGV3YXJlSW5zdGFuY2VzW3BsYXllci5pZCgpXSA9IG51bGw7XG59XG5cbi8qKlxuICoge1xuICogIFtwbGF5ZXJJZF06IFtbbXdGYWN0b3J5LCBtd0luc3RhbmNlXSwgLi4uXVxuICogfVxuICovXG5mdW5jdGlvbiBnZXRPckNyZWF0ZUZhY3RvcnkocGxheWVyLCBtd0ZhY3RvcnkpIHtcbiAgdmFyIG13cyA9IG1pZGRsZXdhcmVJbnN0YW5jZXNbcGxheWVyLmlkKCldO1xuICB2YXIgbXcgPSBudWxsO1xuXG4gIGlmIChtd3MgPT09IHVuZGVmaW5lZCB8fCBtd3MgPT09IG51bGwpIHtcbiAgICBtdyA9IG13RmFjdG9yeShwbGF5ZXIpO1xuICAgIG1pZGRsZXdhcmVJbnN0YW5jZXNbcGxheWVyLmlkKCldID0gW1ttd0ZhY3RvcnksIG13XV07XG4gICAgcmV0dXJuIG13O1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBtd3MubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgX213cyRpID0gbXdzW2ldLFxuICAgICAgICBtd2YgPSBfbXdzJGlbMF0sXG4gICAgICAgIG13aSA9IF9td3MkaVsxXTtcblxuXG4gICAgaWYgKG13ZiAhPT0gbXdGYWN0b3J5KSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBtdyA9IG13aTtcbiAgfVxuXG4gIGlmIChtdyA9PT0gbnVsbCkge1xuICAgIG13ID0gbXdGYWN0b3J5KHBsYXllcik7XG4gICAgbXdzLnB1c2goW213RmFjdG9yeSwgbXddKTtcbiAgfVxuXG4gIHJldHVybiBtdztcbn1cblxuZnVuY3Rpb24gc2V0U291cmNlSGVscGVyKCkge1xuICB2YXIgc3JjID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgdmFyIG1pZGRsZXdhcmUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IFtdO1xuICB2YXIgbmV4dCA9IGFyZ3VtZW50c1syXTtcbiAgdmFyIHBsYXllciA9IGFyZ3VtZW50c1szXTtcbiAgdmFyIGFjYyA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ICYmIGFyZ3VtZW50c1s0XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzRdIDogW107XG4gIHZhciBsYXN0UnVuID0gYXJndW1lbnRzLmxlbmd0aCA+IDUgJiYgYXJndW1lbnRzWzVdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNV0gOiBmYWxzZTtcbiAgdmFyIG13RmFjdG9yeSA9IG1pZGRsZXdhcmVbMF0sXG4gICAgICBtd3Jlc3QgPSBtaWRkbGV3YXJlLnNsaWNlKDEpO1xuXG4gIC8vIGlmIG13RmFjdG9yeSBpcyBhIHN0cmluZywgdGhlbiB3ZSdyZSBhdCBhIGZvcmsgaW4gdGhlIHJvYWRcblxuICBpZiAodHlwZW9mIG13RmFjdG9yeSA9PT0gJ3N0cmluZycpIHtcbiAgICBzZXRTb3VyY2VIZWxwZXIoc3JjLCBtaWRkbGV3YXJlc1ttd0ZhY3RvcnldLCBuZXh0LCBwbGF5ZXIsIGFjYywgbGFzdFJ1bik7XG5cbiAgICAvLyBpZiB3ZSBoYXZlIGFuIG13RmFjdG9yeSwgY2FsbCBpdCB3aXRoIHRoZSBwbGF5ZXIgdG8gZ2V0IHRoZSBtdyxcbiAgICAvLyB0aGVuIGNhbGwgdGhlIG13J3Mgc2V0U291cmNlIG1ldGhvZFxuICB9IGVsc2UgaWYgKG13RmFjdG9yeSkge1xuICAgIHZhciBtdyA9IGdldE9yQ3JlYXRlRmFjdG9yeShwbGF5ZXIsIG13RmFjdG9yeSk7XG5cbiAgICAvLyBpZiBzZXRTb3VyY2UgaXNuJ3QgcHJlc2VudCwgaW1wbGljaXRseSBzZWxlY3QgdGhpcyBtaWRkbGV3YXJlXG4gICAgaWYgKCFtdy5zZXRTb3VyY2UpIHtcbiAgICAgIGFjYy5wdXNoKG13KTtcbiAgICAgIHJldHVybiBzZXRTb3VyY2VIZWxwZXIoc3JjLCBtd3Jlc3QsIG5leHQsIHBsYXllciwgYWNjLCBsYXN0UnVuKTtcbiAgICB9XG5cbiAgICBtdy5zZXRTb3VyY2UoYXNzaWduKHt9LCBzcmMpLCBmdW5jdGlvbiAoZXJyLCBfc3JjKSB7XG5cbiAgICAgIC8vIHNvbWV0aGluZyBoYXBwZW5lZCwgdHJ5IHRoZSBuZXh0IG1pZGRsZXdhcmUgb24gdGhlIGN1cnJlbnQgbGV2ZWxcbiAgICAgIC8vIG1ha2Ugc3VyZSB0byB1c2UgdGhlIG9sZCBzcmNcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIHNldFNvdXJjZUhlbHBlcihzcmMsIG13cmVzdCwgbmV4dCwgcGxheWVyLCBhY2MsIGxhc3RSdW4pO1xuICAgICAgfVxuXG4gICAgICAvLyB3ZSd2ZSBzdWNjZWVkZWQsIG5vdyB3ZSBuZWVkIHRvIGdvIGRlZXBlclxuICAgICAgYWNjLnB1c2gobXcpO1xuXG4gICAgICAvLyBpZiBpdCdzIHRoZSBzYW1lIHR5cGUsIGNvbnRpbnVlIGRvd24gdGhlIGN1cnJlbnQgY2hhaW5cbiAgICAgIC8vIG90aGVyd2lzZSwgd2Ugd2FudCB0byBnbyBkb3duIHRoZSBuZXcgY2hhaW5cbiAgICAgIHNldFNvdXJjZUhlbHBlcihfc3JjLCBzcmMudHlwZSA9PT0gX3NyYy50eXBlID8gbXdyZXN0IDogbWlkZGxld2FyZXNbX3NyYy50eXBlXSwgbmV4dCwgcGxheWVyLCBhY2MsIGxhc3RSdW4pO1xuICAgIH0pO1xuICB9IGVsc2UgaWYgKG13cmVzdC5sZW5ndGgpIHtcbiAgICBzZXRTb3VyY2VIZWxwZXIoc3JjLCBtd3Jlc3QsIG5leHQsIHBsYXllciwgYWNjLCBsYXN0UnVuKTtcbiAgfSBlbHNlIGlmIChsYXN0UnVuKSB7XG4gICAgbmV4dChzcmMsIGFjYyk7XG4gIH0gZWxzZSB7XG4gICAgc2V0U291cmNlSGVscGVyKHNyYywgbWlkZGxld2FyZXNbJyonXSwgbmV4dCwgcGxheWVyLCBhY2MsIHRydWUpO1xuICB9XG59XG5cbi8qKlxuICogTWltZXR5cGVzXG4gKlxuICogQHNlZSBodHRwOi8vaHVsLmhhcnZhcmQuZWR1L29pcy8vLy8vc3lzdGVtcy93YXgvd2F4LXB1YmxpYy1oZWxwL21pbWV0eXBlcy5odG1cbiAqIEB0eXBlZGVmIE1pbWV0eXBlc35LaW5kXG4gKiBAZW51bVxuICovXG52YXIgTWltZXR5cGVzS2luZCA9IHtcbiAgb3B1czogJ3ZpZGVvL29nZycsXG4gIG9ndjogJ3ZpZGVvL29nZycsXG4gIG1wNDogJ3ZpZGVvL21wNCcsXG4gIG1vdjogJ3ZpZGVvL21wNCcsXG4gIG00djogJ3ZpZGVvL21wNCcsXG4gIG1rdjogJ3ZpZGVvL3gtbWF0cm9za2EnLFxuICBtcDM6ICdhdWRpby9tcGVnJyxcbiAgYWFjOiAnYXVkaW8vYWFjJyxcbiAgb2dhOiAnYXVkaW8vb2dnJyxcbiAgbTN1ODogJ2FwcGxpY2F0aW9uL3gtbXBlZ1VSTCdcbn07XG5cbi8qKlxuICogR2V0IHRoZSBtaW1ldHlwZSBvZiBhIGdpdmVuIHNyYyB1cmwgaWYgcG9zc2libGVcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3JjXG4gKiAgICAgICAgVGhlIHVybCB0byB0aGUgc3JjXG4gKlxuICogQHJldHVybiB7c3RyaW5nfVxuICogICAgICAgICByZXR1cm4gdGhlIG1pbWV0eXBlIGlmIGl0IHdhcyBrbm93biBvciBlbXB0eSBzdHJpbmcgb3RoZXJ3aXNlXG4gKi9cbnZhciBnZXRNaW1ldHlwZSA9IGZ1bmN0aW9uIGdldE1pbWV0eXBlKCkge1xuICB2YXIgc3JjID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAnJztcblxuICB2YXIgZXh0ID0gZ2V0RmlsZUV4dGVuc2lvbihzcmMpO1xuICB2YXIgbWltZXR5cGUgPSBNaW1ldHlwZXNLaW5kW2V4dC50b0xvd2VyQ2FzZSgpXTtcblxuICByZXR1cm4gbWltZXR5cGUgfHwgJyc7XG59O1xuXG4vKipcbiAqIEZpbmQgdGhlIG1pbWUgdHlwZSBvZiBhIGdpdmVuIHNvdXJjZSBzdHJpbmcgaWYgcG9zc2libGUuIFVzZXMgdGhlIHBsYXllclxuICogc291cmNlIGNhY2hlLlxuICpcbiAqIEBwYXJhbSB7UGxheWVyfSBwbGF5ZXJcbiAqICAgICAgICBUaGUgcGxheWVyIG9iamVjdFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzcmNcbiAqICAgICAgICBUaGUgc291cmNlIHN0cmluZ1xuICpcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqICAgICAgICAgVGhlIHR5cGUgdGhhdCB3YXMgZm91bmRcbiAqL1xudmFyIGZpbmRNaW1ldHlwZSA9IGZ1bmN0aW9uIGZpbmRNaW1ldHlwZShwbGF5ZXIsIHNyYykge1xuICBpZiAoIXNyYykge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIC8vIDEuIGNoZWNrIGZvciB0aGUgdHlwZSBpbiB0aGUgYHNvdXJjZWAgY2FjaGVcbiAgaWYgKHBsYXllci5jYWNoZV8uc291cmNlLnNyYyA9PT0gc3JjICYmIHBsYXllci5jYWNoZV8uc291cmNlLnR5cGUpIHtcbiAgICByZXR1cm4gcGxheWVyLmNhY2hlXy5zb3VyY2UudHlwZTtcbiAgfVxuXG4gIC8vIDIuIHNlZSBpZiB3ZSBoYXZlIHRoaXMgc291cmNlIGluIG91ciBgY3VycmVudFNvdXJjZXNgIGNhY2hlXG4gIHZhciBtYXRjaGluZ1NvdXJjZXMgPSBwbGF5ZXIuY2FjaGVfLnNvdXJjZXMuZmlsdGVyKGZ1bmN0aW9uIChzKSB7XG4gICAgcmV0dXJuIHMuc3JjID09PSBzcmM7XG4gIH0pO1xuXG4gIGlmIChtYXRjaGluZ1NvdXJjZXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIG1hdGNoaW5nU291cmNlc1swXS50eXBlO1xuICB9XG5cbiAgLy8gMy4gbG9vayBmb3IgdGhlIHNyYyB1cmwgaW4gc291cmNlIGVsZW1lbnRzIGFuZCB1c2UgdGhlIHR5cGUgdGhlcmVcbiAgdmFyIHNvdXJjZXMgPSBwbGF5ZXIuJCQoJ3NvdXJjZScpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc291cmNlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzID0gc291cmNlc1tpXTtcblxuICAgIGlmIChzLnR5cGUgJiYgcy5zcmMgJiYgcy5zcmMgPT09IHNyYykge1xuICAgICAgcmV0dXJuIHMudHlwZTtcbiAgICB9XG4gIH1cblxuICAvLyA0LiBmaW5hbGx5IGZhbGxiYWNrIHRvIG91ciBsaXN0IG9mIG1pbWUgdHlwZXMgYmFzZWQgb24gc3JjIHVybCBleHRlbnNpb25cbiAgcmV0dXJuIGdldE1pbWV0eXBlKHNyYyk7XG59O1xuXG4vKipcbiAqIEBtb2R1bGUgZmlsdGVyLXNvdXJjZVxuICovXG4vKipcbiAqIEZpbHRlciBvdXQgc2luZ2xlIGJhZCBzb3VyY2Ugb2JqZWN0cyBvciBtdWx0aXBsZSBzb3VyY2Ugb2JqZWN0cyBpbiBhblxuICogYXJyYXkuIEFsc28gZmxhdHRlbnMgbmVzdGVkIHNvdXJjZSBvYmplY3QgYXJyYXlzIGludG8gYSAxIGRpbWVuc2lvbmFsXG4gKiBhcnJheSBvZiBzb3VyY2Ugb2JqZWN0cy5cbiAqXG4gKiBAcGFyYW0ge1RlY2h+U291cmNlT2JqZWN0fFRlY2h+U291cmNlT2JqZWN0W119IHNyY1xuICogICAgICAgIFRoZSBzcmMgb2JqZWN0IHRvIGZpbHRlclxuICpcbiAqIEByZXR1cm4ge1RlY2h+U291cmNlT2JqZWN0W119XG4gKiAgICAgICAgIEFuIGFycmF5IG9mIHNvdXJjZW9iamVjdHMgY29udGFpbmluZyBvbmx5IHZhbGlkIHNvdXJjZXNcbiAqXG4gKiBAcHJpdmF0ZVxuICovXG52YXIgZmlsdGVyU291cmNlID0gZnVuY3Rpb24gZmlsdGVyU291cmNlKHNyYykge1xuICAvLyB0cmF2ZXJzZSBhcnJheVxuICBpZiAoQXJyYXkuaXNBcnJheShzcmMpKSB7XG4gICAgdmFyIG5ld3NyYyA9IFtdO1xuXG4gICAgc3JjLmZvckVhY2goZnVuY3Rpb24gKHNyY29iaikge1xuICAgICAgc3Jjb2JqID0gZmlsdGVyU291cmNlKHNyY29iaik7XG5cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHNyY29iaikpIHtcbiAgICAgICAgbmV3c3JjID0gbmV3c3JjLmNvbmNhdChzcmNvYmopO1xuICAgICAgfSBlbHNlIGlmIChpc09iamVjdChzcmNvYmopKSB7XG4gICAgICAgIG5ld3NyYy5wdXNoKHNyY29iaik7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBzcmMgPSBuZXdzcmM7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHNyYyA9PT0gJ3N0cmluZycgJiYgc3JjLnRyaW0oKSkge1xuICAgIC8vIGNvbnZlcnQgc3RyaW5nIGludG8gb2JqZWN0XG4gICAgc3JjID0gW2ZpeFNvdXJjZSh7IHNyYzogc3JjIH0pXTtcbiAgfSBlbHNlIGlmIChpc09iamVjdChzcmMpICYmIHR5cGVvZiBzcmMuc3JjID09PSAnc3RyaW5nJyAmJiBzcmMuc3JjICYmIHNyYy5zcmMudHJpbSgpKSB7XG4gICAgLy8gc3JjIGlzIGFscmVhZHkgdmFsaWRcbiAgICBzcmMgPSBbZml4U291cmNlKHNyYyldO1xuICB9IGVsc2Uge1xuICAgIC8vIGludmFsaWQgc291cmNlLCB0dXJuIGl0IGludG8gYW4gZW1wdHkgYXJyYXlcbiAgICBzcmMgPSBbXTtcbiAgfVxuXG4gIHJldHVybiBzcmM7XG59O1xuXG4vKipcbiAqIENoZWNrcyBzcmMgbWltZXR5cGUsIGFkZGluZyBpdCB3aGVuIHBvc3NpYmxlXG4gKlxuICogQHBhcmFtIHtUZWNoflNvdXJjZU9iamVjdH0gc3JjXG4gKiAgICAgICAgVGhlIHNyYyBvYmplY3QgdG8gY2hlY2tcbiAqIEByZXR1cm4ge1RlY2h+U291cmNlT2JqZWN0fVxuICogICAgICAgIHNyYyBPYmplY3Qgd2l0aCBrbm93biB0eXBlXG4gKi9cbmZ1bmN0aW9uIGZpeFNvdXJjZShzcmMpIHtcbiAgdmFyIG1pbWV0eXBlID0gZ2V0TWltZXR5cGUoc3JjLnNyYyk7XG5cbiAgaWYgKCFzcmMudHlwZSAmJiBtaW1ldHlwZSkge1xuICAgIHNyYy50eXBlID0gbWltZXR5cGU7XG4gIH1cblxuICByZXR1cm4gc3JjO1xufVxuXG4vKipcbiAqIEBmaWxlIGxvYWRlci5qc1xuICovXG4vKipcbiAqIFRoZSBgTWVkaWFMb2FkZXJgIGlzIHRoZSBgQ29tcG9uZW50YCB0aGF0IGRlY2lkZXMgd2hpY2ggcGxheWJhY2sgdGVjaG5vbG9neSB0byBsb2FkXG4gKiB3aGVuIGEgcGxheWVyIGlzIGluaXRpYWxpemVkLlxuICpcbiAqIEBleHRlbmRzIENvbXBvbmVudFxuICovXG5cbnZhciBNZWRpYUxvYWRlciA9IGZ1bmN0aW9uIChfQ29tcG9uZW50KSB7XG4gIGluaGVyaXRzKE1lZGlhTG9hZGVyLCBfQ29tcG9uZW50KTtcblxuICAvKipcbiAgICogQ3JlYXRlIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7UGxheWVyfSBwbGF5ZXJcbiAgICogICAgICAgIFRoZSBgUGxheWVyYCB0aGF0IHRoaXMgY2xhc3Mgc2hvdWxkIGF0dGFjaCB0by5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgICAgICAgVGhlIGtleS92YWx1ZSBzdHJvZSBvZiBwbGF5ZXIgb3B0aW9ucy5cbiAgICpcbiAgICogQHBhcmFtIHtDb21wb25lbnR+UmVhZHlDYWxsYmFja30gW3JlYWR5XVxuICAgKiAgICAgICAgVGhlIGZ1bmN0aW9uIHRoYXQgaXMgcnVuIHdoZW4gdGhpcyBjb21wb25lbnQgaXMgcmVhZHkuXG4gICAqL1xuICBmdW5jdGlvbiBNZWRpYUxvYWRlcihwbGF5ZXIsIG9wdGlvbnMsIHJlYWR5KSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgTWVkaWFMb2FkZXIpO1xuXG4gICAgLy8gTWVkaWFMb2FkZXIgaGFzIG5vIGVsZW1lbnRcbiAgICB2YXIgb3B0aW9uc18gPSBtZXJnZU9wdGlvbnMoeyBjcmVhdGVFbDogZmFsc2UgfSwgb3B0aW9ucyk7XG5cbiAgICAvLyBJZiB0aGVyZSBhcmUgbm8gc291cmNlcyB3aGVuIHRoZSBwbGF5ZXIgaXMgaW5pdGlhbGl6ZWQsXG4gICAgLy8gbG9hZCB0aGUgZmlyc3Qgc3VwcG9ydGVkIHBsYXliYWNrIHRlY2hub2xvZ3kuXG5cbiAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9Db21wb25lbnQuY2FsbCh0aGlzLCBwbGF5ZXIsIG9wdGlvbnNfLCByZWFkeSkpO1xuXG4gICAgaWYgKCFvcHRpb25zLnBsYXllck9wdGlvbnMuc291cmNlcyB8fCBvcHRpb25zLnBsYXllck9wdGlvbnMuc291cmNlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBqID0gb3B0aW9ucy5wbGF5ZXJPcHRpb25zLnRlY2hPcmRlcjsgaSA8IGoubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHRlY2hOYW1lID0gdG9UaXRsZUNhc2UoaltpXSk7XG4gICAgICAgIHZhciB0ZWNoID0gVGVjaC5nZXRUZWNoKHRlY2hOYW1lKTtcblxuICAgICAgICAvLyBTdXBwb3J0IG9sZCBiZWhhdmlvciBvZiB0ZWNocyBiZWluZyByZWdpc3RlcmVkIGFzIGNvbXBvbmVudHMuXG4gICAgICAgIC8vIFJlbW92ZSBvbmNlIHRoYXQgZGVwcmVjYXRlZCBiZWhhdmlvciBpcyByZW1vdmVkLlxuICAgICAgICBpZiAoIXRlY2hOYW1lKSB7XG4gICAgICAgICAgdGVjaCA9IENvbXBvbmVudC5nZXRDb21wb25lbnQodGVjaE5hbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGJyb3dzZXIgc3VwcG9ydHMgdGhpcyB0ZWNobm9sb2d5XG4gICAgICAgIGlmICh0ZWNoICYmIHRlY2guaXNTdXBwb3J0ZWQoKSkge1xuICAgICAgICAgIHBsYXllci5sb2FkVGVjaF8odGVjaE5hbWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIExvb3AgdGhyb3VnaCBwbGF5YmFjayB0ZWNobm9sb2dpZXMgKEhUTUw1LCBGbGFzaCkgYW5kIGNoZWNrIGZvciBzdXBwb3J0LlxuICAgICAgLy8gVGhlbiBsb2FkIHRoZSBiZXN0IHNvdXJjZS5cbiAgICAgIC8vIEEgZmV3IGFzc3VtcHRpb25zIGhlcmU6XG4gICAgICAvLyAgIEFsbCBwbGF5YmFjayB0ZWNobm9sb2dpZXMgcmVzcGVjdCBwcmVsb2FkIGZhbHNlLlxuICAgICAgcGxheWVyLnNyYyhvcHRpb25zLnBsYXllck9wdGlvbnMuc291cmNlcyk7XG4gICAgfVxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHJldHVybiBNZWRpYUxvYWRlcjtcbn0oQ29tcG9uZW50KTtcblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdNZWRpYUxvYWRlcicsIE1lZGlhTG9hZGVyKTtcblxuLyoqXG4gKiBAZmlsZSBidXR0b24uanNcbiAqL1xuLyoqXG4gKiBDbGlja2FibGUgQ29tcG9uZW50IHdoaWNoIGlzIGNsaWNrYWJsZSBvciBrZXlib2FyZCBhY3Rpb25hYmxlLFxuICogYnV0IGlzIG5vdCBhIG5hdGl2ZSBIVE1MIGJ1dHRvbi5cbiAqXG4gKiBAZXh0ZW5kcyBDb21wb25lbnRcbiAqL1xuXG52YXIgQ2xpY2thYmxlQ29tcG9uZW50ID0gZnVuY3Rpb24gKF9Db21wb25lbnQpIHtcbiAgaW5oZXJpdHMoQ2xpY2thYmxlQ29tcG9uZW50LCBfQ29tcG9uZW50KTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxuICAgKlxuICAgKiBAcGFyYW0gIHtQbGF5ZXJ9IHBsYXllclxuICAgKiAgICAgICAgIFRoZSBgUGxheWVyYCB0aGF0IHRoaXMgY2xhc3Mgc2hvdWxkIGJlIGF0dGFjaGVkIHRvLlxuICAgKlxuICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgICAgICAgIFRoZSBrZXkvdmFsdWUgc3RvcmUgb2YgcGxheWVyIG9wdGlvbnMuXG4gICAqL1xuICBmdW5jdGlvbiBDbGlja2FibGVDb21wb25lbnQocGxheWVyLCBvcHRpb25zKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgQ2xpY2thYmxlQ29tcG9uZW50KTtcblxuICAgIHZhciBfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX0NvbXBvbmVudC5jYWxsKHRoaXMsIHBsYXllciwgb3B0aW9ucykpO1xuXG4gICAgX3RoaXMuZW1pdFRhcEV2ZW50cygpO1xuXG4gICAgX3RoaXMuZW5hYmxlKCk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSB0aGUgYENvbXBvbmVudGBzIERPTSBlbGVtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW3RhZz1kaXZdXG4gICAqICAgICAgICBUaGUgZWxlbWVudCdzIG5vZGUgdHlwZS5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtwcm9wcz17fV1cbiAgICogICAgICAgIEFuIG9iamVjdCBvZiBwcm9wZXJ0aWVzIHRoYXQgc2hvdWxkIGJlIHNldCBvbiB0aGUgZWxlbWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFthdHRyaWJ1dGVzPXt9XVxuICAgKiAgICAgICAgQW4gb2JqZWN0IG9mIGF0dHJpYnV0ZXMgdGhhdCBzaG91bGQgYmUgc2V0IG9uIHRoZSBlbGVtZW50LlxuICAgKlxuICAgKiBAcmV0dXJuIHtFbGVtZW50fVxuICAgKiAgICAgICAgIFRoZSBlbGVtZW50IHRoYXQgZ2V0cyBjcmVhdGVkLlxuICAgKi9cblxuXG4gIENsaWNrYWJsZUNvbXBvbmVudC5wcm90b3R5cGUuY3JlYXRlRWwgPSBmdW5jdGlvbiBjcmVhdGVFbCQkMSgpIHtcbiAgICB2YXIgdGFnID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAnZGl2JztcbiAgICB2YXIgcHJvcHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIHZhciBhdHRyaWJ1dGVzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcblxuICAgIHByb3BzID0gYXNzaWduKHtcbiAgICAgIGlubmVySFRNTDogJzxzcGFuIGFyaWEtaGlkZGVuPVwidHJ1ZVwiIGNsYXNzPVwidmpzLWljb24tcGxhY2Vob2xkZXJcIj48L3NwYW4+JyxcbiAgICAgIGNsYXNzTmFtZTogdGhpcy5idWlsZENTU0NsYXNzKCksXG4gICAgICB0YWJJbmRleDogMFxuICAgIH0sIHByb3BzKTtcblxuICAgIGlmICh0YWcgPT09ICdidXR0b24nKSB7XG4gICAgICBsb2cuZXJyb3IoJ0NyZWF0aW5nIGEgQ2xpY2thYmxlQ29tcG9uZW50IHdpdGggYW4gSFRNTCBlbGVtZW50IG9mICcgKyB0YWcgKyAnIGlzIG5vdCBzdXBwb3J0ZWQ7IHVzZSBhIEJ1dHRvbiBpbnN0ZWFkLicpO1xuICAgIH1cblxuICAgIC8vIEFkZCBBUklBIGF0dHJpYnV0ZXMgZm9yIGNsaWNrYWJsZSBlbGVtZW50IHdoaWNoIGlzIG5vdCBhIG5hdGl2ZSBIVE1MIGJ1dHRvblxuICAgIGF0dHJpYnV0ZXMgPSBhc3NpZ24oe1xuICAgICAgcm9sZTogJ2J1dHRvbidcbiAgICB9LCBhdHRyaWJ1dGVzKTtcblxuICAgIHRoaXMudGFiSW5kZXhfID0gcHJvcHMudGFiSW5kZXg7XG5cbiAgICB2YXIgZWwgPSBfQ29tcG9uZW50LnByb3RvdHlwZS5jcmVhdGVFbC5jYWxsKHRoaXMsIHRhZywgcHJvcHMsIGF0dHJpYnV0ZXMpO1xuXG4gICAgdGhpcy5jcmVhdGVDb250cm9sVGV4dEVsKGVsKTtcblxuICAgIHJldHVybiBlbDtcbiAgfTtcblxuICBDbGlja2FibGVDb21wb25lbnQucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiBkaXNwb3NlKCkge1xuICAgIC8vIHJlbW92ZSBjb250cm9sVGV4dEVsXyBvbiBkaXBvc2VcbiAgICB0aGlzLmNvbnRyb2xUZXh0RWxfID0gbnVsbDtcblxuICAgIF9Db21wb25lbnQucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlIGEgY29udHJvbCB0ZXh0IGVsZW1lbnQgb24gdGhpcyBgQ29tcG9uZW50YFxuICAgKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IFtlbF1cbiAgICogICAgICAgIFBhcmVudCBlbGVtZW50IGZvciB0aGUgY29udHJvbCB0ZXh0LlxuICAgKlxuICAgKiBAcmV0dXJuIHtFbGVtZW50fVxuICAgKiAgICAgICAgIFRoZSBjb250cm9sIHRleHQgZWxlbWVudCB0aGF0IGdldHMgY3JlYXRlZC5cbiAgICovXG5cblxuICBDbGlja2FibGVDb21wb25lbnQucHJvdG90eXBlLmNyZWF0ZUNvbnRyb2xUZXh0RWwgPSBmdW5jdGlvbiBjcmVhdGVDb250cm9sVGV4dEVsKGVsKSB7XG4gICAgdGhpcy5jb250cm9sVGV4dEVsXyA9IGNyZWF0ZUVsKCdzcGFuJywge1xuICAgICAgY2xhc3NOYW1lOiAndmpzLWNvbnRyb2wtdGV4dCdcbiAgICB9LCB7XG4gICAgICAvLyBsZXQgdGhlIHNjcmVlbiByZWFkZXIgdXNlciBrbm93IHRoYXQgdGhlIHRleHQgb2YgdGhlIGVsZW1lbnQgbWF5IGNoYW5nZVxuICAgICAgJ2FyaWEtbGl2ZSc6ICdwb2xpdGUnXG4gICAgfSk7XG5cbiAgICBpZiAoZWwpIHtcbiAgICAgIGVsLmFwcGVuZENoaWxkKHRoaXMuY29udHJvbFRleHRFbF8pO1xuICAgIH1cblxuICAgIHRoaXMuY29udHJvbFRleHQodGhpcy5jb250cm9sVGV4dF8sIGVsKTtcblxuICAgIHJldHVybiB0aGlzLmNvbnRyb2xUZXh0RWxfO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgb3Igc2V0IHRoZSBsb2NhbGl6ZSB0ZXh0IHRvIHVzZSBmb3IgdGhlIGNvbnRyb2xzIG9uIHRoZSBgQ29tcG9uZW50YC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IFt0ZXh0XVxuICAgKiAgICAgICAgQ29udHJvbCB0ZXh0IGZvciBlbGVtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IFtlbD10aGlzLmVsKCldXG4gICAqICAgICAgICBFbGVtZW50IHRvIHNldCB0aGUgdGl0bGUgb24uXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICogICAgICAgICAtIFRoZSBjb250cm9sIHRleHQgd2hlbiBnZXR0aW5nXG4gICAqL1xuXG5cbiAgQ2xpY2thYmxlQ29tcG9uZW50LnByb3RvdHlwZS5jb250cm9sVGV4dCA9IGZ1bmN0aW9uIGNvbnRyb2xUZXh0KHRleHQpIHtcbiAgICB2YXIgZWwgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRoaXMuZWwoKTtcblxuICAgIGlmICh0ZXh0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbnRyb2xUZXh0XyB8fCAnTmVlZCBUZXh0JztcbiAgICB9XG5cbiAgICB2YXIgbG9jYWxpemVkVGV4dCA9IHRoaXMubG9jYWxpemUodGV4dCk7XG5cbiAgICB0aGlzLmNvbnRyb2xUZXh0XyA9IHRleHQ7XG4gICAgdGV4dENvbnRlbnQodGhpcy5jb250cm9sVGV4dEVsXywgbG9jYWxpemVkVGV4dCk7XG4gICAgaWYgKCF0aGlzLm5vbkljb25Db250cm9sKSB7XG4gICAgICAvLyBTZXQgdGl0bGUgYXR0cmlidXRlIGlmIG9ubHkgYW4gaWNvbiBpcyBzaG93blxuICAgICAgZWwuc2V0QXR0cmlidXRlKCd0aXRsZScsIGxvY2FsaXplZFRleHQpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQnVpbGRzIHRoZSBkZWZhdWx0IERPTSBgY2xhc3NOYW1lYC5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKiAgICAgICAgIFRoZSBET00gYGNsYXNzTmFtZWAgZm9yIHRoaXMgb2JqZWN0LlxuICAgKi9cblxuXG4gIENsaWNrYWJsZUNvbXBvbmVudC5wcm90b3R5cGUuYnVpbGRDU1NDbGFzcyA9IGZ1bmN0aW9uIGJ1aWxkQ1NTQ2xhc3MoKSB7XG4gICAgcmV0dXJuICd2anMtY29udHJvbCB2anMtYnV0dG9uICcgKyBfQ29tcG9uZW50LnByb3RvdHlwZS5idWlsZENTU0NsYXNzLmNhbGwodGhpcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEVuYWJsZSB0aGlzIGBDb21wb25lbnRgcyBlbGVtZW50LlxuICAgKi9cblxuXG4gIENsaWNrYWJsZUNvbXBvbmVudC5wcm90b3R5cGUuZW5hYmxlID0gZnVuY3Rpb24gZW5hYmxlKCkge1xuICAgIGlmICghdGhpcy5lbmFibGVkXykge1xuICAgICAgdGhpcy5lbmFibGVkXyA9IHRydWU7XG4gICAgICB0aGlzLnJlbW92ZUNsYXNzKCd2anMtZGlzYWJsZWQnKTtcbiAgICAgIHRoaXMuZWxfLnNldEF0dHJpYnV0ZSgnYXJpYS1kaXNhYmxlZCcsICdmYWxzZScpO1xuICAgICAgaWYgKHR5cGVvZiB0aGlzLnRhYkluZGV4XyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhpcy5lbF8uc2V0QXR0cmlidXRlKCd0YWJJbmRleCcsIHRoaXMudGFiSW5kZXhfKTtcbiAgICAgIH1cbiAgICAgIHRoaXMub24oWyd0YXAnLCAnY2xpY2snXSwgdGhpcy5oYW5kbGVDbGljayk7XG4gICAgICB0aGlzLm9uKCdmb2N1cycsIHRoaXMuaGFuZGxlRm9jdXMpO1xuICAgICAgdGhpcy5vbignYmx1cicsIHRoaXMuaGFuZGxlQmx1cik7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBEaXNhYmxlIHRoaXMgYENvbXBvbmVudGBzIGVsZW1lbnQuXG4gICAqL1xuXG5cbiAgQ2xpY2thYmxlQ29tcG9uZW50LnByb3RvdHlwZS5kaXNhYmxlID0gZnVuY3Rpb24gZGlzYWJsZSgpIHtcbiAgICB0aGlzLmVuYWJsZWRfID0gZmFsc2U7XG4gICAgdGhpcy5hZGRDbGFzcygndmpzLWRpc2FibGVkJyk7XG4gICAgdGhpcy5lbF8uc2V0QXR0cmlidXRlKCdhcmlhLWRpc2FibGVkJywgJ3RydWUnKTtcbiAgICBpZiAodHlwZW9mIHRoaXMudGFiSW5kZXhfICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhpcy5lbF8ucmVtb3ZlQXR0cmlidXRlKCd0YWJJbmRleCcpO1xuICAgIH1cbiAgICB0aGlzLm9mZihbJ3RhcCcsICdjbGljayddLCB0aGlzLmhhbmRsZUNsaWNrKTtcbiAgICB0aGlzLm9mZignZm9jdXMnLCB0aGlzLmhhbmRsZUZvY3VzKTtcbiAgICB0aGlzLm9mZignYmx1cicsIHRoaXMuaGFuZGxlQmx1cik7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoaXMgZ2V0cyBjYWxsZWQgd2hlbiBhIGBDbGlja2FibGVDb21wb25lbnRgIGdldHM6XG4gICAqIC0gQ2xpY2tlZCAodmlhIHRoZSBgY2xpY2tgIGV2ZW50LCBsaXN0ZW5pbmcgc3RhcnRzIGluIHRoZSBjb25zdHJ1Y3RvcilcbiAgICogLSBUYXBwZWQgKHZpYSB0aGUgYHRhcGAgZXZlbnQsIGxpc3RlbmluZyBzdGFydHMgaW4gdGhlIGNvbnN0cnVjdG9yKVxuICAgKiAtIFRoZSBmb2xsb3dpbmcgdGhpbmdzIGhhcHBlbiBpbiBvcmRlcjpcbiAgICogICAxLiB7QGxpbmsgQ2xpY2thYmxlQ29tcG9uZW50I2hhbmRsZUZvY3VzfSBpcyBjYWxsZWQgdmlhIGEgYGZvY3VzYCBldmVudCBvbiB0aGVcbiAgICogICAgICBgQ2xpY2thYmxlQ29tcG9uZW50YC5cbiAgICogICAyLiB7QGxpbmsgQ2xpY2thYmxlQ29tcG9uZW50I2hhbmRsZUZvY3VzfSBhZGRzIGEgbGlzdGVuZXIgZm9yIGBrZXlkb3duYCBvbiB1c2luZ1xuICAgKiAgICAgIHtAbGluayBDbGlja2FibGVDb21wb25lbnQjaGFuZGxlS2V5UHJlc3N9LlxuICAgKiAgIDMuIGBDbGlja2FibGVDb21wb25lbnRgIGhhcyBub3QgaGFkIGEgYGJsdXJgIGV2ZW50IChgYmx1cmAgbWVhbnMgdGhhdCBmb2N1cyB3YXMgbG9zdCkuIFRoZSB1c2VyIHByZXNzZXNcbiAgICogICAgICB0aGUgc3BhY2Ugb3IgZW50ZXIga2V5LlxuICAgKiAgIDQuIHtAbGluayBDbGlja2FibGVDb21wb25lbnQjaGFuZGxlS2V5UHJlc3N9IGNhbGxzIHRoaXMgZnVuY3Rpb24gd2l0aCB0aGUgYGtleWRvd25gXG4gICAqICAgICAgZXZlbnQgYXMgYSBwYXJhbWV0ZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IGV2ZW50XG4gICAqICAgICAgICBUaGUgYGtleWRvd25gLCBgdGFwYCwgb3IgYGNsaWNrYCBldmVudCB0aGF0IGNhdXNlZCB0aGlzIGZ1bmN0aW9uIHRvIGJlXG4gICAqICAgICAgICBjYWxsZWQuXG4gICAqXG4gICAqIEBsaXN0ZW5zIHRhcFxuICAgKiBAbGlzdGVucyBjbGlja1xuICAgKiBAYWJzdHJhY3RcbiAgICovXG5cblxuICBDbGlja2FibGVDb21wb25lbnQucHJvdG90eXBlLmhhbmRsZUNsaWNrID0gZnVuY3Rpb24gaGFuZGxlQ2xpY2soZXZlbnQpIHt9O1xuXG4gIC8qKlxuICAgKiBUaGlzIGdldHMgY2FsbGVkIHdoZW4gYSBgQ2xpY2thYmxlQ29tcG9uZW50YCBnYWlucyBmb2N1cyB2aWEgYSBgZm9jdXNgIGV2ZW50LlxuICAgKiBUdXJucyBvbiBsaXN0ZW5pbmcgZm9yIGBrZXlkb3duYCBldmVudHMuIFdoZW4gdGhleSBoYXBwZW4gaXRcbiAgICogY2FsbHMgYHRoaXMuaGFuZGxlS2V5UHJlc3NgLlxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBldmVudFxuICAgKiAgICAgICAgVGhlIGBmb2N1c2AgZXZlbnQgdGhhdCBjYXVzZWQgdGhpcyBmdW5jdGlvbiB0byBiZSBjYWxsZWQuXG4gICAqXG4gICAqIEBsaXN0ZW5zIGZvY3VzXG4gICAqL1xuXG5cbiAgQ2xpY2thYmxlQ29tcG9uZW50LnByb3RvdHlwZS5oYW5kbGVGb2N1cyA9IGZ1bmN0aW9uIGhhbmRsZUZvY3VzKGV2ZW50KSB7XG4gICAgb24oZG9jdW1lbnQsICdrZXlkb3duJywgYmluZCh0aGlzLCB0aGlzLmhhbmRsZUtleVByZXNzKSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENhbGxlZCB3aGVuIHRoaXMgQ2xpY2thYmxlQ29tcG9uZW50IGhhcyBmb2N1cyBhbmQgYSBrZXkgZ2V0cyBwcmVzc2VkIGRvd24uIEJ5XG4gICAqIGRlZmF1bHQgaXQgd2lsbCBjYWxsIGB0aGlzLmhhbmRsZUNsaWNrYCB3aGVuIHRoZSBrZXkgaXMgc3BhY2Ugb3IgZW50ZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IGV2ZW50XG4gICAqICAgICAgICBUaGUgYGtleWRvd25gIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgZnVuY3Rpb24gdG8gYmUgY2FsbGVkLlxuICAgKlxuICAgKiBAbGlzdGVucyBrZXlkb3duXG4gICAqL1xuXG5cbiAgQ2xpY2thYmxlQ29tcG9uZW50LnByb3RvdHlwZS5oYW5kbGVLZXlQcmVzcyA9IGZ1bmN0aW9uIGhhbmRsZUtleVByZXNzKGV2ZW50KSB7XG5cbiAgICAvLyBTdXBwb3J0IFNwYWNlICgzMikgb3IgRW50ZXIgKDEzKSBrZXkgb3BlcmF0aW9uIHRvIGZpcmUgYSBjbGljayBldmVudFxuICAgIGlmIChldmVudC53aGljaCA9PT0gMzIgfHwgZXZlbnQud2hpY2ggPT09IDEzKSB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgdGhpcy50cmlnZ2VyKCdjbGljaycpO1xuICAgIH0gZWxzZSBpZiAoX0NvbXBvbmVudC5wcm90b3R5cGUuaGFuZGxlS2V5UHJlc3MpIHtcblxuICAgICAgLy8gUGFzcyBrZXlwcmVzcyBoYW5kbGluZyB1cCBmb3IgdW5zdXBwb3J0ZWQga2V5c1xuICAgICAgX0NvbXBvbmVudC5wcm90b3R5cGUuaGFuZGxlS2V5UHJlc3MuY2FsbCh0aGlzLCBldmVudCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBDYWxsZWQgd2hlbiBhIGBDbGlja2FibGVDb21wb25lbnRgIGxvc2VzIGZvY3VzLiBUdXJucyBvZmYgdGhlIGxpc3RlbmVyIGZvclxuICAgKiBga2V5ZG93bmAgZXZlbnRzLiBXaGljaCBTdG9wcyBgdGhpcy5oYW5kbGVLZXlQcmVzc2AgZnJvbSBnZXR0aW5nIGNhbGxlZC5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gZXZlbnRcbiAgICogICAgICAgIFRoZSBgYmx1cmAgZXZlbnQgdGhhdCBjYXVzZWQgdGhpcyBmdW5jdGlvbiB0byBiZSBjYWxsZWQuXG4gICAqXG4gICAqIEBsaXN0ZW5zIGJsdXJcbiAgICovXG5cblxuICBDbGlja2FibGVDb21wb25lbnQucHJvdG90eXBlLmhhbmRsZUJsdXIgPSBmdW5jdGlvbiBoYW5kbGVCbHVyKGV2ZW50KSB7XG4gICAgb2ZmKGRvY3VtZW50LCAna2V5ZG93bicsIGJpbmQodGhpcywgdGhpcy5oYW5kbGVLZXlQcmVzcykpO1xuICB9O1xuXG4gIHJldHVybiBDbGlja2FibGVDb21wb25lbnQ7XG59KENvbXBvbmVudCk7XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnQ2xpY2thYmxlQ29tcG9uZW50JywgQ2xpY2thYmxlQ29tcG9uZW50KTtcblxuLyoqXG4gKiBAZmlsZSBwb3N0ZXItaW1hZ2UuanNcbiAqL1xuLyoqXG4gKiBBIGBDbGlja2FibGVDb21wb25lbnRgIHRoYXQgaGFuZGxlcyBzaG93aW5nIHRoZSBwb3N0ZXIgaW1hZ2UgZm9yIHRoZSBwbGF5ZXIuXG4gKlxuICogQGV4dGVuZHMgQ2xpY2thYmxlQ29tcG9uZW50XG4gKi9cblxudmFyIFBvc3RlckltYWdlID0gZnVuY3Rpb24gKF9DbGlja2FibGVDb21wb25lbnQpIHtcbiAgaW5oZXJpdHMoUG9zdGVySW1hZ2UsIF9DbGlja2FibGVDb21wb25lbnQpO1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcy5cbiAgICpcbiAgICogQHBhcmFtIHtQbGF5ZXJ9IHBsYXllclxuICAgKiAgICAgICAgVGhlIGBQbGF5ZXJgIHRoYXQgdGhpcyBjbGFzcyBzaG91bGQgYXR0YWNoIHRvLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgICAgICBUaGUga2V5L3ZhbHVlIHN0b3JlIG9mIHBsYXllciBvcHRpb25zLlxuICAgKi9cbiAgZnVuY3Rpb24gUG9zdGVySW1hZ2UocGxheWVyLCBvcHRpb25zKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgUG9zdGVySW1hZ2UpO1xuXG4gICAgdmFyIF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfQ2xpY2thYmxlQ29tcG9uZW50LmNhbGwodGhpcywgcGxheWVyLCBvcHRpb25zKSk7XG5cbiAgICBfdGhpcy51cGRhdGUoKTtcbiAgICBwbGF5ZXIub24oJ3Bvc3RlcmNoYW5nZScsIGJpbmQoX3RoaXMsIF90aGlzLnVwZGF0ZSkpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBDbGVhbiB1cCBhbmQgZGlzcG9zZSBvZiB0aGUgYFBvc3RlckltYWdlYC5cbiAgICovXG5cblxuICBQb3N0ZXJJbWFnZS5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XG4gICAgdGhpcy5wbGF5ZXIoKS5vZmYoJ3Bvc3RlcmNoYW5nZScsIHRoaXMudXBkYXRlKTtcbiAgICBfQ2xpY2thYmxlQ29tcG9uZW50LnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSB0aGUgYFBvc3RlckltYWdlYHMgRE9NIGVsZW1lbnQuXG4gICAqXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9XG4gICAqICAgICAgICAgVGhlIGVsZW1lbnQgdGhhdCBnZXRzIGNyZWF0ZWQuXG4gICAqL1xuXG5cbiAgUG9zdGVySW1hZ2UucHJvdG90eXBlLmNyZWF0ZUVsID0gZnVuY3Rpb24gY3JlYXRlRWwkJDEoKSB7XG4gICAgdmFyIGVsID0gY3JlYXRlRWwoJ2RpdicsIHtcbiAgICAgIGNsYXNzTmFtZTogJ3Zqcy1wb3N0ZXInLFxuXG4gICAgICAvLyBEb24ndCB3YW50IHBvc3RlciB0byBiZSB0YWJiYWJsZS5cbiAgICAgIHRhYkluZGV4OiAtMVxuICAgIH0pO1xuXG4gICAgLy8gVG8gZW5zdXJlIHRoZSBwb3N0ZXIgaW1hZ2UgcmVzaXplcyB3aGlsZSBtYWludGFpbmluZyBpdHMgb3JpZ2luYWwgYXNwZWN0XG4gICAgLy8gcmF0aW8sIHVzZSBhIGRpdiB3aXRoIGBiYWNrZ3JvdW5kLXNpemVgIHdoZW4gYXZhaWxhYmxlLiBGb3IgYnJvd3NlcnMgdGhhdFxuICAgIC8vIGRvIG5vdCBzdXBwb3J0IGBiYWNrZ3JvdW5kLXNpemVgIChlLmcuIElFOCksIGZhbGwgYmFjayBvbiB1c2luZyBhIHJlZ3VsYXJcbiAgICAvLyBpbWcgZWxlbWVudC5cbiAgICBpZiAoIUJBQ0tHUk9VTkRfU0laRV9TVVBQT1JURUQpIHtcbiAgICAgIHRoaXMuZmFsbGJhY2tJbWdfID0gY3JlYXRlRWwoJ2ltZycpO1xuICAgICAgZWwuYXBwZW5kQ2hpbGQodGhpcy5mYWxsYmFja0ltZ18pO1xuICAgIH1cblxuICAgIHJldHVybiBlbDtcbiAgfTtcblxuICAvKipcbiAgICogQW4ge0BsaW5rIEV2ZW50VGFyZ2V0fkV2ZW50TGlzdGVuZXJ9IGZvciB7QGxpbmsgUGxheWVyI3Bvc3RlcmNoYW5nZX0gZXZlbnRzLlxuICAgKlxuICAgKiBAbGlzdGVucyBQbGF5ZXIjcG9zdGVyY2hhbmdlXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IFtldmVudF1cbiAgICogICAgICAgIFRoZSBgUGxheWVyI3Bvc3RlcmNoYW5nZWAgZXZlbnQgdGhhdCB0cmlnZ2VyZWQgdGhpcyBmdW5jdGlvbi5cbiAgICovXG5cblxuICBQb3N0ZXJJbWFnZS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlKGV2ZW50KSB7XG4gICAgdmFyIHVybCA9IHRoaXMucGxheWVyKCkucG9zdGVyKCk7XG5cbiAgICB0aGlzLnNldFNyYyh1cmwpO1xuXG4gICAgLy8gSWYgdGhlcmUncyBubyBwb3N0ZXIgc291cmNlIHdlIHNob3VsZCBkaXNwbGF5Om5vbmUgb24gdGhpcyBjb21wb25lbnRcbiAgICAvLyBzbyBpdCdzIG5vdCBzdGlsbCBjbGlja2FibGUgb3IgcmlnaHQtY2xpY2thYmxlXG4gICAgaWYgKHVybCkge1xuICAgICAgdGhpcy5zaG93KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaGlkZSgpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogU2V0IHRoZSBzb3VyY2Ugb2YgdGhlIGBQb3N0ZXJJbWFnZWAgZGVwZW5kaW5nIG9uIHRoZSBkaXNwbGF5IG1ldGhvZC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHVybFxuICAgKiAgICAgICAgVGhlIFVSTCB0byB0aGUgc291cmNlIGZvciB0aGUgYFBvc3RlckltYWdlYC5cbiAgICovXG5cblxuICBQb3N0ZXJJbWFnZS5wcm90b3R5cGUuc2V0U3JjID0gZnVuY3Rpb24gc2V0U3JjKHVybCkge1xuICAgIGlmICh0aGlzLmZhbGxiYWNrSW1nXykge1xuICAgICAgdGhpcy5mYWxsYmFja0ltZ18uc3JjID0gdXJsO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYmFja2dyb3VuZEltYWdlID0gJyc7XG5cbiAgICAgIC8vIEFueSBmYWxzZXkgdmFsdWVzIHNob3VsZCBzdGF5IGFzIGFuIGVtcHR5IHN0cmluZywgb3RoZXJ3aXNlXG4gICAgICAvLyB0aGlzIHdpbGwgdGhyb3cgYW4gZXh0cmEgZXJyb3JcbiAgICAgIGlmICh1cmwpIHtcbiAgICAgICAgYmFja2dyb3VuZEltYWdlID0gJ3VybChcIicgKyB1cmwgKyAnXCIpJztcbiAgICAgIH1cblxuICAgICAgdGhpcy5lbF8uc3R5bGUuYmFja2dyb3VuZEltYWdlID0gYmFja2dyb3VuZEltYWdlO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQW4ge0BsaW5rIEV2ZW50VGFyZ2V0fkV2ZW50TGlzdGVuZXJ9IGZvciBjbGlja3Mgb24gdGhlIGBQb3N0ZXJJbWFnZWAuIFNlZVxuICAgKiB7QGxpbmsgQ2xpY2thYmxlQ29tcG9uZW50I2hhbmRsZUNsaWNrfSBmb3IgaW5zdGFuY2VzIHdoZXJlIHRoaXMgd2lsbCBiZSB0cmlnZ2VyZWQuXG4gICAqXG4gICAqIEBsaXN0ZW5zIHRhcFxuICAgKiBAbGlzdGVucyBjbGlja1xuICAgKiBAbGlzdGVucyBrZXlkb3duXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IGV2ZW50XG4gICArICAgICAgICBUaGUgYGNsaWNrYCwgYHRhcGAgb3IgYGtleWRvd25gIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgZnVuY3Rpb24gdG8gYmUgY2FsbGVkLlxuICAgKi9cblxuXG4gIFBvc3RlckltYWdlLnByb3RvdHlwZS5oYW5kbGVDbGljayA9IGZ1bmN0aW9uIGhhbmRsZUNsaWNrKGV2ZW50KSB7XG4gICAgLy8gV2UgZG9uJ3Qgd2FudCBhIGNsaWNrIHRvIHRyaWdnZXIgcGxheWJhY2sgd2hlbiBjb250cm9scyBhcmUgZGlzYWJsZWRcbiAgICBpZiAoIXRoaXMucGxheWVyXy5jb250cm9scygpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMucGxheWVyXy5wYXVzZWQoKSkge1xuICAgICAgc2lsZW5jZVByb21pc2UodGhpcy5wbGF5ZXJfLnBsYXkoKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucGxheWVyXy5wYXVzZSgpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gUG9zdGVySW1hZ2U7XG59KENsaWNrYWJsZUNvbXBvbmVudCk7XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnUG9zdGVySW1hZ2UnLCBQb3N0ZXJJbWFnZSk7XG5cbi8qKlxuICogQGZpbGUgdGV4dC10cmFjay1kaXNwbGF5LmpzXG4gKi9cbnZhciBkYXJrR3JheSA9ICcjMjIyJztcbnZhciBsaWdodEdyYXkgPSAnI2NjYyc7XG52YXIgZm9udE1hcCA9IHtcbiAgbW9ub3NwYWNlOiAnbW9ub3NwYWNlJyxcbiAgc2Fuc1NlcmlmOiAnc2Fucy1zZXJpZicsXG4gIHNlcmlmOiAnc2VyaWYnLFxuICBtb25vc3BhY2VTYW5zU2VyaWY6ICdcIkFuZGFsZSBNb25vXCIsIFwiTHVjaWRhIENvbnNvbGVcIiwgbW9ub3NwYWNlJyxcbiAgbW9ub3NwYWNlU2VyaWY6ICdcIkNvdXJpZXIgTmV3XCIsIG1vbm9zcGFjZScsXG4gIHByb3BvcnRpb25hbFNhbnNTZXJpZjogJ3NhbnMtc2VyaWYnLFxuICBwcm9wb3J0aW9uYWxTZXJpZjogJ3NlcmlmJyxcbiAgY2FzdWFsOiAnXCJDb21pYyBTYW5zIE1TXCIsIEltcGFjdCwgZmFudGFzeScsXG4gIHNjcmlwdDogJ1wiTW9ub3R5cGUgQ29yc2l2YVwiLCBjdXJzaXZlJyxcbiAgc21hbGxjYXBzOiAnXCJBbmRhbGUgTW9ub1wiLCBcIkx1Y2lkYSBDb25zb2xlXCIsIG1vbm9zcGFjZSwgc2Fucy1zZXJpZidcbn07XG5cbi8qKlxuICogQ29uc3RydWN0IGFuIHJnYmEgY29sb3IgZnJvbSBhIGdpdmVuIGhleCBjb2xvciBjb2RlLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBjb2xvclxuICogICAgICAgIEhleCBudW1iZXIgZm9yIGNvbG9yLCBsaWtlICNmMGUgb3IgI2Y2MDRlMi5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gb3BhY2l0eVxuICogICAgICAgIFZhbHVlIGZvciBvcGFjaXR5LCAwLjAgLSAxLjAuXG4gKlxuICogQHJldHVybiB7c3RyaW5nfVxuICogICAgICAgICBUaGUgcmdiYSBjb2xvciB0aGF0IHdhcyBjcmVhdGVkLCBsaWtlICdyZ2JhKDI1NSwgMCwgMCwgMC4zKScuXG4gKi9cbmZ1bmN0aW9uIGNvbnN0cnVjdENvbG9yKGNvbG9yLCBvcGFjaXR5KSB7XG4gIHZhciBoZXggPSB2b2lkIDA7XG5cbiAgaWYgKGNvbG9yLmxlbmd0aCA9PT0gNCkge1xuICAgIC8vIGNvbG9yIGxvb2tzIGxpa2UgXCIjZjBlXCJcbiAgICBoZXggPSBjb2xvclsxXSArIGNvbG9yWzFdICsgY29sb3JbMl0gKyBjb2xvclsyXSArIGNvbG9yWzNdICsgY29sb3JbM107XG4gIH0gZWxzZSBpZiAoY29sb3IubGVuZ3RoID09PSA3KSB7XG4gICAgLy8gY29sb3IgbG9va3MgbGlrZSBcIiNmNjA0ZTJcIlxuICAgIGhleCA9IGNvbG9yLnNsaWNlKDEpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjb2xvciBjb2RlIHByb3ZpZGVkLCAnICsgY29sb3IgKyAnOyBtdXN0IGJlIGZvcm1hdHRlZCBhcyBlLmcuICNmMGUgb3IgI2Y2MDRlMi4nKTtcbiAgfVxuICByZXR1cm4gJ3JnYmEoJyArIHBhcnNlSW50KGhleC5zbGljZSgwLCAyKSwgMTYpICsgJywnICsgcGFyc2VJbnQoaGV4LnNsaWNlKDIsIDQpLCAxNikgKyAnLCcgKyBwYXJzZUludChoZXguc2xpY2UoNCwgNiksIDE2KSArICcsJyArIG9wYWNpdHkgKyAnKSc7XG59XG5cbi8qKlxuICogVHJ5IHRvIHVwZGF0ZSB0aGUgc3R5bGUgb2YgYSBET00gZWxlbWVudC4gU29tZSBzdHlsZSBjaGFuZ2VzIHdpbGwgdGhyb3cgYW4gZXJyb3IsXG4gKiBwYXJ0aWN1bGFybHkgaW4gSUU4LiBUaG9zZSBzaG91bGQgYmUgbm9vcHMuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogICAgICAgIFRoZSBET00gZWxlbWVudCB0byBiZSBzdHlsZWQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0eWxlXG4gKiAgICAgICAgVGhlIENTUyBwcm9wZXJ0eSBvbiB0aGUgZWxlbWVudCB0aGF0IHNob3VsZCBiZSBzdHlsZWQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHJ1bGVcbiAqICAgICAgICBUaGUgc3R5bGUgcnVsZSB0aGF0IHNob3VsZCBiZSBhcHBsaWVkIHRvIHRoZSBwcm9wZXJ0eS5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiB0cnlVcGRhdGVTdHlsZShlbCwgc3R5bGUsIHJ1bGUpIHtcbiAgdHJ5IHtcbiAgICBlbC5zdHlsZVtzdHlsZV0gPSBydWxlO1xuICB9IGNhdGNoIChlKSB7XG5cbiAgICAvLyBTYXRpc2ZpZXMgbGludGVyLlxuICAgIHJldHVybjtcbiAgfVxufVxuXG4vKipcbiAqIFRoZSBjb21wb25lbnQgZm9yIGRpc3BsYXlpbmcgdGV4dCB0cmFjayBjdWVzLlxuICpcbiAqIEBleHRlbmRzIENvbXBvbmVudFxuICovXG5cbnZhciBUZXh0VHJhY2tEaXNwbGF5ID0gZnVuY3Rpb24gKF9Db21wb25lbnQpIHtcbiAgaW5oZXJpdHMoVGV4dFRyYWNrRGlzcGxheSwgX0NvbXBvbmVudCk7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcy5cbiAgICpcbiAgICogQHBhcmFtIHtQbGF5ZXJ9IHBsYXllclxuICAgKiAgICAgICAgVGhlIGBQbGF5ZXJgIHRoYXQgdGhpcyBjbGFzcyBzaG91bGQgYmUgYXR0YWNoZWQgdG8uXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICAgICAgIFRoZSBrZXkvdmFsdWUgc3RvcmUgb2YgcGxheWVyIG9wdGlvbnMuXG4gICAqXG4gICAqIEBwYXJhbSB7Q29tcG9uZW50flJlYWR5Q2FsbGJhY2t9IFtyZWFkeV1cbiAgICogICAgICAgIFRoZSBmdW5jdGlvbiB0byBjYWxsIHdoZW4gYFRleHRUcmFja0Rpc3BsYXlgIGlzIHJlYWR5LlxuICAgKi9cbiAgZnVuY3Rpb24gVGV4dFRyYWNrRGlzcGxheShwbGF5ZXIsIG9wdGlvbnMsIHJlYWR5KSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgVGV4dFRyYWNrRGlzcGxheSk7XG5cbiAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9Db21wb25lbnQuY2FsbCh0aGlzLCBwbGF5ZXIsIG9wdGlvbnMsIHJlYWR5KSk7XG5cbiAgICB2YXIgdXBkYXRlRGlzcGxheUhhbmRsZXIgPSBiaW5kKF90aGlzLCBfdGhpcy51cGRhdGVEaXNwbGF5KTtcblxuICAgIHBsYXllci5vbignbG9hZHN0YXJ0JywgYmluZChfdGhpcywgX3RoaXMudG9nZ2xlRGlzcGxheSkpO1xuICAgIHBsYXllci5vbigndGV4dHRyYWNrY2hhbmdlJywgdXBkYXRlRGlzcGxheUhhbmRsZXIpO1xuICAgIHBsYXllci5vbignbG9hZHN0YXJ0JywgYmluZChfdGhpcywgX3RoaXMucHJlc2VsZWN0VHJhY2spKTtcblxuICAgIC8vIFRoaXMgdXNlZCB0byBiZSBjYWxsZWQgZHVyaW5nIHBsYXllciBpbml0LCBidXQgd2FzIGNhdXNpbmcgYW4gZXJyb3JcbiAgICAvLyBpZiBhIHRyYWNrIHNob3VsZCBzaG93IGJ5IGRlZmF1bHQgYW5kIHRoZSBkaXNwbGF5IGhhZG4ndCBsb2FkZWQgeWV0LlxuICAgIC8vIFNob3VsZCBwcm9iYWJseSBiZSBtb3ZlZCB0byBhbiBleHRlcm5hbCB0cmFjayBsb2FkZXIgd2hlbiB3ZSBzdXBwb3J0XG4gICAgLy8gdHJhY2tzIHRoYXQgZG9uJ3QgbmVlZCBhIGRpc3BsYXkuXG4gICAgcGxheWVyLnJlYWR5KGJpbmQoX3RoaXMsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChwbGF5ZXIudGVjaF8gJiYgcGxheWVyLnRlY2hfLmZlYXR1cmVzTmF0aXZlVGV4dFRyYWNrcykge1xuICAgICAgICB0aGlzLmhpZGUoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBwbGF5ZXIub24oJ2Z1bGxzY3JlZW5jaGFuZ2UnLCB1cGRhdGVEaXNwbGF5SGFuZGxlcik7XG4gICAgICBwbGF5ZXIub24oJ3BsYXllcnJlc2l6ZScsIHVwZGF0ZURpc3BsYXlIYW5kbGVyKTtcblxuICAgICAgaWYgKHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdvcmllbnRhdGlvbmNoYW5nZScsIHVwZGF0ZURpc3BsYXlIYW5kbGVyKTtcbiAgICAgIH1cbiAgICAgIHBsYXllci5vbignZGlzcG9zZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdvcmllbnRhdGlvbmNoYW5nZScsIHVwZGF0ZURpc3BsYXlIYW5kbGVyKTtcbiAgICAgIH0pO1xuXG4gICAgICB2YXIgdHJhY2tzID0gdGhpcy5vcHRpb25zXy5wbGF5ZXJPcHRpb25zLnRyYWNrcyB8fCBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5wbGF5ZXJfLmFkZFJlbW90ZVRleHRUcmFjayh0cmFja3NbaV0sIHRydWUpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnByZXNlbGVjdFRyYWNrKCk7XG4gICAgfSkpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIC8qKlxuICAqIFByZXNlbGVjdCBhIHRyYWNrIGZvbGxvd2luZyB0aGlzIHByZWNlZGVuY2U6XG4gICogLSBtYXRjaGVzIHRoZSBwcmV2aW91c2x5IHNlbGVjdGVkIHtAbGluayBUZXh0VHJhY2t9J3MgbGFuZ3VhZ2UgYW5kIGtpbmRcbiAgKiAtIG1hdGNoZXMgdGhlIHByZXZpb3VzbHkgc2VsZWN0ZWQge0BsaW5rIFRleHRUcmFja30ncyBsYW5ndWFnZSBvbmx5XG4gICogLSBpcyB0aGUgZmlyc3QgZGVmYXVsdCBjYXB0aW9ucyB0cmFja1xuICAqIC0gaXMgdGhlIGZpcnN0IGRlZmF1bHQgZGVzY3JpcHRpb25zIHRyYWNrXG4gICpcbiAgKiBAbGlzdGVucyBQbGF5ZXIjbG9hZHN0YXJ0XG4gICovXG5cblxuICBUZXh0VHJhY2tEaXNwbGF5LnByb3RvdHlwZS5wcmVzZWxlY3RUcmFjayA9IGZ1bmN0aW9uIHByZXNlbGVjdFRyYWNrKCkge1xuICAgIHZhciBtb2RlcyA9IHsgY2FwdGlvbnM6IDEsIHN1YnRpdGxlczogMSB9O1xuICAgIHZhciB0cmFja0xpc3QgPSB0aGlzLnBsYXllcl8udGV4dFRyYWNrcygpO1xuICAgIHZhciB1c2VyUHJlZiA9IHRoaXMucGxheWVyXy5jYWNoZV8uc2VsZWN0ZWRMYW5ndWFnZTtcbiAgICB2YXIgZmlyc3REZXNjID0gdm9pZCAwO1xuICAgIHZhciBmaXJzdENhcHRpb25zID0gdm9pZCAwO1xuICAgIHZhciBwcmVmZXJyZWRUcmFjayA9IHZvaWQgMDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHJhY2tMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdHJhY2sgPSB0cmFja0xpc3RbaV07XG5cbiAgICAgIGlmICh1c2VyUHJlZiAmJiB1c2VyUHJlZi5lbmFibGVkICYmIHVzZXJQcmVmLmxhbmd1YWdlID09PSB0cmFjay5sYW5ndWFnZSkge1xuICAgICAgICAvLyBBbHdheXMgY2hvb3NlIHRoZSB0cmFjayB0aGF0IG1hdGNoZXMgYm90aCBsYW5ndWFnZSBhbmQga2luZFxuICAgICAgICBpZiAodHJhY2sua2luZCA9PT0gdXNlclByZWYua2luZCkge1xuICAgICAgICAgIHByZWZlcnJlZFRyYWNrID0gdHJhY2s7XG4gICAgICAgICAgLy8gb3IgY2hvb3NlIHRoZSBmaXJzdCB0cmFjayB0aGF0IG1hdGNoZXMgbGFuZ3VhZ2VcbiAgICAgICAgfSBlbHNlIGlmICghcHJlZmVycmVkVHJhY2spIHtcbiAgICAgICAgICBwcmVmZXJyZWRUcmFjayA9IHRyYWNrO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY2xlYXIgZXZlcnl0aGluZyBpZiBvZmZUZXh0VHJhY2tNZW51SXRlbSB3YXMgY2xpY2tlZFxuICAgICAgfSBlbHNlIGlmICh1c2VyUHJlZiAmJiAhdXNlclByZWYuZW5hYmxlZCkge1xuICAgICAgICBwcmVmZXJyZWRUcmFjayA9IG51bGw7XG4gICAgICAgIGZpcnN0RGVzYyA9IG51bGw7XG4gICAgICAgIGZpcnN0Q2FwdGlvbnMgPSBudWxsO1xuICAgICAgfSBlbHNlIGlmICh0cmFja1snZGVmYXVsdCddKSB7XG4gICAgICAgIGlmICh0cmFjay5raW5kID09PSAnZGVzY3JpcHRpb25zJyAmJiAhZmlyc3REZXNjKSB7XG4gICAgICAgICAgZmlyc3REZXNjID0gdHJhY2s7XG4gICAgICAgIH0gZWxzZSBpZiAodHJhY2sua2luZCBpbiBtb2RlcyAmJiAhZmlyc3RDYXB0aW9ucykge1xuICAgICAgICAgIGZpcnN0Q2FwdGlvbnMgPSB0cmFjaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRoZSBwcmVmZXJyZWRUcmFjayBtYXRjaGVzIHRoZSB1c2VyIHByZWZlcmVuY2UgYW5kIHRha2VzXG4gICAgLy8gcHJlY2VuZGVuY2Ugb3ZlciBhbGwgdGhlIG90aGVyIHRyYWNrcy5cbiAgICAvLyBTbywgZGlzcGxheSB0aGUgcHJlZmVycmVkVHJhY2sgYmVmb3JlIHRoZSBmaXJzdCBkZWZhdWx0IHRyYWNrXG4gICAgLy8gYW5kIHRoZSBzdWJ0aXRsZXMvY2FwdGlvbnMgdHJhY2sgYmVmb3JlIHRoZSBkZXNjcmlwdGlvbnMgdHJhY2tcbiAgICBpZiAocHJlZmVycmVkVHJhY2spIHtcbiAgICAgIHByZWZlcnJlZFRyYWNrLm1vZGUgPSAnc2hvd2luZyc7XG4gICAgfSBlbHNlIGlmIChmaXJzdENhcHRpb25zKSB7XG4gICAgICBmaXJzdENhcHRpb25zLm1vZGUgPSAnc2hvd2luZyc7XG4gICAgfSBlbHNlIGlmIChmaXJzdERlc2MpIHtcbiAgICAgIGZpcnN0RGVzYy5tb2RlID0gJ3Nob3dpbmcnO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogVHVybiBkaXNwbGF5IG9mIHtAbGluayBUZXh0VHJhY2t9J3MgZnJvbSB0aGUgY3VycmVudCBzdGF0ZSBpbnRvIHRoZSBvdGhlciBzdGF0ZS5cbiAgICogVGhlcmUgYXJlIG9ubHkgdHdvIHN0YXRlczpcbiAgICogLSAnc2hvd24nXG4gICAqIC0gJ2hpZGRlbidcbiAgICpcbiAgICogQGxpc3RlbnMgUGxheWVyI2xvYWRzdGFydFxuICAgKi9cblxuXG4gIFRleHRUcmFja0Rpc3BsYXkucHJvdG90eXBlLnRvZ2dsZURpc3BsYXkgPSBmdW5jdGlvbiB0b2dnbGVEaXNwbGF5KCkge1xuICAgIGlmICh0aGlzLnBsYXllcl8udGVjaF8gJiYgdGhpcy5wbGF5ZXJfLnRlY2hfLmZlYXR1cmVzTmF0aXZlVGV4dFRyYWNrcykge1xuICAgICAgdGhpcy5oaWRlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2hvdygpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlIHRoZSB7QGxpbmsgQ29tcG9uZW50fSdzIERPTSBlbGVtZW50LlxuICAgKlxuICAgKiBAcmV0dXJuIHtFbGVtZW50fVxuICAgKiAgICAgICAgIFRoZSBlbGVtZW50IHRoYXQgd2FzIGNyZWF0ZWQuXG4gICAqL1xuXG5cbiAgVGV4dFRyYWNrRGlzcGxheS5wcm90b3R5cGUuY3JlYXRlRWwgPSBmdW5jdGlvbiBjcmVhdGVFbCgpIHtcbiAgICByZXR1cm4gX0NvbXBvbmVudC5wcm90b3R5cGUuY3JlYXRlRWwuY2FsbCh0aGlzLCAnZGl2Jywge1xuICAgICAgY2xhc3NOYW1lOiAndmpzLXRleHQtdHJhY2stZGlzcGxheSdcbiAgICB9LCB7XG4gICAgICAnYXJpYS1saXZlJzogJ29mZicsXG4gICAgICAnYXJpYS1hdG9taWMnOiAndHJ1ZSdcbiAgICB9KTtcbiAgfTtcblxuICAvKipcbiAgICogQ2xlYXIgYWxsIGRpc3BsYXllZCB7QGxpbmsgVGV4dFRyYWNrfXMuXG4gICAqL1xuXG5cbiAgVGV4dFRyYWNrRGlzcGxheS5wcm90b3R5cGUuY2xlYXJEaXNwbGF5ID0gZnVuY3Rpb24gY2xlYXJEaXNwbGF5KCkge1xuICAgIGlmICh0eXBlb2Ygd2luZG93LldlYlZUVCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgd2luZG93LldlYlZUVC5wcm9jZXNzQ3Vlcyh3aW5kb3csIFtdLCB0aGlzLmVsXyk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIGRpc3BsYXllZCBUZXh0VHJhY2sgd2hlbiBhIGVpdGhlciBhIHtAbGluayBQbGF5ZXIjdGV4dHRyYWNrY2hhbmdlfSBvclxuICAgKiBhIHtAbGluayBQbGF5ZXIjZnVsbHNjcmVlbmNoYW5nZX0gaXMgZmlyZWQuXG4gICAqXG4gICAqIEBsaXN0ZW5zIFBsYXllciN0ZXh0dHJhY2tjaGFuZ2VcbiAgICogQGxpc3RlbnMgUGxheWVyI2Z1bGxzY3JlZW5jaGFuZ2VcbiAgICovXG5cblxuICBUZXh0VHJhY2tEaXNwbGF5LnByb3RvdHlwZS51cGRhdGVEaXNwbGF5ID0gZnVuY3Rpb24gdXBkYXRlRGlzcGxheSgpIHtcbiAgICB2YXIgdHJhY2tzID0gdGhpcy5wbGF5ZXJfLnRleHRUcmFja3MoKTtcblxuICAgIHRoaXMuY2xlYXJEaXNwbGF5KCk7XG5cbiAgICAvLyBUcmFjayBkaXNwbGF5IHByaW9yaXRpemF0aW9uIG1vZGVsOiBpZiBtdWx0aXBsZSB0cmFja3MgYXJlICdzaG93aW5nJyxcbiAgICAvLyAgZGlzcGxheSB0aGUgZmlyc3QgJ3N1YnRpdGxlcycgb3IgJ2NhcHRpb25zJyB0cmFjayB3aGljaCBpcyAnc2hvd2luZycsXG4gICAgLy8gIG90aGVyd2lzZSBkaXNwbGF5IHRoZSBmaXJzdCAnZGVzY3JpcHRpb25zJyB0cmFjayB3aGljaCBpcyAnc2hvd2luZydcblxuICAgIHZhciBkZXNjcmlwdGlvbnNUcmFjayA9IG51bGw7XG4gICAgdmFyIGNhcHRpb25zU3VidGl0bGVzVHJhY2sgPSBudWxsO1xuICAgIHZhciBpID0gdHJhY2tzLmxlbmd0aDtcblxuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHZhciB0cmFjayA9IHRyYWNrc1tpXTtcblxuICAgICAgaWYgKHRyYWNrLm1vZGUgPT09ICdzaG93aW5nJykge1xuICAgICAgICBpZiAodHJhY2sua2luZCA9PT0gJ2Rlc2NyaXB0aW9ucycpIHtcbiAgICAgICAgICBkZXNjcmlwdGlvbnNUcmFjayA9IHRyYWNrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNhcHRpb25zU3VidGl0bGVzVHJhY2sgPSB0cmFjaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjYXB0aW9uc1N1YnRpdGxlc1RyYWNrKSB7XG4gICAgICBpZiAodGhpcy5nZXRBdHRyaWJ1dGUoJ2FyaWEtbGl2ZScpICE9PSAnb2ZmJykge1xuICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZSgnYXJpYS1saXZlJywgJ29mZicpO1xuICAgICAgfVxuICAgICAgdGhpcy51cGRhdGVGb3JUcmFjayhjYXB0aW9uc1N1YnRpdGxlc1RyYWNrKTtcbiAgICB9IGVsc2UgaWYgKGRlc2NyaXB0aW9uc1RyYWNrKSB7XG4gICAgICBpZiAodGhpcy5nZXRBdHRyaWJ1dGUoJ2FyaWEtbGl2ZScpICE9PSAnYXNzZXJ0aXZlJykge1xuICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZSgnYXJpYS1saXZlJywgJ2Fzc2VydGl2ZScpO1xuICAgICAgfVxuICAgICAgdGhpcy51cGRhdGVGb3JUcmFjayhkZXNjcmlwdGlvbnNUcmFjayk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBBZGQgYW4ge0BsaW5rIFRleHR0cmFja30gdG8gdG8gdGhlIHtAbGluayBUZWNofXMge0BsaW5rIFRleHRUcmFja0xpc3R9LlxuICAgKlxuICAgKiBAcGFyYW0ge1RleHRUcmFja30gdHJhY2tcbiAgICogICAgICAgIFRleHQgdHJhY2sgb2JqZWN0IHRvIGJlIGFkZGVkIHRvIHRoZSBsaXN0LlxuICAgKi9cblxuXG4gIFRleHRUcmFja0Rpc3BsYXkucHJvdG90eXBlLnVwZGF0ZUZvclRyYWNrID0gZnVuY3Rpb24gdXBkYXRlRm9yVHJhY2sodHJhY2spIHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdy5XZWJWVFQgIT09ICdmdW5jdGlvbicgfHwgIXRyYWNrLmFjdGl2ZUN1ZXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgY3VlcyA9IFtdO1xuXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IHRyYWNrLmFjdGl2ZUN1ZXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICBjdWVzLnB1c2godHJhY2suYWN0aXZlQ3Vlc1tfaV0pO1xuICAgIH1cblxuICAgIHdpbmRvdy5XZWJWVFQucHJvY2Vzc0N1ZXMod2luZG93LCBjdWVzLCB0aGlzLmVsXyk7XG5cbiAgICBpZiAoIXRoaXMucGxheWVyXy50ZXh0VHJhY2tTZXR0aW5ncykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBvdmVycmlkZXMgPSB0aGlzLnBsYXllcl8udGV4dFRyYWNrU2V0dGluZ3MuZ2V0VmFsdWVzKCk7XG5cbiAgICB2YXIgaSA9IGN1ZXMubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgdmFyIGN1ZSA9IGN1ZXNbaV07XG5cbiAgICAgIGlmICghY3VlKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgY3VlRGl2ID0gY3VlLmRpc3BsYXlTdGF0ZTtcblxuICAgICAgaWYgKG92ZXJyaWRlcy5jb2xvcikge1xuICAgICAgICBjdWVEaXYuZmlyc3RDaGlsZC5zdHlsZS5jb2xvciA9IG92ZXJyaWRlcy5jb2xvcjtcbiAgICAgIH1cbiAgICAgIGlmIChvdmVycmlkZXMudGV4dE9wYWNpdHkpIHtcbiAgICAgICAgdHJ5VXBkYXRlU3R5bGUoY3VlRGl2LmZpcnN0Q2hpbGQsICdjb2xvcicsIGNvbnN0cnVjdENvbG9yKG92ZXJyaWRlcy5jb2xvciB8fCAnI2ZmZicsIG92ZXJyaWRlcy50ZXh0T3BhY2l0eSkpO1xuICAgICAgfVxuICAgICAgaWYgKG92ZXJyaWRlcy5iYWNrZ3JvdW5kQ29sb3IpIHtcbiAgICAgICAgY3VlRGl2LmZpcnN0Q2hpbGQuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gb3ZlcnJpZGVzLmJhY2tncm91bmRDb2xvcjtcbiAgICAgIH1cbiAgICAgIGlmIChvdmVycmlkZXMuYmFja2dyb3VuZE9wYWNpdHkpIHtcbiAgICAgICAgdHJ5VXBkYXRlU3R5bGUoY3VlRGl2LmZpcnN0Q2hpbGQsICdiYWNrZ3JvdW5kQ29sb3InLCBjb25zdHJ1Y3RDb2xvcihvdmVycmlkZXMuYmFja2dyb3VuZENvbG9yIHx8ICcjMDAwJywgb3ZlcnJpZGVzLmJhY2tncm91bmRPcGFjaXR5KSk7XG4gICAgICB9XG4gICAgICBpZiAob3ZlcnJpZGVzLndpbmRvd0NvbG9yKSB7XG4gICAgICAgIGlmIChvdmVycmlkZXMud2luZG93T3BhY2l0eSkge1xuICAgICAgICAgIHRyeVVwZGF0ZVN0eWxlKGN1ZURpdiwgJ2JhY2tncm91bmRDb2xvcicsIGNvbnN0cnVjdENvbG9yKG92ZXJyaWRlcy53aW5kb3dDb2xvciwgb3ZlcnJpZGVzLndpbmRvd09wYWNpdHkpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjdWVEaXYuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gb3ZlcnJpZGVzLndpbmRvd0NvbG9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAob3ZlcnJpZGVzLmVkZ2VTdHlsZSkge1xuICAgICAgICBpZiAob3ZlcnJpZGVzLmVkZ2VTdHlsZSA9PT0gJ2Ryb3BzaGFkb3cnKSB7XG4gICAgICAgICAgY3VlRGl2LmZpcnN0Q2hpbGQuc3R5bGUudGV4dFNoYWRvdyA9ICcycHggMnB4IDNweCAnICsgZGFya0dyYXkgKyAnLCAycHggMnB4IDRweCAnICsgZGFya0dyYXkgKyAnLCAycHggMnB4IDVweCAnICsgZGFya0dyYXk7XG4gICAgICAgIH0gZWxzZSBpZiAob3ZlcnJpZGVzLmVkZ2VTdHlsZSA9PT0gJ3JhaXNlZCcpIHtcbiAgICAgICAgICBjdWVEaXYuZmlyc3RDaGlsZC5zdHlsZS50ZXh0U2hhZG93ID0gJzFweCAxcHggJyArIGRhcmtHcmF5ICsgJywgMnB4IDJweCAnICsgZGFya0dyYXkgKyAnLCAzcHggM3B4ICcgKyBkYXJrR3JheTtcbiAgICAgICAgfSBlbHNlIGlmIChvdmVycmlkZXMuZWRnZVN0eWxlID09PSAnZGVwcmVzc2VkJykge1xuICAgICAgICAgIGN1ZURpdi5maXJzdENoaWxkLnN0eWxlLnRleHRTaGFkb3cgPSAnMXB4IDFweCAnICsgbGlnaHRHcmF5ICsgJywgMCAxcHggJyArIGxpZ2h0R3JheSArICcsIC0xcHggLTFweCAnICsgZGFya0dyYXkgKyAnLCAwIC0xcHggJyArIGRhcmtHcmF5O1xuICAgICAgICB9IGVsc2UgaWYgKG92ZXJyaWRlcy5lZGdlU3R5bGUgPT09ICd1bmlmb3JtJykge1xuICAgICAgICAgIGN1ZURpdi5maXJzdENoaWxkLnN0eWxlLnRleHRTaGFkb3cgPSAnMCAwIDRweCAnICsgZGFya0dyYXkgKyAnLCAwIDAgNHB4ICcgKyBkYXJrR3JheSArICcsIDAgMCA0cHggJyArIGRhcmtHcmF5ICsgJywgMCAwIDRweCAnICsgZGFya0dyYXk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChvdmVycmlkZXMuZm9udFBlcmNlbnQgJiYgb3ZlcnJpZGVzLmZvbnRQZXJjZW50ICE9PSAxKSB7XG4gICAgICAgIHZhciBmb250U2l6ZSA9IHdpbmRvdy5wYXJzZUZsb2F0KGN1ZURpdi5zdHlsZS5mb250U2l6ZSk7XG5cbiAgICAgICAgY3VlRGl2LnN0eWxlLmZvbnRTaXplID0gZm9udFNpemUgKiBvdmVycmlkZXMuZm9udFBlcmNlbnQgKyAncHgnO1xuICAgICAgICBjdWVEaXYuc3R5bGUuaGVpZ2h0ID0gJ2F1dG8nO1xuICAgICAgICBjdWVEaXYuc3R5bGUudG9wID0gJ2F1dG8nO1xuICAgICAgICBjdWVEaXYuc3R5bGUuYm90dG9tID0gJzJweCc7XG4gICAgICB9XG4gICAgICBpZiAob3ZlcnJpZGVzLmZvbnRGYW1pbHkgJiYgb3ZlcnJpZGVzLmZvbnRGYW1pbHkgIT09ICdkZWZhdWx0Jykge1xuICAgICAgICBpZiAob3ZlcnJpZGVzLmZvbnRGYW1pbHkgPT09ICdzbWFsbC1jYXBzJykge1xuICAgICAgICAgIGN1ZURpdi5maXJzdENoaWxkLnN0eWxlLmZvbnRWYXJpYW50ID0gJ3NtYWxsLWNhcHMnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN1ZURpdi5maXJzdENoaWxkLnN0eWxlLmZvbnRGYW1pbHkgPSBmb250TWFwW292ZXJyaWRlcy5mb250RmFtaWx5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICByZXR1cm4gVGV4dFRyYWNrRGlzcGxheTtcbn0oQ29tcG9uZW50KTtcblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdUZXh0VHJhY2tEaXNwbGF5JywgVGV4dFRyYWNrRGlzcGxheSk7XG5cbi8qKlxuICogQGZpbGUgbG9hZGluZy1zcGlubmVyLmpzXG4gKi9cbi8qKlxuICogQSBsb2FkaW5nIHNwaW5uZXIgZm9yIHVzZSBkdXJpbmcgd2FpdGluZy9sb2FkaW5nIGV2ZW50cy5cbiAqXG4gKiBAZXh0ZW5kcyBDb21wb25lbnRcbiAqL1xuXG52YXIgTG9hZGluZ1NwaW5uZXIgPSBmdW5jdGlvbiAoX0NvbXBvbmVudCkge1xuICBpbmhlcml0cyhMb2FkaW5nU3Bpbm5lciwgX0NvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gTG9hZGluZ1NwaW5uZXIoKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgTG9hZGluZ1NwaW5uZXIpO1xuICAgIHJldHVybiBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9Db21wb25lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIHRoZSBgTG9hZGluZ1NwaW5uZXJgcyBET00gZWxlbWVudC5cbiAgICpcbiAgICogQHJldHVybiB7RWxlbWVudH1cbiAgICogICAgICAgICBUaGUgZG9tIGVsZW1lbnQgdGhhdCBnZXRzIGNyZWF0ZWQuXG4gICAqL1xuICBMb2FkaW5nU3Bpbm5lci5wcm90b3R5cGUuY3JlYXRlRWwgPSBmdW5jdGlvbiBjcmVhdGVFbCQkMSgpIHtcbiAgICB2YXIgaXNBdWRpbyA9IHRoaXMucGxheWVyXy5pc0F1ZGlvKCk7XG4gICAgdmFyIHBsYXllclR5cGUgPSB0aGlzLmxvY2FsaXplKGlzQXVkaW8gPyAnQXVkaW8gUGxheWVyJyA6ICdWaWRlbyBQbGF5ZXInKTtcbiAgICB2YXIgY29udHJvbFRleHQgPSBjcmVhdGVFbCgnc3BhbicsIHtcbiAgICAgIGNsYXNzTmFtZTogJ3Zqcy1jb250cm9sLXRleHQnLFxuICAgICAgaW5uZXJIVE1MOiB0aGlzLmxvY2FsaXplKCd7MX0gaXMgbG9hZGluZy4nLCBbcGxheWVyVHlwZV0pXG4gICAgfSk7XG5cbiAgICB2YXIgZWwgPSBfQ29tcG9uZW50LnByb3RvdHlwZS5jcmVhdGVFbC5jYWxsKHRoaXMsICdkaXYnLCB7XG4gICAgICBjbGFzc05hbWU6ICd2anMtbG9hZGluZy1zcGlubmVyJyxcbiAgICAgIGRpcjogJ2x0cidcbiAgICB9KTtcblxuICAgIGVsLmFwcGVuZENoaWxkKGNvbnRyb2xUZXh0KTtcblxuICAgIHJldHVybiBlbDtcbiAgfTtcblxuICByZXR1cm4gTG9hZGluZ1NwaW5uZXI7XG59KENvbXBvbmVudCk7XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnTG9hZGluZ1NwaW5uZXInLCBMb2FkaW5nU3Bpbm5lcik7XG5cbi8qKlxuICogQGZpbGUgYnV0dG9uLmpzXG4gKi9cbi8qKlxuICogQmFzZSBjbGFzcyBmb3IgYWxsIGJ1dHRvbnMuXG4gKlxuICogQGV4dGVuZHMgQ2xpY2thYmxlQ29tcG9uZW50XG4gKi9cblxudmFyIEJ1dHRvbiA9IGZ1bmN0aW9uIChfQ2xpY2thYmxlQ29tcG9uZW50KSB7XG4gIGluaGVyaXRzKEJ1dHRvbiwgX0NsaWNrYWJsZUNvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gQnV0dG9uKCkge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIEJ1dHRvbik7XG4gICAgcmV0dXJuIHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX0NsaWNrYWJsZUNvbXBvbmVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgdGhlIGBCdXR0b25gcyBET00gZWxlbWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IFt0YWc9XCJidXR0b25cIl1cbiAgICogICAgICAgIFRoZSBlbGVtZW50J3Mgbm9kZSB0eXBlLiBUaGlzIGFyZ3VtZW50IGlzIElHTk9SRUQ6IG5vIG1hdHRlciB3aGF0XG4gICAqICAgICAgICBpcyBwYXNzZWQsIGl0IHdpbGwgYWx3YXlzIGNyZWF0ZSBhIGBidXR0b25gIGVsZW1lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHM9e31dXG4gICAqICAgICAgICBBbiBvYmplY3Qgb2YgcHJvcGVydGllcyB0aGF0IHNob3VsZCBiZSBzZXQgb24gdGhlIGVsZW1lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbYXR0cmlidXRlcz17fV1cbiAgICogICAgICAgIEFuIG9iamVjdCBvZiBhdHRyaWJ1dGVzIHRoYXQgc2hvdWxkIGJlIHNldCBvbiB0aGUgZWxlbWVudC5cbiAgICpcbiAgICogQHJldHVybiB7RWxlbWVudH1cbiAgICogICAgICAgICBUaGUgZWxlbWVudCB0aGF0IGdldHMgY3JlYXRlZC5cbiAgICovXG4gIEJ1dHRvbi5wcm90b3R5cGUuY3JlYXRlRWwgPSBmdW5jdGlvbiBjcmVhdGVFbCh0YWcpIHtcbiAgICB2YXIgcHJvcHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIHZhciBhdHRyaWJ1dGVzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcblxuICAgIHRhZyA9ICdidXR0b24nO1xuXG4gICAgcHJvcHMgPSBhc3NpZ24oe1xuICAgICAgaW5uZXJIVE1MOiAnPHNwYW4gYXJpYS1oaWRkZW49XCJ0cnVlXCIgY2xhc3M9XCJ2anMtaWNvbi1wbGFjZWhvbGRlclwiPjwvc3Bhbj4nLFxuICAgICAgY2xhc3NOYW1lOiB0aGlzLmJ1aWxkQ1NTQ2xhc3MoKVxuICAgIH0sIHByb3BzKTtcblxuICAgIC8vIEFkZCBhdHRyaWJ1dGVzIGZvciBidXR0b24gZWxlbWVudFxuICAgIGF0dHJpYnV0ZXMgPSBhc3NpZ24oe1xuXG4gICAgICAvLyBOZWNlc3Nhcnkgc2luY2UgdGhlIGRlZmF1bHQgYnV0dG9uIHR5cGUgaXMgXCJzdWJtaXRcIlxuICAgICAgdHlwZTogJ2J1dHRvbidcbiAgICB9LCBhdHRyaWJ1dGVzKTtcblxuICAgIHZhciBlbCA9IENvbXBvbmVudC5wcm90b3R5cGUuY3JlYXRlRWwuY2FsbCh0aGlzLCB0YWcsIHByb3BzLCBhdHRyaWJ1dGVzKTtcblxuICAgIHRoaXMuY3JlYXRlQ29udHJvbFRleHRFbChlbCk7XG5cbiAgICByZXR1cm4gZWw7XG4gIH07XG5cbiAgLyoqXG4gICAqIEFkZCBhIGNoaWxkIGBDb21wb25lbnRgIGluc2lkZSBvZiB0aGlzIGBCdXR0b25gLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ3xDb21wb25lbnR9IGNoaWxkXG4gICAqICAgICAgICBUaGUgbmFtZSBvciBpbnN0YW5jZSBvZiBhIGNoaWxkIHRvIGFkZC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XVxuICAgKiAgICAgICAgVGhlIGtleS92YWx1ZSBzdG9yZSBvZiBvcHRpb25zIHRoYXQgd2lsbCBnZXQgcGFzc2VkIHRvIGNoaWxkcmVuIG9mXG4gICAqICAgICAgICB0aGUgY2hpbGQuXG4gICAqXG4gICAqIEByZXR1cm4ge0NvbXBvbmVudH1cbiAgICogICAgICAgICBUaGUgYENvbXBvbmVudGAgdGhhdCBnZXRzIGFkZGVkIGFzIGEgY2hpbGQuIFdoZW4gdXNpbmcgYSBzdHJpbmcgdGhlXG4gICAqICAgICAgICAgYENvbXBvbmVudGAgd2lsbCBnZXQgY3JlYXRlZCBieSB0aGlzIHByb2Nlc3MuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gNVxuICAgKi9cblxuXG4gIEJ1dHRvbi5wcm90b3R5cGUuYWRkQ2hpbGQgPSBmdW5jdGlvbiBhZGRDaGlsZChjaGlsZCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICAgIHZhciBjbGFzc05hbWUgPSB0aGlzLmNvbnN0cnVjdG9yLm5hbWU7XG5cbiAgICBsb2cud2FybignQWRkaW5nIGFuIGFjdGlvbmFibGUgKHVzZXIgY29udHJvbGxhYmxlKSBjaGlsZCB0byBhIEJ1dHRvbiAoJyArIGNsYXNzTmFtZSArICcpIGlzIG5vdCBzdXBwb3J0ZWQ7IHVzZSBhIENsaWNrYWJsZUNvbXBvbmVudCBpbnN0ZWFkLicpO1xuXG4gICAgLy8gQXZvaWQgdGhlIGVycm9yIG1lc3NhZ2UgZ2VuZXJhdGVkIGJ5IENsaWNrYWJsZUNvbXBvbmVudCdzIGFkZENoaWxkIG1ldGhvZFxuICAgIHJldHVybiBDb21wb25lbnQucHJvdG90eXBlLmFkZENoaWxkLmNhbGwodGhpcywgY2hpbGQsIG9wdGlvbnMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBFbmFibGUgdGhlIGBCdXR0b25gIGVsZW1lbnQgc28gdGhhdCBpdCBjYW4gYmUgYWN0aXZhdGVkIG9yIGNsaWNrZWQuIFVzZSB0aGlzIHdpdGhcbiAgICoge0BsaW5rIEJ1dHRvbiNkaXNhYmxlfS5cbiAgICovXG5cblxuICBCdXR0b24ucHJvdG90eXBlLmVuYWJsZSA9IGZ1bmN0aW9uIGVuYWJsZSgpIHtcbiAgICBfQ2xpY2thYmxlQ29tcG9uZW50LnByb3RvdHlwZS5lbmFibGUuY2FsbCh0aGlzKTtcbiAgICB0aGlzLmVsXy5yZW1vdmVBdHRyaWJ1dGUoJ2Rpc2FibGVkJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIERpc2FibGUgdGhlIGBCdXR0b25gIGVsZW1lbnQgc28gdGhhdCBpdCBjYW5ub3QgYmUgYWN0aXZhdGVkIG9yIGNsaWNrZWQuIFVzZSB0aGlzIHdpdGhcbiAgICoge0BsaW5rIEJ1dHRvbiNlbmFibGV9LlxuICAgKi9cblxuXG4gIEJ1dHRvbi5wcm90b3R5cGUuZGlzYWJsZSA9IGZ1bmN0aW9uIGRpc2FibGUoKSB7XG4gICAgX0NsaWNrYWJsZUNvbXBvbmVudC5wcm90b3R5cGUuZGlzYWJsZS5jYWxsKHRoaXMpO1xuICAgIHRoaXMuZWxfLnNldEF0dHJpYnV0ZSgnZGlzYWJsZWQnLCAnZGlzYWJsZWQnKTtcbiAgfTtcblxuICAvKipcbiAgICogVGhpcyBnZXRzIGNhbGxlZCB3aGVuIGEgYEJ1dHRvbmAgaGFzIGZvY3VzIGFuZCBga2V5ZG93bmAgaXMgdHJpZ2dlcmVkIHZpYSBhIGtleVxuICAgKiBwcmVzcy5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gZXZlbnRcbiAgICogICAgICAgIFRoZSBldmVudCB0aGF0IGNhdXNlZCB0aGlzIGZ1bmN0aW9uIHRvIGdldCBjYWxsZWQuXG4gICAqXG4gICAqIEBsaXN0ZW5zIGtleWRvd25cbiAgICovXG5cblxuICBCdXR0b24ucHJvdG90eXBlLmhhbmRsZUtleVByZXNzID0gZnVuY3Rpb24gaGFuZGxlS2V5UHJlc3MoZXZlbnQpIHtcblxuICAgIC8vIElnbm9yZSBTcGFjZSAoMzIpIG9yIEVudGVyICgxMykga2V5IG9wZXJhdGlvbiwgd2hpY2ggaXMgaGFuZGxlZCBieSB0aGUgYnJvd3NlciBmb3IgYSBidXR0b24uXG4gICAgaWYgKGV2ZW50LndoaWNoID09PSAzMiB8fCBldmVudC53aGljaCA9PT0gMTMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBQYXNzIGtleXByZXNzIGhhbmRsaW5nIHVwIGZvciB1bnN1cHBvcnRlZCBrZXlzXG4gICAgX0NsaWNrYWJsZUNvbXBvbmVudC5wcm90b3R5cGUuaGFuZGxlS2V5UHJlc3MuY2FsbCh0aGlzLCBldmVudCk7XG4gIH07XG5cbiAgcmV0dXJuIEJ1dHRvbjtcbn0oQ2xpY2thYmxlQ29tcG9uZW50KTtcblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdCdXR0b24nLCBCdXR0b24pO1xuXG4vKipcbiAqIEBmaWxlIGJpZy1wbGF5LWJ1dHRvbi5qc1xuICovXG4vKipcbiAqIFRoZSBpbml0aWFsIHBsYXkgYnV0dG9uIHRoYXQgc2hvd3MgYmVmb3JlIHRoZSB2aWRlbyBoYXMgcGxheWVkLiBUaGUgaGlkaW5nIG9mIHRoZVxuICogYEJpZ1BsYXlCdXR0b25gIGdldCBkb25lIHZpYSBDU1MgYW5kIGBQbGF5ZXJgIHN0YXRlcy5cbiAqXG4gKiBAZXh0ZW5kcyBCdXR0b25cbiAqL1xuXG52YXIgQmlnUGxheUJ1dHRvbiA9IGZ1bmN0aW9uIChfQnV0dG9uKSB7XG4gIGluaGVyaXRzKEJpZ1BsYXlCdXR0b24sIF9CdXR0b24pO1xuXG4gIGZ1bmN0aW9uIEJpZ1BsYXlCdXR0b24ocGxheWVyLCBvcHRpb25zKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgQmlnUGxheUJ1dHRvbik7XG5cbiAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9CdXR0b24uY2FsbCh0aGlzLCBwbGF5ZXIsIG9wdGlvbnMpKTtcblxuICAgIF90aGlzLm1vdXNldXNlZF8gPSBmYWxzZTtcblxuICAgIF90aGlzLm9uKCdtb3VzZWRvd24nLCBfdGhpcy5oYW5kbGVNb3VzZURvd24pO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBCdWlsZHMgdGhlIGRlZmF1bHQgRE9NIGBjbGFzc05hbWVgLlxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqICAgICAgICAgVGhlIERPTSBgY2xhc3NOYW1lYCBmb3IgdGhpcyBvYmplY3QuIEFsd2F5cyByZXR1cm5zICd2anMtYmlnLXBsYXktYnV0dG9uJy5cbiAgICovXG5cblxuICBCaWdQbGF5QnV0dG9uLnByb3RvdHlwZS5idWlsZENTU0NsYXNzID0gZnVuY3Rpb24gYnVpbGRDU1NDbGFzcygpIHtcbiAgICByZXR1cm4gJ3Zqcy1iaWctcGxheS1idXR0b24nO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUaGlzIGdldHMgY2FsbGVkIHdoZW4gYSBgQmlnUGxheUJ1dHRvbmAgXCJjbGlja2VkXCIuIFNlZSB7QGxpbmsgQ2xpY2thYmxlQ29tcG9uZW50fVxuICAgKiBmb3IgbW9yZSBkZXRhaWxlZCBpbmZvcm1hdGlvbiBvbiB3aGF0IGEgY2xpY2sgY2FuIGJlLlxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBldmVudFxuICAgKiAgICAgICAgVGhlIGBrZXlkb3duYCwgYHRhcGAsIG9yIGBjbGlja2AgZXZlbnQgdGhhdCBjYXVzZWQgdGhpcyBmdW5jdGlvbiB0byBiZVxuICAgKiAgICAgICAgY2FsbGVkLlxuICAgKlxuICAgKiBAbGlzdGVucyB0YXBcbiAgICogQGxpc3RlbnMgY2xpY2tcbiAgICovXG5cblxuICBCaWdQbGF5QnV0dG9uLnByb3RvdHlwZS5oYW5kbGVDbGljayA9IGZ1bmN0aW9uIGhhbmRsZUNsaWNrKGV2ZW50KSB7XG4gICAgdmFyIHBsYXlQcm9taXNlID0gdGhpcy5wbGF5ZXJfLnBsYXkoKTtcblxuICAgIC8vIGV4aXQgZWFybHkgaWYgY2xpY2tlZCB2aWEgdGhlIG1vdXNlXG4gICAgaWYgKHRoaXMubW91c2V1c2VkXyAmJiBldmVudC5jbGllbnRYICYmIGV2ZW50LmNsaWVudFkpIHtcbiAgICAgIHNpbGVuY2VQcm9taXNlKHBsYXlQcm9taXNlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgY2IgPSB0aGlzLnBsYXllcl8uZ2V0Q2hpbGQoJ2NvbnRyb2xCYXInKTtcbiAgICB2YXIgcGxheVRvZ2dsZSA9IGNiICYmIGNiLmdldENoaWxkKCdwbGF5VG9nZ2xlJyk7XG5cbiAgICBpZiAoIXBsYXlUb2dnbGUpIHtcbiAgICAgIHRoaXMucGxheWVyXy5mb2N1cygpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBwbGF5Rm9jdXMgPSBmdW5jdGlvbiBwbGF5Rm9jdXMoKSB7XG4gICAgICByZXR1cm4gcGxheVRvZ2dsZS5mb2N1cygpO1xuICAgIH07XG5cbiAgICBpZiAoaXNQcm9taXNlKHBsYXlQcm9taXNlKSkge1xuICAgICAgcGxheVByb21pc2UudGhlbihwbGF5Rm9jdXMsIGZ1bmN0aW9uICgpIHt9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZXRUaW1lb3V0KHBsYXlGb2N1cywgMSk7XG4gICAgfVxuICB9O1xuXG4gIEJpZ1BsYXlCdXR0b24ucHJvdG90eXBlLmhhbmRsZUtleVByZXNzID0gZnVuY3Rpb24gaGFuZGxlS2V5UHJlc3MoZXZlbnQpIHtcbiAgICB0aGlzLm1vdXNldXNlZF8gPSBmYWxzZTtcblxuICAgIF9CdXR0b24ucHJvdG90eXBlLmhhbmRsZUtleVByZXNzLmNhbGwodGhpcywgZXZlbnQpO1xuICB9O1xuXG4gIEJpZ1BsYXlCdXR0b24ucHJvdG90eXBlLmhhbmRsZU1vdXNlRG93biA9IGZ1bmN0aW9uIGhhbmRsZU1vdXNlRG93bihldmVudCkge1xuICAgIHRoaXMubW91c2V1c2VkXyA9IHRydWU7XG4gIH07XG5cbiAgcmV0dXJuIEJpZ1BsYXlCdXR0b247XG59KEJ1dHRvbik7XG5cbi8qKlxuICogVGhlIHRleHQgdGhhdCBzaG91bGQgZGlzcGxheSBvdmVyIHRoZSBgQmlnUGxheUJ1dHRvbmBzIGNvbnRyb2xzLiBBZGRlZCB0byBmb3IgbG9jYWxpemF0aW9uLlxuICpcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKiBAcHJpdmF0ZVxuICovXG5cblxuQmlnUGxheUJ1dHRvbi5wcm90b3R5cGUuY29udHJvbFRleHRfID0gJ1BsYXkgVmlkZW8nO1xuXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ0JpZ1BsYXlCdXR0b24nLCBCaWdQbGF5QnV0dG9uKTtcblxuLyoqXG4gKiBAZmlsZSBjbG9zZS1idXR0b24uanNcbiAqL1xuLyoqXG4gKiBUaGUgYENsb3NlQnV0dG9uYCBpcyBhIGB7QGxpbmsgQnV0dG9ufWAgdGhhdCBmaXJlcyBhIGBjbG9zZWAgZXZlbnQgd2hlblxuICogaXQgZ2V0cyBjbGlja2VkLlxuICpcbiAqIEBleHRlbmRzIEJ1dHRvblxuICovXG5cbnZhciBDbG9zZUJ1dHRvbiA9IGZ1bmN0aW9uIChfQnV0dG9uKSB7XG4gIGluaGVyaXRzKENsb3NlQnV0dG9uLCBfQnV0dG9uKTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiB0aGUgdGhpcyBjbGFzcy5cbiAgICpcbiAgICogQHBhcmFtICB7UGxheWVyfSBwbGF5ZXJcbiAgICogICAgICAgICBUaGUgYFBsYXllcmAgdGhhdCB0aGlzIGNsYXNzIHNob3VsZCBiZSBhdHRhY2hlZCB0by5cbiAgICpcbiAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICAgICAgICBUaGUga2V5L3ZhbHVlIHN0b3JlIG9mIHBsYXllciBvcHRpb25zLlxuICAgKi9cbiAgZnVuY3Rpb24gQ2xvc2VCdXR0b24ocGxheWVyLCBvcHRpb25zKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgQ2xvc2VCdXR0b24pO1xuXG4gICAgdmFyIF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfQnV0dG9uLmNhbGwodGhpcywgcGxheWVyLCBvcHRpb25zKSk7XG5cbiAgICBfdGhpcy5jb250cm9sVGV4dChvcHRpb25zICYmIG9wdGlvbnMuY29udHJvbFRleHQgfHwgX3RoaXMubG9jYWxpemUoJ0Nsb3NlJykpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBCdWlsZHMgdGhlIGRlZmF1bHQgRE9NIGBjbGFzc05hbWVgLlxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqICAgICAgICAgVGhlIERPTSBgY2xhc3NOYW1lYCBmb3IgdGhpcyBvYmplY3QuXG4gICAqL1xuXG5cbiAgQ2xvc2VCdXR0b24ucHJvdG90eXBlLmJ1aWxkQ1NTQ2xhc3MgPSBmdW5jdGlvbiBidWlsZENTU0NsYXNzKCkge1xuICAgIHJldHVybiAndmpzLWNsb3NlLWJ1dHRvbiAnICsgX0J1dHRvbi5wcm90b3R5cGUuYnVpbGRDU1NDbGFzcy5jYWxsKHRoaXMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUaGlzIGdldHMgY2FsbGVkIHdoZW4gYSBgQ2xvc2VCdXR0b25gIGdldHMgY2xpY2tlZC4gU2VlXG4gICAqIHtAbGluayBDbGlja2FibGVDb21wb25lbnQjaGFuZGxlQ2xpY2t9IGZvciBtb3JlIGluZm9ybWF0aW9uIG9uIHdoZW4gdGhpcyB3aWxsIGJlXG4gICAqIHRyaWdnZXJlZFxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBldmVudFxuICAgKiAgICAgICAgVGhlIGBrZXlkb3duYCwgYHRhcGAsIG9yIGBjbGlja2AgZXZlbnQgdGhhdCBjYXVzZWQgdGhpcyBmdW5jdGlvbiB0byBiZVxuICAgKiAgICAgICAgY2FsbGVkLlxuICAgKlxuICAgKiBAbGlzdGVucyB0YXBcbiAgICogQGxpc3RlbnMgY2xpY2tcbiAgICogQGZpcmVzIENsb3NlQnV0dG9uI2Nsb3NlXG4gICAqL1xuXG5cbiAgQ2xvc2VCdXR0b24ucHJvdG90eXBlLmhhbmRsZUNsaWNrID0gZnVuY3Rpb24gaGFuZGxlQ2xpY2soZXZlbnQpIHtcblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCB3aGVuIHRoZSBhIGBDbG9zZUJ1dHRvbmAgaXMgY2xpY2tlZC5cbiAgICAgKlxuICAgICAqIEBldmVudCBDbG9zZUJ1dHRvbiNjbG9zZVxuICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2J1YmJsZXM9ZmFsc2VdXG4gICAgICogICAgICAgICAgIHNldCB0byBmYWxzZSBzbyB0aGF0IHRoZSBjbG9zZSBldmVudCBkb2VzIG5vdFxuICAgICAqICAgICAgICAgICBidWJibGUgdXAgdG8gcGFyZW50cyBpZiB0aGVyZSBpcyBubyBsaXN0ZW5lclxuICAgICAqL1xuICAgIHRoaXMudHJpZ2dlcih7IHR5cGU6ICdjbG9zZScsIGJ1YmJsZXM6IGZhbHNlIH0pO1xuICB9O1xuXG4gIHJldHVybiBDbG9zZUJ1dHRvbjtcbn0oQnV0dG9uKTtcblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdDbG9zZUJ1dHRvbicsIENsb3NlQnV0dG9uKTtcblxuLyoqXG4gKiBAZmlsZSBwbGF5LXRvZ2dsZS5qc1xuICovXG4vKipcbiAqIEJ1dHRvbiB0byB0b2dnbGUgYmV0d2VlbiBwbGF5IGFuZCBwYXVzZS5cbiAqXG4gKiBAZXh0ZW5kcyBCdXR0b25cbiAqL1xuXG52YXIgUGxheVRvZ2dsZSA9IGZ1bmN0aW9uIChfQnV0dG9uKSB7XG4gIGluaGVyaXRzKFBsYXlUb2dnbGUsIF9CdXR0b24pO1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7UGxheWVyfSBwbGF5ZXJcbiAgICogICAgICAgIFRoZSBgUGxheWVyYCB0aGF0IHRoaXMgY2xhc3Mgc2hvdWxkIGJlIGF0dGFjaGVkIHRvLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgICAgICBUaGUga2V5L3ZhbHVlIHN0b3JlIG9mIHBsYXllciBvcHRpb25zLlxuICAgKi9cbiAgZnVuY3Rpb24gUGxheVRvZ2dsZShwbGF5ZXIsIG9wdGlvbnMpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBQbGF5VG9nZ2xlKTtcblxuICAgIHZhciBfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX0J1dHRvbi5jYWxsKHRoaXMsIHBsYXllciwgb3B0aW9ucykpO1xuXG4gICAgX3RoaXMub24ocGxheWVyLCAncGxheScsIF90aGlzLmhhbmRsZVBsYXkpO1xuICAgIF90aGlzLm9uKHBsYXllciwgJ3BhdXNlJywgX3RoaXMuaGFuZGxlUGF1c2UpO1xuICAgIF90aGlzLm9uKHBsYXllciwgJ2VuZGVkJywgX3RoaXMuaGFuZGxlRW5kZWQpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBCdWlsZHMgdGhlIGRlZmF1bHQgRE9NIGBjbGFzc05hbWVgLlxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqICAgICAgICAgVGhlIERPTSBgY2xhc3NOYW1lYCBmb3IgdGhpcyBvYmplY3QuXG4gICAqL1xuXG5cbiAgUGxheVRvZ2dsZS5wcm90b3R5cGUuYnVpbGRDU1NDbGFzcyA9IGZ1bmN0aW9uIGJ1aWxkQ1NTQ2xhc3MoKSB7XG4gICAgcmV0dXJuICd2anMtcGxheS1jb250cm9sICcgKyBfQnV0dG9uLnByb3RvdHlwZS5idWlsZENTU0NsYXNzLmNhbGwodGhpcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoaXMgZ2V0cyBjYWxsZWQgd2hlbiBhbiBgUGxheVRvZ2dsZWAgaXMgXCJjbGlja2VkXCIuIFNlZVxuICAgKiB7QGxpbmsgQ2xpY2thYmxlQ29tcG9uZW50fSBmb3IgbW9yZSBkZXRhaWxlZCBpbmZvcm1hdGlvbiBvbiB3aGF0IGEgY2xpY2sgY2FuIGJlLlxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBbZXZlbnRdXG4gICAqICAgICAgICBUaGUgYGtleWRvd25gLCBgdGFwYCwgb3IgYGNsaWNrYCBldmVudCB0aGF0IGNhdXNlZCB0aGlzIGZ1bmN0aW9uIHRvIGJlXG4gICAqICAgICAgICBjYWxsZWQuXG4gICAqXG4gICAqIEBsaXN0ZW5zIHRhcFxuICAgKiBAbGlzdGVucyBjbGlja1xuICAgKi9cblxuXG4gIFBsYXlUb2dnbGUucHJvdG90eXBlLmhhbmRsZUNsaWNrID0gZnVuY3Rpb24gaGFuZGxlQ2xpY2soZXZlbnQpIHtcbiAgICBpZiAodGhpcy5wbGF5ZXJfLnBhdXNlZCgpKSB7XG4gICAgICB0aGlzLnBsYXllcl8ucGxheSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnBsYXllcl8ucGF1c2UoKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoaXMgZ2V0cyBjYWxsZWQgb25jZSBhZnRlciB0aGUgdmlkZW8gaGFzIGVuZGVkIGFuZCB0aGUgdXNlciBzZWVrcyBzbyB0aGF0XG4gICAqIHdlIGNhbiBjaGFuZ2UgdGhlIHJlcGxheSBidXR0b24gYmFjayB0byBhIHBsYXkgYnV0dG9uLlxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBbZXZlbnRdXG4gICAqICAgICAgICBUaGUgZXZlbnQgdGhhdCBjYXVzZWQgdGhpcyBmdW5jdGlvbiB0byBydW4uXG4gICAqXG4gICAqIEBsaXN0ZW5zIFBsYXllciNzZWVrZWRcbiAgICovXG5cblxuICBQbGF5VG9nZ2xlLnByb3RvdHlwZS5oYW5kbGVTZWVrZWQgPSBmdW5jdGlvbiBoYW5kbGVTZWVrZWQoZXZlbnQpIHtcbiAgICB0aGlzLnJlbW92ZUNsYXNzKCd2anMtZW5kZWQnKTtcblxuICAgIGlmICh0aGlzLnBsYXllcl8ucGF1c2VkKCkpIHtcbiAgICAgIHRoaXMuaGFuZGxlUGF1c2UoZXZlbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmhhbmRsZVBsYXkoZXZlbnQpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQWRkIHRoZSB2anMtcGxheWluZyBjbGFzcyB0byB0aGUgZWxlbWVudCBzbyBpdCBjYW4gY2hhbmdlIGFwcGVhcmFuY2UuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IFtldmVudF1cbiAgICogICAgICAgIFRoZSBldmVudCB0aGF0IGNhdXNlZCB0aGlzIGZ1bmN0aW9uIHRvIHJ1bi5cbiAgICpcbiAgICogQGxpc3RlbnMgUGxheWVyI3BsYXlcbiAgICovXG5cblxuICBQbGF5VG9nZ2xlLnByb3RvdHlwZS5oYW5kbGVQbGF5ID0gZnVuY3Rpb24gaGFuZGxlUGxheShldmVudCkge1xuICAgIHRoaXMucmVtb3ZlQ2xhc3MoJ3Zqcy1lbmRlZCcpO1xuICAgIHRoaXMucmVtb3ZlQ2xhc3MoJ3Zqcy1wYXVzZWQnKTtcbiAgICB0aGlzLmFkZENsYXNzKCd2anMtcGxheWluZycpO1xuICAgIC8vIGNoYW5nZSB0aGUgYnV0dG9uIHRleHQgdG8gXCJQYXVzZVwiXG4gICAgdGhpcy5jb250cm9sVGV4dCgnUGF1c2UnKTtcbiAgfTtcblxuICAvKipcbiAgICogQWRkIHRoZSB2anMtcGF1c2VkIGNsYXNzIHRvIHRoZSBlbGVtZW50IHNvIGl0IGNhbiBjaGFuZ2UgYXBwZWFyYW5jZS5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gW2V2ZW50XVxuICAgKiAgICAgICAgVGhlIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgZnVuY3Rpb24gdG8gcnVuLlxuICAgKlxuICAgKiBAbGlzdGVucyBQbGF5ZXIjcGF1c2VcbiAgICovXG5cblxuICBQbGF5VG9nZ2xlLnByb3RvdHlwZS5oYW5kbGVQYXVzZSA9IGZ1bmN0aW9uIGhhbmRsZVBhdXNlKGV2ZW50KSB7XG4gICAgdGhpcy5yZW1vdmVDbGFzcygndmpzLXBsYXlpbmcnKTtcbiAgICB0aGlzLmFkZENsYXNzKCd2anMtcGF1c2VkJyk7XG4gICAgLy8gY2hhbmdlIHRoZSBidXR0b24gdGV4dCB0byBcIlBsYXlcIlxuICAgIHRoaXMuY29udHJvbFRleHQoJ1BsYXknKTtcbiAgfTtcblxuICAvKipcbiAgICogQWRkIHRoZSB2anMtZW5kZWQgY2xhc3MgdG8gdGhlIGVsZW1lbnQgc28gaXQgY2FuIGNoYW5nZSBhcHBlYXJhbmNlXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IFtldmVudF1cbiAgICogICAgICAgIFRoZSBldmVudCB0aGF0IGNhdXNlZCB0aGlzIGZ1bmN0aW9uIHRvIHJ1bi5cbiAgICpcbiAgICogQGxpc3RlbnMgUGxheWVyI2VuZGVkXG4gICAqL1xuXG5cbiAgUGxheVRvZ2dsZS5wcm90b3R5cGUuaGFuZGxlRW5kZWQgPSBmdW5jdGlvbiBoYW5kbGVFbmRlZChldmVudCkge1xuICAgIHRoaXMucmVtb3ZlQ2xhc3MoJ3Zqcy1wbGF5aW5nJyk7XG4gICAgdGhpcy5hZGRDbGFzcygndmpzLWVuZGVkJyk7XG4gICAgLy8gY2hhbmdlIHRoZSBidXR0b24gdGV4dCB0byBcIlJlcGxheVwiXG4gICAgdGhpcy5jb250cm9sVGV4dCgnUmVwbGF5Jyk7XG5cbiAgICAvLyBvbiB0aGUgbmV4dCBzZWVrIHJlbW92ZSB0aGUgcmVwbGF5IGJ1dHRvblxuICAgIHRoaXMub25lKHRoaXMucGxheWVyXywgJ3NlZWtlZCcsIHRoaXMuaGFuZGxlU2Vla2VkKTtcbiAgfTtcblxuICByZXR1cm4gUGxheVRvZ2dsZTtcbn0oQnV0dG9uKTtcblxuLyoqXG4gKiBUaGUgdGV4dCB0aGF0IHNob3VsZCBkaXNwbGF5IG92ZXIgdGhlIGBQbGF5VG9nZ2xlYHMgY29udHJvbHMuIEFkZGVkIGZvciBsb2NhbGl6YXRpb24uXG4gKlxuICogQHR5cGUge3N0cmluZ31cbiAqIEBwcml2YXRlXG4gKi9cblxuXG5QbGF5VG9nZ2xlLnByb3RvdHlwZS5jb250cm9sVGV4dF8gPSAnUGxheSc7XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnUGxheVRvZ2dsZScsIFBsYXlUb2dnbGUpO1xuXG4vKipcbiAqIEBmaWxlIGZvcm1hdC10aW1lLmpzXG4gKiBAbW9kdWxlIGZvcm1hdC10aW1lXG4gKi9cblxuLyoqXG4qIEZvcm1hdCBzZWNvbmRzIGFzIGEgdGltZSBzdHJpbmcsIEg6TU06U1Mgb3IgTTpTUy4gU3VwcGx5aW5nIGEgZ3VpZGUgKGluIHNlY29uZHMpXG4qIHdpbGwgZm9yY2UgYSBudW1iZXIgb2YgbGVhZGluZyB6ZXJvcyB0byBjb3ZlciB0aGUgbGVuZ3RoIG9mIHRoZSBndWlkZS5cbipcbiogQHBhcmFtIHtudW1iZXJ9IHNlY29uZHNcbiogICAgICAgIE51bWJlciBvZiBzZWNvbmRzIHRvIGJlIHR1cm5lZCBpbnRvIGEgc3RyaW5nXG4qXG4qIEBwYXJhbSB7bnVtYmVyfSBndWlkZVxuKiAgICAgICAgTnVtYmVyIChpbiBzZWNvbmRzKSB0byBtb2RlbCB0aGUgc3RyaW5nIGFmdGVyXG4qXG4qIEByZXR1cm4ge3N0cmluZ31cbiogICAgICAgICBUaW1lIGZvcm1hdHRlZCBhcyBIOk1NOlNTIG9yIE06U1NcbiovXG52YXIgZGVmYXVsdEltcGxlbWVudGF0aW9uID0gZnVuY3Rpb24gZGVmYXVsdEltcGxlbWVudGF0aW9uKHNlY29uZHMsIGd1aWRlKSB7XG4gIHNlY29uZHMgPSBzZWNvbmRzIDwgMCA/IDAgOiBzZWNvbmRzO1xuICB2YXIgcyA9IE1hdGguZmxvb3Ioc2Vjb25kcyAlIDYwKTtcbiAgdmFyIG0gPSBNYXRoLmZsb29yKHNlY29uZHMgLyA2MCAlIDYwKTtcbiAgdmFyIGggPSBNYXRoLmZsb29yKHNlY29uZHMgLyAzNjAwKTtcbiAgdmFyIGdtID0gTWF0aC5mbG9vcihndWlkZSAvIDYwICUgNjApO1xuICB2YXIgZ2ggPSBNYXRoLmZsb29yKGd1aWRlIC8gMzYwMCk7XG5cbiAgLy8gaGFuZGxlIGludmFsaWQgdGltZXNcbiAgaWYgKGlzTmFOKHNlY29uZHMpIHx8IHNlY29uZHMgPT09IEluZmluaXR5KSB7XG4gICAgLy8gJy0nIGlzIGZhbHNlIGZvciBhbGwgcmVsYXRpb25hbCBvcGVyYXRvcnMgKGUuZy4gPCwgPj0pIHNvIHRoaXMgc2V0dGluZ1xuICAgIC8vIHdpbGwgYWRkIHRoZSBtaW5pbXVtIG51bWJlciBvZiBmaWVsZHMgc3BlY2lmaWVkIGJ5IHRoZSBndWlkZVxuICAgIGggPSBtID0gcyA9ICctJztcbiAgfVxuXG4gIC8vIENoZWNrIGlmIHdlIG5lZWQgdG8gc2hvdyBob3Vyc1xuICBoID0gaCA+IDAgfHwgZ2ggPiAwID8gaCArICc6JyA6ICcnO1xuXG4gIC8vIElmIGhvdXJzIGFyZSBzaG93aW5nLCB3ZSBtYXkgbmVlZCB0byBhZGQgYSBsZWFkaW5nIHplcm8uXG4gIC8vIEFsd2F5cyBzaG93IGF0IGxlYXN0IG9uZSBkaWdpdCBvZiBtaW51dGVzLlxuICBtID0gKChoIHx8IGdtID49IDEwKSAmJiBtIDwgMTAgPyAnMCcgKyBtIDogbSkgKyAnOic7XG5cbiAgLy8gQ2hlY2sgaWYgbGVhZGluZyB6ZXJvIGlzIG5lZWQgZm9yIHNlY29uZHNcbiAgcyA9IHMgPCAxMCA/ICcwJyArIHMgOiBzO1xuXG4gIHJldHVybiBoICsgbSArIHM7XG59O1xuXG52YXIgaW1wbGVtZW50YXRpb24gPSBkZWZhdWx0SW1wbGVtZW50YXRpb247XG5cbi8qKlxuICogUmVwbGFjZXMgdGhlIGRlZmF1bHQgZm9ybWF0VGltZSBpbXBsZW1lbnRhdGlvbiB3aXRoIGEgY3VzdG9tIGltcGxlbWVudGF0aW9uLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbUltcGxlbWVudGF0aW9uXG4gKiAgICAgICAgQSBmdW5jdGlvbiB3aGljaCB3aWxsIGJlIHVzZWQgaW4gcGxhY2Ugb2YgdGhlIGRlZmF1bHQgZm9ybWF0VGltZSBpbXBsZW1lbnRhdGlvbi5cbiAqICAgICAgICBXaWxsIHJlY2VpdmUgdGhlIGN1cnJlbnQgdGltZSBpbiBzZWNvbmRzIGFuZCB0aGUgZ3VpZGUgKGluIHNlY29uZHMpIGFzIGFyZ3VtZW50cy5cbiAqL1xuZnVuY3Rpb24gc2V0Rm9ybWF0VGltZShjdXN0b21JbXBsZW1lbnRhdGlvbikge1xuICBpbXBsZW1lbnRhdGlvbiA9IGN1c3RvbUltcGxlbWVudGF0aW9uO1xufVxuXG4vKipcbiAqIFJlc2V0cyBmb3JtYXRUaW1lIHRvIHRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uLlxuICovXG5mdW5jdGlvbiByZXNldEZvcm1hdFRpbWUoKSB7XG4gIGltcGxlbWVudGF0aW9uID0gZGVmYXVsdEltcGxlbWVudGF0aW9uO1xufVxuXG52YXIgZm9ybWF0VGltZSA9IGZ1bmN0aW9uIChzZWNvbmRzKSB7XG4gIHZhciBndWlkZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogc2Vjb25kcztcblxuICByZXR1cm4gaW1wbGVtZW50YXRpb24oc2Vjb25kcywgZ3VpZGUpO1xufTtcblxuLyoqXG4gKiBAZmlsZSB0aW1lLWRpc3BsYXkuanNcbiAqL1xuLyoqXG4gKiBEaXNwbGF5cyB0aGUgdGltZSBsZWZ0IGluIHRoZSB2aWRlb1xuICpcbiAqIEBleHRlbmRzIENvbXBvbmVudFxuICovXG5cbnZhciBUaW1lRGlzcGxheSA9IGZ1bmN0aW9uIChfQ29tcG9uZW50KSB7XG4gIGluaGVyaXRzKFRpbWVEaXNwbGF5LCBfQ29tcG9uZW50KTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge1BsYXllcn0gcGxheWVyXG4gICAqICAgICAgICBUaGUgYFBsYXllcmAgdGhhdCB0aGlzIGNsYXNzIHNob3VsZCBiZSBhdHRhY2hlZCB0by5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgICAgICAgVGhlIGtleS92YWx1ZSBzdG9yZSBvZiBwbGF5ZXIgb3B0aW9ucy5cbiAgICovXG4gIGZ1bmN0aW9uIFRpbWVEaXNwbGF5KHBsYXllciwgb3B0aW9ucykge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFRpbWVEaXNwbGF5KTtcblxuICAgIHZhciBfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX0NvbXBvbmVudC5jYWxsKHRoaXMsIHBsYXllciwgb3B0aW9ucykpO1xuXG4gICAgX3RoaXMudGhyb3R0bGVkVXBkYXRlQ29udGVudCA9IHRocm90dGxlKGJpbmQoX3RoaXMsIF90aGlzLnVwZGF0ZUNvbnRlbnQpLCAyNSk7XG4gICAgX3RoaXMub24ocGxheWVyLCAndGltZXVwZGF0ZScsIF90aGlzLnRocm90dGxlZFVwZGF0ZUNvbnRlbnQpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgdGhlIGBDb21wb25lbnRgJ3MgRE9NIGVsZW1lbnRcbiAgICpcbiAgICogQHJldHVybiB7RWxlbWVudH1cbiAgICogICAgICAgICBUaGUgZWxlbWVudCB0aGF0IHdhcyBjcmVhdGVkLlxuICAgKi9cblxuXG4gIFRpbWVEaXNwbGF5LnByb3RvdHlwZS5jcmVhdGVFbCA9IGZ1bmN0aW9uIGNyZWF0ZUVsJCQxKHBsYWluTmFtZSkge1xuICAgIHZhciBjbGFzc05hbWUgPSB0aGlzLmJ1aWxkQ1NTQ2xhc3MoKTtcbiAgICB2YXIgZWwgPSBfQ29tcG9uZW50LnByb3RvdHlwZS5jcmVhdGVFbC5jYWxsKHRoaXMsICdkaXYnLCB7XG4gICAgICBjbGFzc05hbWU6IGNsYXNzTmFtZSArICcgdmpzLXRpbWUtY29udHJvbCB2anMtY29udHJvbCcsXG4gICAgICBpbm5lckhUTUw6ICc8c3BhbiBjbGFzcz1cInZqcy1jb250cm9sLXRleHRcIj4nICsgdGhpcy5sb2NhbGl6ZSh0aGlzLmxhYmVsVGV4dF8pICsgJ1xceEEwPC9zcGFuPidcbiAgICB9KTtcblxuICAgIHRoaXMuY29udGVudEVsXyA9IGNyZWF0ZUVsKCdzcGFuJywge1xuICAgICAgY2xhc3NOYW1lOiBjbGFzc05hbWUgKyAnLWRpc3BsYXknXG4gICAgfSwge1xuICAgICAgLy8gdGVsbCBzY3JlZW4gcmVhZGVycyBub3QgdG8gYXV0b21hdGljYWxseSByZWFkIHRoZSB0aW1lIGFzIGl0IGNoYW5nZXNcbiAgICAgICdhcmlhLWxpdmUnOiAnb2ZmJ1xuICAgIH0pO1xuXG4gICAgdGhpcy51cGRhdGVUZXh0Tm9kZV8oKTtcbiAgICBlbC5hcHBlbmRDaGlsZCh0aGlzLmNvbnRlbnRFbF8pO1xuICAgIHJldHVybiBlbDtcbiAgfTtcblxuICBUaW1lRGlzcGxheS5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XG4gICAgdGhpcy5jb250ZW50RWxfID0gbnVsbDtcbiAgICB0aGlzLnRleHROb2RlXyA9IG51bGw7XG5cbiAgICBfQ29tcG9uZW50LnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIFwicmVtYWluaW5nIHRpbWVcIiB0ZXh0IG5vZGUgd2l0aCBuZXcgY29udGVudCB1c2luZyB0aGVcbiAgICogY29udGVudHMgb2YgdGhlIGBmb3JtYXR0ZWRUaW1lX2AgcHJvcGVydHkuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgVGltZURpc3BsYXkucHJvdG90eXBlLnVwZGF0ZVRleHROb2RlXyA9IGZ1bmN0aW9uIHVwZGF0ZVRleHROb2RlXygpIHtcbiAgICBpZiAoIXRoaXMuY29udGVudEVsXykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHdoaWxlICh0aGlzLmNvbnRlbnRFbF8uZmlyc3RDaGlsZCkge1xuICAgICAgdGhpcy5jb250ZW50RWxfLnJlbW92ZUNoaWxkKHRoaXMuY29udGVudEVsXy5maXJzdENoaWxkKTtcbiAgICB9XG5cbiAgICB0aGlzLnRleHROb2RlXyA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRoaXMuZm9ybWF0dGVkVGltZV8gfHwgdGhpcy5mb3JtYXRUaW1lXygwKSk7XG4gICAgdGhpcy5jb250ZW50RWxfLmFwcGVuZENoaWxkKHRoaXMudGV4dE5vZGVfKTtcbiAgfTtcblxuICAvKipcbiAgICogR2VuZXJhdGVzIGEgZm9ybWF0dGVkIHRpbWUgZm9yIHRoaXMgY29tcG9uZW50IHRvIHVzZSBpbiBkaXNwbGF5LlxuICAgKlxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHRpbWVcbiAgICogICAgICAgICBBIG51bWVyaWMgdGltZSwgaW4gc2Vjb25kcy5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKiAgICAgICAgIEEgZm9ybWF0dGVkIHRpbWVcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBUaW1lRGlzcGxheS5wcm90b3R5cGUuZm9ybWF0VGltZV8gPSBmdW5jdGlvbiBmb3JtYXRUaW1lXyh0aW1lKSB7XG4gICAgcmV0dXJuIGZvcm1hdFRpbWUodGltZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIHRpbWUgZGlzcGxheSB0ZXh0IG5vZGUgaWYgaXQgaGFzIHdoYXQgd2FzIHBhc3NlZCBpbiBjaGFuZ2VkXG4gICAqIHRoZSBmb3JtYXR0ZWQgdGltZS5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IHRpbWVcbiAgICogICAgICAgIFRoZSB0aW1lIHRvIHVwZGF0ZSB0b1xuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIFRpbWVEaXNwbGF5LnByb3RvdHlwZS51cGRhdGVGb3JtYXR0ZWRUaW1lXyA9IGZ1bmN0aW9uIHVwZGF0ZUZvcm1hdHRlZFRpbWVfKHRpbWUpIHtcbiAgICB2YXIgZm9ybWF0dGVkVGltZSA9IHRoaXMuZm9ybWF0VGltZV8odGltZSk7XG5cbiAgICBpZiAoZm9ybWF0dGVkVGltZSA9PT0gdGhpcy5mb3JtYXR0ZWRUaW1lXykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuZm9ybWF0dGVkVGltZV8gPSBmb3JtYXR0ZWRUaW1lO1xuICAgIHRoaXMucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMudXBkYXRlVGV4dE5vZGVfKTtcbiAgfTtcblxuICAvKipcbiAgICogVG8gYmUgZmlsbGVkIG91dCBpbiB0aGUgY2hpbGQgY2xhc3MsIHNob3VsZCB1cGRhdGUgdGhlIGRpc3BsYXllZCB0aW1lXG4gICAqIGluIGFjY29yZGFuY2Ugd2l0aCB0aGUgZmFjdCB0aGF0IHRoZSBjdXJyZW50IHRpbWUgaGFzIGNoYW5nZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IFtldmVudF1cbiAgICogICAgICAgIFRoZSBgdGltZXVwZGF0ZWAgIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgdG8gcnVuLlxuICAgKlxuICAgKiBAbGlzdGVucyBQbGF5ZXIjdGltZXVwZGF0ZVxuICAgKi9cblxuXG4gIFRpbWVEaXNwbGF5LnByb3RvdHlwZS51cGRhdGVDb250ZW50ID0gZnVuY3Rpb24gdXBkYXRlQ29udGVudChldmVudCkge307XG5cbiAgcmV0dXJuIFRpbWVEaXNwbGF5O1xufShDb21wb25lbnQpO1xuXG4vKipcbiAqIFRoZSB0ZXh0IHRoYXQgaXMgYWRkZWQgdG8gdGhlIGBUaW1lRGlzcGxheWAgZm9yIHNjcmVlbiByZWFkZXIgdXNlcnMuXG4gKlxuICogQHR5cGUge3N0cmluZ31cbiAqIEBwcml2YXRlXG4gKi9cblxuXG5UaW1lRGlzcGxheS5wcm90b3R5cGUubGFiZWxUZXh0XyA9ICdUaW1lJztcblxuLyoqXG4gKiBUaGUgdGV4dCB0aGF0IHNob3VsZCBkaXNwbGF5IG92ZXIgdGhlIGBUaW1lRGlzcGxheWBzIGNvbnRyb2xzLiBBZGRlZCB0byBmb3IgbG9jYWxpemF0aW9uLlxuICpcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKiBAcHJpdmF0ZVxuICpcbiAqIEBkZXByZWNhdGVkIGluIHY3OyBjb250cm9sVGV4dF8gaXMgbm90IHVzZWQgaW4gbm9uLWFjdGl2ZSBkaXNwbGF5IENvbXBvbmVudHNcbiAqL1xuVGltZURpc3BsYXkucHJvdG90eXBlLmNvbnRyb2xUZXh0XyA9ICdUaW1lJztcblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdUaW1lRGlzcGxheScsIFRpbWVEaXNwbGF5KTtcblxuLyoqXG4gKiBAZmlsZSBjdXJyZW50LXRpbWUtZGlzcGxheS5qc1xuICovXG4vKipcbiAqIERpc3BsYXlzIHRoZSBjdXJyZW50IHRpbWVcbiAqXG4gKiBAZXh0ZW5kcyBDb21wb25lbnRcbiAqL1xuXG52YXIgQ3VycmVudFRpbWVEaXNwbGF5ID0gZnVuY3Rpb24gKF9UaW1lRGlzcGxheSkge1xuICBpbmhlcml0cyhDdXJyZW50VGltZURpc3BsYXksIF9UaW1lRGlzcGxheSk7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcy5cbiAgICpcbiAgICogQHBhcmFtIHtQbGF5ZXJ9IHBsYXllclxuICAgKiAgICAgICAgVGhlIGBQbGF5ZXJgIHRoYXQgdGhpcyBjbGFzcyBzaG91bGQgYmUgYXR0YWNoZWQgdG8uXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICAgICAgIFRoZSBrZXkvdmFsdWUgc3RvcmUgb2YgcGxheWVyIG9wdGlvbnMuXG4gICAqL1xuICBmdW5jdGlvbiBDdXJyZW50VGltZURpc3BsYXkocGxheWVyLCBvcHRpb25zKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgQ3VycmVudFRpbWVEaXNwbGF5KTtcblxuICAgIHZhciBfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1RpbWVEaXNwbGF5LmNhbGwodGhpcywgcGxheWVyLCBvcHRpb25zKSk7XG5cbiAgICBfdGhpcy5vbihwbGF5ZXIsICdlbmRlZCcsIF90aGlzLmhhbmRsZUVuZGVkKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICAvKipcbiAgICogQnVpbGRzIHRoZSBkZWZhdWx0IERPTSBgY2xhc3NOYW1lYC5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKiAgICAgICAgIFRoZSBET00gYGNsYXNzTmFtZWAgZm9yIHRoaXMgb2JqZWN0LlxuICAgKi9cblxuXG4gIEN1cnJlbnRUaW1lRGlzcGxheS5wcm90b3R5cGUuYnVpbGRDU1NDbGFzcyA9IGZ1bmN0aW9uIGJ1aWxkQ1NTQ2xhc3MoKSB7XG4gICAgcmV0dXJuICd2anMtY3VycmVudC10aW1lJztcbiAgfTtcblxuICAvKipcbiAgICogVXBkYXRlIGN1cnJlbnQgdGltZSBkaXNwbGF5XG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IFtldmVudF1cbiAgICogICAgICAgIFRoZSBgdGltZXVwZGF0ZWAgZXZlbnQgdGhhdCBjYXVzZWQgdGhpcyBmdW5jdGlvbiB0byBydW4uXG4gICAqXG4gICAqIEBsaXN0ZW5zIFBsYXllciN0aW1ldXBkYXRlXG4gICAqL1xuXG5cbiAgQ3VycmVudFRpbWVEaXNwbGF5LnByb3RvdHlwZS51cGRhdGVDb250ZW50ID0gZnVuY3Rpb24gdXBkYXRlQ29udGVudChldmVudCkge1xuICAgIC8vIEFsbG93cyBmb3Igc21vb3RoIHNjcnViYmluZywgd2hlbiBwbGF5ZXIgY2FuJ3Qga2VlcCB1cC5cbiAgICB2YXIgdGltZSA9IHRoaXMucGxheWVyXy5zY3J1YmJpbmcoKSA/IHRoaXMucGxheWVyXy5nZXRDYWNoZSgpLmN1cnJlbnRUaW1lIDogdGhpcy5wbGF5ZXJfLmN1cnJlbnRUaW1lKCk7XG5cbiAgICB0aGlzLnVwZGF0ZUZvcm1hdHRlZFRpbWVfKHRpbWUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBXaGVuIHRoZSBwbGF5ZXIgZmlyZXMgZW5kZWQgdGhlcmUgc2hvdWxkIGJlIG5vIHRpbWUgbGVmdC4gU2FkbHlcbiAgICogdGhpcyBpcyBub3QgYWx3YXlzIHRoZSBjYXNlLCBsZXRzIG1ha2UgaXQgc2VlbSBsaWtlIHRoYXQgaXMgdGhlIGNhc2VcbiAgICogZm9yIHVzZXJzLlxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBbZXZlbnRdXG4gICAqICAgICAgICBUaGUgYGVuZGVkYCBldmVudCB0aGF0IGNhdXNlZCB0aGlzIHRvIHJ1bi5cbiAgICpcbiAgICogQGxpc3RlbnMgUGxheWVyI2VuZGVkXG4gICAqL1xuXG5cbiAgQ3VycmVudFRpbWVEaXNwbGF5LnByb3RvdHlwZS5oYW5kbGVFbmRlZCA9IGZ1bmN0aW9uIGhhbmRsZUVuZGVkKGV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLnBsYXllcl8uZHVyYXRpb24oKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnVwZGF0ZUZvcm1hdHRlZFRpbWVfKHRoaXMucGxheWVyXy5kdXJhdGlvbigpKTtcbiAgfTtcblxuICByZXR1cm4gQ3VycmVudFRpbWVEaXNwbGF5O1xufShUaW1lRGlzcGxheSk7XG5cbi8qKlxuICogVGhlIHRleHQgdGhhdCBpcyBhZGRlZCB0byB0aGUgYEN1cnJlbnRUaW1lRGlzcGxheWAgZm9yIHNjcmVlbiByZWFkZXIgdXNlcnMuXG4gKlxuICogQHR5cGUge3N0cmluZ31cbiAqIEBwcml2YXRlXG4gKi9cblxuXG5DdXJyZW50VGltZURpc3BsYXkucHJvdG90eXBlLmxhYmVsVGV4dF8gPSAnQ3VycmVudCBUaW1lJztcblxuLyoqXG4gKiBUaGUgdGV4dCB0aGF0IHNob3VsZCBkaXNwbGF5IG92ZXIgdGhlIGBDdXJyZW50VGltZURpc3BsYXlgcyBjb250cm9scy4gQWRkZWQgdG8gZm9yIGxvY2FsaXphdGlvbi5cbiAqXG4gKiBAdHlwZSB7c3RyaW5nfVxuICogQHByaXZhdGVcbiAqXG4gKiBAZGVwcmVjYXRlZCBpbiB2NzsgY29udHJvbFRleHRfIGlzIG5vdCB1c2VkIGluIG5vbi1hY3RpdmUgZGlzcGxheSBDb21wb25lbnRzXG4gKi9cbkN1cnJlbnRUaW1lRGlzcGxheS5wcm90b3R5cGUuY29udHJvbFRleHRfID0gJ0N1cnJlbnQgVGltZSc7XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnQ3VycmVudFRpbWVEaXNwbGF5JywgQ3VycmVudFRpbWVEaXNwbGF5KTtcblxuLyoqXG4gKiBAZmlsZSBkdXJhdGlvbi1kaXNwbGF5LmpzXG4gKi9cbi8qKlxuICogRGlzcGxheXMgdGhlIGR1cmF0aW9uXG4gKlxuICogQGV4dGVuZHMgQ29tcG9uZW50XG4gKi9cblxudmFyIER1cmF0aW9uRGlzcGxheSA9IGZ1bmN0aW9uIChfVGltZURpc3BsYXkpIHtcbiAgaW5oZXJpdHMoRHVyYXRpb25EaXNwbGF5LCBfVGltZURpc3BsYXkpO1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7UGxheWVyfSBwbGF5ZXJcbiAgICogICAgICAgIFRoZSBgUGxheWVyYCB0aGF0IHRoaXMgY2xhc3Mgc2hvdWxkIGJlIGF0dGFjaGVkIHRvLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgICAgICBUaGUga2V5L3ZhbHVlIHN0b3JlIG9mIHBsYXllciBvcHRpb25zLlxuICAgKi9cbiAgZnVuY3Rpb24gRHVyYXRpb25EaXNwbGF5KHBsYXllciwgb3B0aW9ucykge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIER1cmF0aW9uRGlzcGxheSk7XG5cbiAgICAvLyB3ZSBkbyBub3Qgd2FudCB0by9uZWVkIHRvIHRocm90dGxlIGR1cmF0aW9uIGNoYW5nZXMsXG4gICAgLy8gYXMgdGhleSBzaG91bGQgYWx3YXlzIGRpc3BsYXkgdGhlIGNoYW5nZWQgZHVyYXRpb24gYXNcbiAgICAvLyBpdCBoYXMgY2hhbmdlZFxuICAgIHZhciBfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1RpbWVEaXNwbGF5LmNhbGwodGhpcywgcGxheWVyLCBvcHRpb25zKSk7XG5cbiAgICBfdGhpcy5vbihwbGF5ZXIsICdkdXJhdGlvbmNoYW5nZScsIF90aGlzLnVwZGF0ZUNvbnRlbnQpO1xuXG4gICAgLy8gQWxzbyBsaXN0ZW4gZm9yIHRpbWV1cGRhdGUgKGluIHRoZSBwYXJlbnQpIGFuZCBsb2FkZWRtZXRhZGF0YSBiZWNhdXNlIHJlbW92aW5nIHRob3NlXG4gICAgLy8gbGlzdGVuZXJzIGNvdWxkIGhhdmUgYnJva2VuIGRlcGVuZGVudCBhcHBsaWNhdGlvbnMvbGlicmFyaWVzLiBUaGVzZVxuICAgIC8vIGNhbiBsaWtlbHkgYmUgcmVtb3ZlZCBmb3IgNy4wLlxuICAgIF90aGlzLm9uKHBsYXllciwgJ2xvYWRlZG1ldGFkYXRhJywgX3RoaXMudGhyb3R0bGVkVXBkYXRlQ29udGVudCk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEJ1aWxkcyB0aGUgZGVmYXVsdCBET00gYGNsYXNzTmFtZWAuXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICogICAgICAgICBUaGUgRE9NIGBjbGFzc05hbWVgIGZvciB0aGlzIG9iamVjdC5cbiAgICovXG5cblxuICBEdXJhdGlvbkRpc3BsYXkucHJvdG90eXBlLmJ1aWxkQ1NTQ2xhc3MgPSBmdW5jdGlvbiBidWlsZENTU0NsYXNzKCkge1xuICAgIHJldHVybiAndmpzLWR1cmF0aW9uJztcbiAgfTtcblxuICAvKipcbiAgICogVXBkYXRlIGR1cmF0aW9uIHRpbWUgZGlzcGxheS5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gW2V2ZW50XVxuICAgKiAgICAgICAgVGhlIGBkdXJhdGlvbmNoYW5nZWAsIGB0aW1ldXBkYXRlYCwgb3IgYGxvYWRlZG1ldGFkYXRhYCBldmVudCB0aGF0IGNhdXNlZFxuICAgKiAgICAgICAgdGhpcyBmdW5jdGlvbiB0byBiZSBjYWxsZWQuXG4gICAqXG4gICAqIEBsaXN0ZW5zIFBsYXllciNkdXJhdGlvbmNoYW5nZVxuICAgKiBAbGlzdGVucyBQbGF5ZXIjdGltZXVwZGF0ZVxuICAgKiBAbGlzdGVucyBQbGF5ZXIjbG9hZGVkbWV0YWRhdGFcbiAgICovXG5cblxuICBEdXJhdGlvbkRpc3BsYXkucHJvdG90eXBlLnVwZGF0ZUNvbnRlbnQgPSBmdW5jdGlvbiB1cGRhdGVDb250ZW50KGV2ZW50KSB7XG4gICAgdmFyIGR1cmF0aW9uID0gdGhpcy5wbGF5ZXJfLmR1cmF0aW9uKCk7XG5cbiAgICBpZiAoZHVyYXRpb24gJiYgdGhpcy5kdXJhdGlvbl8gIT09IGR1cmF0aW9uKSB7XG4gICAgICB0aGlzLmR1cmF0aW9uXyA9IGR1cmF0aW9uO1xuICAgICAgdGhpcy51cGRhdGVGb3JtYXR0ZWRUaW1lXyhkdXJhdGlvbik7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBEdXJhdGlvbkRpc3BsYXk7XG59KFRpbWVEaXNwbGF5KTtcblxuLyoqXG4gKiBUaGUgdGV4dCB0aGF0IGlzIGFkZGVkIHRvIHRoZSBgRHVyYXRpb25EaXNwbGF5YCBmb3Igc2NyZWVuIHJlYWRlciB1c2Vycy5cbiAqXG4gKiBAdHlwZSB7c3RyaW5nfVxuICogQHByaXZhdGVcbiAqL1xuXG5cbkR1cmF0aW9uRGlzcGxheS5wcm90b3R5cGUubGFiZWxUZXh0XyA9ICdEdXJhdGlvbic7XG5cbi8qKlxuICogVGhlIHRleHQgdGhhdCBzaG91bGQgZGlzcGxheSBvdmVyIHRoZSBgRHVyYXRpb25EaXNwbGF5YHMgY29udHJvbHMuIEFkZGVkIHRvIGZvciBsb2NhbGl6YXRpb24uXG4gKlxuICogQHR5cGUge3N0cmluZ31cbiAqIEBwcml2YXRlXG4gKlxuICogQGRlcHJlY2F0ZWQgaW4gdjc7IGNvbnRyb2xUZXh0XyBpcyBub3QgdXNlZCBpbiBub24tYWN0aXZlIGRpc3BsYXkgQ29tcG9uZW50c1xuICovXG5EdXJhdGlvbkRpc3BsYXkucHJvdG90eXBlLmNvbnRyb2xUZXh0XyA9ICdEdXJhdGlvbic7XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnRHVyYXRpb25EaXNwbGF5JywgRHVyYXRpb25EaXNwbGF5KTtcblxuLyoqXG4gKiBAZmlsZSB0aW1lLWRpdmlkZXIuanNcbiAqL1xuLyoqXG4gKiBUaGUgc2VwYXJhdG9yIGJldHdlZW4gdGhlIGN1cnJlbnQgdGltZSBhbmQgZHVyYXRpb24uXG4gKiBDYW4gYmUgaGlkZGVuIGlmIGl0J3Mgbm90IG5lZWRlZCBpbiB0aGUgZGVzaWduLlxuICpcbiAqIEBleHRlbmRzIENvbXBvbmVudFxuICovXG5cbnZhciBUaW1lRGl2aWRlciA9IGZ1bmN0aW9uIChfQ29tcG9uZW50KSB7XG4gIGluaGVyaXRzKFRpbWVEaXZpZGVyLCBfQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBUaW1lRGl2aWRlcigpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBUaW1lRGl2aWRlcik7XG4gICAgcmV0dXJuIHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX0NvbXBvbmVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgdGhlIGNvbXBvbmVudCdzIERPTSBlbGVtZW50XG4gICAqXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9XG4gICAqICAgICAgICAgVGhlIGVsZW1lbnQgdGhhdCB3YXMgY3JlYXRlZC5cbiAgICovXG4gIFRpbWVEaXZpZGVyLnByb3RvdHlwZS5jcmVhdGVFbCA9IGZ1bmN0aW9uIGNyZWF0ZUVsKCkge1xuICAgIHJldHVybiBfQ29tcG9uZW50LnByb3RvdHlwZS5jcmVhdGVFbC5jYWxsKHRoaXMsICdkaXYnLCB7XG4gICAgICBjbGFzc05hbWU6ICd2anMtdGltZS1jb250cm9sIHZqcy10aW1lLWRpdmlkZXInLFxuICAgICAgaW5uZXJIVE1MOiAnPGRpdj48c3Bhbj4vPC9zcGFuPjwvZGl2PidcbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4gVGltZURpdmlkZXI7XG59KENvbXBvbmVudCk7XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnVGltZURpdmlkZXInLCBUaW1lRGl2aWRlcik7XG5cbi8qKlxuICogQGZpbGUgcmVtYWluaW5nLXRpbWUtZGlzcGxheS5qc1xuICovXG4vKipcbiAqIERpc3BsYXlzIHRoZSB0aW1lIGxlZnQgaW4gdGhlIHZpZGVvXG4gKlxuICogQGV4dGVuZHMgQ29tcG9uZW50XG4gKi9cblxudmFyIFJlbWFpbmluZ1RpbWVEaXNwbGF5ID0gZnVuY3Rpb24gKF9UaW1lRGlzcGxheSkge1xuICBpbmhlcml0cyhSZW1haW5pbmdUaW1lRGlzcGxheSwgX1RpbWVEaXNwbGF5KTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge1BsYXllcn0gcGxheWVyXG4gICAqICAgICAgICBUaGUgYFBsYXllcmAgdGhhdCB0aGlzIGNsYXNzIHNob3VsZCBiZSBhdHRhY2hlZCB0by5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgICAgICAgVGhlIGtleS92YWx1ZSBzdG9yZSBvZiBwbGF5ZXIgb3B0aW9ucy5cbiAgICovXG4gIGZ1bmN0aW9uIFJlbWFpbmluZ1RpbWVEaXNwbGF5KHBsYXllciwgb3B0aW9ucykge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFJlbWFpbmluZ1RpbWVEaXNwbGF5KTtcblxuICAgIHZhciBfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1RpbWVEaXNwbGF5LmNhbGwodGhpcywgcGxheWVyLCBvcHRpb25zKSk7XG5cbiAgICBfdGhpcy5vbihwbGF5ZXIsICdkdXJhdGlvbmNoYW5nZScsIF90aGlzLnRocm90dGxlZFVwZGF0ZUNvbnRlbnQpO1xuICAgIF90aGlzLm9uKHBsYXllciwgJ2VuZGVkJywgX3RoaXMuaGFuZGxlRW5kZWQpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBCdWlsZHMgdGhlIGRlZmF1bHQgRE9NIGBjbGFzc05hbWVgLlxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqICAgICAgICAgVGhlIERPTSBgY2xhc3NOYW1lYCBmb3IgdGhpcyBvYmplY3QuXG4gICAqL1xuXG5cbiAgUmVtYWluaW5nVGltZURpc3BsYXkucHJvdG90eXBlLmJ1aWxkQ1NTQ2xhc3MgPSBmdW5jdGlvbiBidWlsZENTU0NsYXNzKCkge1xuICAgIHJldHVybiAndmpzLXJlbWFpbmluZy10aW1lJztcbiAgfTtcblxuICAvKipcbiAgICogVGhlIHJlbWFpbmluZyB0aW1lIGRpc3BsYXkgcHJlZml4ZXMgbnVtYmVycyB3aXRoIGEgXCJtaW51c1wiIGNoYXJhY3Rlci5cbiAgICpcbiAgICogQHBhcmFtICB7bnVtYmVyfSB0aW1lXG4gICAqICAgICAgICAgQSBudW1lcmljIHRpbWUsIGluIHNlY29uZHMuXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICogICAgICAgICBBIGZvcm1hdHRlZCB0aW1lXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgUmVtYWluaW5nVGltZURpc3BsYXkucHJvdG90eXBlLmZvcm1hdFRpbWVfID0gZnVuY3Rpb24gZm9ybWF0VGltZV8odGltZSkge1xuICAgIC8vIFRPRE86IFRoZSBcIi1cIiBzaG91bGQgYmUgZGVjb3JhdGl2ZSwgYW5kIG5vdCBhbm5vdW5jZWQgYnkgYSBzY3JlZW4gcmVhZGVyXG4gICAgcmV0dXJuICctJyArIF9UaW1lRGlzcGxheS5wcm90b3R5cGUuZm9ybWF0VGltZV8uY2FsbCh0aGlzLCB0aW1lKTtcbiAgfTtcblxuICAvKipcbiAgICogVXBkYXRlIHJlbWFpbmluZyB0aW1lIGRpc3BsYXkuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IFtldmVudF1cbiAgICogICAgICAgIFRoZSBgdGltZXVwZGF0ZWAgb3IgYGR1cmF0aW9uY2hhbmdlYCBldmVudCB0aGF0IGNhdXNlZCB0aGlzIHRvIHJ1bi5cbiAgICpcbiAgICogQGxpc3RlbnMgUGxheWVyI3RpbWV1cGRhdGVcbiAgICogQGxpc3RlbnMgUGxheWVyI2R1cmF0aW9uY2hhbmdlXG4gICAqL1xuXG5cbiAgUmVtYWluaW5nVGltZURpc3BsYXkucHJvdG90eXBlLnVwZGF0ZUNvbnRlbnQgPSBmdW5jdGlvbiB1cGRhdGVDb250ZW50KGV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLnBsYXllcl8uZHVyYXRpb24oKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIEBkZXByZWNhdGVkIFdlIHNob3VsZCBvbmx5IHVzZSByZW1haW5pbmdUaW1lRGlzcGxheVxuICAgIC8vIGFzIG9mIHZpZGVvLmpzIDdcbiAgICBpZiAodGhpcy5wbGF5ZXJfLnJlbWFpbmluZ1RpbWVEaXNwbGF5KSB7XG4gICAgICB0aGlzLnVwZGF0ZUZvcm1hdHRlZFRpbWVfKHRoaXMucGxheWVyXy5yZW1haW5pbmdUaW1lRGlzcGxheSgpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy51cGRhdGVGb3JtYXR0ZWRUaW1lXyh0aGlzLnBsYXllcl8ucmVtYWluaW5nVGltZSgpKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFdoZW4gdGhlIHBsYXllciBmaXJlcyBlbmRlZCB0aGVyZSBzaG91bGQgYmUgbm8gdGltZSBsZWZ0LiBTYWRseVxuICAgKiB0aGlzIGlzIG5vdCBhbHdheXMgdGhlIGNhc2UsIGxldHMgbWFrZSBpdCBzZWVtIGxpa2UgdGhhdCBpcyB0aGUgY2FzZVxuICAgKiBmb3IgdXNlcnMuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IFtldmVudF1cbiAgICogICAgICAgIFRoZSBgZW5kZWRgIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgdG8gcnVuLlxuICAgKlxuICAgKiBAbGlzdGVucyBQbGF5ZXIjZW5kZWRcbiAgICovXG5cblxuICBSZW1haW5pbmdUaW1lRGlzcGxheS5wcm90b3R5cGUuaGFuZGxlRW5kZWQgPSBmdW5jdGlvbiBoYW5kbGVFbmRlZChldmVudCkge1xuICAgIGlmICghdGhpcy5wbGF5ZXJfLmR1cmF0aW9uKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy51cGRhdGVGb3JtYXR0ZWRUaW1lXygwKTtcbiAgfTtcblxuICByZXR1cm4gUmVtYWluaW5nVGltZURpc3BsYXk7XG59KFRpbWVEaXNwbGF5KTtcblxuLyoqXG4gKiBUaGUgdGV4dCB0aGF0IGlzIGFkZGVkIHRvIHRoZSBgUmVtYWluaW5nVGltZURpc3BsYXlgIGZvciBzY3JlZW4gcmVhZGVyIHVzZXJzLlxuICpcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKiBAcHJpdmF0ZVxuICovXG5cblxuUmVtYWluaW5nVGltZURpc3BsYXkucHJvdG90eXBlLmxhYmVsVGV4dF8gPSAnUmVtYWluaW5nIFRpbWUnO1xuXG4vKipcbiAqIFRoZSB0ZXh0IHRoYXQgc2hvdWxkIGRpc3BsYXkgb3ZlciB0aGUgYFJlbWFpbmluZ1RpbWVEaXNwbGF5YHMgY29udHJvbHMuIEFkZGVkIHRvIGZvciBsb2NhbGl6YXRpb24uXG4gKlxuICogQHR5cGUge3N0cmluZ31cbiAqIEBwcml2YXRlXG4gKlxuICogQGRlcHJlY2F0ZWQgaW4gdjc7IGNvbnRyb2xUZXh0XyBpcyBub3QgdXNlZCBpbiBub24tYWN0aXZlIGRpc3BsYXkgQ29tcG9uZW50c1xuICovXG5SZW1haW5pbmdUaW1lRGlzcGxheS5wcm90b3R5cGUuY29udHJvbFRleHRfID0gJ1JlbWFpbmluZyBUaW1lJztcblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdSZW1haW5pbmdUaW1lRGlzcGxheScsIFJlbWFpbmluZ1RpbWVEaXNwbGF5KTtcblxuLyoqXG4gKiBAZmlsZSBsaXZlLWRpc3BsYXkuanNcbiAqL1xuLy8gVE9ETyAtIEZ1dHVyZSBtYWtlIGl0IGNsaWNrIHRvIHNuYXAgdG8gbGl2ZVxuXG4vKipcbiAqIERpc3BsYXlzIHRoZSBsaXZlIGluZGljYXRvciB3aGVuIGR1cmF0aW9uIGlzIEluZmluaXR5LlxuICpcbiAqIEBleHRlbmRzIENvbXBvbmVudFxuICovXG5cbnZhciBMaXZlRGlzcGxheSA9IGZ1bmN0aW9uIChfQ29tcG9uZW50KSB7XG4gIGluaGVyaXRzKExpdmVEaXNwbGF5LCBfQ29tcG9uZW50KTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge1BsYXllcn0gcGxheWVyXG4gICAqICAgICAgICBUaGUgYFBsYXllcmAgdGhhdCB0aGlzIGNsYXNzIHNob3VsZCBiZSBhdHRhY2hlZCB0by5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgICAgICAgVGhlIGtleS92YWx1ZSBzdG9yZSBvZiBwbGF5ZXIgb3B0aW9ucy5cbiAgICovXG4gIGZ1bmN0aW9uIExpdmVEaXNwbGF5KHBsYXllciwgb3B0aW9ucykge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIExpdmVEaXNwbGF5KTtcblxuICAgIHZhciBfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX0NvbXBvbmVudC5jYWxsKHRoaXMsIHBsYXllciwgb3B0aW9ucykpO1xuXG4gICAgX3RoaXMudXBkYXRlU2hvd2luZygpO1xuICAgIF90aGlzLm9uKF90aGlzLnBsYXllcigpLCAnZHVyYXRpb25jaGFuZ2UnLCBfdGhpcy51cGRhdGVTaG93aW5nKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIHRoZSBgQ29tcG9uZW50YCdzIERPTSBlbGVtZW50XG4gICAqXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9XG4gICAqICAgICAgICAgVGhlIGVsZW1lbnQgdGhhdCB3YXMgY3JlYXRlZC5cbiAgICovXG5cblxuICBMaXZlRGlzcGxheS5wcm90b3R5cGUuY3JlYXRlRWwgPSBmdW5jdGlvbiBjcmVhdGVFbCQkMSgpIHtcbiAgICB2YXIgZWwgPSBfQ29tcG9uZW50LnByb3RvdHlwZS5jcmVhdGVFbC5jYWxsKHRoaXMsICdkaXYnLCB7XG4gICAgICBjbGFzc05hbWU6ICd2anMtbGl2ZS1jb250cm9sIHZqcy1jb250cm9sJ1xuICAgIH0pO1xuXG4gICAgdGhpcy5jb250ZW50RWxfID0gY3JlYXRlRWwoJ2RpdicsIHtcbiAgICAgIGNsYXNzTmFtZTogJ3Zqcy1saXZlLWRpc3BsYXknLFxuICAgICAgaW5uZXJIVE1MOiAnPHNwYW4gY2xhc3M9XCJ2anMtY29udHJvbC10ZXh0XCI+JyArIHRoaXMubG9jYWxpemUoJ1N0cmVhbSBUeXBlJykgKyAnXFx4QTA8L3NwYW4+JyArIHRoaXMubG9jYWxpemUoJ0xJVkUnKVxuICAgIH0sIHtcbiAgICAgICdhcmlhLWxpdmUnOiAnb2ZmJ1xuICAgIH0pO1xuXG4gICAgZWwuYXBwZW5kQ2hpbGQodGhpcy5jb250ZW50RWxfKTtcbiAgICByZXR1cm4gZWw7XG4gIH07XG5cbiAgTGl2ZURpc3BsYXkucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiBkaXNwb3NlKCkge1xuICAgIHRoaXMuY29udGVudEVsXyA9IG51bGw7XG5cbiAgICBfQ29tcG9uZW50LnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENoZWNrIHRoZSBkdXJhdGlvbiB0byBzZWUgaWYgdGhlIExpdmVEaXNwbGF5IHNob3VsZCBiZSBzaG93aW5nIG9yIG5vdC4gVGhlbiBzaG93L2hpZGVcbiAgICogaXQgYWNjb3JkaW5nbHlcbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gW2V2ZW50XVxuICAgKiAgICAgICAgVGhlIHtAbGluayBQbGF5ZXIjZHVyYXRpb25jaGFuZ2V9IGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgZnVuY3Rpb24gdG8gcnVuLlxuICAgKlxuICAgKiBAbGlzdGVucyBQbGF5ZXIjZHVyYXRpb25jaGFuZ2VcbiAgICovXG5cblxuICBMaXZlRGlzcGxheS5wcm90b3R5cGUudXBkYXRlU2hvd2luZyA9IGZ1bmN0aW9uIHVwZGF0ZVNob3dpbmcoZXZlbnQpIHtcbiAgICBpZiAodGhpcy5wbGF5ZXIoKS5kdXJhdGlvbigpID09PSBJbmZpbml0eSkge1xuICAgICAgdGhpcy5zaG93KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaGlkZSgpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gTGl2ZURpc3BsYXk7XG59KENvbXBvbmVudCk7XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnTGl2ZURpc3BsYXknLCBMaXZlRGlzcGxheSk7XG5cbi8qKlxuICogQGZpbGUgc2xpZGVyLmpzXG4gKi9cbi8qKlxuICogVGhlIGJhc2UgZnVuY3Rpb25hbGl0eSBmb3IgYSBzbGlkZXIuIENhbiBiZSB2ZXJ0aWNhbCBvciBob3Jpem9udGFsLlxuICogRm9yIGluc3RhbmNlIHRoZSB2b2x1bWUgYmFyIG9yIHRoZSBzZWVrIGJhciBvbiBhIHZpZGVvIGlzIGEgc2xpZGVyLlxuICpcbiAqIEBleHRlbmRzIENvbXBvbmVudFxuICovXG5cbnZhciBTbGlkZXIgPSBmdW5jdGlvbiAoX0NvbXBvbmVudCkge1xuICBpbmhlcml0cyhTbGlkZXIsIF9Db21wb25lbnQpO1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzc1xuICAgKlxuICAgKiBAcGFyYW0ge1BsYXllcn0gcGxheWVyXG4gICAqICAgICAgICBUaGUgYFBsYXllcmAgdGhhdCB0aGlzIGNsYXNzIHNob3VsZCBiZSBhdHRhY2hlZCB0by5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgICAgICAgVGhlIGtleS92YWx1ZSBzdG9yZSBvZiBwbGF5ZXIgb3B0aW9ucy5cbiAgICovXG4gIGZ1bmN0aW9uIFNsaWRlcihwbGF5ZXIsIG9wdGlvbnMpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBTbGlkZXIpO1xuXG4gICAgLy8gU2V0IHByb3BlcnR5IG5hbWVzIHRvIGJhciB0byBtYXRjaCB3aXRoIHRoZSBjaGlsZCBTbGlkZXIgY2xhc3MgaXMgbG9va2luZyBmb3JcbiAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9Db21wb25lbnQuY2FsbCh0aGlzLCBwbGF5ZXIsIG9wdGlvbnMpKTtcblxuICAgIF90aGlzLmJhciA9IF90aGlzLmdldENoaWxkKF90aGlzLm9wdGlvbnNfLmJhck5hbWUpO1xuXG4gICAgLy8gU2V0IGEgaG9yaXpvbnRhbCBvciB2ZXJ0aWNhbCBjbGFzcyBvbiB0aGUgc2xpZGVyIGRlcGVuZGluZyBvbiB0aGUgc2xpZGVyIHR5cGVcbiAgICBfdGhpcy52ZXJ0aWNhbCghIV90aGlzLm9wdGlvbnNfLnZlcnRpY2FsKTtcblxuICAgIF90aGlzLmVuYWJsZSgpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBBcmUgY29udHJvbHMgYXJlIGN1cnJlbnRseSBlbmFibGVkIGZvciB0aGlzIHNsaWRlciBvciBub3QuXG4gICAqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqICAgICAgICAgdHJ1ZSBpZiBjb250cm9scyBhcmUgZW5hYmxlZCwgZmFsc2Ugb3RoZXJ3aXNlXG4gICAqL1xuXG5cbiAgU2xpZGVyLnByb3RvdHlwZS5lbmFibGVkID0gZnVuY3Rpb24gZW5hYmxlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5lbmFibGVkXztcbiAgfTtcblxuICAvKipcbiAgICogRW5hYmxlIGNvbnRyb2xzIGZvciB0aGlzIHNsaWRlciBpZiB0aGV5IGFyZSBkaXNhYmxlZFxuICAgKi9cblxuXG4gIFNsaWRlci5wcm90b3R5cGUuZW5hYmxlID0gZnVuY3Rpb24gZW5hYmxlKCkge1xuICAgIGlmICh0aGlzLmVuYWJsZWQoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMub24oJ21vdXNlZG93bicsIHRoaXMuaGFuZGxlTW91c2VEb3duKTtcbiAgICB0aGlzLm9uKCd0b3VjaHN0YXJ0JywgdGhpcy5oYW5kbGVNb3VzZURvd24pO1xuICAgIHRoaXMub24oJ2ZvY3VzJywgdGhpcy5oYW5kbGVGb2N1cyk7XG4gICAgdGhpcy5vbignYmx1cicsIHRoaXMuaGFuZGxlQmx1cik7XG4gICAgdGhpcy5vbignY2xpY2snLCB0aGlzLmhhbmRsZUNsaWNrKTtcblxuICAgIHRoaXMub24odGhpcy5wbGF5ZXJfLCAnY29udHJvbHN2aXNpYmxlJywgdGhpcy51cGRhdGUpO1xuXG4gICAgaWYgKHRoaXMucGxheWVyRXZlbnQpIHtcbiAgICAgIHRoaXMub24odGhpcy5wbGF5ZXJfLCB0aGlzLnBsYXllckV2ZW50LCB0aGlzLnVwZGF0ZSk7XG4gICAgfVxuXG4gICAgdGhpcy5yZW1vdmVDbGFzcygnZGlzYWJsZWQnKTtcbiAgICB0aGlzLnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCAwKTtcblxuICAgIHRoaXMuZW5hYmxlZF8gPSB0cnVlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBEaXNhYmxlIGNvbnRyb2xzIGZvciB0aGlzIHNsaWRlciBpZiB0aGV5IGFyZSBlbmFibGVkXG4gICAqL1xuXG5cbiAgU2xpZGVyLnByb3RvdHlwZS5kaXNhYmxlID0gZnVuY3Rpb24gZGlzYWJsZSgpIHtcbiAgICBpZiAoIXRoaXMuZW5hYmxlZCgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBkb2MgPSB0aGlzLmJhci5lbF8ub3duZXJEb2N1bWVudDtcblxuICAgIHRoaXMub2ZmKCdtb3VzZWRvd24nLCB0aGlzLmhhbmRsZU1vdXNlRG93bik7XG4gICAgdGhpcy5vZmYoJ3RvdWNoc3RhcnQnLCB0aGlzLmhhbmRsZU1vdXNlRG93bik7XG4gICAgdGhpcy5vZmYoJ2ZvY3VzJywgdGhpcy5oYW5kbGVGb2N1cyk7XG4gICAgdGhpcy5vZmYoJ2JsdXInLCB0aGlzLmhhbmRsZUJsdXIpO1xuICAgIHRoaXMub2ZmKCdjbGljaycsIHRoaXMuaGFuZGxlQ2xpY2spO1xuICAgIHRoaXMub2ZmKHRoaXMucGxheWVyXywgJ2NvbnRyb2xzdmlzaWJsZScsIHRoaXMudXBkYXRlKTtcbiAgICB0aGlzLm9mZihkb2MsICdtb3VzZW1vdmUnLCB0aGlzLmhhbmRsZU1vdXNlTW92ZSk7XG4gICAgdGhpcy5vZmYoZG9jLCAnbW91c2V1cCcsIHRoaXMuaGFuZGxlTW91c2VVcCk7XG4gICAgdGhpcy5vZmYoZG9jLCAndG91Y2htb3ZlJywgdGhpcy5oYW5kbGVNb3VzZU1vdmUpO1xuICAgIHRoaXMub2ZmKGRvYywgJ3RvdWNoZW5kJywgdGhpcy5oYW5kbGVNb3VzZVVwKTtcbiAgICB0aGlzLnJlbW92ZUF0dHJpYnV0ZSgndGFiaW5kZXgnKTtcblxuICAgIHRoaXMuYWRkQ2xhc3MoJ2Rpc2FibGVkJyk7XG5cbiAgICBpZiAodGhpcy5wbGF5ZXJFdmVudCkge1xuICAgICAgdGhpcy5vZmYodGhpcy5wbGF5ZXJfLCB0aGlzLnBsYXllckV2ZW50LCB0aGlzLnVwZGF0ZSk7XG4gICAgfVxuICAgIHRoaXMuZW5hYmxlZF8gPSBmYWxzZTtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlIHRoZSBgQnV0dG9uYHMgRE9NIGVsZW1lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gICAqICAgICAgICBUeXBlIG9mIGVsZW1lbnQgdG8gY3JlYXRlLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW3Byb3BzPXt9XVxuICAgKiAgICAgICAgTGlzdCBvZiBwcm9wZXJ0aWVzIGluIE9iamVjdCBmb3JtLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW2F0dHJpYnV0ZXM9e31dXG4gICAqICAgICAgICBsaXN0IG9mIGF0dHJpYnV0ZXMgaW4gT2JqZWN0IGZvcm0uXG4gICAqXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9XG4gICAqICAgICAgICAgVGhlIGVsZW1lbnQgdGhhdCBnZXRzIGNyZWF0ZWQuXG4gICAqL1xuXG5cbiAgU2xpZGVyLnByb3RvdHlwZS5jcmVhdGVFbCA9IGZ1bmN0aW9uIGNyZWF0ZUVsJCQxKHR5cGUpIHtcbiAgICB2YXIgcHJvcHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIHZhciBhdHRyaWJ1dGVzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcblxuICAgIC8vIEFkZCB0aGUgc2xpZGVyIGVsZW1lbnQgY2xhc3MgdG8gYWxsIHN1YiBjbGFzc2VzXG4gICAgcHJvcHMuY2xhc3NOYW1lID0gcHJvcHMuY2xhc3NOYW1lICsgJyB2anMtc2xpZGVyJztcbiAgICBwcm9wcyA9IGFzc2lnbih7XG4gICAgICB0YWJJbmRleDogMFxuICAgIH0sIHByb3BzKTtcblxuICAgIGF0dHJpYnV0ZXMgPSBhc3NpZ24oe1xuICAgICAgJ3JvbGUnOiAnc2xpZGVyJyxcbiAgICAgICdhcmlhLXZhbHVlbm93JzogMCxcbiAgICAgICdhcmlhLXZhbHVlbWluJzogMCxcbiAgICAgICdhcmlhLXZhbHVlbWF4JzogMTAwLFxuICAgICAgJ3RhYkluZGV4JzogMFxuICAgIH0sIGF0dHJpYnV0ZXMpO1xuXG4gICAgcmV0dXJuIF9Db21wb25lbnQucHJvdG90eXBlLmNyZWF0ZUVsLmNhbGwodGhpcywgdHlwZSwgcHJvcHMsIGF0dHJpYnV0ZXMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBIYW5kbGUgYG1vdXNlZG93bmAgb3IgYHRvdWNoc3RhcnRgIGV2ZW50cyBvbiB0aGUgYFNsaWRlcmAuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IGV2ZW50XG4gICAqICAgICAgICBgbW91c2Vkb3duYCBvciBgdG91Y2hzdGFydGAgZXZlbnQgdGhhdCB0cmlnZ2VyZWQgdGhpcyBmdW5jdGlvblxuICAgKlxuICAgKiBAbGlzdGVucyBtb3VzZWRvd25cbiAgICogQGxpc3RlbnMgdG91Y2hzdGFydFxuICAgKiBAZmlyZXMgU2xpZGVyI3NsaWRlcmFjdGl2ZVxuICAgKi9cblxuXG4gIFNsaWRlci5wcm90b3R5cGUuaGFuZGxlTW91c2VEb3duID0gZnVuY3Rpb24gaGFuZGxlTW91c2VEb3duKGV2ZW50KSB7XG4gICAgdmFyIGRvYyA9IHRoaXMuYmFyLmVsXy5vd25lckRvY3VtZW50O1xuXG4gICAgaWYgKGV2ZW50LnR5cGUgPT09ICdtb3VzZWRvd24nKSB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgICAvLyBEbyBub3QgY2FsbCBwcmV2ZW50RGVmYXVsdCgpIG9uIHRvdWNoc3RhcnQgaW4gQ2hyb21lXG4gICAgLy8gdG8gYXZvaWQgY29uc29sZSB3YXJuaW5ncy4gVXNlIGEgJ3RvdWNoLWFjdGlvbjogbm9uZScgc3R5bGVcbiAgICAvLyBpbnN0ZWFkIHRvIHByZXZlbnQgdW5pbnRlbnRlZCBzY3JvbGxpbmcuXG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vd2ViL3VwZGF0ZXMvMjAxNy8wMS9zY3JvbGxpbmctaW50ZXJ2ZW50aW9uXG4gICAgaWYgKGV2ZW50LnR5cGUgPT09ICd0b3VjaHN0YXJ0JyAmJiAhSVNfQ0hST01FKSB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgICBibG9ja1RleHRTZWxlY3Rpb24oKTtcblxuICAgIHRoaXMuYWRkQ2xhc3MoJ3Zqcy1zbGlkaW5nJyk7XG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIHdoZW4gdGhlIHNsaWRlciBpcyBpbiBhbiBhY3RpdmUgc3RhdGVcbiAgICAgKlxuICAgICAqIEBldmVudCBTbGlkZXIjc2xpZGVyYWN0aXZlXG4gICAgICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICAgICAqL1xuICAgIHRoaXMudHJpZ2dlcignc2xpZGVyYWN0aXZlJyk7XG5cbiAgICB0aGlzLm9uKGRvYywgJ21vdXNlbW92ZScsIHRoaXMuaGFuZGxlTW91c2VNb3ZlKTtcbiAgICB0aGlzLm9uKGRvYywgJ21vdXNldXAnLCB0aGlzLmhhbmRsZU1vdXNlVXApO1xuICAgIHRoaXMub24oZG9jLCAndG91Y2htb3ZlJywgdGhpcy5oYW5kbGVNb3VzZU1vdmUpO1xuICAgIHRoaXMub24oZG9jLCAndG91Y2hlbmQnLCB0aGlzLmhhbmRsZU1vdXNlVXApO1xuXG4gICAgdGhpcy5oYW5kbGVNb3VzZU1vdmUoZXZlbnQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBIYW5kbGUgdGhlIGBtb3VzZW1vdmVgLCBgdG91Y2htb3ZlYCwgYW5kIGBtb3VzZWRvd25gIGV2ZW50cyBvbiB0aGlzIGBTbGlkZXJgLlxuICAgKiBUaGUgYG1vdXNlbW92ZWAgYW5kIGB0b3VjaG1vdmVgIGV2ZW50cyB3aWxsIG9ubHkgb25seSB0cmlnZ2VyIHRoaXMgZnVuY3Rpb24gZHVyaW5nXG4gICAqIGBtb3VzZWRvd25gIGFuZCBgdG91Y2hzdGFydGAuIFRoaXMgaXMgZHVlIHRvIHtAbGluayBTbGlkZXIjaGFuZGxlTW91c2VEb3dufSBhbmRcbiAgICoge0BsaW5rIFNsaWRlciNoYW5kbGVNb3VzZVVwfS5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gZXZlbnRcbiAgICogICAgICAgIGBtb3VzZWRvd25gLCBgbW91c2Vtb3ZlYCwgYHRvdWNoc3RhcnRgLCBvciBgdG91Y2htb3ZlYCBldmVudCB0aGF0IHRyaWdnZXJlZFxuICAgKiAgICAgICAgdGhpcyBmdW5jdGlvblxuICAgKlxuICAgKiBAbGlzdGVucyBtb3VzZW1vdmVcbiAgICogQGxpc3RlbnMgdG91Y2htb3ZlXG4gICAqL1xuXG5cbiAgU2xpZGVyLnByb3RvdHlwZS5oYW5kbGVNb3VzZU1vdmUgPSBmdW5jdGlvbiBoYW5kbGVNb3VzZU1vdmUoZXZlbnQpIHt9O1xuXG4gIC8qKlxuICAgKiBIYW5kbGUgYG1vdXNldXBgIG9yIGB0b3VjaGVuZGAgZXZlbnRzIG9uIHRoZSBgU2xpZGVyYC5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gZXZlbnRcbiAgICogICAgICAgIGBtb3VzZXVwYCBvciBgdG91Y2hlbmRgIGV2ZW50IHRoYXQgdHJpZ2dlcmVkIHRoaXMgZnVuY3Rpb24uXG4gICAqXG4gICAqIEBsaXN0ZW5zIHRvdWNoZW5kXG4gICAqIEBsaXN0ZW5zIG1vdXNldXBcbiAgICogQGZpcmVzIFNsaWRlciNzbGlkZXJpbmFjdGl2ZVxuICAgKi9cblxuXG4gIFNsaWRlci5wcm90b3R5cGUuaGFuZGxlTW91c2VVcCA9IGZ1bmN0aW9uIGhhbmRsZU1vdXNlVXAoKSB7XG4gICAgdmFyIGRvYyA9IHRoaXMuYmFyLmVsXy5vd25lckRvY3VtZW50O1xuXG4gICAgdW5ibG9ja1RleHRTZWxlY3Rpb24oKTtcblxuICAgIHRoaXMucmVtb3ZlQ2xhc3MoJ3Zqcy1zbGlkaW5nJyk7XG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIHdoZW4gdGhlIHNsaWRlciBpcyBubyBsb25nZXIgaW4gYW4gYWN0aXZlIHN0YXRlLlxuICAgICAqXG4gICAgICogQGV2ZW50IFNsaWRlciNzbGlkZXJpbmFjdGl2ZVxuICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAgICAgKi9cbiAgICB0aGlzLnRyaWdnZXIoJ3NsaWRlcmluYWN0aXZlJyk7XG5cbiAgICB0aGlzLm9mZihkb2MsICdtb3VzZW1vdmUnLCB0aGlzLmhhbmRsZU1vdXNlTW92ZSk7XG4gICAgdGhpcy5vZmYoZG9jLCAnbW91c2V1cCcsIHRoaXMuaGFuZGxlTW91c2VVcCk7XG4gICAgdGhpcy5vZmYoZG9jLCAndG91Y2htb3ZlJywgdGhpcy5oYW5kbGVNb3VzZU1vdmUpO1xuICAgIHRoaXMub2ZmKGRvYywgJ3RvdWNoZW5kJywgdGhpcy5oYW5kbGVNb3VzZVVwKTtcblxuICAgIHRoaXMudXBkYXRlKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSB0aGUgcHJvZ3Jlc3MgYmFyIG9mIHRoZSBgU2xpZGVyYC5cbiAgICpcbiAgICogQHJldHVybnMge251bWJlcn1cbiAgICogICAgICAgICAgVGhlIHBlcmNlbnRhZ2Ugb2YgcHJvZ3Jlc3MgdGhlIHByb2dyZXNzIGJhciByZXByZXNlbnRzIGFzIGFcbiAgICogICAgICAgICAgbnVtYmVyIGZyb20gMCB0byAxLlxuICAgKi9cblxuXG4gIFNsaWRlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlKCkge1xuXG4gICAgLy8gSW4gVm9sdW1lQmFyIGluaXQgd2UgaGF2ZSBhIHNldFRpbWVvdXQgZm9yIHVwZGF0ZSB0aGF0IHBvcHMgYW5kIHVwZGF0ZVxuICAgIC8vIHRvIHRoZSBlbmQgb2YgdGhlIGV4ZWN1dGlvbiBzdGFjay4gVGhlIHBsYXllciBpcyBkZXN0cm95ZWQgYmVmb3JlIHRoZW5cbiAgICAvLyB1cGRhdGUgd2lsbCBjYXVzZSBhbiBlcnJvclxuICAgIGlmICghdGhpcy5lbF8pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBJZiBzY3J1YmJpbmcsIHdlIGNvdWxkIHVzZSBhIGNhY2hlZCB2YWx1ZSB0byBtYWtlIHRoZSBoYW5kbGUga2VlcCB1cFxuICAgIC8vIHdpdGggdGhlIHVzZXIncyBtb3VzZS4gT24gSFRNTDUgYnJvd3NlcnMgc2NydWJiaW5nIGlzIHJlYWxseSBzbW9vdGgsIGJ1dFxuICAgIC8vIHNvbWUgZmxhc2ggcGxheWVycyBhcmUgc2xvdywgc28gd2UgbWlnaHQgd2FudCB0byB1dGlsaXplIHRoaXMgbGF0ZXIuXG4gICAgLy8gdmFyIHByb2dyZXNzID0gICh0aGlzLnBsYXllcl8uc2NydWJiaW5nKCkpID8gdGhpcy5wbGF5ZXJfLmdldENhY2hlKCkuY3VycmVudFRpbWUgLyB0aGlzLnBsYXllcl8uZHVyYXRpb24oKSA6IHRoaXMucGxheWVyXy5jdXJyZW50VGltZSgpIC8gdGhpcy5wbGF5ZXJfLmR1cmF0aW9uKCk7XG4gICAgdmFyIHByb2dyZXNzID0gdGhpcy5nZXRQZXJjZW50KCk7XG4gICAgdmFyIGJhciA9IHRoaXMuYmFyO1xuXG4gICAgLy8gSWYgdGhlcmUncyBubyBiYXIuLi5cbiAgICBpZiAoIWJhcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFByb3RlY3QgYWdhaW5zdCBubyBkdXJhdGlvbiBhbmQgb3RoZXIgZGl2aXNpb24gaXNzdWVzXG4gICAgaWYgKHR5cGVvZiBwcm9ncmVzcyAhPT0gJ251bWJlcicgfHwgcHJvZ3Jlc3MgIT09IHByb2dyZXNzIHx8IHByb2dyZXNzIDwgMCB8fCBwcm9ncmVzcyA9PT0gSW5maW5pdHkpIHtcbiAgICAgIHByb2dyZXNzID0gMDtcbiAgICB9XG5cbiAgICAvLyBDb252ZXJ0IHRvIGEgcGVyY2VudGFnZSBmb3Igc2V0dGluZ1xuICAgIHZhciBwZXJjZW50YWdlID0gKHByb2dyZXNzICogMTAwKS50b0ZpeGVkKDIpICsgJyUnO1xuICAgIHZhciBzdHlsZSA9IGJhci5lbCgpLnN0eWxlO1xuXG4gICAgLy8gU2V0IHRoZSBuZXcgYmFyIHdpZHRoIG9yIGhlaWdodFxuICAgIGlmICh0aGlzLnZlcnRpY2FsKCkpIHtcbiAgICAgIHN0eWxlLmhlaWdodCA9IHBlcmNlbnRhZ2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0eWxlLndpZHRoID0gcGVyY2VudGFnZTtcbiAgICB9XG5cbiAgICByZXR1cm4gcHJvZ3Jlc3M7XG4gIH07XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSBkaXN0YW5jZSBmb3Igc2xpZGVyXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IGV2ZW50XG4gICAqICAgICAgICBUaGUgZXZlbnQgdGhhdCBjYXVzZWQgdGhpcyBmdW5jdGlvbiB0byBydW4uXG4gICAqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICogICAgICAgICBUaGUgY3VycmVudCBwb3NpdGlvbiBvZiB0aGUgU2xpZGVyLlxuICAgKiAgICAgICAgIC0gcG9zdGl0aW9uLnggZm9yIHZlcnRpY2FsIGBTbGlkZXJgc1xuICAgKiAgICAgICAgIC0gcG9zdGl0aW9uLnkgZm9yIGhvcml6b250YWwgYFNsaWRlcmBzXG4gICAqL1xuXG5cbiAgU2xpZGVyLnByb3RvdHlwZS5jYWxjdWxhdGVEaXN0YW5jZSA9IGZ1bmN0aW9uIGNhbGN1bGF0ZURpc3RhbmNlKGV2ZW50KSB7XG4gICAgdmFyIHBvc2l0aW9uID0gZ2V0UG9pbnRlclBvc2l0aW9uKHRoaXMuZWxfLCBldmVudCk7XG5cbiAgICBpZiAodGhpcy52ZXJ0aWNhbCgpKSB7XG4gICAgICByZXR1cm4gcG9zaXRpb24ueTtcbiAgICB9XG4gICAgcmV0dXJuIHBvc2l0aW9uLng7XG4gIH07XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBhIGBmb2N1c2AgZXZlbnQgb24gdGhpcyBgU2xpZGVyYC5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gZXZlbnRcbiAgICogICAgICAgIFRoZSBgZm9jdXNgIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgZnVuY3Rpb24gdG8gcnVuLlxuICAgKlxuICAgKiBAbGlzdGVucyBmb2N1c1xuICAgKi9cblxuXG4gIFNsaWRlci5wcm90b3R5cGUuaGFuZGxlRm9jdXMgPSBmdW5jdGlvbiBoYW5kbGVGb2N1cygpIHtcbiAgICB0aGlzLm9uKHRoaXMuYmFyLmVsXy5vd25lckRvY3VtZW50LCAna2V5ZG93bicsIHRoaXMuaGFuZGxlS2V5UHJlc3MpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBIYW5kbGUgYSBga2V5ZG93bmAgZXZlbnQgb24gdGhlIGBTbGlkZXJgLiBXYXRjaGVzIGZvciBsZWZ0LCByaWd0aCwgdXAsIGFuZCBkb3duXG4gICAqIGFycm93IGtleXMuIFRoaXMgZnVuY3Rpb24gd2lsbCBvbmx5IGJlIGNhbGxlZCB3aGVuIHRoZSBzbGlkZXIgaGFzIGZvY3VzLiBTZWVcbiAgICoge0BsaW5rIFNsaWRlciNoYW5kbGVGb2N1c30gYW5kIHtAbGluayBTbGlkZXIjaGFuZGxlQmx1cn0uXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IGV2ZW50XG4gICAqICAgICAgICB0aGUgYGtleWRvd25gIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgZnVuY3Rpb24gdG8gcnVuLlxuICAgKlxuICAgKiBAbGlzdGVucyBrZXlkb3duXG4gICAqL1xuXG5cbiAgU2xpZGVyLnByb3RvdHlwZS5oYW5kbGVLZXlQcmVzcyA9IGZ1bmN0aW9uIGhhbmRsZUtleVByZXNzKGV2ZW50KSB7XG4gICAgLy8gTGVmdCBhbmQgRG93biBBcnJvd3NcbiAgICBpZiAoZXZlbnQud2hpY2ggPT09IDM3IHx8IGV2ZW50LndoaWNoID09PSA0MCkge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHRoaXMuc3RlcEJhY2soKTtcblxuICAgICAgLy8gVXAgYW5kIFJpZ2h0IEFycm93c1xuICAgIH0gZWxzZSBpZiAoZXZlbnQud2hpY2ggPT09IDM4IHx8IGV2ZW50LndoaWNoID09PSAzOSkge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHRoaXMuc3RlcEZvcndhcmQoKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBhIGBibHVyYCBldmVudCBvbiB0aGlzIGBTbGlkZXJgLlxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBldmVudFxuICAgKiAgICAgICAgVGhlIGBibHVyYCBldmVudCB0aGF0IGNhdXNlZCB0aGlzIGZ1bmN0aW9uIHRvIHJ1bi5cbiAgICpcbiAgICogQGxpc3RlbnMgYmx1clxuICAgKi9cblxuICBTbGlkZXIucHJvdG90eXBlLmhhbmRsZUJsdXIgPSBmdW5jdGlvbiBoYW5kbGVCbHVyKCkge1xuICAgIHRoaXMub2ZmKHRoaXMuYmFyLmVsXy5vd25lckRvY3VtZW50LCAna2V5ZG93bicsIHRoaXMuaGFuZGxlS2V5UHJlc3MpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBMaXN0ZW5lciBmb3IgY2xpY2sgZXZlbnRzIG9uIHNsaWRlciwgdXNlZCB0byBwcmV2ZW50IGNsaWNrc1xuICAgKiAgIGZyb20gYnViYmxpbmcgdXAgdG8gcGFyZW50IGVsZW1lbnRzIGxpa2UgYnV0dG9uIG1lbnVzLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnRcbiAgICogICAgICAgIEV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgb2JqZWN0IHRvIHJ1blxuICAgKi9cblxuXG4gIFNsaWRlci5wcm90b3R5cGUuaGFuZGxlQ2xpY2sgPSBmdW5jdGlvbiBoYW5kbGVDbGljayhldmVudCkge1xuICAgIGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldC9zZXQgaWYgc2xpZGVyIGlzIGhvcml6b250YWwgZm9yIHZlcnRpY2FsXG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Jvb2xdXG4gICAqICAgICAgICAtIHRydWUgaWYgc2xpZGVyIGlzIHZlcnRpY2FsLFxuICAgKiAgICAgICAgLSBmYWxzZSBpcyBob3Jpem9udGFsXG4gICAqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqICAgICAgICAgLSB0cnVlIGlmIHNsaWRlciBpcyB2ZXJ0aWNhbCwgYW5kIGdldHRpbmdcbiAgICogICAgICAgICAtIGZhbHNlIGlmIHRoZSBzbGlkZXIgaXMgaG9yaXpvbnRhbCwgYW5kIGdldHRpbmdcbiAgICovXG5cblxuICBTbGlkZXIucHJvdG90eXBlLnZlcnRpY2FsID0gZnVuY3Rpb24gdmVydGljYWwoYm9vbCkge1xuICAgIGlmIChib29sID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLnZlcnRpY2FsXyB8fCBmYWxzZTtcbiAgICB9XG5cbiAgICB0aGlzLnZlcnRpY2FsXyA9ICEhYm9vbDtcblxuICAgIGlmICh0aGlzLnZlcnRpY2FsXykge1xuICAgICAgdGhpcy5hZGRDbGFzcygndmpzLXNsaWRlci12ZXJ0aWNhbCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFkZENsYXNzKCd2anMtc2xpZGVyLWhvcml6b250YWwnKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIFNsaWRlcjtcbn0oQ29tcG9uZW50KTtcblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdTbGlkZXInLCBTbGlkZXIpO1xuXG4vKipcbiAqIEBmaWxlIGxvYWQtcHJvZ3Jlc3MtYmFyLmpzXG4gKi9cbi8qKlxuICogU2hvd3MgbG9hZGluZyBwcm9ncmVzc1xuICpcbiAqIEBleHRlbmRzIENvbXBvbmVudFxuICovXG5cbnZhciBMb2FkUHJvZ3Jlc3NCYXIgPSBmdW5jdGlvbiAoX0NvbXBvbmVudCkge1xuICBpbmhlcml0cyhMb2FkUHJvZ3Jlc3NCYXIsIF9Db21wb25lbnQpO1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7UGxheWVyfSBwbGF5ZXJcbiAgICogICAgICAgIFRoZSBgUGxheWVyYCB0aGF0IHRoaXMgY2xhc3Mgc2hvdWxkIGJlIGF0dGFjaGVkIHRvLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgICAgICBUaGUga2V5L3ZhbHVlIHN0b3JlIG9mIHBsYXllciBvcHRpb25zLlxuICAgKi9cbiAgZnVuY3Rpb24gTG9hZFByb2dyZXNzQmFyKHBsYXllciwgb3B0aW9ucykge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIExvYWRQcm9ncmVzc0Jhcik7XG5cbiAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9Db21wb25lbnQuY2FsbCh0aGlzLCBwbGF5ZXIsIG9wdGlvbnMpKTtcblxuICAgIF90aGlzLnBhcnRFbHNfID0gW107XG4gICAgX3RoaXMub24ocGxheWVyLCAncHJvZ3Jlc3MnLCBfdGhpcy51cGRhdGUpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgdGhlIGBDb21wb25lbnRgJ3MgRE9NIGVsZW1lbnRcbiAgICpcbiAgICogQHJldHVybiB7RWxlbWVudH1cbiAgICogICAgICAgICBUaGUgZWxlbWVudCB0aGF0IHdhcyBjcmVhdGVkLlxuICAgKi9cblxuXG4gIExvYWRQcm9ncmVzc0Jhci5wcm90b3R5cGUuY3JlYXRlRWwgPSBmdW5jdGlvbiBjcmVhdGVFbCQkMSgpIHtcbiAgICByZXR1cm4gX0NvbXBvbmVudC5wcm90b3R5cGUuY3JlYXRlRWwuY2FsbCh0aGlzLCAnZGl2Jywge1xuICAgICAgY2xhc3NOYW1lOiAndmpzLWxvYWQtcHJvZ3Jlc3MnLFxuICAgICAgaW5uZXJIVE1MOiAnPHNwYW4gY2xhc3M9XCJ2anMtY29udHJvbC10ZXh0XCI+PHNwYW4+JyArIHRoaXMubG9jYWxpemUoJ0xvYWRlZCcpICsgJzwvc3Bhbj46IDAlPC9zcGFuPidcbiAgICB9KTtcbiAgfTtcblxuICBMb2FkUHJvZ3Jlc3NCYXIucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiBkaXNwb3NlKCkge1xuICAgIHRoaXMucGFydEVsc18gPSBudWxsO1xuXG4gICAgX0NvbXBvbmVudC5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBVcGRhdGUgcHJvZ3Jlc3MgYmFyXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IFtldmVudF1cbiAgICogICAgICAgIFRoZSBgcHJvZ3Jlc3NgIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgZnVuY3Rpb24gdG8gcnVuLlxuICAgKlxuICAgKiBAbGlzdGVucyBQbGF5ZXIjcHJvZ3Jlc3NcbiAgICovXG5cblxuICBMb2FkUHJvZ3Jlc3NCYXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZShldmVudCkge1xuICAgIHZhciBidWZmZXJlZCA9IHRoaXMucGxheWVyXy5idWZmZXJlZCgpO1xuICAgIHZhciBkdXJhdGlvbiA9IHRoaXMucGxheWVyXy5kdXJhdGlvbigpO1xuICAgIHZhciBidWZmZXJlZEVuZCA9IHRoaXMucGxheWVyXy5idWZmZXJlZEVuZCgpO1xuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMucGFydEVsc187XG5cbiAgICAvLyBnZXQgdGhlIHBlcmNlbnQgd2lkdGggb2YgYSB0aW1lIGNvbXBhcmVkIHRvIHRoZSB0b3RhbCBlbmRcbiAgICB2YXIgcGVyY2VudGlmeSA9IGZ1bmN0aW9uIHBlcmNlbnRpZnkodGltZSwgZW5kKSB7XG4gICAgICAvLyBubyBOYU5cbiAgICAgIHZhciBwZXJjZW50ID0gdGltZSAvIGVuZCB8fCAwO1xuXG4gICAgICByZXR1cm4gKHBlcmNlbnQgPj0gMSA/IDEgOiBwZXJjZW50KSAqIDEwMCArICclJztcbiAgICB9O1xuXG4gICAgLy8gdXBkYXRlIHRoZSB3aWR0aCBvZiB0aGUgcHJvZ3Jlc3MgYmFyXG4gICAgdGhpcy5lbF8uc3R5bGUud2lkdGggPSBwZXJjZW50aWZ5KGJ1ZmZlcmVkRW5kLCBkdXJhdGlvbik7XG5cbiAgICAvLyBhZGQgY2hpbGQgZWxlbWVudHMgdG8gcmVwcmVzZW50IHRoZSBpbmRpdmlkdWFsIGJ1ZmZlcmVkIHRpbWUgcmFuZ2VzXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBidWZmZXJlZC5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHN0YXJ0ID0gYnVmZmVyZWQuc3RhcnQoaSk7XG4gICAgICB2YXIgZW5kID0gYnVmZmVyZWQuZW5kKGkpO1xuICAgICAgdmFyIHBhcnQgPSBjaGlsZHJlbltpXTtcblxuICAgICAgaWYgKCFwYXJ0KSB7XG4gICAgICAgIHBhcnQgPSB0aGlzLmVsXy5hcHBlbmRDaGlsZChjcmVhdGVFbCgpKTtcbiAgICAgICAgY2hpbGRyZW5baV0gPSBwYXJ0O1xuICAgICAgfVxuXG4gICAgICAvLyBzZXQgdGhlIHBlcmNlbnQgYmFzZWQgb24gdGhlIHdpZHRoIG9mIHRoZSBwcm9ncmVzcyBiYXIgKGJ1ZmZlcmVkRW5kKVxuICAgICAgcGFydC5zdHlsZS5sZWZ0ID0gcGVyY2VudGlmeShzdGFydCwgYnVmZmVyZWRFbmQpO1xuICAgICAgcGFydC5zdHlsZS53aWR0aCA9IHBlcmNlbnRpZnkoZW5kIC0gc3RhcnQsIGJ1ZmZlcmVkRW5kKTtcbiAgICB9XG5cbiAgICAvLyByZW1vdmUgdW51c2VkIGJ1ZmZlcmVkIHJhbmdlIGVsZW1lbnRzXG4gICAgZm9yICh2YXIgX2kgPSBjaGlsZHJlbi5sZW5ndGg7IF9pID4gYnVmZmVyZWQubGVuZ3RoOyBfaS0tKSB7XG4gICAgICB0aGlzLmVsXy5yZW1vdmVDaGlsZChjaGlsZHJlbltfaSAtIDFdKTtcbiAgICB9XG4gICAgY2hpbGRyZW4ubGVuZ3RoID0gYnVmZmVyZWQubGVuZ3RoO1xuICB9O1xuXG4gIHJldHVybiBMb2FkUHJvZ3Jlc3NCYXI7XG59KENvbXBvbmVudCk7XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnTG9hZFByb2dyZXNzQmFyJywgTG9hZFByb2dyZXNzQmFyKTtcblxuLyoqXG4gKiBAZmlsZSB0aW1lLXRvb2x0aXAuanNcbiAqL1xuLyoqXG4gKiBUaW1lIHRvb2x0aXBzIGRpc3BsYXkgYSB0aW1lIGFib3ZlIHRoZSBwcm9ncmVzcyBiYXIuXG4gKlxuICogQGV4dGVuZHMgQ29tcG9uZW50XG4gKi9cblxudmFyIFRpbWVUb29sdGlwID0gZnVuY3Rpb24gKF9Db21wb25lbnQpIHtcbiAgaW5oZXJpdHMoVGltZVRvb2x0aXAsIF9Db21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIFRpbWVUb29sdGlwKCkge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFRpbWVUb29sdGlwKTtcbiAgICByZXR1cm4gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfQ29tcG9uZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSB0aGUgdGltZSB0b29sdGlwIERPTSBlbGVtZW50XG4gICAqXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9XG4gICAqICAgICAgICAgVGhlIGVsZW1lbnQgdGhhdCB3YXMgY3JlYXRlZC5cbiAgICovXG4gIFRpbWVUb29sdGlwLnByb3RvdHlwZS5jcmVhdGVFbCA9IGZ1bmN0aW9uIGNyZWF0ZUVsJCQxKCkge1xuICAgIHJldHVybiBfQ29tcG9uZW50LnByb3RvdHlwZS5jcmVhdGVFbC5jYWxsKHRoaXMsICdkaXYnLCB7XG4gICAgICBjbGFzc05hbWU6ICd2anMtdGltZS10b29sdGlwJ1xuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBwb3NpdGlvbiBvZiB0aGUgdGltZSB0b29sdGlwIHJlbGF0aXZlIHRvIHRoZSBgU2Vla0JhcmAuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzZWVrQmFyUmVjdFxuICAgKiAgICAgICAgVGhlIGBDbGllbnRSZWN0YCBmb3IgdGhlIHtAbGluayBTZWVrQmFyfSBlbGVtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gc2Vla0JhclBvaW50XG4gICAqICAgICAgICBBIG51bWJlciBmcm9tIDAgdG8gMSwgcmVwcmVzZW50aW5nIGEgaG9yaXpvbnRhbCByZWZlcmVuY2UgcG9pbnRcbiAgICogICAgICAgIGZyb20gdGhlIGxlZnQgZWRnZSBvZiB0aGUge0BsaW5rIFNlZWtCYXJ9XG4gICAqL1xuXG5cbiAgVGltZVRvb2x0aXAucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZShzZWVrQmFyUmVjdCwgc2Vla0JhclBvaW50LCBjb250ZW50KSB7XG4gICAgdmFyIHRvb2x0aXBSZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KHRoaXMuZWxfKTtcbiAgICB2YXIgcGxheWVyUmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdCh0aGlzLnBsYXllcl8uZWwoKSk7XG4gICAgdmFyIHNlZWtCYXJQb2ludFB4ID0gc2Vla0JhclJlY3Qud2lkdGggKiBzZWVrQmFyUG9pbnQ7XG5cbiAgICAvLyBkbyBub3RoaW5nIGlmIGVpdGhlciByZWN0IGlzbid0IGF2YWlsYWJsZVxuICAgIC8vIGZvciBleGFtcGxlLCBpZiB0aGUgcGxheWVyIGlzbid0IGluIHRoZSBET00gZm9yIHRlc3RpbmdcbiAgICBpZiAoIXBsYXllclJlY3QgfHwgIXRvb2x0aXBSZWN0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gVGhpcyBpcyB0aGUgc3BhY2UgbGVmdCBvZiB0aGUgYHNlZWtCYXJQb2ludGAgYXZhaWxhYmxlIHdpdGhpbiB0aGUgYm91bmRzXG4gICAgLy8gb2YgdGhlIHBsYXllci4gV2UgY2FsY3VsYXRlIGFueSBnYXAgYmV0d2VlbiB0aGUgbGVmdCBlZGdlIG9mIHRoZSBwbGF5ZXJcbiAgICAvLyBhbmQgdGhlIGxlZnQgZWRnZSBvZiB0aGUgYFNlZWtCYXJgIGFuZCBhZGQgdGhlIG51bWJlciBvZiBwaXhlbHMgaW4gdGhlXG4gICAgLy8gYFNlZWtCYXJgIGJlZm9yZSBoaXR0aW5nIHRoZSBgc2Vla0JhclBvaW50YFxuICAgIHZhciBzcGFjZUxlZnRPZlBvaW50ID0gc2Vla0JhclJlY3QubGVmdCAtIHBsYXllclJlY3QubGVmdCArIHNlZWtCYXJQb2ludFB4O1xuXG4gICAgLy8gVGhpcyBpcyB0aGUgc3BhY2UgcmlnaHQgb2YgdGhlIGBzZWVrQmFyUG9pbnRgIGF2YWlsYWJsZSB3aXRoaW4gdGhlIGJvdW5kc1xuICAgIC8vIG9mIHRoZSBwbGF5ZXIuIFdlIGNhbGN1bGF0ZSB0aGUgbnVtYmVyIG9mIHBpeGVscyBmcm9tIHRoZSBgc2Vla0JhclBvaW50YFxuICAgIC8vIHRvIHRoZSByaWdodCBlZGdlIG9mIHRoZSBgU2Vla0JhcmAgYW5kIGFkZCB0byB0aGF0IGFueSBnYXAgYmV0d2VlbiB0aGVcbiAgICAvLyByaWdodCBlZGdlIG9mIHRoZSBgU2Vla0JhcmAgYW5kIHRoZSBwbGF5ZXIuXG4gICAgdmFyIHNwYWNlUmlnaHRPZlBvaW50ID0gc2Vla0JhclJlY3Qud2lkdGggLSBzZWVrQmFyUG9pbnRQeCArIChwbGF5ZXJSZWN0LnJpZ2h0IC0gc2Vla0JhclJlY3QucmlnaHQpO1xuXG4gICAgLy8gVGhpcyBpcyB0aGUgbnVtYmVyIG9mIHBpeGVscyBieSB3aGljaCB0aGUgdG9vbHRpcCB3aWxsIG5lZWQgdG8gYmUgcHVsbGVkXG4gICAgLy8gZnVydGhlciB0byB0aGUgcmlnaHQgdG8gY2VudGVyIGl0IG92ZXIgdGhlIGBzZWVrQmFyUG9pbnRgLlxuICAgIHZhciBwdWxsVG9vbHRpcEJ5ID0gdG9vbHRpcFJlY3Qud2lkdGggLyAyO1xuXG4gICAgLy8gQWRqdXN0IHRoZSBgcHVsbFRvb2x0aXBCeWAgZGlzdGFuY2UgdG8gdGhlIGxlZnQgb3IgcmlnaHQgZGVwZW5kaW5nIG9uXG4gICAgLy8gdGhlIHJlc3VsdHMgb2YgdGhlIHNwYWNlIGNhbGN1bGF0aW9ucyBhYm92ZS5cbiAgICBpZiAoc3BhY2VMZWZ0T2ZQb2ludCA8IHB1bGxUb29sdGlwQnkpIHtcbiAgICAgIHB1bGxUb29sdGlwQnkgKz0gcHVsbFRvb2x0aXBCeSAtIHNwYWNlTGVmdE9mUG9pbnQ7XG4gICAgfSBlbHNlIGlmIChzcGFjZVJpZ2h0T2ZQb2ludCA8IHB1bGxUb29sdGlwQnkpIHtcbiAgICAgIHB1bGxUb29sdGlwQnkgPSBzcGFjZVJpZ2h0T2ZQb2ludDtcbiAgICB9XG5cbiAgICAvLyBEdWUgdG8gdGhlIGltcHJlY2lzaW9uIG9mIGRlY2ltYWwvcmF0aW8gYmFzZWQgY2FsY3VsYXRpb25zIGFuZCB2YXJ5aW5nXG4gICAgLy8gcm91bmRpbmcgYmVoYXZpb3JzLCB0aGVyZSBhcmUgY2FzZXMgd2hlcmUgdGhlIHNwYWNpbmcgYWRqdXN0bWVudCBpcyBvZmZcbiAgICAvLyBieSBhIHBpeGVsIG9yIHR3by4gVGhpcyBhZGRzIGluc3VyYW5jZSB0byB0aGVzZSBjYWxjdWxhdGlvbnMuXG4gICAgaWYgKHB1bGxUb29sdGlwQnkgPCAwKSB7XG4gICAgICBwdWxsVG9vbHRpcEJ5ID0gMDtcbiAgICB9IGVsc2UgaWYgKHB1bGxUb29sdGlwQnkgPiB0b29sdGlwUmVjdC53aWR0aCkge1xuICAgICAgcHVsbFRvb2x0aXBCeSA9IHRvb2x0aXBSZWN0LndpZHRoO1xuICAgIH1cblxuICAgIHRoaXMuZWxfLnN0eWxlLnJpZ2h0ID0gJy0nICsgcHVsbFRvb2x0aXBCeSArICdweCc7XG4gICAgdGV4dENvbnRlbnQodGhpcy5lbF8sIGNvbnRlbnQpO1xuICB9O1xuXG4gIHJldHVybiBUaW1lVG9vbHRpcDtcbn0oQ29tcG9uZW50KTtcblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdUaW1lVG9vbHRpcCcsIFRpbWVUb29sdGlwKTtcblxuLyoqXG4gKiBAZmlsZSBwbGF5LXByb2dyZXNzLWJhci5qc1xuICovXG4vKipcbiAqIFVzZWQgYnkge0BsaW5rIFNlZWtCYXJ9IHRvIGRpc3BsYXkgbWVkaWEgcGxheWJhY2sgcHJvZ3Jlc3MgYXMgcGFydCBvZiB0aGVcbiAqIHtAbGluayBQcm9ncmVzc0NvbnRyb2x9LlxuICpcbiAqIEBleHRlbmRzIENvbXBvbmVudFxuICovXG5cbnZhciBQbGF5UHJvZ3Jlc3NCYXIgPSBmdW5jdGlvbiAoX0NvbXBvbmVudCkge1xuICBpbmhlcml0cyhQbGF5UHJvZ3Jlc3NCYXIsIF9Db21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIFBsYXlQcm9ncmVzc0JhcigpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBQbGF5UHJvZ3Jlc3NCYXIpO1xuICAgIHJldHVybiBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9Db21wb25lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIHRoZSB0aGUgRE9NIGVsZW1lbnQgZm9yIHRoaXMgY2xhc3MuXG4gICAqXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9XG4gICAqICAgICAgICAgVGhlIGVsZW1lbnQgdGhhdCB3YXMgY3JlYXRlZC5cbiAgICovXG4gIFBsYXlQcm9ncmVzc0Jhci5wcm90b3R5cGUuY3JlYXRlRWwgPSBmdW5jdGlvbiBjcmVhdGVFbCgpIHtcbiAgICByZXR1cm4gX0NvbXBvbmVudC5wcm90b3R5cGUuY3JlYXRlRWwuY2FsbCh0aGlzLCAnZGl2Jywge1xuICAgICAgY2xhc3NOYW1lOiAndmpzLXBsYXktcHJvZ3Jlc3MgdmpzLXNsaWRlci1iYXInLFxuICAgICAgaW5uZXJIVE1MOiAnPHNwYW4gY2xhc3M9XCJ2anMtY29udHJvbC10ZXh0XCI+PHNwYW4+JyArIHRoaXMubG9jYWxpemUoJ1Byb2dyZXNzJykgKyAnPC9zcGFuPjogMCU8L3NwYW4+J1xuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBFbnF1ZXVlcyB1cGRhdGVzIHRvIGl0cyBvd24gRE9NIGFzIHdlbGwgYXMgdGhlIERPTSBvZiBpdHNcbiAgICoge0BsaW5rIFRpbWVUb29sdGlwfSBjaGlsZC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHNlZWtCYXJSZWN0XG4gICAqICAgICAgICBUaGUgYENsaWVudFJlY3RgIGZvciB0aGUge0BsaW5rIFNlZWtCYXJ9IGVsZW1lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzZWVrQmFyUG9pbnRcbiAgICogICAgICAgIEEgbnVtYmVyIGZyb20gMCB0byAxLCByZXByZXNlbnRpbmcgYSBob3Jpem9udGFsIHJlZmVyZW5jZSBwb2ludFxuICAgKiAgICAgICAgZnJvbSB0aGUgbGVmdCBlZGdlIG9mIHRoZSB7QGxpbmsgU2Vla0Jhcn1cbiAgICovXG5cblxuICBQbGF5UHJvZ3Jlc3NCYXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZShzZWVrQmFyUmVjdCwgc2Vla0JhclBvaW50KSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAvLyBJZiB0aGVyZSBpcyBhbiBleGlzdGluZyByQUYgSUQsIGNhbmNlbCBpdCBzbyB3ZSBkb24ndCBvdmVyLXF1ZXVlLlxuICAgIGlmICh0aGlzLnJhZklkXykge1xuICAgICAgdGhpcy5jYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLnJhZklkXyk7XG4gICAgfVxuXG4gICAgdGhpcy5yYWZJZF8gPSB0aGlzLnJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgdGltZSA9IF90aGlzMi5wbGF5ZXJfLnNjcnViYmluZygpID8gX3RoaXMyLnBsYXllcl8uZ2V0Q2FjaGUoKS5jdXJyZW50VGltZSA6IF90aGlzMi5wbGF5ZXJfLmN1cnJlbnRUaW1lKCk7XG5cbiAgICAgIHZhciBjb250ZW50ID0gZm9ybWF0VGltZSh0aW1lLCBfdGhpczIucGxheWVyXy5kdXJhdGlvbigpKTtcbiAgICAgIHZhciB0aW1lVG9vbHRpcCA9IF90aGlzMi5nZXRDaGlsZCgndGltZVRvb2x0aXAnKTtcblxuICAgICAgaWYgKHRpbWVUb29sdGlwKSB7XG4gICAgICAgIHRpbWVUb29sdGlwLnVwZGF0ZShzZWVrQmFyUmVjdCwgc2Vla0JhclBvaW50LCBjb250ZW50KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4gUGxheVByb2dyZXNzQmFyO1xufShDb21wb25lbnQpO1xuXG4vKipcbiAqIERlZmF1bHQgb3B0aW9ucyBmb3Ige0BsaW5rIFBsYXlQcm9ncmVzc0Jhcn0uXG4gKlxuICogQHR5cGUge09iamVjdH1cbiAqIEBwcml2YXRlXG4gKi9cblxuXG5QbGF5UHJvZ3Jlc3NCYXIucHJvdG90eXBlLm9wdGlvbnNfID0ge1xuICBjaGlsZHJlbjogW11cbn07XG5cbi8vIFRpbWUgdG9vbHRpcHMgc2hvdWxkIG5vdCBiZSBhZGRlZCB0byBhIHBsYXllciBvbiBtb2JpbGUgZGV2aWNlcyBvciBJRThcbmlmICgoIUlFX1ZFUlNJT04gfHwgSUVfVkVSU0lPTiA+IDgpICYmICFJU19JT1MgJiYgIUlTX0FORFJPSUQpIHtcbiAgUGxheVByb2dyZXNzQmFyLnByb3RvdHlwZS5vcHRpb25zXy5jaGlsZHJlbi5wdXNoKCd0aW1lVG9vbHRpcCcpO1xufVxuXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ1BsYXlQcm9ncmVzc0JhcicsIFBsYXlQcm9ncmVzc0Jhcik7XG5cbi8qKlxuICogQGZpbGUgbW91c2UtdGltZS1kaXNwbGF5LmpzXG4gKi9cbi8qKlxuICogVGhlIHtAbGluayBNb3VzZVRpbWVEaXNwbGF5fSBjb21wb25lbnQgdHJhY2tzIG1vdXNlIG1vdmVtZW50IG92ZXIgdGhlXG4gKiB7QGxpbmsgUHJvZ3Jlc3NDb250cm9sfS4gSXQgZGlzcGxheXMgYW4gaW5kaWNhdG9yIGFuZCBhIHtAbGluayBUaW1lVG9vbHRpcH1cbiAqIGluZGljYXRpbmcgdGhlIHRpbWUgd2hpY2ggaXMgcmVwcmVzZW50ZWQgYnkgYSBnaXZlbiBwb2ludCBpbiB0aGVcbiAqIHtAbGluayBQcm9ncmVzc0NvbnRyb2x9LlxuICpcbiAqIEBleHRlbmRzIENvbXBvbmVudFxuICovXG5cbnZhciBNb3VzZVRpbWVEaXNwbGF5ID0gZnVuY3Rpb24gKF9Db21wb25lbnQpIHtcbiAgaW5oZXJpdHMoTW91c2VUaW1lRGlzcGxheSwgX0NvbXBvbmVudCk7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcy5cbiAgICpcbiAgICogQHBhcmFtIHtQbGF5ZXJ9IHBsYXllclxuICAgKiAgICAgICAgVGhlIHtAbGluayBQbGF5ZXJ9IHRoYXQgdGhpcyBjbGFzcyBzaG91bGQgYmUgYXR0YWNoZWQgdG8uXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICAgICAgIFRoZSBrZXkvdmFsdWUgc3RvcmUgb2YgcGxheWVyIG9wdGlvbnMuXG4gICAqL1xuICBmdW5jdGlvbiBNb3VzZVRpbWVEaXNwbGF5KHBsYXllciwgb3B0aW9ucykge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIE1vdXNlVGltZURpc3BsYXkpO1xuXG4gICAgdmFyIF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfQ29tcG9uZW50LmNhbGwodGhpcywgcGxheWVyLCBvcHRpb25zKSk7XG5cbiAgICBfdGhpcy51cGRhdGUgPSB0aHJvdHRsZShiaW5kKF90aGlzLCBfdGhpcy51cGRhdGUpLCAyNSk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSB0aGUgRE9NIGVsZW1lbnQgZm9yIHRoaXMgY2xhc3MuXG4gICAqXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9XG4gICAqICAgICAgICAgVGhlIGVsZW1lbnQgdGhhdCB3YXMgY3JlYXRlZC5cbiAgICovXG5cblxuICBNb3VzZVRpbWVEaXNwbGF5LnByb3RvdHlwZS5jcmVhdGVFbCA9IGZ1bmN0aW9uIGNyZWF0ZUVsKCkge1xuICAgIHJldHVybiBfQ29tcG9uZW50LnByb3RvdHlwZS5jcmVhdGVFbC5jYWxsKHRoaXMsICdkaXYnLCB7XG4gICAgICBjbGFzc05hbWU6ICd2anMtbW91c2UtZGlzcGxheSdcbiAgICB9KTtcbiAgfTtcblxuICAvKipcbiAgICogRW5xdWV1ZXMgdXBkYXRlcyB0byBpdHMgb3duIERPTSBhcyB3ZWxsIGFzIHRoZSBET00gb2YgaXRzXG4gICAqIHtAbGluayBUaW1lVG9vbHRpcH0gY2hpbGQuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzZWVrQmFyUmVjdFxuICAgKiAgICAgICAgVGhlIGBDbGllbnRSZWN0YCBmb3IgdGhlIHtAbGluayBTZWVrQmFyfSBlbGVtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gc2Vla0JhclBvaW50XG4gICAqICAgICAgICBBIG51bWJlciBmcm9tIDAgdG8gMSwgcmVwcmVzZW50aW5nIGEgaG9yaXpvbnRhbCByZWZlcmVuY2UgcG9pbnRcbiAgICogICAgICAgIGZyb20gdGhlIGxlZnQgZWRnZSBvZiB0aGUge0BsaW5rIFNlZWtCYXJ9XG4gICAqL1xuXG5cbiAgTW91c2VUaW1lRGlzcGxheS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlKHNlZWtCYXJSZWN0LCBzZWVrQmFyUG9pbnQpIHtcbiAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgIC8vIElmIHRoZXJlIGlzIGFuIGV4aXN0aW5nIHJBRiBJRCwgY2FuY2VsIGl0IHNvIHdlIGRvbid0IG92ZXItcXVldWUuXG4gICAgaWYgKHRoaXMucmFmSWRfKSB7XG4gICAgICB0aGlzLmNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMucmFmSWRfKTtcbiAgICB9XG5cbiAgICB0aGlzLnJhZklkXyA9IHRoaXMucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBkdXJhdGlvbiA9IF90aGlzMi5wbGF5ZXJfLmR1cmF0aW9uKCk7XG4gICAgICB2YXIgY29udGVudCA9IGZvcm1hdFRpbWUoc2Vla0JhclBvaW50ICogZHVyYXRpb24sIGR1cmF0aW9uKTtcblxuICAgICAgX3RoaXMyLmVsXy5zdHlsZS5sZWZ0ID0gc2Vla0JhclJlY3Qud2lkdGggKiBzZWVrQmFyUG9pbnQgKyAncHgnO1xuICAgICAgX3RoaXMyLmdldENoaWxkKCd0aW1lVG9vbHRpcCcpLnVwZGF0ZShzZWVrQmFyUmVjdCwgc2Vla0JhclBvaW50LCBjb250ZW50KTtcbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4gTW91c2VUaW1lRGlzcGxheTtcbn0oQ29tcG9uZW50KTtcblxuLyoqXG4gKiBEZWZhdWx0IG9wdGlvbnMgZm9yIGBNb3VzZVRpbWVEaXNwbGF5YFxuICpcbiAqIEB0eXBlIHtPYmplY3R9XG4gKiBAcHJpdmF0ZVxuICovXG5cblxuTW91c2VUaW1lRGlzcGxheS5wcm90b3R5cGUub3B0aW9uc18gPSB7XG4gIGNoaWxkcmVuOiBbJ3RpbWVUb29sdGlwJ11cbn07XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnTW91c2VUaW1lRGlzcGxheScsIE1vdXNlVGltZURpc3BsYXkpO1xuXG4vKipcbiAqIEBmaWxlIHNlZWstYmFyLmpzXG4gKi9cbi8vIFRoZSBudW1iZXIgb2Ygc2Vjb25kcyB0aGUgYHN0ZXAqYCBmdW5jdGlvbnMgbW92ZSB0aGUgdGltZWxpbmUuXG52YXIgU1RFUF9TRUNPTkRTID0gNTtcblxuLy8gVGhlIGludGVydmFsIGF0IHdoaWNoIHRoZSBiYXIgc2hvdWxkIHVwZGF0ZSBhcyBpdCBwcm9ncmVzc2VzLlxudmFyIFVQREFURV9SRUZSRVNIX0lOVEVSVkFMID0gMzA7XG5cbi8qKlxuICogU2VlayBiYXIgYW5kIGNvbnRhaW5lciBmb3IgdGhlIHByb2dyZXNzIGJhcnMuIFVzZXMge0BsaW5rIFBsYXlQcm9ncmVzc0Jhcn1cbiAqIGFzIGl0cyBgYmFyYC5cbiAqXG4gKiBAZXh0ZW5kcyBTbGlkZXJcbiAqL1xuXG52YXIgU2Vla0JhciA9IGZ1bmN0aW9uIChfU2xpZGVyKSB7XG4gIGluaGVyaXRzKFNlZWtCYXIsIF9TbGlkZXIpO1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7UGxheWVyfSBwbGF5ZXJcbiAgICogICAgICAgIFRoZSBgUGxheWVyYCB0aGF0IHRoaXMgY2xhc3Mgc2hvdWxkIGJlIGF0dGFjaGVkIHRvLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgICAgICBUaGUga2V5L3ZhbHVlIHN0b3JlIG9mIHBsYXllciBvcHRpb25zLlxuICAgKi9cbiAgZnVuY3Rpb24gU2Vla0JhcihwbGF5ZXIsIG9wdGlvbnMpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBTZWVrQmFyKTtcblxuICAgIHZhciBfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1NsaWRlci5jYWxsKHRoaXMsIHBsYXllciwgb3B0aW9ucykpO1xuXG4gICAgX3RoaXMuc2V0RXZlbnRIYW5kbGVyc18oKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgZXZlbnQgaGFuZGxlcnNcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBTZWVrQmFyLnByb3RvdHlwZS5zZXRFdmVudEhhbmRsZXJzXyA9IGZ1bmN0aW9uIHNldEV2ZW50SGFuZGxlcnNfKCkge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgdGhpcy51cGRhdGUgPSB0aHJvdHRsZShiaW5kKHRoaXMsIHRoaXMudXBkYXRlKSwgVVBEQVRFX1JFRlJFU0hfSU5URVJWQUwpO1xuXG4gICAgdGhpcy5vbih0aGlzLnBsYXllcl8sICd0aW1ldXBkYXRlJywgdGhpcy51cGRhdGUpO1xuICAgIHRoaXMub24odGhpcy5wbGF5ZXJfLCAnZW5kZWQnLCB0aGlzLmhhbmRsZUVuZGVkKTtcblxuICAgIC8vIHdoZW4gcGxheWluZywgbGV0J3MgZW5zdXJlIHdlIHNtb290aGx5IHVwZGF0ZSB0aGUgcGxheSBwcm9ncmVzcyBiYXJcbiAgICAvLyB2aWEgYW4gaW50ZXJ2YWxcbiAgICB0aGlzLnVwZGF0ZUludGVydmFsID0gbnVsbDtcblxuICAgIHRoaXMub24odGhpcy5wbGF5ZXJfLCBbJ3BsYXlpbmcnXSwgZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMyLmNsZWFySW50ZXJ2YWwoX3RoaXMyLnVwZGF0ZUludGVydmFsKTtcblxuICAgICAgX3RoaXMyLnVwZGF0ZUludGVydmFsID0gX3RoaXMyLnNldEludGVydmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMyLnJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgX3RoaXMyLnVwZGF0ZSgpO1xuICAgICAgICB9KTtcbiAgICAgIH0sIFVQREFURV9SRUZSRVNIX0lOVEVSVkFMKTtcbiAgICB9KTtcblxuICAgIHRoaXMub24odGhpcy5wbGF5ZXJfLCBbJ2VuZGVkJywgJ3BhdXNlJywgJ3dhaXRpbmcnXSwgZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMyLmNsZWFySW50ZXJ2YWwoX3RoaXMyLnVwZGF0ZUludGVydmFsKTtcbiAgICB9KTtcblxuICAgIHRoaXMub24odGhpcy5wbGF5ZXJfLCBbJ3RpbWV1cGRhdGUnLCAnZW5kZWQnXSwgdGhpcy51cGRhdGUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgdGhlIGBDb21wb25lbnRgJ3MgRE9NIGVsZW1lbnRcbiAgICpcbiAgICogQHJldHVybiB7RWxlbWVudH1cbiAgICogICAgICAgICBUaGUgZWxlbWVudCB0aGF0IHdhcyBjcmVhdGVkLlxuICAgKi9cblxuXG4gIFNlZWtCYXIucHJvdG90eXBlLmNyZWF0ZUVsID0gZnVuY3Rpb24gY3JlYXRlRWwkJDEoKSB7XG4gICAgcmV0dXJuIF9TbGlkZXIucHJvdG90eXBlLmNyZWF0ZUVsLmNhbGwodGhpcywgJ2RpdicsIHtcbiAgICAgIGNsYXNzTmFtZTogJ3Zqcy1wcm9ncmVzcy1ob2xkZXInXG4gICAgfSwge1xuICAgICAgJ2FyaWEtbGFiZWwnOiB0aGlzLmxvY2FsaXplKCdQcm9ncmVzcyBCYXInKVxuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIHVwZGF0ZXMgdGhlIHBsYXkgcHJvZ3Jlc3MgYmFyIGFuZCBhY2Nlc3NpYmxpdHlcbiAgICogYXR0cmlidXRlcyB0byB3aGF0ZXZlciBpcyBwYXNzZWQgaW4uXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBjdXJyZW50VGltZVxuICAgKiAgICAgICAgVGhlIGN1cnJlbnRUaW1lIHZhbHVlIHRoYXQgc2hvdWxkIGJlIHVzZWQgZm9yIGFjY2Vzc2libGl0eVxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gcGVyY2VudFxuICAgKiAgICAgICAgVGhlIHBlcmNlbnRhZ2UgYXMgYSBkZWNpbWFsIHRoYXQgdGhlIGJhciBzaG91bGQgYmUgZmlsbGVkIGZyb20gMC0xLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIFNlZWtCYXIucHJvdG90eXBlLnVwZGF0ZV8gPSBmdW5jdGlvbiB1cGRhdGVfKGN1cnJlbnRUaW1lLCBwZXJjZW50KSB7XG4gICAgdmFyIGR1cmF0aW9uID0gdGhpcy5wbGF5ZXJfLmR1cmF0aW9uKCk7XG5cbiAgICAvLyBtYWNoaW5lIHJlYWRhYmxlIHZhbHVlIG9mIHByb2dyZXNzIGJhciAocGVyY2VudGFnZSBjb21wbGV0ZSlcbiAgICB0aGlzLmVsXy5zZXRBdHRyaWJ1dGUoJ2FyaWEtdmFsdWVub3cnLCAocGVyY2VudCAqIDEwMCkudG9GaXhlZCgyKSk7XG5cbiAgICAvLyBodW1hbiByZWFkYWJsZSB2YWx1ZSBvZiBwcm9ncmVzcyBiYXIgKHRpbWUgY29tcGxldGUpXG4gICAgdGhpcy5lbF8uc2V0QXR0cmlidXRlKCdhcmlhLXZhbHVldGV4dCcsIHRoaXMubG9jYWxpemUoJ3Byb2dyZXNzIGJhciB0aW1pbmc6IGN1cnJlbnRUaW1lPXsxfSBkdXJhdGlvbj17Mn0nLCBbZm9ybWF0VGltZShjdXJyZW50VGltZSwgZHVyYXRpb24pLCBmb3JtYXRUaW1lKGR1cmF0aW9uLCBkdXJhdGlvbildLCAnezF9IG9mIHsyfScpKTtcblxuICAgIC8vIFVwZGF0ZSB0aGUgYFBsYXlQcm9ncmVzc0JhcmAuXG4gICAgdGhpcy5iYXIudXBkYXRlKGdldEJvdW5kaW5nQ2xpZW50UmVjdCh0aGlzLmVsXyksIHBlcmNlbnQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIHNlZWsgYmFyJ3MgVUkuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IFtldmVudF1cbiAgICogICAgICAgIFRoZSBgdGltZXVwZGF0ZWAgb3IgYGVuZGVkYCBldmVudCB0aGF0IGNhdXNlZCB0aGlzIHRvIHJ1bi5cbiAgICpcbiAgICogQGxpc3RlbnMgUGxheWVyI3RpbWV1cGRhdGVcbiAgICpcbiAgICogQHJldHVybnMge251bWJlcn1cbiAgICogICAgICAgICAgVGhlIGN1cnJlbnQgcGVyY2VudCBhdCBhIG51bWJlciBmcm9tIDAtMVxuICAgKi9cblxuXG4gIFNlZWtCYXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZShldmVudCkge1xuICAgIHZhciBwZXJjZW50ID0gX1NsaWRlci5wcm90b3R5cGUudXBkYXRlLmNhbGwodGhpcyk7XG5cbiAgICB0aGlzLnVwZGF0ZV8odGhpcy5nZXRDdXJyZW50VGltZV8oKSwgcGVyY2VudCk7XG4gICAgcmV0dXJuIHBlcmNlbnQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdmFsdWUgb2YgY3VycmVudCB0aW1lIGJ1dCBhbGxvd3MgZm9yIHNtb290aCBzY3J1YmJpbmcsXG4gICAqIHdoZW4gcGxheWVyIGNhbid0IGtlZXAgdXAuXG4gICAqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICogICAgICAgICBUaGUgY3VycmVudCB0aW1lIHZhbHVlIHRvIGRpc3BsYXlcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBTZWVrQmFyLnByb3RvdHlwZS5nZXRDdXJyZW50VGltZV8gPSBmdW5jdGlvbiBnZXRDdXJyZW50VGltZV8oKSB7XG4gICAgcmV0dXJuIHRoaXMucGxheWVyXy5zY3J1YmJpbmcoKSA/IHRoaXMucGxheWVyXy5nZXRDYWNoZSgpLmN1cnJlbnRUaW1lIDogdGhpcy5wbGF5ZXJfLmN1cnJlbnRUaW1lKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFdlIHdhbnQgdGhlIHNlZWsgYmFyIHRvIGJlIGZ1bGwgb24gZW5kZWRcbiAgICogbm8gbWF0dGVyIHdoYXQgdGhlIGFjdHVhbCBpbnRlcm5hbCB2YWx1ZXMgYXJlLiBzbyB3ZSBmb3JjZSBpdC5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gW2V2ZW50XVxuICAgKiAgICAgICAgVGhlIGB0aW1ldXBkYXRlYCBvciBgZW5kZWRgIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgdG8gcnVuLlxuICAgKlxuICAgKiBAbGlzdGVucyBQbGF5ZXIjZW5kZWRcbiAgICovXG5cblxuICBTZWVrQmFyLnByb3RvdHlwZS5oYW5kbGVFbmRlZCA9IGZ1bmN0aW9uIGhhbmRsZUVuZGVkKGV2ZW50KSB7XG4gICAgdGhpcy51cGRhdGVfKHRoaXMucGxheWVyXy5kdXJhdGlvbigpLCAxKTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSBwZXJjZW50YWdlIG9mIG1lZGlhIHBsYXllZCBzbyBmYXIuXG4gICAqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICogICAgICAgICBUaGUgcGVyY2VudGFnZSBvZiBtZWRpYSBwbGF5ZWQgc28gZmFyICgwIHRvIDEpLlxuICAgKi9cblxuXG4gIFNlZWtCYXIucHJvdG90eXBlLmdldFBlcmNlbnQgPSBmdW5jdGlvbiBnZXRQZXJjZW50KCkge1xuICAgIHZhciBwZXJjZW50ID0gdGhpcy5nZXRDdXJyZW50VGltZV8oKSAvIHRoaXMucGxheWVyXy5kdXJhdGlvbigpO1xuXG4gICAgcmV0dXJuIHBlcmNlbnQgPj0gMSA/IDEgOiBwZXJjZW50O1xuICB9O1xuXG4gIC8qKlxuICAgKiBIYW5kbGUgbW91c2UgZG93biBvbiBzZWVrIGJhclxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBldmVudFxuICAgKiAgICAgICAgVGhlIGBtb3VzZWRvd25gIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgdG8gcnVuLlxuICAgKlxuICAgKiBAbGlzdGVucyBtb3VzZWRvd25cbiAgICovXG5cblxuICBTZWVrQmFyLnByb3RvdHlwZS5oYW5kbGVNb3VzZURvd24gPSBmdW5jdGlvbiBoYW5kbGVNb3VzZURvd24oZXZlbnQpIHtcbiAgICBpZiAoIWlzU2luZ2xlTGVmdENsaWNrKGV2ZW50KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFN0b3AgZXZlbnQgcHJvcGFnYXRpb24gdG8gcHJldmVudCBkb3VibGUgZmlyZSBpbiBwcm9ncmVzcy1jb250cm9sLmpzXG4gICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgdGhpcy5wbGF5ZXJfLnNjcnViYmluZyh0cnVlKTtcblxuICAgIHRoaXMudmlkZW9XYXNQbGF5aW5nID0gIXRoaXMucGxheWVyXy5wYXVzZWQoKTtcbiAgICB0aGlzLnBsYXllcl8ucGF1c2UoKTtcblxuICAgIF9TbGlkZXIucHJvdG90eXBlLmhhbmRsZU1vdXNlRG93bi5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgfTtcblxuICAvKipcbiAgICogSGFuZGxlIG1vdXNlIG1vdmUgb24gc2VlayBiYXJcbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gZXZlbnRcbiAgICogICAgICAgIFRoZSBgbW91c2Vtb3ZlYCBldmVudCB0aGF0IGNhdXNlZCB0aGlzIHRvIHJ1bi5cbiAgICpcbiAgICogQGxpc3RlbnMgbW91c2Vtb3ZlXG4gICAqL1xuXG5cbiAgU2Vla0Jhci5wcm90b3R5cGUuaGFuZGxlTW91c2VNb3ZlID0gZnVuY3Rpb24gaGFuZGxlTW91c2VNb3ZlKGV2ZW50KSB7XG4gICAgaWYgKCFpc1NpbmdsZUxlZnRDbGljayhldmVudCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbmV3VGltZSA9IHRoaXMuY2FsY3VsYXRlRGlzdGFuY2UoZXZlbnQpICogdGhpcy5wbGF5ZXJfLmR1cmF0aW9uKCk7XG5cbiAgICAvLyBEb24ndCBsZXQgdmlkZW8gZW5kIHdoaWxlIHNjcnViYmluZy5cbiAgICBpZiAobmV3VGltZSA9PT0gdGhpcy5wbGF5ZXJfLmR1cmF0aW9uKCkpIHtcbiAgICAgIG5ld1RpbWUgPSBuZXdUaW1lIC0gMC4xO1xuICAgIH1cblxuICAgIC8vIFNldCBuZXcgdGltZSAodGVsbCBwbGF5ZXIgdG8gc2VlayB0byBuZXcgdGltZSlcbiAgICB0aGlzLnBsYXllcl8uY3VycmVudFRpbWUobmV3VGltZSk7XG4gIH07XG5cbiAgU2Vla0Jhci5wcm90b3R5cGUuZW5hYmxlID0gZnVuY3Rpb24gZW5hYmxlKCkge1xuICAgIF9TbGlkZXIucHJvdG90eXBlLmVuYWJsZS5jYWxsKHRoaXMpO1xuICAgIHZhciBtb3VzZVRpbWVEaXNwbGF5ID0gdGhpcy5nZXRDaGlsZCgnbW91c2VUaW1lRGlzcGxheScpO1xuXG4gICAgaWYgKCFtb3VzZVRpbWVEaXNwbGF5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbW91c2VUaW1lRGlzcGxheS5zaG93KCk7XG4gIH07XG5cbiAgU2Vla0Jhci5wcm90b3R5cGUuZGlzYWJsZSA9IGZ1bmN0aW9uIGRpc2FibGUoKSB7XG4gICAgX1NsaWRlci5wcm90b3R5cGUuZGlzYWJsZS5jYWxsKHRoaXMpO1xuICAgIHZhciBtb3VzZVRpbWVEaXNwbGF5ID0gdGhpcy5nZXRDaGlsZCgnbW91c2VUaW1lRGlzcGxheScpO1xuXG4gICAgaWYgKCFtb3VzZVRpbWVEaXNwbGF5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbW91c2VUaW1lRGlzcGxheS5oaWRlKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBtb3VzZSB1cCBvbiBzZWVrIGJhclxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBldmVudFxuICAgKiAgICAgICAgVGhlIGBtb3VzZXVwYCBldmVudCB0aGF0IGNhdXNlZCB0aGlzIHRvIHJ1bi5cbiAgICpcbiAgICogQGxpc3RlbnMgbW91c2V1cFxuICAgKi9cblxuXG4gIFNlZWtCYXIucHJvdG90eXBlLmhhbmRsZU1vdXNlVXAgPSBmdW5jdGlvbiBoYW5kbGVNb3VzZVVwKGV2ZW50KSB7XG4gICAgX1NsaWRlci5wcm90b3R5cGUuaGFuZGxlTW91c2VVcC5jYWxsKHRoaXMsIGV2ZW50KTtcblxuICAgIC8vIFN0b3AgZXZlbnQgcHJvcGFnYXRpb24gdG8gcHJldmVudCBkb3VibGUgZmlyZSBpbiBwcm9ncmVzcy1jb250cm9sLmpzXG4gICAgaWYgKGV2ZW50KSB7XG4gICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9XG4gICAgdGhpcy5wbGF5ZXJfLnNjcnViYmluZyhmYWxzZSk7XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyIHRpbWV1cGRhdGUgYmVjYXVzZSB3ZSdyZSBkb25lIHNlZWtpbmcgYW5kIHRoZSB0aW1lIGhhcyBjaGFuZ2VkLlxuICAgICAqIFRoaXMgaXMgcGFydGljdWxhcmx5IHVzZWZ1bCBmb3IgaWYgdGhlIHBsYXllciBpcyBwYXVzZWQgdG8gdGltZSB0aGUgdGltZSBkaXNwbGF5cy5cbiAgICAgKlxuICAgICAqIEBldmVudCBUZWNoI3RpbWV1cGRhdGVcbiAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gICAgICovXG4gICAgdGhpcy5wbGF5ZXJfLnRyaWdnZXIoeyB0eXBlOiAndGltZXVwZGF0ZScsIHRhcmdldDogdGhpcywgbWFudWFsbHlUcmlnZ2VyZWQ6IHRydWUgfSk7XG4gICAgaWYgKHRoaXMudmlkZW9XYXNQbGF5aW5nKSB7XG4gICAgICBzaWxlbmNlUHJvbWlzZSh0aGlzLnBsYXllcl8ucGxheSgpKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIE1vdmUgbW9yZSBxdWlja2x5IGZhc3QgZm9yd2FyZCBmb3Iga2V5Ym9hcmQtb25seSB1c2Vyc1xuICAgKi9cblxuXG4gIFNlZWtCYXIucHJvdG90eXBlLnN0ZXBGb3J3YXJkID0gZnVuY3Rpb24gc3RlcEZvcndhcmQoKSB7XG4gICAgdGhpcy5wbGF5ZXJfLmN1cnJlbnRUaW1lKHRoaXMucGxheWVyXy5jdXJyZW50VGltZSgpICsgU1RFUF9TRUNPTkRTKTtcbiAgfTtcblxuICAvKipcbiAgICogTW92ZSBtb3JlIHF1aWNrbHkgcmV3aW5kIGZvciBrZXlib2FyZC1vbmx5IHVzZXJzXG4gICAqL1xuXG5cbiAgU2Vla0Jhci5wcm90b3R5cGUuc3RlcEJhY2sgPSBmdW5jdGlvbiBzdGVwQmFjaygpIHtcbiAgICB0aGlzLnBsYXllcl8uY3VycmVudFRpbWUodGhpcy5wbGF5ZXJfLmN1cnJlbnRUaW1lKCkgLSBTVEVQX1NFQ09ORFMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUb2dnbGVzIHRoZSBwbGF5YmFjayBzdGF0ZSBvZiB0aGUgcGxheWVyXG4gICAqIFRoaXMgZ2V0cyBjYWxsZWQgd2hlbiBlbnRlciBvciBzcGFjZSBpcyB1c2VkIG9uIHRoZSBzZWVrYmFyXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IGV2ZW50XG4gICAqICAgICAgICBUaGUgYGtleWRvd25gIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgZnVuY3Rpb24gdG8gYmUgY2FsbGVkXG4gICAqXG4gICAqL1xuXG5cbiAgU2Vla0Jhci5wcm90b3R5cGUuaGFuZGxlQWN0aW9uID0gZnVuY3Rpb24gaGFuZGxlQWN0aW9uKGV2ZW50KSB7XG4gICAgaWYgKHRoaXMucGxheWVyXy5wYXVzZWQoKSkge1xuICAgICAgdGhpcy5wbGF5ZXJfLnBsYXkoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wbGF5ZXJfLnBhdXNlKCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBDYWxsZWQgd2hlbiB0aGlzIFNlZWtCYXIgaGFzIGZvY3VzIGFuZCBhIGtleSBnZXRzIHByZXNzZWQgZG93bi4gQnlcbiAgICogZGVmYXVsdCBpdCB3aWxsIGNhbGwgYHRoaXMuaGFuZGxlQWN0aW9uYCB3aGVuIHRoZSBrZXkgaXMgc3BhY2Ugb3IgZW50ZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IGV2ZW50XG4gICAqICAgICAgICBUaGUgYGtleWRvd25gIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgZnVuY3Rpb24gdG8gYmUgY2FsbGVkLlxuICAgKlxuICAgKiBAbGlzdGVucyBrZXlkb3duXG4gICAqL1xuXG5cbiAgU2Vla0Jhci5wcm90b3R5cGUuaGFuZGxlS2V5UHJlc3MgPSBmdW5jdGlvbiBoYW5kbGVLZXlQcmVzcyhldmVudCkge1xuXG4gICAgLy8gU3VwcG9ydCBTcGFjZSAoMzIpIG9yIEVudGVyICgxMykga2V5IG9wZXJhdGlvbiB0byBmaXJlIGEgY2xpY2sgZXZlbnRcbiAgICBpZiAoZXZlbnQud2hpY2ggPT09IDMyIHx8IGV2ZW50LndoaWNoID09PSAxMykge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHRoaXMuaGFuZGxlQWN0aW9uKGV2ZW50KTtcbiAgICB9IGVsc2UgaWYgKF9TbGlkZXIucHJvdG90eXBlLmhhbmRsZUtleVByZXNzKSB7XG5cbiAgICAgIC8vIFBhc3Mga2V5cHJlc3MgaGFuZGxpbmcgdXAgZm9yIHVuc3VwcG9ydGVkIGtleXNcbiAgICAgIF9TbGlkZXIucHJvdG90eXBlLmhhbmRsZUtleVByZXNzLmNhbGwodGhpcywgZXZlbnQpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gU2Vla0Jhcjtcbn0oU2xpZGVyKTtcblxuLyoqXG4gKiBEZWZhdWx0IG9wdGlvbnMgZm9yIHRoZSBgU2Vla0JhcmBcbiAqXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQHByaXZhdGVcbiAqL1xuXG5cblNlZWtCYXIucHJvdG90eXBlLm9wdGlvbnNfID0ge1xuICBjaGlsZHJlbjogWydsb2FkUHJvZ3Jlc3NCYXInLCAncGxheVByb2dyZXNzQmFyJ10sXG4gIGJhck5hbWU6ICdwbGF5UHJvZ3Jlc3NCYXInXG59O1xuXG4vLyBNb3VzZVRpbWVEaXNwbGF5IHRvb2x0aXBzIHNob3VsZCBub3QgYmUgYWRkZWQgdG8gYSBwbGF5ZXIgb24gbW9iaWxlIGRldmljZXMgb3IgSUU4XG5pZiAoKCFJRV9WRVJTSU9OIHx8IElFX1ZFUlNJT04gPiA4KSAmJiAhSVNfSU9TICYmICFJU19BTkRST0lEKSB7XG4gIFNlZWtCYXIucHJvdG90eXBlLm9wdGlvbnNfLmNoaWxkcmVuLnNwbGljZSgxLCAwLCAnbW91c2VUaW1lRGlzcGxheScpO1xufVxuXG4vKipcbiAqIENhbGwgdGhlIHVwZGF0ZSBldmVudCBmb3IgdGhpcyBTbGlkZXIgd2hlbiB0aGlzIGV2ZW50IGhhcHBlbnMgb24gdGhlIHBsYXllci5cbiAqXG4gKiBAdHlwZSB7c3RyaW5nfVxuICovXG5TZWVrQmFyLnByb3RvdHlwZS5wbGF5ZXJFdmVudCA9ICd0aW1ldXBkYXRlJztcblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdTZWVrQmFyJywgU2Vla0Jhcik7XG5cbi8qKlxuICogQGZpbGUgcHJvZ3Jlc3MtY29udHJvbC5qc1xuICovXG4vKipcbiAqIFRoZSBQcm9ncmVzcyBDb250cm9sIGNvbXBvbmVudCBjb250YWlucyB0aGUgc2VlayBiYXIsIGxvYWQgcHJvZ3Jlc3MsXG4gKiBhbmQgcGxheSBwcm9ncmVzcy5cbiAqXG4gKiBAZXh0ZW5kcyBDb21wb25lbnRcbiAqL1xuXG52YXIgUHJvZ3Jlc3NDb250cm9sID0gZnVuY3Rpb24gKF9Db21wb25lbnQpIHtcbiAgaW5oZXJpdHMoUHJvZ3Jlc3NDb250cm9sLCBfQ29tcG9uZW50KTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge1BsYXllcn0gcGxheWVyXG4gICAqICAgICAgICBUaGUgYFBsYXllcmAgdGhhdCB0aGlzIGNsYXNzIHNob3VsZCBiZSBhdHRhY2hlZCB0by5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgICAgICAgVGhlIGtleS92YWx1ZSBzdG9yZSBvZiBwbGF5ZXIgb3B0aW9ucy5cbiAgICovXG4gIGZ1bmN0aW9uIFByb2dyZXNzQ29udHJvbChwbGF5ZXIsIG9wdGlvbnMpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBQcm9ncmVzc0NvbnRyb2wpO1xuXG4gICAgdmFyIF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfQ29tcG9uZW50LmNhbGwodGhpcywgcGxheWVyLCBvcHRpb25zKSk7XG5cbiAgICBfdGhpcy5oYW5kbGVNb3VzZU1vdmUgPSB0aHJvdHRsZShiaW5kKF90aGlzLCBfdGhpcy5oYW5kbGVNb3VzZU1vdmUpLCAyNSk7XG4gICAgX3RoaXMudGhyb3R0bGVkSGFuZGxlTW91c2VTZWVrID0gdGhyb3R0bGUoYmluZChfdGhpcywgX3RoaXMuaGFuZGxlTW91c2VTZWVrKSwgMjUpO1xuXG4gICAgX3RoaXMuZW5hYmxlKCk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSB0aGUgYENvbXBvbmVudGAncyBET00gZWxlbWVudFxuICAgKlxuICAgKiBAcmV0dXJuIHtFbGVtZW50fVxuICAgKiAgICAgICAgIFRoZSBlbGVtZW50IHRoYXQgd2FzIGNyZWF0ZWQuXG4gICAqL1xuXG5cbiAgUHJvZ3Jlc3NDb250cm9sLnByb3RvdHlwZS5jcmVhdGVFbCA9IGZ1bmN0aW9uIGNyZWF0ZUVsJCQxKCkge1xuICAgIHJldHVybiBfQ29tcG9uZW50LnByb3RvdHlwZS5jcmVhdGVFbC5jYWxsKHRoaXMsICdkaXYnLCB7XG4gICAgICBjbGFzc05hbWU6ICd2anMtcHJvZ3Jlc3MtY29udHJvbCB2anMtY29udHJvbCdcbiAgICB9KTtcbiAgfTtcblxuICAvKipcbiAgICogV2hlbiB0aGUgbW91c2UgbW92ZXMgb3ZlciB0aGUgYFByb2dyZXNzQ29udHJvbGAsIHRoZSBwb2ludGVyIHBvc2l0aW9uXG4gICAqIGdldHMgcGFzc2VkIGRvd24gdG8gdGhlIGBNb3VzZVRpbWVEaXNwbGF5YCBjb21wb25lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IGV2ZW50XG4gICAqICAgICAgICBUaGUgYG1vdXNlbW92ZWAgZXZlbnQgdGhhdCBjYXVzZWQgdGhpcyBmdW5jdGlvbiB0byBydW4uXG4gICAqXG4gICAqIEBsaXN0ZW4gbW91c2Vtb3ZlXG4gICAqL1xuXG5cbiAgUHJvZ3Jlc3NDb250cm9sLnByb3RvdHlwZS5oYW5kbGVNb3VzZU1vdmUgPSBmdW5jdGlvbiBoYW5kbGVNb3VzZU1vdmUoZXZlbnQpIHtcbiAgICB2YXIgc2Vla0JhciA9IHRoaXMuZ2V0Q2hpbGQoJ3NlZWtCYXInKTtcblxuICAgIGlmIChzZWVrQmFyKSB7XG4gICAgICB2YXIgbW91c2VUaW1lRGlzcGxheSA9IHNlZWtCYXIuZ2V0Q2hpbGQoJ21vdXNlVGltZURpc3BsYXknKTtcbiAgICAgIHZhciBzZWVrQmFyRWwgPSBzZWVrQmFyLmVsKCk7XG4gICAgICB2YXIgc2Vla0JhclJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3Qoc2Vla0JhckVsKTtcbiAgICAgIHZhciBzZWVrQmFyUG9pbnQgPSBnZXRQb2ludGVyUG9zaXRpb24oc2Vla0JhckVsLCBldmVudCkueDtcblxuICAgICAgLy8gVGhlIGRlZmF1bHQgc2tpbiBoYXMgYSBnYXAgb24gZWl0aGVyIHNpZGUgb2YgdGhlIGBTZWVrQmFyYC4gVGhpcyBtZWFuc1xuICAgICAgLy8gdGhhdCBpdCdzIHBvc3NpYmxlIHRvIHRyaWdnZXIgdGhpcyBiZWhhdmlvciBvdXRzaWRlIHRoZSBib3VuZGFyaWVzIG9mXG4gICAgICAvLyB0aGUgYFNlZWtCYXJgLiBUaGlzIGVuc3VyZXMgd2Ugc3RheSB3aXRoaW4gaXQgYXQgYWxsIHRpbWVzLlxuICAgICAgaWYgKHNlZWtCYXJQb2ludCA+IDEpIHtcbiAgICAgICAgc2Vla0JhclBvaW50ID0gMTtcbiAgICAgIH0gZWxzZSBpZiAoc2Vla0JhclBvaW50IDwgMCkge1xuICAgICAgICBzZWVrQmFyUG9pbnQgPSAwO1xuICAgICAgfVxuXG4gICAgICBpZiAobW91c2VUaW1lRGlzcGxheSkge1xuICAgICAgICBtb3VzZVRpbWVEaXNwbGF5LnVwZGF0ZShzZWVrQmFyUmVjdCwgc2Vla0JhclBvaW50KTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEEgdGhyb3R0bGVkIHZlcnNpb24gb2YgdGhlIHtAbGluayBQcm9ncmVzc0NvbnRyb2wjaGFuZGxlTW91c2VTZWVrfSBsaXN0ZW5lci5cbiAgICpcbiAgICogQG1ldGhvZCBQcm9ncmVzc0NvbnRyb2wjdGhyb3R0bGVkSGFuZGxlTW91c2VTZWVrXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IGV2ZW50XG4gICAqICAgICAgICBUaGUgYG1vdXNlbW92ZWAgZXZlbnQgdGhhdCBjYXVzZWQgdGhpcyBmdW5jdGlvbiB0byBydW4uXG4gICAqXG4gICAqIEBsaXN0ZW4gbW91c2Vtb3ZlXG4gICAqIEBsaXN0ZW4gdG91Y2htb3ZlXG4gICAqL1xuXG4gIC8qKlxuICAgKiBIYW5kbGUgYG1vdXNlbW92ZWAgb3IgYHRvdWNobW92ZWAgZXZlbnRzIG9uIHRoZSBgUHJvZ3Jlc3NDb250cm9sYC5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gZXZlbnRcbiAgICogICAgICAgIGBtb3VzZWRvd25gIG9yIGB0b3VjaHN0YXJ0YCBldmVudCB0aGF0IHRyaWdnZXJlZCB0aGlzIGZ1bmN0aW9uXG4gICAqXG4gICAqIEBsaXN0ZW5zIG1vdXNlbW92ZVxuICAgKiBAbGlzdGVucyB0b3VjaG1vdmVcbiAgICovXG5cblxuICBQcm9ncmVzc0NvbnRyb2wucHJvdG90eXBlLmhhbmRsZU1vdXNlU2VlayA9IGZ1bmN0aW9uIGhhbmRsZU1vdXNlU2VlayhldmVudCkge1xuICAgIHZhciBzZWVrQmFyID0gdGhpcy5nZXRDaGlsZCgnc2Vla0JhcicpO1xuXG4gICAgaWYgKHNlZWtCYXIpIHtcbiAgICAgIHNlZWtCYXIuaGFuZGxlTW91c2VNb3ZlKGV2ZW50KTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEFyZSBjb250cm9scyBhcmUgY3VycmVudGx5IGVuYWJsZWQgZm9yIHRoaXMgcHJvZ3Jlc3MgY29udHJvbC5cbiAgICpcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICogICAgICAgICB0cnVlIGlmIGNvbnRyb2xzIGFyZSBlbmFibGVkLCBmYWxzZSBvdGhlcndpc2VcbiAgICovXG5cblxuICBQcm9ncmVzc0NvbnRyb2wucHJvdG90eXBlLmVuYWJsZWQgPSBmdW5jdGlvbiBlbmFibGVkKCkge1xuICAgIHJldHVybiB0aGlzLmVuYWJsZWRfO1xuICB9O1xuXG4gIC8qKlxuICAgKiBEaXNhYmxlIGFsbCBjb250cm9scyBvbiB0aGUgcHJvZ3Jlc3MgY29udHJvbCBhbmQgaXRzIGNoaWxkcmVuXG4gICAqL1xuXG5cbiAgUHJvZ3Jlc3NDb250cm9sLnByb3RvdHlwZS5kaXNhYmxlID0gZnVuY3Rpb24gZGlzYWJsZSgpIHtcbiAgICB0aGlzLmNoaWxkcmVuKCkuZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgIHJldHVybiBjaGlsZC5kaXNhYmxlICYmIGNoaWxkLmRpc2FibGUoKTtcbiAgICB9KTtcblxuICAgIGlmICghdGhpcy5lbmFibGVkKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLm9mZihbJ21vdXNlZG93bicsICd0b3VjaHN0YXJ0J10sIHRoaXMuaGFuZGxlTW91c2VEb3duKTtcbiAgICB0aGlzLm9mZih0aGlzLmVsXywgJ21vdXNlbW92ZScsIHRoaXMuaGFuZGxlTW91c2VNb3ZlKTtcbiAgICB0aGlzLmhhbmRsZU1vdXNlVXAoKTtcblxuICAgIHRoaXMuYWRkQ2xhc3MoJ2Rpc2FibGVkJyk7XG5cbiAgICB0aGlzLmVuYWJsZWRfID0gZmFsc2U7XG4gIH07XG5cbiAgLyoqXG4gICAqIEVuYWJsZSBhbGwgY29udHJvbHMgb24gdGhlIHByb2dyZXNzIGNvbnRyb2wgYW5kIGl0cyBjaGlsZHJlblxuICAgKi9cblxuXG4gIFByb2dyZXNzQ29udHJvbC5wcm90b3R5cGUuZW5hYmxlID0gZnVuY3Rpb24gZW5hYmxlKCkge1xuICAgIHRoaXMuY2hpbGRyZW4oKS5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgcmV0dXJuIGNoaWxkLmVuYWJsZSAmJiBjaGlsZC5lbmFibGUoKTtcbiAgICB9KTtcblxuICAgIGlmICh0aGlzLmVuYWJsZWQoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMub24oWydtb3VzZWRvd24nLCAndG91Y2hzdGFydCddLCB0aGlzLmhhbmRsZU1vdXNlRG93bik7XG4gICAgdGhpcy5vbih0aGlzLmVsXywgJ21vdXNlbW92ZScsIHRoaXMuaGFuZGxlTW91c2VNb3ZlKTtcbiAgICB0aGlzLnJlbW92ZUNsYXNzKCdkaXNhYmxlZCcpO1xuXG4gICAgdGhpcy5lbmFibGVkXyA9IHRydWU7XG4gIH07XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBgbW91c2Vkb3duYCBvciBgdG91Y2hzdGFydGAgZXZlbnRzIG9uIHRoZSBgUHJvZ3Jlc3NDb250cm9sYC5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gZXZlbnRcbiAgICogICAgICAgIGBtb3VzZWRvd25gIG9yIGB0b3VjaHN0YXJ0YCBldmVudCB0aGF0IHRyaWdnZXJlZCB0aGlzIGZ1bmN0aW9uXG4gICAqXG4gICAqIEBsaXN0ZW5zIG1vdXNlZG93blxuICAgKiBAbGlzdGVucyB0b3VjaHN0YXJ0XG4gICAqL1xuXG5cbiAgUHJvZ3Jlc3NDb250cm9sLnByb3RvdHlwZS5oYW5kbGVNb3VzZURvd24gPSBmdW5jdGlvbiBoYW5kbGVNb3VzZURvd24oZXZlbnQpIHtcbiAgICB2YXIgZG9jID0gdGhpcy5lbF8ub3duZXJEb2N1bWVudDtcbiAgICB2YXIgc2Vla0JhciA9IHRoaXMuZ2V0Q2hpbGQoJ3NlZWtCYXInKTtcblxuICAgIGlmIChzZWVrQmFyKSB7XG4gICAgICBzZWVrQmFyLmhhbmRsZU1vdXNlRG93bihldmVudCk7XG4gICAgfVxuXG4gICAgdGhpcy5vbihkb2MsICdtb3VzZW1vdmUnLCB0aGlzLnRocm90dGxlZEhhbmRsZU1vdXNlU2Vlayk7XG4gICAgdGhpcy5vbihkb2MsICd0b3VjaG1vdmUnLCB0aGlzLnRocm90dGxlZEhhbmRsZU1vdXNlU2Vlayk7XG4gICAgdGhpcy5vbihkb2MsICdtb3VzZXVwJywgdGhpcy5oYW5kbGVNb3VzZVVwKTtcbiAgICB0aGlzLm9uKGRvYywgJ3RvdWNoZW5kJywgdGhpcy5oYW5kbGVNb3VzZVVwKTtcbiAgfTtcblxuICAvKipcbiAgICogSGFuZGxlIGBtb3VzZXVwYCBvciBgdG91Y2hlbmRgIGV2ZW50cyBvbiB0aGUgYFByb2dyZXNzQ29udHJvbGAuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IGV2ZW50XG4gICAqICAgICAgICBgbW91c2V1cGAgb3IgYHRvdWNoZW5kYCBldmVudCB0aGF0IHRyaWdnZXJlZCB0aGlzIGZ1bmN0aW9uLlxuICAgKlxuICAgKiBAbGlzdGVucyB0b3VjaGVuZFxuICAgKiBAbGlzdGVucyBtb3VzZXVwXG4gICAqL1xuXG5cbiAgUHJvZ3Jlc3NDb250cm9sLnByb3RvdHlwZS5oYW5kbGVNb3VzZVVwID0gZnVuY3Rpb24gaGFuZGxlTW91c2VVcChldmVudCkge1xuICAgIHZhciBkb2MgPSB0aGlzLmVsXy5vd25lckRvY3VtZW50O1xuICAgIHZhciBzZWVrQmFyID0gdGhpcy5nZXRDaGlsZCgnc2Vla0JhcicpO1xuXG4gICAgaWYgKHNlZWtCYXIpIHtcbiAgICAgIHNlZWtCYXIuaGFuZGxlTW91c2VVcChldmVudCk7XG4gICAgfVxuXG4gICAgdGhpcy5vZmYoZG9jLCAnbW91c2Vtb3ZlJywgdGhpcy50aHJvdHRsZWRIYW5kbGVNb3VzZVNlZWspO1xuICAgIHRoaXMub2ZmKGRvYywgJ3RvdWNobW92ZScsIHRoaXMudGhyb3R0bGVkSGFuZGxlTW91c2VTZWVrKTtcbiAgICB0aGlzLm9mZihkb2MsICdtb3VzZXVwJywgdGhpcy5oYW5kbGVNb3VzZVVwKTtcbiAgICB0aGlzLm9mZihkb2MsICd0b3VjaGVuZCcsIHRoaXMuaGFuZGxlTW91c2VVcCk7XG4gIH07XG5cbiAgcmV0dXJuIFByb2dyZXNzQ29udHJvbDtcbn0oQ29tcG9uZW50KTtcblxuLyoqXG4gKiBEZWZhdWx0IG9wdGlvbnMgZm9yIGBQcm9ncmVzc0NvbnRyb2xgXG4gKlxuICogQHR5cGUge09iamVjdH1cbiAqIEBwcml2YXRlXG4gKi9cblxuXG5Qcm9ncmVzc0NvbnRyb2wucHJvdG90eXBlLm9wdGlvbnNfID0ge1xuICBjaGlsZHJlbjogWydzZWVrQmFyJ11cbn07XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnUHJvZ3Jlc3NDb250cm9sJywgUHJvZ3Jlc3NDb250cm9sKTtcblxuLyoqXG4gKiBAZmlsZSBmdWxsc2NyZWVuLXRvZ2dsZS5qc1xuICovXG4vKipcbiAqIFRvZ2dsZSBmdWxsc2NyZWVuIHZpZGVvXG4gKlxuICogQGV4dGVuZHMgQnV0dG9uXG4gKi9cblxudmFyIEZ1bGxzY3JlZW5Ub2dnbGUgPSBmdW5jdGlvbiAoX0J1dHRvbikge1xuICBpbmhlcml0cyhGdWxsc2NyZWVuVG9nZ2xlLCBfQnV0dG9uKTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge1BsYXllcn0gcGxheWVyXG4gICAqICAgICAgICBUaGUgYFBsYXllcmAgdGhhdCB0aGlzIGNsYXNzIHNob3VsZCBiZSBhdHRhY2hlZCB0by5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgICAgICAgVGhlIGtleS92YWx1ZSBzdG9yZSBvZiBwbGF5ZXIgb3B0aW9ucy5cbiAgICovXG4gIGZ1bmN0aW9uIEZ1bGxzY3JlZW5Ub2dnbGUocGxheWVyLCBvcHRpb25zKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgRnVsbHNjcmVlblRvZ2dsZSk7XG5cbiAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9CdXR0b24uY2FsbCh0aGlzLCBwbGF5ZXIsIG9wdGlvbnMpKTtcblxuICAgIF90aGlzLm9uKHBsYXllciwgJ2Z1bGxzY3JlZW5jaGFuZ2UnLCBfdGhpcy5oYW5kbGVGdWxsc2NyZWVuQ2hhbmdlKTtcblxuICAgIGlmIChkb2N1bWVudFtGdWxsc2NyZWVuQXBpLmZ1bGxzY3JlZW5FbmFibGVkXSA9PT0gZmFsc2UpIHtcbiAgICAgIF90aGlzLmRpc2FibGUoKTtcbiAgICB9XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEJ1aWxkcyB0aGUgZGVmYXVsdCBET00gYGNsYXNzTmFtZWAuXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICogICAgICAgICBUaGUgRE9NIGBjbGFzc05hbWVgIGZvciB0aGlzIG9iamVjdC5cbiAgICovXG5cblxuICBGdWxsc2NyZWVuVG9nZ2xlLnByb3RvdHlwZS5idWlsZENTU0NsYXNzID0gZnVuY3Rpb24gYnVpbGRDU1NDbGFzcygpIHtcbiAgICByZXR1cm4gJ3Zqcy1mdWxsc2NyZWVuLWNvbnRyb2wgJyArIF9CdXR0b24ucHJvdG90eXBlLmJ1aWxkQ1NTQ2xhc3MuY2FsbCh0aGlzKTtcbiAgfTtcblxuICAvKipcbiAgICogSGFuZGxlcyBmdWxsc2NyZWVuY2hhbmdlIG9uIHRoZSBwbGF5ZXIgYW5kIGNoYW5nZSBjb250cm9sIHRleHQgYWNjb3JkaW5nbHkuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IFtldmVudF1cbiAgICogICAgICAgIFRoZSB7QGxpbmsgUGxheWVyI2Z1bGxzY3JlZW5jaGFuZ2V9IGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgZnVuY3Rpb24gdG8gYmVcbiAgICogICAgICAgIGNhbGxlZC5cbiAgICpcbiAgICogQGxpc3RlbnMgUGxheWVyI2Z1bGxzY3JlZW5jaGFuZ2VcbiAgICovXG5cblxuICBGdWxsc2NyZWVuVG9nZ2xlLnByb3RvdHlwZS5oYW5kbGVGdWxsc2NyZWVuQ2hhbmdlID0gZnVuY3Rpb24gaGFuZGxlRnVsbHNjcmVlbkNoYW5nZShldmVudCkge1xuICAgIGlmICh0aGlzLnBsYXllcl8uaXNGdWxsc2NyZWVuKCkpIHtcbiAgICAgIHRoaXMuY29udHJvbFRleHQoJ05vbi1GdWxsc2NyZWVuJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY29udHJvbFRleHQoJ0Z1bGxzY3JlZW4nKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoaXMgZ2V0cyBjYWxsZWQgd2hlbiBhbiBgRnVsbHNjcmVlblRvZ2dsZWAgaXMgXCJjbGlja2VkXCIuIFNlZVxuICAgKiB7QGxpbmsgQ2xpY2thYmxlQ29tcG9uZW50fSBmb3IgbW9yZSBkZXRhaWxlZCBpbmZvcm1hdGlvbiBvbiB3aGF0IGEgY2xpY2sgY2FuIGJlLlxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBbZXZlbnRdXG4gICAqICAgICAgICBUaGUgYGtleWRvd25gLCBgdGFwYCwgb3IgYGNsaWNrYCBldmVudCB0aGF0IGNhdXNlZCB0aGlzIGZ1bmN0aW9uIHRvIGJlXG4gICAqICAgICAgICBjYWxsZWQuXG4gICAqXG4gICAqIEBsaXN0ZW5zIHRhcFxuICAgKiBAbGlzdGVucyBjbGlja1xuICAgKi9cblxuXG4gIEZ1bGxzY3JlZW5Ub2dnbGUucHJvdG90eXBlLmhhbmRsZUNsaWNrID0gZnVuY3Rpb24gaGFuZGxlQ2xpY2soZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMucGxheWVyXy5pc0Z1bGxzY3JlZW4oKSkge1xuICAgICAgdGhpcy5wbGF5ZXJfLnJlcXVlc3RGdWxsc2NyZWVuKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucGxheWVyXy5leGl0RnVsbHNjcmVlbigpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gRnVsbHNjcmVlblRvZ2dsZTtcbn0oQnV0dG9uKTtcblxuLyoqXG4gKiBUaGUgdGV4dCB0aGF0IHNob3VsZCBkaXNwbGF5IG92ZXIgdGhlIGBGdWxsc2NyZWVuVG9nZ2xlYHMgY29udHJvbHMuIEFkZGVkIGZvciBsb2NhbGl6YXRpb24uXG4gKlxuICogQHR5cGUge3N0cmluZ31cbiAqIEBwcml2YXRlXG4gKi9cblxuXG5GdWxsc2NyZWVuVG9nZ2xlLnByb3RvdHlwZS5jb250cm9sVGV4dF8gPSAnRnVsbHNjcmVlbic7XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnRnVsbHNjcmVlblRvZ2dsZScsIEZ1bGxzY3JlZW5Ub2dnbGUpO1xuXG4vKipcbiAqIENoZWNrIGlmIHZvbHVtZSBjb250cm9sIGlzIHN1cHBvcnRlZCBhbmQgaWYgaXQgaXNuJ3QgaGlkZSB0aGVcbiAqIGBDb21wb25lbnRgIHRoYXQgd2FzIHBhc3NlZCAgdXNpbmcgdGhlIGB2anMtaGlkZGVuYCBjbGFzcy5cbiAqXG4gKiBAcGFyYW0ge0NvbXBvbmVudH0gc2VsZlxuICogICAgICAgIFRoZSBjb21wb25lbnQgdGhhdCBzaG91bGQgYmUgaGlkZGVuIGlmIHZvbHVtZSBpcyB1bnN1cHBvcnRlZFxuICpcbiAqIEBwYXJhbSB7UGxheWVyfSBwbGF5ZXJcbiAqICAgICAgICBBIHJlZmVyZW5jZSB0byB0aGUgcGxheWVyXG4gKlxuICogQHByaXZhdGVcbiAqL1xudmFyIGNoZWNrVm9sdW1lU3VwcG9ydCA9IGZ1bmN0aW9uIGNoZWNrVm9sdW1lU3VwcG9ydChzZWxmLCBwbGF5ZXIpIHtcbiAgLy8gaGlkZSB2b2x1bWUgY29udHJvbHMgd2hlbiB0aGV5J3JlIG5vdCBzdXBwb3J0ZWQgYnkgdGhlIGN1cnJlbnQgdGVjaFxuICBpZiAocGxheWVyLnRlY2hfICYmICFwbGF5ZXIudGVjaF8uZmVhdHVyZXNWb2x1bWVDb250cm9sKSB7XG4gICAgc2VsZi5hZGRDbGFzcygndmpzLWhpZGRlbicpO1xuICB9XG5cbiAgc2VsZi5vbihwbGF5ZXIsICdsb2Fkc3RhcnQnLCBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFwbGF5ZXIudGVjaF8uZmVhdHVyZXNWb2x1bWVDb250cm9sKSB7XG4gICAgICBzZWxmLmFkZENsYXNzKCd2anMtaGlkZGVuJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNlbGYucmVtb3ZlQ2xhc3MoJ3Zqcy1oaWRkZW4nKTtcbiAgICB9XG4gIH0pO1xufTtcblxuLyoqXG4gKiBAZmlsZSB2b2x1bWUtbGV2ZWwuanNcbiAqL1xuLyoqXG4gKiBTaG93cyB2b2x1bWUgbGV2ZWxcbiAqXG4gKiBAZXh0ZW5kcyBDb21wb25lbnRcbiAqL1xuXG52YXIgVm9sdW1lTGV2ZWwgPSBmdW5jdGlvbiAoX0NvbXBvbmVudCkge1xuICBpbmhlcml0cyhWb2x1bWVMZXZlbCwgX0NvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gVm9sdW1lTGV2ZWwoKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgVm9sdW1lTGV2ZWwpO1xuICAgIHJldHVybiBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9Db21wb25lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIHRoZSBgQ29tcG9uZW50YCdzIERPTSBlbGVtZW50XG4gICAqXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9XG4gICAqICAgICAgICAgVGhlIGVsZW1lbnQgdGhhdCB3YXMgY3JlYXRlZC5cbiAgICovXG4gIFZvbHVtZUxldmVsLnByb3RvdHlwZS5jcmVhdGVFbCA9IGZ1bmN0aW9uIGNyZWF0ZUVsKCkge1xuICAgIHJldHVybiBfQ29tcG9uZW50LnByb3RvdHlwZS5jcmVhdGVFbC5jYWxsKHRoaXMsICdkaXYnLCB7XG4gICAgICBjbGFzc05hbWU6ICd2anMtdm9sdW1lLWxldmVsJyxcbiAgICAgIGlubmVySFRNTDogJzxzcGFuIGNsYXNzPVwidmpzLWNvbnRyb2wtdGV4dFwiPjwvc3Bhbj4nXG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIFZvbHVtZUxldmVsO1xufShDb21wb25lbnQpO1xuXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ1ZvbHVtZUxldmVsJywgVm9sdW1lTGV2ZWwpO1xuXG4vKipcbiAqIEBmaWxlIHZvbHVtZS1iYXIuanNcbiAqL1xuLy8gUmVxdWlyZWQgY2hpbGRyZW5cbi8qKlxuICogVGhlIGJhciB0aGF0IGNvbnRhaW5zIHRoZSB2b2x1bWUgbGV2ZWwgYW5kIGNhbiBiZSBjbGlja2VkIG9uIHRvIGFkanVzdCB0aGUgbGV2ZWxcbiAqXG4gKiBAZXh0ZW5kcyBTbGlkZXJcbiAqL1xuXG52YXIgVm9sdW1lQmFyID0gZnVuY3Rpb24gKF9TbGlkZXIpIHtcbiAgaW5oZXJpdHMoVm9sdW1lQmFyLCBfU2xpZGVyKTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge1BsYXllcn0gcGxheWVyXG4gICAqICAgICAgICBUaGUgYFBsYXllcmAgdGhhdCB0aGlzIGNsYXNzIHNob3VsZCBiZSBhdHRhY2hlZCB0by5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgICAgICAgVGhlIGtleS92YWx1ZSBzdG9yZSBvZiBwbGF5ZXIgb3B0aW9ucy5cbiAgICovXG4gIGZ1bmN0aW9uIFZvbHVtZUJhcihwbGF5ZXIsIG9wdGlvbnMpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBWb2x1bWVCYXIpO1xuXG4gICAgdmFyIF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfU2xpZGVyLmNhbGwodGhpcywgcGxheWVyLCBvcHRpb25zKSk7XG5cbiAgICBfdGhpcy5vbignc2xpZGVyYWN0aXZlJywgX3RoaXMudXBkYXRlTGFzdFZvbHVtZV8pO1xuICAgIF90aGlzLm9uKHBsYXllciwgJ3ZvbHVtZWNoYW5nZScsIF90aGlzLnVwZGF0ZUFSSUFBdHRyaWJ1dGVzKTtcbiAgICBwbGF5ZXIucmVhZHkoZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF90aGlzLnVwZGF0ZUFSSUFBdHRyaWJ1dGVzKCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSB0aGUgYENvbXBvbmVudGAncyBET00gZWxlbWVudFxuICAgKlxuICAgKiBAcmV0dXJuIHtFbGVtZW50fVxuICAgKiAgICAgICAgIFRoZSBlbGVtZW50IHRoYXQgd2FzIGNyZWF0ZWQuXG4gICAqL1xuXG5cbiAgVm9sdW1lQmFyLnByb3RvdHlwZS5jcmVhdGVFbCA9IGZ1bmN0aW9uIGNyZWF0ZUVsJCQxKCkge1xuICAgIHJldHVybiBfU2xpZGVyLnByb3RvdHlwZS5jcmVhdGVFbC5jYWxsKHRoaXMsICdkaXYnLCB7XG4gICAgICBjbGFzc05hbWU6ICd2anMtdm9sdW1lLWJhciB2anMtc2xpZGVyLWJhcidcbiAgICB9LCB7XG4gICAgICAnYXJpYS1sYWJlbCc6IHRoaXMubG9jYWxpemUoJ1ZvbHVtZSBMZXZlbCcpLFxuICAgICAgJ2FyaWEtbGl2ZSc6ICdwb2xpdGUnXG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBtb3VzZSBkb3duIG9uIHZvbHVtZSBiYXJcbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gZXZlbnRcbiAgICogICAgICAgIFRoZSBgbW91c2Vkb3duYCBldmVudCB0aGF0IGNhdXNlZCB0aGlzIHRvIHJ1bi5cbiAgICpcbiAgICogQGxpc3RlbnMgbW91c2Vkb3duXG4gICAqL1xuXG5cbiAgVm9sdW1lQmFyLnByb3RvdHlwZS5oYW5kbGVNb3VzZURvd24gPSBmdW5jdGlvbiBoYW5kbGVNb3VzZURvd24oZXZlbnQpIHtcbiAgICBpZiAoIWlzU2luZ2xlTGVmdENsaWNrKGV2ZW50KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIF9TbGlkZXIucHJvdG90eXBlLmhhbmRsZU1vdXNlRG93bi5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgfTtcblxuICAvKipcbiAgICogSGFuZGxlIG1vdmVtZW50IGV2ZW50cyBvbiB0aGUge0BsaW5rIFZvbHVtZU1lbnVCdXR0b259LlxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBldmVudFxuICAgKiAgICAgICAgVGhlIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgZnVuY3Rpb24gdG8gcnVuLlxuICAgKlxuICAgKiBAbGlzdGVucyBtb3VzZW1vdmVcbiAgICovXG5cblxuICBWb2x1bWVCYXIucHJvdG90eXBlLmhhbmRsZU1vdXNlTW92ZSA9IGZ1bmN0aW9uIGhhbmRsZU1vdXNlTW92ZShldmVudCkge1xuICAgIGlmICghaXNTaW5nbGVMZWZ0Q2xpY2soZXZlbnQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5jaGVja011dGVkKCk7XG4gICAgdGhpcy5wbGF5ZXJfLnZvbHVtZSh0aGlzLmNhbGN1bGF0ZURpc3RhbmNlKGV2ZW50KSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIElmIHRoZSBwbGF5ZXIgaXMgbXV0ZWQgdW5tdXRlIGl0LlxuICAgKi9cblxuXG4gIFZvbHVtZUJhci5wcm90b3R5cGUuY2hlY2tNdXRlZCA9IGZ1bmN0aW9uIGNoZWNrTXV0ZWQoKSB7XG4gICAgaWYgKHRoaXMucGxheWVyXy5tdXRlZCgpKSB7XG4gICAgICB0aGlzLnBsYXllcl8ubXV0ZWQoZmFsc2UpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogR2V0IHBlcmNlbnQgb2Ygdm9sdW1lIGxldmVsXG4gICAqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICogICAgICAgICBWb2x1bWUgbGV2ZWwgcGVyY2VudCBhcyBhIGRlY2ltYWwgbnVtYmVyLlxuICAgKi9cblxuXG4gIFZvbHVtZUJhci5wcm90b3R5cGUuZ2V0UGVyY2VudCA9IGZ1bmN0aW9uIGdldFBlcmNlbnQoKSB7XG4gICAgaWYgKHRoaXMucGxheWVyXy5tdXRlZCgpKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucGxheWVyXy52b2x1bWUoKTtcbiAgfTtcblxuICAvKipcbiAgICogSW5jcmVhc2Ugdm9sdW1lIGxldmVsIGZvciBrZXlib2FyZCB1c2Vyc1xuICAgKi9cblxuXG4gIFZvbHVtZUJhci5wcm90b3R5cGUuc3RlcEZvcndhcmQgPSBmdW5jdGlvbiBzdGVwRm9yd2FyZCgpIHtcbiAgICB0aGlzLmNoZWNrTXV0ZWQoKTtcbiAgICB0aGlzLnBsYXllcl8udm9sdW1lKHRoaXMucGxheWVyXy52b2x1bWUoKSArIDAuMSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIERlY3JlYXNlIHZvbHVtZSBsZXZlbCBmb3Iga2V5Ym9hcmQgdXNlcnNcbiAgICovXG5cblxuICBWb2x1bWVCYXIucHJvdG90eXBlLnN0ZXBCYWNrID0gZnVuY3Rpb24gc3RlcEJhY2soKSB7XG4gICAgdGhpcy5jaGVja011dGVkKCk7XG4gICAgdGhpcy5wbGF5ZXJfLnZvbHVtZSh0aGlzLnBsYXllcl8udm9sdW1lKCkgLSAwLjEpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBVcGRhdGUgQVJJQSBhY2Nlc3NpYmlsaXR5IGF0dHJpYnV0ZXNcbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gW2V2ZW50XVxuICAgKiAgICAgICAgVGhlIGB2b2x1bWVjaGFuZ2VgIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgZnVuY3Rpb24gdG8gcnVuLlxuICAgKlxuICAgKiBAbGlzdGVucyBQbGF5ZXIjdm9sdW1lY2hhbmdlXG4gICAqL1xuXG5cbiAgVm9sdW1lQmFyLnByb3RvdHlwZS51cGRhdGVBUklBQXR0cmlidXRlcyA9IGZ1bmN0aW9uIHVwZGF0ZUFSSUFBdHRyaWJ1dGVzKGV2ZW50KSB7XG4gICAgdmFyIGFyaWFWYWx1ZSA9IHRoaXMucGxheWVyXy5tdXRlZCgpID8gMCA6IHRoaXMudm9sdW1lQXNQZXJjZW50YWdlXygpO1xuXG4gICAgdGhpcy5lbF8uc2V0QXR0cmlidXRlKCdhcmlhLXZhbHVlbm93JywgYXJpYVZhbHVlKTtcbiAgICB0aGlzLmVsXy5zZXRBdHRyaWJ1dGUoJ2FyaWEtdmFsdWV0ZXh0JywgYXJpYVZhbHVlICsgJyUnKTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY3VycmVudCB2YWx1ZSBvZiB0aGUgcGxheWVyIHZvbHVtZSBhcyBhIHBlcmNlbnRhZ2VcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBWb2x1bWVCYXIucHJvdG90eXBlLnZvbHVtZUFzUGVyY2VudGFnZV8gPSBmdW5jdGlvbiB2b2x1bWVBc1BlcmNlbnRhZ2VfKCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKHRoaXMucGxheWVyXy52b2x1bWUoKSAqIDEwMCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFdoZW4gdXNlciBzdGFydHMgZHJhZ2dpbmcgdGhlIFZvbHVtZUJhciwgc3RvcmUgdGhlIHZvbHVtZSBhbmQgbGlzdGVuIGZvclxuICAgKiB0aGUgZW5kIG9mIHRoZSBkcmFnLiBXaGVuIHRoZSBkcmFnIGVuZHMsIGlmIHRoZSB2b2x1bWUgd2FzIHNldCB0byB6ZXJvLFxuICAgKiBzZXQgbGFzdFZvbHVtZSB0byB0aGUgc3RvcmVkIHZvbHVtZS5cbiAgICpcbiAgICogQGxpc3RlbnMgc2xpZGVyYWN0aXZlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgVm9sdW1lQmFyLnByb3RvdHlwZS51cGRhdGVMYXN0Vm9sdW1lXyA9IGZ1bmN0aW9uIHVwZGF0ZUxhc3RWb2x1bWVfKCkge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgdmFyIHZvbHVtZUJlZm9yZURyYWcgPSB0aGlzLnBsYXllcl8udm9sdW1lKCk7XG5cbiAgICB0aGlzLm9uZSgnc2xpZGVyaW5hY3RpdmUnLCBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoX3RoaXMyLnBsYXllcl8udm9sdW1lKCkgPT09IDApIHtcbiAgICAgICAgX3RoaXMyLnBsYXllcl8ubGFzdFZvbHVtZV8odm9sdW1lQmVmb3JlRHJhZyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIFZvbHVtZUJhcjtcbn0oU2xpZGVyKTtcblxuLyoqXG4gKiBEZWZhdWx0IG9wdGlvbnMgZm9yIHRoZSBgVm9sdW1lQmFyYFxuICpcbiAqIEB0eXBlIHtPYmplY3R9XG4gKiBAcHJpdmF0ZVxuICovXG5cblxuVm9sdW1lQmFyLnByb3RvdHlwZS5vcHRpb25zXyA9IHtcbiAgY2hpbGRyZW46IFsndm9sdW1lTGV2ZWwnXSxcbiAgYmFyTmFtZTogJ3ZvbHVtZUxldmVsJ1xufTtcblxuLyoqXG4gKiBDYWxsIHRoZSB1cGRhdGUgZXZlbnQgZm9yIHRoaXMgU2xpZGVyIHdoZW4gdGhpcyBldmVudCBoYXBwZW5zIG9uIHRoZSBwbGF5ZXIuXG4gKlxuICogQHR5cGUge3N0cmluZ31cbiAqL1xuVm9sdW1lQmFyLnByb3RvdHlwZS5wbGF5ZXJFdmVudCA9ICd2b2x1bWVjaGFuZ2UnO1xuXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ1ZvbHVtZUJhcicsIFZvbHVtZUJhcik7XG5cbi8qKlxuICogQGZpbGUgdm9sdW1lLWNvbnRyb2wuanNcbiAqL1xuLy8gUmVxdWlyZWQgY2hpbGRyZW5cbi8qKlxuICogVGhlIGNvbXBvbmVudCBmb3IgY29udHJvbGxpbmcgdGhlIHZvbHVtZSBsZXZlbFxuICpcbiAqIEBleHRlbmRzIENvbXBvbmVudFxuICovXG5cbnZhciBWb2x1bWVDb250cm9sID0gZnVuY3Rpb24gKF9Db21wb25lbnQpIHtcbiAgaW5oZXJpdHMoVm9sdW1lQ29udHJvbCwgX0NvbXBvbmVudCk7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcy5cbiAgICpcbiAgICogQHBhcmFtIHtQbGF5ZXJ9IHBsYXllclxuICAgKiAgICAgICAgVGhlIGBQbGF5ZXJgIHRoYXQgdGhpcyBjbGFzcyBzaG91bGQgYmUgYXR0YWNoZWQgdG8uXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV1cbiAgICogICAgICAgIFRoZSBrZXkvdmFsdWUgc3RvcmUgb2YgcGxheWVyIG9wdGlvbnMuXG4gICAqL1xuICBmdW5jdGlvbiBWb2x1bWVDb250cm9sKHBsYXllcikge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBWb2x1bWVDb250cm9sKTtcblxuICAgIG9wdGlvbnMudmVydGljYWwgPSBvcHRpb25zLnZlcnRpY2FsIHx8IGZhbHNlO1xuXG4gICAgLy8gUGFzcyB0aGUgdmVydGljYWwgb3B0aW9uIGRvd24gdG8gdGhlIFZvbHVtZUJhciBpZlxuICAgIC8vIHRoZSBWb2x1bWVCYXIgaXMgdHVybmVkIG9uLlxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy52b2x1bWVCYXIgPT09ICd1bmRlZmluZWQnIHx8IGlzUGxhaW4ob3B0aW9ucy52b2x1bWVCYXIpKSB7XG4gICAgICBvcHRpb25zLnZvbHVtZUJhciA9IG9wdGlvbnMudm9sdW1lQmFyIHx8IHt9O1xuICAgICAgb3B0aW9ucy52b2x1bWVCYXIudmVydGljYWwgPSBvcHRpb25zLnZlcnRpY2FsO1xuICAgIH1cblxuICAgIC8vIGhpZGUgdGhpcyBjb250cm9sIGlmIHZvbHVtZSBzdXBwb3J0IGlzIG1pc3NpbmdcbiAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9Db21wb25lbnQuY2FsbCh0aGlzLCBwbGF5ZXIsIG9wdGlvbnMpKTtcblxuICAgIGNoZWNrVm9sdW1lU3VwcG9ydChfdGhpcywgcGxheWVyKTtcblxuICAgIF90aGlzLnRocm90dGxlZEhhbmRsZU1vdXNlTW92ZSA9IHRocm90dGxlKGJpbmQoX3RoaXMsIF90aGlzLmhhbmRsZU1vdXNlTW92ZSksIDI1KTtcblxuICAgIF90aGlzLm9uKCdtb3VzZWRvd24nLCBfdGhpcy5oYW5kbGVNb3VzZURvd24pO1xuICAgIF90aGlzLm9uKCd0b3VjaHN0YXJ0JywgX3RoaXMuaGFuZGxlTW91c2VEb3duKTtcblxuICAgIC8vIHdoaWxlIHRoZSBzbGlkZXIgaXMgYWN0aXZlICh0aGUgbW91c2UgaGFzIGJlZW4gcHJlc3NlZCBkb3duIGFuZFxuICAgIC8vIGlzIGRyYWdnaW5nKSBvciBpbiBmb2N1cyB3ZSBkbyBub3Qgd2FudCB0byBoaWRlIHRoZSBWb2x1bWVCYXJcbiAgICBfdGhpcy5vbihfdGhpcy52b2x1bWVCYXIsIFsnZm9jdXMnLCAnc2xpZGVyYWN0aXZlJ10sIGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzLnZvbHVtZUJhci5hZGRDbGFzcygndmpzLXNsaWRlci1hY3RpdmUnKTtcbiAgICAgIF90aGlzLmFkZENsYXNzKCd2anMtc2xpZGVyLWFjdGl2ZScpO1xuICAgICAgX3RoaXMudHJpZ2dlcignc2xpZGVyYWN0aXZlJyk7XG4gICAgfSk7XG5cbiAgICBfdGhpcy5vbihfdGhpcy52b2x1bWVCYXIsIFsnYmx1cicsICdzbGlkZXJpbmFjdGl2ZSddLCBmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpcy52b2x1bWVCYXIucmVtb3ZlQ2xhc3MoJ3Zqcy1zbGlkZXItYWN0aXZlJyk7XG4gICAgICBfdGhpcy5yZW1vdmVDbGFzcygndmpzLXNsaWRlci1hY3RpdmUnKTtcbiAgICAgIF90aGlzLnRyaWdnZXIoJ3NsaWRlcmluYWN0aXZlJyk7XG4gICAgfSk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSB0aGUgYENvbXBvbmVudGAncyBET00gZWxlbWVudFxuICAgKlxuICAgKiBAcmV0dXJuIHtFbGVtZW50fVxuICAgKiAgICAgICAgIFRoZSBlbGVtZW50IHRoYXQgd2FzIGNyZWF0ZWQuXG4gICAqL1xuXG5cbiAgVm9sdW1lQ29udHJvbC5wcm90b3R5cGUuY3JlYXRlRWwgPSBmdW5jdGlvbiBjcmVhdGVFbCgpIHtcbiAgICB2YXIgb3JpZW50YXRpb25DbGFzcyA9ICd2anMtdm9sdW1lLWhvcml6b250YWwnO1xuXG4gICAgaWYgKHRoaXMub3B0aW9uc18udmVydGljYWwpIHtcbiAgICAgIG9yaWVudGF0aW9uQ2xhc3MgPSAndmpzLXZvbHVtZS12ZXJ0aWNhbCc7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9Db21wb25lbnQucHJvdG90eXBlLmNyZWF0ZUVsLmNhbGwodGhpcywgJ2RpdicsIHtcbiAgICAgIGNsYXNzTmFtZTogJ3Zqcy12b2x1bWUtY29udHJvbCB2anMtY29udHJvbCAnICsgb3JpZW50YXRpb25DbGFzc1xuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBIYW5kbGUgYG1vdXNlZG93bmAgb3IgYHRvdWNoc3RhcnRgIGV2ZW50cyBvbiB0aGUgYFZvbHVtZUNvbnRyb2xgLlxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBldmVudFxuICAgKiAgICAgICAgYG1vdXNlZG93bmAgb3IgYHRvdWNoc3RhcnRgIGV2ZW50IHRoYXQgdHJpZ2dlcmVkIHRoaXMgZnVuY3Rpb25cbiAgICpcbiAgICogQGxpc3RlbnMgbW91c2Vkb3duXG4gICAqIEBsaXN0ZW5zIHRvdWNoc3RhcnRcbiAgICovXG5cblxuICBWb2x1bWVDb250cm9sLnByb3RvdHlwZS5oYW5kbGVNb3VzZURvd24gPSBmdW5jdGlvbiBoYW5kbGVNb3VzZURvd24oZXZlbnQpIHtcbiAgICB2YXIgZG9jID0gdGhpcy5lbF8ub3duZXJEb2N1bWVudDtcblxuICAgIHRoaXMub24oZG9jLCAnbW91c2Vtb3ZlJywgdGhpcy50aHJvdHRsZWRIYW5kbGVNb3VzZU1vdmUpO1xuICAgIHRoaXMub24oZG9jLCAndG91Y2htb3ZlJywgdGhpcy50aHJvdHRsZWRIYW5kbGVNb3VzZU1vdmUpO1xuICAgIHRoaXMub24oZG9jLCAnbW91c2V1cCcsIHRoaXMuaGFuZGxlTW91c2VVcCk7XG4gICAgdGhpcy5vbihkb2MsICd0b3VjaGVuZCcsIHRoaXMuaGFuZGxlTW91c2VVcCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBgbW91c2V1cGAgb3IgYHRvdWNoZW5kYCBldmVudHMgb24gdGhlIGBWb2x1bWVDb250cm9sYC5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gZXZlbnRcbiAgICogICAgICAgIGBtb3VzZXVwYCBvciBgdG91Y2hlbmRgIGV2ZW50IHRoYXQgdHJpZ2dlcmVkIHRoaXMgZnVuY3Rpb24uXG4gICAqXG4gICAqIEBsaXN0ZW5zIHRvdWNoZW5kXG4gICAqIEBsaXN0ZW5zIG1vdXNldXBcbiAgICovXG5cblxuICBWb2x1bWVDb250cm9sLnByb3RvdHlwZS5oYW5kbGVNb3VzZVVwID0gZnVuY3Rpb24gaGFuZGxlTW91c2VVcChldmVudCkge1xuICAgIHZhciBkb2MgPSB0aGlzLmVsXy5vd25lckRvY3VtZW50O1xuXG4gICAgdGhpcy5vZmYoZG9jLCAnbW91c2Vtb3ZlJywgdGhpcy50aHJvdHRsZWRIYW5kbGVNb3VzZU1vdmUpO1xuICAgIHRoaXMub2ZmKGRvYywgJ3RvdWNobW92ZScsIHRoaXMudGhyb3R0bGVkSGFuZGxlTW91c2VNb3ZlKTtcbiAgICB0aGlzLm9mZihkb2MsICdtb3VzZXVwJywgdGhpcy5oYW5kbGVNb3VzZVVwKTtcbiAgICB0aGlzLm9mZihkb2MsICd0b3VjaGVuZCcsIHRoaXMuaGFuZGxlTW91c2VVcCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBgbW91c2Vkb3duYCBvciBgdG91Y2hzdGFydGAgZXZlbnRzIG9uIHRoZSBgVm9sdW1lQ29udHJvbGAuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IGV2ZW50XG4gICAqICAgICAgICBgbW91c2Vkb3duYCBvciBgdG91Y2hzdGFydGAgZXZlbnQgdGhhdCB0cmlnZ2VyZWQgdGhpcyBmdW5jdGlvblxuICAgKlxuICAgKiBAbGlzdGVucyBtb3VzZWRvd25cbiAgICogQGxpc3RlbnMgdG91Y2hzdGFydFxuICAgKi9cblxuXG4gIFZvbHVtZUNvbnRyb2wucHJvdG90eXBlLmhhbmRsZU1vdXNlTW92ZSA9IGZ1bmN0aW9uIGhhbmRsZU1vdXNlTW92ZShldmVudCkge1xuICAgIHRoaXMudm9sdW1lQmFyLmhhbmRsZU1vdXNlTW92ZShldmVudCk7XG4gIH07XG5cbiAgcmV0dXJuIFZvbHVtZUNvbnRyb2w7XG59KENvbXBvbmVudCk7XG5cbi8qKlxuICogRGVmYXVsdCBvcHRpb25zIGZvciB0aGUgYFZvbHVtZUNvbnRyb2xgXG4gKlxuICogQHR5cGUge09iamVjdH1cbiAqIEBwcml2YXRlXG4gKi9cblxuXG5Wb2x1bWVDb250cm9sLnByb3RvdHlwZS5vcHRpb25zXyA9IHtcbiAgY2hpbGRyZW46IFsndm9sdW1lQmFyJ11cbn07XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnVm9sdW1lQ29udHJvbCcsIFZvbHVtZUNvbnRyb2wpO1xuXG4vKipcbiAqIENoZWNrIGlmIG11dGluZyB2b2x1bWUgaXMgc3VwcG9ydGVkIGFuZCBpZiBpdCBpc24ndCBoaWRlIHRoZSBtdXRlIHRvZ2dsZVxuICogYnV0dG9uLlxuICpcbiAqIEBwYXJhbSB7Q29tcG9uZW50fSBzZWxmXG4gKiAgICAgICAgQSByZWZlcmVuY2UgdG8gdGhlIG11dGUgdG9nZ2xlIGJ1dHRvblxuICpcbiAqIEBwYXJhbSB7UGxheWVyfSBwbGF5ZXJcbiAqICAgICAgICBBIHJlZmVyZW5jZSB0byB0aGUgcGxheWVyXG4gKlxuICogQHByaXZhdGVcbiAqL1xudmFyIGNoZWNrTXV0ZVN1cHBvcnQgPSBmdW5jdGlvbiBjaGVja011dGVTdXBwb3J0KHNlbGYsIHBsYXllcikge1xuICAvLyBoaWRlIG11dGUgdG9nZ2xlIGJ1dHRvbiBpZiBpdCdzIG5vdCBzdXBwb3J0ZWQgYnkgdGhlIGN1cnJlbnQgdGVjaFxuICBpZiAocGxheWVyLnRlY2hfICYmICFwbGF5ZXIudGVjaF8uZmVhdHVyZXNNdXRlQ29udHJvbCkge1xuICAgIHNlbGYuYWRkQ2xhc3MoJ3Zqcy1oaWRkZW4nKTtcbiAgfVxuXG4gIHNlbGYub24ocGxheWVyLCAnbG9hZHN0YXJ0JywgZnVuY3Rpb24gKCkge1xuICAgIGlmICghcGxheWVyLnRlY2hfLmZlYXR1cmVzTXV0ZUNvbnRyb2wpIHtcbiAgICAgIHNlbGYuYWRkQ2xhc3MoJ3Zqcy1oaWRkZW4nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2VsZi5yZW1vdmVDbGFzcygndmpzLWhpZGRlbicpO1xuICAgIH1cbiAgfSk7XG59O1xuXG4vKipcbiAqIEBmaWxlIG11dGUtdG9nZ2xlLmpzXG4gKi9cbi8qKlxuICogQSBidXR0b24gY29tcG9uZW50IGZvciBtdXRpbmcgdGhlIGF1ZGlvLlxuICpcbiAqIEBleHRlbmRzIEJ1dHRvblxuICovXG5cbnZhciBNdXRlVG9nZ2xlID0gZnVuY3Rpb24gKF9CdXR0b24pIHtcbiAgaW5oZXJpdHMoTXV0ZVRvZ2dsZSwgX0J1dHRvbik7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcy5cbiAgICpcbiAgICogQHBhcmFtIHtQbGF5ZXJ9IHBsYXllclxuICAgKiAgICAgICAgVGhlIGBQbGF5ZXJgIHRoYXQgdGhpcyBjbGFzcyBzaG91bGQgYmUgYXR0YWNoZWQgdG8uXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICAgICAgIFRoZSBrZXkvdmFsdWUgc3RvcmUgb2YgcGxheWVyIG9wdGlvbnMuXG4gICAqL1xuICBmdW5jdGlvbiBNdXRlVG9nZ2xlKHBsYXllciwgb3B0aW9ucykge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIE11dGVUb2dnbGUpO1xuXG4gICAgLy8gaGlkZSB0aGlzIGNvbnRyb2wgaWYgdm9sdW1lIHN1cHBvcnQgaXMgbWlzc2luZ1xuICAgIHZhciBfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX0J1dHRvbi5jYWxsKHRoaXMsIHBsYXllciwgb3B0aW9ucykpO1xuXG4gICAgY2hlY2tNdXRlU3VwcG9ydChfdGhpcywgcGxheWVyKTtcblxuICAgIF90aGlzLm9uKHBsYXllciwgWydsb2Fkc3RhcnQnLCAndm9sdW1lY2hhbmdlJ10sIF90aGlzLnVwZGF0ZSk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEJ1aWxkcyB0aGUgZGVmYXVsdCBET00gYGNsYXNzTmFtZWAuXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICogICAgICAgICBUaGUgRE9NIGBjbGFzc05hbWVgIGZvciB0aGlzIG9iamVjdC5cbiAgICovXG5cblxuICBNdXRlVG9nZ2xlLnByb3RvdHlwZS5idWlsZENTU0NsYXNzID0gZnVuY3Rpb24gYnVpbGRDU1NDbGFzcygpIHtcbiAgICByZXR1cm4gJ3Zqcy1tdXRlLWNvbnRyb2wgJyArIF9CdXR0b24ucHJvdG90eXBlLmJ1aWxkQ1NTQ2xhc3MuY2FsbCh0aGlzKTtcbiAgfTtcblxuICAvKipcbiAgICogVGhpcyBnZXRzIGNhbGxlZCB3aGVuIGFuIGBNdXRlVG9nZ2xlYCBpcyBcImNsaWNrZWRcIi4gU2VlXG4gICAqIHtAbGluayBDbGlja2FibGVDb21wb25lbnR9IGZvciBtb3JlIGRldGFpbGVkIGluZm9ybWF0aW9uIG9uIHdoYXQgYSBjbGljayBjYW4gYmUuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IFtldmVudF1cbiAgICogICAgICAgIFRoZSBga2V5ZG93bmAsIGB0YXBgLCBvciBgY2xpY2tgIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgZnVuY3Rpb24gdG8gYmVcbiAgICogICAgICAgIGNhbGxlZC5cbiAgICpcbiAgICogQGxpc3RlbnMgdGFwXG4gICAqIEBsaXN0ZW5zIGNsaWNrXG4gICAqL1xuXG5cbiAgTXV0ZVRvZ2dsZS5wcm90b3R5cGUuaGFuZGxlQ2xpY2sgPSBmdW5jdGlvbiBoYW5kbGVDbGljayhldmVudCkge1xuICAgIHZhciB2b2wgPSB0aGlzLnBsYXllcl8udm9sdW1lKCk7XG4gICAgdmFyIGxhc3RWb2x1bWUgPSB0aGlzLnBsYXllcl8ubGFzdFZvbHVtZV8oKTtcblxuICAgIGlmICh2b2wgPT09IDApIHtcbiAgICAgIHZhciB2b2x1bWVUb1NldCA9IGxhc3RWb2x1bWUgPCAwLjEgPyAwLjEgOiBsYXN0Vm9sdW1lO1xuXG4gICAgICB0aGlzLnBsYXllcl8udm9sdW1lKHZvbHVtZVRvU2V0KTtcbiAgICAgIHRoaXMucGxheWVyXy5tdXRlZChmYWxzZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucGxheWVyXy5tdXRlZCh0aGlzLnBsYXllcl8ubXV0ZWQoKSA/IGZhbHNlIDogdHJ1ZSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIGBNdXRlVG9nZ2xlYCBidXR0b24gYmFzZWQgb24gdGhlIHN0YXRlIG9mIGB2b2x1bWVgIGFuZCBgbXV0ZWRgXG4gICAqIG9uIHRoZSBwbGF5ZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IFtldmVudF1cbiAgICogICAgICAgIFRoZSB7QGxpbmsgUGxheWVyI2xvYWRzdGFydH0gZXZlbnQgaWYgdGhpcyBmdW5jdGlvbiB3YXMgY2FsbGVkXG4gICAqICAgICAgICB0aHJvdWdoIGFuIGV2ZW50LlxuICAgKlxuICAgKiBAbGlzdGVucyBQbGF5ZXIjbG9hZHN0YXJ0XG4gICAqIEBsaXN0ZW5zIFBsYXllciN2b2x1bWVjaGFuZ2VcbiAgICovXG5cblxuICBNdXRlVG9nZ2xlLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUoZXZlbnQpIHtcbiAgICB0aGlzLnVwZGF0ZUljb25fKCk7XG4gICAgdGhpcy51cGRhdGVDb250cm9sVGV4dF8oKTtcbiAgfTtcblxuICAvKipcbiAgICogVXBkYXRlIHRoZSBhcHBlYXJhbmNlIG9mIHRoZSBgTXV0ZVRvZ2dsZWAgaWNvbi5cbiAgICpcbiAgICogUG9zc2libGUgc3RhdGVzIChnaXZlbiBgbGV2ZWxgIHZhcmlhYmxlIGJlbG93KTpcbiAgICogLSAwOiBjcm9zc2VkIG91dFxuICAgKiAtIDE6IHplcm8gYmFycyBvZiB2b2x1bWVcbiAgICogLSAyOiBvbmUgYmFyIG9mIHZvbHVtZVxuICAgKiAtIDM6IHR3byBiYXJzIG9mIHZvbHVtZVxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIE11dGVUb2dnbGUucHJvdG90eXBlLnVwZGF0ZUljb25fID0gZnVuY3Rpb24gdXBkYXRlSWNvbl8oKSB7XG4gICAgdmFyIHZvbCA9IHRoaXMucGxheWVyXy52b2x1bWUoKTtcbiAgICB2YXIgbGV2ZWwgPSAzO1xuXG4gICAgLy8gaW4gaU9TIHdoZW4gYSBwbGF5ZXIgaXMgbG9hZGVkIHdpdGggbXV0ZWQgYXR0cmlidXRlXG4gICAgLy8gYW5kIHZvbHVtZSBpcyBjaGFuZ2VkIHdpdGggYSBuYXRpdmUgbXV0ZSBidXR0b25cbiAgICAvLyB3ZSB3YW50IHRvIG1ha2Ugc3VyZSBtdXRlZCBzdGF0ZSBpcyB1cGRhdGVkXG4gICAgaWYgKElTX0lPUykge1xuICAgICAgdGhpcy5wbGF5ZXJfLm11dGVkKHRoaXMucGxheWVyXy50ZWNoXy5lbF8ubXV0ZWQpO1xuICAgIH1cblxuICAgIGlmICh2b2wgPT09IDAgfHwgdGhpcy5wbGF5ZXJfLm11dGVkKCkpIHtcbiAgICAgIGxldmVsID0gMDtcbiAgICB9IGVsc2UgaWYgKHZvbCA8IDAuMzMpIHtcbiAgICAgIGxldmVsID0gMTtcbiAgICB9IGVsc2UgaWYgKHZvbCA8IDAuNjcpIHtcbiAgICAgIGxldmVsID0gMjtcbiAgICB9XG5cbiAgICAvLyBUT0RPIGltcHJvdmUgbXV0ZWQgaWNvbiBjbGFzc2VzXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICAgIHJlbW92ZUNsYXNzKHRoaXMuZWxfLCAndmpzLXZvbC0nICsgaSk7XG4gICAgfVxuICAgIGFkZENsYXNzKHRoaXMuZWxfLCAndmpzLXZvbC0nICsgbGV2ZWwpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBJZiBgbXV0ZWRgIGhhcyBjaGFuZ2VkIG9uIHRoZSBwbGF5ZXIsIHVwZGF0ZSB0aGUgY29udHJvbCB0ZXh0XG4gICAqIChgdGl0bGVgIGF0dHJpYnV0ZSBvbiBgdmpzLW11dGUtY29udHJvbGAgZWxlbWVudCBhbmQgY29udGVudCBvZlxuICAgKiBgdmpzLWNvbnRyb2wtdGV4dGAgZWxlbWVudCkuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgTXV0ZVRvZ2dsZS5wcm90b3R5cGUudXBkYXRlQ29udHJvbFRleHRfID0gZnVuY3Rpb24gdXBkYXRlQ29udHJvbFRleHRfKCkge1xuICAgIHZhciBzb3VuZE9mZiA9IHRoaXMucGxheWVyXy5tdXRlZCgpIHx8IHRoaXMucGxheWVyXy52b2x1bWUoKSA9PT0gMDtcbiAgICB2YXIgdGV4dCA9IHNvdW5kT2ZmID8gJ1VubXV0ZScgOiAnTXV0ZSc7XG5cbiAgICBpZiAodGhpcy5jb250cm9sVGV4dCgpICE9PSB0ZXh0KSB7XG4gICAgICB0aGlzLmNvbnRyb2xUZXh0KHRleHQpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gTXV0ZVRvZ2dsZTtcbn0oQnV0dG9uKTtcblxuLyoqXG4gKiBUaGUgdGV4dCB0aGF0IHNob3VsZCBkaXNwbGF5IG92ZXIgdGhlIGBNdXRlVG9nZ2xlYHMgY29udHJvbHMuIEFkZGVkIGZvciBsb2NhbGl6YXRpb24uXG4gKlxuICogQHR5cGUge3N0cmluZ31cbiAqIEBwcml2YXRlXG4gKi9cblxuXG5NdXRlVG9nZ2xlLnByb3RvdHlwZS5jb250cm9sVGV4dF8gPSAnTXV0ZSc7XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnTXV0ZVRvZ2dsZScsIE11dGVUb2dnbGUpO1xuXG4vKipcbiAqIEBmaWxlIHZvbHVtZS1jb250cm9sLmpzXG4gKi9cbi8vIFJlcXVpcmVkIGNoaWxkcmVuXG4vKipcbiAqIEEgQ29tcG9uZW50IHRvIGNvbnRhaW4gdGhlIE11dGVUb2dnbGUgYW5kIFZvbHVtZUNvbnRyb2wgc28gdGhhdFxuICogdGhleSBjYW4gd29yayB0b2dldGhlci5cbiAqXG4gKiBAZXh0ZW5kcyBDb21wb25lbnRcbiAqL1xuXG52YXIgVm9sdW1lUGFuZWwgPSBmdW5jdGlvbiAoX0NvbXBvbmVudCkge1xuICBpbmhlcml0cyhWb2x1bWVQYW5lbCwgX0NvbXBvbmVudCk7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcy5cbiAgICpcbiAgICogQHBhcmFtIHtQbGF5ZXJ9IHBsYXllclxuICAgKiAgICAgICAgVGhlIGBQbGF5ZXJgIHRoYXQgdGhpcyBjbGFzcyBzaG91bGQgYmUgYXR0YWNoZWQgdG8uXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV1cbiAgICogICAgICAgIFRoZSBrZXkvdmFsdWUgc3RvcmUgb2YgcGxheWVyIG9wdGlvbnMuXG4gICAqL1xuICBmdW5jdGlvbiBWb2x1bWVQYW5lbChwbGF5ZXIpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgVm9sdW1lUGFuZWwpO1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmlubGluZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIG9wdGlvbnMuaW5saW5lID0gb3B0aW9ucy5pbmxpbmU7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9wdGlvbnMuaW5saW5lID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBwYXNzIHRoZSBpbmxpbmUgb3B0aW9uIGRvd24gdG8gdGhlIFZvbHVtZUNvbnRyb2wgYXMgdmVydGljYWwgaWZcbiAgICAvLyB0aGUgVm9sdW1lQ29udHJvbCBpcyBvbi5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMudm9sdW1lQ29udHJvbCA9PT0gJ3VuZGVmaW5lZCcgfHwgaXNQbGFpbihvcHRpb25zLnZvbHVtZUNvbnRyb2wpKSB7XG4gICAgICBvcHRpb25zLnZvbHVtZUNvbnRyb2wgPSBvcHRpb25zLnZvbHVtZUNvbnRyb2wgfHwge307XG4gICAgICBvcHRpb25zLnZvbHVtZUNvbnRyb2wudmVydGljYWwgPSAhb3B0aW9ucy5pbmxpbmU7XG4gICAgfVxuXG4gICAgdmFyIF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfQ29tcG9uZW50LmNhbGwodGhpcywgcGxheWVyLCBvcHRpb25zKSk7XG5cbiAgICBfdGhpcy5vbihwbGF5ZXIsIFsnbG9hZHN0YXJ0J10sIF90aGlzLnZvbHVtZVBhbmVsU3RhdGVfKTtcblxuICAgIC8vIHdoaWxlIHRoZSBzbGlkZXIgaXMgYWN0aXZlICh0aGUgbW91c2UgaGFzIGJlZW4gcHJlc3NlZCBkb3duIGFuZFxuICAgIC8vIGlzIGRyYWdnaW5nKSB3ZSBkbyBub3Qgd2FudCB0byBoaWRlIHRoZSBWb2x1bWVCYXJcbiAgICBfdGhpcy5vbihfdGhpcy52b2x1bWVDb250cm9sLCBbJ3NsaWRlcmFjdGl2ZSddLCBfdGhpcy5zbGlkZXJBY3RpdmVfKTtcblxuICAgIF90aGlzLm9uKF90aGlzLnZvbHVtZUNvbnRyb2wsIFsnc2xpZGVyaW5hY3RpdmUnXSwgX3RoaXMuc2xpZGVySW5hY3RpdmVfKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICAvKipcbiAgICogQWRkIHZqcy1zbGlkZXItYWN0aXZlIGNsYXNzIHRvIHRoZSBWb2x1bWVQYW5lbFxuICAgKlxuICAgKiBAbGlzdGVucyBWb2x1bWVDb250cm9sI3NsaWRlcmFjdGl2ZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIFZvbHVtZVBhbmVsLnByb3RvdHlwZS5zbGlkZXJBY3RpdmVfID0gZnVuY3Rpb24gc2xpZGVyQWN0aXZlXygpIHtcbiAgICB0aGlzLmFkZENsYXNzKCd2anMtc2xpZGVyLWFjdGl2ZScpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZW1vdmVzIHZqcy1zbGlkZXItYWN0aXZlIGNsYXNzIHRvIHRoZSBWb2x1bWVQYW5lbFxuICAgKlxuICAgKiBAbGlzdGVucyBWb2x1bWVDb250cm9sI3NsaWRlcmluYWN0aXZlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgVm9sdW1lUGFuZWwucHJvdG90eXBlLnNsaWRlckluYWN0aXZlXyA9IGZ1bmN0aW9uIHNsaWRlckluYWN0aXZlXygpIHtcbiAgICB0aGlzLnJlbW92ZUNsYXNzKCd2anMtc2xpZGVyLWFjdGl2ZScpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBZGRzIHZqcy1oaWRkZW4gb3IgdmpzLW11dGUtdG9nZ2xlLW9ubHkgdG8gdGhlIFZvbHVtZVBhbmVsXG4gICAqIGRlcGVuZGluZyBvbiBNdXRlVG9nZ2xlIGFuZCBWb2x1bWVDb250cm9sIHN0YXRlXG4gICAqXG4gICAqIEBsaXN0ZW5zIFBsYXllciNsb2Fkc3RhcnRcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBWb2x1bWVQYW5lbC5wcm90b3R5cGUudm9sdW1lUGFuZWxTdGF0ZV8gPSBmdW5jdGlvbiB2b2x1bWVQYW5lbFN0YXRlXygpIHtcbiAgICAvLyBoaWRlIHZvbHVtZSBwYW5lbCBpZiBuZWl0aGVyIHZvbHVtZSBjb250cm9sIG9yIG11dGUgdG9nZ2xlXG4gICAgLy8gYXJlIGRpc3BsYXllZFxuICAgIGlmICh0aGlzLnZvbHVtZUNvbnRyb2wuaGFzQ2xhc3MoJ3Zqcy1oaWRkZW4nKSAmJiB0aGlzLm11dGVUb2dnbGUuaGFzQ2xhc3MoJ3Zqcy1oaWRkZW4nKSkge1xuICAgICAgdGhpcy5hZGRDbGFzcygndmpzLWhpZGRlbicpO1xuICAgIH1cblxuICAgIC8vIGlmIG9ubHkgbXV0ZSB0b2dnbGUgaXMgdmlzaWJsZSB3ZSBkb24ndCB3YW50XG4gICAgLy8gdm9sdW1lIHBhbmVsIGV4cGFuZGluZyB3aGVuIGhvdmVyZWQgb3IgYWN0aXZlXG4gICAgaWYgKHRoaXMudm9sdW1lQ29udHJvbC5oYXNDbGFzcygndmpzLWhpZGRlbicpICYmICF0aGlzLm11dGVUb2dnbGUuaGFzQ2xhc3MoJ3Zqcy1oaWRkZW4nKSkge1xuICAgICAgdGhpcy5hZGRDbGFzcygndmpzLW11dGUtdG9nZ2xlLW9ubHknKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSB0aGUgYENvbXBvbmVudGAncyBET00gZWxlbWVudFxuICAgKlxuICAgKiBAcmV0dXJuIHtFbGVtZW50fVxuICAgKiAgICAgICAgIFRoZSBlbGVtZW50IHRoYXQgd2FzIGNyZWF0ZWQuXG4gICAqL1xuXG5cbiAgVm9sdW1lUGFuZWwucHJvdG90eXBlLmNyZWF0ZUVsID0gZnVuY3Rpb24gY3JlYXRlRWwoKSB7XG4gICAgdmFyIG9yaWVudGF0aW9uQ2xhc3MgPSAndmpzLXZvbHVtZS1wYW5lbC1ob3Jpem9udGFsJztcblxuICAgIGlmICghdGhpcy5vcHRpb25zXy5pbmxpbmUpIHtcbiAgICAgIG9yaWVudGF0aW9uQ2xhc3MgPSAndmpzLXZvbHVtZS1wYW5lbC12ZXJ0aWNhbCc7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9Db21wb25lbnQucHJvdG90eXBlLmNyZWF0ZUVsLmNhbGwodGhpcywgJ2RpdicsIHtcbiAgICAgIGNsYXNzTmFtZTogJ3Zqcy12b2x1bWUtcGFuZWwgdmpzLWNvbnRyb2wgJyArIG9yaWVudGF0aW9uQ2xhc3NcbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4gVm9sdW1lUGFuZWw7XG59KENvbXBvbmVudCk7XG5cbi8qKlxuICogRGVmYXVsdCBvcHRpb25zIGZvciB0aGUgYFZvbHVtZUNvbnRyb2xgXG4gKlxuICogQHR5cGUge09iamVjdH1cbiAqIEBwcml2YXRlXG4gKi9cblxuXG5Wb2x1bWVQYW5lbC5wcm90b3R5cGUub3B0aW9uc18gPSB7XG4gIGNoaWxkcmVuOiBbJ211dGVUb2dnbGUnLCAndm9sdW1lQ29udHJvbCddXG59O1xuXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ1ZvbHVtZVBhbmVsJywgVm9sdW1lUGFuZWwpO1xuXG4vKipcbiAqIEBmaWxlIG1lbnUuanNcbiAqL1xuLyoqXG4gKiBUaGUgTWVudSBjb21wb25lbnQgaXMgdXNlZCB0byBidWlsZCBwb3B1cCBtZW51cywgaW5jbHVkaW5nIHN1YnRpdGxlIGFuZFxuICogY2FwdGlvbnMgc2VsZWN0aW9uIG1lbnVzLlxuICpcbiAqIEBleHRlbmRzIENvbXBvbmVudFxuICovXG5cbnZhciBNZW51ID0gZnVuY3Rpb24gKF9Db21wb25lbnQpIHtcbiAgaW5oZXJpdHMoTWVudSwgX0NvbXBvbmVudCk7XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge1BsYXllcn0gcGxheWVyXG4gICAqICAgICAgICB0aGUgcGxheWVyIHRoYXQgdGhpcyBjb21wb25lbnQgc2hvdWxkIGF0dGFjaCB0b1xuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgICAgICBPYmplY3Qgb2Ygb3B0aW9uIG5hbWVzIGFuZCB2YWx1ZXNcbiAgICpcbiAgICovXG4gIGZ1bmN0aW9uIE1lbnUocGxheWVyLCBvcHRpb25zKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgTWVudSk7XG5cbiAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9Db21wb25lbnQuY2FsbCh0aGlzLCBwbGF5ZXIsIG9wdGlvbnMpKTtcblxuICAgIGlmIChvcHRpb25zKSB7XG4gICAgICBfdGhpcy5tZW51QnV0dG9uXyA9IG9wdGlvbnMubWVudUJ1dHRvbjtcbiAgICB9XG5cbiAgICBfdGhpcy5mb2N1c2VkQ2hpbGRfID0gLTE7XG5cbiAgICBfdGhpcy5vbigna2V5ZG93bicsIF90aGlzLmhhbmRsZUtleVByZXNzKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICAvKipcbiAgICogQWRkIGEge0BsaW5rIE1lbnVJdGVtfSB0byB0aGUgbWVudS5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R8c3RyaW5nfSBjb21wb25lbnRcbiAgICogICAgICAgIFRoZSBuYW1lIG9yIGluc3RhbmNlIG9mIHRoZSBgTWVudUl0ZW1gIHRvIGFkZC5cbiAgICpcbiAgICovXG5cblxuICBNZW51LnByb3RvdHlwZS5hZGRJdGVtID0gZnVuY3Rpb24gYWRkSXRlbShjb21wb25lbnQpIHtcbiAgICB0aGlzLmFkZENoaWxkKGNvbXBvbmVudCk7XG4gICAgY29tcG9uZW50Lm9uKCdjbGljaycsIGJpbmQodGhpcywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAvLyBVbnByZXNzIHRoZSBhc3NvY2lhdGVkIE1lbnVCdXR0b24sIGFuZCBtb3ZlIGZvY3VzIGJhY2sgdG8gaXRcbiAgICAgIGlmICh0aGlzLm1lbnVCdXR0b25fKSB7XG4gICAgICAgIHRoaXMubWVudUJ1dHRvbl8udW5wcmVzc0J1dHRvbigpO1xuXG4gICAgICAgIC8vIGRvbid0IGZvY3VzIG1lbnUgYnV0dG9uIGlmIGl0ZW0gaXMgYSBjYXB0aW9uIHNldHRpbmdzIGl0ZW1cbiAgICAgICAgLy8gYmVjYXVzZSBmb2N1cyB3aWxsIG1vdmUgZWxzZXdoZXJlIGFuZCBpdCBsb2dzIGFuIGVycm9yIG9uIElFOFxuICAgICAgICBpZiAoY29tcG9uZW50Lm5hbWUoKSAhPT0gJ0NhcHRpb25TZXR0aW5nc01lbnVJdGVtJykge1xuICAgICAgICAgIHRoaXMubWVudUJ1dHRvbl8uZm9jdXMoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pKTtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlIHRoZSBgTWVudWBzIERPTSBlbGVtZW50LlxuICAgKlxuICAgKiBAcmV0dXJuIHtFbGVtZW50fVxuICAgKiAgICAgICAgIHRoZSBlbGVtZW50IHRoYXQgd2FzIGNyZWF0ZWRcbiAgICovXG5cblxuICBNZW51LnByb3RvdHlwZS5jcmVhdGVFbCA9IGZ1bmN0aW9uIGNyZWF0ZUVsJCQxKCkge1xuICAgIHZhciBjb250ZW50RWxUeXBlID0gdGhpcy5vcHRpb25zXy5jb250ZW50RWxUeXBlIHx8ICd1bCc7XG5cbiAgICB0aGlzLmNvbnRlbnRFbF8gPSBjcmVhdGVFbChjb250ZW50RWxUeXBlLCB7XG4gICAgICBjbGFzc05hbWU6ICd2anMtbWVudS1jb250ZW50J1xuICAgIH0pO1xuXG4gICAgdGhpcy5jb250ZW50RWxfLnNldEF0dHJpYnV0ZSgncm9sZScsICdtZW51Jyk7XG5cbiAgICB2YXIgZWwgPSBfQ29tcG9uZW50LnByb3RvdHlwZS5jcmVhdGVFbC5jYWxsKHRoaXMsICdkaXYnLCB7XG4gICAgICBhcHBlbmQ6IHRoaXMuY29udGVudEVsXyxcbiAgICAgIGNsYXNzTmFtZTogJ3Zqcy1tZW51J1xuICAgIH0pO1xuXG4gICAgZWwuYXBwZW5kQ2hpbGQodGhpcy5jb250ZW50RWxfKTtcblxuICAgIC8vIFByZXZlbnQgY2xpY2tzIGZyb20gYnViYmxpbmcgdXAuIE5lZWRlZCBmb3IgTWVudSBCdXR0b25zLFxuICAgIC8vIHdoZXJlIGEgY2xpY2sgb24gdGhlIHBhcmVudCBpcyBzaWduaWZpY2FudFxuICAgIG9uKGVsLCAnY2xpY2snLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICB9KTtcblxuICAgIHJldHVybiBlbDtcbiAgfTtcblxuICBNZW51LnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gZGlzcG9zZSgpIHtcbiAgICB0aGlzLmNvbnRlbnRFbF8gPSBudWxsO1xuXG4gICAgX0NvbXBvbmVudC5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBIYW5kbGUgYSBga2V5ZG93bmAgZXZlbnQgb24gdGhpcyBtZW51LiBUaGlzIGxpc3RlbmVyIGlzIGFkZGVkIGluIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gZXZlbnRcbiAgICogICAgICAgIEEgYGtleWRvd25gIGV2ZW50IHRoYXQgaGFwcGVuZWQgb24gdGhlIG1lbnUuXG4gICAqXG4gICAqIEBsaXN0ZW5zIGtleWRvd25cbiAgICovXG5cblxuICBNZW51LnByb3RvdHlwZS5oYW5kbGVLZXlQcmVzcyA9IGZ1bmN0aW9uIGhhbmRsZUtleVByZXNzKGV2ZW50KSB7XG4gICAgLy8gTGVmdCBhbmQgRG93biBBcnJvd3NcbiAgICBpZiAoZXZlbnQud2hpY2ggPT09IDM3IHx8IGV2ZW50LndoaWNoID09PSA0MCkge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHRoaXMuc3RlcEZvcndhcmQoKTtcblxuICAgICAgLy8gVXAgYW5kIFJpZ2h0IEFycm93c1xuICAgIH0gZWxzZSBpZiAoZXZlbnQud2hpY2ggPT09IDM4IHx8IGV2ZW50LndoaWNoID09PSAzOSkge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHRoaXMuc3RlcEJhY2soKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIE1vdmUgdG8gbmV4dCAobG93ZXIpIG1lbnUgaXRlbSBmb3Iga2V5Ym9hcmQgdXNlcnMuXG4gICAqL1xuXG5cbiAgTWVudS5wcm90b3R5cGUuc3RlcEZvcndhcmQgPSBmdW5jdGlvbiBzdGVwRm9yd2FyZCgpIHtcbiAgICB2YXIgc3RlcENoaWxkID0gMDtcblxuICAgIGlmICh0aGlzLmZvY3VzZWRDaGlsZF8gIT09IHVuZGVmaW5lZCkge1xuICAgICAgc3RlcENoaWxkID0gdGhpcy5mb2N1c2VkQ2hpbGRfICsgMTtcbiAgICB9XG4gICAgdGhpcy5mb2N1cyhzdGVwQ2hpbGQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBNb3ZlIHRvIHByZXZpb3VzIChoaWdoZXIpIG1lbnUgaXRlbSBmb3Iga2V5Ym9hcmQgdXNlcnMuXG4gICAqL1xuXG5cbiAgTWVudS5wcm90b3R5cGUuc3RlcEJhY2sgPSBmdW5jdGlvbiBzdGVwQmFjaygpIHtcbiAgICB2YXIgc3RlcENoaWxkID0gMDtcblxuICAgIGlmICh0aGlzLmZvY3VzZWRDaGlsZF8gIT09IHVuZGVmaW5lZCkge1xuICAgICAgc3RlcENoaWxkID0gdGhpcy5mb2N1c2VkQ2hpbGRfIC0gMTtcbiAgICB9XG4gICAgdGhpcy5mb2N1cyhzdGVwQ2hpbGQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgZm9jdXMgb24gYSB7QGxpbmsgTWVudUl0ZW19IGluIHRoZSBgTWVudWAuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fHN0cmluZ30gW2l0ZW09MF1cbiAgICogICAgICAgIEluZGV4IG9mIGNoaWxkIGl0ZW0gc2V0IGZvY3VzIG9uLlxuICAgKi9cblxuXG4gIE1lbnUucHJvdG90eXBlLmZvY3VzID0gZnVuY3Rpb24gZm9jdXMoKSB7XG4gICAgdmFyIGl0ZW0gPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IDA7XG5cbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuKCkuc2xpY2UoKTtcbiAgICB2YXIgaGF2ZVRpdGxlID0gY2hpbGRyZW4ubGVuZ3RoICYmIGNoaWxkcmVuWzBdLmNsYXNzTmFtZSAmJiAvdmpzLW1lbnUtdGl0bGUvLnRlc3QoY2hpbGRyZW5bMF0uY2xhc3NOYW1lKTtcblxuICAgIGlmIChoYXZlVGl0bGUpIHtcbiAgICAgIGNoaWxkcmVuLnNoaWZ0KCk7XG4gICAgfVxuXG4gICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgIGlmIChpdGVtIDwgMCkge1xuICAgICAgICBpdGVtID0gMDtcbiAgICAgIH0gZWxzZSBpZiAoaXRlbSA+PSBjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgaXRlbSA9IGNoaWxkcmVuLmxlbmd0aCAtIDE7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZm9jdXNlZENoaWxkXyA9IGl0ZW07XG5cbiAgICAgIGNoaWxkcmVuW2l0ZW1dLmVsXy5mb2N1cygpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gTWVudTtcbn0oQ29tcG9uZW50KTtcblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdNZW51JywgTWVudSk7XG5cbi8qKlxuICogQGZpbGUgbWVudS1idXR0b24uanNcbiAqL1xuLyoqXG4gKiBBIGBNZW51QnV0dG9uYCBjbGFzcyBmb3IgYW55IHBvcHVwIHtAbGluayBNZW51fS5cbiAqXG4gKiBAZXh0ZW5kcyBDb21wb25lbnRcbiAqL1xuXG52YXIgTWVudUJ1dHRvbiA9IGZ1bmN0aW9uIChfQ29tcG9uZW50KSB7XG4gIGluaGVyaXRzKE1lbnVCdXR0b24sIF9Db21wb25lbnQpO1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7UGxheWVyfSBwbGF5ZXJcbiAgICogICAgICAgIFRoZSBgUGxheWVyYCB0aGF0IHRoaXMgY2xhc3Mgc2hvdWxkIGJlIGF0dGFjaGVkIHRvLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dXG4gICAqICAgICAgICBUaGUga2V5L3ZhbHVlIHN0b3JlIG9mIHBsYXllciBvcHRpb25zLlxuICAgKi9cbiAgZnVuY3Rpb24gTWVudUJ1dHRvbihwbGF5ZXIpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgTWVudUJ1dHRvbik7XG5cbiAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9Db21wb25lbnQuY2FsbCh0aGlzLCBwbGF5ZXIsIG9wdGlvbnMpKTtcblxuICAgIF90aGlzLm1lbnVCdXR0b25fID0gbmV3IEJ1dHRvbihwbGF5ZXIsIG9wdGlvbnMpO1xuXG4gICAgX3RoaXMubWVudUJ1dHRvbl8uY29udHJvbFRleHQoX3RoaXMuY29udHJvbFRleHRfKTtcbiAgICBfdGhpcy5tZW51QnV0dG9uXy5lbF8uc2V0QXR0cmlidXRlKCdhcmlhLWhhc3BvcHVwJywgJ3RydWUnKTtcblxuICAgIC8vIEFkZCBidWlsZENTU0NsYXNzIHZhbHVlcyB0byB0aGUgYnV0dG9uLCBub3QgdGhlIHdyYXBwZXJcbiAgICB2YXIgYnV0dG9uQ2xhc3MgPSBCdXR0b24ucHJvdG90eXBlLmJ1aWxkQ1NTQ2xhc3MoKTtcblxuICAgIF90aGlzLm1lbnVCdXR0b25fLmVsXy5jbGFzc05hbWUgPSBfdGhpcy5idWlsZENTU0NsYXNzKCkgKyAnICcgKyBidXR0b25DbGFzcztcbiAgICBfdGhpcy5tZW51QnV0dG9uXy5yZW1vdmVDbGFzcygndmpzLWNvbnRyb2wnKTtcblxuICAgIF90aGlzLmFkZENoaWxkKF90aGlzLm1lbnVCdXR0b25fKTtcblxuICAgIF90aGlzLnVwZGF0ZSgpO1xuXG4gICAgX3RoaXMuZW5hYmxlZF8gPSB0cnVlO1xuXG4gICAgX3RoaXMub24oX3RoaXMubWVudUJ1dHRvbl8sICd0YXAnLCBfdGhpcy5oYW5kbGVDbGljayk7XG4gICAgX3RoaXMub24oX3RoaXMubWVudUJ1dHRvbl8sICdjbGljaycsIF90aGlzLmhhbmRsZUNsaWNrKTtcbiAgICBfdGhpcy5vbihfdGhpcy5tZW51QnV0dG9uXywgJ2ZvY3VzJywgX3RoaXMuaGFuZGxlRm9jdXMpO1xuICAgIF90aGlzLm9uKF90aGlzLm1lbnVCdXR0b25fLCAnYmx1cicsIF90aGlzLmhhbmRsZUJsdXIpO1xuXG4gICAgX3RoaXMub24oJ2tleWRvd24nLCBfdGhpcy5oYW5kbGVTdWJtZW51S2V5UHJlc3MpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIG1lbnUgYmFzZWQgb24gdGhlIGN1cnJlbnQgc3RhdGUgb2YgaXRzIGl0ZW1zLlxuICAgKi9cblxuXG4gIE1lbnVCdXR0b24ucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSgpIHtcbiAgICB2YXIgbWVudSA9IHRoaXMuY3JlYXRlTWVudSgpO1xuXG4gICAgaWYgKHRoaXMubWVudSkge1xuICAgICAgdGhpcy5tZW51LmRpc3Bvc2UoKTtcbiAgICAgIHRoaXMucmVtb3ZlQ2hpbGQodGhpcy5tZW51KTtcbiAgICB9XG5cbiAgICB0aGlzLm1lbnUgPSBtZW51O1xuICAgIHRoaXMuYWRkQ2hpbGQobWVudSk7XG5cbiAgICAvKipcbiAgICAgKiBUcmFjayB0aGUgc3RhdGUgb2YgdGhlIG1lbnUgYnV0dG9uXG4gICAgICpcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuYnV0dG9uUHJlc3NlZF8gPSBmYWxzZTtcbiAgICB0aGlzLm1lbnVCdXR0b25fLmVsXy5zZXRBdHRyaWJ1dGUoJ2FyaWEtZXhwYW5kZWQnLCAnZmFsc2UnKTtcblxuICAgIGlmICh0aGlzLml0ZW1zICYmIHRoaXMuaXRlbXMubGVuZ3RoIDw9IHRoaXMuaGlkZVRocmVzaG9sZF8pIHtcbiAgICAgIHRoaXMuaGlkZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNob3coKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSB0aGUgbWVudSBhbmQgYWRkIGFsbCBpdGVtcyB0byBpdC5cbiAgICpcbiAgICogQHJldHVybiB7TWVudX1cbiAgICogICAgICAgICBUaGUgY29uc3RydWN0ZWQgbWVudVxuICAgKi9cblxuXG4gIE1lbnVCdXR0b24ucHJvdG90eXBlLmNyZWF0ZU1lbnUgPSBmdW5jdGlvbiBjcmVhdGVNZW51KCkge1xuICAgIHZhciBtZW51ID0gbmV3IE1lbnUodGhpcy5wbGF5ZXJfLCB7IG1lbnVCdXR0b246IHRoaXMgfSk7XG5cbiAgICAvKipcbiAgICAgKiBIaWRlIHRoZSBtZW51IGlmIHRoZSBudW1iZXIgb2YgaXRlbXMgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoaXMgdGhyZXNob2xkLiBUaGlzIGRlZmF1bHRzXG4gICAgICogdG8gMCBhbmQgd2hlbmV2ZXIgd2UgYWRkIGl0ZW1zIHdoaWNoIGNhbiBiZSBoaWRkZW4gdG8gdGhlIG1lbnUgd2UnbGwgaW5jcmVtZW50IGl0LiBXZSBsaXN0XG4gICAgICogaXQgaGVyZSBiZWNhdXNlIGV2ZXJ5IHRpbWUgd2UgcnVuIGBjcmVhdGVNZW51YCB3ZSBuZWVkIHRvIHJlc2V0IHRoZSB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuaGlkZVRocmVzaG9sZF8gPSAwO1xuXG4gICAgLy8gQWRkIGEgdGl0bGUgbGlzdCBpdGVtIHRvIHRoZSB0b3BcbiAgICBpZiAodGhpcy5vcHRpb25zXy50aXRsZSkge1xuICAgICAgdmFyIHRpdGxlID0gY3JlYXRlRWwoJ2xpJywge1xuICAgICAgICBjbGFzc05hbWU6ICd2anMtbWVudS10aXRsZScsXG4gICAgICAgIGlubmVySFRNTDogdG9UaXRsZUNhc2UodGhpcy5vcHRpb25zXy50aXRsZSksXG4gICAgICAgIHRhYkluZGV4OiAtMVxuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuaGlkZVRocmVzaG9sZF8gKz0gMTtcblxuICAgICAgbWVudS5jaGlsZHJlbl8udW5zaGlmdCh0aXRsZSk7XG4gICAgICBwcmVwZW5kVG8odGl0bGUsIG1lbnUuY29udGVudEVsKCkpO1xuICAgIH1cblxuICAgIHRoaXMuaXRlbXMgPSB0aGlzLmNyZWF0ZUl0ZW1zKCk7XG5cbiAgICBpZiAodGhpcy5pdGVtcykge1xuICAgICAgLy8gQWRkIG1lbnUgaXRlbXMgdG8gdGhlIG1lbnVcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5pdGVtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBtZW51LmFkZEl0ZW0odGhpcy5pdGVtc1tpXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG1lbnU7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSB0aGUgbGlzdCBvZiBtZW51IGl0ZW1zLiBTcGVjaWZpYyB0byBlYWNoIHN1YmNsYXNzLlxuICAgKlxuICAgKiBAYWJzdHJhY3RcbiAgICovXG5cblxuICBNZW51QnV0dG9uLnByb3RvdHlwZS5jcmVhdGVJdGVtcyA9IGZ1bmN0aW9uIGNyZWF0ZUl0ZW1zKCkge307XG5cbiAgLyoqXG4gICAqIENyZWF0ZSB0aGUgYE1lbnVCdXR0b25zYHMgRE9NIGVsZW1lbnQuXG4gICAqXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9XG4gICAqICAgICAgICAgVGhlIGVsZW1lbnQgdGhhdCBnZXRzIGNyZWF0ZWQuXG4gICAqL1xuXG5cbiAgTWVudUJ1dHRvbi5wcm90b3R5cGUuY3JlYXRlRWwgPSBmdW5jdGlvbiBjcmVhdGVFbCQkMSgpIHtcbiAgICByZXR1cm4gX0NvbXBvbmVudC5wcm90b3R5cGUuY3JlYXRlRWwuY2FsbCh0aGlzLCAnZGl2Jywge1xuICAgICAgY2xhc3NOYW1lOiB0aGlzLmJ1aWxkV3JhcHBlckNTU0NsYXNzKClcbiAgICB9LCB7fSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEFsbG93IHN1YiBjb21wb25lbnRzIHRvIHN0YWNrIENTUyBjbGFzcyBuYW1lcyBmb3IgdGhlIHdyYXBwZXIgZWxlbWVudFxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqICAgICAgICAgVGhlIGNvbnN0cnVjdGVkIHdyYXBwZXIgRE9NIGBjbGFzc05hbWVgXG4gICAqL1xuXG5cbiAgTWVudUJ1dHRvbi5wcm90b3R5cGUuYnVpbGRXcmFwcGVyQ1NTQ2xhc3MgPSBmdW5jdGlvbiBidWlsZFdyYXBwZXJDU1NDbGFzcygpIHtcbiAgICB2YXIgbWVudUJ1dHRvbkNsYXNzID0gJ3Zqcy1tZW51LWJ1dHRvbic7XG5cbiAgICAvLyBJZiB0aGUgaW5saW5lIG9wdGlvbiBpcyBwYXNzZWQsIHdlIHdhbnQgdG8gdXNlIGRpZmZlcmVudCBzdHlsZXMgYWx0b2dldGhlci5cbiAgICBpZiAodGhpcy5vcHRpb25zXy5pbmxpbmUgPT09IHRydWUpIHtcbiAgICAgIG1lbnVCdXR0b25DbGFzcyArPSAnLWlubGluZSc7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1lbnVCdXR0b25DbGFzcyArPSAnLXBvcHVwJztcbiAgICB9XG5cbiAgICAvLyBUT0RPOiBGaXggdGhlIENTUyBzbyB0aGF0IHRoaXMgaXNuJ3QgbmVjZXNzYXJ5XG4gICAgdmFyIGJ1dHRvbkNsYXNzID0gQnV0dG9uLnByb3RvdHlwZS5idWlsZENTU0NsYXNzKCk7XG5cbiAgICByZXR1cm4gJ3Zqcy1tZW51LWJ1dHRvbiAnICsgbWVudUJ1dHRvbkNsYXNzICsgJyAnICsgYnV0dG9uQ2xhc3MgKyAnICcgKyBfQ29tcG9uZW50LnByb3RvdHlwZS5idWlsZENTU0NsYXNzLmNhbGwodGhpcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEJ1aWxkcyB0aGUgZGVmYXVsdCBET00gYGNsYXNzTmFtZWAuXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICogICAgICAgICBUaGUgRE9NIGBjbGFzc05hbWVgIGZvciB0aGlzIG9iamVjdC5cbiAgICovXG5cblxuICBNZW51QnV0dG9uLnByb3RvdHlwZS5idWlsZENTU0NsYXNzID0gZnVuY3Rpb24gYnVpbGRDU1NDbGFzcygpIHtcbiAgICB2YXIgbWVudUJ1dHRvbkNsYXNzID0gJ3Zqcy1tZW51LWJ1dHRvbic7XG5cbiAgICAvLyBJZiB0aGUgaW5saW5lIG9wdGlvbiBpcyBwYXNzZWQsIHdlIHdhbnQgdG8gdXNlIGRpZmZlcmVudCBzdHlsZXMgYWx0b2dldGhlci5cbiAgICBpZiAodGhpcy5vcHRpb25zXy5pbmxpbmUgPT09IHRydWUpIHtcbiAgICAgIG1lbnVCdXR0b25DbGFzcyArPSAnLWlubGluZSc7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1lbnVCdXR0b25DbGFzcyArPSAnLXBvcHVwJztcbiAgICB9XG5cbiAgICByZXR1cm4gJ3Zqcy1tZW51LWJ1dHRvbiAnICsgbWVudUJ1dHRvbkNsYXNzICsgJyAnICsgX0NvbXBvbmVudC5wcm90b3R5cGUuYnVpbGRDU1NDbGFzcy5jYWxsKHRoaXMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgb3Igc2V0IHRoZSBsb2NhbGl6ZWQgY29udHJvbCB0ZXh0IHRoYXQgd2lsbCBiZSB1c2VkIGZvciBhY2Nlc3NpYmlsaXR5LlxuICAgKlxuICAgKiA+IE5PVEU6IFRoaXMgd2lsbCBjb21lIGZyb20gdGhlIGludGVybmFsIGBtZW51QnV0dG9uX2AgZWxlbWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IFt0ZXh0XVxuICAgKiAgICAgICAgQ29udHJvbCB0ZXh0IGZvciBlbGVtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IFtlbD10aGlzLm1lbnVCdXR0b25fLmVsKCldXG4gICAqICAgICAgICBFbGVtZW50IHRvIHNldCB0aGUgdGl0bGUgb24uXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICogICAgICAgICAtIFRoZSBjb250cm9sIHRleHQgd2hlbiBnZXR0aW5nXG4gICAqL1xuXG5cbiAgTWVudUJ1dHRvbi5wcm90b3R5cGUuY29udHJvbFRleHQgPSBmdW5jdGlvbiBjb250cm9sVGV4dCh0ZXh0KSB7XG4gICAgdmFyIGVsID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0aGlzLm1lbnVCdXR0b25fLmVsKCk7XG5cbiAgICByZXR1cm4gdGhpcy5tZW51QnV0dG9uXy5jb250cm9sVGV4dCh0ZXh0LCBlbCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBhIGNsaWNrIG9uIGEgYE1lbnVCdXR0b25gLlxuICAgKiBTZWUge0BsaW5rIENsaWNrYWJsZUNvbXBvbmVudCNoYW5kbGVDbGlja30gZm9yIGluc3RhbmNlcyB3aGVyZSB0aGlzIGlzIGNhbGxlZC5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gZXZlbnRcbiAgICogICAgICAgIFRoZSBga2V5ZG93bmAsIGB0YXBgLCBvciBgY2xpY2tgIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgZnVuY3Rpb24gdG8gYmVcbiAgICogICAgICAgIGNhbGxlZC5cbiAgICpcbiAgICogQGxpc3RlbnMgdGFwXG4gICAqIEBsaXN0ZW5zIGNsaWNrXG4gICAqL1xuXG5cbiAgTWVudUJ1dHRvbi5wcm90b3R5cGUuaGFuZGxlQ2xpY2sgPSBmdW5jdGlvbiBoYW5kbGVDbGljayhldmVudCkge1xuICAgIC8vIFdoZW4geW91IGNsaWNrIHRoZSBidXR0b24gaXQgYWRkcyBmb2N1cywgd2hpY2ggd2lsbCBzaG93IHRoZSBtZW51LlxuICAgIC8vIFNvIHdlJ2xsIHJlbW92ZSBmb2N1cyB3aGVuIHRoZSBtb3VzZSBsZWF2ZXMgdGhlIGJ1dHRvbi4gRm9jdXMgaXMgbmVlZGVkXG4gICAgLy8gZm9yIHRhYiBuYXZpZ2F0aW9uLlxuXG4gICAgdGhpcy5vbmUodGhpcy5tZW51LmNvbnRlbnRFbCgpLCAnbW91c2VsZWF2ZScsIGJpbmQodGhpcywgZnVuY3Rpb24gKGUpIHtcbiAgICAgIHRoaXMudW5wcmVzc0J1dHRvbigpO1xuICAgICAgdGhpcy5lbF8uYmx1cigpO1xuICAgIH0pKTtcbiAgICBpZiAodGhpcy5idXR0b25QcmVzc2VkXykge1xuICAgICAgdGhpcy51bnByZXNzQnV0dG9uKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucHJlc3NCdXR0b24oKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgZm9jdXMgdG8gdGhlIGFjdHVhbCBidXR0b24sIG5vdCB0byB0aGlzIGVsZW1lbnRcbiAgICovXG5cblxuICBNZW51QnV0dG9uLnByb3RvdHlwZS5mb2N1cyA9IGZ1bmN0aW9uIGZvY3VzKCkge1xuICAgIHRoaXMubWVudUJ1dHRvbl8uZm9jdXMoKTtcbiAgfTtcblxuICAvKipcbiAgICogUmVtb3ZlIHRoZSBmb2N1cyBmcm9tIHRoZSBhY3R1YWwgYnV0dG9uLCBub3QgdGhpcyBlbGVtZW50XG4gICAqL1xuXG5cbiAgTWVudUJ1dHRvbi5wcm90b3R5cGUuYmx1ciA9IGZ1bmN0aW9uIGJsdXIoKSB7XG4gICAgdGhpcy5tZW51QnV0dG9uXy5ibHVyKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoaXMgZ2V0cyBjYWxsZWQgd2hlbiBhIGBNZW51QnV0dG9uYCBnYWlucyBmb2N1cyB2aWEgYSBgZm9jdXNgIGV2ZW50LlxuICAgKiBUdXJucyBvbiBsaXN0ZW5pbmcgZm9yIGBrZXlkb3duYCBldmVudHMuIFdoZW4gdGhleSBoYXBwZW4gaXRcbiAgICogY2FsbHMgYHRoaXMuaGFuZGxlS2V5UHJlc3NgLlxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBldmVudFxuICAgKiAgICAgICAgVGhlIGBmb2N1c2AgZXZlbnQgdGhhdCBjYXVzZWQgdGhpcyBmdW5jdGlvbiB0byBiZSBjYWxsZWQuXG4gICAqXG4gICAqIEBsaXN0ZW5zIGZvY3VzXG4gICAqL1xuXG5cbiAgTWVudUJ1dHRvbi5wcm90b3R5cGUuaGFuZGxlRm9jdXMgPSBmdW5jdGlvbiBoYW5kbGVGb2N1cygpIHtcbiAgICBvbihkb2N1bWVudCwgJ2tleWRvd24nLCBiaW5kKHRoaXMsIHRoaXMuaGFuZGxlS2V5UHJlc3MpKTtcbiAgfTtcblxuICAvKipcbiAgICogQ2FsbGVkIHdoZW4gYSBgTWVudUJ1dHRvbmAgbG9zZXMgZm9jdXMuIFR1cm5zIG9mZiB0aGUgbGlzdGVuZXIgZm9yXG4gICAqIGBrZXlkb3duYCBldmVudHMuIFdoaWNoIFN0b3BzIGB0aGlzLmhhbmRsZUtleVByZXNzYCBmcm9tIGdldHRpbmcgY2FsbGVkLlxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBldmVudFxuICAgKiAgICAgICAgVGhlIGBibHVyYCBldmVudCB0aGF0IGNhdXNlZCB0aGlzIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZC5cbiAgICpcbiAgICogQGxpc3RlbnMgYmx1clxuICAgKi9cblxuXG4gIE1lbnVCdXR0b24ucHJvdG90eXBlLmhhbmRsZUJsdXIgPSBmdW5jdGlvbiBoYW5kbGVCbHVyKCkge1xuICAgIG9mZihkb2N1bWVudCwgJ2tleWRvd24nLCBiaW5kKHRoaXMsIHRoaXMuaGFuZGxlS2V5UHJlc3MpKTtcbiAgfTtcblxuICAvKipcbiAgICogSGFuZGxlIHRhYiwgZXNjYXBlLCBkb3duIGFycm93LCBhbmQgdXAgYXJyb3cga2V5cyBmb3IgYE1lbnVCdXR0b25gLiBTZWVcbiAgICoge0BsaW5rIENsaWNrYWJsZUNvbXBvbmVudCNoYW5kbGVLZXlQcmVzc30gZm9yIGluc3RhbmNlcyB3aGVyZSB0aGlzIGlzIGNhbGxlZC5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gZXZlbnRcbiAgICogICAgICAgIFRoZSBga2V5ZG93bmAgZXZlbnQgdGhhdCBjYXVzZWQgdGhpcyBmdW5jdGlvbiB0byBiZSBjYWxsZWQuXG4gICAqXG4gICAqIEBsaXN0ZW5zIGtleWRvd25cbiAgICovXG5cblxuICBNZW51QnV0dG9uLnByb3RvdHlwZS5oYW5kbGVLZXlQcmVzcyA9IGZ1bmN0aW9uIGhhbmRsZUtleVByZXNzKGV2ZW50KSB7XG5cbiAgICAvLyBFc2NhcGUgKDI3KSBrZXkgb3IgVGFiICg5KSBrZXkgdW5wcmVzcyB0aGUgJ2J1dHRvbidcbiAgICBpZiAoZXZlbnQud2hpY2ggPT09IDI3IHx8IGV2ZW50LndoaWNoID09PSA5KSB7XG4gICAgICBpZiAodGhpcy5idXR0b25QcmVzc2VkXykge1xuICAgICAgICB0aGlzLnVucHJlc3NCdXR0b24oKTtcbiAgICAgIH1cbiAgICAgIC8vIERvbid0IHByZXZlbnREZWZhdWx0IGZvciBUYWIga2V5IC0gd2Ugc3RpbGwgd2FudCB0byBsb3NlIGZvY3VzXG4gICAgICBpZiAoZXZlbnQud2hpY2ggIT09IDkpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgLy8gU2V0IGZvY3VzIGJhY2sgdG8gdGhlIG1lbnUgYnV0dG9uJ3MgYnV0dG9uXG4gICAgICAgIHRoaXMubWVudUJ1dHRvbl8uZWxfLmZvY3VzKCk7XG4gICAgICB9XG4gICAgICAvLyBVcCAoMzgpIGtleSBvciBEb3duICg0MCkga2V5IHByZXNzIHRoZSAnYnV0dG9uJ1xuICAgIH0gZWxzZSBpZiAoZXZlbnQud2hpY2ggPT09IDM4IHx8IGV2ZW50LndoaWNoID09PSA0MCkge1xuICAgICAgaWYgKCF0aGlzLmJ1dHRvblByZXNzZWRfKSB7XG4gICAgICAgIHRoaXMucHJlc3NCdXR0b24oKTtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBhIGBrZXlkb3duYCBldmVudCBvbiBhIHN1Yi1tZW51LiBUaGUgbGlzdGVuZXIgZm9yIHRoaXMgaXMgYWRkZWQgaW5cbiAgICogdGhlIGNvbnN0cnVjdG9yLlxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBldmVudFxuICAgKiAgICAgICAgS2V5IHByZXNzIGV2ZW50XG4gICAqXG4gICAqIEBsaXN0ZW5zIGtleWRvd25cbiAgICovXG5cblxuICBNZW51QnV0dG9uLnByb3RvdHlwZS5oYW5kbGVTdWJtZW51S2V5UHJlc3MgPSBmdW5jdGlvbiBoYW5kbGVTdWJtZW51S2V5UHJlc3MoZXZlbnQpIHtcblxuICAgIC8vIEVzY2FwZSAoMjcpIGtleSBvciBUYWIgKDkpIGtleSB1bnByZXNzIHRoZSAnYnV0dG9uJ1xuICAgIGlmIChldmVudC53aGljaCA9PT0gMjcgfHwgZXZlbnQud2hpY2ggPT09IDkpIHtcbiAgICAgIGlmICh0aGlzLmJ1dHRvblByZXNzZWRfKSB7XG4gICAgICAgIHRoaXMudW5wcmVzc0J1dHRvbigpO1xuICAgICAgfVxuICAgICAgLy8gRG9uJ3QgcHJldmVudERlZmF1bHQgZm9yIFRhYiBrZXkgLSB3ZSBzdGlsbCB3YW50IHRvIGxvc2UgZm9jdXNcbiAgICAgIGlmIChldmVudC53aGljaCAhPT0gOSkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAvLyBTZXQgZm9jdXMgYmFjayB0byB0aGUgbWVudSBidXR0b24ncyBidXR0b25cbiAgICAgICAgdGhpcy5tZW51QnV0dG9uXy5lbF8uZm9jdXMoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFB1dCB0aGUgY3VycmVudCBgTWVudUJ1dHRvbmAgaW50byBhIHByZXNzZWQgc3RhdGUuXG4gICAqL1xuXG5cbiAgTWVudUJ1dHRvbi5wcm90b3R5cGUucHJlc3NCdXR0b24gPSBmdW5jdGlvbiBwcmVzc0J1dHRvbigpIHtcbiAgICBpZiAodGhpcy5lbmFibGVkXykge1xuICAgICAgdGhpcy5idXR0b25QcmVzc2VkXyA9IHRydWU7XG4gICAgICB0aGlzLm1lbnUubG9ja1Nob3dpbmcoKTtcbiAgICAgIHRoaXMubWVudUJ1dHRvbl8uZWxfLnNldEF0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcsICd0cnVlJyk7XG5cbiAgICAgIC8vIHNldCB0aGUgZm9jdXMgaW50byB0aGUgc3VibWVudSwgZXhjZXB0IG9uIGlPUyB3aGVyZSBpdCBpcyByZXN1bHRpbmcgaW5cbiAgICAgIC8vIHVuZGVzaXJlZCBzY3JvbGxpbmcgYmVoYXZpb3Igd2hlbiB0aGUgcGxheWVyIGlzIGluIGFuIGlmcmFtZVxuICAgICAgaWYgKElTX0lPUyAmJiBpc0luRnJhbWUoKSkge1xuICAgICAgICAvLyBSZXR1cm4gZWFybHkgc28gdGhhdCB0aGUgbWVudSBpc24ndCBmb2N1c2VkXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5tZW51LmZvY3VzKCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBUYWtlIHRoZSBjdXJyZW50IGBNZW51QnV0dG9uYCBvdXQgb2YgYSBwcmVzc2VkIHN0YXRlLlxuICAgKi9cblxuXG4gIE1lbnVCdXR0b24ucHJvdG90eXBlLnVucHJlc3NCdXR0b24gPSBmdW5jdGlvbiB1bnByZXNzQnV0dG9uKCkge1xuICAgIGlmICh0aGlzLmVuYWJsZWRfKSB7XG4gICAgICB0aGlzLmJ1dHRvblByZXNzZWRfID0gZmFsc2U7XG4gICAgICB0aGlzLm1lbnUudW5sb2NrU2hvd2luZygpO1xuICAgICAgdGhpcy5tZW51QnV0dG9uXy5lbF8uc2V0QXR0cmlidXRlKCdhcmlhLWV4cGFuZGVkJywgJ2ZhbHNlJyk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBEaXNhYmxlIHRoZSBgTWVudUJ1dHRvbmAuIERvbid0IGFsbG93IGl0IHRvIGJlIGNsaWNrZWQuXG4gICAqL1xuXG5cbiAgTWVudUJ1dHRvbi5wcm90b3R5cGUuZGlzYWJsZSA9IGZ1bmN0aW9uIGRpc2FibGUoKSB7XG4gICAgdGhpcy51bnByZXNzQnV0dG9uKCk7XG5cbiAgICB0aGlzLmVuYWJsZWRfID0gZmFsc2U7XG4gICAgdGhpcy5hZGRDbGFzcygndmpzLWRpc2FibGVkJyk7XG5cbiAgICB0aGlzLm1lbnVCdXR0b25fLmRpc2FibGUoKTtcbiAgfTtcblxuICAvKipcbiAgICogRW5hYmxlIHRoZSBgTWVudUJ1dHRvbmAuIEFsbG93IGl0IHRvIGJlIGNsaWNrZWQuXG4gICAqL1xuXG5cbiAgTWVudUJ1dHRvbi5wcm90b3R5cGUuZW5hYmxlID0gZnVuY3Rpb24gZW5hYmxlKCkge1xuICAgIHRoaXMuZW5hYmxlZF8gPSB0cnVlO1xuICAgIHRoaXMucmVtb3ZlQ2xhc3MoJ3Zqcy1kaXNhYmxlZCcpO1xuXG4gICAgdGhpcy5tZW51QnV0dG9uXy5lbmFibGUoKTtcbiAgfTtcblxuICByZXR1cm4gTWVudUJ1dHRvbjtcbn0oQ29tcG9uZW50KTtcblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdNZW51QnV0dG9uJywgTWVudUJ1dHRvbik7XG5cbi8qKlxuICogQGZpbGUgdHJhY2stYnV0dG9uLmpzXG4gKi9cbi8qKlxuICogVGhlIGJhc2UgY2xhc3MgZm9yIGJ1dHRvbnMgdGhhdCB0b2dnbGUgc3BlY2lmaWMgIHRyYWNrIHR5cGVzIChlLmcuIHN1YnRpdGxlcykuXG4gKlxuICogQGV4dGVuZHMgTWVudUJ1dHRvblxuICovXG5cbnZhciBUcmFja0J1dHRvbiA9IGZ1bmN0aW9uIChfTWVudUJ1dHRvbikge1xuICBpbmhlcml0cyhUcmFja0J1dHRvbiwgX01lbnVCdXR0b24pO1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7UGxheWVyfSBwbGF5ZXJcbiAgICogICAgICAgIFRoZSBgUGxheWVyYCB0aGF0IHRoaXMgY2xhc3Mgc2hvdWxkIGJlIGF0dGFjaGVkIHRvLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgICAgICBUaGUga2V5L3ZhbHVlIHN0b3JlIG9mIHBsYXllciBvcHRpb25zLlxuICAgKi9cbiAgZnVuY3Rpb24gVHJhY2tCdXR0b24ocGxheWVyLCBvcHRpb25zKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgVHJhY2tCdXR0b24pO1xuXG4gICAgdmFyIHRyYWNrcyA9IG9wdGlvbnMudHJhY2tzO1xuXG4gICAgdmFyIF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfTWVudUJ1dHRvbi5jYWxsKHRoaXMsIHBsYXllciwgb3B0aW9ucykpO1xuXG4gICAgaWYgKF90aGlzLml0ZW1zLmxlbmd0aCA8PSAxKSB7XG4gICAgICBfdGhpcy5oaWRlKCk7XG4gICAgfVxuXG4gICAgaWYgKCF0cmFja3MpIHtcbiAgICAgIHJldHVybiBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKF90aGlzKTtcbiAgICB9XG5cbiAgICB2YXIgdXBkYXRlSGFuZGxlciA9IGJpbmQoX3RoaXMsIF90aGlzLnVwZGF0ZSk7XG5cbiAgICB0cmFja3MuYWRkRXZlbnRMaXN0ZW5lcigncmVtb3ZldHJhY2snLCB1cGRhdGVIYW5kbGVyKTtcbiAgICB0cmFja3MuYWRkRXZlbnRMaXN0ZW5lcignYWRkdHJhY2snLCB1cGRhdGVIYW5kbGVyKTtcbiAgICBfdGhpcy5wbGF5ZXJfLm9uKCdyZWFkeScsIHVwZGF0ZUhhbmRsZXIpO1xuXG4gICAgX3RoaXMucGxheWVyXy5vbignZGlzcG9zZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHRyYWNrcy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZW1vdmV0cmFjaycsIHVwZGF0ZUhhbmRsZXIpO1xuICAgICAgdHJhY2tzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2FkZHRyYWNrJywgdXBkYXRlSGFuZGxlcik7XG4gICAgfSk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgcmV0dXJuIFRyYWNrQnV0dG9uO1xufShNZW51QnV0dG9uKTtcblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdUcmFja0J1dHRvbicsIFRyYWNrQnV0dG9uKTtcblxuLyoqXG4gKiBAZmlsZSBtZW51LWl0ZW0uanNcbiAqL1xuLyoqXG4gKiBUaGUgY29tcG9uZW50IGZvciBhIG1lbnUgaXRlbS4gYDxsaT5gXG4gKlxuICogQGV4dGVuZHMgQ2xpY2thYmxlQ29tcG9uZW50XG4gKi9cblxudmFyIE1lbnVJdGVtID0gZnVuY3Rpb24gKF9DbGlja2FibGVDb21wb25lbnQpIHtcbiAgaW5oZXJpdHMoTWVudUl0ZW0sIF9DbGlja2FibGVDb21wb25lbnQpO1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIHRoZSB0aGlzIGNsYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge1BsYXllcn0gcGxheWVyXG4gICAqICAgICAgICBUaGUgYFBsYXllcmAgdGhhdCB0aGlzIGNsYXNzIHNob3VsZCBiZSBhdHRhY2hlZCB0by5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XVxuICAgKiAgICAgICAgVGhlIGtleS92YWx1ZSBzdG9yZSBvZiBwbGF5ZXIgb3B0aW9ucy5cbiAgICpcbiAgICovXG4gIGZ1bmN0aW9uIE1lbnVJdGVtKHBsYXllciwgb3B0aW9ucykge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIE1lbnVJdGVtKTtcblxuICAgIHZhciBfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX0NsaWNrYWJsZUNvbXBvbmVudC5jYWxsKHRoaXMsIHBsYXllciwgb3B0aW9ucykpO1xuXG4gICAgX3RoaXMuc2VsZWN0YWJsZSA9IG9wdGlvbnMuc2VsZWN0YWJsZTtcbiAgICBfdGhpcy5pc1NlbGVjdGVkXyA9IG9wdGlvbnMuc2VsZWN0ZWQgfHwgZmFsc2U7XG4gICAgX3RoaXMubXVsdGlTZWxlY3RhYmxlID0gb3B0aW9ucy5tdWx0aVNlbGVjdGFibGU7XG5cbiAgICBfdGhpcy5zZWxlY3RlZChfdGhpcy5pc1NlbGVjdGVkXyk7XG5cbiAgICBpZiAoX3RoaXMuc2VsZWN0YWJsZSkge1xuICAgICAgaWYgKF90aGlzLm11bHRpU2VsZWN0YWJsZSkge1xuICAgICAgICBfdGhpcy5lbF8uc2V0QXR0cmlidXRlKCdyb2xlJywgJ21lbnVpdGVtY2hlY2tib3gnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF90aGlzLmVsXy5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCAnbWVudWl0ZW1yYWRpbycpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBfdGhpcy5lbF8uc2V0QXR0cmlidXRlKCdyb2xlJywgJ21lbnVpdGVtJyk7XG4gICAgfVxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgdGhlIGBNZW51SXRlbSdzIERPTSBlbGVtZW50XG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbdHlwZT1saV1cbiAgICogICAgICAgIEVsZW1lbnQncyBub2RlIHR5cGUsIG5vdCBhY3R1YWxseSB1c2VkLCBhbHdheXMgc2V0IHRvIGBsaWAuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHM9e31dXG4gICAqICAgICAgICBBbiBvYmplY3Qgb2YgcHJvcGVydGllcyB0aGF0IHNob3VsZCBiZSBzZXQgb24gdGhlIGVsZW1lbnRcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFthdHRycz17fV1cbiAgICogICAgICAgIEFuIG9iamVjdCBvZiBhdHRyaWJ1dGVzIHRoYXQgc2hvdWxkIGJlIHNldCBvbiB0aGUgZWxlbWVudFxuICAgKlxuICAgKiBAcmV0dXJuIHtFbGVtZW50fVxuICAgKiAgICAgICAgIFRoZSBlbGVtZW50IHRoYXQgZ2V0cyBjcmVhdGVkLlxuICAgKi9cblxuXG4gIE1lbnVJdGVtLnByb3RvdHlwZS5jcmVhdGVFbCA9IGZ1bmN0aW9uIGNyZWF0ZUVsKHR5cGUsIHByb3BzLCBhdHRycykge1xuICAgIC8vIFRoZSBjb250cm9sIGlzIHRleHR1YWwsIG5vdCBqdXN0IGFuIGljb25cbiAgICB0aGlzLm5vbkljb25Db250cm9sID0gdHJ1ZTtcblxuICAgIHJldHVybiBfQ2xpY2thYmxlQ29tcG9uZW50LnByb3RvdHlwZS5jcmVhdGVFbC5jYWxsKHRoaXMsICdsaScsIGFzc2lnbih7XG4gICAgICBjbGFzc05hbWU6ICd2anMtbWVudS1pdGVtJyxcbiAgICAgIGlubmVySFRNTDogJzxzcGFuIGNsYXNzPVwidmpzLW1lbnUtaXRlbS10ZXh0XCI+JyArIHRoaXMubG9jYWxpemUodGhpcy5vcHRpb25zXy5sYWJlbCkgKyAnPC9zcGFuPicsXG4gICAgICB0YWJJbmRleDogLTFcbiAgICB9LCBwcm9wcyksIGF0dHJzKTtcbiAgfTtcblxuICAvKipcbiAgICogQW55IGNsaWNrIG9uIGEgYE1lbnVJdGVtYCBwdXRzIGl0IGludG8gdGhlIHNlbGVjdGVkIHN0YXRlLlxuICAgKiBTZWUge0BsaW5rIENsaWNrYWJsZUNvbXBvbmVudCNoYW5kbGVDbGlja30gZm9yIGluc3RhbmNlcyB3aGVyZSB0aGlzIGlzIGNhbGxlZC5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gZXZlbnRcbiAgICogICAgICAgIFRoZSBga2V5ZG93bmAsIGB0YXBgLCBvciBgY2xpY2tgIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgZnVuY3Rpb24gdG8gYmVcbiAgICogICAgICAgIGNhbGxlZC5cbiAgICpcbiAgICogQGxpc3RlbnMgdGFwXG4gICAqIEBsaXN0ZW5zIGNsaWNrXG4gICAqL1xuXG5cbiAgTWVudUl0ZW0ucHJvdG90eXBlLmhhbmRsZUNsaWNrID0gZnVuY3Rpb24gaGFuZGxlQ2xpY2soZXZlbnQpIHtcbiAgICB0aGlzLnNlbGVjdGVkKHRydWUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHN0YXRlIGZvciB0aGlzIG1lbnUgaXRlbSBhcyBzZWxlY3RlZCBvciBub3QuXG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2VsZWN0ZWRcbiAgICogICAgICAgIGlmIHRoZSBtZW51IGl0ZW0gaXMgc2VsZWN0ZWQgb3Igbm90XG4gICAqL1xuXG5cbiAgTWVudUl0ZW0ucHJvdG90eXBlLnNlbGVjdGVkID0gZnVuY3Rpb24gc2VsZWN0ZWQoX3NlbGVjdGVkKSB7XG4gICAgaWYgKHRoaXMuc2VsZWN0YWJsZSkge1xuICAgICAgaWYgKF9zZWxlY3RlZCkge1xuICAgICAgICB0aGlzLmFkZENsYXNzKCd2anMtc2VsZWN0ZWQnKTtcbiAgICAgICAgdGhpcy5lbF8uc2V0QXR0cmlidXRlKCdhcmlhLWNoZWNrZWQnLCAndHJ1ZScpO1xuICAgICAgICAvLyBhcmlhLWNoZWNrZWQgaXNuJ3QgZnVsbHkgc3VwcG9ydGVkIGJ5IGJyb3dzZXJzL3NjcmVlbiByZWFkZXJzLFxuICAgICAgICAvLyBzbyBpbmRpY2F0ZSBzZWxlY3RlZCBzdGF0ZSB0byBzY3JlZW4gcmVhZGVyIGluIHRoZSBjb250cm9sIHRleHQuXG4gICAgICAgIHRoaXMuY29udHJvbFRleHQoJywgc2VsZWN0ZWQnKTtcbiAgICAgICAgdGhpcy5pc1NlbGVjdGVkXyA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnJlbW92ZUNsYXNzKCd2anMtc2VsZWN0ZWQnKTtcbiAgICAgICAgdGhpcy5lbF8uc2V0QXR0cmlidXRlKCdhcmlhLWNoZWNrZWQnLCAnZmFsc2UnKTtcbiAgICAgICAgLy8gSW5kaWNhdGUgdW4tc2VsZWN0ZWQgc3RhdGUgdG8gc2NyZWVuIHJlYWRlclxuICAgICAgICB0aGlzLmNvbnRyb2xUZXh0KCcnKTtcbiAgICAgICAgdGhpcy5pc1NlbGVjdGVkXyA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICByZXR1cm4gTWVudUl0ZW07XG59KENsaWNrYWJsZUNvbXBvbmVudCk7XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnTWVudUl0ZW0nLCBNZW51SXRlbSk7XG5cbi8qKlxuICogQGZpbGUgdGV4dC10cmFjay1tZW51LWl0ZW0uanNcbiAqL1xuLyoqXG4gKiBUaGUgc3BlY2lmaWMgbWVudSBpdGVtIHR5cGUgZm9yIHNlbGVjdGluZyBhIGxhbmd1YWdlIHdpdGhpbiBhIHRleHQgdHJhY2sga2luZFxuICpcbiAqIEBleHRlbmRzIE1lbnVJdGVtXG4gKi9cblxudmFyIFRleHRUcmFja01lbnVJdGVtID0gZnVuY3Rpb24gKF9NZW51SXRlbSkge1xuICBpbmhlcml0cyhUZXh0VHJhY2tNZW51SXRlbSwgX01lbnVJdGVtKTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge1BsYXllcn0gcGxheWVyXG4gICAqICAgICAgICBUaGUgYFBsYXllcmAgdGhhdCB0aGlzIGNsYXNzIHNob3VsZCBiZSBhdHRhY2hlZCB0by5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgICAgICAgVGhlIGtleS92YWx1ZSBzdG9yZSBvZiBwbGF5ZXIgb3B0aW9ucy5cbiAgICovXG4gIGZ1bmN0aW9uIFRleHRUcmFja01lbnVJdGVtKHBsYXllciwgb3B0aW9ucykge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFRleHRUcmFja01lbnVJdGVtKTtcblxuICAgIHZhciB0cmFjayA9IG9wdGlvbnMudHJhY2s7XG4gICAgdmFyIHRyYWNrcyA9IHBsYXllci50ZXh0VHJhY2tzKCk7XG5cbiAgICAvLyBNb2RpZnkgb3B0aW9ucyBmb3IgcGFyZW50IE1lbnVJdGVtIGNsYXNzJ3MgaW5pdC5cbiAgICBvcHRpb25zLmxhYmVsID0gdHJhY2subGFiZWwgfHwgdHJhY2subGFuZ3VhZ2UgfHwgJ1Vua25vd24nO1xuICAgIG9wdGlvbnMuc2VsZWN0ZWQgPSB0cmFjay5tb2RlID09PSAnc2hvd2luZyc7XG5cbiAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9NZW51SXRlbS5jYWxsKHRoaXMsIHBsYXllciwgb3B0aW9ucykpO1xuXG4gICAgX3RoaXMudHJhY2sgPSB0cmFjaztcbiAgICB2YXIgY2hhbmdlSGFuZGxlciA9IGZ1bmN0aW9uIGNoYW5nZUhhbmRsZXIoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuXG4gICAgICBfdGhpcy5oYW5kbGVUcmFja3NDaGFuZ2UuYXBwbHkoX3RoaXMsIGFyZ3MpO1xuICAgIH07XG4gICAgdmFyIHNlbGVjdGVkTGFuZ3VhZ2VDaGFuZ2VIYW5kbGVyID0gZnVuY3Rpb24gc2VsZWN0ZWRMYW5ndWFnZUNoYW5nZUhhbmRsZXIoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuMiksIF9rZXkyID0gMDsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICBhcmdzW19rZXkyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICB9XG5cbiAgICAgIF90aGlzLmhhbmRsZVNlbGVjdGVkTGFuZ3VhZ2VDaGFuZ2UuYXBwbHkoX3RoaXMsIGFyZ3MpO1xuICAgIH07XG5cbiAgICBwbGF5ZXIub24oWydsb2Fkc3RhcnQnLCAndGV4dHRyYWNrY2hhbmdlJ10sIGNoYW5nZUhhbmRsZXIpO1xuICAgIHRyYWNrcy5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBjaGFuZ2VIYW5kbGVyKTtcbiAgICB0cmFja3MuYWRkRXZlbnRMaXN0ZW5lcignc2VsZWN0ZWRsYW5ndWFnZWNoYW5nZScsIHNlbGVjdGVkTGFuZ3VhZ2VDaGFuZ2VIYW5kbGVyKTtcbiAgICBfdGhpcy5vbignZGlzcG9zZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHBsYXllci5vZmYoWydsb2Fkc3RhcnQnLCAndGV4dHRyYWNrY2hhbmdlJ10sIGNoYW5nZUhhbmRsZXIpO1xuICAgICAgdHJhY2tzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIGNoYW5nZUhhbmRsZXIpO1xuICAgICAgdHJhY2tzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3NlbGVjdGVkbGFuZ3VhZ2VjaGFuZ2UnLCBzZWxlY3RlZExhbmd1YWdlQ2hhbmdlSGFuZGxlcik7XG4gICAgfSk7XG5cbiAgICAvLyBpT1M3IGRvZXNuJ3QgZGlzcGF0Y2ggY2hhbmdlIGV2ZW50cyB0byBUZXh0VHJhY2tMaXN0cyB3aGVuIGFuXG4gICAgLy8gYXNzb2NpYXRlZCB0cmFjaydzIG1vZGUgY2hhbmdlcy4gV2l0aG91dCBzb21ldGhpbmcgbGlrZVxuICAgIC8vIE9iamVjdC5vYnNlcnZlKCkgKGFsc28gbm90IHByZXNlbnQgb24gaU9TNyksIGl0J3Mgbm90XG4gICAgLy8gcG9zc2libGUgdG8gZGV0ZWN0IGNoYW5nZXMgdG8gdGhlIG1vZGUgYXR0cmlidXRlIGFuZCBwb2x5ZmlsbFxuICAgIC8vIHRoZSBjaGFuZ2UgZXZlbnQuIEFzIGEgcG9vciBzdWJzdGl0dXRlLCB3ZSBtYW51YWxseSBkaXNwYXRjaFxuICAgIC8vIGNoYW5nZSBldmVudHMgd2hlbmV2ZXIgdGhlIGNvbnRyb2xzIG1vZGlmeSB0aGUgbW9kZS5cbiAgICBpZiAodHJhY2tzLm9uY2hhbmdlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhciBldmVudCA9IHZvaWQgMDtcblxuICAgICAgX3RoaXMub24oWyd0YXAnLCAnY2xpY2snXSwgZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoX3R5cGVvZih3aW5kb3cuRXZlbnQpICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgIC8vIEFuZHJvaWQgMi4zIHRocm93cyBhbiBJbGxlZ2FsIENvbnN0cnVjdG9yIGVycm9yIGZvciB3aW5kb3cuRXZlbnRcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgZXZlbnQgPSBuZXcgd2luZG93LkV2ZW50KCdjaGFuZ2UnKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIC8vIGNvbnRpbnVlIHJlZ2FyZGxlc3Mgb2YgZXJyb3JcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWV2ZW50KSB7XG4gICAgICAgICAgZXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKTtcbiAgICAgICAgICBldmVudC5pbml0RXZlbnQoJ2NoYW5nZScsIHRydWUsIHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdHJhY2tzLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gc2V0IHRoZSBkZWZhdWx0IHN0YXRlIGJhc2VkIG9uIGN1cnJlbnQgdHJhY2tzXG4gICAgX3RoaXMuaGFuZGxlVHJhY2tzQ2hhbmdlKCk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgZ2V0cyBjYWxsZWQgd2hlbiBhbiBgVGV4dFRyYWNrTWVudUl0ZW1gIGlzIFwiY2xpY2tlZFwiLiBTZWVcbiAgICoge0BsaW5rIENsaWNrYWJsZUNvbXBvbmVudH0gZm9yIG1vcmUgZGV0YWlsZWQgaW5mb3JtYXRpb24gb24gd2hhdCBhIGNsaWNrIGNhbiBiZS5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gZXZlbnRcbiAgICogICAgICAgIFRoZSBga2V5ZG93bmAsIGB0YXBgLCBvciBgY2xpY2tgIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgZnVuY3Rpb24gdG8gYmVcbiAgICogICAgICAgIGNhbGxlZC5cbiAgICpcbiAgICogQGxpc3RlbnMgdGFwXG4gICAqIEBsaXN0ZW5zIGNsaWNrXG4gICAqL1xuXG5cbiAgVGV4dFRyYWNrTWVudUl0ZW0ucHJvdG90eXBlLmhhbmRsZUNsaWNrID0gZnVuY3Rpb24gaGFuZGxlQ2xpY2soZXZlbnQpIHtcbiAgICB2YXIga2luZCA9IHRoaXMudHJhY2sua2luZDtcbiAgICB2YXIga2luZHMgPSB0aGlzLnRyYWNrLmtpbmRzO1xuICAgIHZhciB0cmFja3MgPSB0aGlzLnBsYXllcl8udGV4dFRyYWNrcygpO1xuXG4gICAgaWYgKCFraW5kcykge1xuICAgICAga2luZHMgPSBba2luZF07XG4gICAgfVxuXG4gICAgX01lbnVJdGVtLnByb3RvdHlwZS5oYW5kbGVDbGljay5jYWxsKHRoaXMsIGV2ZW50KTtcblxuICAgIGlmICghdHJhY2tzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB0cmFjayA9IHRyYWNrc1tpXTtcblxuICAgICAgaWYgKHRyYWNrID09PSB0aGlzLnRyYWNrICYmIGtpbmRzLmluZGV4T2YodHJhY2sua2luZCkgPiAtMSkge1xuICAgICAgICBpZiAodHJhY2subW9kZSAhPT0gJ3Nob3dpbmcnKSB7XG4gICAgICAgICAgdHJhY2subW9kZSA9ICdzaG93aW5nJztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0cmFjay5tb2RlICE9PSAnZGlzYWJsZWQnKSB7XG4gICAgICAgIHRyYWNrLm1vZGUgPSAnZGlzYWJsZWQnO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogSGFuZGxlIHRleHQgdHJhY2sgbGlzdCBjaGFuZ2VcbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gZXZlbnRcbiAgICogICAgICAgIFRoZSBgY2hhbmdlYCBldmVudCB0aGF0IGNhdXNlZCB0aGlzIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZC5cbiAgICpcbiAgICogQGxpc3RlbnMgVGV4dFRyYWNrTGlzdCNjaGFuZ2VcbiAgICovXG5cblxuICBUZXh0VHJhY2tNZW51SXRlbS5wcm90b3R5cGUuaGFuZGxlVHJhY2tzQ2hhbmdlID0gZnVuY3Rpb24gaGFuZGxlVHJhY2tzQ2hhbmdlKGV2ZW50KSB7XG4gICAgdmFyIHNob3VsZEJlU2VsZWN0ZWQgPSB0aGlzLnRyYWNrLm1vZGUgPT09ICdzaG93aW5nJztcblxuICAgIC8vIFByZXZlbnQgcmVkdW5kYW50IHNlbGVjdGVkKCkgY2FsbHMgYmVjYXVzZSB0aGV5IG1heSBjYXVzZVxuICAgIC8vIHNjcmVlbiByZWFkZXJzIHRvIHJlYWQgdGhlIGFwcGVuZGVkIGNvbnRyb2wgdGV4dCB1bm5lY2Vzc2FyaWx5XG4gICAgaWYgKHNob3VsZEJlU2VsZWN0ZWQgIT09IHRoaXMuaXNTZWxlY3RlZF8pIHtcbiAgICAgIHRoaXMuc2VsZWN0ZWQoc2hvdWxkQmVTZWxlY3RlZCk7XG4gICAgfVxuICB9O1xuXG4gIFRleHRUcmFja01lbnVJdGVtLnByb3RvdHlwZS5oYW5kbGVTZWxlY3RlZExhbmd1YWdlQ2hhbmdlID0gZnVuY3Rpb24gaGFuZGxlU2VsZWN0ZWRMYW5ndWFnZUNoYW5nZShldmVudCkge1xuICAgIGlmICh0aGlzLnRyYWNrLm1vZGUgPT09ICdzaG93aW5nJykge1xuICAgICAgdmFyIHNlbGVjdGVkTGFuZ3VhZ2UgPSB0aGlzLnBsYXllcl8uY2FjaGVfLnNlbGVjdGVkTGFuZ3VhZ2U7XG5cbiAgICAgIC8vIERvbid0IHJlcGxhY2UgdGhlIGtpbmQgb2YgdHJhY2sgYWNyb3NzIHRoZSBzYW1lIGxhbmd1YWdlXG4gICAgICBpZiAoc2VsZWN0ZWRMYW5ndWFnZSAmJiBzZWxlY3RlZExhbmd1YWdlLmVuYWJsZWQgJiYgc2VsZWN0ZWRMYW5ndWFnZS5sYW5ndWFnZSA9PT0gdGhpcy50cmFjay5sYW5ndWFnZSAmJiBzZWxlY3RlZExhbmd1YWdlLmtpbmQgIT09IHRoaXMudHJhY2sua2luZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMucGxheWVyXy5jYWNoZV8uc2VsZWN0ZWRMYW5ndWFnZSA9IHtcbiAgICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgbGFuZ3VhZ2U6IHRoaXMudHJhY2subGFuZ3VhZ2UsXG4gICAgICAgIGtpbmQ6IHRoaXMudHJhY2sua2luZFxuICAgICAgfTtcbiAgICB9XG4gIH07XG5cbiAgVGV4dFRyYWNrTWVudUl0ZW0ucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiBkaXNwb3NlKCkge1xuICAgIC8vIHJlbW92ZSByZWZlcmVuY2UgdG8gdHJhY2sgb2JqZWN0IG9uIGRpc3Bvc2VcbiAgICB0aGlzLnRyYWNrID0gbnVsbDtcblxuICAgIF9NZW51SXRlbS5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuICB9O1xuXG4gIHJldHVybiBUZXh0VHJhY2tNZW51SXRlbTtcbn0oTWVudUl0ZW0pO1xuXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ1RleHRUcmFja01lbnVJdGVtJywgVGV4dFRyYWNrTWVudUl0ZW0pO1xuXG4vKipcbiAqIEBmaWxlIG9mZi10ZXh0LXRyYWNrLW1lbnUtaXRlbS5qc1xuICovXG4vKipcbiAqIEEgc3BlY2lhbCBtZW51IGl0ZW0gZm9yIHR1cm5pbmcgb2YgYSBzcGVjaWZpYyB0eXBlIG9mIHRleHQgdHJhY2tcbiAqXG4gKiBAZXh0ZW5kcyBUZXh0VHJhY2tNZW51SXRlbVxuICovXG5cbnZhciBPZmZUZXh0VHJhY2tNZW51SXRlbSA9IGZ1bmN0aW9uIChfVGV4dFRyYWNrTWVudUl0ZW0pIHtcbiAgaW5oZXJpdHMoT2ZmVGV4dFRyYWNrTWVudUl0ZW0sIF9UZXh0VHJhY2tNZW51SXRlbSk7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcy5cbiAgICpcbiAgICogQHBhcmFtIHtQbGF5ZXJ9IHBsYXllclxuICAgKiAgICAgICAgVGhlIGBQbGF5ZXJgIHRoYXQgdGhpcyBjbGFzcyBzaG91bGQgYmUgYXR0YWNoZWQgdG8uXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICAgICAgIFRoZSBrZXkvdmFsdWUgc3RvcmUgb2YgcGxheWVyIG9wdGlvbnMuXG4gICAqL1xuICBmdW5jdGlvbiBPZmZUZXh0VHJhY2tNZW51SXRlbShwbGF5ZXIsIG9wdGlvbnMpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBPZmZUZXh0VHJhY2tNZW51SXRlbSk7XG5cbiAgICAvLyBDcmVhdGUgcHNldWRvIHRyYWNrIGluZm9cbiAgICAvLyBSZXF1aXJlcyBvcHRpb25zWydraW5kJ11cbiAgICBvcHRpb25zLnRyYWNrID0ge1xuICAgICAgcGxheWVyOiBwbGF5ZXIsXG4gICAgICBraW5kOiBvcHRpb25zLmtpbmQsXG4gICAgICBraW5kczogb3B0aW9ucy5raW5kcyxcbiAgICAgICdkZWZhdWx0JzogZmFsc2UsXG4gICAgICBtb2RlOiAnZGlzYWJsZWQnXG4gICAgfTtcblxuICAgIGlmICghb3B0aW9ucy5raW5kcykge1xuICAgICAgb3B0aW9ucy5raW5kcyA9IFtvcHRpb25zLmtpbmRdO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmxhYmVsKSB7XG4gICAgICBvcHRpb25zLnRyYWNrLmxhYmVsID0gb3B0aW9ucy5sYWJlbDtcbiAgICB9IGVsc2Uge1xuICAgICAgb3B0aW9ucy50cmFjay5sYWJlbCA9IG9wdGlvbnMua2luZHMuam9pbignIGFuZCAnKSArICcgb2ZmJztcbiAgICB9XG5cbiAgICAvLyBNZW51SXRlbSBpcyBzZWxlY3RhYmxlXG4gICAgb3B0aW9ucy5zZWxlY3RhYmxlID0gdHJ1ZTtcbiAgICAvLyBNZW51SXRlbSBpcyBOT1QgbXVsdGlTZWxlY3RhYmxlIChpLmUuIG9ubHkgb25lIGNhbiBiZSBtYXJrZWQgXCJzZWxlY3RlZFwiIGF0IGEgdGltZSlcbiAgICBvcHRpb25zLm11bHRpU2VsZWN0YWJsZSA9IGZhbHNlO1xuXG4gICAgcmV0dXJuIHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1RleHRUcmFja01lbnVJdGVtLmNhbGwodGhpcywgcGxheWVyLCBvcHRpb25zKSk7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlIHRleHQgdHJhY2sgY2hhbmdlXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IGV2ZW50XG4gICAqICAgICAgICBUaGUgZXZlbnQgdGhhdCBjYXVzZWQgdGhpcyBmdW5jdGlvbiB0byBydW5cbiAgICovXG5cblxuICBPZmZUZXh0VHJhY2tNZW51SXRlbS5wcm90b3R5cGUuaGFuZGxlVHJhY2tzQ2hhbmdlID0gZnVuY3Rpb24gaGFuZGxlVHJhY2tzQ2hhbmdlKGV2ZW50KSB7XG4gICAgdmFyIHRyYWNrcyA9IHRoaXMucGxheWVyKCkudGV4dFRyYWNrcygpO1xuICAgIHZhciBzaG91bGRCZVNlbGVjdGVkID0gdHJ1ZTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gdHJhY2tzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIHRyYWNrID0gdHJhY2tzW2ldO1xuXG4gICAgICBpZiAodGhpcy5vcHRpb25zXy5raW5kcy5pbmRleE9mKHRyYWNrLmtpbmQpID4gLTEgJiYgdHJhY2subW9kZSA9PT0gJ3Nob3dpbmcnKSB7XG4gICAgICAgIHNob3VsZEJlU2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUHJldmVudCByZWR1bmRhbnQgc2VsZWN0ZWQoKSBjYWxscyBiZWNhdXNlIHRoZXkgbWF5IGNhdXNlXG4gICAgLy8gc2NyZWVuIHJlYWRlcnMgdG8gcmVhZCB0aGUgYXBwZW5kZWQgY29udHJvbCB0ZXh0IHVubmVjZXNzYXJpbHlcbiAgICBpZiAoc2hvdWxkQmVTZWxlY3RlZCAhPT0gdGhpcy5pc1NlbGVjdGVkXykge1xuICAgICAgdGhpcy5zZWxlY3RlZChzaG91bGRCZVNlbGVjdGVkKTtcbiAgICB9XG4gIH07XG5cbiAgT2ZmVGV4dFRyYWNrTWVudUl0ZW0ucHJvdG90eXBlLmhhbmRsZVNlbGVjdGVkTGFuZ3VhZ2VDaGFuZ2UgPSBmdW5jdGlvbiBoYW5kbGVTZWxlY3RlZExhbmd1YWdlQ2hhbmdlKGV2ZW50KSB7XG4gICAgdmFyIHRyYWNrcyA9IHRoaXMucGxheWVyKCkudGV4dFRyYWNrcygpO1xuICAgIHZhciBhbGxIaWRkZW4gPSB0cnVlO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSB0cmFja3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgdHJhY2sgPSB0cmFja3NbaV07XG5cbiAgICAgIGlmIChbJ2NhcHRpb25zJywgJ2Rlc2NyaXB0aW9ucycsICdzdWJ0aXRsZXMnXS5pbmRleE9mKHRyYWNrLmtpbmQpID4gLTEgJiYgdHJhY2subW9kZSA9PT0gJ3Nob3dpbmcnKSB7XG4gICAgICAgIGFsbEhpZGRlbiA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoYWxsSGlkZGVuKSB7XG4gICAgICB0aGlzLnBsYXllcl8uY2FjaGVfLnNlbGVjdGVkTGFuZ3VhZ2UgPSB7XG4gICAgICAgIGVuYWJsZWQ6IGZhbHNlXG4gICAgICB9O1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gT2ZmVGV4dFRyYWNrTWVudUl0ZW07XG59KFRleHRUcmFja01lbnVJdGVtKTtcblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdPZmZUZXh0VHJhY2tNZW51SXRlbScsIE9mZlRleHRUcmFja01lbnVJdGVtKTtcblxuLyoqXG4gKiBAZmlsZSB0ZXh0LXRyYWNrLWJ1dHRvbi5qc1xuICovXG4vKipcbiAqIFRoZSBiYXNlIGNsYXNzIGZvciBidXR0b25zIHRoYXQgdG9nZ2xlIHNwZWNpZmljIHRleHQgdHJhY2sgdHlwZXMgKGUuZy4gc3VidGl0bGVzKVxuICpcbiAqIEBleHRlbmRzIE1lbnVCdXR0b25cbiAqL1xuXG52YXIgVGV4dFRyYWNrQnV0dG9uID0gZnVuY3Rpb24gKF9UcmFja0J1dHRvbikge1xuICBpbmhlcml0cyhUZXh0VHJhY2tCdXR0b24sIF9UcmFja0J1dHRvbik7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcy5cbiAgICpcbiAgICogQHBhcmFtIHtQbGF5ZXJ9IHBsYXllclxuICAgKiAgICAgICAgVGhlIGBQbGF5ZXJgIHRoYXQgdGhpcyBjbGFzcyBzaG91bGQgYmUgYXR0YWNoZWQgdG8uXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV1cbiAgICogICAgICAgIFRoZSBrZXkvdmFsdWUgc3RvcmUgb2YgcGxheWVyIG9wdGlvbnMuXG4gICAqL1xuICBmdW5jdGlvbiBUZXh0VHJhY2tCdXR0b24ocGxheWVyKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFRleHRUcmFja0J1dHRvbik7XG5cbiAgICBvcHRpb25zLnRyYWNrcyA9IHBsYXllci50ZXh0VHJhY2tzKCk7XG5cbiAgICByZXR1cm4gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfVHJhY2tCdXR0b24uY2FsbCh0aGlzLCBwbGF5ZXIsIG9wdGlvbnMpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBtZW51IGl0ZW0gZm9yIGVhY2ggdGV4dCB0cmFja1xuICAgKlxuICAgKiBAcGFyYW0ge1RleHRUcmFja01lbnVJdGVtW119IFtpdGVtcz1bXV1cbiAgICogICAgICAgIEV4aXN0aW5nIGFycmF5IG9mIGl0ZW1zIHRvIHVzZSBkdXJpbmcgY3JlYXRpb25cbiAgICpcbiAgICogQHJldHVybiB7VGV4dFRyYWNrTWVudUl0ZW1bXX1cbiAgICogICAgICAgICBBcnJheSBvZiBtZW51IGl0ZW1zIHRoYXQgd2VyZSBjcmVhdGVkXG4gICAqL1xuXG5cbiAgVGV4dFRyYWNrQnV0dG9uLnByb3RvdHlwZS5jcmVhdGVJdGVtcyA9IGZ1bmN0aW9uIGNyZWF0ZUl0ZW1zKCkge1xuICAgIHZhciBpdGVtcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogW107XG4gICAgdmFyIFRyYWNrTWVudUl0ZW0gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IFRleHRUcmFja01lbnVJdGVtO1xuXG5cbiAgICAvLyBMYWJlbCBpcyBhbiBvdmVyaWRlIGZvciB0aGUgW3RyYWNrXSBvZmYgbGFiZWxcbiAgICAvLyBVU2VkIHRvIGxvY2FsaXNlIGNhcHRpb25zL3N1YnRpdGxlc1xuICAgIHZhciBsYWJlbCA9IHZvaWQgMDtcblxuICAgIGlmICh0aGlzLmxhYmVsXykge1xuICAgICAgbGFiZWwgPSB0aGlzLmxhYmVsXyArICcgb2ZmJztcbiAgICB9XG4gICAgLy8gQWRkIGFuIE9GRiBtZW51IGl0ZW0gdG8gdHVybiBhbGwgdHJhY2tzIG9mZlxuICAgIGl0ZW1zLnB1c2gobmV3IE9mZlRleHRUcmFja01lbnVJdGVtKHRoaXMucGxheWVyXywge1xuICAgICAga2luZHM6IHRoaXMua2luZHNfLFxuICAgICAga2luZDogdGhpcy5raW5kXyxcbiAgICAgIGxhYmVsOiBsYWJlbFxuICAgIH0pKTtcblxuICAgIHRoaXMuaGlkZVRocmVzaG9sZF8gKz0gMTtcblxuICAgIHZhciB0cmFja3MgPSB0aGlzLnBsYXllcl8udGV4dFRyYWNrcygpO1xuXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHRoaXMua2luZHNfKSkge1xuICAgICAgdGhpcy5raW5kc18gPSBbdGhpcy5raW5kX107XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB0cmFjayA9IHRyYWNrc1tpXTtcblxuICAgICAgLy8gb25seSBhZGQgdHJhY2tzIHRoYXQgYXJlIG9mIGFuIGFwcHJvcHJpYXRlIGtpbmQgYW5kIGhhdmUgYSBsYWJlbFxuICAgICAgaWYgKHRoaXMua2luZHNfLmluZGV4T2YodHJhY2sua2luZCkgPiAtMSkge1xuXG4gICAgICAgIHZhciBpdGVtID0gbmV3IFRyYWNrTWVudUl0ZW0odGhpcy5wbGF5ZXJfLCB7XG4gICAgICAgICAgdHJhY2s6IHRyYWNrLFxuICAgICAgICAgIC8vIE1lbnVJdGVtIGlzIHNlbGVjdGFibGVcbiAgICAgICAgICBzZWxlY3RhYmxlOiB0cnVlLFxuICAgICAgICAgIC8vIE1lbnVJdGVtIGlzIE5PVCBtdWx0aVNlbGVjdGFibGUgKGkuZS4gb25seSBvbmUgY2FuIGJlIG1hcmtlZCBcInNlbGVjdGVkXCIgYXQgYSB0aW1lKVxuICAgICAgICAgIG11bHRpU2VsZWN0YWJsZTogZmFsc2VcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXRlbS5hZGRDbGFzcygndmpzLScgKyB0cmFjay5raW5kICsgJy1tZW51LWl0ZW0nKTtcbiAgICAgICAgaXRlbXMucHVzaChpdGVtKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaXRlbXM7XG4gIH07XG5cbiAgcmV0dXJuIFRleHRUcmFja0J1dHRvbjtcbn0oVHJhY2tCdXR0b24pO1xuXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ1RleHRUcmFja0J1dHRvbicsIFRleHRUcmFja0J1dHRvbik7XG5cbi8qKlxuICogQGZpbGUgY2hhcHRlcnMtdHJhY2stbWVudS1pdGVtLmpzXG4gKi9cbi8qKlxuICogVGhlIGNoYXB0ZXIgdHJhY2sgbWVudSBpdGVtXG4gKlxuICogQGV4dGVuZHMgTWVudUl0ZW1cbiAqL1xuXG52YXIgQ2hhcHRlcnNUcmFja01lbnVJdGVtID0gZnVuY3Rpb24gKF9NZW51SXRlbSkge1xuICBpbmhlcml0cyhDaGFwdGVyc1RyYWNrTWVudUl0ZW0sIF9NZW51SXRlbSk7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcy5cbiAgICpcbiAgICogQHBhcmFtIHtQbGF5ZXJ9IHBsYXllclxuICAgKiAgICAgICAgVGhlIGBQbGF5ZXJgIHRoYXQgdGhpcyBjbGFzcyBzaG91bGQgYmUgYXR0YWNoZWQgdG8uXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICAgICAgIFRoZSBrZXkvdmFsdWUgc3RvcmUgb2YgcGxheWVyIG9wdGlvbnMuXG4gICAqL1xuICBmdW5jdGlvbiBDaGFwdGVyc1RyYWNrTWVudUl0ZW0ocGxheWVyLCBvcHRpb25zKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgQ2hhcHRlcnNUcmFja01lbnVJdGVtKTtcblxuICAgIHZhciB0cmFjayA9IG9wdGlvbnMudHJhY2s7XG4gICAgdmFyIGN1ZSA9IG9wdGlvbnMuY3VlO1xuICAgIHZhciBjdXJyZW50VGltZSA9IHBsYXllci5jdXJyZW50VGltZSgpO1xuXG4gICAgLy8gTW9kaWZ5IG9wdGlvbnMgZm9yIHBhcmVudCBNZW51SXRlbSBjbGFzcydzIGluaXQuXG4gICAgb3B0aW9ucy5zZWxlY3RhYmxlID0gdHJ1ZTtcbiAgICBvcHRpb25zLm11bHRpU2VsZWN0YWJsZSA9IGZhbHNlO1xuICAgIG9wdGlvbnMubGFiZWwgPSBjdWUudGV4dDtcbiAgICBvcHRpb25zLnNlbGVjdGVkID0gY3VlLnN0YXJ0VGltZSA8PSBjdXJyZW50VGltZSAmJiBjdXJyZW50VGltZSA8IGN1ZS5lbmRUaW1lO1xuXG4gICAgdmFyIF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfTWVudUl0ZW0uY2FsbCh0aGlzLCBwbGF5ZXIsIG9wdGlvbnMpKTtcblxuICAgIF90aGlzLnRyYWNrID0gdHJhY2s7XG4gICAgX3RoaXMuY3VlID0gY3VlO1xuICAgIHRyYWNrLmFkZEV2ZW50TGlzdGVuZXIoJ2N1ZWNoYW5nZScsIGJpbmQoX3RoaXMsIF90aGlzLnVwZGF0ZSkpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIGdldHMgY2FsbGVkIHdoZW4gYW4gYENoYXB0ZXJzVHJhY2tNZW51SXRlbWAgaXMgXCJjbGlja2VkXCIuIFNlZVxuICAgKiB7QGxpbmsgQ2xpY2thYmxlQ29tcG9uZW50fSBmb3IgbW9yZSBkZXRhaWxlZCBpbmZvcm1hdGlvbiBvbiB3aGF0IGEgY2xpY2sgY2FuIGJlLlxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBbZXZlbnRdXG4gICAqICAgICAgICBUaGUgYGtleWRvd25gLCBgdGFwYCwgb3IgYGNsaWNrYCBldmVudCB0aGF0IGNhdXNlZCB0aGlzIGZ1bmN0aW9uIHRvIGJlXG4gICAqICAgICAgICBjYWxsZWQuXG4gICAqXG4gICAqIEBsaXN0ZW5zIHRhcFxuICAgKiBAbGlzdGVucyBjbGlja1xuICAgKi9cblxuXG4gIENoYXB0ZXJzVHJhY2tNZW51SXRlbS5wcm90b3R5cGUuaGFuZGxlQ2xpY2sgPSBmdW5jdGlvbiBoYW5kbGVDbGljayhldmVudCkge1xuICAgIF9NZW51SXRlbS5wcm90b3R5cGUuaGFuZGxlQ2xpY2suY2FsbCh0aGlzKTtcbiAgICB0aGlzLnBsYXllcl8uY3VycmVudFRpbWUodGhpcy5jdWUuc3RhcnRUaW1lKTtcbiAgICB0aGlzLnVwZGF0ZSh0aGlzLmN1ZS5zdGFydFRpbWUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBVcGRhdGUgY2hhcHRlciBtZW51IGl0ZW1cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gW2V2ZW50XVxuICAgKiAgICAgICAgVGhlIGBjdWVjaGFuZ2VgIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgZnVuY3Rpb24gdG8gcnVuLlxuICAgKlxuICAgKiBAbGlzdGVucyBUZXh0VHJhY2sjY3VlY2hhbmdlXG4gICAqL1xuXG5cbiAgQ2hhcHRlcnNUcmFja01lbnVJdGVtLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUoZXZlbnQpIHtcbiAgICB2YXIgY3VlID0gdGhpcy5jdWU7XG4gICAgdmFyIGN1cnJlbnRUaW1lID0gdGhpcy5wbGF5ZXJfLmN1cnJlbnRUaW1lKCk7XG5cbiAgICAvLyB2anMubG9nKGN1cnJlbnRUaW1lLCBjdWUuc3RhcnRUaW1lKTtcbiAgICB0aGlzLnNlbGVjdGVkKGN1ZS5zdGFydFRpbWUgPD0gY3VycmVudFRpbWUgJiYgY3VycmVudFRpbWUgPCBjdWUuZW5kVGltZSk7XG4gIH07XG5cbiAgcmV0dXJuIENoYXB0ZXJzVHJhY2tNZW51SXRlbTtcbn0oTWVudUl0ZW0pO1xuXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ0NoYXB0ZXJzVHJhY2tNZW51SXRlbScsIENoYXB0ZXJzVHJhY2tNZW51SXRlbSk7XG5cbi8qKlxuICogQGZpbGUgY2hhcHRlcnMtYnV0dG9uLmpzXG4gKi9cbi8qKlxuICogVGhlIGJ1dHRvbiBjb21wb25lbnQgZm9yIHRvZ2dsaW5nIGFuZCBzZWxlY3RpbmcgY2hhcHRlcnNcbiAqIENoYXB0ZXJzIGFjdCBtdWNoIGRpZmZlcmVudGx5IHRoYW4gb3RoZXIgdGV4dCB0cmFja3NcbiAqIEN1ZXMgYXJlIG5hdmlnYXRpb24gdnMuIG90aGVyIHRyYWNrcyBvZiBhbHRlcm5hdGl2ZSBsYW5ndWFnZXNcbiAqXG4gKiBAZXh0ZW5kcyBUZXh0VHJhY2tCdXR0b25cbiAqL1xuXG52YXIgQ2hhcHRlcnNCdXR0b24gPSBmdW5jdGlvbiAoX1RleHRUcmFja0J1dHRvbikge1xuICBpbmhlcml0cyhDaGFwdGVyc0J1dHRvbiwgX1RleHRUcmFja0J1dHRvbik7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcy5cbiAgICpcbiAgICogQHBhcmFtIHtQbGF5ZXJ9IHBsYXllclxuICAgKiAgICAgICAgVGhlIGBQbGF5ZXJgIHRoYXQgdGhpcyBjbGFzcyBzaG91bGQgYmUgYXR0YWNoZWQgdG8uXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICAgICAgIFRoZSBrZXkvdmFsdWUgc3RvcmUgb2YgcGxheWVyIG9wdGlvbnMuXG4gICAqXG4gICAqIEBwYXJhbSB7Q29tcG9uZW50flJlYWR5Q2FsbGJhY2t9IFtyZWFkeV1cbiAgICogICAgICAgIFRoZSBmdW5jdGlvbiB0byBjYWxsIHdoZW4gdGhpcyBmdW5jdGlvbiBpcyByZWFkeS5cbiAgICovXG4gIGZ1bmN0aW9uIENoYXB0ZXJzQnV0dG9uKHBsYXllciwgb3B0aW9ucywgcmVhZHkpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBDaGFwdGVyc0J1dHRvbik7XG4gICAgcmV0dXJuIHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1RleHRUcmFja0J1dHRvbi5jYWxsKHRoaXMsIHBsYXllciwgb3B0aW9ucywgcmVhZHkpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBCdWlsZHMgdGhlIGRlZmF1bHQgRE9NIGBjbGFzc05hbWVgLlxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqICAgICAgICAgVGhlIERPTSBgY2xhc3NOYW1lYCBmb3IgdGhpcyBvYmplY3QuXG4gICAqL1xuXG5cbiAgQ2hhcHRlcnNCdXR0b24ucHJvdG90eXBlLmJ1aWxkQ1NTQ2xhc3MgPSBmdW5jdGlvbiBidWlsZENTU0NsYXNzKCkge1xuICAgIHJldHVybiAndmpzLWNoYXB0ZXJzLWJ1dHRvbiAnICsgX1RleHRUcmFja0J1dHRvbi5wcm90b3R5cGUuYnVpbGRDU1NDbGFzcy5jYWxsKHRoaXMpO1xuICB9O1xuXG4gIENoYXB0ZXJzQnV0dG9uLnByb3RvdHlwZS5idWlsZFdyYXBwZXJDU1NDbGFzcyA9IGZ1bmN0aW9uIGJ1aWxkV3JhcHBlckNTU0NsYXNzKCkge1xuICAgIHJldHVybiAndmpzLWNoYXB0ZXJzLWJ1dHRvbiAnICsgX1RleHRUcmFja0J1dHRvbi5wcm90b3R5cGUuYnVpbGRXcmFwcGVyQ1NTQ2xhc3MuY2FsbCh0aGlzKTtcbiAgfTtcblxuICAvKipcbiAgICogVXBkYXRlIHRoZSBtZW51IGJhc2VkIG9uIHRoZSBjdXJyZW50IHN0YXRlIG9mIGl0cyBpdGVtcy5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gW2V2ZW50XVxuICAgKiAgICAgICAgQW4gZXZlbnQgdGhhdCB0cmlnZ2VyZWQgdGhpcyBmdW5jdGlvbiB0byBydW4uXG4gICAqXG4gICAqIEBsaXN0ZW5zIFRleHRUcmFja0xpc3QjYWRkdHJhY2tcbiAgICogQGxpc3RlbnMgVGV4dFRyYWNrTGlzdCNyZW1vdmV0cmFja1xuICAgKiBAbGlzdGVucyBUZXh0VHJhY2tMaXN0I2NoYW5nZVxuICAgKi9cblxuXG4gIENoYXB0ZXJzQnV0dG9uLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUoZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMudHJhY2tfIHx8IGV2ZW50ICYmIChldmVudC50eXBlID09PSAnYWRkdHJhY2snIHx8IGV2ZW50LnR5cGUgPT09ICdyZW1vdmV0cmFjaycpKSB7XG4gICAgICB0aGlzLnNldFRyYWNrKHRoaXMuZmluZENoYXB0ZXJzVHJhY2soKSk7XG4gICAgfVxuICAgIF9UZXh0VHJhY2tCdXR0b24ucHJvdG90eXBlLnVwZGF0ZS5jYWxsKHRoaXMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGN1cnJlbnRseSBzZWxlY3RlZCB0cmFjayBmb3IgdGhlIGNoYXB0ZXJzIGJ1dHRvbi5cbiAgICpcbiAgICogQHBhcmFtIHtUZXh0VHJhY2t9IHRyYWNrXG4gICAqICAgICAgICBUaGUgbmV3IHRyYWNrIHRvIHNlbGVjdC4gTm90aGluZyB3aWxsIGNoYW5nZSBpZiB0aGlzIGlzIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWRcbiAgICogICAgICAgIHRyYWNrLlxuICAgKi9cblxuXG4gIENoYXB0ZXJzQnV0dG9uLnByb3RvdHlwZS5zZXRUcmFjayA9IGZ1bmN0aW9uIHNldFRyYWNrKHRyYWNrKSB7XG4gICAgaWYgKHRoaXMudHJhY2tfID09PSB0cmFjaykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghdGhpcy51cGRhdGVIYW5kbGVyXykge1xuICAgICAgdGhpcy51cGRhdGVIYW5kbGVyXyA9IHRoaXMudXBkYXRlLmJpbmQodGhpcyk7XG4gICAgfVxuXG4gICAgLy8gaGVyZSB0aGlzLnRyYWNrXyByZWZlcnMgdG8gdGhlIG9sZCB0cmFjayBpbnN0YW5jZVxuICAgIGlmICh0aGlzLnRyYWNrXykge1xuICAgICAgdmFyIHJlbW90ZVRleHRUcmFja0VsID0gdGhpcy5wbGF5ZXJfLnJlbW90ZVRleHRUcmFja0VscygpLmdldFRyYWNrRWxlbWVudEJ5VHJhY2tfKHRoaXMudHJhY2tfKTtcblxuICAgICAgaWYgKHJlbW90ZVRleHRUcmFja0VsKSB7XG4gICAgICAgIHJlbW90ZVRleHRUcmFja0VsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2xvYWQnLCB0aGlzLnVwZGF0ZUhhbmRsZXJfKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy50cmFja18gPSBudWxsO1xuICAgIH1cblxuICAgIHRoaXMudHJhY2tfID0gdHJhY2s7XG5cbiAgICAvLyBoZXJlIHRoaXMudHJhY2tfIHJlZmVycyB0byB0aGUgbmV3IHRyYWNrIGluc3RhbmNlXG4gICAgaWYgKHRoaXMudHJhY2tfKSB7XG4gICAgICB0aGlzLnRyYWNrXy5tb2RlID0gJ2hpZGRlbic7XG5cbiAgICAgIHZhciBfcmVtb3RlVGV4dFRyYWNrRWwgPSB0aGlzLnBsYXllcl8ucmVtb3RlVGV4dFRyYWNrRWxzKCkuZ2V0VHJhY2tFbGVtZW50QnlUcmFja18odGhpcy50cmFja18pO1xuXG4gICAgICBpZiAoX3JlbW90ZVRleHRUcmFja0VsKSB7XG4gICAgICAgIF9yZW1vdGVUZXh0VHJhY2tFbC5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgdGhpcy51cGRhdGVIYW5kbGVyXyk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBGaW5kIHRoZSB0cmFjayBvYmplY3QgdGhhdCBpcyBjdXJyZW50bHkgaW4gdXNlIGJ5IHRoaXMgQ2hhcHRlcnNCdXR0b25cbiAgICpcbiAgICogQHJldHVybiB7VGV4dFRyYWNrfHVuZGVmaW5lZH1cbiAgICogICAgICAgICBUaGUgY3VycmVudCB0cmFjayBvciB1bmRlZmluZWQgaWYgbm9uZSB3YXMgZm91bmQuXG4gICAqL1xuXG5cbiAgQ2hhcHRlcnNCdXR0b24ucHJvdG90eXBlLmZpbmRDaGFwdGVyc1RyYWNrID0gZnVuY3Rpb24gZmluZENoYXB0ZXJzVHJhY2soKSB7XG4gICAgdmFyIHRyYWNrcyA9IHRoaXMucGxheWVyXy50ZXh0VHJhY2tzKCkgfHwgW107XG5cbiAgICBmb3IgKHZhciBpID0gdHJhY2tzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAvLyBXZSB3aWxsIGFsd2F5cyBjaG9vc2UgdGhlIGxhc3QgdHJhY2sgYXMgb3VyIGNoYXB0ZXJzVHJhY2tcbiAgICAgIHZhciB0cmFjayA9IHRyYWNrc1tpXTtcblxuICAgICAgaWYgKHRyYWNrLmtpbmQgPT09IHRoaXMua2luZF8pIHtcbiAgICAgICAgcmV0dXJuIHRyYWNrO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSBjYXB0aW9uIGZvciB0aGUgQ2hhcHRlcnNCdXR0b24gYmFzZWQgb24gdGhlIHRyYWNrIGxhYmVsLiBUaGlzIHdpbGwgYWxzb1xuICAgKiB1c2UgdGhlIGN1cnJlbnQgdHJhY2tzIGxvY2FsaXplZCBraW5kIGFzIGEgZmFsbGJhY2sgaWYgYSBsYWJlbCBkb2VzIG5vdCBleGlzdC5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKiAgICAgICAgIFRoZSB0cmFja3MgY3VycmVudCBsYWJlbCBvciB0aGUgbG9jYWxpemVkIHRyYWNrIGtpbmQuXG4gICAqL1xuXG5cbiAgQ2hhcHRlcnNCdXR0b24ucHJvdG90eXBlLmdldE1lbnVDYXB0aW9uID0gZnVuY3Rpb24gZ2V0TWVudUNhcHRpb24oKSB7XG4gICAgaWYgKHRoaXMudHJhY2tfICYmIHRoaXMudHJhY2tfLmxhYmVsKSB7XG4gICAgICByZXR1cm4gdGhpcy50cmFja18ubGFiZWw7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmxvY2FsaXplKHRvVGl0bGVDYXNlKHRoaXMua2luZF8pKTtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlIG1lbnUgZnJvbSBjaGFwdGVyIHRyYWNrXG4gICAqXG4gICAqIEByZXR1cm4ge01lbnV9XG4gICAqICAgICAgICAgTmV3IG1lbnUgZm9yIHRoZSBjaGFwdGVyIGJ1dHRvbnNcbiAgICovXG5cblxuICBDaGFwdGVyc0J1dHRvbi5wcm90b3R5cGUuY3JlYXRlTWVudSA9IGZ1bmN0aW9uIGNyZWF0ZU1lbnUoKSB7XG4gICAgdGhpcy5vcHRpb25zXy50aXRsZSA9IHRoaXMuZ2V0TWVudUNhcHRpb24oKTtcbiAgICByZXR1cm4gX1RleHRUcmFja0J1dHRvbi5wcm90b3R5cGUuY3JlYXRlTWVudS5jYWxsKHRoaXMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBtZW51IGl0ZW0gZm9yIGVhY2ggdGV4dCB0cmFja1xuICAgKlxuICAgKiBAcmV0dXJuIHtUZXh0VHJhY2tNZW51SXRlbVtdfVxuICAgKiAgICAgICAgIEFycmF5IG9mIG1lbnUgaXRlbXNcbiAgICovXG5cblxuICBDaGFwdGVyc0J1dHRvbi5wcm90b3R5cGUuY3JlYXRlSXRlbXMgPSBmdW5jdGlvbiBjcmVhdGVJdGVtcygpIHtcbiAgICB2YXIgaXRlbXMgPSBbXTtcblxuICAgIGlmICghdGhpcy50cmFja18pIHtcbiAgICAgIHJldHVybiBpdGVtcztcbiAgICB9XG5cbiAgICB2YXIgY3VlcyA9IHRoaXMudHJhY2tfLmN1ZXM7XG5cbiAgICBpZiAoIWN1ZXMpIHtcbiAgICAgIHJldHVybiBpdGVtcztcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGN1ZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgY3VlID0gY3Vlc1tpXTtcbiAgICAgIHZhciBtaSA9IG5ldyBDaGFwdGVyc1RyYWNrTWVudUl0ZW0odGhpcy5wbGF5ZXJfLCB7IHRyYWNrOiB0aGlzLnRyYWNrXywgY3VlOiBjdWUgfSk7XG5cbiAgICAgIGl0ZW1zLnB1c2gobWkpO1xuICAgIH1cblxuICAgIHJldHVybiBpdGVtcztcbiAgfTtcblxuICByZXR1cm4gQ2hhcHRlcnNCdXR0b247XG59KFRleHRUcmFja0J1dHRvbik7XG5cbi8qKlxuICogYGtpbmRgIG9mIFRleHRUcmFjayB0byBsb29rIGZvciB0byBhc3NvY2lhdGUgaXQgd2l0aCB0aGlzIG1lbnUuXG4gKlxuICogQHR5cGUge3N0cmluZ31cbiAqIEBwcml2YXRlXG4gKi9cblxuXG5DaGFwdGVyc0J1dHRvbi5wcm90b3R5cGUua2luZF8gPSAnY2hhcHRlcnMnO1xuXG4vKipcbiAqIFRoZSB0ZXh0IHRoYXQgc2hvdWxkIGRpc3BsYXkgb3ZlciB0aGUgYENoYXB0ZXJzQnV0dG9uYHMgY29udHJvbHMuIEFkZGVkIGZvciBsb2NhbGl6YXRpb24uXG4gKlxuICogQHR5cGUge3N0cmluZ31cbiAqIEBwcml2YXRlXG4gKi9cbkNoYXB0ZXJzQnV0dG9uLnByb3RvdHlwZS5jb250cm9sVGV4dF8gPSAnQ2hhcHRlcnMnO1xuXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ0NoYXB0ZXJzQnV0dG9uJywgQ2hhcHRlcnNCdXR0b24pO1xuXG4vKipcbiAqIEBmaWxlIGRlc2NyaXB0aW9ucy1idXR0b24uanNcbiAqL1xuLyoqXG4gKiBUaGUgYnV0dG9uIGNvbXBvbmVudCBmb3IgdG9nZ2xpbmcgYW5kIHNlbGVjdGluZyBkZXNjcmlwdGlvbnNcbiAqXG4gKiBAZXh0ZW5kcyBUZXh0VHJhY2tCdXR0b25cbiAqL1xuXG52YXIgRGVzY3JpcHRpb25zQnV0dG9uID0gZnVuY3Rpb24gKF9UZXh0VHJhY2tCdXR0b24pIHtcbiAgaW5oZXJpdHMoRGVzY3JpcHRpb25zQnV0dG9uLCBfVGV4dFRyYWNrQnV0dG9uKTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge1BsYXllcn0gcGxheWVyXG4gICAqICAgICAgICBUaGUgYFBsYXllcmAgdGhhdCB0aGlzIGNsYXNzIHNob3VsZCBiZSBhdHRhY2hlZCB0by5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgICAgICAgVGhlIGtleS92YWx1ZSBzdG9yZSBvZiBwbGF5ZXIgb3B0aW9ucy5cbiAgICpcbiAgICogQHBhcmFtIHtDb21wb25lbnR+UmVhZHlDYWxsYmFja30gW3JlYWR5XVxuICAgKiAgICAgICAgVGhlIGZ1bmN0aW9uIHRvIGNhbGwgd2hlbiB0aGlzIGNvbXBvbmVudCBpcyByZWFkeS5cbiAgICovXG4gIGZ1bmN0aW9uIERlc2NyaXB0aW9uc0J1dHRvbihwbGF5ZXIsIG9wdGlvbnMsIHJlYWR5KSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgRGVzY3JpcHRpb25zQnV0dG9uKTtcblxuICAgIHZhciBfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1RleHRUcmFja0J1dHRvbi5jYWxsKHRoaXMsIHBsYXllciwgb3B0aW9ucywgcmVhZHkpKTtcblxuICAgIHZhciB0cmFja3MgPSBwbGF5ZXIudGV4dFRyYWNrcygpO1xuICAgIHZhciBjaGFuZ2VIYW5kbGVyID0gYmluZChfdGhpcywgX3RoaXMuaGFuZGxlVHJhY2tzQ2hhbmdlKTtcblxuICAgIHRyYWNrcy5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBjaGFuZ2VIYW5kbGVyKTtcbiAgICBfdGhpcy5vbignZGlzcG9zZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHRyYWNrcy5yZW1vdmVFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBjaGFuZ2VIYW5kbGVyKTtcbiAgICB9KTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlIHRleHQgdHJhY2sgY2hhbmdlXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IGV2ZW50XG4gICAqICAgICAgICBUaGUgZXZlbnQgdGhhdCBjYXVzZWQgdGhpcyBmdW5jdGlvbiB0byBydW5cbiAgICpcbiAgICogQGxpc3RlbnMgVGV4dFRyYWNrTGlzdCNjaGFuZ2VcbiAgICovXG5cblxuICBEZXNjcmlwdGlvbnNCdXR0b24ucHJvdG90eXBlLmhhbmRsZVRyYWNrc0NoYW5nZSA9IGZ1bmN0aW9uIGhhbmRsZVRyYWNrc0NoYW5nZShldmVudCkge1xuICAgIHZhciB0cmFja3MgPSB0aGlzLnBsYXllcigpLnRleHRUcmFja3MoKTtcbiAgICB2YXIgZGlzYWJsZWQgPSBmYWxzZTtcblxuICAgIC8vIENoZWNrIHdoZXRoZXIgYSB0cmFjayBvZiBhIGRpZmZlcmVudCBraW5kIGlzIHNob3dpbmdcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IHRyYWNrcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciB0cmFjayA9IHRyYWNrc1tpXTtcblxuICAgICAgaWYgKHRyYWNrLmtpbmQgIT09IHRoaXMua2luZF8gJiYgdHJhY2subW9kZSA9PT0gJ3Nob3dpbmcnKSB7XG4gICAgICAgIGRpc2FibGVkID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSWYgYW5vdGhlciB0cmFjayBpcyBzaG93aW5nLCBkaXNhYmxlIHRoaXMgbWVudSBidXR0b25cbiAgICBpZiAoZGlzYWJsZWQpIHtcbiAgICAgIHRoaXMuZGlzYWJsZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmVuYWJsZSgpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQnVpbGRzIHRoZSBkZWZhdWx0IERPTSBgY2xhc3NOYW1lYC5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKiAgICAgICAgIFRoZSBET00gYGNsYXNzTmFtZWAgZm9yIHRoaXMgb2JqZWN0LlxuICAgKi9cblxuXG4gIERlc2NyaXB0aW9uc0J1dHRvbi5wcm90b3R5cGUuYnVpbGRDU1NDbGFzcyA9IGZ1bmN0aW9uIGJ1aWxkQ1NTQ2xhc3MoKSB7XG4gICAgcmV0dXJuICd2anMtZGVzY3JpcHRpb25zLWJ1dHRvbiAnICsgX1RleHRUcmFja0J1dHRvbi5wcm90b3R5cGUuYnVpbGRDU1NDbGFzcy5jYWxsKHRoaXMpO1xuICB9O1xuXG4gIERlc2NyaXB0aW9uc0J1dHRvbi5wcm90b3R5cGUuYnVpbGRXcmFwcGVyQ1NTQ2xhc3MgPSBmdW5jdGlvbiBidWlsZFdyYXBwZXJDU1NDbGFzcygpIHtcbiAgICByZXR1cm4gJ3Zqcy1kZXNjcmlwdGlvbnMtYnV0dG9uICcgKyBfVGV4dFRyYWNrQnV0dG9uLnByb3RvdHlwZS5idWlsZFdyYXBwZXJDU1NDbGFzcy5jYWxsKHRoaXMpO1xuICB9O1xuXG4gIHJldHVybiBEZXNjcmlwdGlvbnNCdXR0b247XG59KFRleHRUcmFja0J1dHRvbik7XG5cbi8qKlxuICogYGtpbmRgIG9mIFRleHRUcmFjayB0byBsb29rIGZvciB0byBhc3NvY2lhdGUgaXQgd2l0aCB0aGlzIG1lbnUuXG4gKlxuICogQHR5cGUge3N0cmluZ31cbiAqIEBwcml2YXRlXG4gKi9cblxuXG5EZXNjcmlwdGlvbnNCdXR0b24ucHJvdG90eXBlLmtpbmRfID0gJ2Rlc2NyaXB0aW9ucyc7XG5cbi8qKlxuICogVGhlIHRleHQgdGhhdCBzaG91bGQgZGlzcGxheSBvdmVyIHRoZSBgRGVzY3JpcHRpb25zQnV0dG9uYHMgY29udHJvbHMuIEFkZGVkIGZvciBsb2NhbGl6YXRpb24uXG4gKlxuICogQHR5cGUge3N0cmluZ31cbiAqIEBwcml2YXRlXG4gKi9cbkRlc2NyaXB0aW9uc0J1dHRvbi5wcm90b3R5cGUuY29udHJvbFRleHRfID0gJ0Rlc2NyaXB0aW9ucyc7XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnRGVzY3JpcHRpb25zQnV0dG9uJywgRGVzY3JpcHRpb25zQnV0dG9uKTtcblxuLyoqXG4gKiBAZmlsZSBzdWJ0aXRsZXMtYnV0dG9uLmpzXG4gKi9cbi8qKlxuICogVGhlIGJ1dHRvbiBjb21wb25lbnQgZm9yIHRvZ2dsaW5nIGFuZCBzZWxlY3Rpbmcgc3VidGl0bGVzXG4gKlxuICogQGV4dGVuZHMgVGV4dFRyYWNrQnV0dG9uXG4gKi9cblxudmFyIFN1YnRpdGxlc0J1dHRvbiA9IGZ1bmN0aW9uIChfVGV4dFRyYWNrQnV0dG9uKSB7XG4gIGluaGVyaXRzKFN1YnRpdGxlc0J1dHRvbiwgX1RleHRUcmFja0J1dHRvbik7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcy5cbiAgICpcbiAgICogQHBhcmFtIHtQbGF5ZXJ9IHBsYXllclxuICAgKiAgICAgICAgVGhlIGBQbGF5ZXJgIHRoYXQgdGhpcyBjbGFzcyBzaG91bGQgYmUgYXR0YWNoZWQgdG8uXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICAgICAgIFRoZSBrZXkvdmFsdWUgc3RvcmUgb2YgcGxheWVyIG9wdGlvbnMuXG4gICAqXG4gICAqIEBwYXJhbSB7Q29tcG9uZW50flJlYWR5Q2FsbGJhY2t9IFtyZWFkeV1cbiAgICogICAgICAgIFRoZSBmdW5jdGlvbiB0byBjYWxsIHdoZW4gdGhpcyBjb21wb25lbnQgaXMgcmVhZHkuXG4gICAqL1xuICBmdW5jdGlvbiBTdWJ0aXRsZXNCdXR0b24ocGxheWVyLCBvcHRpb25zLCByZWFkeSkge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFN1YnRpdGxlc0J1dHRvbik7XG4gICAgcmV0dXJuIHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1RleHRUcmFja0J1dHRvbi5jYWxsKHRoaXMsIHBsYXllciwgb3B0aW9ucywgcmVhZHkpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBCdWlsZHMgdGhlIGRlZmF1bHQgRE9NIGBjbGFzc05hbWVgLlxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqICAgICAgICAgVGhlIERPTSBgY2xhc3NOYW1lYCBmb3IgdGhpcyBvYmplY3QuXG4gICAqL1xuXG5cbiAgU3VidGl0bGVzQnV0dG9uLnByb3RvdHlwZS5idWlsZENTU0NsYXNzID0gZnVuY3Rpb24gYnVpbGRDU1NDbGFzcygpIHtcbiAgICByZXR1cm4gJ3Zqcy1zdWJ0aXRsZXMtYnV0dG9uICcgKyBfVGV4dFRyYWNrQnV0dG9uLnByb3RvdHlwZS5idWlsZENTU0NsYXNzLmNhbGwodGhpcyk7XG4gIH07XG5cbiAgU3VidGl0bGVzQnV0dG9uLnByb3RvdHlwZS5idWlsZFdyYXBwZXJDU1NDbGFzcyA9IGZ1bmN0aW9uIGJ1aWxkV3JhcHBlckNTU0NsYXNzKCkge1xuICAgIHJldHVybiAndmpzLXN1YnRpdGxlcy1idXR0b24gJyArIF9UZXh0VHJhY2tCdXR0b24ucHJvdG90eXBlLmJ1aWxkV3JhcHBlckNTU0NsYXNzLmNhbGwodGhpcyk7XG4gIH07XG5cbiAgcmV0dXJuIFN1YnRpdGxlc0J1dHRvbjtcbn0oVGV4dFRyYWNrQnV0dG9uKTtcblxuLyoqXG4gKiBga2luZGAgb2YgVGV4dFRyYWNrIHRvIGxvb2sgZm9yIHRvIGFzc29jaWF0ZSBpdCB3aXRoIHRoaXMgbWVudS5cbiAqXG4gKiBAdHlwZSB7c3RyaW5nfVxuICogQHByaXZhdGVcbiAqL1xuXG5cblN1YnRpdGxlc0J1dHRvbi5wcm90b3R5cGUua2luZF8gPSAnc3VidGl0bGVzJztcblxuLyoqXG4gKiBUaGUgdGV4dCB0aGF0IHNob3VsZCBkaXNwbGF5IG92ZXIgdGhlIGBTdWJ0aXRsZXNCdXR0b25gcyBjb250cm9scy4gQWRkZWQgZm9yIGxvY2FsaXphdGlvbi5cbiAqXG4gKiBAdHlwZSB7c3RyaW5nfVxuICogQHByaXZhdGVcbiAqL1xuU3VidGl0bGVzQnV0dG9uLnByb3RvdHlwZS5jb250cm9sVGV4dF8gPSAnU3VidGl0bGVzJztcblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdTdWJ0aXRsZXNCdXR0b24nLCBTdWJ0aXRsZXNCdXR0b24pO1xuXG4vKipcbiAqIEBmaWxlIGNhcHRpb24tc2V0dGluZ3MtbWVudS1pdGVtLmpzXG4gKi9cbi8qKlxuICogVGhlIG1lbnUgaXRlbSBmb3IgY2FwdGlvbiB0cmFjayBzZXR0aW5ncyBtZW51XG4gKlxuICogQGV4dGVuZHMgVGV4dFRyYWNrTWVudUl0ZW1cbiAqL1xuXG52YXIgQ2FwdGlvblNldHRpbmdzTWVudUl0ZW0gPSBmdW5jdGlvbiAoX1RleHRUcmFja01lbnVJdGVtKSB7XG4gIGluaGVyaXRzKENhcHRpb25TZXR0aW5nc01lbnVJdGVtLCBfVGV4dFRyYWNrTWVudUl0ZW0pO1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7UGxheWVyfSBwbGF5ZXJcbiAgICogICAgICAgIFRoZSBgUGxheWVyYCB0aGF0IHRoaXMgY2xhc3Mgc2hvdWxkIGJlIGF0dGFjaGVkIHRvLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgICAgICBUaGUga2V5L3ZhbHVlIHN0b3JlIG9mIHBsYXllciBvcHRpb25zLlxuICAgKi9cbiAgZnVuY3Rpb24gQ2FwdGlvblNldHRpbmdzTWVudUl0ZW0ocGxheWVyLCBvcHRpb25zKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgQ2FwdGlvblNldHRpbmdzTWVudUl0ZW0pO1xuXG4gICAgb3B0aW9ucy50cmFjayA9IHtcbiAgICAgIHBsYXllcjogcGxheWVyLFxuICAgICAga2luZDogb3B0aW9ucy5raW5kLFxuICAgICAgbGFiZWw6IG9wdGlvbnMua2luZCArICcgc2V0dGluZ3MnLFxuICAgICAgc2VsZWN0YWJsZTogZmFsc2UsXG4gICAgICAnZGVmYXVsdCc6IGZhbHNlLFxuICAgICAgbW9kZTogJ2Rpc2FibGVkJ1xuICAgIH07XG5cbiAgICAvLyBDYXB0aW9uU2V0dGluZ3NNZW51SXRlbSBoYXMgbm8gY29uY2VwdCBvZiAnc2VsZWN0ZWQnXG4gICAgb3B0aW9ucy5zZWxlY3RhYmxlID0gZmFsc2U7XG5cbiAgICBvcHRpb25zLm5hbWUgPSAnQ2FwdGlvblNldHRpbmdzTWVudUl0ZW0nO1xuXG4gICAgdmFyIF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfVGV4dFRyYWNrTWVudUl0ZW0uY2FsbCh0aGlzLCBwbGF5ZXIsIG9wdGlvbnMpKTtcblxuICAgIF90aGlzLmFkZENsYXNzKCd2anMtdGV4dHRyYWNrLXNldHRpbmdzJyk7XG4gICAgX3RoaXMuY29udHJvbFRleHQoJywgb3BlbnMgJyArIG9wdGlvbnMua2luZCArICcgc2V0dGluZ3MgZGlhbG9nJyk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgZ2V0cyBjYWxsZWQgd2hlbiBhbiBgQ2FwdGlvblNldHRpbmdzTWVudUl0ZW1gIGlzIFwiY2xpY2tlZFwiLiBTZWVcbiAgICoge0BsaW5rIENsaWNrYWJsZUNvbXBvbmVudH0gZm9yIG1vcmUgZGV0YWlsZWQgaW5mb3JtYXRpb24gb24gd2hhdCBhIGNsaWNrIGNhbiBiZS5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gW2V2ZW50XVxuICAgKiAgICAgICAgVGhlIGBrZXlkb3duYCwgYHRhcGAsIG9yIGBjbGlja2AgZXZlbnQgdGhhdCBjYXVzZWQgdGhpcyBmdW5jdGlvbiB0byBiZVxuICAgKiAgICAgICAgY2FsbGVkLlxuICAgKlxuICAgKiBAbGlzdGVucyB0YXBcbiAgICogQGxpc3RlbnMgY2xpY2tcbiAgICovXG5cblxuICBDYXB0aW9uU2V0dGluZ3NNZW51SXRlbS5wcm90b3R5cGUuaGFuZGxlQ2xpY2sgPSBmdW5jdGlvbiBoYW5kbGVDbGljayhldmVudCkge1xuICAgIHRoaXMucGxheWVyKCkuZ2V0Q2hpbGQoJ3RleHRUcmFja1NldHRpbmdzJykub3BlbigpO1xuICB9O1xuXG4gIHJldHVybiBDYXB0aW9uU2V0dGluZ3NNZW51SXRlbTtcbn0oVGV4dFRyYWNrTWVudUl0ZW0pO1xuXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ0NhcHRpb25TZXR0aW5nc01lbnVJdGVtJywgQ2FwdGlvblNldHRpbmdzTWVudUl0ZW0pO1xuXG4vKipcbiAqIEBmaWxlIGNhcHRpb25zLWJ1dHRvbi5qc1xuICovXG4vKipcbiAqIFRoZSBidXR0b24gY29tcG9uZW50IGZvciB0b2dnbGluZyBhbmQgc2VsZWN0aW5nIGNhcHRpb25zXG4gKlxuICogQGV4dGVuZHMgVGV4dFRyYWNrQnV0dG9uXG4gKi9cblxudmFyIENhcHRpb25zQnV0dG9uID0gZnVuY3Rpb24gKF9UZXh0VHJhY2tCdXR0b24pIHtcbiAgaW5oZXJpdHMoQ2FwdGlvbnNCdXR0b24sIF9UZXh0VHJhY2tCdXR0b24pO1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7UGxheWVyfSBwbGF5ZXJcbiAgICogICAgICAgIFRoZSBgUGxheWVyYCB0aGF0IHRoaXMgY2xhc3Mgc2hvdWxkIGJlIGF0dGFjaGVkIHRvLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgICAgICBUaGUga2V5L3ZhbHVlIHN0b3JlIG9mIHBsYXllciBvcHRpb25zLlxuICAgKlxuICAgKiBAcGFyYW0ge0NvbXBvbmVudH5SZWFkeUNhbGxiYWNrfSBbcmVhZHldXG4gICAqICAgICAgICBUaGUgZnVuY3Rpb24gdG8gY2FsbCB3aGVuIHRoaXMgY29tcG9uZW50IGlzIHJlYWR5LlxuICAgKi9cbiAgZnVuY3Rpb24gQ2FwdGlvbnNCdXR0b24ocGxheWVyLCBvcHRpb25zLCByZWFkeSkge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIENhcHRpb25zQnV0dG9uKTtcbiAgICByZXR1cm4gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfVGV4dFRyYWNrQnV0dG9uLmNhbGwodGhpcywgcGxheWVyLCBvcHRpb25zLCByZWFkeSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEJ1aWxkcyB0aGUgZGVmYXVsdCBET00gYGNsYXNzTmFtZWAuXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICogICAgICAgICBUaGUgRE9NIGBjbGFzc05hbWVgIGZvciB0aGlzIG9iamVjdC5cbiAgICovXG5cblxuICBDYXB0aW9uc0J1dHRvbi5wcm90b3R5cGUuYnVpbGRDU1NDbGFzcyA9IGZ1bmN0aW9uIGJ1aWxkQ1NTQ2xhc3MoKSB7XG4gICAgcmV0dXJuICd2anMtY2FwdGlvbnMtYnV0dG9uICcgKyBfVGV4dFRyYWNrQnV0dG9uLnByb3RvdHlwZS5idWlsZENTU0NsYXNzLmNhbGwodGhpcyk7XG4gIH07XG5cbiAgQ2FwdGlvbnNCdXR0b24ucHJvdG90eXBlLmJ1aWxkV3JhcHBlckNTU0NsYXNzID0gZnVuY3Rpb24gYnVpbGRXcmFwcGVyQ1NTQ2xhc3MoKSB7XG4gICAgcmV0dXJuICd2anMtY2FwdGlvbnMtYnV0dG9uICcgKyBfVGV4dFRyYWNrQnV0dG9uLnByb3RvdHlwZS5idWlsZFdyYXBwZXJDU1NDbGFzcy5jYWxsKHRoaXMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgY2FwdGlvbiBtZW51IGl0ZW1zXG4gICAqXG4gICAqIEByZXR1cm4ge0NhcHRpb25TZXR0aW5nc01lbnVJdGVtW119XG4gICAqICAgICAgICAgVGhlIGFycmF5IG9mIGN1cnJlbnQgbWVudSBpdGVtcy5cbiAgICovXG5cblxuICBDYXB0aW9uc0J1dHRvbi5wcm90b3R5cGUuY3JlYXRlSXRlbXMgPSBmdW5jdGlvbiBjcmVhdGVJdGVtcygpIHtcbiAgICB2YXIgaXRlbXMgPSBbXTtcblxuICAgIGlmICghKHRoaXMucGxheWVyKCkudGVjaF8gJiYgdGhpcy5wbGF5ZXIoKS50ZWNoXy5mZWF0dXJlc05hdGl2ZVRleHRUcmFja3MpICYmIHRoaXMucGxheWVyKCkuZ2V0Q2hpbGQoJ3RleHRUcmFja1NldHRpbmdzJykpIHtcbiAgICAgIGl0ZW1zLnB1c2gobmV3IENhcHRpb25TZXR0aW5nc01lbnVJdGVtKHRoaXMucGxheWVyXywgeyBraW5kOiB0aGlzLmtpbmRfIH0pKTtcblxuICAgICAgdGhpcy5oaWRlVGhyZXNob2xkXyArPSAxO1xuICAgIH1cblxuICAgIHJldHVybiBfVGV4dFRyYWNrQnV0dG9uLnByb3RvdHlwZS5jcmVhdGVJdGVtcy5jYWxsKHRoaXMsIGl0ZW1zKTtcbiAgfTtcblxuICByZXR1cm4gQ2FwdGlvbnNCdXR0b247XG59KFRleHRUcmFja0J1dHRvbik7XG5cbi8qKlxuICogYGtpbmRgIG9mIFRleHRUcmFjayB0byBsb29rIGZvciB0byBhc3NvY2lhdGUgaXQgd2l0aCB0aGlzIG1lbnUuXG4gKlxuICogQHR5cGUge3N0cmluZ31cbiAqIEBwcml2YXRlXG4gKi9cblxuXG5DYXB0aW9uc0J1dHRvbi5wcm90b3R5cGUua2luZF8gPSAnY2FwdGlvbnMnO1xuXG4vKipcbiAqIFRoZSB0ZXh0IHRoYXQgc2hvdWxkIGRpc3BsYXkgb3ZlciB0aGUgYENhcHRpb25zQnV0dG9uYHMgY29udHJvbHMuIEFkZGVkIGZvciBsb2NhbGl6YXRpb24uXG4gKlxuICogQHR5cGUge3N0cmluZ31cbiAqIEBwcml2YXRlXG4gKi9cbkNhcHRpb25zQnV0dG9uLnByb3RvdHlwZS5jb250cm9sVGV4dF8gPSAnQ2FwdGlvbnMnO1xuXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ0NhcHRpb25zQnV0dG9uJywgQ2FwdGlvbnNCdXR0b24pO1xuXG4vKipcbiAqIEBmaWxlIHN1YnMtY2Fwcy1tZW51LWl0ZW0uanNcbiAqL1xuLyoqXG4gKiBTdWJzQ2Fwc01lbnVJdGVtIGhhcyBhbiBbY2NdIGljb24gdG8gZGlzdGluZ3Vpc2ggY2FwdGlvbnMgZnJvbSBzdWJ0aXRsZXNcbiAqIGluIHRoZSBTdWJzQ2Fwc01lbnUuXG4gKlxuICogQGV4dGVuZHMgVGV4dFRyYWNrTWVudUl0ZW1cbiAqL1xuXG52YXIgU3Vic0NhcHNNZW51SXRlbSA9IGZ1bmN0aW9uIChfVGV4dFRyYWNrTWVudUl0ZW0pIHtcbiAgaW5oZXJpdHMoU3Vic0NhcHNNZW51SXRlbSwgX1RleHRUcmFja01lbnVJdGVtKTtcblxuICBmdW5jdGlvbiBTdWJzQ2Fwc01lbnVJdGVtKCkge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFN1YnNDYXBzTWVudUl0ZW0pO1xuICAgIHJldHVybiBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9UZXh0VHJhY2tNZW51SXRlbS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIFN1YnNDYXBzTWVudUl0ZW0ucHJvdG90eXBlLmNyZWF0ZUVsID0gZnVuY3Rpb24gY3JlYXRlRWwodHlwZSwgcHJvcHMsIGF0dHJzKSB7XG4gICAgdmFyIGlubmVySFRNTCA9ICc8c3BhbiBjbGFzcz1cInZqcy1tZW51LWl0ZW0tdGV4dFwiPicgKyB0aGlzLmxvY2FsaXplKHRoaXMub3B0aW9uc18ubGFiZWwpO1xuXG4gICAgaWYgKHRoaXMub3B0aW9uc18udHJhY2sua2luZCA9PT0gJ2NhcHRpb25zJykge1xuICAgICAgaW5uZXJIVE1MICs9ICdcXG4gICAgICAgIDxzcGFuIGFyaWEtaGlkZGVuPVwidHJ1ZVwiIGNsYXNzPVwidmpzLWljb24tcGxhY2Vob2xkZXJcIj48L3NwYW4+XFxuICAgICAgICA8c3BhbiBjbGFzcz1cInZqcy1jb250cm9sLXRleHRcIj4gJyArIHRoaXMubG9jYWxpemUoJ0NhcHRpb25zJykgKyAnPC9zcGFuPlxcbiAgICAgICc7XG4gICAgfVxuXG4gICAgaW5uZXJIVE1MICs9ICc8L3NwYW4+JztcblxuICAgIHZhciBlbCA9IF9UZXh0VHJhY2tNZW51SXRlbS5wcm90b3R5cGUuY3JlYXRlRWwuY2FsbCh0aGlzLCB0eXBlLCBhc3NpZ24oe1xuICAgICAgaW5uZXJIVE1MOiBpbm5lckhUTUxcbiAgICB9LCBwcm9wcyksIGF0dHJzKTtcblxuICAgIHJldHVybiBlbDtcbiAgfTtcblxuICByZXR1cm4gU3Vic0NhcHNNZW51SXRlbTtcbn0oVGV4dFRyYWNrTWVudUl0ZW0pO1xuXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ1N1YnNDYXBzTWVudUl0ZW0nLCBTdWJzQ2Fwc01lbnVJdGVtKTtcblxuLyoqXG4gKiBAZmlsZSBzdWItY2Fwcy1idXR0b24uanNcbiAqL1xuLyoqXG4gKiBUaGUgYnV0dG9uIGNvbXBvbmVudCBmb3IgdG9nZ2xpbmcgYW5kIHNlbGVjdGluZyBjYXB0aW9ucyBhbmQvb3Igc3VidGl0bGVzXG4gKlxuICogQGV4dGVuZHMgVGV4dFRyYWNrQnV0dG9uXG4gKi9cblxudmFyIFN1YnNDYXBzQnV0dG9uID0gZnVuY3Rpb24gKF9UZXh0VHJhY2tCdXR0b24pIHtcbiAgaW5oZXJpdHMoU3Vic0NhcHNCdXR0b24sIF9UZXh0VHJhY2tCdXR0b24pO1xuXG4gIGZ1bmN0aW9uIFN1YnNDYXBzQnV0dG9uKHBsYXllcikge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBTdWJzQ2Fwc0J1dHRvbik7XG5cbiAgICAvLyBBbHRob3VnaCBOb3J0aCBBbWVyaWNhIHVzZXMgXCJjYXB0aW9uc1wiIGluIG1vc3QgY2FzZXMgZm9yXG4gICAgLy8gXCJjYXB0aW9ucyBhbmQgc3VidGl0bGVzXCIgb3RoZXIgbG9jYWxlcyB1c2UgXCJzdWJ0aXRsZXNcIlxuICAgIHZhciBfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1RleHRUcmFja0J1dHRvbi5jYWxsKHRoaXMsIHBsYXllciwgb3B0aW9ucykpO1xuXG4gICAgX3RoaXMubGFiZWxfID0gJ3N1YnRpdGxlcyc7XG4gICAgaWYgKFsnZW4nLCAnZW4tdXMnLCAnZW4tY2EnLCAnZnItY2EnXS5pbmRleE9mKF90aGlzLnBsYXllcl8ubGFuZ3VhZ2VfKSA+IC0xKSB7XG4gICAgICBfdGhpcy5sYWJlbF8gPSAnY2FwdGlvbnMnO1xuICAgIH1cbiAgICBfdGhpcy5tZW51QnV0dG9uXy5jb250cm9sVGV4dCh0b1RpdGxlQ2FzZShfdGhpcy5sYWJlbF8pKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICAvKipcbiAgICogQnVpbGRzIHRoZSBkZWZhdWx0IERPTSBgY2xhc3NOYW1lYC5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKiAgICAgICAgIFRoZSBET00gYGNsYXNzTmFtZWAgZm9yIHRoaXMgb2JqZWN0LlxuICAgKi9cblxuXG4gIFN1YnNDYXBzQnV0dG9uLnByb3RvdHlwZS5idWlsZENTU0NsYXNzID0gZnVuY3Rpb24gYnVpbGRDU1NDbGFzcygpIHtcbiAgICByZXR1cm4gJ3Zqcy1zdWJzLWNhcHMtYnV0dG9uICcgKyBfVGV4dFRyYWNrQnV0dG9uLnByb3RvdHlwZS5idWlsZENTU0NsYXNzLmNhbGwodGhpcyk7XG4gIH07XG5cbiAgU3Vic0NhcHNCdXR0b24ucHJvdG90eXBlLmJ1aWxkV3JhcHBlckNTU0NsYXNzID0gZnVuY3Rpb24gYnVpbGRXcmFwcGVyQ1NTQ2xhc3MoKSB7XG4gICAgcmV0dXJuICd2anMtc3Vicy1jYXBzLWJ1dHRvbiAnICsgX1RleHRUcmFja0J1dHRvbi5wcm90b3R5cGUuYnVpbGRXcmFwcGVyQ1NTQ2xhc3MuY2FsbCh0aGlzKTtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlIGNhcHRpb24vc3VidGl0bGVzIG1lbnUgaXRlbXNcbiAgICpcbiAgICogQHJldHVybiB7Q2FwdGlvblNldHRpbmdzTWVudUl0ZW1bXX1cbiAgICogICAgICAgICBUaGUgYXJyYXkgb2YgY3VycmVudCBtZW51IGl0ZW1zLlxuICAgKi9cblxuXG4gIFN1YnNDYXBzQnV0dG9uLnByb3RvdHlwZS5jcmVhdGVJdGVtcyA9IGZ1bmN0aW9uIGNyZWF0ZUl0ZW1zKCkge1xuICAgIHZhciBpdGVtcyA9IFtdO1xuXG4gICAgaWYgKCEodGhpcy5wbGF5ZXIoKS50ZWNoXyAmJiB0aGlzLnBsYXllcigpLnRlY2hfLmZlYXR1cmVzTmF0aXZlVGV4dFRyYWNrcykgJiYgdGhpcy5wbGF5ZXIoKS5nZXRDaGlsZCgndGV4dFRyYWNrU2V0dGluZ3MnKSkge1xuICAgICAgaXRlbXMucHVzaChuZXcgQ2FwdGlvblNldHRpbmdzTWVudUl0ZW0odGhpcy5wbGF5ZXJfLCB7IGtpbmQ6IHRoaXMubGFiZWxfIH0pKTtcblxuICAgICAgdGhpcy5oaWRlVGhyZXNob2xkXyArPSAxO1xuICAgIH1cblxuICAgIGl0ZW1zID0gX1RleHRUcmFja0J1dHRvbi5wcm90b3R5cGUuY3JlYXRlSXRlbXMuY2FsbCh0aGlzLCBpdGVtcywgU3Vic0NhcHNNZW51SXRlbSk7XG4gICAgcmV0dXJuIGl0ZW1zO1xuICB9O1xuXG4gIHJldHVybiBTdWJzQ2Fwc0J1dHRvbjtcbn0oVGV4dFRyYWNrQnV0dG9uKTtcblxuLyoqXG4gKiBga2luZGBzIG9mIFRleHRUcmFjayB0byBsb29rIGZvciB0byBhc3NvY2lhdGUgaXQgd2l0aCB0aGlzIG1lbnUuXG4gKlxuICogQHR5cGUge2FycmF5fVxuICogQHByaXZhdGVcbiAqL1xuXG5cblN1YnNDYXBzQnV0dG9uLnByb3RvdHlwZS5raW5kc18gPSBbJ2NhcHRpb25zJywgJ3N1YnRpdGxlcyddO1xuXG4vKipcbiAqIFRoZSB0ZXh0IHRoYXQgc2hvdWxkIGRpc3BsYXkgb3ZlciB0aGUgYFN1YnNDYXBzQnV0dG9uYHMgY29udHJvbHMuXG4gKlxuICpcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKiBAcHJpdmF0ZVxuICovXG5TdWJzQ2Fwc0J1dHRvbi5wcm90b3R5cGUuY29udHJvbFRleHRfID0gJ1N1YnRpdGxlcyc7XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnU3Vic0NhcHNCdXR0b24nLCBTdWJzQ2Fwc0J1dHRvbik7XG5cbi8qKlxuICogQGZpbGUgYXVkaW8tdHJhY2stbWVudS1pdGVtLmpzXG4gKi9cbi8qKlxuICogQW4ge0BsaW5rIEF1ZGlvVHJhY2t9IHtAbGluayBNZW51SXRlbX1cbiAqXG4gKiBAZXh0ZW5kcyBNZW51SXRlbVxuICovXG5cbnZhciBBdWRpb1RyYWNrTWVudUl0ZW0gPSBmdW5jdGlvbiAoX01lbnVJdGVtKSB7XG4gIGluaGVyaXRzKEF1ZGlvVHJhY2tNZW51SXRlbSwgX01lbnVJdGVtKTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge1BsYXllcn0gcGxheWVyXG4gICAqICAgICAgICBUaGUgYFBsYXllcmAgdGhhdCB0aGlzIGNsYXNzIHNob3VsZCBiZSBhdHRhY2hlZCB0by5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgICAgICAgVGhlIGtleS92YWx1ZSBzdG9yZSBvZiBwbGF5ZXIgb3B0aW9ucy5cbiAgICovXG4gIGZ1bmN0aW9uIEF1ZGlvVHJhY2tNZW51SXRlbShwbGF5ZXIsIG9wdGlvbnMpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBBdWRpb1RyYWNrTWVudUl0ZW0pO1xuXG4gICAgdmFyIHRyYWNrID0gb3B0aW9ucy50cmFjaztcbiAgICB2YXIgdHJhY2tzID0gcGxheWVyLmF1ZGlvVHJhY2tzKCk7XG5cbiAgICAvLyBNb2RpZnkgb3B0aW9ucyBmb3IgcGFyZW50IE1lbnVJdGVtIGNsYXNzJ3MgaW5pdC5cbiAgICBvcHRpb25zLmxhYmVsID0gdHJhY2subGFiZWwgfHwgdHJhY2subGFuZ3VhZ2UgfHwgJ1Vua25vd24nO1xuICAgIG9wdGlvbnMuc2VsZWN0ZWQgPSB0cmFjay5lbmFibGVkO1xuXG4gICAgdmFyIF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfTWVudUl0ZW0uY2FsbCh0aGlzLCBwbGF5ZXIsIG9wdGlvbnMpKTtcblxuICAgIF90aGlzLnRyYWNrID0gdHJhY2s7XG5cbiAgICBfdGhpcy5hZGRDbGFzcygndmpzLScgKyB0cmFjay5raW5kICsgJy1tZW51LWl0ZW0nKTtcblxuICAgIHZhciBjaGFuZ2VIYW5kbGVyID0gZnVuY3Rpb24gY2hhbmdlSGFuZGxlcigpIHtcbiAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICB9XG5cbiAgICAgIF90aGlzLmhhbmRsZVRyYWNrc0NoYW5nZS5hcHBseShfdGhpcywgYXJncyk7XG4gICAgfTtcblxuICAgIHRyYWNrcy5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBjaGFuZ2VIYW5kbGVyKTtcbiAgICBfdGhpcy5vbignZGlzcG9zZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHRyYWNrcy5yZW1vdmVFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBjaGFuZ2VIYW5kbGVyKTtcbiAgICB9KTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBBdWRpb1RyYWNrTWVudUl0ZW0ucHJvdG90eXBlLmNyZWF0ZUVsID0gZnVuY3Rpb24gY3JlYXRlRWwodHlwZSwgcHJvcHMsIGF0dHJzKSB7XG4gICAgdmFyIGlubmVySFRNTCA9ICc8c3BhbiBjbGFzcz1cInZqcy1tZW51LWl0ZW0tdGV4dFwiPicgKyB0aGlzLmxvY2FsaXplKHRoaXMub3B0aW9uc18ubGFiZWwpO1xuXG4gICAgaWYgKHRoaXMub3B0aW9uc18udHJhY2sua2luZCA9PT0gJ21haW4tZGVzYycpIHtcbiAgICAgIGlubmVySFRNTCArPSAnXFxuICAgICAgICA8c3BhbiBhcmlhLWhpZGRlbj1cInRydWVcIiBjbGFzcz1cInZqcy1pY29uLXBsYWNlaG9sZGVyXCI+PC9zcGFuPlxcbiAgICAgICAgPHNwYW4gY2xhc3M9XCJ2anMtY29udHJvbC10ZXh0XCI+ICcgKyB0aGlzLmxvY2FsaXplKCdEZXNjcmlwdGlvbnMnKSArICc8L3NwYW4+XFxuICAgICAgJztcbiAgICB9XG5cbiAgICBpbm5lckhUTUwgKz0gJzwvc3Bhbj4nO1xuXG4gICAgdmFyIGVsID0gX01lbnVJdGVtLnByb3RvdHlwZS5jcmVhdGVFbC5jYWxsKHRoaXMsIHR5cGUsIGFzc2lnbih7XG4gICAgICBpbm5lckhUTUw6IGlubmVySFRNTFxuICAgIH0sIHByb3BzKSwgYXR0cnMpO1xuXG4gICAgcmV0dXJuIGVsO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUaGlzIGdldHMgY2FsbGVkIHdoZW4gYW4gYEF1ZGlvVHJhY2tNZW51SXRlbSBpcyBcImNsaWNrZWRcIi4gU2VlIHtAbGluayBDbGlja2FibGVDb21wb25lbnR9XG4gICAqIGZvciBtb3JlIGRldGFpbGVkIGluZm9ybWF0aW9uIG9uIHdoYXQgYSBjbGljayBjYW4gYmUuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IFtldmVudF1cbiAgICogICAgICAgIFRoZSBga2V5ZG93bmAsIGB0YXBgLCBvciBgY2xpY2tgIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgZnVuY3Rpb24gdG8gYmVcbiAgICogICAgICAgIGNhbGxlZC5cbiAgICpcbiAgICogQGxpc3RlbnMgdGFwXG4gICAqIEBsaXN0ZW5zIGNsaWNrXG4gICAqL1xuXG5cbiAgQXVkaW9UcmFja01lbnVJdGVtLnByb3RvdHlwZS5oYW5kbGVDbGljayA9IGZ1bmN0aW9uIGhhbmRsZUNsaWNrKGV2ZW50KSB7XG4gICAgdmFyIHRyYWNrcyA9IHRoaXMucGxheWVyXy5hdWRpb1RyYWNrcygpO1xuXG4gICAgX01lbnVJdGVtLnByb3RvdHlwZS5oYW5kbGVDbGljay5jYWxsKHRoaXMsIGV2ZW50KTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdHJhY2sgPSB0cmFja3NbaV07XG5cbiAgICAgIHRyYWNrLmVuYWJsZWQgPSB0cmFjayA9PT0gdGhpcy50cmFjaztcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBhbnkge0BsaW5rIEF1ZGlvVHJhY2t9IGNoYW5nZS5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gW2V2ZW50XVxuICAgKiAgICAgICAgVGhlIHtAbGluayBBdWRpb1RyYWNrTGlzdCNjaGFuZ2V9IGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgdG8gcnVuLlxuICAgKlxuICAgKiBAbGlzdGVucyBBdWRpb1RyYWNrTGlzdCNjaGFuZ2VcbiAgICovXG5cblxuICBBdWRpb1RyYWNrTWVudUl0ZW0ucHJvdG90eXBlLmhhbmRsZVRyYWNrc0NoYW5nZSA9IGZ1bmN0aW9uIGhhbmRsZVRyYWNrc0NoYW5nZShldmVudCkge1xuICAgIHRoaXMuc2VsZWN0ZWQodGhpcy50cmFjay5lbmFibGVkKTtcbiAgfTtcblxuICByZXR1cm4gQXVkaW9UcmFja01lbnVJdGVtO1xufShNZW51SXRlbSk7XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnQXVkaW9UcmFja01lbnVJdGVtJywgQXVkaW9UcmFja01lbnVJdGVtKTtcblxuLyoqXG4gKiBAZmlsZSBhdWRpby10cmFjay1idXR0b24uanNcbiAqL1xuLyoqXG4gKiBUaGUgYmFzZSBjbGFzcyBmb3IgYnV0dG9ucyB0aGF0IHRvZ2dsZSBzcGVjaWZpYyB7QGxpbmsgQXVkaW9UcmFja30gdHlwZXMuXG4gKlxuICogQGV4dGVuZHMgVHJhY2tCdXR0b25cbiAqL1xuXG52YXIgQXVkaW9UcmFja0J1dHRvbiA9IGZ1bmN0aW9uIChfVHJhY2tCdXR0b24pIHtcbiAgaW5oZXJpdHMoQXVkaW9UcmFja0J1dHRvbiwgX1RyYWNrQnV0dG9uKTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge1BsYXllcn0gcGxheWVyXG4gICAqICAgICAgICBUaGUgYFBsYXllcmAgdGhhdCB0aGlzIGNsYXNzIHNob3VsZCBiZSBhdHRhY2hlZCB0by5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XVxuICAgKiAgICAgICAgVGhlIGtleS92YWx1ZSBzdG9yZSBvZiBwbGF5ZXIgb3B0aW9ucy5cbiAgICovXG4gIGZ1bmN0aW9uIEF1ZGlvVHJhY2tCdXR0b24ocGxheWVyKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIEF1ZGlvVHJhY2tCdXR0b24pO1xuXG4gICAgb3B0aW9ucy50cmFja3MgPSBwbGF5ZXIuYXVkaW9UcmFja3MoKTtcblxuICAgIHJldHVybiBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9UcmFja0J1dHRvbi5jYWxsKHRoaXMsIHBsYXllciwgb3B0aW9ucykpO1xuICB9XG5cbiAgLyoqXG4gICAqIEJ1aWxkcyB0aGUgZGVmYXVsdCBET00gYGNsYXNzTmFtZWAuXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICogICAgICAgICBUaGUgRE9NIGBjbGFzc05hbWVgIGZvciB0aGlzIG9iamVjdC5cbiAgICovXG5cblxuICBBdWRpb1RyYWNrQnV0dG9uLnByb3RvdHlwZS5idWlsZENTU0NsYXNzID0gZnVuY3Rpb24gYnVpbGRDU1NDbGFzcygpIHtcbiAgICByZXR1cm4gJ3Zqcy1hdWRpby1idXR0b24gJyArIF9UcmFja0J1dHRvbi5wcm90b3R5cGUuYnVpbGRDU1NDbGFzcy5jYWxsKHRoaXMpO1xuICB9O1xuXG4gIEF1ZGlvVHJhY2tCdXR0b24ucHJvdG90eXBlLmJ1aWxkV3JhcHBlckNTU0NsYXNzID0gZnVuY3Rpb24gYnVpbGRXcmFwcGVyQ1NTQ2xhc3MoKSB7XG4gICAgcmV0dXJuICd2anMtYXVkaW8tYnV0dG9uICcgKyBfVHJhY2tCdXR0b24ucHJvdG90eXBlLmJ1aWxkV3JhcHBlckNTU0NsYXNzLmNhbGwodGhpcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG1lbnUgaXRlbSBmb3IgZWFjaCBhdWRpbyB0cmFja1xuICAgKlxuICAgKiBAcGFyYW0ge0F1ZGlvVHJhY2tNZW51SXRlbVtdfSBbaXRlbXM9W11dXG4gICAqICAgICAgICBBbiBhcnJheSBvZiBleGlzdGluZyBtZW51IGl0ZW1zIHRvIHVzZS5cbiAgICpcbiAgICogQHJldHVybiB7QXVkaW9UcmFja01lbnVJdGVtW119XG4gICAqICAgICAgICAgQW4gYXJyYXkgb2YgbWVudSBpdGVtc1xuICAgKi9cblxuXG4gIEF1ZGlvVHJhY2tCdXR0b24ucHJvdG90eXBlLmNyZWF0ZUl0ZW1zID0gZnVuY3Rpb24gY3JlYXRlSXRlbXMoKSB7XG4gICAgdmFyIGl0ZW1zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBbXTtcblxuICAgIC8vIGlmIHRoZXJlJ3Mgb25seSBvbmUgYXVkaW8gdHJhY2ssIHRoZXJlIG5vIHBvaW50IGluIHNob3dpbmcgaXRcbiAgICB0aGlzLmhpZGVUaHJlc2hvbGRfID0gMTtcblxuICAgIHZhciB0cmFja3MgPSB0aGlzLnBsYXllcl8uYXVkaW9UcmFja3MoKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdHJhY2sgPSB0cmFja3NbaV07XG5cbiAgICAgIGl0ZW1zLnB1c2gobmV3IEF1ZGlvVHJhY2tNZW51SXRlbSh0aGlzLnBsYXllcl8sIHtcbiAgICAgICAgdHJhY2s6IHRyYWNrLFxuICAgICAgICAvLyBNZW51SXRlbSBpcyBzZWxlY3RhYmxlXG4gICAgICAgIHNlbGVjdGFibGU6IHRydWUsXG4gICAgICAgIC8vIE1lbnVJdGVtIGlzIE5PVCBtdWx0aVNlbGVjdGFibGUgKGkuZS4gb25seSBvbmUgY2FuIGJlIG1hcmtlZCBcInNlbGVjdGVkXCIgYXQgYSB0aW1lKVxuICAgICAgICBtdWx0aVNlbGVjdGFibGU6IGZhbHNlXG4gICAgICB9KSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGl0ZW1zO1xuICB9O1xuXG4gIHJldHVybiBBdWRpb1RyYWNrQnV0dG9uO1xufShUcmFja0J1dHRvbik7XG5cbi8qKlxuICogVGhlIHRleHQgdGhhdCBzaG91bGQgZGlzcGxheSBvdmVyIHRoZSBgQXVkaW9UcmFja0J1dHRvbmBzIGNvbnRyb2xzLiBBZGRlZCBmb3IgbG9jYWxpemF0aW9uLlxuICpcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKiBAcHJpdmF0ZVxuICovXG5cblxuQXVkaW9UcmFja0J1dHRvbi5wcm90b3R5cGUuY29udHJvbFRleHRfID0gJ0F1ZGlvIFRyYWNrJztcbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnQXVkaW9UcmFja0J1dHRvbicsIEF1ZGlvVHJhY2tCdXR0b24pO1xuXG4vKipcbiAqIEBmaWxlIHBsYXliYWNrLXJhdGUtbWVudS1pdGVtLmpzXG4gKi9cbi8qKlxuICogVGhlIHNwZWNpZmljIG1lbnUgaXRlbSB0eXBlIGZvciBzZWxlY3RpbmcgYSBwbGF5YmFjayByYXRlLlxuICpcbiAqIEBleHRlbmRzIE1lbnVJdGVtXG4gKi9cblxudmFyIFBsYXliYWNrUmF0ZU1lbnVJdGVtID0gZnVuY3Rpb24gKF9NZW51SXRlbSkge1xuICBpbmhlcml0cyhQbGF5YmFja1JhdGVNZW51SXRlbSwgX01lbnVJdGVtKTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge1BsYXllcn0gcGxheWVyXG4gICAqICAgICAgICBUaGUgYFBsYXllcmAgdGhhdCB0aGlzIGNsYXNzIHNob3VsZCBiZSBhdHRhY2hlZCB0by5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgICAgICAgVGhlIGtleS92YWx1ZSBzdG9yZSBvZiBwbGF5ZXIgb3B0aW9ucy5cbiAgICovXG4gIGZ1bmN0aW9uIFBsYXliYWNrUmF0ZU1lbnVJdGVtKHBsYXllciwgb3B0aW9ucykge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFBsYXliYWNrUmF0ZU1lbnVJdGVtKTtcblxuICAgIHZhciBsYWJlbCA9IG9wdGlvbnMucmF0ZTtcbiAgICB2YXIgcmF0ZSA9IHBhcnNlRmxvYXQobGFiZWwsIDEwKTtcblxuICAgIC8vIE1vZGlmeSBvcHRpb25zIGZvciBwYXJlbnQgTWVudUl0ZW0gY2xhc3MncyBpbml0LlxuICAgIG9wdGlvbnMubGFiZWwgPSBsYWJlbDtcbiAgICBvcHRpb25zLnNlbGVjdGVkID0gcmF0ZSA9PT0gMTtcbiAgICBvcHRpb25zLnNlbGVjdGFibGUgPSB0cnVlO1xuICAgIG9wdGlvbnMubXVsdGlTZWxlY3RhYmxlID0gZmFsc2U7XG5cbiAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9NZW51SXRlbS5jYWxsKHRoaXMsIHBsYXllciwgb3B0aW9ucykpO1xuXG4gICAgX3RoaXMubGFiZWwgPSBsYWJlbDtcbiAgICBfdGhpcy5yYXRlID0gcmF0ZTtcblxuICAgIF90aGlzLm9uKHBsYXllciwgJ3JhdGVjaGFuZ2UnLCBfdGhpcy51cGRhdGUpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIGdldHMgY2FsbGVkIHdoZW4gYW4gYFBsYXliYWNrUmF0ZU1lbnVJdGVtYCBpcyBcImNsaWNrZWRcIi4gU2VlXG4gICAqIHtAbGluayBDbGlja2FibGVDb21wb25lbnR9IGZvciBtb3JlIGRldGFpbGVkIGluZm9ybWF0aW9uIG9uIHdoYXQgYSBjbGljayBjYW4gYmUuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IFtldmVudF1cbiAgICogICAgICAgIFRoZSBga2V5ZG93bmAsIGB0YXBgLCBvciBgY2xpY2tgIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgZnVuY3Rpb24gdG8gYmVcbiAgICogICAgICAgIGNhbGxlZC5cbiAgICpcbiAgICogQGxpc3RlbnMgdGFwXG4gICAqIEBsaXN0ZW5zIGNsaWNrXG4gICAqL1xuXG5cbiAgUGxheWJhY2tSYXRlTWVudUl0ZW0ucHJvdG90eXBlLmhhbmRsZUNsaWNrID0gZnVuY3Rpb24gaGFuZGxlQ2xpY2soZXZlbnQpIHtcbiAgICBfTWVudUl0ZW0ucHJvdG90eXBlLmhhbmRsZUNsaWNrLmNhbGwodGhpcyk7XG4gICAgdGhpcy5wbGF5ZXIoKS5wbGF5YmFja1JhdGUodGhpcy5yYXRlKTtcbiAgfTtcblxuICAvKipcbiAgICogVXBkYXRlIHRoZSBQbGF5YmFja1JhdGVNZW51SXRlbSB3aGVuIHRoZSBwbGF5YmFja3JhdGUgY2hhbmdlcy5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gW2V2ZW50XVxuICAgKiAgICAgICAgVGhlIGByYXRlY2hhbmdlYCBldmVudCB0aGF0IGNhdXNlZCB0aGlzIGZ1bmN0aW9uIHRvIHJ1bi5cbiAgICpcbiAgICogQGxpc3RlbnMgUGxheWVyI3JhdGVjaGFuZ2VcbiAgICovXG5cblxuICBQbGF5YmFja1JhdGVNZW51SXRlbS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlKGV2ZW50KSB7XG4gICAgdGhpcy5zZWxlY3RlZCh0aGlzLnBsYXllcigpLnBsYXliYWNrUmF0ZSgpID09PSB0aGlzLnJhdGUpO1xuICB9O1xuXG4gIHJldHVybiBQbGF5YmFja1JhdGVNZW51SXRlbTtcbn0oTWVudUl0ZW0pO1xuXG4vKipcbiAqIFRoZSB0ZXh0IHRoYXQgc2hvdWxkIGRpc3BsYXkgb3ZlciB0aGUgYFBsYXliYWNrUmF0ZU1lbnVJdGVtYHMgY29udHJvbHMuIEFkZGVkIGZvciBsb2NhbGl6YXRpb24uXG4gKlxuICogQHR5cGUge3N0cmluZ31cbiAqIEBwcml2YXRlXG4gKi9cblxuXG5QbGF5YmFja1JhdGVNZW51SXRlbS5wcm90b3R5cGUuY29udGVudEVsVHlwZSA9ICdidXR0b24nO1xuXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ1BsYXliYWNrUmF0ZU1lbnVJdGVtJywgUGxheWJhY2tSYXRlTWVudUl0ZW0pO1xuXG4vKipcbiAqIEBmaWxlIHBsYXliYWNrLXJhdGUtbWVudS1idXR0b24uanNcbiAqL1xuLyoqXG4gKiBUaGUgY29tcG9uZW50IGZvciBjb250cm9sbGluZyB0aGUgcGxheWJhY2sgcmF0ZS5cbiAqXG4gKiBAZXh0ZW5kcyBNZW51QnV0dG9uXG4gKi9cblxudmFyIFBsYXliYWNrUmF0ZU1lbnVCdXR0b24gPSBmdW5jdGlvbiAoX01lbnVCdXR0b24pIHtcbiAgaW5oZXJpdHMoUGxheWJhY2tSYXRlTWVudUJ1dHRvbiwgX01lbnVCdXR0b24pO1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7UGxheWVyfSBwbGF5ZXJcbiAgICogICAgICAgIFRoZSBgUGxheWVyYCB0aGF0IHRoaXMgY2xhc3Mgc2hvdWxkIGJlIGF0dGFjaGVkIHRvLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgICAgICBUaGUga2V5L3ZhbHVlIHN0b3JlIG9mIHBsYXllciBvcHRpb25zLlxuICAgKi9cbiAgZnVuY3Rpb24gUGxheWJhY2tSYXRlTWVudUJ1dHRvbihwbGF5ZXIsIG9wdGlvbnMpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBQbGF5YmFja1JhdGVNZW51QnV0dG9uKTtcblxuICAgIHZhciBfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX01lbnVCdXR0b24uY2FsbCh0aGlzLCBwbGF5ZXIsIG9wdGlvbnMpKTtcblxuICAgIF90aGlzLnVwZGF0ZVZpc2liaWxpdHkoKTtcbiAgICBfdGhpcy51cGRhdGVMYWJlbCgpO1xuXG4gICAgX3RoaXMub24ocGxheWVyLCAnbG9hZHN0YXJ0JywgX3RoaXMudXBkYXRlVmlzaWJpbGl0eSk7XG4gICAgX3RoaXMub24ocGxheWVyLCAncmF0ZWNoYW5nZScsIF90aGlzLnVwZGF0ZUxhYmVsKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIHRoZSBgQ29tcG9uZW50YCdzIERPTSBlbGVtZW50XG4gICAqXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9XG4gICAqICAgICAgICAgVGhlIGVsZW1lbnQgdGhhdCB3YXMgY3JlYXRlZC5cbiAgICovXG5cblxuICBQbGF5YmFja1JhdGVNZW51QnV0dG9uLnByb3RvdHlwZS5jcmVhdGVFbCA9IGZ1bmN0aW9uIGNyZWF0ZUVsJCQxKCkge1xuICAgIHZhciBlbCA9IF9NZW51QnV0dG9uLnByb3RvdHlwZS5jcmVhdGVFbC5jYWxsKHRoaXMpO1xuXG4gICAgdGhpcy5sYWJlbEVsXyA9IGNyZWF0ZUVsKCdkaXYnLCB7XG4gICAgICBjbGFzc05hbWU6ICd2anMtcGxheWJhY2stcmF0ZS12YWx1ZScsXG4gICAgICBpbm5lckhUTUw6ICcxeCdcbiAgICB9KTtcblxuICAgIGVsLmFwcGVuZENoaWxkKHRoaXMubGFiZWxFbF8pO1xuXG4gICAgcmV0dXJuIGVsO1xuICB9O1xuXG4gIFBsYXliYWNrUmF0ZU1lbnVCdXR0b24ucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiBkaXNwb3NlKCkge1xuICAgIHRoaXMubGFiZWxFbF8gPSBudWxsO1xuXG4gICAgX01lbnVCdXR0b24ucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcbiAgfTtcblxuICAvKipcbiAgICogQnVpbGRzIHRoZSBkZWZhdWx0IERPTSBgY2xhc3NOYW1lYC5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKiAgICAgICAgIFRoZSBET00gYGNsYXNzTmFtZWAgZm9yIHRoaXMgb2JqZWN0LlxuICAgKi9cblxuXG4gIFBsYXliYWNrUmF0ZU1lbnVCdXR0b24ucHJvdG90eXBlLmJ1aWxkQ1NTQ2xhc3MgPSBmdW5jdGlvbiBidWlsZENTU0NsYXNzKCkge1xuICAgIHJldHVybiAndmpzLXBsYXliYWNrLXJhdGUgJyArIF9NZW51QnV0dG9uLnByb3RvdHlwZS5idWlsZENTU0NsYXNzLmNhbGwodGhpcyk7XG4gIH07XG5cbiAgUGxheWJhY2tSYXRlTWVudUJ1dHRvbi5wcm90b3R5cGUuYnVpbGRXcmFwcGVyQ1NTQ2xhc3MgPSBmdW5jdGlvbiBidWlsZFdyYXBwZXJDU1NDbGFzcygpIHtcbiAgICByZXR1cm4gJ3Zqcy1wbGF5YmFjay1yYXRlICcgKyBfTWVudUJ1dHRvbi5wcm90b3R5cGUuYnVpbGRXcmFwcGVyQ1NTQ2xhc3MuY2FsbCh0aGlzKTtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlIHRoZSBwbGF5YmFjayByYXRlIG1lbnVcbiAgICpcbiAgICogQHJldHVybiB7TWVudX1cbiAgICogICAgICAgICBNZW51IG9iamVjdCBwb3B1bGF0ZWQgd2l0aCB7QGxpbmsgUGxheWJhY2tSYXRlTWVudUl0ZW19c1xuICAgKi9cblxuXG4gIFBsYXliYWNrUmF0ZU1lbnVCdXR0b24ucHJvdG90eXBlLmNyZWF0ZU1lbnUgPSBmdW5jdGlvbiBjcmVhdGVNZW51KCkge1xuICAgIHZhciBtZW51ID0gbmV3IE1lbnUodGhpcy5wbGF5ZXIoKSk7XG4gICAgdmFyIHJhdGVzID0gdGhpcy5wbGF5YmFja1JhdGVzKCk7XG5cbiAgICBpZiAocmF0ZXMpIHtcbiAgICAgIGZvciAodmFyIGkgPSByYXRlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBtZW51LmFkZENoaWxkKG5ldyBQbGF5YmFja1JhdGVNZW51SXRlbSh0aGlzLnBsYXllcigpLCB7IHJhdGU6IHJhdGVzW2ldICsgJ3gnIH0pKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbWVudTtcbiAgfTtcblxuICAvKipcbiAgICogVXBkYXRlcyBBUklBIGFjY2Vzc2liaWxpdHkgYXR0cmlidXRlc1xuICAgKi9cblxuXG4gIFBsYXliYWNrUmF0ZU1lbnVCdXR0b24ucHJvdG90eXBlLnVwZGF0ZUFSSUFBdHRyaWJ1dGVzID0gZnVuY3Rpb24gdXBkYXRlQVJJQUF0dHJpYnV0ZXMoKSB7XG4gICAgLy8gQ3VycmVudCBwbGF5YmFjayByYXRlXG4gICAgdGhpcy5lbCgpLnNldEF0dHJpYnV0ZSgnYXJpYS12YWx1ZW5vdycsIHRoaXMucGxheWVyKCkucGxheWJhY2tSYXRlKCkpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUaGlzIGdldHMgY2FsbGVkIHdoZW4gYW4gYFBsYXliYWNrUmF0ZU1lbnVCdXR0b25gIGlzIFwiY2xpY2tlZFwiLiBTZWVcbiAgICoge0BsaW5rIENsaWNrYWJsZUNvbXBvbmVudH0gZm9yIG1vcmUgZGV0YWlsZWQgaW5mb3JtYXRpb24gb24gd2hhdCBhIGNsaWNrIGNhbiBiZS5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gW2V2ZW50XVxuICAgKiAgICAgICAgVGhlIGBrZXlkb3duYCwgYHRhcGAsIG9yIGBjbGlja2AgZXZlbnQgdGhhdCBjYXVzZWQgdGhpcyBmdW5jdGlvbiB0byBiZVxuICAgKiAgICAgICAgY2FsbGVkLlxuICAgKlxuICAgKiBAbGlzdGVucyB0YXBcbiAgICogQGxpc3RlbnMgY2xpY2tcbiAgICovXG5cblxuICBQbGF5YmFja1JhdGVNZW51QnV0dG9uLnByb3RvdHlwZS5oYW5kbGVDbGljayA9IGZ1bmN0aW9uIGhhbmRsZUNsaWNrKGV2ZW50KSB7XG4gICAgLy8gc2VsZWN0IG5leHQgcmF0ZSBvcHRpb25cbiAgICB2YXIgY3VycmVudFJhdGUgPSB0aGlzLnBsYXllcigpLnBsYXliYWNrUmF0ZSgpO1xuICAgIHZhciByYXRlcyA9IHRoaXMucGxheWJhY2tSYXRlcygpO1xuXG4gICAgLy8gdGhpcyB3aWxsIHNlbGVjdCBmaXJzdCBvbmUgaWYgdGhlIGxhc3Qgb25lIGN1cnJlbnRseSBzZWxlY3RlZFxuICAgIHZhciBuZXdSYXRlID0gcmF0ZXNbMF07XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJhdGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAocmF0ZXNbaV0gPiBjdXJyZW50UmF0ZSkge1xuICAgICAgICBuZXdSYXRlID0gcmF0ZXNbaV07XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnBsYXllcigpLnBsYXliYWNrUmF0ZShuZXdSYXRlKTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHBvc3NpYmxlIHBsYXliYWNrIHJhdGVzXG4gICAqXG4gICAqIEByZXR1cm4ge0FycmF5fVxuICAgKiAgICAgICAgIEFsbCBwb3NzaWJsZSBwbGF5YmFjayByYXRlc1xuICAgKi9cblxuXG4gIFBsYXliYWNrUmF0ZU1lbnVCdXR0b24ucHJvdG90eXBlLnBsYXliYWNrUmF0ZXMgPSBmdW5jdGlvbiBwbGF5YmFja1JhdGVzKCkge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnNfLnBsYXliYWNrUmF0ZXMgfHwgdGhpcy5vcHRpb25zXy5wbGF5ZXJPcHRpb25zICYmIHRoaXMub3B0aW9uc18ucGxheWVyT3B0aW9ucy5wbGF5YmFja1JhdGVzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgd2hldGhlciBwbGF5YmFjayByYXRlcyBpcyBzdXBwb3J0ZWQgYnkgdGhlIHRlY2hcbiAgICogYW5kIGFuIGFycmF5IG9mIHBsYXliYWNrIHJhdGVzIGV4aXN0c1xuICAgKlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKiAgICAgICAgIFdoZXRoZXIgY2hhbmdpbmcgcGxheWJhY2sgcmF0ZSBpcyBzdXBwb3J0ZWRcbiAgICovXG5cblxuICBQbGF5YmFja1JhdGVNZW51QnV0dG9uLnByb3RvdHlwZS5wbGF5YmFja1JhdGVTdXBwb3J0ZWQgPSBmdW5jdGlvbiBwbGF5YmFja1JhdGVTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMucGxheWVyKCkudGVjaF8gJiYgdGhpcy5wbGF5ZXIoKS50ZWNoXy5mZWF0dXJlc1BsYXliYWNrUmF0ZSAmJiB0aGlzLnBsYXliYWNrUmF0ZXMoKSAmJiB0aGlzLnBsYXliYWNrUmF0ZXMoKS5sZW5ndGggPiAwO1xuICB9O1xuXG4gIC8qKlxuICAgKiBIaWRlIHBsYXliYWNrIHJhdGUgY29udHJvbHMgd2hlbiB0aGV5J3JlIG5vIHBsYXliYWNrIHJhdGUgb3B0aW9ucyB0byBzZWxlY3RcbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gW2V2ZW50XVxuICAgKiAgICAgICAgVGhlIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgZnVuY3Rpb24gdG8gcnVuLlxuICAgKlxuICAgKiBAbGlzdGVucyBQbGF5ZXIjbG9hZHN0YXJ0XG4gICAqL1xuXG5cbiAgUGxheWJhY2tSYXRlTWVudUJ1dHRvbi5wcm90b3R5cGUudXBkYXRlVmlzaWJpbGl0eSA9IGZ1bmN0aW9uIHVwZGF0ZVZpc2liaWxpdHkoZXZlbnQpIHtcbiAgICBpZiAodGhpcy5wbGF5YmFja1JhdGVTdXBwb3J0ZWQoKSkge1xuICAgICAgdGhpcy5yZW1vdmVDbGFzcygndmpzLWhpZGRlbicpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFkZENsYXNzKCd2anMtaGlkZGVuJyk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBVcGRhdGUgYnV0dG9uIGxhYmVsIHdoZW4gcmF0ZSBjaGFuZ2VkXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IFtldmVudF1cbiAgICogICAgICAgIFRoZSBldmVudCB0aGF0IGNhdXNlZCB0aGlzIGZ1bmN0aW9uIHRvIHJ1bi5cbiAgICpcbiAgICogQGxpc3RlbnMgUGxheWVyI3JhdGVjaGFuZ2VcbiAgICovXG5cblxuICBQbGF5YmFja1JhdGVNZW51QnV0dG9uLnByb3RvdHlwZS51cGRhdGVMYWJlbCA9IGZ1bmN0aW9uIHVwZGF0ZUxhYmVsKGV2ZW50KSB7XG4gICAgaWYgKHRoaXMucGxheWJhY2tSYXRlU3VwcG9ydGVkKCkpIHtcbiAgICAgIHRoaXMubGFiZWxFbF8uaW5uZXJIVE1MID0gdGhpcy5wbGF5ZXIoKS5wbGF5YmFja1JhdGUoKSArICd4JztcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIFBsYXliYWNrUmF0ZU1lbnVCdXR0b247XG59KE1lbnVCdXR0b24pO1xuXG4vKipcbiAqIFRoZSB0ZXh0IHRoYXQgc2hvdWxkIGRpc3BsYXkgb3ZlciB0aGUgYEZ1bGxzY3JlZW5Ub2dnbGVgcyBjb250cm9scy4gQWRkZWQgZm9yIGxvY2FsaXphdGlvbi5cbiAqXG4gKiBAdHlwZSB7c3RyaW5nfVxuICogQHByaXZhdGVcbiAqL1xuXG5cblBsYXliYWNrUmF0ZU1lbnVCdXR0b24ucHJvdG90eXBlLmNvbnRyb2xUZXh0XyA9ICdQbGF5YmFjayBSYXRlJztcblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdQbGF5YmFja1JhdGVNZW51QnV0dG9uJywgUGxheWJhY2tSYXRlTWVudUJ1dHRvbik7XG5cbi8qKlxuICogQGZpbGUgc3BhY2VyLmpzXG4gKi9cbi8qKlxuICogSnVzdCBhbiBlbXB0eSBzcGFjZXIgZWxlbWVudCB0aGF0IGNhbiBiZSB1c2VkIGFzIGFuIGFwcGVuZCBwb2ludCBmb3IgcGx1Z2lucywgZXRjLlxuICogQWxzbyBjYW4gYmUgdXNlZCB0byBjcmVhdGUgc3BhY2UgYmV0d2VlbiBlbGVtZW50cyB3aGVuIG5lY2Vzc2FyeS5cbiAqXG4gKiBAZXh0ZW5kcyBDb21wb25lbnRcbiAqL1xuXG52YXIgU3BhY2VyID0gZnVuY3Rpb24gKF9Db21wb25lbnQpIHtcbiAgaW5oZXJpdHMoU3BhY2VyLCBfQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBTcGFjZXIoKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgU3BhY2VyKTtcbiAgICByZXR1cm4gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfQ29tcG9uZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9XG5cbiAgLyoqXG4gICAqIEJ1aWxkcyB0aGUgZGVmYXVsdCBET00gYGNsYXNzTmFtZWAuXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICogICAgICAgICBUaGUgRE9NIGBjbGFzc05hbWVgIGZvciB0aGlzIG9iamVjdC5cbiAgICovXG4gIFNwYWNlci5wcm90b3R5cGUuYnVpbGRDU1NDbGFzcyA9IGZ1bmN0aW9uIGJ1aWxkQ1NTQ2xhc3MoKSB7XG4gICAgcmV0dXJuICd2anMtc3BhY2VyICcgKyBfQ29tcG9uZW50LnByb3RvdHlwZS5idWlsZENTU0NsYXNzLmNhbGwodGhpcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSB0aGUgYENvbXBvbmVudGAncyBET00gZWxlbWVudFxuICAgKlxuICAgKiBAcmV0dXJuIHtFbGVtZW50fVxuICAgKiAgICAgICAgIFRoZSBlbGVtZW50IHRoYXQgd2FzIGNyZWF0ZWQuXG4gICAqL1xuXG5cbiAgU3BhY2VyLnByb3RvdHlwZS5jcmVhdGVFbCA9IGZ1bmN0aW9uIGNyZWF0ZUVsKCkge1xuICAgIHJldHVybiBfQ29tcG9uZW50LnByb3RvdHlwZS5jcmVhdGVFbC5jYWxsKHRoaXMsICdkaXYnLCB7XG4gICAgICBjbGFzc05hbWU6IHRoaXMuYnVpbGRDU1NDbGFzcygpXG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIFNwYWNlcjtcbn0oQ29tcG9uZW50KTtcblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdTcGFjZXInLCBTcGFjZXIpO1xuXG4vKipcbiAqIEBmaWxlIGN1c3RvbS1jb250cm9sLXNwYWNlci5qc1xuICovXG4vKipcbiAqIFNwYWNlciBzcGVjaWZpY2FsbHkgbWVhbnQgdG8gYmUgdXNlZCBhcyBhbiBpbnNlcnRpb24gcG9pbnQgZm9yIG5ldyBwbHVnaW5zLCBldGMuXG4gKlxuICogQGV4dGVuZHMgU3BhY2VyXG4gKi9cblxudmFyIEN1c3RvbUNvbnRyb2xTcGFjZXIgPSBmdW5jdGlvbiAoX1NwYWNlcikge1xuICBpbmhlcml0cyhDdXN0b21Db250cm9sU3BhY2VyLCBfU3BhY2VyKTtcblxuICBmdW5jdGlvbiBDdXN0b21Db250cm9sU3BhY2VyKCkge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIEN1c3RvbUNvbnRyb2xTcGFjZXIpO1xuICAgIHJldHVybiBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9TcGFjZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH1cblxuICAvKipcbiAgICogQnVpbGRzIHRoZSBkZWZhdWx0IERPTSBgY2xhc3NOYW1lYC5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKiAgICAgICAgIFRoZSBET00gYGNsYXNzTmFtZWAgZm9yIHRoaXMgb2JqZWN0LlxuICAgKi9cbiAgQ3VzdG9tQ29udHJvbFNwYWNlci5wcm90b3R5cGUuYnVpbGRDU1NDbGFzcyA9IGZ1bmN0aW9uIGJ1aWxkQ1NTQ2xhc3MoKSB7XG4gICAgcmV0dXJuICd2anMtY3VzdG9tLWNvbnRyb2wtc3BhY2VyICcgKyBfU3BhY2VyLnByb3RvdHlwZS5idWlsZENTU0NsYXNzLmNhbGwodGhpcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSB0aGUgYENvbXBvbmVudGAncyBET00gZWxlbWVudFxuICAgKlxuICAgKiBAcmV0dXJuIHtFbGVtZW50fVxuICAgKiAgICAgICAgIFRoZSBlbGVtZW50IHRoYXQgd2FzIGNyZWF0ZWQuXG4gICAqL1xuXG5cbiAgQ3VzdG9tQ29udHJvbFNwYWNlci5wcm90b3R5cGUuY3JlYXRlRWwgPSBmdW5jdGlvbiBjcmVhdGVFbCgpIHtcbiAgICB2YXIgZWwgPSBfU3BhY2VyLnByb3RvdHlwZS5jcmVhdGVFbC5jYWxsKHRoaXMsIHtcbiAgICAgIGNsYXNzTmFtZTogdGhpcy5idWlsZENTU0NsYXNzKClcbiAgICB9KTtcblxuICAgIC8vIE5vLWZsZXgvdGFibGUtY2VsbCBtb2RlIHJlcXVpcmVzIHRoZXJlIGJlIHNvbWUgY29udGVudFxuICAgIC8vIGluIHRoZSBjZWxsIHRvIGZpbGwgdGhlIHJlbWFpbmluZyBzcGFjZSBvZiB0aGUgdGFibGUuXG4gICAgZWwuaW5uZXJIVE1MID0gJ1xceEEwJztcbiAgICByZXR1cm4gZWw7XG4gIH07XG5cbiAgcmV0dXJuIEN1c3RvbUNvbnRyb2xTcGFjZXI7XG59KFNwYWNlcik7XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnQ3VzdG9tQ29udHJvbFNwYWNlcicsIEN1c3RvbUNvbnRyb2xTcGFjZXIpO1xuXG4vKipcbiAqIEBmaWxlIGNvbnRyb2wtYmFyLmpzXG4gKi9cbi8vIFJlcXVpcmVkIGNoaWxkcmVuXG4vKipcbiAqIENvbnRhaW5lciBvZiBtYWluIGNvbnRyb2xzLlxuICpcbiAqIEBleHRlbmRzIENvbXBvbmVudFxuICovXG5cbnZhciBDb250cm9sQmFyID0gZnVuY3Rpb24gKF9Db21wb25lbnQpIHtcbiAgaW5oZXJpdHMoQ29udHJvbEJhciwgX0NvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gQ29udHJvbEJhcigpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBDb250cm9sQmFyKTtcbiAgICByZXR1cm4gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfQ29tcG9uZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSB0aGUgYENvbXBvbmVudGAncyBET00gZWxlbWVudFxuICAgKlxuICAgKiBAcmV0dXJuIHtFbGVtZW50fVxuICAgKiAgICAgICAgIFRoZSBlbGVtZW50IHRoYXQgd2FzIGNyZWF0ZWQuXG4gICAqL1xuICBDb250cm9sQmFyLnByb3RvdHlwZS5jcmVhdGVFbCA9IGZ1bmN0aW9uIGNyZWF0ZUVsKCkge1xuICAgIHJldHVybiBfQ29tcG9uZW50LnByb3RvdHlwZS5jcmVhdGVFbC5jYWxsKHRoaXMsICdkaXYnLCB7XG4gICAgICBjbGFzc05hbWU6ICd2anMtY29udHJvbC1iYXInLFxuICAgICAgZGlyOiAnbHRyJ1xuICAgIH0pO1xuICB9O1xuXG4gIHJldHVybiBDb250cm9sQmFyO1xufShDb21wb25lbnQpO1xuXG4vKipcbiAqIERlZmF1bHQgb3B0aW9ucyBmb3IgYENvbnRyb2xCYXJgXG4gKlxuICogQHR5cGUge09iamVjdH1cbiAqIEBwcml2YXRlXG4gKi9cblxuXG5Db250cm9sQmFyLnByb3RvdHlwZS5vcHRpb25zXyA9IHtcbiAgY2hpbGRyZW46IFsncGxheVRvZ2dsZScsICd2b2x1bWVQYW5lbCcsICdjdXJyZW50VGltZURpc3BsYXknLCAndGltZURpdmlkZXInLCAnZHVyYXRpb25EaXNwbGF5JywgJ3Byb2dyZXNzQ29udHJvbCcsICdsaXZlRGlzcGxheScsICdyZW1haW5pbmdUaW1lRGlzcGxheScsICdjdXN0b21Db250cm9sU3BhY2VyJywgJ3BsYXliYWNrUmF0ZU1lbnVCdXR0b24nLCAnY2hhcHRlcnNCdXR0b24nLCAnZGVzY3JpcHRpb25zQnV0dG9uJywgJ3N1YnNDYXBzQnV0dG9uJywgJ2F1ZGlvVHJhY2tCdXR0b24nLCAnZnVsbHNjcmVlblRvZ2dsZSddXG59O1xuXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ0NvbnRyb2xCYXInLCBDb250cm9sQmFyKTtcblxuLyoqXG4gKiBAZmlsZSBlcnJvci1kaXNwbGF5LmpzXG4gKi9cbi8qKlxuICogQSBkaXNwbGF5IHRoYXQgaW5kaWNhdGVzIGFuIGVycm9yIGhhcyBvY2N1cnJlZC4gVGhpcyBtZWFucyB0aGF0IHRoZSB2aWRlb1xuICogaXMgdW5wbGF5YWJsZS5cbiAqXG4gKiBAZXh0ZW5kcyBNb2RhbERpYWxvZ1xuICovXG5cbnZhciBFcnJvckRpc3BsYXkgPSBmdW5jdGlvbiAoX01vZGFsRGlhbG9nKSB7XG4gIGluaGVyaXRzKEVycm9yRGlzcGxheSwgX01vZGFsRGlhbG9nKTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxuICAgKlxuICAgKiBAcGFyYW0gIHtQbGF5ZXJ9IHBsYXllclxuICAgKiAgICAgICAgIFRoZSBgUGxheWVyYCB0aGF0IHRoaXMgY2xhc3Mgc2hvdWxkIGJlIGF0dGFjaGVkIHRvLlxuICAgKlxuICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgICAgICAgIFRoZSBrZXkvdmFsdWUgc3RvcmUgb2YgcGxheWVyIG9wdGlvbnMuXG4gICAqL1xuICBmdW5jdGlvbiBFcnJvckRpc3BsYXkocGxheWVyLCBvcHRpb25zKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgRXJyb3JEaXNwbGF5KTtcblxuICAgIHZhciBfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX01vZGFsRGlhbG9nLmNhbGwodGhpcywgcGxheWVyLCBvcHRpb25zKSk7XG5cbiAgICBfdGhpcy5vbihwbGF5ZXIsICdlcnJvcicsIF90aGlzLm9wZW4pO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBCdWlsZHMgdGhlIGRlZmF1bHQgRE9NIGBjbGFzc05hbWVgLlxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqICAgICAgICAgVGhlIERPTSBgY2xhc3NOYW1lYCBmb3IgdGhpcyBvYmplY3QuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFNpbmNlIHZlcnNpb24gNS5cbiAgICovXG5cblxuICBFcnJvckRpc3BsYXkucHJvdG90eXBlLmJ1aWxkQ1NTQ2xhc3MgPSBmdW5jdGlvbiBidWlsZENTU0NsYXNzKCkge1xuICAgIHJldHVybiAndmpzLWVycm9yLWRpc3BsYXkgJyArIF9Nb2RhbERpYWxvZy5wcm90b3R5cGUuYnVpbGRDU1NDbGFzcy5jYWxsKHRoaXMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBsb2NhbGl6ZWQgZXJyb3IgbWVzc2FnZSBiYXNlZCBvbiB0aGUgYFBsYXllcmBzIGVycm9yLlxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqICAgICAgICAgVGhlIGBQbGF5ZXJgcyBlcnJvciBtZXNzYWdlIGxvY2FsaXplZCBvciBhbiBlbXB0eSBzdHJpbmcuXG4gICAqL1xuXG5cbiAgRXJyb3JEaXNwbGF5LnByb3RvdHlwZS5jb250ZW50ID0gZnVuY3Rpb24gY29udGVudCgpIHtcbiAgICB2YXIgZXJyb3IgPSB0aGlzLnBsYXllcigpLmVycm9yKCk7XG5cbiAgICByZXR1cm4gZXJyb3IgPyB0aGlzLmxvY2FsaXplKGVycm9yLm1lc3NhZ2UpIDogJyc7XG4gIH07XG5cbiAgcmV0dXJuIEVycm9yRGlzcGxheTtcbn0oTW9kYWxEaWFsb2cpO1xuXG4vKipcbiAqIFRoZSBkZWZhdWx0IG9wdGlvbnMgZm9yIGFuIGBFcnJvckRpc3BsYXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cblxuXG5FcnJvckRpc3BsYXkucHJvdG90eXBlLm9wdGlvbnNfID0gbWVyZ2VPcHRpb25zKE1vZGFsRGlhbG9nLnByb3RvdHlwZS5vcHRpb25zXywge1xuICBwYXVzZU9uT3BlbjogZmFsc2UsXG4gIGZpbGxBbHdheXM6IHRydWUsXG4gIHRlbXBvcmFyeTogZmFsc2UsXG4gIHVuY2xvc2VhYmxlOiB0cnVlXG59KTtcblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdFcnJvckRpc3BsYXknLCBFcnJvckRpc3BsYXkpO1xuXG4vKipcbiAqIEBmaWxlIHRleHQtdHJhY2stc2V0dGluZ3MuanNcbiAqL1xudmFyIExPQ0FMX1NUT1JBR0VfS0VZID0gJ3Zqcy10ZXh0LXRyYWNrLXNldHRpbmdzJztcblxudmFyIENPTE9SX0JMQUNLID0gWycjMDAwJywgJ0JsYWNrJ107XG52YXIgQ09MT1JfQkxVRSA9IFsnIzAwRicsICdCbHVlJ107XG52YXIgQ09MT1JfQ1lBTiA9IFsnIzBGRicsICdDeWFuJ107XG52YXIgQ09MT1JfR1JFRU4gPSBbJyMwRjAnLCAnR3JlZW4nXTtcbnZhciBDT0xPUl9NQUdFTlRBID0gWycjRjBGJywgJ01hZ2VudGEnXTtcbnZhciBDT0xPUl9SRUQgPSBbJyNGMDAnLCAnUmVkJ107XG52YXIgQ09MT1JfV0hJVEUgPSBbJyNGRkYnLCAnV2hpdGUnXTtcbnZhciBDT0xPUl9ZRUxMT1cgPSBbJyNGRjAnLCAnWWVsbG93J107XG5cbnZhciBPUEFDSVRZX09QQVFVRSA9IFsnMScsICdPcGFxdWUnXTtcbnZhciBPUEFDSVRZX1NFTUkgPSBbJzAuNScsICdTZW1pLVRyYW5zcGFyZW50J107XG52YXIgT1BBQ0lUWV9UUkFOUyA9IFsnMCcsICdUcmFuc3BhcmVudCddO1xuXG4vLyBDb25maWd1cmF0aW9uIGZvciB0aGUgdmFyaW91cyA8c2VsZWN0PiBlbGVtZW50cyBpbiB0aGUgRE9NIG9mIHRoaXMgY29tcG9uZW50LlxuLy9cbi8vIFBvc3NpYmxlIGtleXMgaW5jbHVkZTpcbi8vXG4vLyBgZGVmYXVsdGA6XG4vLyAgIFRoZSBkZWZhdWx0IG9wdGlvbiBpbmRleC4gT25seSBuZWVkcyB0byBiZSBwcm92aWRlZCBpZiBub3QgemVyby5cbi8vIGBwYXJzZXJgOlxuLy8gICBBIGZ1bmN0aW9uIHdoaWNoIGlzIHVzZWQgdG8gcGFyc2UgdGhlIHZhbHVlIGZyb20gdGhlIHNlbGVjdGVkIG9wdGlvbiBpblxuLy8gICBhIGN1c3RvbWl6ZWQgd2F5LlxuLy8gYHNlbGVjdG9yYDpcbi8vICAgVGhlIHNlbGVjdG9yIHVzZWQgdG8gZmluZCB0aGUgYXNzb2NpYXRlZCA8c2VsZWN0PiBlbGVtZW50LlxudmFyIHNlbGVjdENvbmZpZ3MgPSB7XG4gIGJhY2tncm91bmRDb2xvcjoge1xuICAgIHNlbGVjdG9yOiAnLnZqcy1iZy1jb2xvciA+IHNlbGVjdCcsXG4gICAgaWQ6ICdjYXB0aW9ucy1iYWNrZ3JvdW5kLWNvbG9yLSVzJyxcbiAgICBsYWJlbDogJ0NvbG9yJyxcbiAgICBvcHRpb25zOiBbQ09MT1JfQkxBQ0ssIENPTE9SX1dISVRFLCBDT0xPUl9SRUQsIENPTE9SX0dSRUVOLCBDT0xPUl9CTFVFLCBDT0xPUl9ZRUxMT1csIENPTE9SX01BR0VOVEEsIENPTE9SX0NZQU5dXG4gIH0sXG5cbiAgYmFja2dyb3VuZE9wYWNpdHk6IHtcbiAgICBzZWxlY3RvcjogJy52anMtYmctb3BhY2l0eSA+IHNlbGVjdCcsXG4gICAgaWQ6ICdjYXB0aW9ucy1iYWNrZ3JvdW5kLW9wYWNpdHktJXMnLFxuICAgIGxhYmVsOiAnVHJhbnNwYXJlbmN5JyxcbiAgICBvcHRpb25zOiBbT1BBQ0lUWV9PUEFRVUUsIE9QQUNJVFlfU0VNSSwgT1BBQ0lUWV9UUkFOU11cbiAgfSxcblxuICBjb2xvcjoge1xuICAgIHNlbGVjdG9yOiAnLnZqcy1mZy1jb2xvciA+IHNlbGVjdCcsXG4gICAgaWQ6ICdjYXB0aW9ucy1mb3JlZ3JvdW5kLWNvbG9yLSVzJyxcbiAgICBsYWJlbDogJ0NvbG9yJyxcbiAgICBvcHRpb25zOiBbQ09MT1JfV0hJVEUsIENPTE9SX0JMQUNLLCBDT0xPUl9SRUQsIENPTE9SX0dSRUVOLCBDT0xPUl9CTFVFLCBDT0xPUl9ZRUxMT1csIENPTE9SX01BR0VOVEEsIENPTE9SX0NZQU5dXG4gIH0sXG5cbiAgZWRnZVN0eWxlOiB7XG4gICAgc2VsZWN0b3I6ICcudmpzLWVkZ2Utc3R5bGUgPiBzZWxlY3QnLFxuICAgIGlkOiAnJXMnLFxuICAgIGxhYmVsOiAnVGV4dCBFZGdlIFN0eWxlJyxcbiAgICBvcHRpb25zOiBbWydub25lJywgJ05vbmUnXSwgWydyYWlzZWQnLCAnUmFpc2VkJ10sIFsnZGVwcmVzc2VkJywgJ0RlcHJlc3NlZCddLCBbJ3VuaWZvcm0nLCAnVW5pZm9ybSddLCBbJ2Ryb3BzaGFkb3cnLCAnRHJvcHNoYWRvdyddXVxuICB9LFxuXG4gIGZvbnRGYW1pbHk6IHtcbiAgICBzZWxlY3RvcjogJy52anMtZm9udC1mYW1pbHkgPiBzZWxlY3QnLFxuICAgIGlkOiAnY2FwdGlvbnMtZm9udC1mYW1pbHktJXMnLFxuICAgIGxhYmVsOiAnRm9udCBGYW1pbHknLFxuICAgIG9wdGlvbnM6IFtbJ3Byb3BvcnRpb25hbFNhbnNTZXJpZicsICdQcm9wb3J0aW9uYWwgU2Fucy1TZXJpZiddLCBbJ21vbm9zcGFjZVNhbnNTZXJpZicsICdNb25vc3BhY2UgU2Fucy1TZXJpZiddLCBbJ3Byb3BvcnRpb25hbFNlcmlmJywgJ1Byb3BvcnRpb25hbCBTZXJpZiddLCBbJ21vbm9zcGFjZVNlcmlmJywgJ01vbm9zcGFjZSBTZXJpZiddLCBbJ2Nhc3VhbCcsICdDYXN1YWwnXSwgWydzY3JpcHQnLCAnU2NyaXB0J10sIFsnc21hbGwtY2FwcycsICdTbWFsbCBDYXBzJ11dXG4gIH0sXG5cbiAgZm9udFBlcmNlbnQ6IHtcbiAgICBzZWxlY3RvcjogJy52anMtZm9udC1wZXJjZW50ID4gc2VsZWN0JyxcbiAgICBpZDogJ2NhcHRpb25zLWZvbnQtc2l6ZS0lcycsXG4gICAgbGFiZWw6ICdGb250IFNpemUnLFxuICAgIG9wdGlvbnM6IFtbJzAuNTAnLCAnNTAlJ10sIFsnMC43NScsICc3NSUnXSwgWycxLjAwJywgJzEwMCUnXSwgWycxLjI1JywgJzEyNSUnXSwgWycxLjUwJywgJzE1MCUnXSwgWycxLjc1JywgJzE3NSUnXSwgWycyLjAwJywgJzIwMCUnXSwgWyczLjAwJywgJzMwMCUnXSwgWyc0LjAwJywgJzQwMCUnXV0sXG4gICAgJ2RlZmF1bHQnOiAyLFxuICAgIHBhcnNlcjogZnVuY3Rpb24gcGFyc2VyKHYpIHtcbiAgICAgIHJldHVybiB2ID09PSAnMS4wMCcgPyBudWxsIDogTnVtYmVyKHYpO1xuICAgIH1cbiAgfSxcblxuICB0ZXh0T3BhY2l0eToge1xuICAgIHNlbGVjdG9yOiAnLnZqcy10ZXh0LW9wYWNpdHkgPiBzZWxlY3QnLFxuICAgIGlkOiAnY2FwdGlvbnMtZm9yZWdyb3VuZC1vcGFjaXR5LSVzJyxcbiAgICBsYWJlbDogJ1RyYW5zcGFyZW5jeScsXG4gICAgb3B0aW9uczogW09QQUNJVFlfT1BBUVVFLCBPUEFDSVRZX1NFTUldXG4gIH0sXG5cbiAgLy8gT3B0aW9ucyBmb3IgdGhpcyBvYmplY3QgYXJlIGRlZmluZWQgYmVsb3cuXG4gIHdpbmRvd0NvbG9yOiB7XG4gICAgc2VsZWN0b3I6ICcudmpzLXdpbmRvdy1jb2xvciA+IHNlbGVjdCcsXG4gICAgaWQ6ICdjYXB0aW9ucy13aW5kb3ctY29sb3ItJXMnLFxuICAgIGxhYmVsOiAnQ29sb3InXG4gIH0sXG5cbiAgLy8gT3B0aW9ucyBmb3IgdGhpcyBvYmplY3QgYXJlIGRlZmluZWQgYmVsb3cuXG4gIHdpbmRvd09wYWNpdHk6IHtcbiAgICBzZWxlY3RvcjogJy52anMtd2luZG93LW9wYWNpdHkgPiBzZWxlY3QnLFxuICAgIGlkOiAnY2FwdGlvbnMtd2luZG93LW9wYWNpdHktJXMnLFxuICAgIGxhYmVsOiAnVHJhbnNwYXJlbmN5JyxcbiAgICBvcHRpb25zOiBbT1BBQ0lUWV9UUkFOUywgT1BBQ0lUWV9TRU1JLCBPUEFDSVRZX09QQVFVRV1cbiAgfVxufTtcblxuc2VsZWN0Q29uZmlncy53aW5kb3dDb2xvci5vcHRpb25zID0gc2VsZWN0Q29uZmlncy5iYWNrZ3JvdW5kQ29sb3Iub3B0aW9ucztcblxuLyoqXG4gKiBHZXQgdGhlIGFjdHVhbCB2YWx1ZSBvZiBhbiBvcHRpb24uXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfSB2YWx1ZVxuICogICAgICAgICBUaGUgdmFsdWUgdG8gZ2V0XG4gKlxuICogQHBhcmFtICB7RnVuY3Rpb259IFtwYXJzZXJdXG4gKiAgICAgICAgIE9wdGlvbmFsIGZ1bmN0aW9uIHRvIGFkanVzdCB0aGUgdmFsdWUuXG4gKlxuICogQHJldHVybiB7TWl4ZWR9XG4gKiAgICAgICAgIC0gV2lsbCBiZSBgdW5kZWZpbmVkYCBpZiBubyB2YWx1ZSBleGlzdHNcbiAqICAgICAgICAgLSBXaWxsIGJlIGB1bmRlZmluZWRgIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBcIm5vbmVcIi5cbiAqICAgICAgICAgLSBXaWxsIGJlIHRoZSBhY3R1YWwgdmFsdWUgb3RoZXJ3aXNlLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHBhcnNlT3B0aW9uVmFsdWUodmFsdWUsIHBhcnNlcikge1xuICBpZiAocGFyc2VyKSB7XG4gICAgdmFsdWUgPSBwYXJzZXIodmFsdWUpO1xuICB9XG5cbiAgaWYgKHZhbHVlICYmIHZhbHVlICE9PSAnbm9uZScpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbn1cblxuLyoqXG4gKiBHZXRzIHRoZSB2YWx1ZSBvZiB0aGUgc2VsZWN0ZWQgPG9wdGlvbj4gZWxlbWVudCB3aXRoaW4gYSA8c2VsZWN0PiBlbGVtZW50LlxuICpcbiAqIEBwYXJhbSAge0VsZW1lbnR9IGVsXG4gKiAgICAgICAgIHRoZSBlbGVtZW50IHRvIGxvb2sgaW5cbiAqXG4gKiBAcGFyYW0gIHtGdW5jdGlvbn0gW3BhcnNlcl1cbiAqICAgICAgICAgT3B0aW9uYWwgZnVuY3Rpb24gdG8gYWRqdXN0IHRoZSB2YWx1ZS5cbiAqXG4gKiBAcmV0dXJuIHtNaXhlZH1cbiAqICAgICAgICAgLSBXaWxsIGJlIGB1bmRlZmluZWRgIGlmIG5vIHZhbHVlIGV4aXN0c1xuICogICAgICAgICAtIFdpbGwgYmUgYHVuZGVmaW5lZGAgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIFwibm9uZVwiLlxuICogICAgICAgICAtIFdpbGwgYmUgdGhlIGFjdHVhbCB2YWx1ZSBvdGhlcndpc2UuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZ2V0U2VsZWN0ZWRPcHRpb25WYWx1ZShlbCwgcGFyc2VyKSB7XG4gIHZhciB2YWx1ZSA9IGVsLm9wdGlvbnNbZWwub3B0aW9ucy5zZWxlY3RlZEluZGV4XS52YWx1ZTtcblxuICByZXR1cm4gcGFyc2VPcHRpb25WYWx1ZSh2YWx1ZSwgcGFyc2VyKTtcbn1cblxuLyoqXG4gKiBTZXRzIHRoZSBzZWxlY3RlZCA8b3B0aW9uPiBlbGVtZW50IHdpdGhpbiBhIDxzZWxlY3Q+IGVsZW1lbnQgYmFzZWQgb24gYVxuICogZ2l2ZW4gdmFsdWUuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogICAgICAgIFRoZSBlbGVtZW50IHRvIGxvb2sgaW4uXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gKiAgICAgICAgdGhlIHByb3BlcnR5IHRvIGxvb2sgb24uXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW3BhcnNlcl1cbiAqICAgICAgICBPcHRpb25hbCBmdW5jdGlvbiB0byBhZGp1c3QgdGhlIHZhbHVlIGJlZm9yZSBjb21wYXJpbmcuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc2V0U2VsZWN0ZWRPcHRpb24oZWwsIHZhbHVlLCBwYXJzZXIpIHtcbiAgaWYgKCF2YWx1ZSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZWwub3B0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChwYXJzZU9wdGlvblZhbHVlKGVsLm9wdGlvbnNbaV0udmFsdWUsIHBhcnNlcikgPT09IHZhbHVlKSB7XG4gICAgICBlbC5zZWxlY3RlZEluZGV4ID0gaTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIE1hbmlwdWxhdGUgVGV4dCBUcmFja3Mgc2V0dGluZ3MuXG4gKlxuICogQGV4dGVuZHMgTW9kYWxEaWFsb2dcbiAqL1xuXG52YXIgVGV4dFRyYWNrU2V0dGluZ3MgPSBmdW5jdGlvbiAoX01vZGFsRGlhbG9nKSB7XG4gIGluaGVyaXRzKFRleHRUcmFja1NldHRpbmdzLCBfTW9kYWxEaWFsb2cpO1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7UGxheWVyfSBwbGF5ZXJcbiAgICogICAgICAgICBUaGUgYFBsYXllcmAgdGhhdCB0aGlzIGNsYXNzIHNob3VsZCBiZSBhdHRhY2hlZCB0by5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgICAgICAgIFRoZSBrZXkvdmFsdWUgc3RvcmUgb2YgcGxheWVyIG9wdGlvbnMuXG4gICAqL1xuICBmdW5jdGlvbiBUZXh0VHJhY2tTZXR0aW5ncyhwbGF5ZXIsIG9wdGlvbnMpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBUZXh0VHJhY2tTZXR0aW5ncyk7XG5cbiAgICBvcHRpb25zLnRlbXBvcmFyeSA9IGZhbHNlO1xuXG4gICAgdmFyIF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfTW9kYWxEaWFsb2cuY2FsbCh0aGlzLCBwbGF5ZXIsIG9wdGlvbnMpKTtcblxuICAgIF90aGlzLnVwZGF0ZURpc3BsYXkgPSBiaW5kKF90aGlzLCBfdGhpcy51cGRhdGVEaXNwbGF5KTtcblxuICAgIC8vIGZpbGwgdGhlIG1vZGFsIGFuZCBwcmV0ZW5kIHdlIGhhdmUgb3BlbmVkIGl0XG4gICAgX3RoaXMuZmlsbCgpO1xuICAgIF90aGlzLmhhc0JlZW5PcGVuZWRfID0gX3RoaXMuaGFzQmVlbkZpbGxlZF8gPSB0cnVlO1xuXG4gICAgX3RoaXMuZW5kRGlhbG9nID0gY3JlYXRlRWwoJ3AnLCB7XG4gICAgICBjbGFzc05hbWU6ICd2anMtY29udHJvbC10ZXh0JyxcbiAgICAgIHRleHRDb250ZW50OiBfdGhpcy5sb2NhbGl6ZSgnRW5kIG9mIGRpYWxvZyB3aW5kb3cuJylcbiAgICB9KTtcbiAgICBfdGhpcy5lbCgpLmFwcGVuZENoaWxkKF90aGlzLmVuZERpYWxvZyk7XG5cbiAgICBfdGhpcy5zZXREZWZhdWx0cygpO1xuXG4gICAgLy8gR3JhYiBgcGVyc2lzdFRleHRUcmFja1NldHRpbmdzYCBmcm9tIHRoZSBwbGF5ZXIgb3B0aW9ucyBpZiBub3QgcGFzc2VkIGluIGNoaWxkIG9wdGlvbnNcbiAgICBpZiAob3B0aW9ucy5wZXJzaXN0VGV4dFRyYWNrU2V0dGluZ3MgPT09IHVuZGVmaW5lZCkge1xuICAgICAgX3RoaXMub3B0aW9uc18ucGVyc2lzdFRleHRUcmFja1NldHRpbmdzID0gX3RoaXMub3B0aW9uc18ucGxheWVyT3B0aW9ucy5wZXJzaXN0VGV4dFRyYWNrU2V0dGluZ3M7XG4gICAgfVxuXG4gICAgX3RoaXMub24oX3RoaXMuJCgnLnZqcy1kb25lLWJ1dHRvbicpLCAnY2xpY2snLCBmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpcy5zYXZlU2V0dGluZ3MoKTtcbiAgICAgIF90aGlzLmNsb3NlKCk7XG4gICAgfSk7XG5cbiAgICBfdGhpcy5vbihfdGhpcy4kKCcudmpzLWRlZmF1bHQtYnV0dG9uJyksICdjbGljaycsIGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzLnNldERlZmF1bHRzKCk7XG4gICAgICBfdGhpcy51cGRhdGVEaXNwbGF5KCk7XG4gICAgfSk7XG5cbiAgICBlYWNoKHNlbGVjdENvbmZpZ3MsIGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICAgIF90aGlzLm9uKF90aGlzLiQoY29uZmlnLnNlbGVjdG9yKSwgJ2NoYW5nZScsIF90aGlzLnVwZGF0ZURpc3BsYXkpO1xuICAgIH0pO1xuXG4gICAgaWYgKF90aGlzLm9wdGlvbnNfLnBlcnNpc3RUZXh0VHJhY2tTZXR0aW5ncykge1xuICAgICAgX3RoaXMucmVzdG9yZVNldHRpbmdzKCk7XG4gICAgfVxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIFRleHRUcmFja1NldHRpbmdzLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gZGlzcG9zZSgpIHtcbiAgICB0aGlzLmVuZERpYWxvZyA9IG51bGw7XG5cbiAgICBfTW9kYWxEaWFsb2cucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlIGEgPHNlbGVjdD4gZWxlbWVudCB3aXRoIGNvbmZpZ3VyZWQgb3B0aW9ucy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICAgKiAgICAgICAgQ29uZmlndXJhdGlvbiBrZXkgdG8gdXNlIGR1cmluZyBjcmVhdGlvbi5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKiAgICAgICAgIEFuIEhUTUwgc3RyaW5nLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIFRleHRUcmFja1NldHRpbmdzLnByb3RvdHlwZS5jcmVhdGVFbFNlbGVjdF8gPSBmdW5jdGlvbiBjcmVhdGVFbFNlbGVjdF8oa2V5KSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICB2YXIgbGVnZW5kSWQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6ICcnO1xuICAgIHZhciB0eXBlID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAnbGFiZWwnO1xuXG4gICAgdmFyIGNvbmZpZyA9IHNlbGVjdENvbmZpZ3Nba2V5XTtcbiAgICB2YXIgaWQgPSBjb25maWcuaWQucmVwbGFjZSgnJXMnLCB0aGlzLmlkXyk7XG4gICAgdmFyIHNlbGVjdExhYmVsbGVkYnlJZHMgPSBbbGVnZW5kSWQsIGlkXS5qb2luKCcgJykudHJpbSgpO1xuXG4gICAgcmV0dXJuIFsnPCcgKyB0eXBlICsgJyBpZD1cIicgKyBpZCArICdcIiBjbGFzcz1cIicgKyAodHlwZSA9PT0gJ2xhYmVsJyA/ICd2anMtbGFiZWwnIDogJycpICsgJ1wiPicsIHRoaXMubG9jYWxpemUoY29uZmlnLmxhYmVsKSwgJzwvJyArIHR5cGUgKyAnPicsICc8c2VsZWN0IGFyaWEtbGFiZWxsZWRieT1cIicgKyBzZWxlY3RMYWJlbGxlZGJ5SWRzICsgJ1wiPiddLmNvbmNhdChjb25maWcub3B0aW9ucy5tYXAoZnVuY3Rpb24gKG8pIHtcbiAgICAgIHZhciBvcHRpb25JZCA9IGlkICsgJy0nICsgb1sxXS5yZXBsYWNlKC9cXFcrL2csICcnKTtcblxuICAgICAgcmV0dXJuIFsnPG9wdGlvbiBpZD1cIicgKyBvcHRpb25JZCArICdcIiB2YWx1ZT1cIicgKyBvWzBdICsgJ1wiICcsICdhcmlhLWxhYmVsbGVkYnk9XCInICsgc2VsZWN0TGFiZWxsZWRieUlkcyArICcgJyArIG9wdGlvbklkICsgJ1wiPicsIF90aGlzMi5sb2NhbGl6ZShvWzFdKSwgJzwvb3B0aW9uPiddLmpvaW4oJycpO1xuICAgIH0pKS5jb25jYXQoJzwvc2VsZWN0PicpLmpvaW4oJycpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgZm9yZWdyb3VuZCBjb2xvciBlbGVtZW50IGZvciB0aGUgY29tcG9uZW50XG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICogICAgICAgICBBbiBIVE1MIHN0cmluZy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBUZXh0VHJhY2tTZXR0aW5ncy5wcm90b3R5cGUuY3JlYXRlRWxGZ0NvbG9yXyA9IGZ1bmN0aW9uIGNyZWF0ZUVsRmdDb2xvcl8oKSB7XG4gICAgdmFyIGxlZ2VuZElkID0gJ2NhcHRpb25zLXRleHQtbGVnZW5kLScgKyB0aGlzLmlkXztcblxuICAgIHJldHVybiBbJzxmaWVsZHNldCBjbGFzcz1cInZqcy1mZy1jb2xvciB2anMtdHJhY2stc2V0dGluZ1wiPicsICc8bGVnZW5kIGlkPVwiJyArIGxlZ2VuZElkICsgJ1wiPicsIHRoaXMubG9jYWxpemUoJ1RleHQnKSwgJzwvbGVnZW5kPicsIHRoaXMuY3JlYXRlRWxTZWxlY3RfKCdjb2xvcicsIGxlZ2VuZElkKSwgJzxzcGFuIGNsYXNzPVwidmpzLXRleHQtb3BhY2l0eSB2anMtb3BhY2l0eVwiPicsIHRoaXMuY3JlYXRlRWxTZWxlY3RfKCd0ZXh0T3BhY2l0eScsIGxlZ2VuZElkKSwgJzwvc3Bhbj4nLCAnPC9maWVsZHNldD4nXS5qb2luKCcnKTtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlIGJhY2tncm91bmQgY29sb3IgZWxlbWVudCBmb3IgdGhlIGNvbXBvbmVudFxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqICAgICAgICAgQW4gSFRNTCBzdHJpbmcuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgVGV4dFRyYWNrU2V0dGluZ3MucHJvdG90eXBlLmNyZWF0ZUVsQmdDb2xvcl8gPSBmdW5jdGlvbiBjcmVhdGVFbEJnQ29sb3JfKCkge1xuICAgIHZhciBsZWdlbmRJZCA9ICdjYXB0aW9ucy1iYWNrZ3JvdW5kLScgKyB0aGlzLmlkXztcblxuICAgIHJldHVybiBbJzxmaWVsZHNldCBjbGFzcz1cInZqcy1iZy1jb2xvciB2anMtdHJhY2stc2V0dGluZ1wiPicsICc8bGVnZW5kIGlkPVwiJyArIGxlZ2VuZElkICsgJ1wiPicsIHRoaXMubG9jYWxpemUoJ0JhY2tncm91bmQnKSwgJzwvbGVnZW5kPicsIHRoaXMuY3JlYXRlRWxTZWxlY3RfKCdiYWNrZ3JvdW5kQ29sb3InLCBsZWdlbmRJZCksICc8c3BhbiBjbGFzcz1cInZqcy1iZy1vcGFjaXR5IHZqcy1vcGFjaXR5XCI+JywgdGhpcy5jcmVhdGVFbFNlbGVjdF8oJ2JhY2tncm91bmRPcGFjaXR5JywgbGVnZW5kSWQpLCAnPC9zcGFuPicsICc8L2ZpZWxkc2V0PiddLmpvaW4oJycpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgd2luZG93IGNvbG9yIGVsZW1lbnQgZm9yIHRoZSBjb21wb25lbnRcbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKiAgICAgICAgIEFuIEhUTUwgc3RyaW5nLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIFRleHRUcmFja1NldHRpbmdzLnByb3RvdHlwZS5jcmVhdGVFbFdpbkNvbG9yXyA9IGZ1bmN0aW9uIGNyZWF0ZUVsV2luQ29sb3JfKCkge1xuICAgIHZhciBsZWdlbmRJZCA9ICdjYXB0aW9ucy13aW5kb3ctJyArIHRoaXMuaWRfO1xuXG4gICAgcmV0dXJuIFsnPGZpZWxkc2V0IGNsYXNzPVwidmpzLXdpbmRvdy1jb2xvciB2anMtdHJhY2stc2V0dGluZ1wiPicsICc8bGVnZW5kIGlkPVwiJyArIGxlZ2VuZElkICsgJ1wiPicsIHRoaXMubG9jYWxpemUoJ1dpbmRvdycpLCAnPC9sZWdlbmQ+JywgdGhpcy5jcmVhdGVFbFNlbGVjdF8oJ3dpbmRvd0NvbG9yJywgbGVnZW5kSWQpLCAnPHNwYW4gY2xhc3M9XCJ2anMtd2luZG93LW9wYWNpdHkgdmpzLW9wYWNpdHlcIj4nLCB0aGlzLmNyZWF0ZUVsU2VsZWN0Xygnd2luZG93T3BhY2l0eScsIGxlZ2VuZElkKSwgJzwvc3Bhbj4nLCAnPC9maWVsZHNldD4nXS5qb2luKCcnKTtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlIGNvbG9yIGVsZW1lbnRzIGZvciB0aGUgY29tcG9uZW50XG4gICAqXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9XG4gICAqICAgICAgICAgVGhlIGVsZW1lbnQgdGhhdCB3YXMgY3JlYXRlZFxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIFRleHRUcmFja1NldHRpbmdzLnByb3RvdHlwZS5jcmVhdGVFbENvbG9yc18gPSBmdW5jdGlvbiBjcmVhdGVFbENvbG9yc18oKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUVsKCdkaXYnLCB7XG4gICAgICBjbGFzc05hbWU6ICd2anMtdHJhY2stc2V0dGluZ3MtY29sb3JzJyxcbiAgICAgIGlubmVySFRNTDogW3RoaXMuY3JlYXRlRWxGZ0NvbG9yXygpLCB0aGlzLmNyZWF0ZUVsQmdDb2xvcl8oKSwgdGhpcy5jcmVhdGVFbFdpbkNvbG9yXygpXS5qb2luKCcnKVxuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgZm9udCBlbGVtZW50cyBmb3IgdGhlIGNvbXBvbmVudFxuICAgKlxuICAgKiBAcmV0dXJuIHtFbGVtZW50fVxuICAgKiAgICAgICAgIFRoZSBlbGVtZW50IHRoYXQgd2FzIGNyZWF0ZWQuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgVGV4dFRyYWNrU2V0dGluZ3MucHJvdG90eXBlLmNyZWF0ZUVsRm9udF8gPSBmdW5jdGlvbiBjcmVhdGVFbEZvbnRfKCkge1xuICAgIHJldHVybiBjcmVhdGVFbCgnZGl2Jywge1xuICAgICAgY2xhc3NOYW1lOiAndmpzLXRyYWNrLXNldHRpbmdzLWZvbnQnLFxuICAgICAgaW5uZXJIVE1MOiBbJzxmaWVsZHNldCBjbGFzcz1cInZqcy1mb250LXBlcmNlbnQgdmpzLXRyYWNrLXNldHRpbmdcIj4nLCB0aGlzLmNyZWF0ZUVsU2VsZWN0XygnZm9udFBlcmNlbnQnLCAnJywgJ2xlZ2VuZCcpLCAnPC9maWVsZHNldD4nLCAnPGZpZWxkc2V0IGNsYXNzPVwidmpzLWVkZ2Utc3R5bGUgdmpzLXRyYWNrLXNldHRpbmdcIj4nLCB0aGlzLmNyZWF0ZUVsU2VsZWN0XygnZWRnZVN0eWxlJywgJycsICdsZWdlbmQnKSwgJzwvZmllbGRzZXQ+JywgJzxmaWVsZHNldCBjbGFzcz1cInZqcy1mb250LWZhbWlseSB2anMtdHJhY2stc2V0dGluZ1wiPicsIHRoaXMuY3JlYXRlRWxTZWxlY3RfKCdmb250RmFtaWx5JywgJycsICdsZWdlbmQnKSwgJzwvZmllbGRzZXQ+J10uam9pbignJylcbiAgICB9KTtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlIGNvbnRyb2xzIGZvciB0aGUgY29tcG9uZW50XG4gICAqXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9XG4gICAqICAgICAgICAgVGhlIGVsZW1lbnQgdGhhdCB3YXMgY3JlYXRlZC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBUZXh0VHJhY2tTZXR0aW5ncy5wcm90b3R5cGUuY3JlYXRlRWxDb250cm9sc18gPSBmdW5jdGlvbiBjcmVhdGVFbENvbnRyb2xzXygpIHtcbiAgICB2YXIgZGVmYXVsdHNEZXNjcmlwdGlvbiA9IHRoaXMubG9jYWxpemUoJ3Jlc3RvcmUgYWxsIHNldHRpbmdzIHRvIHRoZSBkZWZhdWx0IHZhbHVlcycpO1xuXG4gICAgcmV0dXJuIGNyZWF0ZUVsKCdkaXYnLCB7XG4gICAgICBjbGFzc05hbWU6ICd2anMtdHJhY2stc2V0dGluZ3MtY29udHJvbHMnLFxuICAgICAgaW5uZXJIVE1MOiBbJzxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwidmpzLWRlZmF1bHQtYnV0dG9uXCIgdGl0bGU9XCInICsgZGVmYXVsdHNEZXNjcmlwdGlvbiArICdcIj4nLCB0aGlzLmxvY2FsaXplKCdSZXNldCcpLCAnPHNwYW4gY2xhc3M9XCJ2anMtY29udHJvbC10ZXh0XCI+ICcgKyBkZWZhdWx0c0Rlc2NyaXB0aW9uICsgJzwvc3Bhbj4nLCAnPC9idXR0b24+JywgJzxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwidmpzLWRvbmUtYnV0dG9uXCI+JyArIHRoaXMubG9jYWxpemUoJ0RvbmUnKSArICc8L2J1dHRvbj4nXS5qb2luKCcnKVxuICAgIH0pO1xuICB9O1xuXG4gIFRleHRUcmFja1NldHRpbmdzLnByb3RvdHlwZS5jb250ZW50ID0gZnVuY3Rpb24gY29udGVudCgpIHtcbiAgICByZXR1cm4gW3RoaXMuY3JlYXRlRWxDb2xvcnNfKCksIHRoaXMuY3JlYXRlRWxGb250XygpLCB0aGlzLmNyZWF0ZUVsQ29udHJvbHNfKCldO1xuICB9O1xuXG4gIFRleHRUcmFja1NldHRpbmdzLnByb3RvdHlwZS5sYWJlbCA9IGZ1bmN0aW9uIGxhYmVsKCkge1xuICAgIHJldHVybiB0aGlzLmxvY2FsaXplKCdDYXB0aW9uIFNldHRpbmdzIERpYWxvZycpO1xuICB9O1xuXG4gIFRleHRUcmFja1NldHRpbmdzLnByb3RvdHlwZS5kZXNjcmlwdGlvbiA9IGZ1bmN0aW9uIGRlc2NyaXB0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmxvY2FsaXplKCdCZWdpbm5pbmcgb2YgZGlhbG9nIHdpbmRvdy4gRXNjYXBlIHdpbGwgY2FuY2VsIGFuZCBjbG9zZSB0aGUgd2luZG93LicpO1xuICB9O1xuXG4gIFRleHRUcmFja1NldHRpbmdzLnByb3RvdHlwZS5idWlsZENTU0NsYXNzID0gZnVuY3Rpb24gYnVpbGRDU1NDbGFzcygpIHtcbiAgICByZXR1cm4gX01vZGFsRGlhbG9nLnByb3RvdHlwZS5idWlsZENTU0NsYXNzLmNhbGwodGhpcykgKyAnIHZqcy10ZXh0LXRyYWNrLXNldHRpbmdzJztcbiAgfTtcblxuICAvKipcbiAgICogR2V0cyBhbiBvYmplY3Qgb2YgdGV4dCB0cmFjayBzZXR0aW5ncyAob3IgbnVsbCkuXG4gICAqXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICogICAgICAgICBBbiBvYmplY3Qgd2l0aCBjb25maWcgdmFsdWVzIHBhcnNlZCBmcm9tIHRoZSBET00gb3IgbG9jYWxTdG9yYWdlLlxuICAgKi9cblxuXG4gIFRleHRUcmFja1NldHRpbmdzLnByb3RvdHlwZS5nZXRWYWx1ZXMgPSBmdW5jdGlvbiBnZXRWYWx1ZXMoKSB7XG4gICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICByZXR1cm4gcmVkdWNlKHNlbGVjdENvbmZpZ3MsIGZ1bmN0aW9uIChhY2N1bSwgY29uZmlnLCBrZXkpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGdldFNlbGVjdGVkT3B0aW9uVmFsdWUoX3RoaXMzLiQoY29uZmlnLnNlbGVjdG9yKSwgY29uZmlnLnBhcnNlcik7XG5cbiAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGFjY3VtW2tleV0gPSB2YWx1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGFjY3VtO1xuICAgIH0sIHt9KTtcbiAgfTtcblxuICAvKipcbiAgICogU2V0cyB0ZXh0IHRyYWNrIHNldHRpbmdzIGZyb20gYW4gb2JqZWN0IG9mIHZhbHVlcy5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHZhbHVlc1xuICAgKiAgICAgICAgQW4gb2JqZWN0IHdpdGggY29uZmlnIHZhbHVlcyBwYXJzZWQgZnJvbSB0aGUgRE9NIG9yIGxvY2FsU3RvcmFnZS5cbiAgICovXG5cblxuICBUZXh0VHJhY2tTZXR0aW5ncy5wcm90b3R5cGUuc2V0VmFsdWVzID0gZnVuY3Rpb24gc2V0VmFsdWVzKHZhbHVlcykge1xuICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgZWFjaChzZWxlY3RDb25maWdzLCBmdW5jdGlvbiAoY29uZmlnLCBrZXkpIHtcbiAgICAgIHNldFNlbGVjdGVkT3B0aW9uKF90aGlzNC4kKGNvbmZpZy5zZWxlY3RvciksIHZhbHVlc1trZXldLCBjb25maWcucGFyc2VyKTtcbiAgICB9KTtcbiAgfTtcblxuICAvKipcbiAgICogU2V0cyBhbGwgYDxzZWxlY3Q+YCBlbGVtZW50cyB0byB0aGVpciBkZWZhdWx0IHZhbHVlcy5cbiAgICovXG5cblxuICBUZXh0VHJhY2tTZXR0aW5ncy5wcm90b3R5cGUuc2V0RGVmYXVsdHMgPSBmdW5jdGlvbiBzZXREZWZhdWx0cygpIHtcbiAgICB2YXIgX3RoaXM1ID0gdGhpcztcblxuICAgIGVhY2goc2VsZWN0Q29uZmlncywgZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgdmFyIGluZGV4ID0gY29uZmlnLmhhc093blByb3BlcnR5KCdkZWZhdWx0JykgPyBjb25maWdbJ2RlZmF1bHQnXSA6IDA7XG5cbiAgICAgIF90aGlzNS4kKGNvbmZpZy5zZWxlY3Rvcikuc2VsZWN0ZWRJbmRleCA9IGluZGV4O1xuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXN0b3JlIHRleHR0cmFjayBzZXR0aW5ncyBmcm9tIGxvY2FsU3RvcmFnZVxuICAgKi9cblxuXG4gIFRleHRUcmFja1NldHRpbmdzLnByb3RvdHlwZS5yZXN0b3JlU2V0dGluZ3MgPSBmdW5jdGlvbiByZXN0b3JlU2V0dGluZ3MoKSB7XG4gICAgdmFyIHZhbHVlcyA9IHZvaWQgMDtcblxuICAgIHRyeSB7XG4gICAgICB2YWx1ZXMgPSBKU09OLnBhcnNlKHdpbmRvdy5sb2NhbFN0b3JhZ2UuZ2V0SXRlbShMT0NBTF9TVE9SQUdFX0tFWSkpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgbG9nLndhcm4oZXJyKTtcbiAgICB9XG5cbiAgICBpZiAodmFsdWVzKSB7XG4gICAgICB0aGlzLnNldFZhbHVlcyh2YWx1ZXMpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogU2F2ZSB0ZXh0IHRyYWNrIHNldHRpbmdzIHRvIGxvY2FsU3RvcmFnZVxuICAgKi9cblxuXG4gIFRleHRUcmFja1NldHRpbmdzLnByb3RvdHlwZS5zYXZlU2V0dGluZ3MgPSBmdW5jdGlvbiBzYXZlU2V0dGluZ3MoKSB7XG4gICAgaWYgKCF0aGlzLm9wdGlvbnNfLnBlcnNpc3RUZXh0VHJhY2tTZXR0aW5ncykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciB2YWx1ZXMgPSB0aGlzLmdldFZhbHVlcygpO1xuXG4gICAgdHJ5IHtcbiAgICAgIGlmIChPYmplY3Qua2V5cyh2YWx1ZXMpLmxlbmd0aCkge1xuICAgICAgICB3aW5kb3cubG9jYWxTdG9yYWdlLnNldEl0ZW0oTE9DQUxfU1RPUkFHRV9LRVksIEpTT04uc3RyaW5naWZ5KHZhbHVlcykpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2luZG93LmxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKExPQ0FMX1NUT1JBR0VfS0VZKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGxvZy53YXJuKGVycik7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBVcGRhdGUgZGlzcGxheSBvZiB0ZXh0IHRyYWNrIHNldHRpbmdzXG4gICAqL1xuXG5cbiAgVGV4dFRyYWNrU2V0dGluZ3MucHJvdG90eXBlLnVwZGF0ZURpc3BsYXkgPSBmdW5jdGlvbiB1cGRhdGVEaXNwbGF5KCkge1xuICAgIHZhciB0dERpc3BsYXkgPSB0aGlzLnBsYXllcl8uZ2V0Q2hpbGQoJ3RleHRUcmFja0Rpc3BsYXknKTtcblxuICAgIGlmICh0dERpc3BsYXkpIHtcbiAgICAgIHR0RGlzcGxheS51cGRhdGVEaXNwbGF5KCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBjb25kaXRpb25hbGx5IGJsdXIgdGhlIGVsZW1lbnQgYW5kIHJlZm9jdXMgdGhlIGNhcHRpb25zIGJ1dHRvblxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIFRleHRUcmFja1NldHRpbmdzLnByb3RvdHlwZS5jb25kaXRpb25hbEJsdXJfID0gZnVuY3Rpb24gY29uZGl0aW9uYWxCbHVyXygpIHtcbiAgICB0aGlzLnByZXZpb3VzbHlBY3RpdmVFbF8gPSBudWxsO1xuICAgIHRoaXMub2ZmKGRvY3VtZW50LCAna2V5ZG93bicsIHRoaXMuaGFuZGxlS2V5RG93bik7XG5cbiAgICB2YXIgY2IgPSB0aGlzLnBsYXllcl8uY29udHJvbEJhcjtcbiAgICB2YXIgc3Vic0NhcHNCdG4gPSBjYiAmJiBjYi5zdWJzQ2Fwc0J1dHRvbjtcbiAgICB2YXIgY2NCdG4gPSBjYiAmJiBjYi5jYXB0aW9uc0J1dHRvbjtcblxuICAgIGlmIChzdWJzQ2Fwc0J0bikge1xuICAgICAgc3Vic0NhcHNCdG4uZm9jdXMoKTtcbiAgICB9IGVsc2UgaWYgKGNjQnRuKSB7XG4gICAgICBjY0J0bi5mb2N1cygpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gVGV4dFRyYWNrU2V0dGluZ3M7XG59KE1vZGFsRGlhbG9nKTtcblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdUZXh0VHJhY2tTZXR0aW5ncycsIFRleHRUcmFja1NldHRpbmdzKTtcblxuLyoqXG4gKiBAZmlsZSByZXNpemUtbWFuYWdlci5qc1xuICovXG4vKipcbiAqIEEgUmVzaXplIE1hbmFnZXIuIEl0IGlzIGluIGNoYXJnZSBvZiB0cmlnZ2VyaW5nIGBwbGF5ZXJyZXNpemVgIG9uIHRoZSBwbGF5ZXIgaW4gdGhlIHJpZ2h0IGNvbmRpdGlvbnMuXG4gKlxuICogSXQnbGwgZWl0aGVyIGNyZWF0ZSBhbiBpZnJhbWUgYW5kIHVzZSBhIGRlYm91bmNlZCByZXNpemUgaGFuZGxlciBvbiBpdCBvciB1c2UgdGhlIG5ldyB7QGxpbmsgaHR0cHM6Ly93aWNnLmdpdGh1Yi5pby9SZXNpemVPYnNlcnZlci98UmVzaXplT2JzZXJ2ZXJ9LlxuICpcbiAqIElmIHRoZSBSZXNpemVPYnNlcnZlciBpcyBhdmFpbGFibGUgbmF0aXZlbHksIGl0IHdpbGwgYmUgdXNlZC4gQSBwb2x5ZmlsbCBjYW4gYmUgcGFzc2VkIGluIGFzIGFuIG9wdGlvbi5cbiAqIElmIGEgYHBsYXllcnJlc2l6ZWAgZXZlbnQgaXMgbm90IG5lZWRlZCwgdGhlIFJlc2l6ZU1hbmFnZXIgY29tcG9uZW50IGNhbiBiZSByZW1vdmVkIGZyb20gdGhlIHBsYXllciwgc2VlIHRoZSBleGFtcGxlIGJlbG93LlxuICogQGV4YW1wbGUgPGNhcHRpb24+SG93IHRvIGRpc2FibGUgdGhlIHJlc2l6ZSBtYW5hZ2VyPC9jYXB0aW9uPlxuICogY29uc3QgcGxheWVyID0gdmlkZW9qcygnI3ZpZCcsIHtcbiAqICAgcmVzaXplTWFuYWdlcjogZmFsc2VcbiAqIH0pO1xuICpcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vd2ljZy5naXRodWIuaW8vUmVzaXplT2JzZXJ2ZXIvfFJlc2l6ZU9ic2VydmVyIHNwZWNpZmljYXRpb259XG4gKlxuICogQGV4dGVuZHMgQ29tcG9uZW50XG4gKi9cblxudmFyIFJlc2l6ZU1hbmFnZXIgPSBmdW5jdGlvbiAoX0NvbXBvbmVudCkge1xuICBpbmhlcml0cyhSZXNpemVNYW5hZ2VyLCBfQ29tcG9uZW50KTtcblxuICAvKipcbiAgICogQ3JlYXRlIHRoZSBSZXNpemVNYW5hZ2VyLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gcGxheWVyXG4gICAqICAgICAgICBUaGUgYFBsYXllcmAgdGhhdCB0aGlzIGNsYXNzIHNob3VsZCBiZSBhdHRhY2hlZCB0by5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgICAgICAgVGhlIGtleS92YWx1ZSBzdG9yZSBvZiBSZXNpemVNYW5hZ2VyIG9wdGlvbnMuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5SZXNpemVPYnNlcnZlcl1cbiAgICogICAgICAgIEEgcG9seWZpbGwgZm9yIFJlc2l6ZU9ic2VydmVyIGNhbiBiZSBwYXNzZWQgaW4gaGVyZS5cbiAgICogICAgICAgIElmIHRoaXMgaXMgc2V0IHRvIG51bGwgaXQgd2lsbCBpZ25vcmUgdGhlIG5hdGl2ZSBSZXNpemVPYnNlcnZlciBhbmQgZmFsbCBiYWNrIHRvIHRoZSBpZnJhbWUgZmFsbGJhY2suXG4gICAqL1xuICBmdW5jdGlvbiBSZXNpemVNYW5hZ2VyKHBsYXllciwgb3B0aW9ucykge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFJlc2l6ZU1hbmFnZXIpO1xuXG4gICAgdmFyIFJFU0laRV9PQlNFUlZFUl9BVkFJTEFCTEUgPSBvcHRpb25zLlJlc2l6ZU9ic2VydmVyIHx8IHdpbmRvdy5SZXNpemVPYnNlcnZlcjtcblxuICAgIC8vIGlmIGBudWxsYCB3YXMgcGFzc2VkLCB3ZSB3YW50IHRvIGRpc2FibGUgdGhlIFJlc2l6ZU9ic2VydmVyXG4gICAgaWYgKG9wdGlvbnMuUmVzaXplT2JzZXJ2ZXIgPT09IG51bGwpIHtcbiAgICAgIFJFU0laRV9PQlNFUlZFUl9BVkFJTEFCTEUgPSBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBPbmx5IGNyZWF0ZSBhbiBlbGVtZW50IHdoZW4gUmVzaXplT2JzZXJ2ZXIgaXNuJ3QgYXZhaWxhYmxlXG4gICAgdmFyIG9wdGlvbnNfID0gbWVyZ2VPcHRpb25zKHsgY3JlYXRlRWw6ICFSRVNJWkVfT0JTRVJWRVJfQVZBSUxBQkxFIH0sIG9wdGlvbnMpO1xuXG4gICAgdmFyIF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfQ29tcG9uZW50LmNhbGwodGhpcywgcGxheWVyLCBvcHRpb25zXykpO1xuXG4gICAgX3RoaXMuUmVzaXplT2JzZXJ2ZXIgPSBvcHRpb25zLlJlc2l6ZU9ic2VydmVyIHx8IHdpbmRvdy5SZXNpemVPYnNlcnZlcjtcbiAgICBfdGhpcy5sb2FkTGlzdGVuZXJfID0gbnVsbDtcbiAgICBfdGhpcy5yZXNpemVPYnNlcnZlcl8gPSBudWxsO1xuICAgIF90aGlzLmRlYm91bmNlZEhhbmRsZXJfID0gZGVib3VuY2UoZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMucmVzaXplSGFuZGxlcigpO1xuICAgIH0sIDEwMCwgZmFsc2UsIF90aGlzKTtcblxuICAgIGlmIChSRVNJWkVfT0JTRVJWRVJfQVZBSUxBQkxFKSB7XG4gICAgICBfdGhpcy5yZXNpemVPYnNlcnZlcl8gPSBuZXcgX3RoaXMuUmVzaXplT2JzZXJ2ZXIoX3RoaXMuZGVib3VuY2VkSGFuZGxlcl8pO1xuICAgICAgX3RoaXMucmVzaXplT2JzZXJ2ZXJfLm9ic2VydmUocGxheWVyLmVsKCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBfdGhpcy5sb2FkTGlzdGVuZXJfID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIV90aGlzLmVsXyB8fCAhX3RoaXMuZWxfLmNvbnRlbnRXaW5kb3cpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBvbihfdGhpcy5lbF8uY29udGVudFdpbmRvdywgJ3Jlc2l6ZScsIF90aGlzLmRlYm91bmNlZEhhbmRsZXJfKTtcbiAgICAgIH07XG5cbiAgICAgIF90aGlzLm9uZSgnbG9hZCcsIF90aGlzLmxvYWRMaXN0ZW5lcl8pO1xuICAgIH1cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBSZXNpemVNYW5hZ2VyLnByb3RvdHlwZS5jcmVhdGVFbCA9IGZ1bmN0aW9uIGNyZWF0ZUVsKCkge1xuICAgIHJldHVybiBfQ29tcG9uZW50LnByb3RvdHlwZS5jcmVhdGVFbC5jYWxsKHRoaXMsICdpZnJhbWUnLCB7XG4gICAgICBjbGFzc05hbWU6ICd2anMtcmVzaXplLW1hbmFnZXInXG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENhbGxlZCB3aGVuIGEgcmVzaXplIGlzIHRyaWdnZXJlZCBvbiB0aGUgaWZyYW1lIG9yIGEgcmVzaXplIGlzIG9ic2VydmVkIHZpYSB0aGUgUmVzaXplT2JzZXJ2ZXJcbiAgICpcbiAgICogQGZpcmVzIFBsYXllciNwbGF5ZXJyZXNpemVcbiAgICovXG5cblxuICBSZXNpemVNYW5hZ2VyLnByb3RvdHlwZS5yZXNpemVIYW5kbGVyID0gZnVuY3Rpb24gcmVzaXplSGFuZGxlcigpIHtcbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbiB0aGUgcGxheWVyIHNpemUgaGFzIGNoYW5nZWRcbiAgICAgKlxuICAgICAqIEBldmVudCBQbGF5ZXIjcGxheWVycmVzaXplXG4gICAgICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICAgICAqL1xuICAgIC8vIG1ha2Ugc3VyZSBwbGF5ZXIgaXMgc3RpbGwgYXJvdW5kIHRvIHRyaWdnZXJcbiAgICAvLyBwcmV2ZW50cyB0aGlzIGZyb20gY2F1c2luZyBhbiBlcnJvciBhZnRlciBkaXNwb3NlXG4gICAgaWYgKCF0aGlzLnBsYXllcl8gfHwgIXRoaXMucGxheWVyXy50cmlnZ2VyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5wbGF5ZXJfLnRyaWdnZXIoJ3BsYXllcnJlc2l6ZScpO1xuICB9O1xuXG4gIFJlc2l6ZU1hbmFnZXIucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiBkaXNwb3NlKCkge1xuICAgIGlmICh0aGlzLmRlYm91bmNlZEhhbmRsZXJfKSB7XG4gICAgICB0aGlzLmRlYm91bmNlZEhhbmRsZXJfLmNhbmNlbCgpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnJlc2l6ZU9ic2VydmVyXykge1xuICAgICAgaWYgKHRoaXMucGxheWVyXy5lbCgpKSB7XG4gICAgICAgIHRoaXMucmVzaXplT2JzZXJ2ZXJfLnVub2JzZXJ2ZSh0aGlzLnBsYXllcl8uZWwoKSk7XG4gICAgICB9XG4gICAgICB0aGlzLnJlc2l6ZU9ic2VydmVyXy5kaXNjb25uZWN0KCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZWxfICYmIHRoaXMuZWxfLmNvbnRlbnRXaW5kb3cpIHtcbiAgICAgIG9mZih0aGlzLmVsXy5jb250ZW50V2luZG93LCAncmVzaXplJywgdGhpcy5kZWJvdW5jZWRIYW5kbGVyXyk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMubG9hZExpc3RlbmVyXykge1xuICAgICAgdGhpcy5vZmYoJ2xvYWQnLCB0aGlzLmxvYWRMaXN0ZW5lcl8pO1xuICAgIH1cblxuICAgIHRoaXMuUmVzaXplT2JzZXJ2ZXIgPSBudWxsO1xuICAgIHRoaXMucmVzaXplT2JzZXJ2ZXIgPSBudWxsO1xuICAgIHRoaXMuZGVib3VuY2VkSGFuZGxlcl8gPSBudWxsO1xuICAgIHRoaXMubG9hZExpc3RlbmVyXyA9IG51bGw7XG4gIH07XG5cbiAgcmV0dXJuIFJlc2l6ZU1hbmFnZXI7XG59KENvbXBvbmVudCk7XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnUmVzaXplTWFuYWdlcicsIFJlc2l6ZU1hbmFnZXIpO1xuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCB0byBmaXJlIGEgc291cmNlc2V0IHdoZW4gdGhlcmUgaXMgc29tZXRoaW5nXG4gKiBzaW1pbGFyIHRvIGBtZWRpYUVsLmxvYWQoKWAgYmVpbmcgY2FsbGVkLiBJdCB3aWxsIHRyeSB0byBmaW5kIHRoZSBzb3VyY2UgdmlhXG4gKiB0aGUgYHNyY2AgYXR0cmlidXRlIGFuZCB0aGVuIHRoZSBgPHNvdXJjZT5gIGVsZW1lbnRzLiBJdCB3aWxsIHRoZW4gZmlyZSBgc291cmNlc2V0YFxuICogd2l0aCB0aGUgc291cmNlIHRoYXQgd2FzIGZvdW5kIG9yIGVtcHR5IHN0cmluZyBpZiB3ZSBjYW5ub3Qga25vdy4gSWYgaXQgY2Fubm90XG4gKiBmaW5kIGEgc291cmNlIHRoZW4gYHNvdXJjZXNldGAgd2lsbCBub3QgYmUgZmlyZWQuXG4gKlxuICogQHBhcmFtIHtIdG1sNX0gdGVjaFxuICogICAgICAgIFRoZSB0ZWNoIG9iamVjdCB0aGF0IHNvdXJjZXNldCB3YXMgc2V0dXAgb25cbiAqXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICogICAgICAgICByZXR1cm5zIGZhbHNlIGlmIHRoZSBzb3VyY2VzZXQgd2FzIG5vdCBmaXJlZCBhbmQgdHJ1ZSBvdGhlcndpc2UuXG4gKi9cbnZhciBzb3VyY2VzZXRMb2FkID0gZnVuY3Rpb24gc291cmNlc2V0TG9hZCh0ZWNoKSB7XG4gIHZhciBlbCA9IHRlY2guZWwoKTtcblxuICAvLyBpZiBgZWwuc3JjYCBpcyBzZXQsIHRoYXQgc291cmNlIHdpbGwgYmUgbG9hZGVkLlxuICBpZiAoZWwuaGFzQXR0cmlidXRlKCdzcmMnKSkge1xuICAgIHRlY2gudHJpZ2dlclNvdXJjZXNldChlbC5zcmMpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIFNpbmNlIHRoZXJlIGlzbid0IGEgc3JjIHByb3BlcnR5IG9uIHRoZSBtZWRpYSBlbGVtZW50LCBzb3VyY2UgZWxlbWVudHMgd2lsbCBiZSB1c2VkIGZvclxuICAgKiBpbXBsZW1lbnRpbmcgdGhlIHNvdXJjZSBzZWxlY3Rpb24gYWxnb3JpdGhtLiBUaGlzIGhhcHBlbnMgYXN5bmNocm9ub3VzbHkgYW5kXG4gICAqIGZvciBtb3N0IGNhc2VzIHdlcmUgdGhlcmUgaXMgbW9yZSB0aGFuIG9uZSBzb3VyY2Ugd2UgY2Fubm90IHRlbGwgd2hhdCBzb3VyY2Ugd2lsbFxuICAgKiBiZSBsb2FkZWQsIHdpdGhvdXQgcmUtaW1wbGVtZW50aW5nIHRoZSBzb3VyY2Ugc2VsZWN0aW9uIGFsZ29yaXRobS4gQXQgdGhpcyB0aW1lIHdlIGFyZSBub3RcbiAgICogZ29pbmcgdG8gZG8gdGhhdC4gVGhlcmUgYXJlIHRocmVlIHNwZWNpYWwgY2FzZXMgdGhhdCB3ZSBkbyBoYW5kbGUgaGVyZSB0aG91Z2g6XG4gICAqXG4gICAqIDEuIElmIHRoZXJlIGFyZSBubyBzb3VyY2VzLCBkbyBub3QgZmlyZSBgc291cmNlc2V0YC5cbiAgICogMi4gSWYgdGhlcmUgaXMgb25seSBvbmUgYDxzb3VyY2U+YCB3aXRoIGEgYHNyY2AgcHJvcGVydHkvYXR0cmlidXRlIHRoYXQgaXMgb3VyIGBzcmNgXG4gICAqIDMuIElmIHRoZXJlIGlzIG1vcmUgdGhhbiBvbmUgYDxzb3VyY2U+YCBidXQgYWxsIG9mIHRoZW0gaGF2ZSB0aGUgc2FtZSBgc3JjYCB1cmwuXG4gICAqICAgIFRoYXQgd2lsbCBiZSBvdXIgc3JjLlxuICAgKi9cbiAgdmFyIHNvdXJjZXMgPSB0ZWNoLiQkKCdzb3VyY2UnKTtcbiAgdmFyIHNyY1VybHMgPSBbXTtcbiAgdmFyIHNyYyA9ICcnO1xuXG4gIC8vIGlmIHRoZXJlIGFyZSBubyBzb3VyY2VzLCBkbyBub3QgZmlyZSBzb3VyY2VzZXRcbiAgaWYgKCFzb3VyY2VzLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIG9ubHkgY291bnQgdmFsaWQvbm9uLWR1cGxpY2F0ZSBzb3VyY2UgZWxlbWVudHNcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzb3VyY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHVybCA9IHNvdXJjZXNbaV0uc3JjO1xuXG4gICAgaWYgKHVybCAmJiBzcmNVcmxzLmluZGV4T2YodXJsKSA9PT0gLTEpIHtcbiAgICAgIHNyY1VybHMucHVzaCh1cmwpO1xuICAgIH1cbiAgfVxuXG4gIC8vIHRoZXJlIHdlcmUgbm8gdmFsaWQgc291cmNlc1xuICBpZiAoIXNyY1VybHMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gdGhlcmUgaXMgb25seSBvbmUgdmFsaWQgc291cmNlIGVsZW1lbnQgdXJsXG4gIC8vIHVzZSB0aGF0XG4gIGlmIChzcmNVcmxzLmxlbmd0aCA9PT0gMSkge1xuICAgIHNyYyA9IHNyY1VybHNbMF07XG4gIH1cblxuICB0ZWNoLnRyaWdnZXJTb3VyY2VzZXQoc3JjKTtcbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vKipcbiAqIG91ciBpbXBsZW1lbnRhdGlvbiBvZiBhbiBgaW5uZXJIVE1MYCBkZXNjcmlwdG9yIGZvciBicm93c2Vyc1xuICogdGhhdCBkbyBub3QgaGF2ZSBvbmUuXG4gKi9cbnZhciBpbm5lckhUTUxEZXNjcmlwdG9yUG9seWZpbGwgPSB7fTtcblxuaWYgKCFJU19JRTgpIHtcbiAgaW5uZXJIVE1MRGVzY3JpcHRvclBvbHlmaWxsID0gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAnaW5uZXJIVE1MJywge1xuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuY2xvbmVOb2RlKHRydWUpLmlubmVySFRNTDtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0KHYpIHtcbiAgICAgIC8vIG1ha2UgYSBkdW1teSBub2RlIHRvIHVzZSBpbm5lckhUTUwgb25cbiAgICAgIHZhciBkdW1teSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGhpcy5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpKTtcblxuICAgICAgLy8gc2V0IGlubmVySFRNTCB0byB0aGUgdmFsdWUgcHJvdmlkZWRcbiAgICAgIGR1bW15LmlubmVySFRNTCA9IHY7XG5cbiAgICAgIC8vIG1ha2UgYSBkb2N1bWVudCBmcmFnbWVudCB0byBob2xkIHRoZSBub2RlcyBmcm9tIGR1bW15XG4gICAgICB2YXIgZG9jRnJhZyA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcblxuICAgICAgLy8gY29weSBhbGwgb2YgdGhlIG5vZGVzIGNyZWF0ZWQgYnkgdGhlIGlubmVySFRNTCBvbiBkdW1teVxuICAgICAgLy8gdG8gdGhlIGRvY3VtZW50IGZyYWdtZW50XG4gICAgICB3aGlsZSAoZHVtbXkuY2hpbGROb2Rlcy5sZW5ndGgpIHtcbiAgICAgICAgZG9jRnJhZy5hcHBlbmRDaGlsZChkdW1teS5jaGlsZE5vZGVzWzBdKTtcbiAgICAgIH1cblxuICAgICAgLy8gcmVtb3ZlIGNvbnRlbnRcbiAgICAgIHRoaXMuaW5uZXJUZXh0ID0gJyc7XG5cbiAgICAgIC8vIG5vdyB3ZSBhZGQgYWxsIG9mIHRoYXQgaHRtbCBpbiBvbmUgYnkgYXBwZW5kaW5nIHRoZVxuICAgICAgLy8gZG9jdW1lbnQgZnJhZ21lbnQuIFRoaXMgaXMgaG93IGlubmVySFRNTCBkb2VzIGl0LlxuICAgICAgd2luZG93LkVsZW1lbnQucHJvdG90eXBlLmFwcGVuZENoaWxkLmNhbGwodGhpcywgZG9jRnJhZyk7XG5cbiAgICAgIC8vIHRoZW4gcmV0dXJuIHRoZSByZXN1bHQgdGhhdCBpbm5lckhUTUwncyBzZXR0ZXIgd291bGRcbiAgICAgIHJldHVybiB0aGlzLmlubmVySFRNTDtcbiAgICB9XG4gIH0pO1xufVxuLyoqXG4gKiBHZXQgYSBwcm9wZXJ0eSBkZXNjcmlwdG9yIGdpdmVuIGEgbGlzdCBvZiBwcmlvcml0aWVzIGFuZCB0aGVcbiAqIHByb3BlcnR5IHRvIGdldC5cbiAqL1xudmFyIGdldERlc2NyaXB0b3IgPSBmdW5jdGlvbiBnZXREZXNjcmlwdG9yKHByaW9yaXR5LCBwcm9wKSB7XG4gIHZhciBkZXNjcmlwdG9yID0ge307XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcmlvcml0eS5sZW5ndGg7IGkrKykge1xuICAgIGRlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHByaW9yaXR5W2ldLCBwcm9wKTtcblxuICAgIGlmIChkZXNjcmlwdG9yICYmIGRlc2NyaXB0b3Iuc2V0ICYmIGRlc2NyaXB0b3IuZ2V0KSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSB0cnVlO1xuICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG5cbiAgcmV0dXJuIGRlc2NyaXB0b3I7XG59O1xuXG52YXIgZ2V0SW5uZXJIVE1MRGVzY3JpcHRvciA9IGZ1bmN0aW9uIGdldElubmVySFRNTERlc2NyaXB0b3IodGVjaCkge1xuICByZXR1cm4gZ2V0RGVzY3JpcHRvcihbdGVjaC5lbCgpLCB3aW5kb3cuSFRNTE1lZGlhRWxlbWVudC5wcm90b3R5cGUsIHdpbmRvdy5FbGVtZW50LnByb3RvdHlwZSwgaW5uZXJIVE1MRGVzY3JpcHRvclBvbHlmaWxsXSwgJ2lubmVySFRNTCcpO1xufTtcblxuLyoqXG4gKiBQYXRjaGVzIGJyb3dzZXIgaW50ZXJuYWwgZnVuY3Rpb25zIHNvIHRoYXQgd2UgY2FuIHRlbGwgc3luY3Jvbm91c2x5XG4gKiBpZiBhIGA8c291cmNlPmAgd2FzIGFwcGVuZGVkIHRvIHRoZSBtZWRpYSBlbGVtZW50LiBGb3Igc29tZSByZWFzb24gdGhpc1xuICogY2F1c2VzIGEgYHNvdXJjZXNldGAgaWYgdGhlIHRoZSBtZWRpYSBlbGVtZW50IGlzIHJlYWR5IGFuZCBoYXMgbm8gc291cmNlLlxuICogVGhpcyBoYXBwZW5zIHdoZW46XG4gKiAtIFRoZSBwYWdlIGhhcyBqdXN0IGxvYWRlZCBhbmQgdGhlIG1lZGlhIGVsZW1lbnQgZG9lcyBub3QgaGF2ZSBhIHNvdXJjZS5cbiAqIC0gVGhlIG1lZGlhIGVsZW1lbnQgd2FzIGVtcHRpZWQgb2YgYWxsIHNvdXJjZXMsIHRoZW4gYGxvYWQoKWAgd2FzIGNhbGxlZC5cbiAqXG4gKiBJdCBkb2VzIHRoaXMgYnkgcGF0Y2hpbmcgdGhlIGZvbGxvd2luZyBmdW5jdGlvbnMvcHJvcGVydGllcyB3aGVuIHRoZXkgYXJlIHN1cHBvcnRlZDpcbiAqXG4gKiAtIGBhcHBlbmQoKWAgLSBjYW4gYmUgdXNlZCB0byBhZGQgYSBgPHNvdXJjZT5gIGVsZW1lbnQgdG8gdGhlIG1lZGlhIGVsZW1lbnRcbiAqIC0gYGFwcGVuZENoaWxkKClgIC0gY2FuIGJlIHVzZWQgdG8gYWRkIGEgYDxzb3VyY2U+YCBlbGVtZW50IHRvIHRoZSBtZWRpYSBlbGVtZW50XG4gKiAtIGBpbnNlcnRBZGphY2VudEhUTUwoKWAgLSAgY2FuIGJlIHVzZWQgdG8gYWRkIGEgYDxzb3VyY2U+YCBlbGVtZW50IHRvIHRoZSBtZWRpYSBlbGVtZW50XG4gKiAtIGBpbm5lckhUTUxgIC0gIGNhbiBiZSB1c2VkIHRvIGFkZCBhIGA8c291cmNlPmAgZWxlbWVudCB0byB0aGUgbWVkaWEgZWxlbWVudFxuICpcbiAqIEBwYXJhbSB7SHRtbDV9IHRlY2hcbiAqICAgICAgICBUaGUgdGVjaCBvYmplY3QgdGhhdCBzb3VyY2VzZXQgaXMgYmVpbmcgc2V0dXAgb24uXG4gKi9cbnZhciBmaXJzdFNvdXJjZVdhdGNoID0gZnVuY3Rpb24gZmlyc3RTb3VyY2VXYXRjaCh0ZWNoKSB7XG4gIHZhciBlbCA9IHRlY2guZWwoKTtcblxuICAvLyBtYWtlIHN1cmUgZmlyc3RTb3VyY2VXYXRjaCBpc24ndCBzZXR1cCB0d2ljZS5cbiAgaWYgKGVsLnJlc2V0U291cmNlV2F0Y2hfKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIG9sZCA9IHt9O1xuICB2YXIgaW5uZXJEZXNjcmlwdG9yID0gZ2V0SW5uZXJIVE1MRGVzY3JpcHRvcih0ZWNoKTtcbiAgdmFyIGFwcGVuZFdyYXBwZXIgPSBmdW5jdGlvbiBhcHBlbmRXcmFwcGVyKGFwcGVuZEZuKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICB9XG5cbiAgICAgIHZhciByZXR2YWwgPSBhcHBlbmRGbi5hcHBseShlbCwgYXJncyk7XG5cbiAgICAgIHNvdXJjZXNldExvYWQodGVjaCk7XG5cbiAgICAgIHJldHVybiByZXR2YWw7XG4gICAgfTtcbiAgfTtcblxuICBbJ2FwcGVuZCcsICdhcHBlbmRDaGlsZCcsICdpbnNlcnRBZGphY2VudEhUTUwnXS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgaWYgKCFlbFtrXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIHN0b3JlIHRoZSBvbGQgZnVuY3Rpb25cbiAgICBvbGRba10gPSBlbFtrXTtcblxuICAgIC8vIGNhbGwgdGhlIG9sZCBmdW5jdGlvbiB3aXRoIGEgc291cmNlc2V0IGlmIGEgc291cmNlXG4gICAgLy8gd2FzIGxvYWRlZFxuICAgIGVsW2tdID0gYXBwZW5kV3JhcHBlcihvbGRba10pO1xuICB9KTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWwsICdpbm5lckhUTUwnLCBtZXJnZU9wdGlvbnMoaW5uZXJEZXNjcmlwdG9yLCB7XG4gICAgc2V0OiBhcHBlbmRXcmFwcGVyKGlubmVyRGVzY3JpcHRvci5zZXQpXG4gIH0pKTtcblxuICBlbC5yZXNldFNvdXJjZVdhdGNoXyA9IGZ1bmN0aW9uICgpIHtcbiAgICBlbC5yZXNldFNvdXJjZVdhdGNoXyA9IG51bGw7XG4gICAgT2JqZWN0LmtleXMob2xkKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgICBlbFtrXSA9IG9sZFtrXTtcbiAgICB9KTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbCwgJ2lubmVySFRNTCcsIGlubmVyRGVzY3JpcHRvcik7XG4gIH07XG5cbiAgLy8gb24gdGhlIGZpcnN0IHNvdXJjZXNldCwgd2UgbmVlZCB0byByZXZlcnQgb3VyIGNoYW5nZXNcbiAgdGVjaC5vbmUoJ3NvdXJjZXNldCcsIGVsLnJlc2V0U291cmNlV2F0Y2hfKTtcbn07XG5cbi8qKlxuICogb3VyIGltcGxlbWVudGF0aW9uIG9mIGEgYHNyY2AgZGVzY3JpcHRvciBmb3IgYnJvd3NlcnNcbiAqIHRoYXQgZG8gbm90IGhhdmUgb25lLlxuICovXG5cbnZhciBzcmNEZXNjcmlwdG9yUG9seWZpbGwgPSB7fTtcblxuaWYgKCFJU19JRTgpIHtcbiAgc3JjRGVzY3JpcHRvclBvbHlmaWxsID0gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAnc3JjJywge1xuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgaWYgKHRoaXMuaGFzQXR0cmlidXRlKCdzcmMnKSkge1xuICAgICAgICByZXR1cm4gZ2V0QWJzb2x1dGVVUkwod2luZG93LkVsZW1lbnQucHJvdG90eXBlLmdldEF0dHJpYnV0ZS5jYWxsKHRoaXMsICdzcmMnKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAnJztcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0KHYpIHtcbiAgICAgIHdpbmRvdy5FbGVtZW50LnByb3RvdHlwZS5zZXRBdHRyaWJ1dGUuY2FsbCh0aGlzLCAnc3JjJywgdik7XG5cbiAgICAgIHJldHVybiB2O1xuICAgIH1cbiAgfSk7XG59XG5cbnZhciBnZXRTcmNEZXNjcmlwdG9yID0gZnVuY3Rpb24gZ2V0U3JjRGVzY3JpcHRvcih0ZWNoKSB7XG4gIHJldHVybiBnZXREZXNjcmlwdG9yKFt0ZWNoLmVsKCksIHdpbmRvdy5IVE1MTWVkaWFFbGVtZW50LnByb3RvdHlwZSwgc3JjRGVzY3JpcHRvclBvbHlmaWxsXSwgJ3NyYycpO1xufTtcblxuLyoqXG4gKiBzZXR1cCBgc291cmNlc2V0YCBoYW5kbGluZyBvbiB0aGUgYEh0bWw1YCB0ZWNoLiBUaGlzIGZ1bmN0aW9uXG4gKiBwYXRjaGVzIHRoZSBmb2xsb3dpbmcgZWxlbWVudCBwcm9wZXJ0aWVzL2Z1bmN0aW9uczpcbiAqXG4gKiAtIGBzcmNgIC0gdG8gZGV0ZXJtaW5lIHdoZW4gYHNyY2AgaXMgc2V0XG4gKiAtIGBzZXRBdHRyaWJ1dGUoKWAgLSB0byBkZXRlcm1pbmUgd2hlbiBgc3JjYCBpcyBzZXRcbiAqIC0gYGxvYWQoKWAgLSB0aGlzIHJlLXRyaWdnZXJzIHRoZSBzb3VyY2Ugc2VsZWN0aW9uIGFsZ29yaXRobSwgYW5kIGNhblxuICogICAgICAgICAgICAgIGNhdXNlIGEgc291cmNlc2V0LlxuICpcbiAqIElmIHRoZXJlIGlzIG5vIHNvdXJjZSB3aGVuIHdlIGFyZSBhZGRpbmcgYHNvdXJjZXNldGAgc3VwcG9ydCBvciBkdXJpbmcgYSBgbG9hZCgpYFxuICogd2UgYWxzbyBwYXRjaCB0aGUgZnVuY3Rpb25zIGxpc3RlZCBpbiBgZmlyc3RTb3VyY2VXYXRjaGAuXG4gKlxuICogQHBhcmFtIHtIdG1sNX0gdGVjaFxuICogICAgICAgIFRoZSB0ZWNoIHRvIHBhdGNoXG4gKi9cbnZhciBzZXR1cFNvdXJjZXNldCA9IGZ1bmN0aW9uIHNldHVwU291cmNlc2V0KHRlY2gpIHtcbiAgaWYgKCF0ZWNoLmZlYXR1cmVzU291cmNlc2V0KSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGVsID0gdGVjaC5lbCgpO1xuXG4gIC8vIG1ha2Ugc3VyZSBzb3VyY2VzZXQgaXNuJ3Qgc2V0dXAgdHdpY2UuXG4gIGlmIChlbC5yZXNldFNvdXJjZXNldF8pIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgc3JjRGVzY3JpcHRvciA9IGdldFNyY0Rlc2NyaXB0b3IodGVjaCk7XG4gIHZhciBvbGRTZXRBdHRyaWJ1dGUgPSBlbC5zZXRBdHRyaWJ1dGU7XG4gIHZhciBvbGRMb2FkID0gZWwubG9hZDtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWwsICdzcmMnLCBtZXJnZU9wdGlvbnMoc3JjRGVzY3JpcHRvciwge1xuICAgIHNldDogZnVuY3Rpb24gc2V0KHYpIHtcbiAgICAgIHZhciByZXR2YWwgPSBzcmNEZXNjcmlwdG9yLnNldC5jYWxsKGVsLCB2KTtcblxuICAgICAgLy8gd2UgdXNlIHRoZSBnZXR0ZXIgaGVyZSB0byBnZXQgdGhlIGFjdHVhbCB2YWx1ZSBzZXQgb24gc3JjXG4gICAgICB0ZWNoLnRyaWdnZXJTb3VyY2VzZXQoZWwuc3JjKTtcblxuICAgICAgcmV0dXJuIHJldHZhbDtcbiAgICB9XG4gIH0pKTtcblxuICBlbC5zZXRBdHRyaWJ1dGUgPSBmdW5jdGlvbiAobiwgdikge1xuICAgIHZhciByZXR2YWwgPSBvbGRTZXRBdHRyaWJ1dGUuY2FsbChlbCwgbiwgdik7XG5cbiAgICBpZiAoL3NyYy9pLnRlc3QobikpIHtcbiAgICAgIHRlY2gudHJpZ2dlclNvdXJjZXNldChlbC5zcmMpO1xuICAgIH1cblxuICAgIHJldHVybiByZXR2YWw7XG4gIH07XG5cbiAgZWwubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmV0dmFsID0gb2xkTG9hZC5jYWxsKGVsKTtcblxuICAgIC8vIGlmIGxvYWQgd2FzIGNhbGxlZCwgYnV0IHRoZXJlIHdhcyBubyBzb3VyY2UgdG8gZmlyZVxuICAgIC8vIHNvdXJjZXNldCBvbi4gV2UgaGF2ZSB0byB3YXRjaCBmb3IgYSBzb3VyY2UgYXBwZW5kXG4gICAgLy8gYXMgdGhhdCBjYW4gdHJpZ2dlciBhIGBzb3VyY2VzZXRgIHdoZW4gdGhlIG1lZGlhIGVsZW1lbnRcbiAgICAvLyBoYXMgbm8gc291cmNlXG4gICAgaWYgKCFzb3VyY2VzZXRMb2FkKHRlY2gpKSB7XG4gICAgICB0ZWNoLnRyaWdnZXJTb3VyY2VzZXQoJycpO1xuICAgICAgZmlyc3RTb3VyY2VXYXRjaCh0ZWNoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmV0dmFsO1xuICB9O1xuXG4gIGlmIChlbC5jdXJyZW50U3JjKSB7XG4gICAgdGVjaC50cmlnZ2VyU291cmNlc2V0KGVsLmN1cnJlbnRTcmMpO1xuICB9IGVsc2UgaWYgKCFzb3VyY2VzZXRMb2FkKHRlY2gpKSB7XG4gICAgZmlyc3RTb3VyY2VXYXRjaCh0ZWNoKTtcbiAgfVxuXG4gIGVsLnJlc2V0U291cmNlc2V0XyA9IGZ1bmN0aW9uICgpIHtcbiAgICBlbC5yZXNldFNvdXJjZXNldF8gPSBudWxsO1xuICAgIGVsLmxvYWQgPSBvbGRMb2FkO1xuICAgIGVsLnNldEF0dHJpYnV0ZSA9IG9sZFNldEF0dHJpYnV0ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWwsICdzcmMnLCBzcmNEZXNjcmlwdG9yKTtcbiAgICBpZiAoZWwucmVzZXRTb3VyY2VXYXRjaF8pIHtcbiAgICAgIGVsLnJlc2V0U291cmNlV2F0Y2hfKCk7XG4gICAgfVxuICB9O1xufTtcblxudmFyIF90ZW1wbGF0ZU9iamVjdCQyID0gdGFnZ2VkVGVtcGxhdGVMaXRlcmFsTG9vc2UoWydUZXh0IFRyYWNrcyBhcmUgYmVpbmcgbG9hZGVkIGZyb20gYW5vdGhlciBvcmlnaW4gYnV0IHRoZSBjcm9zc29yaWdpbiBhdHRyaWJ1dGUgaXNuXFwndCB1c2VkLlxcbiAgICAgICAgICAgIFRoaXMgbWF5IHByZXZlbnQgdGV4dCB0cmFja3MgZnJvbSBsb2FkaW5nLiddLCBbJ1RleHQgVHJhY2tzIGFyZSBiZWluZyBsb2FkZWQgZnJvbSBhbm90aGVyIG9yaWdpbiBidXQgdGhlIGNyb3Nzb3JpZ2luIGF0dHJpYnV0ZSBpc25cXCd0IHVzZWQuXFxuICAgICAgICAgICAgVGhpcyBtYXkgcHJldmVudCB0ZXh0IHRyYWNrcyBmcm9tIGxvYWRpbmcuJ10pO1xuXG4vKipcbiAqIEBmaWxlIGh0bWw1LmpzXG4gKi9cbi8qKlxuICogSFRNTDUgTWVkaWEgQ29udHJvbGxlciAtIFdyYXBwZXIgZm9yIEhUTUw1IE1lZGlhIEFQSVxuICpcbiAqIEBtaXhlcyBUZWNoflNvdWNlSGFuZGxlckFkZGl0aW9uc1xuICogQGV4dGVuZHMgVGVjaFxuICovXG5cbnZhciBIdG1sNSA9IGZ1bmN0aW9uIChfVGVjaCkge1xuICBpbmhlcml0cyhIdG1sNSwgX1RlY2gpO1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgdGhpcyBUZWNoLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgICAgICBUaGUga2V5L3ZhbHVlIHN0b3JlIG9mIHBsYXllciBvcHRpb25zLlxuICAgKlxuICAgKiBAcGFyYW0ge0NvbXBvbmVudH5SZWFkeUNhbGxiYWNrfSByZWFkeVxuICAgKiAgICAgICAgQ2FsbGJhY2sgZnVuY3Rpb24gdG8gY2FsbCB3aGVuIHRoZSBgSFRNTDVgIFRlY2ggaXMgcmVhZHkuXG4gICAqL1xuICBmdW5jdGlvbiBIdG1sNShvcHRpb25zLCByZWFkeSkge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIEh0bWw1KTtcblxuICAgIHZhciBfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1RlY2guY2FsbCh0aGlzLCBvcHRpb25zLCByZWFkeSkpO1xuXG4gICAgdmFyIHNvdXJjZSA9IG9wdGlvbnMuc291cmNlO1xuICAgIHZhciBjcm9zc29yaWdpblRyYWNrcyA9IGZhbHNlO1xuXG4gICAgLy8gU2V0IHRoZSBzb3VyY2UgaWYgb25lIGlzIHByb3ZpZGVkXG4gICAgLy8gMSkgQ2hlY2sgaWYgdGhlIHNvdXJjZSBpcyBuZXcgKGlmIG5vdCwgd2Ugd2FudCB0byBrZWVwIHRoZSBvcmlnaW5hbCBzbyBwbGF5YmFjayBpc24ndCBpbnRlcnJ1cHRlZClcbiAgICAvLyAyKSBDaGVjayB0byBzZWUgaWYgdGhlIG5ldHdvcmsgc3RhdGUgb2YgdGhlIHRhZyB3YXMgZmFpbGVkIGF0IGluaXQsIGFuZCBpZiBzbywgcmVzZXQgdGhlIHNvdXJjZVxuICAgIC8vIGFueXdheSBzbyB0aGUgZXJyb3IgZ2V0cyBmaXJlZC5cbiAgICBpZiAoc291cmNlICYmIChfdGhpcy5lbF8uY3VycmVudFNyYyAhPT0gc291cmNlLnNyYyB8fCBvcHRpb25zLnRhZyAmJiBvcHRpb25zLnRhZy5pbml0TmV0d29ya1N0YXRlXyA9PT0gMykpIHtcbiAgICAgIF90aGlzLnNldFNvdXJjZShzb3VyY2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICBfdGhpcy5oYW5kbGVMYXRlSW5pdF8oX3RoaXMuZWxfKTtcbiAgICB9XG5cbiAgICAvLyBzZXR1cCBzb3VyY2VzZXQgYWZ0ZXIgbGF0ZSBzb3VyY2VzZXQvaW5pdFxuICAgIGlmIChvcHRpb25zLmVuYWJsZVNvdXJjZXNldCkge1xuICAgICAgX3RoaXMuc2V0dXBTb3VyY2VzZXRIYW5kbGluZ18oKTtcbiAgICB9XG5cbiAgICBpZiAoX3RoaXMuZWxfLmhhc0NoaWxkTm9kZXMoKSkge1xuXG4gICAgICB2YXIgbm9kZXMgPSBfdGhpcy5lbF8uY2hpbGROb2RlcztcbiAgICAgIHZhciBub2Rlc0xlbmd0aCA9IG5vZGVzLmxlbmd0aDtcbiAgICAgIHZhciByZW1vdmVOb2RlcyA9IFtdO1xuXG4gICAgICB3aGlsZSAobm9kZXNMZW5ndGgtLSkge1xuICAgICAgICB2YXIgbm9kZSA9IG5vZGVzW25vZGVzTGVuZ3RoXTtcbiAgICAgICAgdmFyIG5vZGVOYW1lID0gbm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgICAgIGlmIChub2RlTmFtZSA9PT0gJ3RyYWNrJykge1xuICAgICAgICAgIGlmICghX3RoaXMuZmVhdHVyZXNOYXRpdmVUZXh0VHJhY2tzKSB7XG4gICAgICAgICAgICAvLyBFbXB0eSB2aWRlbyB0YWcgdHJhY2tzIHNvIHRoZSBidWlsdC1pbiBwbGF5ZXIgZG9lc24ndCB1c2UgdGhlbSBhbHNvLlxuICAgICAgICAgICAgLy8gVGhpcyBtYXkgbm90IGJlIGZhc3QgZW5vdWdoIHRvIHN0b3AgSFRNTDUgYnJvd3NlcnMgZnJvbSByZWFkaW5nIHRoZSB0YWdzXG4gICAgICAgICAgICAvLyBzbyB3ZSdsbCBuZWVkIHRvIHR1cm4gb2ZmIGFueSBkZWZhdWx0IHRyYWNrcyBpZiB3ZSdyZSBtYW51YWxseSBkb2luZ1xuICAgICAgICAgICAgLy8gY2FwdGlvbnMgYW5kIHN1YnRpdGxlcy4gdmlkZW9FbGVtZW50LnRleHRUcmFja3NcbiAgICAgICAgICAgIHJlbW92ZU5vZGVzLnB1c2gobm9kZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHN0b3JlIEhUTUxUcmFja0VsZW1lbnQgYW5kIFRleHRUcmFjayB0byByZW1vdGUgbGlzdFxuICAgICAgICAgICAgX3RoaXMucmVtb3RlVGV4dFRyYWNrRWxzKCkuYWRkVHJhY2tFbGVtZW50Xyhub2RlKTtcbiAgICAgICAgICAgIF90aGlzLnJlbW90ZVRleHRUcmFja3MoKS5hZGRUcmFjayhub2RlLnRyYWNrKTtcbiAgICAgICAgICAgIF90aGlzLnRleHRUcmFja3MoKS5hZGRUcmFjayhub2RlLnRyYWNrKTtcbiAgICAgICAgICAgIGlmICghY3Jvc3NvcmlnaW5UcmFja3MgJiYgIV90aGlzLmVsXy5oYXNBdHRyaWJ1dGUoJ2Nyb3Nzb3JpZ2luJykgJiYgaXNDcm9zc09yaWdpbihub2RlLnNyYykpIHtcbiAgICAgICAgICAgICAgY3Jvc3NvcmlnaW5UcmFja3MgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlbW92ZU5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIF90aGlzLmVsXy5yZW1vdmVDaGlsZChyZW1vdmVOb2Rlc1tpXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgX3RoaXMucHJveHlOYXRpdmVUcmFja3NfKCk7XG4gICAgaWYgKF90aGlzLmZlYXR1cmVzTmF0aXZlVGV4dFRyYWNrcyAmJiBjcm9zc29yaWdpblRyYWNrcykge1xuICAgICAgbG9nLndhcm4odHNtbChfdGVtcGxhdGVPYmplY3QkMikpO1xuICAgIH1cblxuICAgIC8vIHByZXZlbnQgaU9TIFNhZmFyaSBmcm9tIGRpc2FibGluZyBtZXRhZGF0YSB0ZXh0IHRyYWNrcyBkdXJpbmcgbmF0aXZlIHBsYXliYWNrXG4gICAgX3RoaXMucmVzdG9yZU1ldGFkYXRhVHJhY2tzSW5JT1NOYXRpdmVQbGF5ZXJfKCk7XG5cbiAgICAvLyBEZXRlcm1pbmUgaWYgbmF0aXZlIGNvbnRyb2xzIHNob3VsZCBiZSB1c2VkXG4gICAgLy8gT3VyIGdvYWwgc2hvdWxkIGJlIHRvIGdldCB0aGUgY3VzdG9tIGNvbnRyb2xzIG9uIG1vYmlsZSBzb2xpZCBldmVyeXdoZXJlXG4gICAgLy8gc28gd2UgY2FuIHJlbW92ZSB0aGlzIGFsbCB0b2dldGhlci4gUmlnaHQgbm93IHRoaXMgd2lsbCBibG9jayBjdXN0b21cbiAgICAvLyBjb250cm9scyBvbiB0b3VjaCBlbmFibGVkIGxhcHRvcHMgbGlrZSB0aGUgQ2hyb21lIFBpeGVsXG4gICAgaWYgKChUT1VDSF9FTkFCTEVEIHx8IElTX0lQSE9ORSB8fCBJU19OQVRJVkVfQU5EUk9JRCkgJiYgb3B0aW9ucy5uYXRpdmVDb250cm9sc0ZvclRvdWNoID09PSB0cnVlKSB7XG4gICAgICBfdGhpcy5zZXRDb250cm9scyh0cnVlKTtcbiAgICB9XG5cbiAgICAvLyBvbiBpT1MsIHdlIHdhbnQgdG8gcHJveHkgYHdlYmtpdGJlZ2luZnVsbHNjcmVlbmAgYW5kIGB3ZWJraXRlbmRmdWxsc2NyZWVuYFxuICAgIC8vIGludG8gYSBgZnVsbHNjcmVlbmNoYW5nZWAgZXZlbnRcbiAgICBfdGhpcy5wcm94eVdlYmtpdEZ1bGxzY3JlZW5fKCk7XG5cbiAgICBfdGhpcy50cmlnZ2VyUmVhZHkoKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICAvKipcbiAgICogRGlzcG9zZSBvZiBgSFRNTDVgIG1lZGlhIGVsZW1lbnQgYW5kIHJlbW92ZSBhbGwgdHJhY2tzLlxuICAgKi9cblxuXG4gIEh0bWw1LnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gZGlzcG9zZSgpIHtcbiAgICBpZiAodGhpcy5lbF8gJiYgdGhpcy5lbF8ucmVzZXRTb3VyY2VzZXRfKSB7XG4gICAgICB0aGlzLmVsXy5yZXNldFNvdXJjZXNldF8oKTtcbiAgICB9XG4gICAgSHRtbDUuZGlzcG9zZU1lZGlhRWxlbWVudCh0aGlzLmVsXyk7XG4gICAgdGhpcy5vcHRpb25zXyA9IG51bGw7XG5cbiAgICAvLyB0ZWNoIHdpbGwgaGFuZGxlIGNsZWFyaW5nIG9mIHRoZSBlbXVsYXRlZCB0cmFjayBsaXN0XG4gICAgX1RlY2gucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcbiAgfTtcblxuICAvKipcbiAgICogTW9kaWZ5IHRoZSBtZWRpYSBlbGVtZW50IHNvIHRoYXQgd2UgY2FuIGRldGVjdCB3aGVuXG4gICAqIHRoZSBzb3VyY2UgaXMgY2hhbmdlZC4gRmlyZXMgYHNvdXJjZXNldGAganVzdCBhZnRlciB0aGUgc291cmNlIGhhcyBjaGFuZ2VkXG4gICAqL1xuXG5cbiAgSHRtbDUucHJvdG90eXBlLnNldHVwU291cmNlc2V0SGFuZGxpbmdfID0gZnVuY3Rpb24gc2V0dXBTb3VyY2VzZXRIYW5kbGluZ18oKSB7XG4gICAgc2V0dXBTb3VyY2VzZXQodGhpcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFdoZW4gYSBjYXB0aW9ucyB0cmFjayBpcyBlbmFibGVkIGluIHRoZSBpT1MgU2FmYXJpIG5hdGl2ZSBwbGF5ZXIsIGFsbCBvdGhlclxuICAgKiB0cmFja3MgYXJlIGRpc2FibGVkIChpbmNsdWRpbmcgbWV0YWRhdGEgdHJhY2tzKSwgd2hpY2ggbnVsbHMgYWxsIG9mIHRoZWlyXG4gICAqIGFzc29jaWF0ZWQgY3VlIHBvaW50cy4gVGhpcyB3aWxsIHJlc3RvcmUgbWV0YWRhdGEgdHJhY2tzIHRvIHRoZWlyIHByZS1mdWxsc2NyZWVuXG4gICAqIHN0YXRlIGluIHRob3NlIGNhc2VzIHNvIHRoYXQgY3VlIHBvaW50cyBhcmUgbm90IG5lZWRsZXNzbHkgbG9zdC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBIdG1sNS5wcm90b3R5cGUucmVzdG9yZU1ldGFkYXRhVHJhY2tzSW5JT1NOYXRpdmVQbGF5ZXJfID0gZnVuY3Rpb24gcmVzdG9yZU1ldGFkYXRhVHJhY2tzSW5JT1NOYXRpdmVQbGF5ZXJfKCkge1xuICAgIHZhciB0ZXh0VHJhY2tzID0gdGhpcy50ZXh0VHJhY2tzKCk7XG4gICAgdmFyIG1ldGFkYXRhVHJhY2tzUHJlRnVsbHNjcmVlblN0YXRlID0gdm9pZCAwO1xuXG4gICAgLy8gY2FwdHVyZXMgYSBzbmFwc2hvdCBvZiBldmVyeSBtZXRhZGF0YSB0cmFjaydzIGN1cnJlbnQgc3RhdGVcbiAgICB2YXIgdGFrZU1ldGFkYXRhVHJhY2tTbmFwc2hvdCA9IGZ1bmN0aW9uIHRha2VNZXRhZGF0YVRyYWNrU25hcHNob3QoKSB7XG4gICAgICBtZXRhZGF0YVRyYWNrc1ByZUZ1bGxzY3JlZW5TdGF0ZSA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRleHRUcmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHRyYWNrID0gdGV4dFRyYWNrc1tpXTtcblxuICAgICAgICBpZiAodHJhY2sua2luZCA9PT0gJ21ldGFkYXRhJykge1xuICAgICAgICAgIG1ldGFkYXRhVHJhY2tzUHJlRnVsbHNjcmVlblN0YXRlLnB1c2goe1xuICAgICAgICAgICAgdHJhY2s6IHRyYWNrLFxuICAgICAgICAgICAgc3RvcmVkTW9kZTogdHJhY2subW9kZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8vIHNuYXBzaG90IGVhY2ggbWV0YWRhdGEgdHJhY2sncyBpbml0aWFsIHN0YXRlLCBhbmQgdXBkYXRlIHRoZSBzbmFwc2hvdFxuICAgIC8vIGVhY2ggdGltZSB0aGVyZSBpcyBhIHRyYWNrICdjaGFuZ2UnIGV2ZW50XG4gICAgdGFrZU1ldGFkYXRhVHJhY2tTbmFwc2hvdCgpO1xuICAgIHRleHRUcmFja3MuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgdGFrZU1ldGFkYXRhVHJhY2tTbmFwc2hvdCk7XG5cbiAgICB0aGlzLm9uKCdkaXNwb3NlJywgZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRleHRUcmFja3MucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgdGFrZU1ldGFkYXRhVHJhY2tTbmFwc2hvdCk7XG4gICAgfSk7XG5cbiAgICB2YXIgcmVzdG9yZVRyYWNrTW9kZSA9IGZ1bmN0aW9uIHJlc3RvcmVUcmFja01vZGUoKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1ldGFkYXRhVHJhY2tzUHJlRnVsbHNjcmVlblN0YXRlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBzdG9yZWRUcmFjayA9IG1ldGFkYXRhVHJhY2tzUHJlRnVsbHNjcmVlblN0YXRlW2ldO1xuXG4gICAgICAgIGlmIChzdG9yZWRUcmFjay50cmFjay5tb2RlID09PSAnZGlzYWJsZWQnICYmIHN0b3JlZFRyYWNrLnRyYWNrLm1vZGUgIT09IHN0b3JlZFRyYWNrLnN0b3JlZE1vZGUpIHtcbiAgICAgICAgICBzdG9yZWRUcmFjay50cmFjay5tb2RlID0gc3RvcmVkVHJhY2suc3RvcmVkTW9kZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gd2Ugb25seSB3YW50IHRoaXMgaGFuZGxlciB0byBiZSBleGVjdXRlZCBvbiB0aGUgZmlyc3QgJ2NoYW5nZScgZXZlbnRcbiAgICAgIHRleHRUcmFja3MucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgcmVzdG9yZVRyYWNrTW9kZSk7XG4gICAgfTtcblxuICAgIC8vIHdoZW4gd2UgZW50ZXIgZnVsbHNjcmVlbiBwbGF5YmFjaywgc3RvcCB1cGRhdGluZyB0aGUgc25hcHNob3QgYW5kXG4gICAgLy8gcmVzdG9yZSBhbGwgdHJhY2sgbW9kZXMgdG8gdGhlaXIgcHJlLWZ1bGxzY3JlZW4gc3RhdGVcbiAgICB0aGlzLm9uKCd3ZWJraXRiZWdpbmZ1bGxzY3JlZW4nLCBmdW5jdGlvbiAoKSB7XG4gICAgICB0ZXh0VHJhY2tzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHRha2VNZXRhZGF0YVRyYWNrU25hcHNob3QpO1xuXG4gICAgICAvLyByZW1vdmUgdGhlIGxpc3RlbmVyIGJlZm9yZSBhZGRpbmcgaXQganVzdCBpbiBjYXNlIGl0IHdhc24ndCBwcmV2aW91c2x5IHJlbW92ZWRcbiAgICAgIHRleHRUcmFja3MucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgcmVzdG9yZVRyYWNrTW9kZSk7XG4gICAgICB0ZXh0VHJhY2tzLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHJlc3RvcmVUcmFja01vZGUpO1xuICAgIH0pO1xuXG4gICAgLy8gc3RhcnQgdXBkYXRpbmcgdGhlIHNuYXBzaG90IGFnYWluIGFmdGVyIGxlYXZpbmcgZnVsbHNjcmVlblxuICAgIHRoaXMub24oJ3dlYmtpdGVuZGZ1bGxzY3JlZW4nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyByZW1vdmUgdGhlIGxpc3RlbmVyIGJlZm9yZSBhZGRpbmcgaXQganVzdCBpbiBjYXNlIGl0IHdhc24ndCBwcmV2aW91c2x5IHJlbW92ZWRcbiAgICAgIHRleHRUcmFja3MucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgdGFrZU1ldGFkYXRhVHJhY2tTbmFwc2hvdCk7XG4gICAgICB0ZXh0VHJhY2tzLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHRha2VNZXRhZGF0YVRyYWNrU25hcHNob3QpO1xuXG4gICAgICAvLyByZW1vdmUgdGhlIHJlc3RvcmVUcmFja01vZGUgaGFuZGxlciBpbiBjYXNlIGl0IHdhc24ndCB0cmlnZ2VyZWQgZHVyaW5nIGZ1bGxzY3JlZW4gcGxheWJhY2tcbiAgICAgIHRleHRUcmFja3MucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgcmVzdG9yZVRyYWNrTW9kZSk7XG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFByb3h5IGFsbCBuYXRpdmUgdHJhY2sgbGlzdCBldmVudHMgdG8gb3VyIHRyYWNrIGxpc3RzIGlmIHRoZSBicm93c2VyIHdlIGFyZSBwbGF5aW5nXG4gICAqIGluIHN1cHBvcnRzIHRoYXQgdHlwZSBvZiB0cmFjayBsaXN0LlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIEh0bWw1LnByb3RvdHlwZS5wcm94eU5hdGl2ZVRyYWNrc18gPSBmdW5jdGlvbiBwcm94eU5hdGl2ZVRyYWNrc18oKSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICBOT1JNQUwubmFtZXMuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgdmFyIHByb3BzID0gTk9STUFMW25hbWVdO1xuICAgICAgdmFyIGVsVHJhY2tzID0gX3RoaXMyLmVsKClbcHJvcHMuZ2V0dGVyTmFtZV07XG4gICAgICB2YXIgdGVjaFRyYWNrcyA9IF90aGlzMltwcm9wcy5nZXR0ZXJOYW1lXSgpO1xuXG4gICAgICBpZiAoIV90aGlzMlsnZmVhdHVyZXNOYXRpdmUnICsgcHJvcHMuY2FwaXRhbE5hbWUgKyAnVHJhY2tzJ10gfHwgIWVsVHJhY2tzIHx8ICFlbFRyYWNrcy5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBsaXN0ZW5lcnMgPSB7XG4gICAgICAgIGNoYW5nZTogZnVuY3Rpb24gY2hhbmdlKGUpIHtcbiAgICAgICAgICB0ZWNoVHJhY2tzLnRyaWdnZXIoe1xuICAgICAgICAgICAgdHlwZTogJ2NoYW5nZScsXG4gICAgICAgICAgICB0YXJnZXQ6IHRlY2hUcmFja3MsXG4gICAgICAgICAgICBjdXJyZW50VGFyZ2V0OiB0ZWNoVHJhY2tzLFxuICAgICAgICAgICAgc3JjRWxlbWVudDogdGVjaFRyYWNrc1xuICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBhZGR0cmFjazogZnVuY3Rpb24gYWRkdHJhY2soZSkge1xuICAgICAgICAgIHRlY2hUcmFja3MuYWRkVHJhY2soZS50cmFjayk7XG4gICAgICAgIH0sXG4gICAgICAgIHJlbW92ZXRyYWNrOiBmdW5jdGlvbiByZW1vdmV0cmFjayhlKSB7XG4gICAgICAgICAgdGVjaFRyYWNrcy5yZW1vdmVUcmFjayhlLnRyYWNrKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHZhciByZW1vdmVPbGRUcmFja3MgPSBmdW5jdGlvbiByZW1vdmVPbGRUcmFja3MoKSB7XG4gICAgICAgIHZhciByZW1vdmVUcmFja3MgPSBbXTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRlY2hUcmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgZm91bmQgPSBmYWxzZTtcblxuICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZWxUcmFja3MubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGlmIChlbFRyYWNrc1tqXSA9PT0gdGVjaFRyYWNrc1tpXSkge1xuICAgICAgICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghZm91bmQpIHtcbiAgICAgICAgICAgIHJlbW92ZVRyYWNrcy5wdXNoKHRlY2hUcmFja3NbaV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHdoaWxlIChyZW1vdmVUcmFja3MubGVuZ3RoKSB7XG4gICAgICAgICAgdGVjaFRyYWNrcy5yZW1vdmVUcmFjayhyZW1vdmVUcmFja3Muc2hpZnQoKSk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIE9iamVjdC5rZXlzKGxpc3RlbmVycykuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnROYW1lKSB7XG4gICAgICAgIHZhciBsaXN0ZW5lciA9IGxpc3RlbmVyc1tldmVudE5hbWVdO1xuXG4gICAgICAgIGVsVHJhY2tzLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBsaXN0ZW5lcik7XG4gICAgICAgIF90aGlzMi5vbignZGlzcG9zZScsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgcmV0dXJuIGVsVHJhY2tzLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBsaXN0ZW5lcik7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIFJlbW92ZSAobmF0aXZlKSB0cmFja3MgdGhhdCBhcmUgbm90IHVzZWQgYW55bW9yZVxuICAgICAgX3RoaXMyLm9uKCdsb2Fkc3RhcnQnLCByZW1vdmVPbGRUcmFja3MpO1xuICAgICAgX3RoaXMyLm9uKCdkaXNwb3NlJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzMi5vZmYoJ2xvYWRzdGFydCcsIHJlbW92ZU9sZFRyYWNrcyk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlIHRoZSBgSHRtbDVgIFRlY2gncyBET00gZWxlbWVudC5cbiAgICpcbiAgICogQHJldHVybiB7RWxlbWVudH1cbiAgICogICAgICAgICBUaGUgZWxlbWVudCB0aGF0IGdldHMgY3JlYXRlZC5cbiAgICovXG5cblxuICBIdG1sNS5wcm90b3R5cGUuY3JlYXRlRWwgPSBmdW5jdGlvbiBjcmVhdGVFbCQkMSgpIHtcbiAgICB2YXIgZWwgPSB0aGlzLm9wdGlvbnNfLnRhZztcblxuICAgIC8vIENoZWNrIGlmIHRoaXMgYnJvd3NlciBzdXBwb3J0cyBtb3ZpbmcgdGhlIGVsZW1lbnQgaW50byB0aGUgYm94LlxuICAgIC8vIE9uIHRoZSBpUGhvbmUgdmlkZW8gd2lsbCBicmVhayBpZiB5b3UgbW92ZSB0aGUgZWxlbWVudCxcbiAgICAvLyBTbyB3ZSBoYXZlIHRvIGNyZWF0ZSBhIGJyYW5kIG5ldyBlbGVtZW50LlxuICAgIC8vIElmIHdlIGluZ2VzdGVkIHRoZSBwbGF5ZXIgZGl2LCB3ZSBkbyBub3QgbmVlZCB0byBtb3ZlIHRoZSBtZWRpYSBlbGVtZW50LlxuICAgIGlmICghZWwgfHwgISh0aGlzLm9wdGlvbnNfLnBsYXllckVsSW5nZXN0IHx8IHRoaXMubW92aW5nTWVkaWFFbGVtZW50SW5ET00pKSB7XG5cbiAgICAgIC8vIElmIHRoZSBvcmlnaW5hbCB0YWcgaXMgc3RpbGwgdGhlcmUsIGNsb25lIGFuZCByZW1vdmUgaXQuXG4gICAgICBpZiAoZWwpIHtcbiAgICAgICAgdmFyIGNsb25lID0gZWwuY2xvbmVOb2RlKHRydWUpO1xuXG4gICAgICAgIGlmIChlbC5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgZWwucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoY2xvbmUsIGVsKTtcbiAgICAgICAgfVxuICAgICAgICBIdG1sNS5kaXNwb3NlTWVkaWFFbGVtZW50KGVsKTtcbiAgICAgICAgZWwgPSBjbG9uZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndmlkZW8nKTtcblxuICAgICAgICAvLyBkZXRlcm1pbmUgaWYgbmF0aXZlIGNvbnRyb2xzIHNob3VsZCBiZSB1c2VkXG4gICAgICAgIHZhciB0YWdBdHRyaWJ1dGVzID0gdGhpcy5vcHRpb25zXy50YWcgJiYgZ2V0QXR0cmlidXRlcyh0aGlzLm9wdGlvbnNfLnRhZyk7XG4gICAgICAgIHZhciBhdHRyaWJ1dGVzID0gbWVyZ2VPcHRpb25zKHt9LCB0YWdBdHRyaWJ1dGVzKTtcblxuICAgICAgICBpZiAoIVRPVUNIX0VOQUJMRUQgfHwgdGhpcy5vcHRpb25zXy5uYXRpdmVDb250cm9sc0ZvclRvdWNoICE9PSB0cnVlKSB7XG4gICAgICAgICAgZGVsZXRlIGF0dHJpYnV0ZXMuY29udHJvbHM7XG4gICAgICAgIH1cblxuICAgICAgICBzZXRBdHRyaWJ1dGVzKGVsLCBhc3NpZ24oYXR0cmlidXRlcywge1xuICAgICAgICAgIGlkOiB0aGlzLm9wdGlvbnNfLnRlY2hJZCxcbiAgICAgICAgICAnY2xhc3MnOiAndmpzLXRlY2gnXG4gICAgICAgIH0pKTtcbiAgICAgIH1cblxuICAgICAgZWwucGxheWVySWQgPSB0aGlzLm9wdGlvbnNfLnBsYXllcklkO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zXy5wcmVsb2FkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgc2V0QXR0cmlidXRlKGVsLCAncHJlbG9hZCcsIHRoaXMub3B0aW9uc18ucHJlbG9hZCk7XG4gICAgfVxuXG4gICAgLy8gVXBkYXRlIHNwZWNpZmljIHRhZyBzZXR0aW5ncywgaW4gY2FzZSB0aGV5IHdlcmUgb3ZlcnJpZGRlblxuICAgIC8vIGBhdXRvcGxheWAgaGFzIHRvIGJlICpsYXN0KiBzbyB0aGF0IGBtdXRlZGAgYW5kIGBwbGF5c2lubGluZWAgYXJlIHByZXNlbnRcbiAgICAvLyB3aGVuIGlPUy9TYWZhcmkgb3Igb3RoZXIgYnJvd3NlcnMgYXR0ZW1wdCB0byBhdXRvcGxheS5cbiAgICB2YXIgc2V0dGluZ3NBdHRycyA9IFsnbG9vcCcsICdtdXRlZCcsICdwbGF5c2lubGluZScsICdhdXRvcGxheSddO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZXR0aW5nc0F0dHJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgYXR0ciA9IHNldHRpbmdzQXR0cnNbaV07XG4gICAgICB2YXIgdmFsdWUgPSB0aGlzLm9wdGlvbnNfW2F0dHJdO1xuXG4gICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICBzZXRBdHRyaWJ1dGUoZWwsIGF0dHIsIGF0dHIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlbW92ZUF0dHJpYnV0ZShlbCwgYXR0cik7XG4gICAgICAgIH1cbiAgICAgICAgZWxbYXR0cl0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZWw7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoaXMgd2lsbCBiZSB0cmlnZ2VyZWQgaWYgdGhlIGxvYWRzdGFydCBldmVudCBoYXMgYWxyZWFkeSBmaXJlZCwgYmVmb3JlIHZpZGVvanMgd2FzXG4gICAqIHJlYWR5LiBUd28ga25vd24gZXhhbXBsZXMgb2Ygd2hlbiB0aGlzIGNhbiBoYXBwZW4gYXJlOlxuICAgKiAxLiBJZiB3ZSdyZSBsb2FkaW5nIHRoZSBwbGF5YmFjayBvYmplY3QgYWZ0ZXIgaXQgaGFzIHN0YXJ0ZWQgbG9hZGluZ1xuICAgKiAyLiBUaGUgbWVkaWEgaXMgYWxyZWFkeSBwbGF5aW5nIHRoZSAob2Z0ZW4gd2l0aCBhdXRvcGxheSBvbikgdGhlblxuICAgKlxuICAgKiBUaGlzIGZ1bmN0aW9uIHdpbGwgZmlyZSBhbm90aGVyIGxvYWRzdGFydCBzbyB0aGF0IHZpZGVvanMgY2FuIGNhdGNodXAuXG4gICAqXG4gICAqIEBmaXJlcyBUZWNoI2xvYWRzdGFydFxuICAgKlxuICAgKiBAcmV0dXJuIHt1bmRlZmluZWR9XG4gICAqICAgICAgICAgcmV0dXJucyBub3RoaW5nLlxuICAgKi9cblxuXG4gIEh0bWw1LnByb3RvdHlwZS5oYW5kbGVMYXRlSW5pdF8gPSBmdW5jdGlvbiBoYW5kbGVMYXRlSW5pdF8oZWwpIHtcbiAgICBpZiAoZWwubmV0d29ya1N0YXRlID09PSAwIHx8IGVsLm5ldHdvcmtTdGF0ZSA9PT0gMykge1xuICAgICAgLy8gVGhlIHZpZGVvIGVsZW1lbnQgaGFzbid0IHN0YXJ0ZWQgbG9hZGluZyB0aGUgc291cmNlIHlldFxuICAgICAgLy8gb3IgZGlkbid0IGZpbmQgYSBzb3VyY2VcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZWwucmVhZHlTdGF0ZSA9PT0gMCkge1xuICAgICAgLy8gTmV0d29ya1N0YXRlIGlzIHNldCBzeW5jaHJvbm91c2x5IEJVVCBsb2Fkc3RhcnQgaXMgZmlyZWQgYXQgdGhlXG4gICAgICAvLyBlbmQgb2YgdGhlIGN1cnJlbnQgc3RhY2ssIHVzdWFsbHkgYmVmb3JlIHNldEludGVydmFsKGZuLCAwKS5cbiAgICAgIC8vIFNvIGF0IHRoaXMgcG9pbnQgd2Uga25vdyBsb2Fkc3RhcnQgbWF5IGhhdmUgYWxyZWFkeSBmaXJlZCBvciBpc1xuICAgICAgLy8gYWJvdXQgdG8gZmlyZSwgYW5kIGVpdGhlciB3YXkgdGhlIHBsYXllciBoYXNuJ3Qgc2VlbiBpdCB5ZXQuXG4gICAgICAvLyBXZSBkb24ndCB3YW50IHRvIGZpcmUgbG9hZHN0YXJ0IHByZW1hdHVyZWx5IGhlcmUgYW5kIGNhdXNlIGFcbiAgICAgIC8vIGRvdWJsZSBsb2Fkc3RhcnQgc28gd2UnbGwgd2FpdCBhbmQgc2VlIGlmIGl0IGhhcHBlbnMgYmV0d2VlbiBub3dcbiAgICAgIC8vIGFuZCB0aGUgbmV4dCBsb29wLCBhbmQgZmlyZSBpdCBpZiBub3QuXG4gICAgICAvLyBIT1dFVkVSLCB3ZSBhbHNvIHdhbnQgdG8gbWFrZSBzdXJlIGl0IGZpcmVzIGJlZm9yZSBsb2FkZWRtZXRhZGF0YVxuICAgICAgLy8gd2hpY2ggY291bGQgYWxzbyBoYXBwZW4gYmV0d2VlbiBub3cgYW5kIHRoZSBuZXh0IGxvb3AsIHNvIHdlJ2xsXG4gICAgICAvLyB3YXRjaCBmb3IgdGhhdCBhbHNvLlxuICAgICAgdmFyIGxvYWRzdGFydEZpcmVkID0gZmFsc2U7XG4gICAgICB2YXIgc2V0TG9hZHN0YXJ0RmlyZWQgPSBmdW5jdGlvbiBzZXRMb2Fkc3RhcnRGaXJlZCgpIHtcbiAgICAgICAgbG9hZHN0YXJ0RmlyZWQgPSB0cnVlO1xuICAgICAgfTtcblxuICAgICAgdGhpcy5vbignbG9hZHN0YXJ0Jywgc2V0TG9hZHN0YXJ0RmlyZWQpO1xuXG4gICAgICB2YXIgdHJpZ2dlckxvYWRzdGFydCA9IGZ1bmN0aW9uIHRyaWdnZXJMb2Fkc3RhcnQoKSB7XG4gICAgICAgIC8vIFdlIGRpZCBtaXNzIHRoZSBvcmlnaW5hbCBsb2Fkc3RhcnQuIE1ha2Ugc3VyZSB0aGUgcGxheWVyXG4gICAgICAgIC8vIHNlZXMgbG9hZHN0YXJ0IGJlZm9yZSBsb2FkZWRtZXRhZGF0YVxuICAgICAgICBpZiAoIWxvYWRzdGFydEZpcmVkKSB7XG4gICAgICAgICAgdGhpcy50cmlnZ2VyKCdsb2Fkc3RhcnQnKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgdGhpcy5vbignbG9hZGVkbWV0YWRhdGEnLCB0cmlnZ2VyTG9hZHN0YXJ0KTtcblxuICAgICAgdGhpcy5yZWFkeShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMub2ZmKCdsb2Fkc3RhcnQnLCBzZXRMb2Fkc3RhcnRGaXJlZCk7XG4gICAgICAgIHRoaXMub2ZmKCdsb2FkZWRtZXRhZGF0YScsIHRyaWdnZXJMb2Fkc3RhcnQpO1xuXG4gICAgICAgIGlmICghbG9hZHN0YXJ0RmlyZWQpIHtcbiAgICAgICAgICAvLyBXZSBkaWQgbWlzcyB0aGUgb3JpZ2luYWwgbmF0aXZlIGxvYWRzdGFydC4gRmlyZSBpdCBub3cuXG4gICAgICAgICAgdGhpcy50cmlnZ2VyKCdsb2Fkc3RhcnQnKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBGcm9tIGhlcmUgb24gd2Uga25vdyB0aGF0IGxvYWRzdGFydCBhbHJlYWR5IGZpcmVkIGFuZCB3ZSBtaXNzZWQgaXQuXG4gICAgLy8gVGhlIG90aGVyIHJlYWR5U3RhdGUgZXZlbnRzIGFyZW4ndCBhcyBtdWNoIG9mIGEgcHJvYmxlbSBpZiB3ZSBkb3VibGVcbiAgICAvLyB0aGVtLCBzbyBub3QgZ29pbmcgdG8gZ28gdG8gYXMgbXVjaCB0cm91YmxlIGFzIGxvYWRzdGFydCB0byBwcmV2ZW50XG4gICAgLy8gdGhhdCB1bmxlc3Mgd2UgZmluZCByZWFzb24gdG8uXG4gICAgdmFyIGV2ZW50c1RvVHJpZ2dlciA9IFsnbG9hZHN0YXJ0J107XG5cbiAgICAvLyBsb2FkZWRtZXRhZGF0YTogbmV3bHkgZXF1YWwgdG8gSEFWRV9NRVRBREFUQSAoMSkgb3IgZ3JlYXRlclxuICAgIGV2ZW50c1RvVHJpZ2dlci5wdXNoKCdsb2FkZWRtZXRhZGF0YScpO1xuXG4gICAgLy8gbG9hZGVkZGF0YTogbmV3bHkgaW5jcmVhc2VkIHRvIEhBVkVfQ1VSUkVOVF9EQVRBICgyKSBvciBncmVhdGVyXG4gICAgaWYgKGVsLnJlYWR5U3RhdGUgPj0gMikge1xuICAgICAgZXZlbnRzVG9UcmlnZ2VyLnB1c2goJ2xvYWRlZGRhdGEnKTtcbiAgICB9XG5cbiAgICAvLyBjYW5wbGF5OiBuZXdseSBpbmNyZWFzZWQgdG8gSEFWRV9GVVRVUkVfREFUQSAoMykgb3IgZ3JlYXRlclxuICAgIGlmIChlbC5yZWFkeVN0YXRlID49IDMpIHtcbiAgICAgIGV2ZW50c1RvVHJpZ2dlci5wdXNoKCdjYW5wbGF5Jyk7XG4gICAgfVxuXG4gICAgLy8gY2FucGxheXRocm91Z2g6IG5ld2x5IGVxdWFsIHRvIEhBVkVfRU5PVUdIX0RBVEEgKDQpXG4gICAgaWYgKGVsLnJlYWR5U3RhdGUgPj0gNCkge1xuICAgICAgZXZlbnRzVG9UcmlnZ2VyLnB1c2goJ2NhbnBsYXl0aHJvdWdoJyk7XG4gICAgfVxuXG4gICAgLy8gV2Ugc3RpbGwgbmVlZCB0byBnaXZlIHRoZSBwbGF5ZXIgdGltZSB0byBhZGQgZXZlbnQgbGlzdGVuZXJzXG4gICAgdGhpcy5yZWFkeShmdW5jdGlvbiAoKSB7XG4gICAgICBldmVudHNUb1RyaWdnZXIuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICB0aGlzLnRyaWdnZXIodHlwZSk7XG4gICAgICB9LCB0aGlzKTtcbiAgICB9KTtcbiAgfTtcblxuICAvKipcbiAgICogU2V0IGN1cnJlbnQgdGltZSBmb3IgdGhlIGBIVE1MNWAgdGVjaC5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNlY29uZHNcbiAgICogICAgICAgIFNldCB0aGUgY3VycmVudCB0aW1lIG9mIHRoZSBtZWRpYSB0byB0aGlzLlxuICAgKi9cblxuXG4gIEh0bWw1LnByb3RvdHlwZS5zZXRDdXJyZW50VGltZSA9IGZ1bmN0aW9uIHNldEN1cnJlbnRUaW1lKHNlY29uZHMpIHtcbiAgICB0cnkge1xuICAgICAgdGhpcy5lbF8uY3VycmVudFRpbWUgPSBzZWNvbmRzO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGxvZyhlLCAnVmlkZW8gaXMgbm90IHJlYWR5LiAoVmlkZW8uanMpJyk7XG4gICAgICAvLyB0aGlzLndhcm5pbmcoVmlkZW9KUy53YXJuaW5ncy52aWRlb05vdFJlYWR5KTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgY3VycmVudCBkdXJhdGlvbiBvZiB0aGUgSFRNTDUgbWVkaWEgZWxlbWVudC5cbiAgICpcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKiAgICAgICAgIFRoZSBkdXJhdGlvbiBvZiB0aGUgbWVkaWEgb3IgMCBpZiB0aGVyZSBpcyBubyBkdXJhdGlvbi5cbiAgICovXG5cblxuICBIdG1sNS5wcm90b3R5cGUuZHVyYXRpb24gPSBmdW5jdGlvbiBkdXJhdGlvbigpIHtcbiAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgIC8vIEFuZHJvaWQgQ2hyb21lIHdpbGwgcmVwb3J0IGR1cmF0aW9uIGFzIEluZmluaXR5IGZvciBWT0QgSExTIHVudGlsIGFmdGVyXG4gICAgLy8gcGxheWJhY2sgaGFzIHN0YXJ0ZWQsIHdoaWNoIHRyaWdnZXJzIHRoZSBsaXZlIGRpc3BsYXkgZXJyb25lb3VzbHkuXG4gICAgLy8gUmV0dXJuIE5hTiBpZiBwbGF5YmFjayBoYXMgbm90IHN0YXJ0ZWQgYW5kIHRyaWdnZXIgYSBkdXJhdGlvbnVwZGF0ZSBvbmNlXG4gICAgLy8gdGhlIGR1cmF0aW9uIGNhbiBiZSByZWxpYWJseSBrbm93bi5cbiAgICBpZiAodGhpcy5lbF8uZHVyYXRpb24gPT09IEluZmluaXR5ICYmIElTX0FORFJPSUQgJiYgSVNfQ0hST01FICYmIHRoaXMuZWxfLmN1cnJlbnRUaW1lID09PSAwKSB7XG4gICAgICAvLyBXYWl0IGZvciB0aGUgZmlyc3QgYHRpbWV1cGRhdGVgIHdpdGggY3VycmVudFRpbWUgPiAwIC0gdGhlcmUgbWF5IGJlXG4gICAgICAvLyBzZXZlcmFsIHdpdGggMFxuICAgICAgdmFyIGNoZWNrUHJvZ3Jlc3MgPSBmdW5jdGlvbiBjaGVja1Byb2dyZXNzKCkge1xuICAgICAgICBpZiAoX3RoaXMzLmVsXy5jdXJyZW50VGltZSA+IDApIHtcbiAgICAgICAgICAvLyBUcmlnZ2VyIGR1cmF0aW9uY2hhbmdlIGZvciBnZW51aW5lbHkgbGl2ZSB2aWRlb1xuICAgICAgICAgIGlmIChfdGhpczMuZWxfLmR1cmF0aW9uID09PSBJbmZpbml0eSkge1xuICAgICAgICAgICAgX3RoaXMzLnRyaWdnZXIoJ2R1cmF0aW9uY2hhbmdlJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIF90aGlzMy5vZmYoJ3RpbWV1cGRhdGUnLCBjaGVja1Byb2dyZXNzKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgdGhpcy5vbigndGltZXVwZGF0ZScsIGNoZWNrUHJvZ3Jlc3MpO1xuICAgICAgcmV0dXJuIE5hTjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZWxfLmR1cmF0aW9uIHx8IE5hTjtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSBjdXJyZW50IHdpZHRoIG9mIHRoZSBIVE1MNSBtZWRpYSBlbGVtZW50LlxuICAgKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqICAgICAgICAgVGhlIHdpZHRoIG9mIHRoZSBIVE1MNSBtZWRpYSBlbGVtZW50LlxuICAgKi9cblxuXG4gIEh0bWw1LnByb3RvdHlwZS53aWR0aCA9IGZ1bmN0aW9uIHdpZHRoKCkge1xuICAgIHJldHVybiB0aGlzLmVsXy5vZmZzZXRXaWR0aDtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSBjdXJyZW50IGhlaWdodCBvZiB0aGUgSFRNTDUgbWVkaWEgZWxlbWVudC5cbiAgICpcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKiAgICAgICAgIFRoZSBoZWlndGggb2YgdGhlIEhUTUw1IG1lZGlhIGVsZW1lbnQuXG4gICAqL1xuXG5cbiAgSHRtbDUucHJvdG90eXBlLmhlaWdodCA9IGZ1bmN0aW9uIGhlaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy5lbF8ub2Zmc2V0SGVpZ2h0O1xuICB9O1xuXG4gIC8qKlxuICAgKiBQcm94eSBpT1MgYHdlYmtpdGJlZ2luZnVsbHNjcmVlbmAgYW5kIGB3ZWJraXRlbmRmdWxsc2NyZWVuYCBpbnRvXG4gICAqIGBmdWxsc2NyZWVuY2hhbmdlYCBldmVudC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQGZpcmVzIGZ1bGxzY3JlZW5jaGFuZ2VcbiAgICogQGxpc3RlbnMgd2Via2l0ZW5kZnVsbHNjcmVlblxuICAgKiBAbGlzdGVucyB3ZWJraXRiZWdpbmZ1bGxzY3JlZW5cbiAgICogQGxpc3RlbnMgd2Via2l0YmVnaW5mdWxsc2NyZWVuXG4gICAqL1xuXG5cbiAgSHRtbDUucHJvdG90eXBlLnByb3h5V2Via2l0RnVsbHNjcmVlbl8gPSBmdW5jdGlvbiBwcm94eVdlYmtpdEZ1bGxzY3JlZW5fKCkge1xuICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgaWYgKCEoJ3dlYmtpdERpc3BsYXlpbmdGdWxsc2NyZWVuJyBpbiB0aGlzLmVsXykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgZW5kRm4gPSBmdW5jdGlvbiBlbmRGbigpIHtcbiAgICAgIHRoaXMudHJpZ2dlcignZnVsbHNjcmVlbmNoYW5nZScsIHsgaXNGdWxsc2NyZWVuOiBmYWxzZSB9KTtcbiAgICB9O1xuXG4gICAgdmFyIGJlZ2luRm4gPSBmdW5jdGlvbiBiZWdpbkZuKCkge1xuICAgICAgaWYgKCd3ZWJraXRQcmVzZW50YXRpb25Nb2RlJyBpbiB0aGlzLmVsXyAmJiB0aGlzLmVsXy53ZWJraXRQcmVzZW50YXRpb25Nb2RlICE9PSAncGljdHVyZS1pbi1waWN0dXJlJykge1xuICAgICAgICB0aGlzLm9uZSgnd2Via2l0ZW5kZnVsbHNjcmVlbicsIGVuZEZuKTtcblxuICAgICAgICB0aGlzLnRyaWdnZXIoJ2Z1bGxzY3JlZW5jaGFuZ2UnLCB7IGlzRnVsbHNjcmVlbjogdHJ1ZSB9KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy5vbignd2Via2l0YmVnaW5mdWxsc2NyZWVuJywgYmVnaW5Gbik7XG4gICAgdGhpcy5vbignZGlzcG9zZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzNC5vZmYoJ3dlYmtpdGJlZ2luZnVsbHNjcmVlbicsIGJlZ2luRm4pO1xuICAgICAgX3RoaXM0Lm9mZignd2Via2l0ZW5kZnVsbHNjcmVlbicsIGVuZEZuKTtcbiAgICB9KTtcbiAgfTtcblxuICAvKipcbiAgICogQ2hlY2sgaWYgZnVsbHNjcmVlbiBpcyBzdXBwb3J0ZWQgb24gdGhlIGN1cnJlbnQgcGxheWJhY2sgZGV2aWNlLlxuICAgKlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKiAgICAgICAgIC0gVHJ1ZSBpZiBmdWxsc2NyZWVuIGlzIHN1cHBvcnRlZC5cbiAgICogICAgICAgICAtIEZhbHNlIGlmIGZ1bGxzY3JlZW4gaXMgbm90IHN1cHBvcnRlZC5cbiAgICovXG5cblxuICBIdG1sNS5wcm90b3R5cGUuc3VwcG9ydHNGdWxsU2NyZWVuID0gZnVuY3Rpb24gc3VwcG9ydHNGdWxsU2NyZWVuKCkge1xuICAgIGlmICh0eXBlb2YgdGhpcy5lbF8ud2Via2l0RW50ZXJGdWxsU2NyZWVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2YXIgdXNlckFnZW50ID0gd2luZG93Lm5hdmlnYXRvciAmJiB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudCB8fCAnJztcblxuICAgICAgLy8gU2VlbXMgdG8gYmUgYnJva2VuIGluIENocm9taXVtL0Nocm9tZSAmJiBTYWZhcmkgaW4gTGVvcGFyZFxuICAgICAgaWYgKC9BbmRyb2lkLy50ZXN0KHVzZXJBZ2VudCkgfHwgIS9DaHJvbWV8TWFjIE9TIFggMTAuNS8udGVzdCh1c2VyQWdlbnQpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlcXVlc3QgdGhhdCB0aGUgYEhUTUw1YCBUZWNoIGVudGVyIGZ1bGxzY3JlZW4uXG4gICAqL1xuXG5cbiAgSHRtbDUucHJvdG90eXBlLmVudGVyRnVsbFNjcmVlbiA9IGZ1bmN0aW9uIGVudGVyRnVsbFNjcmVlbigpIHtcbiAgICB2YXIgdmlkZW8gPSB0aGlzLmVsXztcblxuICAgIGlmICh2aWRlby5wYXVzZWQgJiYgdmlkZW8ubmV0d29ya1N0YXRlIDw9IHZpZGVvLkhBVkVfTUVUQURBVEEpIHtcbiAgICAgIC8vIGF0dGVtcHQgdG8gcHJpbWUgdGhlIHZpZGVvIGVsZW1lbnQgZm9yIHByb2dyYW1tYXRpYyBhY2Nlc3NcbiAgICAgIC8vIHRoaXMgaXNuJ3QgbmVjZXNzYXJ5IG9uIHRoZSBkZXNrdG9wIGJ1dCBzaG91bGRuJ3QgaHVydFxuICAgICAgdGhpcy5lbF8ucGxheSgpO1xuXG4gICAgICAvLyBwbGF5aW5nIGFuZCBwYXVzaW5nIHN5bmNocm9ub3VzbHkgZHVyaW5nIHRoZSB0cmFuc2l0aW9uIHRvIGZ1bGxzY3JlZW5cbiAgICAgIC8vIGNhbiBnZXQgaU9TIH42LjEgZGV2aWNlcyBpbnRvIGEgcGxheS9wYXVzZSBsb29wXG4gICAgICB0aGlzLnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICB2aWRlby5wYXVzZSgpO1xuICAgICAgICB2aWRlby53ZWJraXRFbnRlckZ1bGxTY3JlZW4oKTtcbiAgICAgIH0sIDApO1xuICAgIH0gZWxzZSB7XG4gICAgICB2aWRlby53ZWJraXRFbnRlckZ1bGxTY3JlZW4oKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlcXVlc3QgdGhhdCB0aGUgYEhUTUw1YCBUZWNoIGV4aXQgZnVsbHNjcmVlbi5cbiAgICovXG5cblxuICBIdG1sNS5wcm90b3R5cGUuZXhpdEZ1bGxTY3JlZW4gPSBmdW5jdGlvbiBleGl0RnVsbFNjcmVlbigpIHtcbiAgICB0aGlzLmVsXy53ZWJraXRFeGl0RnVsbFNjcmVlbigpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBIGdldHRlci9zZXR0ZXIgZm9yIHRoZSBgSHRtbDVgIFRlY2gncyBzb3VyY2Ugb2JqZWN0LlxuICAgKiA+IE5vdGU6IFBsZWFzZSB1c2Uge0BsaW5rIEh0bWw1I3NldFNvdXJjZX1cbiAgICpcbiAgICogQHBhcmFtIHtUZWNoflNvdXJjZU9iamVjdH0gW3NyY11cbiAgICogICAgICAgIFRoZSBzb3VyY2Ugb2JqZWN0IHlvdSB3YW50IHRvIHNldCBvbiB0aGUgYEhUTUw1YCB0ZWNocyBlbGVtZW50LlxuICAgKlxuICAgKiBAcmV0dXJuIHtUZWNoflNvdXJjZU9iamVjdHx1bmRlZmluZWR9XG4gICAqICAgICAgICAgLSBUaGUgY3VycmVudCBzb3VyY2Ugb2JqZWN0IHdoZW4gYSBzb3VyY2UgaXMgbm90IHBhc3NlZCBpbi5cbiAgICogICAgICAgICAtIHVuZGVmaW5lZCB3aGVuIHNldHRpbmdcbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgU2luY2UgdmVyc2lvbiA1LlxuICAgKi9cblxuXG4gIEh0bWw1LnByb3RvdHlwZS5zcmMgPSBmdW5jdGlvbiBzcmMoX3NyYykge1xuICAgIGlmIChfc3JjID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLmVsXy5zcmM7XG4gICAgfVxuXG4gICAgLy8gU2V0dGluZyBzcmMgdGhyb3VnaCBgc3JjYCBpbnN0ZWFkIG9mIGBzZXRTcmNgIHdpbGwgYmUgZGVwcmVjYXRlZFxuICAgIHRoaXMuc2V0U3JjKF9zcmMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXNldCB0aGUgdGVjaCBieSByZW1vdmluZyBhbGwgc291cmNlcyBhbmQgdGhlbiBjYWxsaW5nXG4gICAqIHtAbGluayBIdG1sNS5yZXNldE1lZGlhRWxlbWVudH0uXG4gICAqL1xuXG5cbiAgSHRtbDUucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgSHRtbDUucmVzZXRNZWRpYUVsZW1lbnQodGhpcy5lbF8pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGN1cnJlbnQgc291cmNlIG9uIHRoZSBgSFRNTDVgIFRlY2guIEZhbGxzIGJhY2sgdG8gcmV0dXJuaW5nIHRoZSBzb3VyY2UgZnJvbVxuICAgKiB0aGUgSFRNTDUgbWVkaWEgZWxlbWVudC5cbiAgICpcbiAgICogQHJldHVybiB7VGVjaH5Tb3VyY2VPYmplY3R9XG4gICAqICAgICAgICAgVGhlIGN1cnJlbnQgc291cmNlIG9iamVjdCBmcm9tIHRoZSBIVE1MNSB0ZWNoLiBXaXRoIGEgZmFsbGJhY2sgdG8gdGhlXG4gICAqICAgICAgICAgZWxlbWVudHMgc291cmNlLlxuICAgKi9cblxuXG4gIEh0bWw1LnByb3RvdHlwZS5jdXJyZW50U3JjID0gZnVuY3Rpb24gY3VycmVudFNyYygpIHtcbiAgICBpZiAodGhpcy5jdXJyZW50U291cmNlXykge1xuICAgICAgcmV0dXJuIHRoaXMuY3VycmVudFNvdXJjZV8uc3JjO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5lbF8uY3VycmVudFNyYztcbiAgfTtcblxuICAvKipcbiAgICogU2V0IGNvbnRyb2xzIGF0dHJpYnV0ZSBmb3IgdGhlIEhUTUw1IG1lZGlhIEVsZW1lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWxcbiAgICogICAgICAgIFZhbHVlIHRvIHNldCB0aGUgY29udHJvbHMgYXR0cmlidXRlIHRvXG4gICAqL1xuXG5cbiAgSHRtbDUucHJvdG90eXBlLnNldENvbnRyb2xzID0gZnVuY3Rpb24gc2V0Q29udHJvbHModmFsKSB7XG4gICAgdGhpcy5lbF8uY29udHJvbHMgPSAhIXZhbDtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlIGFuZCByZXR1cm5zIGEgcmVtb3RlIHtAbGluayBUZXh0VHJhY2t9IG9iamVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtpbmRcbiAgICogICAgICAgIGBUZXh0VHJhY2tgIGtpbmQgKHN1YnRpdGxlcywgY2FwdGlvbnMsIGRlc2NyaXB0aW9ucywgY2hhcHRlcnMsIG9yIG1ldGFkYXRhKVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2xhYmVsXVxuICAgKiAgICAgICAgTGFiZWwgdG8gaWRlbnRpZnkgdGhlIHRleHQgdHJhY2tcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtsYW5ndWFnZV1cbiAgICogICAgICAgIFR3byBsZXR0ZXIgbGFuZ3VhZ2UgYWJicmV2aWF0aW9uXG4gICAqXG4gICAqIEByZXR1cm4ge1RleHRUcmFja31cbiAgICogICAgICAgICBUaGUgVGV4dFRyYWNrIHRoYXQgZ2V0cyBjcmVhdGVkLlxuICAgKi9cblxuXG4gIEh0bWw1LnByb3RvdHlwZS5hZGRUZXh0VHJhY2sgPSBmdW5jdGlvbiBhZGRUZXh0VHJhY2soa2luZCwgbGFiZWwsIGxhbmd1YWdlKSB7XG4gICAgaWYgKCF0aGlzLmZlYXR1cmVzTmF0aXZlVGV4dFRyYWNrcykge1xuICAgICAgcmV0dXJuIF9UZWNoLnByb3RvdHlwZS5hZGRUZXh0VHJhY2suY2FsbCh0aGlzLCBraW5kLCBsYWJlbCwgbGFuZ3VhZ2UpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmVsXy5hZGRUZXh0VHJhY2soa2luZCwgbGFiZWwsIGxhbmd1YWdlKTtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBlaXRoZXIgbmF0aXZlIFRleHRUcmFjayBvciBhbiBlbXVsYXRlZCBUZXh0VHJhY2sgZGVwZW5kaW5nXG4gICAqIG9uIHRoZSB2YWx1ZSBvZiBgZmVhdHVyZXNOYXRpdmVUZXh0VHJhY2tzYFxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiAgICAgICAgVGhlIG9iamVjdCBzaG91bGQgY29udGFpbiB0aGUgb3B0aW9ucyB0byBpbnRpYWxpemUgdGhlIFRleHRUcmFjayB3aXRoLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMua2luZF1cbiAgICogICAgICAgIGBUZXh0VHJhY2tgIGtpbmQgKHN1YnRpdGxlcywgY2FwdGlvbnMsIGRlc2NyaXB0aW9ucywgY2hhcHRlcnMsIG9yIG1ldGFkYXRhKS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmxhYmVsXS5cbiAgICogICAgICAgIExhYmVsIHRvIGlkZW50aWZ5IHRoZSB0ZXh0IHRyYWNrXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5sYW5ndWFnZV1cbiAgICogICAgICAgIFR3byBsZXR0ZXIgbGFuZ3VhZ2UgYWJicmV2aWF0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmRlZmF1bHRdXG4gICAqICAgICAgICBEZWZhdWx0IHRoaXMgdHJhY2sgdG8gb24uXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5pZF1cbiAgICogICAgICAgIFRoZSBpbnRlcm5hbCBpZCB0byBhc3NpZ24gdGhpcyB0cmFjay5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnNyY11cbiAgICogICAgICAgIEEgc291cmNlIHVybCBmb3IgdGhlIHRyYWNrLlxuICAgKlxuICAgKiBAcmV0dXJuIHtIVE1MVHJhY2tFbGVtZW50fVxuICAgKiAgICAgICAgIFRoZSB0cmFjayBlbGVtZW50IHRoYXQgZ2V0cyBjcmVhdGVkLlxuICAgKi9cblxuXG4gIEh0bWw1LnByb3RvdHlwZS5jcmVhdGVSZW1vdGVUZXh0VHJhY2sgPSBmdW5jdGlvbiBjcmVhdGVSZW1vdGVUZXh0VHJhY2sob3B0aW9ucykge1xuICAgIGlmICghdGhpcy5mZWF0dXJlc05hdGl2ZVRleHRUcmFja3MpIHtcbiAgICAgIHJldHVybiBfVGVjaC5wcm90b3R5cGUuY3JlYXRlUmVtb3RlVGV4dFRyYWNrLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gICAgfVxuICAgIHZhciBodG1sVHJhY2tFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndHJhY2snKTtcblxuICAgIGlmIChvcHRpb25zLmtpbmQpIHtcbiAgICAgIGh0bWxUcmFja0VsZW1lbnQua2luZCA9IG9wdGlvbnMua2luZDtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMubGFiZWwpIHtcbiAgICAgIGh0bWxUcmFja0VsZW1lbnQubGFiZWwgPSBvcHRpb25zLmxhYmVsO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5sYW5ndWFnZSB8fCBvcHRpb25zLnNyY2xhbmcpIHtcbiAgICAgIGh0bWxUcmFja0VsZW1lbnQuc3JjbGFuZyA9IG9wdGlvbnMubGFuZ3VhZ2UgfHwgb3B0aW9ucy5zcmNsYW5nO1xuICAgIH1cbiAgICBpZiAob3B0aW9uc1snZGVmYXVsdCddKSB7XG4gICAgICBodG1sVHJhY2tFbGVtZW50WydkZWZhdWx0J10gPSBvcHRpb25zWydkZWZhdWx0J107XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmlkKSB7XG4gICAgICBodG1sVHJhY2tFbGVtZW50LmlkID0gb3B0aW9ucy5pZDtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuc3JjKSB7XG4gICAgICBodG1sVHJhY2tFbGVtZW50LnNyYyA9IG9wdGlvbnMuc3JjO1xuICAgIH1cblxuICAgIHJldHVybiBodG1sVHJhY2tFbGVtZW50O1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgcmVtb3RlIHRleHQgdHJhY2sgb2JqZWN0IGFuZCByZXR1cm5zIGFuIGh0bWwgdHJhY2sgZWxlbWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgVGhlIG9iamVjdCBzaG91bGQgY29udGFpbiB2YWx1ZXMgZm9yXG4gICAqIGtpbmQsIGxhbmd1YWdlLCBsYWJlbCwgYW5kIHNyYyAobG9jYXRpb24gb2YgdGhlIFdlYlZUVCBmaWxlKVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFttYW51YWxDbGVhbnVwPXRydWVdIGlmIHNldCB0byBmYWxzZSwgdGhlIFRleHRUcmFjayB3aWxsIGJlXG4gICAqIGF1dG9tYXRpY2FsbHkgcmVtb3ZlZCBmcm9tIHRoZSB2aWRlbyBlbGVtZW50IHdoZW5ldmVyIHRoZSBzb3VyY2UgY2hhbmdlc1xuICAgKiBAcmV0dXJuIHtIVE1MVHJhY2tFbGVtZW50fSBBbiBIdG1sIFRyYWNrIEVsZW1lbnQuXG4gICAqIFRoaXMgY2FuIGJlIGFuIGVtdWxhdGVkIHtAbGluayBIVE1MVHJhY2tFbGVtZW50fSBvciBhIG5hdGl2ZSBvbmUuXG4gICAqIEBkZXByZWNhdGVkIFRoZSBkZWZhdWx0IHZhbHVlIG9mIHRoZSBcIm1hbnVhbENsZWFudXBcIiBwYXJhbWV0ZXIgd2lsbCBkZWZhdWx0XG4gICAqIHRvIFwiZmFsc2VcIiBpbiB1cGNvbWluZyB2ZXJzaW9ucyBvZiBWaWRlby5qc1xuICAgKi9cblxuXG4gIEh0bWw1LnByb3RvdHlwZS5hZGRSZW1vdGVUZXh0VHJhY2sgPSBmdW5jdGlvbiBhZGRSZW1vdGVUZXh0VHJhY2sob3B0aW9ucywgbWFudWFsQ2xlYW51cCkge1xuICAgIHZhciBodG1sVHJhY2tFbGVtZW50ID0gX1RlY2gucHJvdG90eXBlLmFkZFJlbW90ZVRleHRUcmFjay5jYWxsKHRoaXMsIG9wdGlvbnMsIG1hbnVhbENsZWFudXApO1xuXG4gICAgaWYgKHRoaXMuZmVhdHVyZXNOYXRpdmVUZXh0VHJhY2tzKSB7XG4gICAgICB0aGlzLmVsKCkuYXBwZW5kQ2hpbGQoaHRtbFRyYWNrRWxlbWVudCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGh0bWxUcmFja0VsZW1lbnQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZSByZW1vdGUgYFRleHRUcmFja2AgZnJvbSBgVGV4dFRyYWNrTGlzdGAgb2JqZWN0XG4gICAqXG4gICAqIEBwYXJhbSB7VGV4dFRyYWNrfSB0cmFja1xuICAgKiAgICAgICAgYFRleHRUcmFja2Agb2JqZWN0IHRvIHJlbW92ZVxuICAgKi9cblxuXG4gIEh0bWw1LnByb3RvdHlwZS5yZW1vdmVSZW1vdGVUZXh0VHJhY2sgPSBmdW5jdGlvbiByZW1vdmVSZW1vdGVUZXh0VHJhY2sodHJhY2spIHtcbiAgICBfVGVjaC5wcm90b3R5cGUucmVtb3ZlUmVtb3RlVGV4dFRyYWNrLmNhbGwodGhpcywgdHJhY2spO1xuXG4gICAgaWYgKHRoaXMuZmVhdHVyZXNOYXRpdmVUZXh0VHJhY2tzKSB7XG4gICAgICB2YXIgdHJhY2tzID0gdGhpcy4kJCgndHJhY2snKTtcblxuICAgICAgdmFyIGkgPSB0cmFja3MubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIGlmICh0cmFjayA9PT0gdHJhY2tzW2ldIHx8IHRyYWNrID09PSB0cmFja3NbaV0udHJhY2spIHtcbiAgICAgICAgICB0aGlzLmVsKCkucmVtb3ZlQ2hpbGQodHJhY2tzW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogR2V0cyBhdmFpbGFibGUgbWVkaWEgcGxheWJhY2sgcXVhbGl0eSBtZXRyaWNzIGFzIHNwZWNpZmllZCBieSB0aGUgVzNDJ3MgTWVkaWFcbiAgICogUGxheWJhY2sgUXVhbGl0eSBBUEkuXG4gICAqXG4gICAqIEBzZWUgW1NwZWNde0BsaW5rIGh0dHBzOi8vd2ljZy5naXRodWIuaW8vbWVkaWEtcGxheWJhY2stcXVhbGl0eX1cbiAgICpcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKiAgICAgICAgIEFuIG9iamVjdCB3aXRoIHN1cHBvcnRlZCBtZWRpYSBwbGF5YmFjayBxdWFsaXR5IG1ldHJpY3NcbiAgICovXG5cblxuICBIdG1sNS5wcm90b3R5cGUuZ2V0VmlkZW9QbGF5YmFja1F1YWxpdHkgPSBmdW5jdGlvbiBnZXRWaWRlb1BsYXliYWNrUXVhbGl0eSgpIHtcbiAgICBpZiAodHlwZW9mIHRoaXMuZWwoKS5nZXRWaWRlb1BsYXliYWNrUXVhbGl0eSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIHRoaXMuZWwoKS5nZXRWaWRlb1BsYXliYWNrUXVhbGl0eSgpO1xuICAgIH1cblxuICAgIHZhciB2aWRlb1BsYXliYWNrUXVhbGl0eSA9IHt9O1xuXG4gICAgaWYgKHR5cGVvZiB0aGlzLmVsKCkud2Via2l0RHJvcHBlZEZyYW1lQ291bnQgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB0aGlzLmVsKCkud2Via2l0RGVjb2RlZEZyYW1lQ291bnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB2aWRlb1BsYXliYWNrUXVhbGl0eS5kcm9wcGVkVmlkZW9GcmFtZXMgPSB0aGlzLmVsKCkud2Via2l0RHJvcHBlZEZyYW1lQ291bnQ7XG4gICAgICB2aWRlb1BsYXliYWNrUXVhbGl0eS50b3RhbFZpZGVvRnJhbWVzID0gdGhpcy5lbCgpLndlYmtpdERlY29kZWRGcmFtZUNvdW50O1xuICAgIH1cblxuICAgIGlmICh3aW5kb3cucGVyZm9ybWFuY2UgJiYgdHlwZW9mIHdpbmRvdy5wZXJmb3JtYW5jZS5ub3cgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHZpZGVvUGxheWJhY2tRdWFsaXR5LmNyZWF0aW9uVGltZSA9IHdpbmRvdy5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICB9IGVsc2UgaWYgKHdpbmRvdy5wZXJmb3JtYW5jZSAmJiB3aW5kb3cucGVyZm9ybWFuY2UudGltaW5nICYmIHR5cGVvZiB3aW5kb3cucGVyZm9ybWFuY2UudGltaW5nLm5hdmlnYXRpb25TdGFydCA9PT0gJ251bWJlcicpIHtcbiAgICAgIHZpZGVvUGxheWJhY2tRdWFsaXR5LmNyZWF0aW9uVGltZSA9IHdpbmRvdy5EYXRlLm5vdygpIC0gd2luZG93LnBlcmZvcm1hbmNlLnRpbWluZy5uYXZpZ2F0aW9uU3RhcnQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZpZGVvUGxheWJhY2tRdWFsaXR5O1xuICB9O1xuXG4gIHJldHVybiBIdG1sNTtcbn0oVGVjaCk7XG5cbi8qIEhUTUw1IFN1cHBvcnQgVGVzdGluZyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cbmlmIChpc1JlYWwoKSkge1xuXG4gIC8qKlxuICAgKiBFbGVtZW50IGZvciB0ZXN0aW5nIGJyb3dzZXIgSFRNTDUgbWVkaWEgY2FwYWJpbGl0aWVzXG4gICAqXG4gICAqIEB0eXBlIHtFbGVtZW50fVxuICAgKiBAY29uc3RhbnRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIEh0bWw1LlRFU1RfVklEID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndmlkZW8nKTtcbiAgdmFyIHRyYWNrID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndHJhY2snKTtcblxuICB0cmFjay5raW5kID0gJ2NhcHRpb25zJztcbiAgdHJhY2suc3JjbGFuZyA9ICdlbic7XG4gIHRyYWNrLmxhYmVsID0gJ0VuZ2xpc2gnO1xuICBIdG1sNS5URVNUX1ZJRC5hcHBlbmRDaGlsZCh0cmFjayk7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgSFRNTDUgbWVkaWEgaXMgc3VwcG9ydGVkIGJ5IHRoaXMgYnJvd3Nlci9kZXZpY2UuXG4gKlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqICAgICAgICAgLSBUcnVlIGlmIEhUTUw1IG1lZGlhIGlzIHN1cHBvcnRlZC5cbiAqICAgICAgICAgLSBGYWxzZSBpZiBIVE1MNSBtZWRpYSBpcyBub3Qgc3VwcG9ydGVkLlxuICovXG5IdG1sNS5pc1N1cHBvcnRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gSUU5IHdpdGggbm8gTWVkaWEgUGxheWVyIGlzIGEgTElBUiEgKCM5ODQpXG4gIHRyeSB7XG4gICAgSHRtbDUuVEVTVF9WSUQudm9sdW1lID0gMC41O1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuICEhKEh0bWw1LlRFU1RfVklEICYmIEh0bWw1LlRFU1RfVklELmNhblBsYXlUeXBlKTtcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIHRlY2ggY2FuIHN1cHBvcnQgdGhlIGdpdmVuIHR5cGVcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICogICAgICAgIFRoZSBtaW1ldHlwZSB0byBjaGVja1xuICogQHJldHVybiB7c3RyaW5nfSAncHJvYmFibHknLCAnbWF5YmUnLCBvciAnJyAoZW1wdHkgc3RyaW5nKVxuICovXG5IdG1sNS5jYW5QbGF5VHlwZSA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gIHJldHVybiBIdG1sNS5URVNUX1ZJRC5jYW5QbGF5VHlwZSh0eXBlKTtcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIHRlY2ggY2FuIHN1cHBvcnQgdGhlIGdpdmVuIHNvdXJjZVxuICogQHBhcmFtIHtPYmplY3R9IHNyY09ialxuICogICAgICAgIFRoZSBzb3VyY2Ugb2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogICAgICAgIFRoZSBvcHRpb25zIHBhc3NlZCB0byB0aGUgdGVjaFxuICogQHJldHVybiB7c3RyaW5nfSAncHJvYmFibHknLCAnbWF5YmUnLCBvciAnJyAoZW1wdHkgc3RyaW5nKVxuICovXG5IdG1sNS5jYW5QbGF5U291cmNlID0gZnVuY3Rpb24gKHNyY09iaiwgb3B0aW9ucykge1xuICByZXR1cm4gSHRtbDUuY2FuUGxheVR5cGUoc3JjT2JqLnR5cGUpO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgdm9sdW1lIGNhbiBiZSBjaGFuZ2VkIGluIHRoaXMgYnJvd3Nlci9kZXZpY2UuXG4gKiBWb2x1bWUgY2Fubm90IGJlIGNoYW5nZWQgaW4gYSBsb3Qgb2YgbW9iaWxlIGRldmljZXMuXG4gKiBTcGVjaWZpY2FsbHksIGl0IGNhbid0IGJlIGNoYW5nZWQgZnJvbSAxIG9uIGlPUy5cbiAqXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICogICAgICAgICAtIFRydWUgaWYgdm9sdW1lIGNhbiBiZSBjb250cm9sbGVkXG4gKiAgICAgICAgIC0gRmFsc2Ugb3RoZXJ3aXNlXG4gKi9cbkh0bWw1LmNhbkNvbnRyb2xWb2x1bWUgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIElFIHdpbGwgZXJyb3IgaWYgV2luZG93cyBNZWRpYSBQbGF5ZXIgbm90IGluc3RhbGxlZCAjMzMxNVxuICB0cnkge1xuICAgIHZhciB2b2x1bWUgPSBIdG1sNS5URVNUX1ZJRC52b2x1bWU7XG5cbiAgICBIdG1sNS5URVNUX1ZJRC52b2x1bWUgPSB2b2x1bWUgLyAyICsgMC4xO1xuICAgIHJldHVybiB2b2x1bWUgIT09IEh0bWw1LlRFU1RfVklELnZvbHVtZTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgdm9sdW1lIGNhbiBiZSBtdXRlZCBpbiB0aGlzIGJyb3dzZXIvZGV2aWNlLlxuICogU29tZSBkZXZpY2VzLCBlLmcuIGlPUywgZG9uJ3QgYWxsb3cgY2hhbmdpbmcgdm9sdW1lXG4gKiBidXQgcGVybWl0cyBtdXRpbmcvdW5tdXRpbmcuXG4gKlxuICogQHJldHVybiB7Ym9sZWFufVxuICogICAgICAtIFRydWUgaWYgdm9sdW1lIGNhbiBiZSBtdXRlZFxuICogICAgICAtIEZhbHNlIG90aGVyd2lzZVxuICovXG5IdG1sNS5jYW5NdXRlVm9sdW1lID0gZnVuY3Rpb24gKCkge1xuICB0cnkge1xuICAgIHZhciBtdXRlZCA9IEh0bWw1LlRFU1RfVklELm11dGVkO1xuXG4gICAgLy8gaW4gc29tZSB2ZXJzaW9ucyBvZiBpT1MgbXV0ZWQgcHJvcGVydHkgZG9lc24ndCBhbHdheXNcbiAgICAvLyB3b3JrLCBzbyB3ZSB3YW50IHRvIHNldCBib3RoIHByb3BlcnR5IGFuZCBhdHRyaWJ1dGVcbiAgICBIdG1sNS5URVNUX1ZJRC5tdXRlZCA9ICFtdXRlZDtcbiAgICBpZiAoSHRtbDUuVEVTVF9WSUQubXV0ZWQpIHtcbiAgICAgIHNldEF0dHJpYnV0ZShIdG1sNS5URVNUX1ZJRCwgJ211dGVkJywgJ211dGVkJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlbW92ZUF0dHJpYnV0ZShIdG1sNS5URVNUX1ZJRCwgJ211dGVkJywgJ211dGVkJyk7XG4gICAgfVxuICAgIHJldHVybiBtdXRlZCAhPT0gSHRtbDUuVEVTVF9WSUQubXV0ZWQ7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIHBsYXliYWNrIHJhdGUgY2FuIGJlIGNoYW5nZWQgaW4gdGhpcyBicm93c2VyL2RldmljZS5cbiAqXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICogICAgICAgICAtIFRydWUgaWYgcGxheWJhY2sgcmF0ZSBjYW4gYmUgY29udHJvbGxlZFxuICogICAgICAgICAtIEZhbHNlIG90aGVyd2lzZVxuICovXG5IdG1sNS5jYW5Db250cm9sUGxheWJhY2tSYXRlID0gZnVuY3Rpb24gKCkge1xuICAvLyBQbGF5YmFjayByYXRlIEFQSSBpcyBpbXBsZW1lbnRlZCBpbiBBbmRyb2lkIENocm9tZSwgYnV0IGRvZXNuJ3QgZG8gYW55dGhpbmdcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3ZpZGVvanMvdmlkZW8uanMvaXNzdWVzLzMxODBcbiAgaWYgKElTX0FORFJPSUQgJiYgSVNfQ0hST01FICYmIENIUk9NRV9WRVJTSU9OIDwgNTgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gSUUgd2lsbCBlcnJvciBpZiBXaW5kb3dzIE1lZGlhIFBsYXllciBub3QgaW5zdGFsbGVkICMzMzE1XG4gIHRyeSB7XG4gICAgdmFyIHBsYXliYWNrUmF0ZSA9IEh0bWw1LlRFU1RfVklELnBsYXliYWNrUmF0ZTtcblxuICAgIEh0bWw1LlRFU1RfVklELnBsYXliYWNrUmF0ZSA9IHBsYXliYWNrUmF0ZSAvIDIgKyAwLjE7XG4gICAgcmV0dXJuIHBsYXliYWNrUmF0ZSAhPT0gSHRtbDUuVEVTVF9WSUQucGxheWJhY2tSYXRlO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIHdlIGNhbiBvdmVycmlkZSBhIHZpZGVvL2F1ZGlvIGVsZW1lbnRzIGF0dHJpYnV0ZXMsIHdpdGhcbiAqIE9iamVjdC5kZWZpbmVQcm9wZXJ0eS5cbiAqXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICogICAgICAgICAtIFRydWUgaWYgYnVpbHRpbiBhdHRyaWJ1dGVzIGNhbiBiZSBvdmVycmlkZW5cbiAqICAgICAgICAgLSBGYWxzZSBvdGhlcndpc2VcbiAqL1xuSHRtbDUuY2FuT3ZlcnJpZGVBdHRyaWJ1dGVzID0gZnVuY3Rpb24gKCkge1xuICBpZiAoSVNfSUU4KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIGlmIHdlIGNhbm5vdCBvdmVyd3JpdGUgdGhlIHNyYy9pbm5lckhUTUwgcHJvcGVydHksIHRoZXJlIGlzIG5vIHN1cHBvcnRcbiAgLy8gaU9TIDcgc2FmYXJpIGZvciBpbnN0YW5jZSBjYW5ub3QgZG8gdGhpcy5cbiAgdHJ5IHtcbiAgICB2YXIgbm9vcCA9IGZ1bmN0aW9uIG5vb3AoKSB7fTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd2aWRlbycpLCAnc3JjJywgeyBnZXQ6IG5vb3AsIHNldDogbm9vcCB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYXVkaW8nKSwgJ3NyYycsIHsgZ2V0OiBub29wLCBzZXQ6IG5vb3AgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3ZpZGVvJyksICdpbm5lckhUTUwnLCB7IGdldDogbm9vcCwgc2V0OiBub29wIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhdWRpbycpLCAnaW5uZXJIVE1MJywgeyBnZXQ6IG5vb3AsIHNldDogbm9vcCB9KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuLyoqXG4gKiBDaGVjayB0byBzZWUgaWYgbmF0aXZlIGBUZXh0VHJhY2tgcyBhcmUgc3VwcG9ydGVkIGJ5IHRoaXMgYnJvd3Nlci9kZXZpY2UuXG4gKlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqICAgICAgICAgLSBUcnVlIGlmIG5hdGl2ZSBgVGV4dFRyYWNrYHMgYXJlIHN1cHBvcnRlZC5cbiAqICAgICAgICAgLSBGYWxzZSBvdGhlcndpc2VcbiAqL1xuSHRtbDUuc3VwcG9ydHNOYXRpdmVUZXh0VHJhY2tzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gSVNfQU5ZX1NBRkFSSSB8fCBJU19JT1MgJiYgSVNfQ0hST01FO1xufTtcblxuLyoqXG4gKiBDaGVjayB0byBzZWUgaWYgbmF0aXZlIGBWaWRlb1RyYWNrYHMgYXJlIHN1cHBvcnRlZCBieSB0aGlzIGJyb3dzZXIvZGV2aWNlXG4gKlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqICAgICAgICAtIFRydWUgaWYgbmF0aXZlIGBWaWRlb1RyYWNrYHMgYXJlIHN1cHBvcnRlZC5cbiAqICAgICAgICAtIEZhbHNlIG90aGVyd2lzZVxuICovXG5IdG1sNS5zdXBwb3J0c05hdGl2ZVZpZGVvVHJhY2tzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gISEoSHRtbDUuVEVTVF9WSUQgJiYgSHRtbDUuVEVTVF9WSUQudmlkZW9UcmFja3MpO1xufTtcblxuLyoqXG4gKiBDaGVjayB0byBzZWUgaWYgbmF0aXZlIGBBdWRpb1RyYWNrYHMgYXJlIHN1cHBvcnRlZCBieSB0aGlzIGJyb3dzZXIvZGV2aWNlXG4gKlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqICAgICAgICAtIFRydWUgaWYgbmF0aXZlIGBBdWRpb1RyYWNrYHMgYXJlIHN1cHBvcnRlZC5cbiAqICAgICAgICAtIEZhbHNlIG90aGVyd2lzZVxuICovXG5IdG1sNS5zdXBwb3J0c05hdGl2ZUF1ZGlvVHJhY2tzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gISEoSHRtbDUuVEVTVF9WSUQgJiYgSHRtbDUuVEVTVF9WSUQuYXVkaW9UcmFja3MpO1xufTtcblxuLyoqXG4gKiBBbiBhcnJheSBvZiBldmVudHMgYXZhaWxhYmxlIG9uIHRoZSBIdG1sNSB0ZWNoLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAdHlwZSB7QXJyYXl9XG4gKi9cbkh0bWw1LkV2ZW50cyA9IFsnbG9hZHN0YXJ0JywgJ3N1c3BlbmQnLCAnYWJvcnQnLCAnZXJyb3InLCAnZW1wdGllZCcsICdzdGFsbGVkJywgJ2xvYWRlZG1ldGFkYXRhJywgJ2xvYWRlZGRhdGEnLCAnY2FucGxheScsICdjYW5wbGF5dGhyb3VnaCcsICdwbGF5aW5nJywgJ3dhaXRpbmcnLCAnc2Vla2luZycsICdzZWVrZWQnLCAnZW5kZWQnLCAnZHVyYXRpb25jaGFuZ2UnLCAndGltZXVwZGF0ZScsICdwcm9ncmVzcycsICdwbGF5JywgJ3BhdXNlJywgJ3JhdGVjaGFuZ2UnLCAncmVzaXplJywgJ3ZvbHVtZWNoYW5nZSddO1xuXG4vKipcbiAqIEJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBgVGVjaGAgc3VwcG9ydHMgdm9sdW1lIGNvbnRyb2wuXG4gKlxuICogQHR5cGUge2Jvb2xlYW59XG4gKiBAZGVmYXVsdCB7QGxpbmsgSHRtbDUuY2FuQ29udHJvbFZvbHVtZX1cbiAqL1xuSHRtbDUucHJvdG90eXBlLmZlYXR1cmVzVm9sdW1lQ29udHJvbCA9IEh0bWw1LmNhbkNvbnRyb2xWb2x1bWUoKTtcblxuLyoqXG4gKiBCb29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0aGUgYFRlY2hgIHN1cHBvcnRzIG11dGluZyB2b2x1bWUuXG4gKlxuICogQHR5cGUge2JvbGVhbn1cbiAqIEBkZWZhdWx0IHtAbGluayBIdG1sNS5jYW5NdXRlVm9sdW1lfVxuICovXG5IdG1sNS5wcm90b3R5cGUuZmVhdHVyZXNNdXRlQ29udHJvbCA9IEh0bWw1LmNhbk11dGVWb2x1bWUoKTtcblxuLyoqXG4gKiBCb29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0aGUgYFRlY2hgIHN1cHBvcnRzIGNoYW5naW5nIHRoZSBzcGVlZCBhdCB3aGljaCB0aGUgbWVkaWFcbiAqIHBsYXlzLiBFeGFtcGxlczpcbiAqICAgLSBTZXQgcGxheWVyIHRvIHBsYXkgMnggKHR3aWNlKSBhcyBmYXN0XG4gKiAgIC0gU2V0IHBsYXllciB0byBwbGF5IDAuNXggKGhhbGYpIGFzIGZhc3RcbiAqXG4gKiBAdHlwZSB7Ym9vbGVhbn1cbiAqIEBkZWZhdWx0IHtAbGluayBIdG1sNS5jYW5Db250cm9sUGxheWJhY2tSYXRlfVxuICovXG5IdG1sNS5wcm90b3R5cGUuZmVhdHVyZXNQbGF5YmFja1JhdGUgPSBIdG1sNS5jYW5Db250cm9sUGxheWJhY2tSYXRlKCk7XG5cbi8qKlxuICogQm9vbGVhbiBpbmRpY2F0aW5nIHdldGhlciB0aGUgYFRlY2hgIHN1cHBvcnRzIHRoZSBgc291cmNlc2V0YCBldmVudC5cbiAqXG4gKiBAdHlwZSB7Ym9vbGVhbn1cbiAqIEBkZWZhdWx0XG4gKi9cbkh0bWw1LnByb3RvdHlwZS5mZWF0dXJlc1NvdXJjZXNldCA9IEh0bWw1LmNhbk92ZXJyaWRlQXR0cmlidXRlcygpO1xuXG4vKipcbiAqIEJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBgSFRNTDVgIHRlY2ggY3VycmVudGx5IHN1cHBvcnRzIHRoZSBtZWRpYSBlbGVtZW50XG4gKiBtb3ZpbmcgaW4gdGhlIERPTS4gaU9TIGJyZWFrcyBpZiB5b3UgbW92ZSB0aGUgbWVkaWEgZWxlbWVudCwgc28gdGhpcyBpcyBzZXQgdGhpcyB0b1xuICogZmFsc2UgdGhlcmUuIEV2ZXJ5d2hlcmUgZWxzZSB0aGlzIHNob3VsZCBiZSB0cnVlLlxuICpcbiAqIEB0eXBlIHtib29sZWFufVxuICogQGRlZmF1bHRcbiAqL1xuSHRtbDUucHJvdG90eXBlLm1vdmluZ01lZGlhRWxlbWVudEluRE9NID0gIUlTX0lPUztcblxuLy8gVE9ETzogUHJldmlvdXMgY29tbWVudDogTm8gbG9uZ2VyIGFwcGVhcnMgdG8gYmUgdXNlZC4gQ2FuIHByb2JhYmx5IGJlIHJlbW92ZWQuXG4vLyAgICAgICBJcyB0aGlzIHRydWU/XG4vKipcbiAqIEJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBgSFRNTDVgIHRlY2ggY3VycmVudGx5IHN1cHBvcnRzIGF1dG9tYXRpYyBtZWRpYSByZXNpemVcbiAqIHdoZW4gZ29pbmcgaW50byBmdWxsc2NyZWVuLlxuICpcbiAqIEB0eXBlIHtib29sZWFufVxuICogQGRlZmF1bHRcbiAqL1xuSHRtbDUucHJvdG90eXBlLmZlYXR1cmVzRnVsbHNjcmVlblJlc2l6ZSA9IHRydWU7XG5cbi8qKlxuICogQm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIGBIVE1MNWAgdGVjaCBjdXJyZW50bHkgc3VwcG9ydHMgdGhlIHByb2dyZXNzIGV2ZW50LlxuICogSWYgdGhpcyBpcyBmYWxzZSwgbWFudWFsIGBwcm9ncmVzc2AgZXZlbnRzIHdpbGwgYmUgdHJpZ2dyZWQgaW5zdGVhZC5cbiAqXG4gKiBAdHlwZSB7Ym9vbGVhbn1cbiAqIEBkZWZhdWx0XG4gKi9cbkh0bWw1LnByb3RvdHlwZS5mZWF0dXJlc1Byb2dyZXNzRXZlbnRzID0gdHJ1ZTtcblxuLyoqXG4gKiBCb29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0aGUgYEhUTUw1YCB0ZWNoIGN1cnJlbnRseSBzdXBwb3J0cyB0aGUgdGltZXVwZGF0ZSBldmVudC5cbiAqIElmIHRoaXMgaXMgZmFsc2UsIG1hbnVhbCBgdGltZXVwZGF0ZWAgZXZlbnRzIHdpbGwgYmUgdHJpZ2dyZWQgaW5zdGVhZC5cbiAqXG4gKiBAZGVmYXVsdFxuICovXG5IdG1sNS5wcm90b3R5cGUuZmVhdHVyZXNUaW1ldXBkYXRlRXZlbnRzID0gdHJ1ZTtcblxuLyoqXG4gKiBCb29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0aGUgYEhUTUw1YCB0ZWNoIGN1cnJlbnRseSBzdXBwb3J0cyBuYXRpdmUgYFRleHRUcmFja2BzLlxuICpcbiAqIEB0eXBlIHtib29sZWFufVxuICogQGRlZmF1bHQge0BsaW5rIEh0bWw1LnN1cHBvcnRzTmF0aXZlVGV4dFRyYWNrc31cbiAqL1xuSHRtbDUucHJvdG90eXBlLmZlYXR1cmVzTmF0aXZlVGV4dFRyYWNrcyA9IEh0bWw1LnN1cHBvcnRzTmF0aXZlVGV4dFRyYWNrcygpO1xuXG4vKipcbiAqIEJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBgSFRNTDVgIHRlY2ggY3VycmVudGx5IHN1cHBvcnRzIG5hdGl2ZSBgVmlkZW9UcmFja2BzLlxuICpcbiAqIEB0eXBlIHtib29sZWFufVxuICogQGRlZmF1bHQge0BsaW5rIEh0bWw1LnN1cHBvcnRzTmF0aXZlVmlkZW9UcmFja3N9XG4gKi9cbkh0bWw1LnByb3RvdHlwZS5mZWF0dXJlc05hdGl2ZVZpZGVvVHJhY2tzID0gSHRtbDUuc3VwcG9ydHNOYXRpdmVWaWRlb1RyYWNrcygpO1xuXG4vKipcbiAqIEJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBgSFRNTDVgIHRlY2ggY3VycmVudGx5IHN1cHBvcnRzIG5hdGl2ZSBgQXVkaW9UcmFja2BzLlxuICpcbiAqIEB0eXBlIHtib29sZWFufVxuICogQGRlZmF1bHQge0BsaW5rIEh0bWw1LnN1cHBvcnRzTmF0aXZlQXVkaW9UcmFja3N9XG4gKi9cbkh0bWw1LnByb3RvdHlwZS5mZWF0dXJlc05hdGl2ZUF1ZGlvVHJhY2tzID0gSHRtbDUuc3VwcG9ydHNOYXRpdmVBdWRpb1RyYWNrcygpO1xuXG4vLyBIVE1MNSBGZWF0dXJlIGRldGVjdGlvbiBhbmQgRGV2aWNlIEZpeGVzIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvL1xudmFyIGNhblBsYXlUeXBlID0gSHRtbDUuVEVTVF9WSUQgJiYgSHRtbDUuVEVTVF9WSUQuY29uc3RydWN0b3IucHJvdG90eXBlLmNhblBsYXlUeXBlO1xudmFyIG1wZWd1cmxSRSA9IC9eYXBwbGljYXRpb25cXC8oPzp4LXx2bmRcXC5hcHBsZVxcLiltcGVndXJsL2k7XG52YXIgbXA0UkUgPSAvXnZpZGVvXFwvbXA0L2k7XG5cbkh0bWw1LnBhdGNoQ2FuUGxheVR5cGUgPSBmdW5jdGlvbiAoKSB7XG5cbiAgLy8gQW5kcm9pZCA0LjAgYW5kIGFib3ZlIGNhbiBwbGF5IEhMUyB0byBzb21lIGV4dGVudCBidXQgaXQgcmVwb3J0cyBiZWluZyB1bmFibGUgdG8gZG8gc29cbiAgLy8gRmlyZWZveCBhbmQgQ2hyb21lIHJlcG9ydCBjb3JyZWN0bHlcbiAgaWYgKEFORFJPSURfVkVSU0lPTiA+PSA0LjAgJiYgIUlTX0ZJUkVGT1ggJiYgIUlTX0NIUk9NRSkge1xuICAgIEh0bWw1LlRFU1RfVklELmNvbnN0cnVjdG9yLnByb3RvdHlwZS5jYW5QbGF5VHlwZSA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICBpZiAodHlwZSAmJiBtcGVndXJsUkUudGVzdCh0eXBlKSkge1xuICAgICAgICByZXR1cm4gJ21heWJlJztcbiAgICAgIH1cbiAgICAgIHJldHVybiBjYW5QbGF5VHlwZS5jYWxsKHRoaXMsIHR5cGUpO1xuICAgIH07XG5cbiAgICAvLyBPdmVycmlkZSBBbmRyb2lkIDIuMiBhbmQgbGVzcyBjYW5QbGF5VHlwZSBtZXRob2Qgd2hpY2ggaXMgYnJva2VuXG4gIH0gZWxzZSBpZiAoSVNfT0xEX0FORFJPSUQpIHtcbiAgICBIdG1sNS5URVNUX1ZJRC5jb25zdHJ1Y3Rvci5wcm90b3R5cGUuY2FuUGxheVR5cGUgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgaWYgKHR5cGUgJiYgbXA0UkUudGVzdCh0eXBlKSkge1xuICAgICAgICByZXR1cm4gJ21heWJlJztcbiAgICAgIH1cbiAgICAgIHJldHVybiBjYW5QbGF5VHlwZS5jYWxsKHRoaXMsIHR5cGUpO1xuICAgIH07XG4gIH1cbn07XG5cbkh0bWw1LnVucGF0Y2hDYW5QbGF5VHlwZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHIgPSBIdG1sNS5URVNUX1ZJRC5jb25zdHJ1Y3Rvci5wcm90b3R5cGUuY2FuUGxheVR5cGU7XG5cbiAgSHRtbDUuVEVTVF9WSUQuY29uc3RydWN0b3IucHJvdG90eXBlLmNhblBsYXlUeXBlID0gY2FuUGxheVR5cGU7XG4gIHJldHVybiByO1xufTtcblxuLy8gYnkgZGVmYXVsdCwgcGF0Y2ggdGhlIG1lZGlhIGVsZW1lbnRcbkh0bWw1LnBhdGNoQ2FuUGxheVR5cGUoKTtcblxuSHRtbDUuZGlzcG9zZU1lZGlhRWxlbWVudCA9IGZ1bmN0aW9uIChlbCkge1xuICBpZiAoIWVsKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGVsLnBhcmVudE5vZGUpIHtcbiAgICBlbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGVsKTtcbiAgfVxuXG4gIC8vIHJlbW92ZSBhbnkgY2hpbGQgdHJhY2sgb3Igc291cmNlIG5vZGVzIHRvIHByZXZlbnQgdGhlaXIgbG9hZGluZ1xuICB3aGlsZSAoZWwuaGFzQ2hpbGROb2RlcygpKSB7XG4gICAgZWwucmVtb3ZlQ2hpbGQoZWwuZmlyc3RDaGlsZCk7XG4gIH1cblxuICAvLyByZW1vdmUgYW55IHNyYyByZWZlcmVuY2UuIG5vdCBzZXR0aW5nIGBzcmM9JydgIGJlY2F1c2UgdGhhdCBjYXVzZXMgYSB3YXJuaW5nXG4gIC8vIGluIGZpcmVmb3hcbiAgZWwucmVtb3ZlQXR0cmlidXRlKCdzcmMnKTtcblxuICAvLyBmb3JjZSB0aGUgbWVkaWEgZWxlbWVudCB0byB1cGRhdGUgaXRzIGxvYWRpbmcgc3RhdGUgYnkgY2FsbGluZyBsb2FkKClcbiAgLy8gaG93ZXZlciBJRSBvbiBXaW5kb3dzIDdOIGhhcyBhIGJ1ZyB0aGF0IHRocm93cyBhbiBlcnJvciBzbyBuZWVkIGEgdHJ5L2NhdGNoICgjNzkzKVxuICBpZiAodHlwZW9mIGVsLmxvYWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyB3cmFwcGluZyBpbiBhbiBpaWZlIHNvIGl0J3Mgbm90IGRlb3B0aW1pemVkICgjMTA2MCNkaXNjdXNzaW9uX3IxMDMyNDQ3MylcbiAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgZWwubG9hZCgpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvLyBub3Qgc3VwcG9ydGVkXG4gICAgICB9XG4gICAgfSkoKTtcbiAgfVxufTtcblxuSHRtbDUucmVzZXRNZWRpYUVsZW1lbnQgPSBmdW5jdGlvbiAoZWwpIHtcbiAgaWYgKCFlbCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBzb3VyY2VzID0gZWwucXVlcnlTZWxlY3RvckFsbCgnc291cmNlJyk7XG4gIHZhciBpID0gc291cmNlcy5sZW5ndGg7XG5cbiAgd2hpbGUgKGktLSkge1xuICAgIGVsLnJlbW92ZUNoaWxkKHNvdXJjZXNbaV0pO1xuICB9XG5cbiAgLy8gcmVtb3ZlIGFueSBzcmMgcmVmZXJlbmNlLlxuICAvLyBub3Qgc2V0dGluZyBgc3JjPScnYCBiZWNhdXNlIHRoYXQgdGhyb3dzIGFuIGVycm9yXG4gIGVsLnJlbW92ZUF0dHJpYnV0ZSgnc3JjJyk7XG5cbiAgaWYgKHR5cGVvZiBlbC5sb2FkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gd3JhcHBpbmcgaW4gYW4gaWlmZSBzbyBpdCdzIG5vdCBkZW9wdGltaXplZCAoIzEwNjAjZGlzY3Vzc2lvbl9yMTAzMjQ0NzMpXG4gICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGVsLmxvYWQoKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gc2F0aXNmeSBsaW50ZXJcbiAgICAgIH1cbiAgICB9KSgpO1xuICB9XG59O1xuXG4vKiBOYXRpdmUgSFRNTDUgZWxlbWVudCBwcm9wZXJ0eSB3cmFwcGluZyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuLy8gV3JhcCBuYXRpdmUgYm9vbGVhbiBhdHRyaWJ1dGVzIHdpdGggZ2V0dGVycyB0aGF0IGNoZWNrIGJvdGggcHJvcGVydHkgYW5kIGF0dHJpYnV0ZVxuLy8gVGhlIGxpc3QgaXMgYXMgZm9sbG93ZWQ6XG4vLyBtdXRlZCwgZGVmYXVsdE11dGVkLCBhdXRvcGxheSwgY29udHJvbHMsIGxvb3AsIHBsYXlzaW5saW5lXG5bXG4vKipcbiAqIEdldCB0aGUgdmFsdWUgb2YgYG11dGVkYCBmcm9tIHRoZSBtZWRpYSBlbGVtZW50LiBgbXV0ZWRgIGluZGljYXRlc1xuICogdGhhdCB0aGUgdm9sdW1lIGZvciB0aGUgbWVkaWEgc2hvdWxkIGJlIHNldCB0byBzaWxlbnQuIFRoaXMgZG9lcyBub3QgYWN0dWFsbHkgY2hhbmdlXG4gKiB0aGUgYHZvbHVtZWAgYXR0cmlidXRlLlxuICpcbiAqIEBtZXRob2QgSHRtbDUjbXV0ZWRcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKiAgICAgICAgIC0gVHJ1ZSBpZiB0aGUgdmFsdWUgb2YgYHZvbHVtZWAgc2hvdWxkIGJlIGlnbm9yZWQgYW5kIHRoZSBhdWRpbyBzZXQgdG8gc2lsZW50LlxuICogICAgICAgICAtIEZhbHNlIGlmIHRoZSB2YWx1ZSBvZiBgdm9sdW1lYCBzaG91bGQgYmUgdXNlZC5cbiAqXG4gKiBAc2VlIFtTcGVjXXtAbGluayBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUvZW1iZWRkZWQtY29udGVudC0wLmh0bWwjZG9tLW1lZGlhLW11dGVkfVxuICovXG4nbXV0ZWQnLFxuXG4vKipcbiAqIEdldCB0aGUgdmFsdWUgb2YgYGRlZmF1bHRNdXRlZGAgZnJvbSB0aGUgbWVkaWEgZWxlbWVudC4gYGRlZmF1bHRNdXRlZGAgaW5kaWNhdGVzXG4gKiB3aGV0aGVyIHRoZSBtZWRpYSBzaG91bGQgc3RhcnQgbXV0ZWQgb3Igbm90LiBPbmx5IGNoYW5nZXMgdGhlIGRlZmF1bHQgc3RhdGUgb2YgdGhlXG4gKiBtZWRpYS4gYG11dGVkYCBhbmQgYGRlZmF1bHRNdXRlZGAgY2FuIGhhdmUgZGlmZmVyZW50IHZhbHVlcy4ge0BsaW5rIEh0bWw1I211dGVkfSBpbmRpY2F0ZXMgdGhlXG4gKiBjdXJyZW50IHN0YXRlLlxuICpcbiAqIEBtZXRob2QgSHRtbDUjZGVmYXVsdE11dGVkXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICogICAgICAgICAtIFRoZSB2YWx1ZSBvZiBgZGVmYXVsdE11dGVkYCBmcm9tIHRoZSBtZWRpYSBlbGVtZW50LlxuICogICAgICAgICAtIFRydWUgaW5kaWNhdGVzIHRoYXQgdGhlIG1lZGlhIHNob3VsZCBzdGFydCBtdXRlZC5cbiAqICAgICAgICAgLSBGYWxzZSBpbmRpY2F0ZXMgdGhhdCB0aGUgbWVkaWEgc2hvdWxkIG5vdCBzdGFydCBtdXRlZFxuICpcbiAqIEBzZWUgW1NwZWNde0BsaW5rIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNS9lbWJlZGRlZC1jb250ZW50LTAuaHRtbCNkb20tbWVkaWEtZGVmYXVsdG11dGVkfVxuICovXG4nZGVmYXVsdE11dGVkJyxcblxuLyoqXG4gKiBHZXQgdGhlIHZhbHVlIG9mIGBhdXRvcGxheWAgZnJvbSB0aGUgbWVkaWEgZWxlbWVudC4gYGF1dG9wbGF5YCBpbmRpY2F0ZXNcbiAqIHRoYXQgdGhlIG1lZGlhIHNob3VsZCBzdGFydCB0byBwbGF5IGFzIHNvb24gYXMgdGhlIHBhZ2UgaXMgcmVhZHkuXG4gKlxuICogQG1ldGhvZCBIdG1sNSNhdXRvcGxheVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqICAgICAgICAgLSBUaGUgdmFsdWUgb2YgYGF1dG9wbGF5YCBmcm9tIHRoZSBtZWRpYSBlbGVtZW50LlxuICogICAgICAgICAtIFRydWUgaW5kaWNhdGVzIHRoYXQgdGhlIG1lZGlhIHNob3VsZCBzdGFydCBhcyBzb29uIGFzIHRoZSBwYWdlIGxvYWRzLlxuICogICAgICAgICAtIEZhbHNlIGluZGljYXRlcyB0aGF0IHRoZSBtZWRpYSBzaG91bGQgbm90IHN0YXJ0IGFzIHNvb24gYXMgdGhlIHBhZ2UgbG9hZHMuXG4gKlxuICogQHNlZSBbU3BlY117QGxpbmsgaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1L2VtYmVkZGVkLWNvbnRlbnQtMC5odG1sI2F0dHItbWVkaWEtYXV0b3BsYXl9XG4gKi9cbidhdXRvcGxheScsXG5cbi8qKlxuICogR2V0IHRoZSB2YWx1ZSBvZiBgY29udHJvbHNgIGZyb20gdGhlIG1lZGlhIGVsZW1lbnQuIGBjb250cm9sc2AgaW5kaWNhdGVzXG4gKiB3aGV0aGVyIHRoZSBuYXRpdmUgbWVkaWEgY29udHJvbHMgc2hvdWxkIGJlIHNob3duIG9yIGhpZGRlbi5cbiAqXG4gKiBAbWV0aG9kIEh0bWw1I2NvbnRyb2xzXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICogICAgICAgICAtIFRoZSB2YWx1ZSBvZiBgY29udHJvbHNgIGZyb20gdGhlIG1lZGlhIGVsZW1lbnQuXG4gKiAgICAgICAgIC0gVHJ1ZSBpbmRpY2F0ZXMgdGhhdCBuYXRpdmUgY29udHJvbHMgc2hvdWxkIGJlIHNob3dpbmcuXG4gKiAgICAgICAgIC0gRmFsc2UgaW5kaWNhdGVzIHRoYXQgbmF0aXZlIGNvbnRyb2xzIHNob3VsZCBiZSBoaWRkZW4uXG4gKlxuICogQHNlZSBbU3BlY117QGxpbmsgaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1L2VtYmVkZGVkLWNvbnRlbnQtMC5odG1sI2F0dHItbWVkaWEtY29udHJvbHN9XG4gKi9cbidjb250cm9scycsXG5cbi8qKlxuICogR2V0IHRoZSB2YWx1ZSBvZiBgbG9vcGAgZnJvbSB0aGUgbWVkaWEgZWxlbWVudC4gYGxvb3BgIGluZGljYXRlc1xuICogdGhhdCB0aGUgbWVkaWEgc2hvdWxkIHJldHVybiB0byB0aGUgc3RhcnQgb2YgdGhlIG1lZGlhIGFuZCBjb250aW51ZSBwbGF5aW5nIG9uY2VcbiAqIGl0IHJlYWNoZXMgdGhlIGVuZC5cbiAqXG4gKiBAbWV0aG9kIEh0bWw1I2xvb3BcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKiAgICAgICAgIC0gVGhlIHZhbHVlIG9mIGBsb29wYCBmcm9tIHRoZSBtZWRpYSBlbGVtZW50LlxuICogICAgICAgICAtIFRydWUgaW5kaWNhdGVzIHRoYXQgcGxheWJhY2sgc2hvdWxkIHNlZWsgYmFjayB0byBzdGFydCBvbmNlXG4gKiAgICAgICAgICAgdGhlIGVuZCBvZiBhIG1lZGlhIGlzIHJlYWNoZWQuXG4gKiAgICAgICAgIC0gRmFsc2UgaW5kaWNhdGVzIHRoYXQgcGxheWJhY2sgc2hvdWxkIG5vdCBsb29wIGJhY2sgdG8gdGhlIHN0YXJ0IHdoZW4gdGhlXG4gKiAgICAgICAgICAgZW5kIG9mIHRoZSBtZWRpYSBpcyByZWFjaGVkLlxuICpcbiAqIEBzZWUgW1NwZWNde0BsaW5rIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNS9lbWJlZGRlZC1jb250ZW50LTAuaHRtbCNhdHRyLW1lZGlhLWxvb3B9XG4gKi9cbidsb29wJyxcblxuLyoqXG4gKiBHZXQgdGhlIHZhbHVlIG9mIGBwbGF5c2lubGluZWAgZnJvbSB0aGUgbWVkaWEgZWxlbWVudC4gYHBsYXlzaW5saW5lYCBpbmRpY2F0ZXNcbiAqIHRvIHRoZSBicm93c2VyIHRoYXQgbm9uLWZ1bGxzY3JlZW4gcGxheWJhY2sgaXMgcHJlZmVycmVkIHdoZW4gZnVsbHNjcmVlblxuICogcGxheWJhY2sgaXMgdGhlIG5hdGl2ZSBkZWZhdWx0LCBzdWNoIGFzIGluIGlPUyBTYWZhcmkuXG4gKlxuICogQG1ldGhvZCBIdG1sNSNwbGF5c2lubGluZVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqICAgICAgICAgLSBUaGUgdmFsdWUgb2YgYHBsYXlzaW5saW5lYCBmcm9tIHRoZSBtZWRpYSBlbGVtZW50LlxuICogICAgICAgICAtIFRydWUgaW5kaWNhdGVzIHRoYXQgdGhlIG1lZGlhIHNob3VsZCBwbGF5IGlubGluZS5cbiAqICAgICAgICAgLSBGYWxzZSBpbmRpY2F0ZXMgdGhhdCB0aGUgbWVkaWEgc2hvdWxkIG5vdCBwbGF5IGlubGluZS5cbiAqXG4gKiBAc2VlIFtTcGVjXXtAbGluayBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnLyNhdHRyLXZpZGVvLXBsYXlzaW5saW5lfVxuICovXG4ncGxheXNpbmxpbmUnXS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gIEh0bWw1LnByb3RvdHlwZVtwcm9wXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5lbF9bcHJvcF0gfHwgdGhpcy5lbF8uaGFzQXR0cmlidXRlKHByb3ApO1xuICB9O1xufSk7XG5cbi8vIFdyYXAgbmF0aXZlIGJvb2xlYW4gYXR0cmlidXRlcyB3aXRoIHNldHRlcnMgdGhhdCBzZXQgYm90aCBwcm9wZXJ0eSBhbmQgYXR0cmlidXRlXG4vLyBUaGUgbGlzdCBpcyBhcyBmb2xsb3dlZDpcbi8vIHNldE11dGVkLCBzZXREZWZhdWx0TXV0ZWQsIHNldEF1dG9wbGF5LCBzZXRMb29wLCBzZXRQbGF5c2lubGluZVxuLy8gc2V0Q29udHJvbHMgaXMgc3BlY2lhbC1jYXNlZCBhYm92ZVxuW1xuLyoqXG4gKiBTZXQgdGhlIHZhbHVlIG9mIGBtdXRlZGAgb24gdGhlIG1lZGlhIGVsZW1lbnQuIGBtdXRlZGAgaW5kaWNhdGVzIHRoYXQgdGhlIGN1cnJlbnRcbiAqIGF1ZGlvIGxldmVsIHNob3VsZCBiZSBzaWxlbnQuXG4gKlxuICogQG1ldGhvZCBIdG1sNSNzZXRNdXRlZFxuICogQHBhcmFtIHtib29sZWFufSBtdXRlZFxuICogICAgICAgIC0gVHJ1ZSBpZiB0aGUgYXVkaW8gc2hvdWxkIGJlIHNldCB0byBzaWxlbnRcbiAqICAgICAgICAtIEZhbHNlIG90aGVyd2lzZVxuICpcbiAqIEBzZWUgW1NwZWNde0BsaW5rIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNS9lbWJlZGRlZC1jb250ZW50LTAuaHRtbCNkb20tbWVkaWEtbXV0ZWR9XG4gKi9cbidtdXRlZCcsXG5cbi8qKlxuICogU2V0IHRoZSB2YWx1ZSBvZiBgZGVmYXVsdE11dGVkYCBvbiB0aGUgbWVkaWEgZWxlbWVudC4gYGRlZmF1bHRNdXRlZGAgaW5kaWNhdGVzIHRoYXQgdGhlIGN1cnJlbnRcbiAqIGF1ZGlvIGxldmVsIHNob3VsZCBiZSBzaWxlbnQsIGJ1dCB3aWxsIG9ubHkgZWZmZWN0IHRoZSBtdXRlZCBsZXZlbCBvbiBpbnRpYWwgcGxheWJhY2suLlxuICpcbiAqIEBtZXRob2QgSHRtbDUucHJvdG90eXBlLnNldERlZmF1bHRNdXRlZFxuICogQHBhcmFtIHtib29sZWFufSBkZWZhdWx0TXV0ZWRcbiAqICAgICAgICAtIFRydWUgaWYgdGhlIGF1ZGlvIHNob3VsZCBiZSBzZXQgdG8gc2lsZW50XG4gKiAgICAgICAgLSBGYWxzZSBvdGhlcndpc2VcbiAqXG4gKiBAc2VlIFtTcGVjXXtAbGluayBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUvZW1iZWRkZWQtY29udGVudC0wLmh0bWwjZG9tLW1lZGlhLWRlZmF1bHRtdXRlZH1cbiAqL1xuJ2RlZmF1bHRNdXRlZCcsXG5cbi8qKlxuICogU2V0IHRoZSB2YWx1ZSBvZiBgYXV0b3BsYXlgIG9uIHRoZSBtZWRpYSBlbGVtZW50LiBgYXV0b3BsYXlgIGluZGljYXRlc1xuICogdGhhdCB0aGUgbWVkaWEgc2hvdWxkIHN0YXJ0IHRvIHBsYXkgYXMgc29vbiBhcyB0aGUgcGFnZSBpcyByZWFkeS5cbiAqXG4gKiBAbWV0aG9kIEh0bWw1I3NldEF1dG9wbGF5XG4gKiBAcGFyYW0ge2Jvb2xlYW59IGF1dG9wbGF5XG4gKiAgICAgICAgIC0gVHJ1ZSBpbmRpY2F0ZXMgdGhhdCB0aGUgbWVkaWEgc2hvdWxkIHN0YXJ0IGFzIHNvb24gYXMgdGhlIHBhZ2UgbG9hZHMuXG4gKiAgICAgICAgIC0gRmFsc2UgaW5kaWNhdGVzIHRoYXQgdGhlIG1lZGlhIHNob3VsZCBub3Qgc3RhcnQgYXMgc29vbiBhcyB0aGUgcGFnZSBsb2Fkcy5cbiAqXG4gKiBAc2VlIFtTcGVjXXtAbGluayBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUvZW1iZWRkZWQtY29udGVudC0wLmh0bWwjYXR0ci1tZWRpYS1hdXRvcGxheX1cbiAqL1xuJ2F1dG9wbGF5JyxcblxuLyoqXG4gKiBTZXQgdGhlIHZhbHVlIG9mIGBsb29wYCBvbiB0aGUgbWVkaWEgZWxlbWVudC4gYGxvb3BgIGluZGljYXRlc1xuICogdGhhdCB0aGUgbWVkaWEgc2hvdWxkIHJldHVybiB0byB0aGUgc3RhcnQgb2YgdGhlIG1lZGlhIGFuZCBjb250aW51ZSBwbGF5aW5nIG9uY2VcbiAqIGl0IHJlYWNoZXMgdGhlIGVuZC5cbiAqXG4gKiBAbWV0aG9kIEh0bWw1I3NldExvb3BcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gbG9vcFxuICogICAgICAgICAtIFRydWUgaW5kaWNhdGVzIHRoYXQgcGxheWJhY2sgc2hvdWxkIHNlZWsgYmFjayB0byBzdGFydCBvbmNlXG4gKiAgICAgICAgICAgdGhlIGVuZCBvZiBhIG1lZGlhIGlzIHJlYWNoZWQuXG4gKiAgICAgICAgIC0gRmFsc2UgaW5kaWNhdGVzIHRoYXQgcGxheWJhY2sgc2hvdWxkIG5vdCBsb29wIGJhY2sgdG8gdGhlIHN0YXJ0IHdoZW4gdGhlXG4gKiAgICAgICAgICAgZW5kIG9mIHRoZSBtZWRpYSBpcyByZWFjaGVkLlxuICpcbiAqIEBzZWUgW1NwZWNde0BsaW5rIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNS9lbWJlZGRlZC1jb250ZW50LTAuaHRtbCNhdHRyLW1lZGlhLWxvb3B9XG4gKi9cbidsb29wJyxcblxuLyoqXG4gKiBTZXQgdGhlIHZhbHVlIG9mIGBwbGF5c2lubGluZWAgZnJvbSB0aGUgbWVkaWEgZWxlbWVudC4gYHBsYXlzaW5saW5lYCBpbmRpY2F0ZXNcbiAqIHRvIHRoZSBicm93c2VyIHRoYXQgbm9uLWZ1bGxzY3JlZW4gcGxheWJhY2sgaXMgcHJlZmVycmVkIHdoZW4gZnVsbHNjcmVlblxuICogcGxheWJhY2sgaXMgdGhlIG5hdGl2ZSBkZWZhdWx0LCBzdWNoIGFzIGluIGlPUyBTYWZhcmkuXG4gKlxuICogQG1ldGhvZCBIdG1sNSNzZXRQbGF5c2lubGluZVxuICogQHBhcmFtIHtib29sZWFufSBwbGF5c2lubGluZVxuICogICAgICAgICAtIFRydWUgaW5kaWNhdGVzIHRoYXQgdGhlIG1lZGlhIHNob3VsZCBwbGF5IGlubGluZS5cbiAqICAgICAgICAgLSBGYWxzZSBpbmRpY2F0ZXMgdGhhdCB0aGUgbWVkaWEgc2hvdWxkIG5vdCBwbGF5IGlubGluZS5cbiAqXG4gKiBAc2VlIFtTcGVjXXtAbGluayBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnLyNhdHRyLXZpZGVvLXBsYXlzaW5saW5lfVxuICovXG4ncGxheXNpbmxpbmUnXS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gIEh0bWw1LnByb3RvdHlwZVsnc2V0JyArIHRvVGl0bGVDYXNlKHByb3ApXSA9IGZ1bmN0aW9uICh2KSB7XG4gICAgdGhpcy5lbF9bcHJvcF0gPSB2O1xuXG4gICAgaWYgKHYpIHtcbiAgICAgIHRoaXMuZWxfLnNldEF0dHJpYnV0ZShwcm9wLCBwcm9wKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5lbF8ucmVtb3ZlQXR0cmlidXRlKHByb3ApO1xuICAgIH1cbiAgfTtcbn0pO1xuXG4vLyBXcmFwIG5hdGl2ZSBwcm9wZXJ0aWVzIHdpdGggYSBnZXR0ZXJcbi8vIFRoZSBsaXN0IGlzIGFzIGZvbGxvd2VkXG4vLyBwYXVzZWQsIGN1cnJlbnRUaW1lLCBidWZmZXJlZCwgdm9sdW1lLCBwb3N0ZXIsIHByZWxvYWQsIGVycm9yLCBzZWVraW5nXG4vLyBzZWVrYWJsZSwgZW5kZWQsIHBsYXliYWNrUmF0ZSwgZGVmYXVsdFBsYXliYWNrUmF0ZSwgcGxheWVkLCBuZXR3b3JrU3RhdGVcbi8vIHJlYWR5U3RhdGUsIHZpZGVvV2lkdGgsIHZpZGVvSGVpZ2h0XG5bXG4vKipcbiAqIEdldCB0aGUgdmFsdWUgb2YgYHBhdXNlZGAgZnJvbSB0aGUgbWVkaWEgZWxlbWVudC4gYHBhdXNlZGAgaW5kaWNhdGVzIHdoZXRoZXIgdGhlIG1lZGlhIGVsZW1lbnRcbiAqIGlzIGN1cnJlbnRseSBwYXVzZWQgb3Igbm90LlxuICpcbiAqIEBtZXRob2QgSHRtbDUjcGF1c2VkXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICogICAgICAgICBUaGUgdmFsdWUgb2YgYHBhdXNlZGAgZnJvbSB0aGUgbWVkaWEgZWxlbWVudC5cbiAqXG4gKiBAc2VlIFtTcGVjXXtAbGluayBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUvZW1iZWRkZWQtY29udGVudC0wLmh0bWwjZG9tLW1lZGlhLXBhdXNlZH1cbiAqL1xuJ3BhdXNlZCcsXG5cbi8qKlxuICogR2V0IHRoZSB2YWx1ZSBvZiBgY3VycmVudFRpbWVgIGZyb20gdGhlIG1lZGlhIGVsZW1lbnQuIGBjdXJyZW50VGltZWAgaW5kaWNhdGVzXG4gKiB0aGUgY3VycmVudCBzZWNvbmQgdGhhdCB0aGUgbWVkaWEgaXMgYXQgaW4gcGxheWJhY2suXG4gKlxuICogQG1ldGhvZCBIdG1sNSNjdXJyZW50VGltZVxuICogQHJldHVybiB7bnVtYmVyfVxuICogICAgICAgICBUaGUgdmFsdWUgb2YgYGN1cnJlbnRUaW1lYCBmcm9tIHRoZSBtZWRpYSBlbGVtZW50LlxuICpcbiAqIEBzZWUgW1NwZWNde0BsaW5rIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNS9lbWJlZGRlZC1jb250ZW50LTAuaHRtbCNkb20tbWVkaWEtY3VycmVudHRpbWV9XG4gKi9cbidjdXJyZW50VGltZScsXG5cbi8qKlxuICogR2V0IHRoZSB2YWx1ZSBvZiBgYnVmZmVyZWRgIGZyb20gdGhlIG1lZGlhIGVsZW1lbnQuIGBidWZmZXJlZGAgaXMgYSBgVGltZVJhbmdlYFxuICogb2JqZWN0IHRoYXQgcmVwcmVzZW50cyB0aGUgcGFydHMgb2YgdGhlIG1lZGlhIHRoYXQgYXJlIGFscmVhZHkgZG93bmxvYWRlZCBhbmRcbiAqIGF2YWlsYWJsZSBmb3IgcGxheWJhY2suXG4gKlxuICogQG1ldGhvZCBIdG1sNSNidWZmZXJlZFxuICogQHJldHVybiB7VGltZVJhbmdlfVxuICogICAgICAgICBUaGUgdmFsdWUgb2YgYGJ1ZmZlcmVkYCBmcm9tIHRoZSBtZWRpYSBlbGVtZW50LlxuICpcbiAqIEBzZWUgW1NwZWNde0BsaW5rIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNS9lbWJlZGRlZC1jb250ZW50LTAuaHRtbCNkb20tbWVkaWEtYnVmZmVyZWR9XG4gKi9cbididWZmZXJlZCcsXG5cbi8qKlxuICogR2V0IHRoZSB2YWx1ZSBvZiBgdm9sdW1lYCBmcm9tIHRoZSBtZWRpYSBlbGVtZW50LiBgdm9sdW1lYCBpbmRpY2F0ZXNcbiAqIHRoZSBjdXJyZW50IHBsYXliYWNrIHZvbHVtZSBvZiBhdWRpbyBmb3IgYSBtZWRpYS4gYHZvbHVtZWAgd2lsbCBiZSBhIHZhbHVlIGZyb20gMFxuICogKHNpbGVudCkgdG8gMSAobG91ZGVzdCBhbmQgZGVmYXVsdCkuXG4gKlxuICogQG1ldGhvZCBIdG1sNSN2b2x1bWVcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqICAgICAgICAgVGhlIHZhbHVlIG9mIGB2b2x1bWVgIGZyb20gdGhlIG1lZGlhIGVsZW1lbnQuIFZhbHVlIHdpbGwgYmUgYmV0d2VlbiAwLTEuXG4gKlxuICogQHNlZSBbU3BlY117QGxpbmsgaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1L2VtYmVkZGVkLWNvbnRlbnQtMC5odG1sI2RvbS1hLXZvbHVtZX1cbiAqL1xuJ3ZvbHVtZScsXG5cbi8qKlxuICogR2V0IHRoZSB2YWx1ZSBvZiBgcG9zdGVyYCBmcm9tIHRoZSBtZWRpYSBlbGVtZW50LiBgcG9zdGVyYCBpbmRpY2F0ZXNcbiAqIHRoYXQgdGhlIHVybCBvZiBhbiBpbWFnZSBmaWxlIHRoYXQgY2FuL3dpbGwgYmUgc2hvd24gd2hlbiBubyBtZWRpYSBkYXRhIGlzIGF2YWlsYWJsZS5cbiAqXG4gKiBAbWV0aG9kIEh0bWw1I3Bvc3RlclxuICogQHJldHVybiB7c3RyaW5nfVxuICogICAgICAgICBUaGUgdmFsdWUgb2YgYHBvc3RlcmAgZnJvbSB0aGUgbWVkaWEgZWxlbWVudC4gVmFsdWUgd2lsbCBiZSBhIHVybCB0byBhblxuICogICAgICAgICBpbWFnZS5cbiAqXG4gKiBAc2VlIFtTcGVjXXtAbGluayBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUvZW1iZWRkZWQtY29udGVudC0wLmh0bWwjYXR0ci12aWRlby1wb3N0ZXJ9XG4gKi9cbidwb3N0ZXInLFxuXG4vKipcbiAqIEdldCB0aGUgdmFsdWUgb2YgYHByZWxvYWRgIGZyb20gdGhlIG1lZGlhIGVsZW1lbnQuIGBwcmVsb2FkYCBpbmRpY2F0ZXNcbiAqIHdoYXQgc2hvdWxkIGRvd25sb2FkIGJlZm9yZSB0aGUgbWVkaWEgaXMgaW50ZXJhY3RlZCB3aXRoLiBJdCBjYW4gaGF2ZSB0aGUgZm9sbG93aW5nXG4gKiB2YWx1ZXM6XG4gKiAtIG5vbmU6IG5vdGhpbmcgc2hvdWxkIGJlIGRvd25sb2FkZWRcbiAqIC0gbWV0YWRhdGE6IHBvc3RlciBhbmQgdGhlIGZpcnN0IGZldyBmcmFtZXMgb2YgdGhlIG1lZGlhIG1heSBiZSBkb3dubG9hZGVkIHRvIGdldFxuICogICBtZWRpYSBkaW1lbnNpb25zIGFuZCBvdGhlciBtZXRhZGF0YVxuICogLSBhdXRvOiBhbGxvdyB0aGUgbWVkaWEgYW5kIG1ldGFkYXRhIGZvciB0aGUgbWVkaWEgdG8gYmUgZG93bmxvYWRlZCBiZWZvcmVcbiAqICAgIGludGVyYWN0aW9uXG4gKlxuICogQG1ldGhvZCBIdG1sNSNwcmVsb2FkXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKiAgICAgICAgIFRoZSB2YWx1ZSBvZiBgcHJlbG9hZGAgZnJvbSB0aGUgbWVkaWEgZWxlbWVudC4gV2lsbCBiZSAnbm9uZScsICdtZXRhZGF0YScsXG4gKiAgICAgICAgIG9yICdhdXRvJy5cbiAqXG4gKiBAc2VlIFtTcGVjXXtAbGluayBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUvZW1iZWRkZWQtY29udGVudC0wLmh0bWwjYXR0ci1tZWRpYS1wcmVsb2FkfVxuICovXG4ncHJlbG9hZCcsXG5cbi8qKlxuICogR2V0IHRoZSB2YWx1ZSBvZiB0aGUgYGVycm9yYCBmcm9tIHRoZSBtZWRpYSBlbGVtZW50LiBgZXJyb3JgIGluZGljYXRlcyBhbnlcbiAqIE1lZGlhRXJyb3IgdGhhdCBtYXkgaGF2ZSBvY2N1cmVkIGR1cmluZyBwbGF5YmFjay4gSWYgZXJyb3IgcmV0dXJucyBudWxsIHRoZXJlIGlzIG5vXG4gKiBjdXJyZW50IGVycm9yLlxuICpcbiAqIEBtZXRob2QgSHRtbDUjZXJyb3JcbiAqIEByZXR1cm4ge01lZGlhRXJyb3J8bnVsbH1cbiAqICAgICAgICAgVGhlIHZhbHVlIG9mIGBlcnJvcmAgZnJvbSB0aGUgbWVkaWEgZWxlbWVudC4gV2lsbCBiZSBgTWVkaWFFcnJvcmAgaWYgdGhlcmVcbiAqICAgICAgICAgaXMgYSBjdXJyZW50IGVycm9yIGFuZCBudWxsIG90aGVyd2lzZS5cbiAqXG4gKiBAc2VlIFtTcGVjXXtAbGluayBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUvZW1iZWRkZWQtY29udGVudC0wLmh0bWwjZG9tLW1lZGlhLWVycm9yfVxuICovXG4nZXJyb3InLFxuXG4vKipcbiAqIEdldCB0aGUgdmFsdWUgb2YgYHNlZWtpbmdgIGZyb20gdGhlIG1lZGlhIGVsZW1lbnQuIGBzZWVraW5nYCBpbmRpY2F0ZXMgd2hldGhlciB0aGVcbiAqIG1lZGlhIGlzIGN1cnJlbnRseSBzZWVraW5nIHRvIGEgbmV3IHBvc2l0aW9uIG9yIG5vdC5cbiAqXG4gKiBAbWV0aG9kIEh0bWw1I3NlZWtpbmdcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKiAgICAgICAgIC0gVGhlIHZhbHVlIG9mIGBzZWVraW5nYCBmcm9tIHRoZSBtZWRpYSBlbGVtZW50LlxuICogICAgICAgICAtIFRydWUgaW5kaWNhdGVzIHRoYXQgdGhlIG1lZGlhIGlzIGN1cnJlbnRseSBzZWVraW5nIHRvIGEgbmV3IHBvc2l0aW9uLlxuICogICAgICAgICAtIEZsYXNlIGluZGljYXRlcyB0aGF0IHRoZSBtZWRpYSBpcyBub3Qgc2Vla2luZyB0byBhIG5ldyBwb3NpdGlvbiBhdCB0aGlzIHRpbWUuXG4gKlxuICogQHNlZSBbU3BlY117QGxpbmsgaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1L2VtYmVkZGVkLWNvbnRlbnQtMC5odG1sI2RvbS1tZWRpYS1zZWVraW5nfVxuICovXG4nc2Vla2luZycsXG5cbi8qKlxuICogR2V0IHRoZSB2YWx1ZSBvZiBgc2Vla2FibGVgIGZyb20gdGhlIG1lZGlhIGVsZW1lbnQuIGBzZWVrYWJsZWAgcmV0dXJucyBhXG4gKiBgVGltZVJhbmdlYCBvYmplY3QgaW5kaWNhdGluZyByYW5nZXMgb2YgdGltZSB0aGF0IGNhbiBjdXJyZW50bHkgYmUgYHNlZWtlZGAgdG8uXG4gKlxuICogQG1ldGhvZCBIdG1sNSNzZWVrYWJsZVxuICogQHJldHVybiB7VGltZVJhbmdlfVxuICogICAgICAgICBUaGUgdmFsdWUgb2YgYHNlZWthYmxlYCBmcm9tIHRoZSBtZWRpYSBlbGVtZW50LiBBIGBUaW1lUmFuZ2VgIG9iamVjdFxuICogICAgICAgICBpbmRpY2F0aW5nIHRoZSBjdXJyZW50IHJhbmdlcyBvZiB0aW1lIHRoYXQgY2FuIGJlIHNlZWtlZCB0by5cbiAqXG4gKiBAc2VlIFtTcGVjXXtAbGluayBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUvZW1iZWRkZWQtY29udGVudC0wLmh0bWwjZG9tLW1lZGlhLXNlZWthYmxlfVxuICovXG4nc2Vla2FibGUnLFxuXG4vKipcbiAqIEdldCB0aGUgdmFsdWUgb2YgYGVuZGVkYCBmcm9tIHRoZSBtZWRpYSBlbGVtZW50LiBgZW5kZWRgIGluZGljYXRlcyB3aGV0aGVyXG4gKiB0aGUgbWVkaWEgaGFzIHJlYWNoZWQgdGhlIGVuZCBvciBub3QuXG4gKlxuICogQG1ldGhvZCBIdG1sNSNlbmRlZFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqICAgICAgICAgLSBUaGUgdmFsdWUgb2YgYGVuZGVkYCBmcm9tIHRoZSBtZWRpYSBlbGVtZW50LlxuICogICAgICAgICAtIFRydWUgaW5kaWNhdGVzIHRoYXQgdGhlIG1lZGlhIGhhcyBlbmRlZC5cbiAqICAgICAgICAgLSBGYWxzZSBpbmRpY2F0ZXMgdGhhdCB0aGUgbWVkaWEgaGFzIG5vdCBlbmRlZC5cbiAqXG4gKiBAc2VlIFtTcGVjXXtAbGluayBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUvZW1iZWRkZWQtY29udGVudC0wLmh0bWwjZG9tLW1lZGlhLWVuZGVkfVxuICovXG4nZW5kZWQnLFxuXG4vKipcbiAqIEdldCB0aGUgdmFsdWUgb2YgYHBsYXliYWNrUmF0ZWAgZnJvbSB0aGUgbWVkaWEgZWxlbWVudC4gYHBsYXliYWNrUmF0ZWAgaW5kaWNhdGVzXG4gKiB0aGUgcmF0ZSBhdCB3aGljaCB0aGUgbWVkaWEgaXMgY3VycmVudGx5IHBsYXlpbmcgYmFjay4gRXhhbXBsZXM6XG4gKiAgIC0gaWYgcGxheWJhY2tSYXRlIGlzIHNldCB0byAyLCBtZWRpYSB3aWxsIHBsYXkgdHdpY2UgYXMgZmFzdC5cbiAqICAgLSBpZiBwbGF5YmFja1JhdGUgaXMgc2V0IHRvIDAuNSwgbWVkaWEgd2lsbCBwbGF5IGhhbGYgYXMgZmFzdC5cbiAqXG4gKiBAbWV0aG9kIEh0bWw1I3BsYXliYWNrUmF0ZVxuICogQHJldHVybiB7bnVtYmVyfVxuICogICAgICAgICBUaGUgdmFsdWUgb2YgYHBsYXliYWNrUmF0ZWAgZnJvbSB0aGUgbWVkaWEgZWxlbWVudC4gQSBudW1iZXIgaW5kaWNhdGluZ1xuICogICAgICAgICB0aGUgY3VycmVudCBwbGF5YmFjayBzcGVlZCBvZiB0aGUgbWVkaWEsIHdoZXJlIDEgaXMgbm9ybWFsIHNwZWVkLlxuICpcbiAqIEBzZWUgW1NwZWNde0BsaW5rIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNS9lbWJlZGRlZC1jb250ZW50LTAuaHRtbCNkb20tbWVkaWEtcGxheWJhY2tyYXRlfVxuICovXG4ncGxheWJhY2tSYXRlJyxcblxuLyoqXG4gKiBHZXQgdGhlIHZhbHVlIG9mIGBkZWZhdWx0UGxheWJhY2tSYXRlYCBmcm9tIHRoZSBtZWRpYSBlbGVtZW50LiBgZGVmYXVsdFBsYXliYWNrUmF0ZWAgaW5kaWNhdGVzXG4gKiB0aGUgcmF0ZSBhdCB3aGljaCB0aGUgbWVkaWEgaXMgY3VycmVudGx5IHBsYXlpbmcgYmFjay4gVGhpcyB2YWx1ZSB3aWxsIG5vdCBpbmRpY2F0ZSB0aGUgY3VycmVudFxuICogYHBsYXliYWNrUmF0ZWAgYWZ0ZXIgcGxheWJhY2sgaGFzIHN0YXJ0ZWQsIHVzZSB7QGxpbmsgSHRtbDUjcGxheWJhY2tSYXRlfSBmb3IgdGhhdC5cbiAqXG4gKiBFeGFtcGxlczpcbiAqICAgLSBpZiBkZWZhdWx0UGxheWJhY2tSYXRlIGlzIHNldCB0byAyLCBtZWRpYSB3aWxsIHBsYXkgdHdpY2UgYXMgZmFzdC5cbiAqICAgLSBpZiBkZWZhdWx0UGxheWJhY2tSYXRlIGlzIHNldCB0byAwLjUsIG1lZGlhIHdpbGwgcGxheSBoYWxmIGFzIGZhc3QuXG4gKlxuICogQG1ldGhvZCBIdG1sNS5wcm90b3R5cGUuZGVmYXVsdFBsYXliYWNrUmF0ZVxuICogQHJldHVybiB7bnVtYmVyfVxuICogICAgICAgICBUaGUgdmFsdWUgb2YgYGRlZmF1bHRQbGF5YmFja1JhdGVgIGZyb20gdGhlIG1lZGlhIGVsZW1lbnQuIEEgbnVtYmVyIGluZGljYXRpbmdcbiAqICAgICAgICAgdGhlIGN1cnJlbnQgcGxheWJhY2sgc3BlZWQgb2YgdGhlIG1lZGlhLCB3aGVyZSAxIGlzIG5vcm1hbCBzcGVlZC5cbiAqXG4gKiBAc2VlIFtTcGVjXXtAbGluayBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUvZW1iZWRkZWQtY29udGVudC0wLmh0bWwjZG9tLW1lZGlhLXBsYXliYWNrcmF0ZX1cbiAqL1xuJ2RlZmF1bHRQbGF5YmFja1JhdGUnLFxuXG4vKipcbiAqIEdldCB0aGUgdmFsdWUgb2YgYHBsYXllZGAgZnJvbSB0aGUgbWVkaWEgZWxlbWVudC4gYHBsYXllZGAgcmV0dXJucyBhIGBUaW1lUmFuZ2VgXG4gKiBvYmplY3QgcmVwcmVzZW50aW5nIHBvaW50cyBpbiB0aGUgbWVkaWEgdGltZWxpbmUgdGhhdCBoYXZlIGJlZW4gcGxheWVkLlxuICpcbiAqIEBtZXRob2QgSHRtbDUjcGxheWVkXG4gKiBAcmV0dXJuIHtUaW1lUmFuZ2V9XG4gKiAgICAgICAgIFRoZSB2YWx1ZSBvZiBgcGxheWVkYCBmcm9tIHRoZSBtZWRpYSBlbGVtZW50LiBBIGBUaW1lUmFuZ2VgIG9iamVjdCBpbmRpY2F0aW5nXG4gKiAgICAgICAgIHRoZSByYW5nZXMgb2YgdGltZSB0aGF0IGhhdmUgYmVlbiBwbGF5ZWQuXG4gKlxuICogQHNlZSBbU3BlY117QGxpbmsgaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1L2VtYmVkZGVkLWNvbnRlbnQtMC5odG1sI2RvbS1tZWRpYS1wbGF5ZWR9XG4gKi9cbidwbGF5ZWQnLFxuXG4vKipcbiAqIEdldCB0aGUgdmFsdWUgb2YgYG5ldHdvcmtTdGF0ZWAgZnJvbSB0aGUgbWVkaWEgZWxlbWVudC4gYG5ldHdvcmtTdGF0ZWAgaW5kaWNhdGVzXG4gKiB0aGUgY3VycmVudCBuZXR3b3JrIHN0YXRlLiBJdCByZXR1cm5zIGFuIGVudW1lcmF0aW9uIGZyb20gdGhlIGZvbGxvd2luZyBsaXN0OlxuICogLSAwOiBORVRXT1JLX0VNUFRZXG4gKiAtIDE6IE5FV09SS19JRExFXG4gKiAtIDI6IE5FVFdPUktfTE9BRElOR1xuICogLSAzOiBORVRXT1JLX05PX1NPVVJDRVxuICpcbiAqIEBtZXRob2QgSHRtbDUjbmV0d29ya1N0YXRlXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKiAgICAgICAgIFRoZSB2YWx1ZSBvZiBgbmV0d29ya1N0YXRlYCBmcm9tIHRoZSBtZWRpYSBlbGVtZW50LiBUaGlzIHdpbGwgYmUgYSBudW1iZXJcbiAqICAgICAgICAgZnJvbSB0aGUgbGlzdCBpbiB0aGUgZGVzY3JpcHRpb24uXG4gKlxuICogQHNlZSBbU3BlY10ge0BsaW5rIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNS9lbWJlZGRlZC1jb250ZW50LTAuaHRtbCNkb20tbWVkaWEtbmV0d29ya3N0YXRlfVxuICovXG4nbmV0d29ya1N0YXRlJyxcblxuLyoqXG4gKiBHZXQgdGhlIHZhbHVlIG9mIGByZWFkeVN0YXRlYCBmcm9tIHRoZSBtZWRpYSBlbGVtZW50LiBgcmVhZHlTdGF0ZWAgaW5kaWNhdGVzXG4gKiB0aGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgbWVkaWEgZWxlbWVudC4gSXQgcmV0dXJucyBhbiBlbnVtZXJhdGlvbiBmcm9tIHRoZVxuICogZm9sbG93aW5nIGxpc3Q6XG4gKiAtIDA6IEhBVkVfTk9USElOR1xuICogLSAxOiBIQVZFX01FVEFEQVRBXG4gKiAtIDI6IEhBVkVfQ1VSUkVOVF9EQVRBXG4gKiAtIDM6IEhBVkVfRlVUVVJFX0RBVEFcbiAqIC0gNDogSEFWRV9FTk9VR0hfREFUQVxuICpcbiAqIEBtZXRob2QgSHRtbDUjcmVhZHlTdGF0ZVxuICogQHJldHVybiB7bnVtYmVyfVxuICogICAgICAgICBUaGUgdmFsdWUgb2YgYHJlYWR5U3RhdGVgIGZyb20gdGhlIG1lZGlhIGVsZW1lbnQuIFRoaXMgd2lsbCBiZSBhIG51bWJlclxuICogICAgICAgICBmcm9tIHRoZSBsaXN0IGluIHRoZSBkZXNjcmlwdGlvbi5cbiAqXG4gKiBAc2VlIFtTcGVjXSB7QGxpbmsgaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1L2VtYmVkZGVkLWNvbnRlbnQtMC5odG1sI3JlYWR5LXN0YXRlc31cbiAqL1xuJ3JlYWR5U3RhdGUnLFxuXG4vKipcbiAqIEdldCB0aGUgdmFsdWUgb2YgYHZpZGVvV2lkdGhgIGZyb20gdGhlIHZpZGVvIGVsZW1lbnQuIGB2aWRlb1dpZHRoYCBpbmRpY2F0ZXNcbiAqIHRoZSBjdXJyZW50IHdpZHRoIG9mIHRoZSB2aWRlbyBpbiBjc3MgcGl4ZWxzLlxuICpcbiAqIEBtZXRob2QgSHRtbDUjdmlkZW9XaWR0aFxuICogQHJldHVybiB7bnVtYmVyfVxuICogICAgICAgICBUaGUgdmFsdWUgb2YgYHZpZGVvV2lkdGhgIGZyb20gdGhlIHZpZGVvIGVsZW1lbnQuIFRoaXMgd2lsbCBiZSBhIG51bWJlclxuICogICAgICAgICBpbiBjc3MgcGl4ZWxzLlxuICpcbiAqIEBzZWUgW1NwZWNdIHtAbGluayBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUvZW1iZWRkZWQtY29udGVudC0wLmh0bWwjZG9tLXZpZGVvLXZpZGVvd2lkdGh9XG4gKi9cbid2aWRlb1dpZHRoJyxcblxuLyoqXG4gKiBHZXQgdGhlIHZhbHVlIG9mIGB2aWRlb0hlaWdodGAgZnJvbSB0aGUgdmlkZW8gZWxlbWVudC4gYHZpZGVvSGVpZ3RoYCBpbmRpY2F0ZXNcbiAqIHRoZSBjdXJyZW50IGhlaWdodCBvZiB0aGUgdmlkZW8gaW4gY3NzIHBpeGVscy5cbiAqXG4gKiBAbWV0aG9kIEh0bWw1I3ZpZGVvSGVpZ2h0XG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKiAgICAgICAgIFRoZSB2YWx1ZSBvZiBgdmlkZW9IZWlnaHRgIGZyb20gdGhlIHZpZGVvIGVsZW1lbnQuIFRoaXMgd2lsbCBiZSBhIG51bWJlclxuICogICAgICAgICBpbiBjc3MgcGl4ZWxzLlxuICpcbiAqIEBzZWUgW1NwZWNdIHtAbGluayBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUvZW1iZWRkZWQtY29udGVudC0wLmh0bWwjZG9tLXZpZGVvLXZpZGVvd2lkdGh9XG4gKi9cbid2aWRlb0hlaWdodCddLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgSHRtbDUucHJvdG90eXBlW3Byb3BdID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmVsX1twcm9wXTtcbiAgfTtcbn0pO1xuXG4vLyBXcmFwIG5hdGl2ZSBwcm9wZXJ0aWVzIHdpdGggYSBzZXR0ZXIgaW4gdGhpcyBmb3JtYXQ6XG4vLyBzZXQgKyB0b1RpdGxlQ2FzZShuYW1lKVxuLy8gVGhlIGxpc3QgaXMgYXMgZm9sbG93czpcbi8vIHNldFZvbHVtZSwgc2V0U3JjLCBzZXRQb3N0ZXIsIHNldFByZWxvYWQsIHNldFBsYXliYWNrUmF0ZSwgc2V0RGVmYXVsdFBsYXliYWNrUmF0ZVxuW1xuLyoqXG4gKiBTZXQgdGhlIHZhbHVlIG9mIGB2b2x1bWVgIG9uIHRoZSBtZWRpYSBlbGVtZW50LiBgdm9sdW1lYCBpbmRpY2F0ZXMgdGhlIGN1cnJlbnRcbiAqIGF1ZGlvIGxldmVsIGFzIGEgcGVyY2VudGFnZSBpbiBkZWNpbWFsIGZvcm0uIFRoaXMgbWVhbnMgdGhhdCAxIGlzIDEwMCUsIDAuNSBpcyA1MCUsIGFuZFxuICogc28gb24uXG4gKlxuICogQG1ldGhvZCBIdG1sNSNzZXRWb2x1bWVcbiAqIEBwYXJhbSB7bnVtYmVyfSBwZXJjZW50QXNEZWNpbWFsXG4gKiAgICAgICAgVGhlIHZvbHVtZSBwZXJjZW50IGFzIGEgZGVjaW1hbC4gVmFsaWQgcmFuZ2UgaXMgZnJvbSAwLTEuXG4gKlxuICogQHNlZSBbU3BlY117QGxpbmsgaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1L2VtYmVkZGVkLWNvbnRlbnQtMC5odG1sI2RvbS1hLXZvbHVtZX1cbiAqL1xuJ3ZvbHVtZScsXG5cbi8qKlxuICogU2V0IHRoZSB2YWx1ZSBvZiBgc3JjYCBvbiB0aGUgbWVkaWEgZWxlbWVudC4gYHNyY2AgaW5kaWNhdGVzIHRoZSBjdXJyZW50XG4gKiB7QGxpbmsgVGVjaH5Tb3VyY2VPYmplY3R9IGZvciB0aGUgbWVkaWEuXG4gKlxuICogQG1ldGhvZCBIdG1sNSNzZXRTcmNcbiAqIEBwYXJhbSB7VGVjaH5Tb3VyY2VPYmplY3R9IHNyY1xuICogICAgICAgIFRoZSBzb3VyY2Ugb2JqZWN0IHRvIHNldCBhcyB0aGUgY3VycmVudCBzb3VyY2UuXG4gKlxuICogQHNlZSBbU3BlY117QGxpbmsgaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1L2VtYmVkZGVkLWNvbnRlbnQtMC5odG1sI2RvbS1tZWRpYS1zcmN9XG4gKi9cbidzcmMnLFxuXG4vKipcbiAqIFNldCB0aGUgdmFsdWUgb2YgYHBvc3RlcmAgb24gdGhlIG1lZGlhIGVsZW1lbnQuIGBwb3N0ZXJgIGlzIHRoZSB1cmwgdG9cbiAqIGFuIGltYWdlIGZpbGUgdGhhdCBjYW4vd2lsbCBiZSBzaG93biB3aGVuIG5vIG1lZGlhIGRhdGEgaXMgYXZhaWxhYmxlLlxuICpcbiAqIEBtZXRob2QgSHRtbDUjc2V0UG9zdGVyXG4gKiBAcGFyYW0ge3N0cmluZ30gcG9zdGVyXG4gKiAgICAgICAgVGhlIHVybCB0byBhbiBpbWFnZSB0aGF0IHNob3VsZCBiZSB1c2VkIGFzIHRoZSBgcG9zdGVyYCBmb3IgdGhlIG1lZGlhXG4gKiAgICAgICAgZWxlbWVudC5cbiAqXG4gKiBAc2VlIFtTcGVjXXtAbGluayBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUvZW1iZWRkZWQtY29udGVudC0wLmh0bWwjYXR0ci1tZWRpYS1wb3N0ZXJ9XG4gKi9cbidwb3N0ZXInLFxuXG4vKipcbiAqIFNldCB0aGUgdmFsdWUgb2YgYHByZWxvYWRgIG9uIHRoZSBtZWRpYSBlbGVtZW50LiBgcHJlbG9hZGAgaW5kaWNhdGVzXG4gKiB3aGF0IHNob3VsZCBkb3dubG9hZCBiZWZvcmUgdGhlIG1lZGlhIGlzIGludGVyYWN0ZWQgd2l0aC4gSXQgY2FuIGhhdmUgdGhlIGZvbGxvd2luZ1xuICogdmFsdWVzOlxuICogLSBub25lOiBub3RoaW5nIHNob3VsZCBiZSBkb3dubG9hZGVkXG4gKiAtIG1ldGFkYXRhOiBwb3N0ZXIgYW5kIHRoZSBmaXJzdCBmZXcgZnJhbWVzIG9mIHRoZSBtZWRpYSBtYXkgYmUgZG93bmxvYWRlZCB0byBnZXRcbiAqICAgbWVkaWEgZGltZW5zaW9ucyBhbmQgb3RoZXIgbWV0YWRhdGFcbiAqIC0gYXV0bzogYWxsb3cgdGhlIG1lZGlhIGFuZCBtZXRhZGF0YSBmb3IgdGhlIG1lZGlhIHRvIGJlIGRvd25sb2FkZWQgYmVmb3JlXG4gKiAgICBpbnRlcmFjdGlvblxuICpcbiAqIEBtZXRob2QgSHRtbDUjc2V0UHJlbG9hZFxuICogQHBhcmFtIHtzdHJpbmd9IHByZWxvYWRcbiAqICAgICAgICAgVGhlIHZhbHVlIG9mIGBwcmVsb2FkYCB0byBzZXQgb24gdGhlIG1lZGlhIGVsZW1lbnQuIE11c3QgYmUgJ25vbmUnLCAnbWV0YWRhdGEnLFxuICogICAgICAgICBvciAnYXV0bycuXG4gKlxuICogQHNlZSBbU3BlY117QGxpbmsgaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1L2VtYmVkZGVkLWNvbnRlbnQtMC5odG1sI2F0dHItbWVkaWEtcHJlbG9hZH1cbiAqL1xuJ3ByZWxvYWQnLFxuXG4vKipcbiAqIFNldCB0aGUgdmFsdWUgb2YgYHBsYXliYWNrUmF0ZWAgb24gdGhlIG1lZGlhIGVsZW1lbnQuIGBwbGF5YmFja1JhdGVgIGluZGljYXRlc1xuICogdGhlIHJhdGUgYXQgd2hpY2ggdGhlIG1lZGlhIHNob3VsZCBwbGF5IGJhY2suIEV4YW1wbGVzOlxuICogICAtIGlmIHBsYXliYWNrUmF0ZSBpcyBzZXQgdG8gMiwgbWVkaWEgd2lsbCBwbGF5IHR3aWNlIGFzIGZhc3QuXG4gKiAgIC0gaWYgcGxheWJhY2tSYXRlIGlzIHNldCB0byAwLjUsIG1lZGlhIHdpbGwgcGxheSBoYWxmIGFzIGZhc3QuXG4gKlxuICogQG1ldGhvZCBIdG1sNSNzZXRQbGF5YmFja1JhdGVcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqICAgICAgICAgVGhlIHZhbHVlIG9mIGBwbGF5YmFja1JhdGVgIGZyb20gdGhlIG1lZGlhIGVsZW1lbnQuIEEgbnVtYmVyIGluZGljYXRpbmdcbiAqICAgICAgICAgdGhlIGN1cnJlbnQgcGxheWJhY2sgc3BlZWQgb2YgdGhlIG1lZGlhLCB3aGVyZSAxIGlzIG5vcm1hbCBzcGVlZC5cbiAqXG4gKiBAc2VlIFtTcGVjXXtAbGluayBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUvZW1iZWRkZWQtY29udGVudC0wLmh0bWwjZG9tLW1lZGlhLXBsYXliYWNrcmF0ZX1cbiAqL1xuJ3BsYXliYWNrUmF0ZScsXG5cbi8qKlxuICogU2V0IHRoZSB2YWx1ZSBvZiBgZGVmYXVsdFBsYXliYWNrUmF0ZWAgb24gdGhlIG1lZGlhIGVsZW1lbnQuIGBkZWZhdWx0UGxheWJhY2tSYXRlYCBpbmRpY2F0ZXNcbiAqIHRoZSByYXRlIGF0IHdoaWNoIHRoZSBtZWRpYSBzaG91bGQgcGxheSBiYWNrIHVwb24gaW5pdGlhbCBzdGFydHVwLiBDaGFuZ2luZyB0aGlzIHZhbHVlXG4gKiBhZnRlciBhIHZpZGVvIGhhcyBzdGFydGVkIHdpbGwgZG8gbm90aGluZy4gSW5zdGVhZCB5b3Ugc2hvdWxkIHVzZWQge0BsaW5rIEh0bWw1I3NldFBsYXliYWNrUmF0ZX0uXG4gKlxuICogRXhhbXBsZSBWYWx1ZXM6XG4gKiAgIC0gaWYgcGxheWJhY2tSYXRlIGlzIHNldCB0byAyLCBtZWRpYSB3aWxsIHBsYXkgdHdpY2UgYXMgZmFzdC5cbiAqICAgLSBpZiBwbGF5YmFja1JhdGUgaXMgc2V0IHRvIDAuNSwgbWVkaWEgd2lsbCBwbGF5IGhhbGYgYXMgZmFzdC5cbiAqXG4gKiBAbWV0aG9kIEh0bWw1LnByb3RvdHlwZS5zZXREZWZhdWx0UGxheWJhY2tSYXRlXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKiAgICAgICAgIFRoZSB2YWx1ZSBvZiBgZGVmYXVsdFBsYXliYWNrUmF0ZWAgZnJvbSB0aGUgbWVkaWEgZWxlbWVudC4gQSBudW1iZXIgaW5kaWNhdGluZ1xuICogICAgICAgICB0aGUgY3VycmVudCBwbGF5YmFjayBzcGVlZCBvZiB0aGUgbWVkaWEsIHdoZXJlIDEgaXMgbm9ybWFsIHNwZWVkLlxuICpcbiAqIEBzZWUgW1NwZWNde0BsaW5rIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNS9lbWJlZGRlZC1jb250ZW50LTAuaHRtbCNkb20tbWVkaWEtZGVmYXVsdHBsYXliYWNrcmF0ZX1cbiAqL1xuJ2RlZmF1bHRQbGF5YmFja1JhdGUnXS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gIEh0bWw1LnByb3RvdHlwZVsnc2V0JyArIHRvVGl0bGVDYXNlKHByb3ApXSA9IGZ1bmN0aW9uICh2KSB7XG4gICAgdGhpcy5lbF9bcHJvcF0gPSB2O1xuICB9O1xufSk7XG5cbi8vIHdyYXAgbmF0aXZlIGZ1bmN0aW9ucyB3aXRoIGEgZnVuY3Rpb25cbi8vIFRoZSBsaXN0IGlzIGFzIGZvbGxvd3M6XG4vLyBwYXVzZSwgbG9hZCBwbGF5XG5bXG4vKipcbiAqIEEgd3JhcHBlciBhcm91bmQgdGhlIG1lZGlhIGVsZW1lbnRzIGBwYXVzZWAgZnVuY3Rpb24uIFRoaXMgd2lsbCBjYWxsIHRoZSBgSFRNTDVgXG4gKiBtZWRpYSBlbGVtZW50cyBgcGF1c2VgIGZ1bmN0aW9uLlxuICpcbiAqIEBtZXRob2QgSHRtbDUjcGF1c2VcbiAqIEBzZWUgW1NwZWNde0BsaW5rIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNS9lbWJlZGRlZC1jb250ZW50LTAuaHRtbCNkb20tbWVkaWEtcGF1c2V9XG4gKi9cbidwYXVzZScsXG5cbi8qKlxuICogQSB3cmFwcGVyIGFyb3VuZCB0aGUgbWVkaWEgZWxlbWVudHMgYGxvYWRgIGZ1bmN0aW9uLiBUaGlzIHdpbGwgY2FsbCB0aGUgYEhUTUw1YHNcbiAqIG1lZGlhIGVsZW1lbnQgYGxvYWRgIGZ1bmN0aW9uLlxuICpcbiAqIEBtZXRob2QgSHRtbDUjbG9hZFxuICogQHNlZSBbU3BlY117QGxpbmsgaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1L2VtYmVkZGVkLWNvbnRlbnQtMC5odG1sI2RvbS1tZWRpYS1sb2FkfVxuICovXG4nbG9hZCcsXG5cbi8qKlxuICogQSB3cmFwcGVyIGFyb3VuZCB0aGUgbWVkaWEgZWxlbWVudHMgYHBsYXlgIGZ1bmN0aW9uLiBUaGlzIHdpbGwgY2FsbCB0aGUgYEhUTUw1YHNcbiAqIG1lZGlhIGVsZW1lbnQgYHBsYXlgIGZ1bmN0aW9uLlxuICpcbiAqIEBtZXRob2QgSHRtbDUjcGxheVxuICogQHNlZSBbU3BlY117QGxpbmsgaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1L2VtYmVkZGVkLWNvbnRlbnQtMC5odG1sI2RvbS1tZWRpYS1wbGF5fVxuICovXG4ncGxheSddLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgSHRtbDUucHJvdG90eXBlW3Byb3BdID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmVsX1twcm9wXSgpO1xuICB9O1xufSk7XG5cblRlY2gud2l0aFNvdXJjZUhhbmRsZXJzKEh0bWw1KTtcblxuLyoqXG4gKiBOYXRpdmUgc291cmNlIGhhbmRsZXIgZm9yIEh0bWw1LCBzaW1wbHkgcGFzc2VzIHRoZSBzb3VyY2UgdG8gdGhlIG1lZGlhIGVsZW1lbnQuXG4gKlxuICogQHByb3ByZXR5IHtUZWNoflNvdXJjZU9iamVjdH0gc291cmNlXG4gKiAgICAgICAgVGhlIHNvdXJjZSBvYmplY3RcbiAqXG4gKiBAcHJvcHJldHkge0h0bWw1fSB0ZWNoXG4gKiAgICAgICAgVGhlIGluc3RhbmNlIG9mIHRoZSBIVE1MNSB0ZWNoLlxuICovXG5IdG1sNS5uYXRpdmVTb3VyY2VIYW5kbGVyID0ge307XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIG1lZGlhIGVsZW1lbnQgY2FuIHBsYXkgdGhlIGdpdmVuIG1pbWUgdHlwZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICogICAgICAgIFRoZSBtaW1ldHlwZSB0byBjaGVja1xuICpcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqICAgICAgICAgJ3Byb2JhYmx5JywgJ21heWJlJywgb3IgJycgKGVtcHR5IHN0cmluZylcbiAqL1xuSHRtbDUubmF0aXZlU291cmNlSGFuZGxlci5jYW5QbGF5VHlwZSA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gIC8vIElFOSBvbiBXaW5kb3dzIDcgd2l0aG91dCBNZWRpYVBsYXllciB0aHJvd3MgYW4gZXJyb3IgaGVyZVxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vdmlkZW9qcy92aWRlby5qcy9pc3N1ZXMvNTE5XG4gIHRyeSB7XG4gICAgcmV0dXJuIEh0bWw1LlRFU1RfVklELmNhblBsYXlUeXBlKHR5cGUpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBtZWRpYSBlbGVtZW50IGNhbiBoYW5kbGUgYSBzb3VyY2UgbmF0aXZlbHkuXG4gKlxuICogQHBhcmFtIHtUZWNoflNvdXJjZU9iamVjdH0gc291cmNlXG4gKiAgICAgICAgIFRoZSBzb3VyY2Ugb2JqZWN0XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogICAgICAgICBPcHRpb25zIHRvIGJlIHBhc3NlZCB0byB0aGUgdGVjaC5cbiAqXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKiAgICAgICAgICdwcm9iYWJseScsICdtYXliZScsIG9yICcnIChlbXB0eSBzdHJpbmcpLlxuICovXG5IdG1sNS5uYXRpdmVTb3VyY2VIYW5kbGVyLmNhbkhhbmRsZVNvdXJjZSA9IGZ1bmN0aW9uIChzb3VyY2UsIG9wdGlvbnMpIHtcblxuICAvLyBJZiBhIHR5cGUgd2FzIHByb3ZpZGVkIHdlIHNob3VsZCByZWx5IG9uIHRoYXRcbiAgaWYgKHNvdXJjZS50eXBlKSB7XG4gICAgcmV0dXJuIEh0bWw1Lm5hdGl2ZVNvdXJjZUhhbmRsZXIuY2FuUGxheVR5cGUoc291cmNlLnR5cGUpO1xuXG4gICAgLy8gSWYgbm8gdHlwZSwgZmFsbCBiYWNrIHRvIGNoZWNraW5nICd2aWRlby9bRVhURU5TSU9OXSdcbiAgfSBlbHNlIGlmIChzb3VyY2Uuc3JjKSB7XG4gICAgdmFyIGV4dCA9IGdldEZpbGVFeHRlbnNpb24oc291cmNlLnNyYyk7XG5cbiAgICByZXR1cm4gSHRtbDUubmF0aXZlU291cmNlSGFuZGxlci5jYW5QbGF5VHlwZSgndmlkZW8vJyArIGV4dCk7XG4gIH1cblxuICByZXR1cm4gJyc7XG59O1xuXG4vKipcbiAqIFBhc3MgdGhlIHNvdXJjZSB0byB0aGUgbmF0aXZlIG1lZGlhIGVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHtUZWNoflNvdXJjZU9iamVjdH0gc291cmNlXG4gKiAgICAgICAgVGhlIHNvdXJjZSBvYmplY3RcbiAqXG4gKiBAcGFyYW0ge0h0bWw1fSB0ZWNoXG4gKiAgICAgICAgVGhlIGluc3RhbmNlIG9mIHRoZSBIdG1sNSB0ZWNoXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogICAgICAgIFRoZSBvcHRpb25zIHRvIHBhc3MgdG8gdGhlIHNvdXJjZVxuICovXG5IdG1sNS5uYXRpdmVTb3VyY2VIYW5kbGVyLmhhbmRsZVNvdXJjZSA9IGZ1bmN0aW9uIChzb3VyY2UsIHRlY2gsIG9wdGlvbnMpIHtcbiAgdGVjaC5zZXRTcmMoc291cmNlLnNyYyk7XG59O1xuXG4vKipcbiAqIEEgbm9vcCBmb3IgdGhlIG5hdGl2ZSBkaXNwb3NlIGZ1bmN0aW9uLCBhcyBjbGVhbnVwIGlzIG5vdCBuZWVkZWQuXG4gKi9cbkh0bWw1Lm5hdGl2ZVNvdXJjZUhhbmRsZXIuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHt9O1xuXG4vLyBSZWdpc3RlciB0aGUgbmF0aXZlIHNvdXJjZSBoYW5kbGVyXG5IdG1sNS5yZWdpc3RlclNvdXJjZUhhbmRsZXIoSHRtbDUubmF0aXZlU291cmNlSGFuZGxlcik7XG5cblRlY2gucmVnaXN0ZXJUZWNoKCdIdG1sNScsIEh0bWw1KTtcblxudmFyIF90ZW1wbGF0ZU9iamVjdCQxID0gdGFnZ2VkVGVtcGxhdGVMaXRlcmFsTG9vc2UoWydcXG4gICAgICAgIFVzaW5nIHRoZSB0ZWNoIGRpcmVjdGx5IGNhbiBiZSBkYW5nZXJvdXMuIEkgaG9wZSB5b3Uga25vdyB3aGF0IHlvdVxcJ3JlIGRvaW5nLlxcbiAgICAgICAgU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS92aWRlb2pzL3ZpZGVvLmpzL2lzc3Vlcy8yNjE3IGZvciBtb3JlIGluZm8uXFxuICAgICAgJ10sIFsnXFxuICAgICAgICBVc2luZyB0aGUgdGVjaCBkaXJlY3RseSBjYW4gYmUgZGFuZ2Vyb3VzLiBJIGhvcGUgeW91IGtub3cgd2hhdCB5b3VcXCdyZSBkb2luZy5cXG4gICAgICAgIFNlZSBodHRwczovL2dpdGh1Yi5jb20vdmlkZW9qcy92aWRlby5qcy9pc3N1ZXMvMjYxNyBmb3IgbW9yZSBpbmZvLlxcbiAgICAgICddKTtcblxuLyoqXG4gKiBAZmlsZSBwbGF5ZXIuanNcbiAqL1xuLy8gU3ViY2xhc3NlcyBDb21wb25lbnRcbi8vIFRoZSBmb2xsb3dpbmcgaW1wb3J0cyBhcmUgdXNlZCBvbmx5IHRvIGVuc3VyZSB0aGF0IHRoZSBjb3JyZXNwb25kaW5nIG1vZHVsZXNcbi8vIGFyZSBhbHdheXMgaW5jbHVkZWQgaW4gdGhlIHZpZGVvLmpzIHBhY2thZ2UuIEltcG9ydGluZyB0aGUgbW9kdWxlcyB3aWxsXG4vLyBleGVjdXRlIHRoZW0gYW5kIHRoZXkgd2lsbCByZWdpc3RlciB0aGVtc2VsdmVzIHdpdGggdmlkZW8uanMuXG4vLyBJbXBvcnQgSHRtbDUgdGVjaCwgYXQgbGVhc3QgZm9yIGRpc3Bvc2luZyB0aGUgb3JpZ2luYWwgdmlkZW8gdGFnLlxuLy8gVGhlIGZvbGxvd2luZyB0ZWNoIGV2ZW50cyBhcmUgc2ltcGx5IHJlLXRyaWdnZXJlZFxuLy8gb24gdGhlIHBsYXllciB3aGVuIHRoZXkgaGFwcGVuXG52YXIgVEVDSF9FVkVOVFNfUkVUUklHR0VSID0gW1xuLyoqXG4gKiBGaXJlZCB3aGlsZSB0aGUgdXNlciBhZ2VudCBpcyBkb3dubG9hZGluZyBtZWRpYSBkYXRhLlxuICpcbiAqIEBldmVudCBQbGF5ZXIjcHJvZ3Jlc3NcbiAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAqL1xuLyoqXG4gKiBSZXRyaWdnZXIgdGhlIGBwcm9ncmVzc2AgZXZlbnQgdGhhdCB3YXMgdHJpZ2dlcmVkIGJ5IHRoZSB7QGxpbmsgVGVjaH0uXG4gKlxuICogQHByaXZhdGVcbiAqIEBtZXRob2QgUGxheWVyI2hhbmRsZVRlY2hQcm9ncmVzc19cbiAqIEBmaXJlcyBQbGF5ZXIjcHJvZ3Jlc3NcbiAqIEBsaXN0ZW5zIFRlY2gjcHJvZ3Jlc3NcbiAqL1xuJ3Byb2dyZXNzJyxcblxuLyoqXG4gKiBGaXJlcyB3aGVuIHRoZSBsb2FkaW5nIG9mIGFuIGF1ZGlvL3ZpZGVvIGlzIGFib3J0ZWQuXG4gKlxuICogQGV2ZW50IFBsYXllciNhYm9ydFxuICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICovXG4vKipcbiAqIFJldHJpZ2dlciB0aGUgYGFib3J0YCBldmVudCB0aGF0IHdhcyB0cmlnZ2VyZWQgYnkgdGhlIHtAbGluayBUZWNofS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG1ldGhvZCBQbGF5ZXIjaGFuZGxlVGVjaEFib3J0X1xuICogQGZpcmVzIFBsYXllciNhYm9ydFxuICogQGxpc3RlbnMgVGVjaCNhYm9ydFxuICovXG4nYWJvcnQnLFxuXG4vKipcbiAqIEZpcmVzIHdoZW4gdGhlIGJyb3dzZXIgaXMgaW50ZW50aW9uYWxseSBub3QgZ2V0dGluZyBtZWRpYSBkYXRhLlxuICpcbiAqIEBldmVudCBQbGF5ZXIjc3VzcGVuZFxuICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICovXG4vKipcbiAqIFJldHJpZ2dlciB0aGUgYHN1c3BlbmRgIGV2ZW50IHRoYXQgd2FzIHRyaWdnZXJlZCBieSB0aGUge0BsaW5rIFRlY2h9LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbWV0aG9kIFBsYXllciNoYW5kbGVUZWNoU3VzcGVuZF9cbiAqIEBmaXJlcyBQbGF5ZXIjc3VzcGVuZFxuICogQGxpc3RlbnMgVGVjaCNzdXNwZW5kXG4gKi9cbidzdXNwZW5kJyxcblxuLyoqXG4gKiBGaXJlcyB3aGVuIHRoZSBjdXJyZW50IHBsYXlsaXN0IGlzIGVtcHR5LlxuICpcbiAqIEBldmVudCBQbGF5ZXIjZW1wdGllZFxuICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICovXG4vKipcbiAqIFJldHJpZ2dlciB0aGUgYGVtcHRpZWRgIGV2ZW50IHRoYXQgd2FzIHRyaWdnZXJlZCBieSB0aGUge0BsaW5rIFRlY2h9LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbWV0aG9kIFBsYXllciNoYW5kbGVUZWNoRW1wdGllZF9cbiAqIEBmaXJlcyBQbGF5ZXIjZW1wdGllZFxuICogQGxpc3RlbnMgVGVjaCNlbXB0aWVkXG4gKi9cbidlbXB0aWVkJyxcbi8qKlxuICogRmlyZXMgd2hlbiB0aGUgYnJvd3NlciBpcyB0cnlpbmcgdG8gZ2V0IG1lZGlhIGRhdGEsIGJ1dCBkYXRhIGlzIG5vdCBhdmFpbGFibGUuXG4gKlxuICogQGV2ZW50IFBsYXllciNzdGFsbGVkXG4gKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gKi9cbi8qKlxuICogUmV0cmlnZ2VyIHRoZSBgc3RhbGxlZGAgZXZlbnQgdGhhdCB3YXMgdHJpZ2dlcmVkIGJ5IHRoZSB7QGxpbmsgVGVjaH0uXG4gKlxuICogQHByaXZhdGVcbiAqIEBtZXRob2QgUGxheWVyI2hhbmRsZVRlY2hTdGFsbGVkX1xuICogQGZpcmVzIFBsYXllciNzdGFsbGVkXG4gKiBAbGlzdGVucyBUZWNoI3N0YWxsZWRcbiAqL1xuJ3N0YWxsZWQnLFxuXG4vKipcbiAqIEZpcmVzIHdoZW4gdGhlIGJyb3dzZXIgaGFzIGxvYWRlZCBtZXRhIGRhdGEgZm9yIHRoZSBhdWRpby92aWRlby5cbiAqXG4gKiBAZXZlbnQgUGxheWVyI2xvYWRlZG1ldGFkYXRhXG4gKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gKi9cbi8qKlxuICogUmV0cmlnZ2VyIHRoZSBgc3RhbGxlZGAgZXZlbnQgdGhhdCB3YXMgdHJpZ2dlcmVkIGJ5IHRoZSB7QGxpbmsgVGVjaH0uXG4gKlxuICogQHByaXZhdGVcbiAqIEBtZXRob2QgUGxheWVyI2hhbmRsZVRlY2hMb2FkZWRtZXRhZGF0YV9cbiAqIEBmaXJlcyBQbGF5ZXIjbG9hZGVkbWV0YWRhdGFcbiAqIEBsaXN0ZW5zIFRlY2gjbG9hZGVkbWV0YWRhdGFcbiAqL1xuJ2xvYWRlZG1ldGFkYXRhJyxcblxuLyoqXG4gKiBGaXJlcyB3aGVuIHRoZSBicm93c2VyIGhhcyBsb2FkZWQgdGhlIGN1cnJlbnQgZnJhbWUgb2YgdGhlIGF1ZGlvL3ZpZGVvLlxuICpcbiAqIEBldmVudCBQbGF5ZXIjbG9hZGVkZGF0YVxuICogQHR5cGUge2V2ZW50fVxuICovXG4vKipcbiAqIFJldHJpZ2dlciB0aGUgYGxvYWRlZGRhdGFgIGV2ZW50IHRoYXQgd2FzIHRyaWdnZXJlZCBieSB0aGUge0BsaW5rIFRlY2h9LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbWV0aG9kIFBsYXllciNoYW5kbGVUZWNoTG9hZGRlZGRhdGFfXG4gKiBAZmlyZXMgUGxheWVyI2xvYWRlZGRhdGFcbiAqIEBsaXN0ZW5zIFRlY2gjbG9hZGVkZGF0YVxuICovXG4nbG9hZGVkZGF0YScsXG5cbi8qKlxuICogRmlyZXMgd2hlbiB0aGUgY3VycmVudCBwbGF5YmFjayBwb3NpdGlvbiBoYXMgY2hhbmdlZC5cbiAqXG4gKiBAZXZlbnQgUGxheWVyI3RpbWV1cGRhdGVcbiAqIEB0eXBlIHtldmVudH1cbiAqL1xuLyoqXG4gKiBSZXRyaWdnZXIgdGhlIGB0aW1ldXBkYXRlYCBldmVudCB0aGF0IHdhcyB0cmlnZ2VyZWQgYnkgdGhlIHtAbGluayBUZWNofS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG1ldGhvZCBQbGF5ZXIjaGFuZGxlVGVjaFRpbWVVcGRhdGVfXG4gKiBAZmlyZXMgUGxheWVyI3RpbWV1cGRhdGVcbiAqIEBsaXN0ZW5zIFRlY2gjdGltZXVwZGF0ZVxuICovXG4ndGltZXVwZGF0ZScsXG5cbi8qKlxuICogRmlyZXMgd2hlbiB0aGUgdmlkZW8ncyBpbnRyaW5zaWMgZGltZW5zaW9ucyBjaGFuZ2VcbiAqXG4gKiBAZXZlbnQgUGxheWVyI3Jlc2l6ZVxuICogQHR5cGUge2V2ZW50fVxuICovXG4vKipcbiAqIFJldHJpZ2dlciB0aGUgYHJlc2l6ZWAgZXZlbnQgdGhhdCB3YXMgdHJpZ2dlcmVkIGJ5IHRoZSB7QGxpbmsgVGVjaH0uXG4gKlxuICogQHByaXZhdGVcbiAqIEBtZXRob2QgUGxheWVyI2hhbmRsZVRlY2hSZXNpemVfXG4gKiBAZmlyZXMgUGxheWVyI3Jlc2l6ZVxuICogQGxpc3RlbnMgVGVjaCNyZXNpemVcbiAqL1xuJ3Jlc2l6ZScsXG5cbi8qKlxuICogRmlyZXMgd2hlbiB0aGUgdm9sdW1lIGhhcyBiZWVuIGNoYW5nZWRcbiAqXG4gKiBAZXZlbnQgUGxheWVyI3ZvbHVtZWNoYW5nZVxuICogQHR5cGUge2V2ZW50fVxuICovXG4vKipcbiAqIFJldHJpZ2dlciB0aGUgYHZvbHVtZWNoYW5nZWAgZXZlbnQgdGhhdCB3YXMgdHJpZ2dlcmVkIGJ5IHRoZSB7QGxpbmsgVGVjaH0uXG4gKlxuICogQHByaXZhdGVcbiAqIEBtZXRob2QgUGxheWVyI2hhbmRsZVRlY2hWb2x1bWVjaGFuZ2VfXG4gKiBAZmlyZXMgUGxheWVyI3ZvbHVtZWNoYW5nZVxuICogQGxpc3RlbnMgVGVjaCN2b2x1bWVjaGFuZ2VcbiAqL1xuJ3ZvbHVtZWNoYW5nZScsXG5cbi8qKlxuICogRmlyZXMgd2hlbiB0aGUgdGV4dCB0cmFjayBoYXMgYmVlbiBjaGFuZ2VkXG4gKlxuICogQGV2ZW50IFBsYXllciN0ZXh0dHJhY2tjaGFuZ2VcbiAqIEB0eXBlIHtldmVudH1cbiAqL1xuLyoqXG4gKiBSZXRyaWdnZXIgdGhlIGB0ZXh0dHJhY2tjaGFuZ2VgIGV2ZW50IHRoYXQgd2FzIHRyaWdnZXJlZCBieSB0aGUge0BsaW5rIFRlY2h9LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbWV0aG9kIFBsYXllciNoYW5kbGVUZWNoVGV4dHRyYWNrY2hhbmdlX1xuICogQGZpcmVzIFBsYXllciN0ZXh0dHJhY2tjaGFuZ2VcbiAqIEBsaXN0ZW5zIFRlY2gjdGV4dHRyYWNrY2hhbmdlXG4gKi9cbid0ZXh0dHJhY2tjaGFuZ2UnXTtcblxuLy8gZXZlbnRzIHRvIHF1ZXVlIHdoZW4gcGxheWJhY2sgcmF0ZSBpcyB6ZXJvXG4vLyB0aGlzIGlzIGEgaGFzaCBmb3IgdGhlIHNvbGUgcHVycG9zZSBvZiBtYXBwaW5nIG5vbi1jYW1lbC1jYXNlZCBldmVudCBuYW1lc1xuLy8gdG8gY2FtZWwtY2FzZWQgZnVuY3Rpb24gbmFtZXNcbnZhciBURUNIX0VWRU5UU19RVUVVRSA9IHtcbiAgY2FucGxheTogJ0NhblBsYXknLFxuICBjYW5wbGF5dGhyb3VnaDogJ0NhblBsYXlUaHJvdWdoJyxcbiAgcGxheWluZzogJ1BsYXlpbmcnLFxuICBzZWVrZWQ6ICdTZWVrZWQnXG59O1xuXG52YXIgQlJFQUtQT0lOVF9PUkRFUiA9IFsndGlueScsICd4c21hbGwnLCAnc21hbGwnLCAnbWVkaXVtJywgJ2xhcmdlJywgJ3hsYXJnZScsICdodWdlJ107XG5cbnZhciBCUkVBS1BPSU5UX0NMQVNTRVMgPSB7fTtcblxuLy8gZ3JlcDogdmpzLWxheW91dC10aW55XG4vLyBncmVwOiB2anMtbGF5b3V0LXgtc21hbGxcbi8vIGdyZXA6IHZqcy1sYXlvdXQtc21hbGxcbi8vIGdyZXA6IHZqcy1sYXlvdXQtbWVkaXVtXG4vLyBncmVwOiB2anMtbGF5b3V0LWxhcmdlXG4vLyBncmVwOiB2anMtbGF5b3V0LXgtbGFyZ2Vcbi8vIGdyZXA6IHZqcy1sYXlvdXQtaHVnZVxuQlJFQUtQT0lOVF9PUkRFUi5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gIHZhciB2ID0gay5jaGFyQXQoMCkgPT09ICd4JyA/ICd4LScgKyBrLnN1YnN0cmluZygxKSA6IGs7XG5cbiAgQlJFQUtQT0lOVF9DTEFTU0VTW2tdID0gJ3Zqcy1sYXlvdXQtJyArIHY7XG59KTtcblxudmFyIERFRkFVTFRfQlJFQUtQT0lOVFMgPSB7XG4gIHRpbnk6IDIxMCxcbiAgeHNtYWxsOiAzMjAsXG4gIHNtYWxsOiA0MjUsXG4gIG1lZGl1bTogNzY4LFxuICBsYXJnZTogMTQ0MCxcbiAgeGxhcmdlOiAyNTYwLFxuICBodWdlOiBJbmZpbml0eVxufTtcblxuLyoqXG4gKiBBbiBpbnN0YW5jZSBvZiB0aGUgYFBsYXllcmAgY2xhc3MgaXMgY3JlYXRlZCB3aGVuIGFueSBvZiB0aGUgVmlkZW8uanMgc2V0dXAgbWV0aG9kc1xuICogYXJlIHVzZWQgdG8gaW5pdGlhbGl6ZSBhIHZpZGVvLlxuICpcbiAqIEFmdGVyIGFuIGluc3RhbmNlIGhhcyBiZWVuIGNyZWF0ZWQgaXQgY2FuIGJlIGFjY2Vzc2VkIGdsb2JhbGx5IGluIHR3byB3YXlzOlxuICogMS4gQnkgY2FsbGluZyBgdmlkZW9qcygnZXhhbXBsZV92aWRlb18xJyk7YFxuICogMi4gQnkgdXNpbmcgaXQgZGlyZWN0bHkgdmlhICBgdmlkZW9qcy5wbGF5ZXJzLmV4YW1wbGVfdmlkZW9fMTtgXG4gKlxuICogQGV4dGVuZHMgQ29tcG9uZW50XG4gKi9cblxudmFyIFBsYXllciA9IGZ1bmN0aW9uIChfQ29tcG9uZW50KSB7XG4gIGluaGVyaXRzKFBsYXllciwgX0NvbXBvbmVudCk7XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IHRhZ1xuICAgKiAgICAgICAgVGhlIG9yaWdpbmFsIHZpZGVvIERPTSBlbGVtZW50IHVzZWQgZm9yIGNvbmZpZ3VyaW5nIG9wdGlvbnMuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICAgICAgIE9iamVjdCBvZiBvcHRpb24gbmFtZXMgYW5kIHZhbHVlcy5cbiAgICpcbiAgICogQHBhcmFtIHtDb21wb25lbnR+UmVhZHlDYWxsYmFja30gW3JlYWR5XVxuICAgKiAgICAgICAgUmVhZHkgY2FsbGJhY2sgZnVuY3Rpb24uXG4gICAqL1xuICBmdW5jdGlvbiBQbGF5ZXIodGFnLCBvcHRpb25zLCByZWFkeSkge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFBsYXllcik7XG5cbiAgICAvLyBNYWtlIHN1cmUgdGFnIElEIGV4aXN0c1xuICAgIHRhZy5pZCA9IHRhZy5pZCB8fCBvcHRpb25zLmlkIHx8ICd2anNfdmlkZW9fJyArIG5ld0dVSUQoKTtcblxuICAgIC8vIFNldCBPcHRpb25zXG4gICAgLy8gVGhlIG9wdGlvbnMgYXJndW1lbnQgb3ZlcnJpZGVzIG9wdGlvbnMgc2V0IGluIHRoZSB2aWRlbyB0YWdcbiAgICAvLyB3aGljaCBvdmVycmlkZXMgZ2xvYmFsbHkgc2V0IG9wdGlvbnMuXG4gICAgLy8gVGhpcyBsYXR0ZXIgcGFydCBjb2luY2lkZXMgd2l0aCB0aGUgbG9hZCBvcmRlclxuICAgIC8vICh0YWcgbXVzdCBleGlzdCBiZWZvcmUgUGxheWVyKVxuICAgIG9wdGlvbnMgPSBhc3NpZ24oUGxheWVyLmdldFRhZ1NldHRpbmdzKHRhZyksIG9wdGlvbnMpO1xuXG4gICAgLy8gRGVsYXkgdGhlIGluaXRpYWxpemF0aW9uIG9mIGNoaWxkcmVuIGJlY2F1c2Ugd2UgbmVlZCB0byBzZXQgdXBcbiAgICAvLyBwbGF5ZXIgcHJvcGVydGllcyBmaXJzdCwgYW5kIGNhbid0IHVzZSBgdGhpc2AgYmVmb3JlIGBzdXBlcigpYFxuICAgIG9wdGlvbnMuaW5pdENoaWxkcmVuID0gZmFsc2U7XG5cbiAgICAvLyBTYW1lIHdpdGggY3JlYXRpbmcgdGhlIGVsZW1lbnRcbiAgICBvcHRpb25zLmNyZWF0ZUVsID0gZmFsc2U7XG5cbiAgICAvLyBkb24ndCBhdXRvIG1peGluIHRoZSBldmVudGVkIG1peGluXG4gICAgb3B0aW9ucy5ldmVudGVkID0gZmFsc2U7XG5cbiAgICAvLyB3ZSBkb24ndCB3YW50IHRoZSBwbGF5ZXIgdG8gcmVwb3J0IHRvdWNoIGFjdGl2aXR5IG9uIGl0c2VsZlxuICAgIC8vIHNlZSBlbmFibGVUb3VjaEFjdGl2aXR5IGluIENvbXBvbmVudFxuICAgIG9wdGlvbnMucmVwb3J0VG91Y2hBY3Rpdml0eSA9IGZhbHNlO1xuXG4gICAgLy8gSWYgbGFuZ3VhZ2UgaXMgbm90IHNldCwgZ2V0IHRoZSBjbG9zZXN0IGxhbmcgYXR0cmlidXRlXG4gICAgaWYgKCFvcHRpb25zLmxhbmd1YWdlKSB7XG4gICAgICBpZiAodHlwZW9mIHRhZy5jbG9zZXN0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHZhciBjbG9zZXN0ID0gdGFnLmNsb3Nlc3QoJ1tsYW5nXScpO1xuXG4gICAgICAgIGlmIChjbG9zZXN0ICYmIGNsb3Nlc3QuZ2V0QXR0cmlidXRlKSB7XG4gICAgICAgICAgb3B0aW9ucy5sYW5ndWFnZSA9IGNsb3Nlc3QuZ2V0QXR0cmlidXRlKCdsYW5nJyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBlbGVtZW50ID0gdGFnO1xuXG4gICAgICAgIHdoaWxlIChlbGVtZW50ICYmIGVsZW1lbnQubm9kZVR5cGUgPT09IDEpIHtcbiAgICAgICAgICBpZiAoZ2V0QXR0cmlidXRlcyhlbGVtZW50KS5oYXNPd25Qcm9wZXJ0eSgnbGFuZycpKSB7XG4gICAgICAgICAgICBvcHRpb25zLmxhbmd1YWdlID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2xhbmcnKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbGVtZW50ID0gZWxlbWVudC5wYXJlbnROb2RlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUnVuIGJhc2UgY29tcG9uZW50IGluaXRpYWxpemluZyB3aXRoIG5ldyBvcHRpb25zXG5cbiAgICAvLyBjcmVhdGUgbG9nZ2VyXG4gICAgdmFyIF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfQ29tcG9uZW50LmNhbGwodGhpcywgbnVsbCwgb3B0aW9ucywgcmVhZHkpKTtcblxuICAgIF90aGlzLmxvZyA9IGNyZWF0ZUxvZ2dlcihfdGhpcy5pZF8pO1xuXG4gICAgLy8gVHJhY2tzIHdoZW4gYSB0ZWNoIGNoYW5nZXMgdGhlIHBvc3RlclxuICAgIF90aGlzLmlzUG9zdGVyRnJvbVRlY2hfID0gZmFsc2U7XG5cbiAgICAvLyBIb2xkcyBjYWxsYmFjayBpbmZvIHRoYXQgZ2V0cyBxdWV1ZWQgd2hlbiBwbGF5YmFjayByYXRlIGlzIHplcm9cbiAgICAvLyBhbmQgYSBzZWVrIGlzIGhhcHBlbmluZ1xuICAgIF90aGlzLnF1ZXVlZENhbGxiYWNrc18gPSBbXTtcblxuICAgIC8vIFR1cm4gb2ZmIEFQSSBhY2Nlc3MgYmVjYXVzZSB3ZSdyZSBsb2FkaW5nIGEgbmV3IHRlY2ggdGhhdCBtaWdodCBsb2FkIGFzeW5jaHJvbm91c2x5XG4gICAgX3RoaXMuaXNSZWFkeV8gPSBmYWxzZTtcblxuICAgIC8vIEluaXQgc3RhdGUgaGFzU3RhcnRlZF9cbiAgICBfdGhpcy5oYXNTdGFydGVkXyA9IGZhbHNlO1xuXG4gICAgLy8gSW5pdCBzdGF0ZSB1c2VyQWN0aXZlX1xuICAgIF90aGlzLnVzZXJBY3RpdmVfID0gZmFsc2U7XG5cbiAgICAvLyBpZiB0aGUgZ2xvYmFsIG9wdGlvbiBvYmplY3Qgd2FzIGFjY2lkZW50YWxseSBibG93biBhd2F5IGJ5XG4gICAgLy8gc29tZW9uZSwgYmFpbCBlYXJseSB3aXRoIGFuIGluZm9ybWF0aXZlIGVycm9yXG4gICAgaWYgKCFfdGhpcy5vcHRpb25zXyB8fCAhX3RoaXMub3B0aW9uc18udGVjaE9yZGVyIHx8ICFfdGhpcy5vcHRpb25zXy50ZWNoT3JkZXIubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHRlY2hPcmRlciBzcGVjaWZpZWQuIERpZCB5b3Ugb3ZlcndyaXRlICcgKyAndmlkZW9qcy5vcHRpb25zIGluc3RlYWQgb2YganVzdCBjaGFuZ2luZyB0aGUgJyArICdwcm9wZXJ0aWVzIHlvdSB3YW50IHRvIG92ZXJyaWRlPycpO1xuICAgIH1cblxuICAgIC8vIFN0b3JlIHRoZSBvcmlnaW5hbCB0YWcgdXNlZCB0byBzZXQgb3B0aW9uc1xuICAgIF90aGlzLnRhZyA9IHRhZztcblxuICAgIC8vIFN0b3JlIHRoZSB0YWcgYXR0cmlidXRlcyB1c2VkIHRvIHJlc3RvcmUgaHRtbDUgZWxlbWVudFxuICAgIF90aGlzLnRhZ0F0dHJpYnV0ZXMgPSB0YWcgJiYgZ2V0QXR0cmlidXRlcyh0YWcpO1xuXG4gICAgLy8gVXBkYXRlIGN1cnJlbnQgbGFuZ3VhZ2VcbiAgICBfdGhpcy5sYW5ndWFnZShfdGhpcy5vcHRpb25zXy5sYW5ndWFnZSk7XG5cbiAgICAvLyBVcGRhdGUgU3VwcG9ydGVkIExhbmd1YWdlc1xuICAgIGlmIChvcHRpb25zLmxhbmd1YWdlcykge1xuICAgICAgLy8gTm9ybWFsaXNlIHBsYXllciBvcHRpb24gbGFuZ3VhZ2VzIHRvIGxvd2VyY2FzZVxuICAgICAgdmFyIGxhbmd1YWdlc1RvTG93ZXIgPSB7fTtcblxuICAgICAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMob3B0aW9ucy5sYW5ndWFnZXMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUkJDEpIHtcbiAgICAgICAgbGFuZ3VhZ2VzVG9Mb3dlcltuYW1lJCQxLnRvTG93ZXJDYXNlKCldID0gb3B0aW9ucy5sYW5ndWFnZXNbbmFtZSQkMV07XG4gICAgICB9KTtcbiAgICAgIF90aGlzLmxhbmd1YWdlc18gPSBsYW5ndWFnZXNUb0xvd2VyO1xuICAgIH0gZWxzZSB7XG4gICAgICBfdGhpcy5sYW5ndWFnZXNfID0gUGxheWVyLnByb3RvdHlwZS5vcHRpb25zXy5sYW5ndWFnZXM7XG4gICAgfVxuXG4gICAgLy8gQ2FjaGUgZm9yIHZpZGVvIHByb3BlcnR5IHZhbHVlcy5cbiAgICBfdGhpcy5jYWNoZV8gPSB7fTtcblxuICAgIC8vIFNldCBwb3N0ZXJcbiAgICBfdGhpcy5wb3N0ZXJfID0gb3B0aW9ucy5wb3N0ZXIgfHwgJyc7XG5cbiAgICAvLyBTZXQgY29udHJvbHNcbiAgICBfdGhpcy5jb250cm9sc18gPSAhIW9wdGlvbnMuY29udHJvbHM7XG5cbiAgICAvLyBTZXQgZGVmYXVsdCB2YWx1ZXMgZm9yIGxhc3RWb2x1bWVcbiAgICBfdGhpcy5jYWNoZV8ubGFzdFZvbHVtZSA9IDE7XG5cbiAgICAvLyBPcmlnaW5hbCB0YWcgc2V0dGluZ3Mgc3RvcmVkIGluIG9wdGlvbnNcbiAgICAvLyBub3cgcmVtb3ZlIGltbWVkaWF0ZWx5IHNvIG5hdGl2ZSBjb250cm9scyBkb24ndCBmbGFzaC5cbiAgICAvLyBNYXkgYmUgdHVybmVkIGJhY2sgb24gYnkgSFRNTDUgdGVjaCBpZiBuYXRpdmVDb250cm9sc0ZvclRvdWNoIGlzIHRydWVcbiAgICB0YWcuY29udHJvbHMgPSBmYWxzZTtcbiAgICB0YWcucmVtb3ZlQXR0cmlidXRlKCdjb250cm9scycpO1xuXG4gICAgLy8gdGhlIGF0dHJpYnV0ZSBvdmVycmlkZXMgdGhlIG9wdGlvblxuICAgIGlmICh0YWcuaGFzQXR0cmlidXRlKCdhdXRvcGxheScpKSB7XG4gICAgICBfdGhpcy5vcHRpb25zXy5hdXRvcGxheSA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIG90aGVyd2lzZSB1c2UgdGhlIHNldHRlciB0byB2YWxpZGF0ZSBhbmRcbiAgICAgIC8vIHNldCB0aGUgY29ycmVjdCB2YWx1ZS5cbiAgICAgIF90aGlzLmF1dG9wbGF5KF90aGlzLm9wdGlvbnNfLmF1dG9wbGF5KTtcbiAgICB9XG5cbiAgICAvKlxuICAgICAqIFN0b3JlIHRoZSBpbnRlcm5hbCBzdGF0ZSBvZiBzY3J1YmJpbmdcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgdXNlciBpcyBzY3J1YmJpbmdcbiAgICAgKi9cbiAgICBfdGhpcy5zY3J1YmJpbmdfID0gZmFsc2U7XG5cbiAgICBfdGhpcy5lbF8gPSBfdGhpcy5jcmVhdGVFbCgpO1xuXG4gICAgLy8gU2V0IGRlZmF1bHQgdmFsdWUgZm9yIGxhc3RQbGF5YmFja1JhdGVcbiAgICBfdGhpcy5jYWNoZV8ubGFzdFBsYXliYWNrUmF0ZSA9IF90aGlzLmRlZmF1bHRQbGF5YmFja1JhdGUoKTtcblxuICAgIC8vIE1ha2UgdGhpcyBhbiBldmVudGVkIG9iamVjdCBhbmQgdXNlIGBlbF9gIGFzIGl0cyBldmVudCBidXMuXG4gICAgZXZlbnRlZChfdGhpcywgeyBldmVudEJ1c0tleTogJ2VsXycgfSk7XG5cbiAgICAvLyBXZSBhbHNvIHdhbnQgdG8gcGFzcyB0aGUgb3JpZ2luYWwgcGxheWVyIG9wdGlvbnMgdG8gZWFjaCBjb21wb25lbnQgYW5kIHBsdWdpblxuICAgIC8vIGFzIHdlbGwgc28gdGhleSBkb24ndCBuZWVkIHRvIHJlYWNoIGJhY2sgaW50byB0aGUgcGxheWVyIGZvciBvcHRpb25zIGxhdGVyLlxuICAgIC8vIFdlIGFsc28gbmVlZCB0byBkbyBhbm90aGVyIGNvcHkgb2YgdGhpcy5vcHRpb25zXyBzbyB3ZSBkb24ndCBlbmQgdXAgd2l0aFxuICAgIC8vIGFuIGluZmluaXRlIGxvb3AuXG4gICAgdmFyIHBsYXllck9wdGlvbnNDb3B5ID0gbWVyZ2VPcHRpb25zKF90aGlzLm9wdGlvbnNfKTtcblxuICAgIC8vIExvYWQgcGx1Z2luc1xuICAgIGlmIChvcHRpb25zLnBsdWdpbnMpIHtcbiAgICAgIHZhciBwbHVnaW5zID0gb3B0aW9ucy5wbHVnaW5zO1xuXG4gICAgICBPYmplY3Qua2V5cyhwbHVnaW5zKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lJCQxKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpc1tuYW1lJCQxXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHRoaXNbbmFtZSQkMV0ocGx1Z2luc1tuYW1lJCQxXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwbHVnaW4gXCInICsgbmFtZSQkMSArICdcIiBkb2VzIG5vdCBleGlzdCcpO1xuICAgICAgICB9XG4gICAgICB9LCBfdGhpcyk7XG4gICAgfVxuXG4gICAgX3RoaXMub3B0aW9uc18ucGxheWVyT3B0aW9ucyA9IHBsYXllck9wdGlvbnNDb3B5O1xuXG4gICAgX3RoaXMubWlkZGxld2FyZV8gPSBbXTtcblxuICAgIF90aGlzLmluaXRDaGlsZHJlbigpO1xuXG4gICAgLy8gU2V0IGlzQXVkaW8gYmFzZWQgb24gd2hldGhlciBvciBub3QgYW4gYXVkaW8gdGFnIHdhcyB1c2VkXG4gICAgX3RoaXMuaXNBdWRpbyh0YWcubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2F1ZGlvJyk7XG5cbiAgICAvLyBVcGRhdGUgY29udHJvbHMgY2xhc3NOYW1lLiBDYW4ndCBkbyB0aGlzIHdoZW4gdGhlIGNvbnRyb2xzIGFyZSBpbml0aWFsbHlcbiAgICAvLyBzZXQgYmVjYXVzZSB0aGUgZWxlbWVudCBkb2Vzbid0IGV4aXN0IHlldC5cbiAgICBpZiAoX3RoaXMuY29udHJvbHMoKSkge1xuICAgICAgX3RoaXMuYWRkQ2xhc3MoJ3Zqcy1jb250cm9scy1lbmFibGVkJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIF90aGlzLmFkZENsYXNzKCd2anMtY29udHJvbHMtZGlzYWJsZWQnKTtcbiAgICB9XG5cbiAgICAvLyBTZXQgQVJJQSBsYWJlbCBhbmQgcmVnaW9uIHJvbGUgZGVwZW5kaW5nIG9uIHBsYXllciB0eXBlXG4gICAgX3RoaXMuZWxfLnNldEF0dHJpYnV0ZSgncm9sZScsICdyZWdpb24nKTtcbiAgICBpZiAoX3RoaXMuaXNBdWRpbygpKSB7XG4gICAgICBfdGhpcy5lbF8uc2V0QXR0cmlidXRlKCdhcmlhLWxhYmVsJywgX3RoaXMubG9jYWxpemUoJ0F1ZGlvIFBsYXllcicpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgX3RoaXMuZWxfLnNldEF0dHJpYnV0ZSgnYXJpYS1sYWJlbCcsIF90aGlzLmxvY2FsaXplKCdWaWRlbyBQbGF5ZXInKSk7XG4gICAgfVxuXG4gICAgaWYgKF90aGlzLmlzQXVkaW8oKSkge1xuICAgICAgX3RoaXMuYWRkQ2xhc3MoJ3Zqcy1hdWRpbycpO1xuICAgIH1cblxuICAgIGlmIChfdGhpcy5mbGV4Tm90U3VwcG9ydGVkXygpKSB7XG4gICAgICBfdGhpcy5hZGRDbGFzcygndmpzLW5vLWZsZXgnKTtcbiAgICB9XG5cbiAgICAvLyBUT0RPOiBNYWtlIHRoaXMgc21hcnRlci4gVG9nZ2xlIHVzZXIgc3RhdGUgYmV0d2VlbiB0b3VjaGluZy9tb3VzaW5nXG4gICAgLy8gdXNpbmcgZXZlbnRzLCBzaW5jZSBkZXZpY2VzIGNhbiBoYXZlIGJvdGggdG91Y2ggYW5kIG1vdXNlIGV2ZW50cy5cbiAgICAvLyBpZiAoYnJvd3Nlci5UT1VDSF9FTkFCTEVEKSB7XG4gICAgLy8gICB0aGlzLmFkZENsYXNzKCd2anMtdG91Y2gtZW5hYmxlZCcpO1xuICAgIC8vIH1cblxuICAgIC8vIGlPUyBTYWZhcmkgaGFzIGJyb2tlbiBob3ZlciBoYW5kbGluZ1xuICAgIGlmICghSVNfSU9TKSB7XG4gICAgICBfdGhpcy5hZGRDbGFzcygndmpzLXdvcmtpbmdob3ZlcicpO1xuICAgIH1cblxuICAgIC8vIE1ha2UgcGxheWVyIGVhc2lseSBmaW5kYWJsZSBieSBJRFxuICAgIFBsYXllci5wbGF5ZXJzW190aGlzLmlkX10gPSBfdGhpcztcblxuICAgIC8vIEFkZCBhIG1ham9yIHZlcnNpb24gY2xhc3MgdG8gYWlkIGNzcyBpbiBwbHVnaW5zXG4gICAgdmFyIG1ham9yVmVyc2lvbiA9IHZlcnNpb24uc3BsaXQoJy4nKVswXTtcblxuICAgIF90aGlzLmFkZENsYXNzKCd2anMtdicgKyBtYWpvclZlcnNpb24pO1xuXG4gICAgLy8gV2hlbiB0aGUgcGxheWVyIGlzIGZpcnN0IGluaXRpYWxpemVkLCB0cmlnZ2VyIGFjdGl2aXR5IHNvIGNvbXBvbmVudHNcbiAgICAvLyBsaWtlIHRoZSBjb250cm9sIGJhciBzaG93IHRoZW1zZWx2ZXMgaWYgbmVlZGVkXG4gICAgX3RoaXMudXNlckFjdGl2ZSh0cnVlKTtcbiAgICBfdGhpcy5yZXBvcnRVc2VyQWN0aXZpdHkoKTtcblxuICAgIF90aGlzLm9uZSgncGxheScsIF90aGlzLmxpc3RlbkZvclVzZXJBY3Rpdml0eV8pO1xuICAgIF90aGlzLm9uKCdmdWxsc2NyZWVuY2hhbmdlJywgX3RoaXMuaGFuZGxlRnVsbHNjcmVlbkNoYW5nZV8pO1xuICAgIF90aGlzLm9uKCdzdGFnZWNsaWNrJywgX3RoaXMuaGFuZGxlU3RhZ2VDbGlja18pO1xuXG4gICAgX3RoaXMuYnJlYWtwb2ludHMoX3RoaXMub3B0aW9uc18uYnJlYWtwb2ludHMpO1xuICAgIF90aGlzLnJlc3BvbnNpdmUoX3RoaXMub3B0aW9uc18ucmVzcG9uc2l2ZSk7XG5cbiAgICBfdGhpcy5jaGFuZ2luZ1NyY18gPSBmYWxzZTtcbiAgICBfdGhpcy5wbGF5V2FpdGluZ0ZvclJlYWR5XyA9IGZhbHNlO1xuICAgIF90aGlzLnBsYXlPbkxvYWRzdGFydF8gPSBudWxsO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXN0cm95cyB0aGUgdmlkZW8gcGxheWVyIGFuZCBkb2VzIGFueSBuZWNlc3NhcnkgY2xlYW51cC5cbiAgICpcbiAgICogVGhpcyBpcyBlc3BlY2lhbGx5IGhlbHBmdWwgaWYgeW91IGFyZSBkeW5hbWljYWxseSBhZGRpbmcgYW5kIHJlbW92aW5nIHZpZGVvc1xuICAgKiB0by9mcm9tIHRoZSBET00uXG4gICAqXG4gICAqIEBmaXJlcyBQbGF5ZXIjZGlzcG9zZVxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW4gdGhlIHBsYXllciBpcyBiZWluZyBkaXNwb3NlZCBvZi5cbiAgICAgKlxuICAgICAqIEBldmVudCBQbGF5ZXIjZGlzcG9zZVxuICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAgICAgKi9cbiAgICB0aGlzLnRyaWdnZXIoJ2Rpc3Bvc2UnKTtcbiAgICAvLyBwcmV2ZW50IGRpc3Bvc2UgZnJvbSBiZWluZyBjYWxsZWQgdHdpY2VcbiAgICB0aGlzLm9mZignZGlzcG9zZScpO1xuXG4gICAgaWYgKHRoaXMuc3R5bGVFbF8gJiYgdGhpcy5zdHlsZUVsXy5wYXJlbnROb2RlKSB7XG4gICAgICB0aGlzLnN0eWxlRWxfLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5zdHlsZUVsXyk7XG4gICAgICB0aGlzLnN0eWxlRWxfID0gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBLaWxsIHJlZmVyZW5jZSB0byB0aGlzIHBsYXllclxuICAgIFBsYXllci5wbGF5ZXJzW3RoaXMuaWRfXSA9IG51bGw7XG5cbiAgICBpZiAodGhpcy50YWcgJiYgdGhpcy50YWcucGxheWVyKSB7XG4gICAgICB0aGlzLnRhZy5wbGF5ZXIgPSBudWxsO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmVsXyAmJiB0aGlzLmVsXy5wbGF5ZXIpIHtcbiAgICAgIHRoaXMuZWxfLnBsYXllciA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMudGVjaF8pIHtcbiAgICAgIHRoaXMudGVjaF8uZGlzcG9zZSgpO1xuICAgICAgdGhpcy5pc1Bvc3RlckZyb21UZWNoXyA9IGZhbHNlO1xuICAgICAgdGhpcy5wb3N0ZXJfID0gJyc7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMucGxheWVyRWxJbmdlc3RfKSB7XG4gICAgICB0aGlzLnBsYXllckVsSW5nZXN0XyA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMudGFnKSB7XG4gICAgICB0aGlzLnRhZyA9IG51bGw7XG4gICAgfVxuXG4gICAgY2xlYXJDYWNoZUZvclBsYXllcih0aGlzKTtcblxuICAgIC8vIHRoZSBhY3R1YWwgLmVsXyBpcyByZW1vdmVkIGhlcmVcbiAgICBfQ29tcG9uZW50LnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSB0aGUgYFBsYXllcmAncyBET00gZWxlbWVudC5cbiAgICpcbiAgICogQHJldHVybiB7RWxlbWVudH1cbiAgICogICAgICAgICBUaGUgRE9NIGVsZW1lbnQgdGhhdCBnZXRzIGNyZWF0ZWQuXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5jcmVhdGVFbCA9IGZ1bmN0aW9uIGNyZWF0ZUVsJCQxKCkge1xuICAgIHZhciB0YWcgPSB0aGlzLnRhZztcbiAgICB2YXIgZWwgPSB2b2lkIDA7XG4gICAgdmFyIHBsYXllckVsSW5nZXN0ID0gdGhpcy5wbGF5ZXJFbEluZ2VzdF8gPSB0YWcucGFyZW50Tm9kZSAmJiB0YWcucGFyZW50Tm9kZS5oYXNBdHRyaWJ1dGUgJiYgdGFnLnBhcmVudE5vZGUuaGFzQXR0cmlidXRlKCdkYXRhLXZqcy1wbGF5ZXInKTtcbiAgICB2YXIgZGl2RW1iZWQgPSB0aGlzLnRhZy50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICd2aWRlby1qcyc7XG5cbiAgICBpZiAocGxheWVyRWxJbmdlc3QpIHtcbiAgICAgIGVsID0gdGhpcy5lbF8gPSB0YWcucGFyZW50Tm9kZTtcbiAgICB9IGVsc2UgaWYgKCFkaXZFbWJlZCkge1xuICAgICAgZWwgPSB0aGlzLmVsXyA9IF9Db21wb25lbnQucHJvdG90eXBlLmNyZWF0ZUVsLmNhbGwodGhpcywgJ2RpdicpO1xuICAgIH1cblxuICAgIC8vIENvcHkgb3ZlciBhbGwgdGhlIGF0dHJpYnV0ZXMgZnJvbSB0aGUgdGFnLCBpbmNsdWRpbmcgSUQgYW5kIGNsYXNzXG4gICAgLy8gSUQgd2lsbCBub3cgcmVmZXJlbmNlIHBsYXllciBib3gsIG5vdCB0aGUgdmlkZW8gdGFnXG4gICAgdmFyIGF0dHJzID0gZ2V0QXR0cmlidXRlcyh0YWcpO1xuXG4gICAgaWYgKGRpdkVtYmVkKSB7XG4gICAgICBlbCA9IHRoaXMuZWxfID0gdGFnO1xuICAgICAgdGFnID0gdGhpcy50YWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd2aWRlbycpO1xuICAgICAgd2hpbGUgKGVsLmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICB0YWcuYXBwZW5kQ2hpbGQoZWwuZmlyc3RDaGlsZCk7XG4gICAgICB9XG5cbiAgICAgIGlmICghaGFzQ2xhc3MoZWwsICd2aWRlby1qcycpKSB7XG4gICAgICAgIGFkZENsYXNzKGVsLCAndmlkZW8tanMnKTtcbiAgICAgIH1cblxuICAgICAgZWwuYXBwZW5kQ2hpbGQodGFnKTtcblxuICAgICAgcGxheWVyRWxJbmdlc3QgPSB0aGlzLnBsYXllckVsSW5nZXN0XyA9IGVsO1xuXG4gICAgICAvLyBjb3B5IG92ZXIgcHJvcGVydGllcyBmcm9tIHRoZSB2aWRlby1qcyBlbGVtZW50XG4gICAgICAvLyBpZTggZG9lc24ndCBzdXBwb3J0IE9iamVjdC5rZXlzIG5vciBoYXNPd25Qcm9wZXJ0eVxuICAgICAgLy8gb24gZG9tIGVsZW1lbnRzIHNvIHdlIGhhdmUgdG8gc3BlY2lmeSBwcm9wZXJ0aWVzIGluZGl2aWR1YWxseVxuICAgICAgWydhdXRvcGxheScsICdjb250cm9scycsICdjcm9zc09yaWdpbicsICdkZWZhdWx0TXV0ZWQnLCAnZGVmYXVsdFBsYXliYWNrUmF0ZScsICdsb29wJywgJ211dGVkJywgJ3BsYXliYWNrUmF0ZScsICdzcmMnLCAndm9sdW1lJ10uZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgICAgICBpZiAodHlwZW9mIGVsW3Byb3BdICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHRhZ1twcm9wXSA9IGVsW3Byb3BdO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBzZXQgdGFiaW5kZXggdG8gLTEgdG8gcmVtb3ZlIHRoZSB2aWRlbyBlbGVtZW50IGZyb20gdGhlIGZvY3VzIG9yZGVyXG4gICAgdGFnLnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCAnLTEnKTtcbiAgICBhdHRycy50YWJpbmRleCA9ICctMSc7XG5cbiAgICAvLyBXb3JrYXJvdW5kIGZvciAjNDU4MyAoSkFXUytJRSBkb2Vzbid0IGFubm91bmNlIEJQQiBvciBwbGF5IGJ1dHRvbilcbiAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL0ZyZWVkb21TY2llbnRpZmljL1ZGTy1zdGFuZGFyZHMtc3VwcG9ydC9pc3N1ZXMvNzhcbiAgICAvLyBOb3RlIHRoYXQgd2UgY2FuJ3QgZGV0ZWN0IGlmIEpBV1MgaXMgYmVpbmcgdXNlZCwgYnV0IHRoaXMgQVJJQSBhdHRyaWJ1dGVcbiAgICAvLyAgZG9lc24ndCBjaGFuZ2UgYmVoYXZpb3Igb2YgSUUxMSBpZiBKQVdTIGlzIG5vdCBiZWluZyB1c2VkXG4gICAgaWYgKElFX1ZFUlNJT04pIHtcbiAgICAgIHRhZy5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCAnYXBwbGljYXRpb24nKTtcbiAgICAgIGF0dHJzLnJvbGUgPSAnYXBwbGljYXRpb24nO1xuICAgIH1cblxuICAgIC8vIFJlbW92ZSB3aWR0aC9oZWlnaHQgYXR0cnMgZnJvbSB0YWcgc28gQ1NTIGNhbiBtYWtlIGl0IDEwMCUgd2lkdGgvaGVpZ2h0XG4gICAgdGFnLnJlbW92ZUF0dHJpYnV0ZSgnd2lkdGgnKTtcbiAgICB0YWcucmVtb3ZlQXR0cmlidXRlKCdoZWlnaHQnKTtcblxuICAgIGlmICgnd2lkdGgnIGluIGF0dHJzKSB7XG4gICAgICBkZWxldGUgYXR0cnMud2lkdGg7XG4gICAgfVxuICAgIGlmICgnaGVpZ2h0JyBpbiBhdHRycykge1xuICAgICAgZGVsZXRlIGF0dHJzLmhlaWdodDtcbiAgICB9XG5cbiAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhhdHRycykuZm9yRWFjaChmdW5jdGlvbiAoYXR0cikge1xuICAgICAgLy8gd29ya2Fyb3VuZCBzbyB3ZSBkb24ndCB0b3RhbGx5IGJyZWFrIElFN1xuICAgICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8zNjUzNDQ0L2Nzcy1zdHlsZXMtbm90LWFwcGxpZWQtb24tZHluYW1pYy1lbGVtZW50cy1pbi1pbnRlcm5ldC1leHBsb3Jlci03XG4gICAgICBpZiAoYXR0ciA9PT0gJ2NsYXNzJykge1xuICAgICAgICBlbC5jbGFzc05hbWUgKz0gJyAnICsgYXR0cnNbYXR0cl07XG5cbiAgICAgICAgaWYgKGRpdkVtYmVkKSB7XG4gICAgICAgICAgdGFnLmNsYXNzTmFtZSArPSAnICcgKyBhdHRyc1thdHRyXTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWwuc2V0QXR0cmlidXRlKGF0dHIsIGF0dHJzW2F0dHJdKTtcblxuICAgICAgICBpZiAoZGl2RW1iZWQpIHtcbiAgICAgICAgICB0YWcuc2V0QXR0cmlidXRlKGF0dHIsIGF0dHJzW2F0dHJdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gVXBkYXRlIHRhZyBpZC9jbGFzcyBmb3IgdXNlIGFzIEhUTUw1IHBsYXliYWNrIHRlY2hcbiAgICAvLyBNaWdodCB0aGluayB3ZSBzaG91bGQgZG8gdGhpcyBhZnRlciBlbWJlZGRpbmcgaW4gY29udGFpbmVyIHNvIC52anMtdGVjaCBjbGFzc1xuICAgIC8vIGRvZXNuJ3QgZmxhc2ggMTAwJSB3aWR0aC9oZWlnaHQsIGJ1dCBjbGFzcyBvbmx5IGFwcGxpZXMgd2l0aCAudmlkZW8tanMgcGFyZW50XG4gICAgdGFnLnBsYXllcklkID0gdGFnLmlkO1xuICAgIHRhZy5pZCArPSAnX2h0bWw1X2FwaSc7XG4gICAgdGFnLmNsYXNzTmFtZSA9ICd2anMtdGVjaCc7XG5cbiAgICAvLyBNYWtlIHBsYXllciBmaW5kYWJsZSBvbiBlbGVtZW50c1xuICAgIHRhZy5wbGF5ZXIgPSBlbC5wbGF5ZXIgPSB0aGlzO1xuICAgIC8vIERlZmF1bHQgc3RhdGUgb2YgdmlkZW8gaXMgcGF1c2VkXG4gICAgdGhpcy5hZGRDbGFzcygndmpzLXBhdXNlZCcpO1xuXG4gICAgLy8gQWRkIGEgc3R5bGUgZWxlbWVudCBpbiB0aGUgcGxheWVyIHRoYXQgd2UnbGwgdXNlIHRvIHNldCB0aGUgd2lkdGgvaGVpZ2h0XG4gICAgLy8gb2YgdGhlIHBsYXllciBpbiBhIHdheSB0aGF0J3Mgc3RpbGwgb3ZlcnJpZGVhYmxlIGJ5IENTUywganVzdCBsaWtlIHRoZVxuICAgIC8vIHZpZGVvIGVsZW1lbnRcbiAgICBpZiAod2luZG93LlZJREVPSlNfTk9fRFlOQU1JQ19TVFlMRSAhPT0gdHJ1ZSkge1xuICAgICAgdGhpcy5zdHlsZUVsXyA9IGNyZWF0ZVN0eWxlRWxlbWVudCgndmpzLXN0eWxlcy1kaW1lbnNpb25zJyk7XG4gICAgICB2YXIgZGVmYXVsdHNTdHlsZUVsID0gJCgnLnZqcy1zdHlsZXMtZGVmYXVsdHMnKTtcbiAgICAgIHZhciBoZWFkID0gJCgnaGVhZCcpO1xuXG4gICAgICBoZWFkLmluc2VydEJlZm9yZSh0aGlzLnN0eWxlRWxfLCBkZWZhdWx0c1N0eWxlRWwgPyBkZWZhdWx0c1N0eWxlRWwubmV4dFNpYmxpbmcgOiBoZWFkLmZpcnN0Q2hpbGQpO1xuICAgIH1cblxuICAgIHRoaXMuZmlsbF8gPSBmYWxzZTtcbiAgICB0aGlzLmZsdWlkXyA9IGZhbHNlO1xuXG4gICAgLy8gUGFzcyBpbiB0aGUgd2lkdGgvaGVpZ2h0L2FzcGVjdFJhdGlvIG9wdGlvbnMgd2hpY2ggd2lsbCB1cGRhdGUgdGhlIHN0eWxlIGVsXG4gICAgdGhpcy53aWR0aCh0aGlzLm9wdGlvbnNfLndpZHRoKTtcbiAgICB0aGlzLmhlaWdodCh0aGlzLm9wdGlvbnNfLmhlaWdodCk7XG4gICAgdGhpcy5maWxsKHRoaXMub3B0aW9uc18uZmlsbCk7XG4gICAgdGhpcy5mbHVpZCh0aGlzLm9wdGlvbnNfLmZsdWlkKTtcbiAgICB0aGlzLmFzcGVjdFJhdGlvKHRoaXMub3B0aW9uc18uYXNwZWN0UmF0aW8pO1xuXG4gICAgLy8gSGlkZSBhbnkgbGlua3Mgd2l0aGluIHRoZSB2aWRlby9hdWRpbyB0YWcsIGJlY2F1c2UgSUUgZG9lc24ndCBoaWRlIHRoZW0gY29tcGxldGVseS5cbiAgICB2YXIgbGlua3MgPSB0YWcuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2EnKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlua3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBsaW5rRWwgPSBsaW5rcy5pdGVtKGkpO1xuXG4gICAgICBhZGRDbGFzcyhsaW5rRWwsICd2anMtaGlkZGVuJyk7XG4gICAgICBsaW5rRWwuc2V0QXR0cmlidXRlKCdoaWRkZW4nLCAnaGlkZGVuJyk7XG4gICAgfVxuXG4gICAgLy8gaW5zZXJ0RWxGaXJzdCBzZWVtcyB0byBjYXVzZSB0aGUgbmV0d29ya1N0YXRlIHRvIGZsaWNrZXIgZnJvbSAzIHRvIDIsIHNvXG4gICAgLy8ga2VlcCB0cmFjayBvZiB0aGUgb3JpZ2luYWwgZm9yIGxhdGVyIHNvIHdlIGNhbiBrbm93IGlmIHRoZSBzb3VyY2Ugb3JpZ2luYWxseSBmYWlsZWRcbiAgICB0YWcuaW5pdE5ldHdvcmtTdGF0ZV8gPSB0YWcubmV0d29ya1N0YXRlO1xuXG4gICAgLy8gV3JhcCB2aWRlbyB0YWcgaW4gZGl2IChlbC9ib3gpIGNvbnRhaW5lclxuICAgIGlmICh0YWcucGFyZW50Tm9kZSAmJiAhcGxheWVyRWxJbmdlc3QpIHtcbiAgICAgIHRhZy5wYXJlbnROb2RlLmluc2VydEJlZm9yZShlbCwgdGFnKTtcbiAgICB9XG5cbiAgICAvLyBpbnNlcnQgdGhlIHRhZyBhcyB0aGUgZmlyc3QgY2hpbGQgb2YgdGhlIHBsYXllciBlbGVtZW50XG4gICAgLy8gdGhlbiBtYW51YWxseSBhZGQgaXQgdG8gdGhlIGNoaWxkcmVuIGFycmF5IHNvIHRoYXQgdGhpcy5hZGRDaGlsZFxuICAgIC8vIHdpbGwgd29yayBwcm9wZXJseSBmb3Igb3RoZXIgY29tcG9uZW50c1xuICAgIC8vXG4gICAgLy8gQnJlYWtzIGlQaG9uZSwgZml4ZWQgaW4gSFRNTDUgc2V0dXAuXG4gICAgcHJlcGVuZFRvKHRhZywgZWwpO1xuICAgIHRoaXMuY2hpbGRyZW5fLnVuc2hpZnQodGFnKTtcblxuICAgIC8vIFNldCBsYW5nIGF0dHIgb24gcGxheWVyIHRvIGVuc3VyZSBDU1MgOmxhbmcoKSBpbiBjb25zaXN0ZW50IHdpdGggcGxheWVyXG4gICAgLy8gaWYgaXQncyBiZWVuIHNldCB0byBzb21ldGhpbmcgZGlmZmVyZW50IHRvIHRoZSBkb2NcbiAgICB0aGlzLmVsXy5zZXRBdHRyaWJ1dGUoJ2xhbmcnLCB0aGlzLmxhbmd1YWdlXyk7XG5cbiAgICB0aGlzLmVsXyA9IGVsO1xuXG4gICAgcmV0dXJuIGVsO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBIGdldHRlci9zZXR0ZXIgZm9yIHRoZSBgUGxheWVyYCdzIHdpZHRoLiBSZXR1cm5zIHRoZSBwbGF5ZXIncyBjb25maWd1cmVkIHZhbHVlLlxuICAgKiBUbyBnZXQgdGhlIGN1cnJlbnQgd2lkdGggdXNlIGBjdXJyZW50V2lkdGgoKWAuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbdmFsdWVdXG4gICAqICAgICAgICBUaGUgdmFsdWUgdG8gc2V0IHRoZSBgUGxheWVyYCdzIHdpZHRoIHRvLlxuICAgKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqICAgICAgICAgVGhlIGN1cnJlbnQgd2lkdGggb2YgdGhlIGBQbGF5ZXJgIHdoZW4gZ2V0dGluZy5cbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLndpZHRoID0gZnVuY3Rpb24gd2lkdGgodmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5kaW1lbnNpb24oJ3dpZHRoJywgdmFsdWUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBIGdldHRlci9zZXR0ZXIgZm9yIHRoZSBgUGxheWVyYCdzIGhlaWdodC4gUmV0dXJucyB0aGUgcGxheWVyJ3MgY29uZmlndXJlZCB2YWx1ZS5cbiAgICogVG8gZ2V0IHRoZSBjdXJyZW50IGhlaWdodCB1c2UgYGN1cnJlbnRoZWlnaHQoKWAuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbdmFsdWVdXG4gICAqICAgICAgICBUaGUgdmFsdWUgdG8gc2V0IHRoZSBgUGxheWVyYCdzIGhlaWd0aCB0by5cbiAgICpcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKiAgICAgICAgIFRoZSBjdXJyZW50IGhlaWdodCBvZiB0aGUgYFBsYXllcmAgd2hlbiBnZXR0aW5nLlxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuaGVpZ2h0ID0gZnVuY3Rpb24gaGVpZ2h0KHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMuZGltZW5zaW9uKCdoZWlnaHQnLCB2YWx1ZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEEgZ2V0dGVyL3NldHRlciBmb3IgdGhlIGBQbGF5ZXJgJ3Mgd2lkdGggJiBoZWlnaHQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBkaW1lbnNpb25cbiAgICogICAgICAgIFRoaXMgc3RyaW5nIGNhbiBiZTpcbiAgICogICAgICAgIC0gJ3dpZHRoJ1xuICAgKiAgICAgICAgLSAnaGVpZ2h0J1xuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gW3ZhbHVlXVxuICAgKiAgICAgICAgVmFsdWUgZm9yIGRpbWVuc2lvbiBzcGVjaWZpZWQgaW4gdGhlIGZpcnN0IGFyZ3VtZW50LlxuICAgKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqICAgICAgICAgVGhlIGRpbWVuc2lvbiBhcmd1bWVudHMgdmFsdWUgd2hlbiBnZXR0aW5nICh3aWR0aC9oZWlnaHQpLlxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuZGltZW5zaW9uID0gZnVuY3Rpb24gZGltZW5zaW9uKF9kaW1lbnNpb24sIHZhbHVlKSB7XG4gICAgdmFyIHByaXZEaW1lbnNpb24gPSBfZGltZW5zaW9uICsgJ18nO1xuXG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0aGlzW3ByaXZEaW1lbnNpb25dIHx8IDA7XG4gICAgfVxuXG4gICAgaWYgKHZhbHVlID09PSAnJykge1xuICAgICAgLy8gSWYgYW4gZW1wdHkgc3RyaW5nIGlzIGdpdmVuLCByZXNldCB0aGUgZGltZW5zaW9uIHRvIGJlIGF1dG9tYXRpY1xuICAgICAgdGhpc1twcml2RGltZW5zaW9uXSA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMudXBkYXRlU3R5bGVFbF8oKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcGFyc2VkVmFsID0gcGFyc2VGbG9hdCh2YWx1ZSk7XG5cbiAgICBpZiAoaXNOYU4ocGFyc2VkVmFsKSkge1xuICAgICAgbG9nLmVycm9yKCdJbXByb3BlciB2YWx1ZSBcIicgKyB2YWx1ZSArICdcIiBzdXBwbGllZCBmb3IgZm9yICcgKyBfZGltZW5zaW9uKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzW3ByaXZEaW1lbnNpb25dID0gcGFyc2VkVmFsO1xuICAgIHRoaXMudXBkYXRlU3R5bGVFbF8oKTtcbiAgfTtcblxuICAvKipcbiAgICogQSBnZXR0ZXIvc2V0dGVyL3RvZ2dsZXIgZm9yIHRoZSB2anMtZmx1aWQgYGNsYXNzTmFtZWAgb24gdGhlIGBQbGF5ZXJgLlxuICAgKlxuICAgKiBUdXJuaW5nIHRoaXMgb24gd2lsbCB0dXJuIG9mZiBmaWxsIG1vZGUuXG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Jvb2xdXG4gICAqICAgICAgICAtIEEgdmFsdWUgb2YgdHJ1ZSBhZGRzIHRoZSBjbGFzcy5cbiAgICogICAgICAgIC0gQSB2YWx1ZSBvZiBmYWxzZSByZW1vdmVzIHRoZSBjbGFzcy5cbiAgICogICAgICAgIC0gTm8gdmFsdWUgd2lsbCBiZSBhIGdldHRlci5cbiAgICpcbiAgICogQHJldHVybiB7Ym9vbGVhbnx1bmRlZmluZWR9XG4gICAqICAgICAgICAgLSBUaGUgdmFsdWUgb2YgZmx1aWQgd2hlbiBnZXR0aW5nLlxuICAgKiAgICAgICAgIC0gYHVuZGVmaW5lZGAgd2hlbiBzZXR0aW5nLlxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuZmx1aWQgPSBmdW5jdGlvbiBmbHVpZChib29sKSB7XG4gICAgaWYgKGJvb2wgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuICEhdGhpcy5mbHVpZF87XG4gICAgfVxuXG4gICAgdGhpcy5mbHVpZF8gPSAhIWJvb2w7XG5cbiAgICBpZiAoYm9vbCkge1xuICAgICAgdGhpcy5hZGRDbGFzcygndmpzLWZsdWlkJyk7XG4gICAgICB0aGlzLmZpbGwoZmFsc2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJlbW92ZUNsYXNzKCd2anMtZmx1aWQnKTtcbiAgICB9XG5cbiAgICB0aGlzLnVwZGF0ZVN0eWxlRWxfKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEEgZ2V0dGVyL3NldHRlci90b2dnbGVyIGZvciB0aGUgdmpzLWZpbGwgYGNsYXNzTmFtZWAgb24gdGhlIGBQbGF5ZXJgLlxuICAgKlxuICAgKiBUdXJuaW5nIHRoaXMgb24gd2lsbCB0dXJuIG9mZiBmbHVpZCBtb2RlLlxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtib29sXVxuICAgKiAgICAgICAgLSBBIHZhbHVlIG9mIHRydWUgYWRkcyB0aGUgY2xhc3MuXG4gICAqICAgICAgICAtIEEgdmFsdWUgb2YgZmFsc2UgcmVtb3ZlcyB0aGUgY2xhc3MuXG4gICAqICAgICAgICAtIE5vIHZhbHVlIHdpbGwgYmUgYSBnZXR0ZXIuXG4gICAqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW58dW5kZWZpbmVkfVxuICAgKiAgICAgICAgIC0gVGhlIHZhbHVlIG9mIGZsdWlkIHdoZW4gZ2V0dGluZy5cbiAgICogICAgICAgICAtIGB1bmRlZmluZWRgIHdoZW4gc2V0dGluZy5cbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiBmaWxsKGJvb2wpIHtcbiAgICBpZiAoYm9vbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gISF0aGlzLmZpbGxfO1xuICAgIH1cblxuICAgIHRoaXMuZmlsbF8gPSAhIWJvb2w7XG5cbiAgICBpZiAoYm9vbCkge1xuICAgICAgdGhpcy5hZGRDbGFzcygndmpzLWZpbGwnKTtcbiAgICAgIHRoaXMuZmx1aWQoZmFsc2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJlbW92ZUNsYXNzKCd2anMtZmlsbCcpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogR2V0L1NldCB0aGUgYXNwZWN0IHJhdGlvXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbcmF0aW9dXG4gICAqICAgICAgICBBc3BlY3QgcmF0aW8gZm9yIHBsYXllclxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd8dW5kZWZpbmVkfVxuICAgKiAgICAgICAgIHJldHVybnMgdGhlIGN1cnJlbnQgYXNwZWN0IHJhdGlvIHdoZW4gZ2V0dGluZ1xuICAgKi9cblxuICAvKipcbiAgICogQSBnZXR0ZXIvc2V0dGVyIGZvciB0aGUgYFBsYXllcmAncyBhc3BlY3QgcmF0aW8uXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbcmF0aW9dXG4gICAqICAgICAgICBUaGUgdmFsdWUgdG8gc2V0IHRoZSBgUGxheWVyJ3MgYXNwZWN0IHJhdGlvIHRvLlxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd8dW5kZWZpbmVkfVxuICAgKiAgICAgICAgIC0gVGhlIGN1cnJlbnQgYXNwZWN0IHJhdGlvIG9mIHRoZSBgUGxheWVyYCB3aGVuIGdldHRpbmcuXG4gICAqICAgICAgICAgLSB1bmRlZmluZWQgd2hlbiBzZXR0aW5nXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5hc3BlY3RSYXRpbyA9IGZ1bmN0aW9uIGFzcGVjdFJhdGlvKHJhdGlvKSB7XG4gICAgaWYgKHJhdGlvID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLmFzcGVjdFJhdGlvXztcbiAgICB9XG5cbiAgICAvLyBDaGVjayBmb3Igd2lkdGg6aGVpZ2h0IGZvcm1hdFxuICAgIGlmICghL15cXGQrXFw6XFxkKyQvLnRlc3QocmF0aW8pKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ltcHJvcGVyIHZhbHVlIHN1cHBsaWVkIGZvciBhc3BlY3QgcmF0aW8uIFRoZSBmb3JtYXQgc2hvdWxkIGJlIHdpZHRoOmhlaWdodCwgZm9yIGV4YW1wbGUgMTY6OS4nKTtcbiAgICB9XG4gICAgdGhpcy5hc3BlY3RSYXRpb18gPSByYXRpbztcblxuICAgIC8vIFdlJ3JlIGFzc3VtaW5nIGlmIHlvdSBzZXQgYW4gYXNwZWN0IHJhdGlvIHlvdSB3YW50IGZsdWlkIG1vZGUsXG4gICAgLy8gYmVjYXVzZSBpbiBmaXhlZCBtb2RlIHlvdSBjb3VsZCBjYWxjdWxhdGUgd2lkdGggYW5kIGhlaWdodCB5b3Vyc2VsZi5cbiAgICB0aGlzLmZsdWlkKHRydWUpO1xuXG4gICAgdGhpcy51cGRhdGVTdHlsZUVsXygpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBVcGRhdGUgc3R5bGVzIG9mIHRoZSBgUGxheWVyYCBlbGVtZW50IChoZWlnaHQsIHdpZHRoIGFuZCBhc3BlY3QgcmF0aW8pLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAbGlzdGVucyBUZWNoI2xvYWRlZG1ldGFkYXRhXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS51cGRhdGVTdHlsZUVsXyA9IGZ1bmN0aW9uIHVwZGF0ZVN0eWxlRWxfKCkge1xuICAgIGlmICh3aW5kb3cuVklERU9KU19OT19EWU5BTUlDX1NUWUxFID09PSB0cnVlKSB7XG4gICAgICB2YXIgX3dpZHRoID0gdHlwZW9mIHRoaXMud2lkdGhfID09PSAnbnVtYmVyJyA/IHRoaXMud2lkdGhfIDogdGhpcy5vcHRpb25zXy53aWR0aDtcbiAgICAgIHZhciBfaGVpZ2h0ID0gdHlwZW9mIHRoaXMuaGVpZ2h0XyA9PT0gJ251bWJlcicgPyB0aGlzLmhlaWdodF8gOiB0aGlzLm9wdGlvbnNfLmhlaWdodDtcbiAgICAgIHZhciB0ZWNoRWwgPSB0aGlzLnRlY2hfICYmIHRoaXMudGVjaF8uZWwoKTtcblxuICAgICAgaWYgKHRlY2hFbCkge1xuICAgICAgICBpZiAoX3dpZHRoID49IDApIHtcbiAgICAgICAgICB0ZWNoRWwud2lkdGggPSBfd2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKF9oZWlnaHQgPj0gMCkge1xuICAgICAgICAgIHRlY2hFbC5oZWlnaHQgPSBfaGVpZ2h0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgd2lkdGggPSB2b2lkIDA7XG4gICAgdmFyIGhlaWdodCA9IHZvaWQgMDtcbiAgICB2YXIgYXNwZWN0UmF0aW8gPSB2b2lkIDA7XG4gICAgdmFyIGlkQ2xhc3MgPSB2b2lkIDA7XG5cbiAgICAvLyBUaGUgYXNwZWN0IHJhdGlvIGlzIGVpdGhlciB1c2VkIGRpcmVjdGx5IG9yIHRvIGNhbGN1bGF0ZSB3aWR0aCBhbmQgaGVpZ2h0LlxuICAgIGlmICh0aGlzLmFzcGVjdFJhdGlvXyAhPT0gdW5kZWZpbmVkICYmIHRoaXMuYXNwZWN0UmF0aW9fICE9PSAnYXV0bycpIHtcbiAgICAgIC8vIFVzZSBhbnkgYXNwZWN0UmF0aW8gdGhhdCdzIGJlZW4gc3BlY2lmaWNhbGx5IHNldFxuICAgICAgYXNwZWN0UmF0aW8gPSB0aGlzLmFzcGVjdFJhdGlvXztcbiAgICB9IGVsc2UgaWYgKHRoaXMudmlkZW9XaWR0aCgpID4gMCkge1xuICAgICAgLy8gT3RoZXJ3aXNlIHRyeSB0byBnZXQgdGhlIGFzcGVjdCByYXRpbyBmcm9tIHRoZSB2aWRlbyBtZXRhZGF0YVxuICAgICAgYXNwZWN0UmF0aW8gPSB0aGlzLnZpZGVvV2lkdGgoKSArICc6JyArIHRoaXMudmlkZW9IZWlnaHQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gT3IgdXNlIGEgZGVmYXVsdC4gVGhlIHZpZGVvIGVsZW1lbnQncyBpcyAyOjEsIGJ1dCAxNjo5IGlzIG1vcmUgY29tbW9uLlxuICAgICAgYXNwZWN0UmF0aW8gPSAnMTY6OSc7XG4gICAgfVxuXG4gICAgLy8gR2V0IHRoZSByYXRpbyBhcyBhIGRlY2ltYWwgd2UgY2FuIHVzZSB0byBjYWxjdWxhdGUgZGltZW5zaW9uc1xuICAgIHZhciByYXRpb1BhcnRzID0gYXNwZWN0UmF0aW8uc3BsaXQoJzonKTtcbiAgICB2YXIgcmF0aW9NdWx0aXBsaWVyID0gcmF0aW9QYXJ0c1sxXSAvIHJhdGlvUGFydHNbMF07XG5cbiAgICBpZiAodGhpcy53aWR0aF8gIT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gVXNlIGFueSB3aWR0aCB0aGF0J3MgYmVlbiBzcGVjaWZpY2FsbHkgc2V0XG4gICAgICB3aWR0aCA9IHRoaXMud2lkdGhfO1xuICAgIH0gZWxzZSBpZiAodGhpcy5oZWlnaHRfICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIE9yIGNhbHVsYXRlIHRoZSB3aWR0aCBmcm9tIHRoZSBhc3BlY3QgcmF0aW8gaWYgYSBoZWlnaHQgaGFzIGJlZW4gc2V0XG4gICAgICB3aWR0aCA9IHRoaXMuaGVpZ2h0XyAvIHJhdGlvTXVsdGlwbGllcjtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gT3IgdXNlIHRoZSB2aWRlbydzIG1ldGFkYXRhLCBvciB1c2UgdGhlIHZpZGVvIGVsJ3MgZGVmYXVsdCBvZiAzMDBcbiAgICAgIHdpZHRoID0gdGhpcy52aWRlb1dpZHRoKCkgfHwgMzAwO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmhlaWdodF8gIT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gVXNlIGFueSBoZWlnaHQgdGhhdCdzIGJlZW4gc3BlY2lmaWNhbGx5IHNldFxuICAgICAgaGVpZ2h0ID0gdGhpcy5oZWlnaHRfO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBPdGhlcndpc2UgY2FsY3VsYXRlIHRoZSBoZWlnaHQgZnJvbSB0aGUgcmF0aW8gYW5kIHRoZSB3aWR0aFxuICAgICAgaGVpZ2h0ID0gd2lkdGggKiByYXRpb011bHRpcGxpZXI7XG4gICAgfVxuXG4gICAgLy8gRW5zdXJlIHRoZSBDU1MgY2xhc3MgaXMgdmFsaWQgYnkgc3RhcnRpbmcgd2l0aCBhbiBhbHBoYSBjaGFyYWN0ZXJcbiAgICBpZiAoL15bXmEtekEtWl0vLnRlc3QodGhpcy5pZCgpKSkge1xuICAgICAgaWRDbGFzcyA9ICdkaW1lbnNpb25zLScgKyB0aGlzLmlkKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlkQ2xhc3MgPSB0aGlzLmlkKCkgKyAnLWRpbWVuc2lvbnMnO1xuICAgIH1cblxuICAgIC8vIEVuc3VyZSB0aGUgcmlnaHQgY2xhc3MgaXMgc3RpbGwgb24gdGhlIHBsYXllciBmb3IgdGhlIHN0eWxlIGVsZW1lbnRcbiAgICB0aGlzLmFkZENsYXNzKGlkQ2xhc3MpO1xuXG4gICAgc2V0VGV4dENvbnRlbnQodGhpcy5zdHlsZUVsXywgJ1xcbiAgICAgIC4nICsgaWRDbGFzcyArICcge1xcbiAgICAgICAgd2lkdGg6ICcgKyB3aWR0aCArICdweDtcXG4gICAgICAgIGhlaWdodDogJyArIGhlaWdodCArICdweDtcXG4gICAgICB9XFxuXFxuICAgICAgLicgKyBpZENsYXNzICsgJy52anMtZmx1aWQge1xcbiAgICAgICAgcGFkZGluZy10b3A6ICcgKyByYXRpb011bHRpcGxpZXIgKiAxMDAgKyAnJTtcXG4gICAgICB9XFxuICAgICcpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBMb2FkL0NyZWF0ZSBhbiBpbnN0YW5jZSBvZiBwbGF5YmFjayB7QGxpbmsgVGVjaH0gaW5jbHVkaW5nIGVsZW1lbnRcbiAgICogYW5kIEFQSSBtZXRob2RzLiBUaGVuIGFwcGVuZCB0aGUgYFRlY2hgIGVsZW1lbnQgaW4gYFBsYXllcmAgYXMgYSBjaGlsZC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRlY2hOYW1lXG4gICAqICAgICAgICBuYW1lIG9mIHRoZSBwbGF5YmFjayB0ZWNobm9sb2d5XG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzb3VyY2VcbiAgICogICAgICAgIHZpZGVvIHNvdXJjZVxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUubG9hZFRlY2hfID0gZnVuY3Rpb24gbG9hZFRlY2hfKHRlY2hOYW1lLCBzb3VyY2UpIHtcbiAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgIC8vIFBhdXNlIGFuZCByZW1vdmUgY3VycmVudCBwbGF5YmFjayB0ZWNobm9sb2d5XG4gICAgaWYgKHRoaXMudGVjaF8pIHtcbiAgICAgIHRoaXMudW5sb2FkVGVjaF8oKTtcbiAgICB9XG5cbiAgICB2YXIgdGl0bGVUZWNoTmFtZSA9IHRvVGl0bGVDYXNlKHRlY2hOYW1lKTtcbiAgICB2YXIgY2FtZWxUZWNoTmFtZSA9IHRlY2hOYW1lLmNoYXJBdCgwKS50b0xvd2VyQ2FzZSgpICsgdGVjaE5hbWUuc2xpY2UoMSk7XG5cbiAgICAvLyBnZXQgcmlkIG9mIHRoZSBIVE1MNSB2aWRlbyB0YWcgYXMgc29vbiBhcyB3ZSBhcmUgdXNpbmcgYW5vdGhlciB0ZWNoXG4gICAgaWYgKHRpdGxlVGVjaE5hbWUgIT09ICdIdG1sNScgJiYgdGhpcy50YWcpIHtcbiAgICAgIFRlY2guZ2V0VGVjaCgnSHRtbDUnKS5kaXNwb3NlTWVkaWFFbGVtZW50KHRoaXMudGFnKTtcbiAgICAgIHRoaXMudGFnLnBsYXllciA9IG51bGw7XG4gICAgICB0aGlzLnRhZyA9IG51bGw7XG4gICAgfVxuXG4gICAgdGhpcy50ZWNoTmFtZV8gPSB0aXRsZVRlY2hOYW1lO1xuXG4gICAgLy8gVHVybiBvZmYgQVBJIGFjY2VzcyBiZWNhdXNlIHdlJ3JlIGxvYWRpbmcgYSBuZXcgdGVjaCB0aGF0IG1pZ2h0IGxvYWQgYXN5bmNocm9ub3VzbHlcbiAgICB0aGlzLmlzUmVhZHlfID0gZmFsc2U7XG5cbiAgICAvLyBpZiBhdXRvcGxheSBpcyBhIHN0cmluZyB3ZSBwYXNzIGZhbHNlIHRvIHRoZSB0ZWNoXG4gICAgLy8gYmVjYXVzZSB0aGUgcGxheWVyIGlzIGdvaW5nIHRvIGhhbmRsZSBhdXRvcGxheSBvbiBgbG9hZHN0YXJ0YFxuICAgIHZhciBhdXRvcGxheSA9IHR5cGVvZiB0aGlzLmF1dG9wbGF5KCkgPT09ICdzdHJpbmcnID8gZmFsc2UgOiB0aGlzLmF1dG9wbGF5KCk7XG5cbiAgICAvLyBHcmFiIHRlY2gtc3BlY2lmaWMgb3B0aW9ucyBmcm9tIHBsYXllciBvcHRpb25zIGFuZCBhZGQgc291cmNlIGFuZCBwYXJlbnQgZWxlbWVudCB0byB1c2UuXG4gICAgdmFyIHRlY2hPcHRpb25zID0ge1xuICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICBhdXRvcGxheTogYXV0b3BsYXksXG4gICAgICAnbmF0aXZlQ29udHJvbHNGb3JUb3VjaCc6IHRoaXMub3B0aW9uc18ubmF0aXZlQ29udHJvbHNGb3JUb3VjaCxcbiAgICAgICdwbGF5ZXJJZCc6IHRoaXMuaWQoKSxcbiAgICAgICd0ZWNoSWQnOiB0aGlzLmlkKCkgKyAnXycgKyBjYW1lbFRlY2hOYW1lICsgJ19hcGknLFxuICAgICAgJ3BsYXlzaW5saW5lJzogdGhpcy5vcHRpb25zXy5wbGF5c2lubGluZSxcbiAgICAgICdwcmVsb2FkJzogdGhpcy5vcHRpb25zXy5wcmVsb2FkLFxuICAgICAgJ2xvb3AnOiB0aGlzLm9wdGlvbnNfLmxvb3AsXG4gICAgICAnbXV0ZWQnOiB0aGlzLm9wdGlvbnNfLm11dGVkLFxuICAgICAgJ3Bvc3Rlcic6IHRoaXMucG9zdGVyKCksXG4gICAgICAnbGFuZ3VhZ2UnOiB0aGlzLmxhbmd1YWdlKCksXG4gICAgICAncGxheWVyRWxJbmdlc3QnOiB0aGlzLnBsYXllckVsSW5nZXN0XyB8fCBmYWxzZSxcbiAgICAgICd2dHQuanMnOiB0aGlzLm9wdGlvbnNfWyd2dHQuanMnXSxcbiAgICAgICdjYW5PdmVycmlkZVBvc3Rlcic6ICEhdGhpcy5vcHRpb25zXy50ZWNoQ2FuT3ZlcnJpZGVQb3N0ZXIsXG4gICAgICAnZW5hYmxlU291cmNlc2V0JzogdGhpcy5vcHRpb25zXy5lbmFibGVTb3VyY2VzZXRcbiAgICB9O1xuXG4gICAgQUxMLm5hbWVzLmZvckVhY2goZnVuY3Rpb24gKG5hbWUkJDEpIHtcbiAgICAgIHZhciBwcm9wcyA9IEFMTFtuYW1lJCQxXTtcblxuICAgICAgdGVjaE9wdGlvbnNbcHJvcHMuZ2V0dGVyTmFtZV0gPSBfdGhpczJbcHJvcHMucHJpdmF0ZU5hbWVdO1xuICAgIH0pO1xuXG4gICAgYXNzaWduKHRlY2hPcHRpb25zLCB0aGlzLm9wdGlvbnNfW3RpdGxlVGVjaE5hbWVdKTtcbiAgICBhc3NpZ24odGVjaE9wdGlvbnMsIHRoaXMub3B0aW9uc19bY2FtZWxUZWNoTmFtZV0pO1xuICAgIGFzc2lnbih0ZWNoT3B0aW9ucywgdGhpcy5vcHRpb25zX1t0ZWNoTmFtZS50b0xvd2VyQ2FzZSgpXSk7XG5cbiAgICBpZiAodGhpcy50YWcpIHtcbiAgICAgIHRlY2hPcHRpb25zLnRhZyA9IHRoaXMudGFnO1xuICAgIH1cblxuICAgIGlmIChzb3VyY2UgJiYgc291cmNlLnNyYyA9PT0gdGhpcy5jYWNoZV8uc3JjICYmIHRoaXMuY2FjaGVfLmN1cnJlbnRUaW1lID4gMCkge1xuICAgICAgdGVjaE9wdGlvbnMuc3RhcnRUaW1lID0gdGhpcy5jYWNoZV8uY3VycmVudFRpbWU7XG4gICAgfVxuXG4gICAgLy8gSW5pdGlhbGl6ZSB0ZWNoIGluc3RhbmNlXG4gICAgdmFyIFRlY2hDbGFzcyA9IFRlY2guZ2V0VGVjaCh0ZWNoTmFtZSk7XG5cbiAgICBpZiAoIVRlY2hDbGFzcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBUZWNoIG5hbWVkIFxcJycgKyB0aXRsZVRlY2hOYW1lICsgJ1xcJyBleGlzdHMhIFxcJycgKyB0aXRsZVRlY2hOYW1lICsgJ1xcJyBzaG91bGQgYmUgcmVnaXN0ZXJlZCB1c2luZyB2aWRlb2pzLnJlZ2lzdGVyVGVjaCgpXFwnJyk7XG4gICAgfVxuXG4gICAgdGhpcy50ZWNoXyA9IG5ldyBUZWNoQ2xhc3ModGVjaE9wdGlvbnMpO1xuXG4gICAgLy8gcGxheWVyLnRyaWdnZXJSZWFkeSBpcyBhbHdheXMgYXN5bmMsIHNvIGRvbid0IG5lZWQgdGhpcyB0byBiZSBhc3luY1xuICAgIHRoaXMudGVjaF8ucmVhZHkoYmluZCh0aGlzLCB0aGlzLmhhbmRsZVRlY2hSZWFkeV8pLCB0cnVlKTtcblxuICAgIHRleHRUcmFja0NvbnZlcnRlci5qc29uVG9UZXh0VHJhY2tzKHRoaXMudGV4dFRyYWNrc0pzb25fIHx8IFtdLCB0aGlzLnRlY2hfKTtcblxuICAgIC8vIExpc3RlbiB0byBhbGwgSFRNTDUtZGVmaW5lZCBldmVudHMgYW5kIHRyaWdnZXIgdGhlbSBvbiB0aGUgcGxheWVyXG4gICAgVEVDSF9FVkVOVFNfUkVUUklHR0VSLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICBfdGhpczIub24oX3RoaXMyLnRlY2hfLCBldmVudCwgX3RoaXMyWydoYW5kbGVUZWNoJyArIHRvVGl0bGVDYXNlKGV2ZW50KSArICdfJ10pO1xuICAgIH0pO1xuXG4gICAgT2JqZWN0LmtleXMoVEVDSF9FVkVOVFNfUVVFVUUpLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICBfdGhpczIub24oX3RoaXMyLnRlY2hfLCBldmVudCwgZnVuY3Rpb24gKGV2ZW50T2JqKSB7XG4gICAgICAgIGlmIChfdGhpczIudGVjaF8ucGxheWJhY2tSYXRlKCkgPT09IDAgJiYgX3RoaXMyLnRlY2hfLnNlZWtpbmcoKSkge1xuICAgICAgICAgIF90aGlzMi5xdWV1ZWRDYWxsYmFja3NfLnB1c2goe1xuICAgICAgICAgICAgY2FsbGJhY2s6IF90aGlzMlsnaGFuZGxlVGVjaCcgKyBURUNIX0VWRU5UU19RVUVVRVtldmVudF0gKyAnXyddLmJpbmQoX3RoaXMyKSxcbiAgICAgICAgICAgIGV2ZW50OiBldmVudE9ialxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBfdGhpczJbJ2hhbmRsZVRlY2gnICsgVEVDSF9FVkVOVFNfUVVFVUVbZXZlbnRdICsgJ18nXShldmVudE9iaik7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHRoaXMub24odGhpcy50ZWNoXywgJ2xvYWRzdGFydCcsIHRoaXMuaGFuZGxlVGVjaExvYWRTdGFydF8pO1xuICAgIHRoaXMub24odGhpcy50ZWNoXywgJ3NvdXJjZXNldCcsIHRoaXMuaGFuZGxlVGVjaFNvdXJjZXNldF8pO1xuICAgIHRoaXMub24odGhpcy50ZWNoXywgJ3dhaXRpbmcnLCB0aGlzLmhhbmRsZVRlY2hXYWl0aW5nXyk7XG4gICAgdGhpcy5vbih0aGlzLnRlY2hfLCAnZW5kZWQnLCB0aGlzLmhhbmRsZVRlY2hFbmRlZF8pO1xuICAgIHRoaXMub24odGhpcy50ZWNoXywgJ3NlZWtpbmcnLCB0aGlzLmhhbmRsZVRlY2hTZWVraW5nXyk7XG4gICAgdGhpcy5vbih0aGlzLnRlY2hfLCAncGxheScsIHRoaXMuaGFuZGxlVGVjaFBsYXlfKTtcbiAgICB0aGlzLm9uKHRoaXMudGVjaF8sICdmaXJzdHBsYXknLCB0aGlzLmhhbmRsZVRlY2hGaXJzdFBsYXlfKTtcbiAgICB0aGlzLm9uKHRoaXMudGVjaF8sICdwYXVzZScsIHRoaXMuaGFuZGxlVGVjaFBhdXNlXyk7XG4gICAgdGhpcy5vbih0aGlzLnRlY2hfLCAnZHVyYXRpb25jaGFuZ2UnLCB0aGlzLmhhbmRsZVRlY2hEdXJhdGlvbkNoYW5nZV8pO1xuICAgIHRoaXMub24odGhpcy50ZWNoXywgJ2Z1bGxzY3JlZW5jaGFuZ2UnLCB0aGlzLmhhbmRsZVRlY2hGdWxsc2NyZWVuQ2hhbmdlXyk7XG4gICAgdGhpcy5vbih0aGlzLnRlY2hfLCAnZXJyb3InLCB0aGlzLmhhbmRsZVRlY2hFcnJvcl8pO1xuICAgIHRoaXMub24odGhpcy50ZWNoXywgJ2xvYWRlZG1ldGFkYXRhJywgdGhpcy51cGRhdGVTdHlsZUVsXyk7XG4gICAgdGhpcy5vbih0aGlzLnRlY2hfLCAncG9zdGVyY2hhbmdlJywgdGhpcy5oYW5kbGVUZWNoUG9zdGVyQ2hhbmdlXyk7XG4gICAgdGhpcy5vbih0aGlzLnRlY2hfLCAndGV4dGRhdGEnLCB0aGlzLmhhbmRsZVRlY2hUZXh0RGF0YV8pO1xuICAgIHRoaXMub24odGhpcy50ZWNoXywgJ3JhdGVjaGFuZ2UnLCB0aGlzLmhhbmRsZVRlY2hSYXRlQ2hhbmdlXyk7XG5cbiAgICB0aGlzLnVzaW5nTmF0aXZlQ29udHJvbHModGhpcy50ZWNoR2V0XygnY29udHJvbHMnKSk7XG5cbiAgICBpZiAodGhpcy5jb250cm9scygpICYmICF0aGlzLnVzaW5nTmF0aXZlQ29udHJvbHMoKSkge1xuICAgICAgdGhpcy5hZGRUZWNoQ29udHJvbHNMaXN0ZW5lcnNfKCk7XG4gICAgfVxuXG4gICAgLy8gQWRkIHRoZSB0ZWNoIGVsZW1lbnQgaW4gdGhlIERPTSBpZiBpdCB3YXMgbm90IGFscmVhZHkgdGhlcmVcbiAgICAvLyBNYWtlIHN1cmUgdG8gbm90IGluc2VydCB0aGUgb3JpZ2luYWwgdmlkZW8gZWxlbWVudCBpZiB1c2luZyBIdG1sNVxuICAgIGlmICh0aGlzLnRlY2hfLmVsKCkucGFyZW50Tm9kZSAhPT0gdGhpcy5lbCgpICYmICh0aXRsZVRlY2hOYW1lICE9PSAnSHRtbDUnIHx8ICF0aGlzLnRhZykpIHtcbiAgICAgIHByZXBlbmRUbyh0aGlzLnRlY2hfLmVsKCksIHRoaXMuZWwoKSk7XG4gICAgfVxuXG4gICAgLy8gR2V0IHJpZCBvZiB0aGUgb3JpZ2luYWwgdmlkZW8gdGFnIHJlZmVyZW5jZSBhZnRlciB0aGUgZmlyc3QgdGVjaCBpcyBsb2FkZWRcbiAgICBpZiAodGhpcy50YWcpIHtcbiAgICAgIHRoaXMudGFnLnBsYXllciA9IG51bGw7XG4gICAgICB0aGlzLnRhZyA9IG51bGw7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBVbmxvYWQgYW5kIGRpc3Bvc2Ugb2YgdGhlIGN1cnJlbnQgcGxheWJhY2sge0BsaW5rIFRlY2h9LlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUudW5sb2FkVGVjaF8gPSBmdW5jdGlvbiB1bmxvYWRUZWNoXygpIHtcbiAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgIC8vIFNhdmUgdGhlIGN1cnJlbnQgdGV4dCB0cmFja3Mgc28gdGhhdCB3ZSBjYW4gcmV1c2UgdGhlIHNhbWUgdGV4dCB0cmFja3Mgd2l0aCB0aGUgbmV4dCB0ZWNoXG4gICAgQUxMLm5hbWVzLmZvckVhY2goZnVuY3Rpb24gKG5hbWUkJDEpIHtcbiAgICAgIHZhciBwcm9wcyA9IEFMTFtuYW1lJCQxXTtcblxuICAgICAgX3RoaXMzW3Byb3BzLnByaXZhdGVOYW1lXSA9IF90aGlzM1twcm9wcy5nZXR0ZXJOYW1lXSgpO1xuICAgIH0pO1xuICAgIHRoaXMudGV4dFRyYWNrc0pzb25fID0gdGV4dFRyYWNrQ29udmVydGVyLnRleHRUcmFja3NUb0pzb24odGhpcy50ZWNoXyk7XG5cbiAgICB0aGlzLmlzUmVhZHlfID0gZmFsc2U7XG5cbiAgICB0aGlzLnRlY2hfLmRpc3Bvc2UoKTtcblxuICAgIHRoaXMudGVjaF8gPSBmYWxzZTtcblxuICAgIGlmICh0aGlzLmlzUG9zdGVyRnJvbVRlY2hfKSB7XG4gICAgICB0aGlzLnBvc3Rlcl8gPSAnJztcbiAgICAgIHRoaXMudHJpZ2dlcigncG9zdGVyY2hhbmdlJyk7XG4gICAgfVxuXG4gICAgdGhpcy5pc1Bvc3RlckZyb21UZWNoXyA9IGZhbHNlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm4gYSByZWZlcmVuY2UgdG8gdGhlIGN1cnJlbnQge0BsaW5rIFRlY2h9LlxuICAgKiBJdCB3aWxsIHByaW50IGEgd2FybmluZyBieSBkZWZhdWx0IGFib3V0IHRoZSBkYW5nZXIgb2YgdXNpbmcgdGhlIHRlY2ggZGlyZWN0bHlcbiAgICogYnV0IGFueSBhcmd1bWVudCB0aGF0IGlzIHBhc3NlZCBpbiB3aWxsIHNpbGVuY2UgdGhlIHdhcm5pbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gW3NhZmV0eV1cbiAgICogICAgICAgIEFueXRoaW5nIHBhc3NlZCBpbiB0byBzaWxlbmNlIHRoZSB3YXJuaW5nXG4gICAqXG4gICAqIEByZXR1cm4ge1RlY2h9XG4gICAqICAgICAgICAgVGhlIFRlY2hcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLnRlY2ggPSBmdW5jdGlvbiB0ZWNoKHNhZmV0eSkge1xuICAgIGlmIChzYWZldHkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgbG9nLndhcm4odHNtbChfdGVtcGxhdGVPYmplY3QkMSkpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnRlY2hfO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgdXAgY2xpY2sgYW5kIHRvdWNoIGxpc3RlbmVycyBmb3IgdGhlIHBsYXliYWNrIGVsZW1lbnRcbiAgICpcbiAgICogLSBPbiBkZXNrdG9wczogYSBjbGljayBvbiB0aGUgdmlkZW8gaXRzZWxmIHdpbGwgdG9nZ2xlIHBsYXliYWNrXG4gICAqIC0gT24gbW9iaWxlIGRldmljZXM6IGEgY2xpY2sgb24gdGhlIHZpZGVvIHRvZ2dsZXMgY29udHJvbHNcbiAgICogICB3aGljaCBpcyBkb25lIGJ5IHRvZ2dsaW5nIHRoZSB1c2VyIHN0YXRlIGJldHdlZW4gYWN0aXZlIGFuZFxuICAgKiAgIGluYWN0aXZlXG4gICAqIC0gQSB0YXAgY2FuIHNpZ25hbCB0aGF0IGEgdXNlciBoYXMgYmVjb21lIGFjdGl2ZSBvciBoYXMgYmVjb21lIGluYWN0aXZlXG4gICAqICAgZS5nLiBhIHF1aWNrIHRhcCBvbiBhbiBpUGhvbmUgbW92aWUgc2hvdWxkIHJldmVhbCB0aGUgY29udHJvbHMuIEFub3RoZXJcbiAgICogICBxdWljayB0YXAgc2hvdWxkIGhpZGUgdGhlbSBhZ2FpbiAoc2lnbmFsaW5nIHRoZSB1c2VyIGlzIGluIGFuIGluYWN0aXZlXG4gICAqICAgdmlld2luZyBzdGF0ZSlcbiAgICogLSBJbiBhZGRpdGlvbiB0byB0aGlzLCB3ZSBzdGlsbCB3YW50IHRoZSB1c2VyIHRvIGJlIGNvbnNpZGVyZWQgaW5hY3RpdmUgYWZ0ZXJcbiAgICogICBhIGZldyBzZWNvbmRzIG9mIGluYWN0aXZpdHkuXG4gICAqXG4gICAqID4gTm90ZTogdGhlIG9ubHkgcGFydCBvZiBpT1MgaW50ZXJhY3Rpb24gd2UgY2FuJ3QgbWltaWMgd2l0aCB0aGlzIHNldHVwXG4gICAqIGlzIGEgdG91Y2ggYW5kIGhvbGQgb24gdGhlIHZpZGVvIGVsZW1lbnQgY291bnRpbmcgYXMgYWN0aXZpdHkgaW4gb3JkZXIgdG9cbiAgICoga2VlcCB0aGUgY29udHJvbHMgc2hvd2luZywgYnV0IHRoYXQgc2hvdWxkbid0IGJlIGFuIGlzc3VlLiBBIHRvdWNoIGFuZCBob2xkXG4gICAqIG9uIGFueSBjb250cm9scyB3aWxsIHN0aWxsIGtlZXAgdGhlIHVzZXIgYWN0aXZlXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5hZGRUZWNoQ29udHJvbHNMaXN0ZW5lcnNfID0gZnVuY3Rpb24gYWRkVGVjaENvbnRyb2xzTGlzdGVuZXJzXygpIHtcbiAgICAvLyBNYWtlIHN1cmUgdG8gcmVtb3ZlIGFsbCB0aGUgcHJldmlvdXMgbGlzdGVuZXJzIGluIGNhc2Ugd2UgYXJlIGNhbGxlZCBtdWx0aXBsZSB0aW1lcy5cbiAgICB0aGlzLnJlbW92ZVRlY2hDb250cm9sc0xpc3RlbmVyc18oKTtcblxuICAgIC8vIFNvbWUgYnJvd3NlcnMgKENocm9tZSAmIElFKSBkb24ndCB0cmlnZ2VyIGEgY2xpY2sgb24gYSBmbGFzaCBzd2YsIGJ1dCBkb1xuICAgIC8vIHRyaWdnZXIgbW91c2Vkb3duL3VwLlxuICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTQ0NDU2Mi9qYXZhc2NyaXB0LW9uY2xpY2stZXZlbnQtb3Zlci1mbGFzaC1vYmplY3RcbiAgICAvLyBBbnkgdG91Y2ggZXZlbnRzIGFyZSBzZXQgdG8gYmxvY2sgdGhlIG1vdXNlZG93biBldmVudCBmcm9tIGhhcHBlbmluZ1xuICAgIHRoaXMub24odGhpcy50ZWNoXywgJ21vdXNlZG93bicsIHRoaXMuaGFuZGxlVGVjaENsaWNrXyk7XG5cbiAgICAvLyBJZiB0aGUgY29udHJvbHMgd2VyZSBoaWRkZW4gd2UgZG9uJ3Qgd2FudCB0aGF0IHRvIGNoYW5nZSB3aXRob3V0IGEgdGFwIGV2ZW50XG4gICAgLy8gc28gd2UnbGwgY2hlY2sgaWYgdGhlIGNvbnRyb2xzIHdlcmUgYWxyZWFkeSBzaG93aW5nIGJlZm9yZSByZXBvcnRpbmcgdXNlclxuICAgIC8vIGFjdGl2aXR5XG4gICAgdGhpcy5vbih0aGlzLnRlY2hfLCAndG91Y2hzdGFydCcsIHRoaXMuaGFuZGxlVGVjaFRvdWNoU3RhcnRfKTtcbiAgICB0aGlzLm9uKHRoaXMudGVjaF8sICd0b3VjaG1vdmUnLCB0aGlzLmhhbmRsZVRlY2hUb3VjaE1vdmVfKTtcbiAgICB0aGlzLm9uKHRoaXMudGVjaF8sICd0b3VjaGVuZCcsIHRoaXMuaGFuZGxlVGVjaFRvdWNoRW5kXyk7XG5cbiAgICAvLyBUaGUgdGFwIGxpc3RlbmVyIG5lZWRzIHRvIGNvbWUgYWZ0ZXIgdGhlIHRvdWNoZW5kIGxpc3RlbmVyIGJlY2F1c2UgdGhlIHRhcFxuICAgIC8vIGxpc3RlbmVyIGNhbmNlbHMgb3V0IGFueSByZXBvcnRlZFVzZXJBY3Rpdml0eSB3aGVuIHNldHRpbmcgdXNlckFjdGl2ZShmYWxzZSlcbiAgICB0aGlzLm9uKHRoaXMudGVjaF8sICd0YXAnLCB0aGlzLmhhbmRsZVRlY2hUYXBfKTtcbiAgfTtcblxuICAvKipcbiAgICogUmVtb3ZlIHRoZSBsaXN0ZW5lcnMgdXNlZCBmb3IgY2xpY2sgYW5kIHRhcCBjb250cm9scy4gVGhpcyBpcyBuZWVkZWQgZm9yXG4gICAqIHRvZ2dsaW5nIHRvIGNvbnRyb2xzIGRpc2FibGVkLCB3aGVyZSBhIHRhcC90b3VjaCBzaG91bGQgZG8gbm90aGluZy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLnJlbW92ZVRlY2hDb250cm9sc0xpc3RlbmVyc18gPSBmdW5jdGlvbiByZW1vdmVUZWNoQ29udHJvbHNMaXN0ZW5lcnNfKCkge1xuICAgIC8vIFdlIGRvbid0IHdhbnQgdG8ganVzdCB1c2UgYHRoaXMub2ZmKClgIGJlY2F1c2UgdGhlcmUgbWlnaHQgYmUgb3RoZXIgbmVlZGVkXG4gICAgLy8gbGlzdGVuZXJzIGFkZGVkIGJ5IHRlY2hzIHRoYXQgZXh0ZW5kIHRoaXMuXG4gICAgdGhpcy5vZmYodGhpcy50ZWNoXywgJ3RhcCcsIHRoaXMuaGFuZGxlVGVjaFRhcF8pO1xuICAgIHRoaXMub2ZmKHRoaXMudGVjaF8sICd0b3VjaHN0YXJ0JywgdGhpcy5oYW5kbGVUZWNoVG91Y2hTdGFydF8pO1xuICAgIHRoaXMub2ZmKHRoaXMudGVjaF8sICd0b3VjaG1vdmUnLCB0aGlzLmhhbmRsZVRlY2hUb3VjaE1vdmVfKTtcbiAgICB0aGlzLm9mZih0aGlzLnRlY2hfLCAndG91Y2hlbmQnLCB0aGlzLmhhbmRsZVRlY2hUb3VjaEVuZF8pO1xuICAgIHRoaXMub2ZmKHRoaXMudGVjaF8sICdtb3VzZWRvd24nLCB0aGlzLmhhbmRsZVRlY2hDbGlja18pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBQbGF5ZXIgd2FpdHMgZm9yIHRoZSB0ZWNoIHRvIGJlIHJlYWR5XG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5oYW5kbGVUZWNoUmVhZHlfID0gZnVuY3Rpb24gaGFuZGxlVGVjaFJlYWR5XygpIHtcbiAgICB0aGlzLnRyaWdnZXJSZWFkeSgpO1xuXG4gICAgLy8gS2VlcCB0aGUgc2FtZSB2b2x1bWUgYXMgYmVmb3JlXG4gICAgaWYgKHRoaXMuY2FjaGVfLnZvbHVtZSkge1xuICAgICAgdGhpcy50ZWNoQ2FsbF8oJ3NldFZvbHVtZScsIHRoaXMuY2FjaGVfLnZvbHVtZSk7XG4gICAgfVxuXG4gICAgLy8gTG9vayBpZiB0aGUgdGVjaCBmb3VuZCBhIGhpZ2hlciByZXNvbHV0aW9uIHBvc3RlciB3aGlsZSBsb2FkaW5nXG4gICAgdGhpcy5oYW5kbGVUZWNoUG9zdGVyQ2hhbmdlXygpO1xuXG4gICAgLy8gVXBkYXRlIHRoZSBkdXJhdGlvbiBpZiBhdmFpbGFibGVcbiAgICB0aGlzLmhhbmRsZVRlY2hEdXJhdGlvbkNoYW5nZV8oKTtcblxuICAgIC8vIENocm9tZSBhbmQgU2FmYXJpIGJvdGggaGF2ZSBpc3N1ZXMgd2l0aCBhdXRvcGxheS5cbiAgICAvLyBJbiBTYWZhcmkgKDUuMS4xKSwgd2hlbiB3ZSBtb3ZlIHRoZSB2aWRlbyBlbGVtZW50IGludG8gdGhlIGNvbnRhaW5lciBkaXYsIGF1dG9wbGF5IGRvZXNuJ3Qgd29yay5cbiAgICAvLyBJbiBDaHJvbWUgKDE1KSwgaWYgeW91IGhhdmUgYXV0b3BsYXkgKyBhIHBvc3RlciArIG5vIGNvbnRyb2xzLCB0aGUgdmlkZW8gZ2V0cyBoaWRkZW4gKGJ1dCBhdWRpbyBwbGF5cylcbiAgICAvLyBUaGlzIGZpeGVzIGJvdGggaXNzdWVzLiBOZWVkIHRvIHdhaXQgZm9yIEFQSSwgc28gaXQgdXBkYXRlcyBkaXNwbGF5cyBjb3JyZWN0bHlcbiAgICBpZiAoKHRoaXMuc3JjKCkgfHwgdGhpcy5jdXJyZW50U3JjKCkpICYmIHRoaXMudGFnICYmIHRoaXMub3B0aW9uc18uYXV0b3BsYXkgJiYgdGhpcy5wYXVzZWQoKSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gQ2hyb21lIEZpeC4gRml4ZWQgaW4gQ2hyb21lIHYxNi5cbiAgICAgICAgZGVsZXRlIHRoaXMudGFnLnBvc3RlcjtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgbG9nKCdkZWxldGluZyB0YWcucG9zdGVyIHRocm93cyBpbiBzb21lIGJyb3dzZXJzJywgZSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBSZXRyaWdnZXIgdGhlIGBsb2Fkc3RhcnRgIGV2ZW50IHRoYXQgd2FzIHRyaWdnZXJlZCBieSB0aGUge0BsaW5rIFRlY2h9LiBUaGlzXG4gICAqIGZ1bmN0aW9uIHdpbGwgYWxzbyB0cmlnZ2VyIHtAbGluayBQbGF5ZXIjZmlyc3RwbGF5fSBpZiBpdCBpcyB0aGUgZmlyc3QgbG9hZHN0YXJ0XG4gICAqIGZvciBhIHZpZGVvLlxuICAgKlxuICAgKiBAZmlyZXMgUGxheWVyI2xvYWRzdGFydFxuICAgKiBAZmlyZXMgUGxheWVyI2ZpcnN0cGxheVxuICAgKiBAbGlzdGVucyBUZWNoI2xvYWRzdGFydFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuaGFuZGxlVGVjaExvYWRTdGFydF8gPSBmdW5jdGlvbiBoYW5kbGVUZWNoTG9hZFN0YXJ0XygpIHtcbiAgICAvLyBUT0RPOiBVcGRhdGUgdG8gdXNlIGBlbXB0aWVkYCBldmVudCBpbnN0ZWFkLiBTZWUgIzEyNzcuXG5cbiAgICB0aGlzLnJlbW92ZUNsYXNzKCd2anMtZW5kZWQnKTtcbiAgICB0aGlzLnJlbW92ZUNsYXNzKCd2anMtc2Vla2luZycpO1xuXG4gICAgLy8gcmVzZXQgdGhlIGVycm9yIHN0YXRlXG4gICAgdGhpcy5lcnJvcihudWxsKTtcblxuICAgIC8vIElmIGl0J3MgYWxyZWFkeSBwbGF5aW5nIHdlIHdhbnQgdG8gdHJpZ2dlciBhIGZpcnN0cGxheSBldmVudCBub3cuXG4gICAgLy8gVGhlIGZpcnN0cGxheSBldmVudCByZWxpZXMgb24gYm90aCB0aGUgcGxheSBhbmQgbG9hZHN0YXJ0IGV2ZW50c1xuICAgIC8vIHdoaWNoIGNhbiBoYXBwZW4gaW4gYW55IG9yZGVyIGZvciBhIG5ldyBzb3VyY2VcbiAgICBpZiAoIXRoaXMucGF1c2VkKCkpIHtcbiAgICAgIC8qKlxuICAgICAgICogRmlyZWQgd2hlbiB0aGUgdXNlciBhZ2VudCBiZWdpbnMgbG9va2luZyBmb3IgbWVkaWEgZGF0YVxuICAgICAgICpcbiAgICAgICAqIEBldmVudCBQbGF5ZXIjbG9hZHN0YXJ0XG4gICAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gICAgICAgKi9cbiAgICAgIHRoaXMudHJpZ2dlcignbG9hZHN0YXJ0Jyk7XG4gICAgICB0aGlzLnRyaWdnZXIoJ2ZpcnN0cGxheScpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyByZXNldCB0aGUgaGFzU3RhcnRlZCBzdGF0ZVxuICAgICAgdGhpcy5oYXNTdGFydGVkKGZhbHNlKTtcbiAgICAgIHRoaXMudHJpZ2dlcignbG9hZHN0YXJ0Jyk7XG4gICAgfVxuXG4gICAgLy8gYXV0b3BsYXkgaGFwcGVucyBhZnRlciBsb2Fkc3RhcnQgZm9yIHRoZSBicm93c2VyLFxuICAgIC8vIHNvIHdlIG1pbWljIHRoYXQgYmVoYXZpb3JcbiAgICB0aGlzLm1hbnVhbEF1dG9wbGF5Xyh0aGlzLmF1dG9wbGF5KCkpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBIYW5kbGUgYXV0b3BsYXkgc3RyaW5nIHZhbHVlcywgcmF0aGVyIHRoYW4gdGhlIHR5cGljYWwgYm9vbGVhblxuICAgKiB2YWx1ZXMgdGhhdCBzaG91bGQgYmUgaGFuZGxlZCBieSB0aGUgdGVjaC4gTm90ZSB0aGF0IHRoaXMgaXMgbm90XG4gICAqIHBhcnQgb2YgYW55IHNwZWNpZmljYXRpb24uIFZhbGlkIHZhbHVlcyBhbmQgd2hhdCB0aGV5IGRvIGNhbiBiZVxuICAgKiBmb3VuZCBvbiB0aGUgYXV0b3BsYXkgZ2V0dGVyIGF0IFBsYXllciNhdXRvcGxheSgpXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5tYW51YWxBdXRvcGxheV8gPSBmdW5jdGlvbiBtYW51YWxBdXRvcGxheV8odHlwZSkge1xuICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgaWYgKCF0aGlzLnRlY2hfIHx8IHR5cGVvZiB0eXBlICE9PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBtdXRlZCA9IGZ1bmN0aW9uIG11dGVkKCkge1xuICAgICAgdmFyIHByZXZpb3VzbHlNdXRlZCA9IF90aGlzNC5tdXRlZCgpO1xuXG4gICAgICBfdGhpczQubXV0ZWQodHJ1ZSk7XG5cbiAgICAgIHZhciBwbGF5UHJvbWlzZSA9IF90aGlzNC5wbGF5KCk7XG5cbiAgICAgIGlmICghcGxheVByb21pc2UgfHwgIXBsYXlQcm9taXNlLnRoZW4gfHwgIXBsYXlQcm9taXNlWydjYXRjaCddKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBsYXlQcm9taXNlWydjYXRjaCddKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIC8vIHJlc3RvcmUgb2xkIHZhbHVlIG9mIG11dGVkIG9uIGZhaWx1cmVcbiAgICAgICAgX3RoaXM0Lm11dGVkKHByZXZpb3VzbHlNdXRlZCk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgdmFyIHByb21pc2UgPSB2b2lkIDA7XG5cbiAgICBpZiAodHlwZSA9PT0gJ2FueScpIHtcbiAgICAgIHByb21pc2UgPSB0aGlzLnBsYXkoKTtcblxuICAgICAgaWYgKHByb21pc2UgJiYgcHJvbWlzZS50aGVuICYmIHByb21pc2VbJ2NhdGNoJ10pIHtcbiAgICAgICAgcHJvbWlzZVsnY2F0Y2gnXShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIG11dGVkKCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ211dGVkJykge1xuICAgICAgcHJvbWlzZSA9IG11dGVkKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByb21pc2UgPSB0aGlzLnBsYXkoKTtcbiAgICB9XG5cbiAgICBpZiAoIXByb21pc2UgfHwgIXByb21pc2UudGhlbiB8fCAhcHJvbWlzZVsnY2F0Y2gnXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHJldHVybiBwcm9taXNlLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXM0LnRyaWdnZXIoeyB0eXBlOiAnYXV0b3BsYXktc3VjY2VzcycsIGF1dG9wbGF5OiB0eXBlIH0pO1xuICAgIH0pWydjYXRjaCddKGZ1bmN0aW9uIChlKSB7XG4gICAgICBfdGhpczQudHJpZ2dlcih7IHR5cGU6ICdhdXRvcGxheS1mYWlsdXJlJywgYXV0b3BsYXk6IHR5cGUgfSk7XG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSB0aGUgaW50ZXJuYWwgc291cmNlIGNhY2hlcyBzbyB0aGF0IHdlIHJldHVybiB0aGUgY29ycmVjdCBzb3VyY2UgZnJvbVxuICAgKiBgc3JjKClgLCBgY3VycmVudFNvdXJjZSgpYCwgYW5kIGBjdXJyZW50U291cmNlcygpYC5cbiAgICpcbiAgICogPiBOb3RlOiBgY3VycmVudFNvdXJjZXNgIHdpbGwgbm90IGJlIHVwZGF0ZWQgaWYgdGhlIHNvdXJjZSB0aGF0IGlzIHBhc3NlZCBpbiBleGlzdHNcbiAgICogICAgICAgICBpbiB0aGUgY3VycmVudCBgY3VycmVudFNvdXJjZXNgIGNhY2hlLlxuICAgKlxuICAgKlxuICAgKiBAcGFyYW0ge1RlY2h+U291cmNlT2JqZWN0fSBzcmNPYmpcbiAgICogICAgICAgIEEgc3RyaW5nIG9yIG9iamVjdCBzb3VyY2UgdG8gdXBkYXRlIG91ciBjYWNoZXMgdG8uXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS51cGRhdGVTb3VyY2VDYWNoZXNfID0gZnVuY3Rpb24gdXBkYXRlU291cmNlQ2FjaGVzXygpIHtcbiAgICB2YXIgc3JjT2JqID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAnJztcblxuXG4gICAgdmFyIHNyYyA9IHNyY09iajtcbiAgICB2YXIgdHlwZSA9ICcnO1xuXG4gICAgaWYgKHR5cGVvZiBzcmMgIT09ICdzdHJpbmcnKSB7XG4gICAgICBzcmMgPSBzcmNPYmouc3JjO1xuICAgICAgdHlwZSA9IHNyY09iai50eXBlO1xuICAgIH1cblxuICAgIC8vIG1ha2Ugc3VyZSBhbGwgdGhlIGNhY2hlcyBhcmUgc2V0IHRvIGRlZmF1bHQgdmFsdWVzXG4gICAgLy8gdG8gcHJldmVudCBudWxsIGNoZWNraW5nXG4gICAgdGhpcy5jYWNoZV8uc291cmNlID0gdGhpcy5jYWNoZV8uc291cmNlIHx8IHt9O1xuICAgIHRoaXMuY2FjaGVfLnNvdXJjZXMgPSB0aGlzLmNhY2hlXy5zb3VyY2VzIHx8IFtdO1xuXG4gICAgLy8gdHJ5IHRvIGdldCB0aGUgdHlwZSBvZiB0aGUgc3JjIHRoYXQgd2FzIHBhc3NlZCBpblxuICAgIGlmIChzcmMgJiYgIXR5cGUpIHtcbiAgICAgIHR5cGUgPSBmaW5kTWltZXR5cGUodGhpcywgc3JjKTtcbiAgICB9XG5cbiAgICAvLyB1cGRhdGUgYGN1cnJlbnRTb3VyY2VgIGNhY2hlIGFsd2F5c1xuICAgIHRoaXMuY2FjaGVfLnNvdXJjZSA9IG1lcmdlT3B0aW9ucyh7fSwgc3JjT2JqLCB7IHNyYzogc3JjLCB0eXBlOiB0eXBlIH0pO1xuXG4gICAgdmFyIG1hdGNoaW5nU291cmNlcyA9IHRoaXMuY2FjaGVfLnNvdXJjZXMuZmlsdGVyKGZ1bmN0aW9uIChzKSB7XG4gICAgICByZXR1cm4gcy5zcmMgJiYgcy5zcmMgPT09IHNyYztcbiAgICB9KTtcbiAgICB2YXIgc291cmNlRWxTb3VyY2VzID0gW107XG4gICAgdmFyIHNvdXJjZUVscyA9IHRoaXMuJCQoJ3NvdXJjZScpO1xuICAgIHZhciBtYXRjaGluZ1NvdXJjZUVscyA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzb3VyY2VFbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzb3VyY2VPYmogPSBnZXRBdHRyaWJ1dGVzKHNvdXJjZUVsc1tpXSk7XG5cbiAgICAgIHNvdXJjZUVsU291cmNlcy5wdXNoKHNvdXJjZU9iaik7XG5cbiAgICAgIGlmIChzb3VyY2VPYmouc3JjICYmIHNvdXJjZU9iai5zcmMgPT09IHNyYykge1xuICAgICAgICBtYXRjaGluZ1NvdXJjZUVscy5wdXNoKHNvdXJjZU9iai5zcmMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGlmIHdlIGhhdmUgbWF0Y2hpbmcgc291cmNlIGVscyBidXQgbm90IG1hdGNoaW5nIHNvdXJjZXNcbiAgICAvLyB0aGUgY3VycmVudCBzb3VyY2UgY2FjaGUgaXMgbm90IHVwIHRvIGRhdGVcbiAgICBpZiAobWF0Y2hpbmdTb3VyY2VFbHMubGVuZ3RoICYmICFtYXRjaGluZ1NvdXJjZXMubGVuZ3RoKSB7XG4gICAgICB0aGlzLmNhY2hlXy5zb3VyY2VzID0gc291cmNlRWxTb3VyY2VzO1xuICAgICAgLy8gaWYgd2UgZG9uJ3QgaGF2ZSBtYXRjaGluZyBzb3VyY2Ugb3Igc291cmNlIGVscyBzZXQgdGhlXG4gICAgICAvLyBzb3VyY2VzIGNhY2hlIHRvIHRoZSBgY3VycmVudFNvdXJjZWAgY2FjaGVcbiAgICB9IGVsc2UgaWYgKCFtYXRjaGluZ1NvdXJjZXMubGVuZ3RoKSB7XG4gICAgICB0aGlzLmNhY2hlXy5zb3VyY2VzID0gW3RoaXMuY2FjaGVfLnNvdXJjZV07XG4gICAgfVxuXG4gICAgLy8gdXBkYXRlIHRoZSB0ZWNoIGBzcmNgIGNhY2hlXG4gICAgdGhpcy5jYWNoZV8uc3JjID0gc3JjO1xuICB9O1xuXG4gIC8qKlxuICAgKiAqRVhQRVJJTUVOVEFMKiBGaXJlZCB3aGVuIHRoZSBzb3VyY2UgaXMgc2V0IG9yIGNoYW5nZWQgb24gdGhlIHtAbGluayBUZWNofVxuICAgKiBjYXVzaW5nIHRoZSBtZWRpYSBlbGVtZW50IHRvIHJlbG9hZC5cbiAgICpcbiAgICogSXQgd2lsbCBmaXJlIGZvciB0aGUgaW5pdGlhbCBzb3VyY2UgYW5kIGVhY2ggc3Vic2VxdWVudCBzb3VyY2UuXG4gICAqIFRoaXMgZXZlbnQgaXMgYSBjdXN0b20gZXZlbnQgZnJvbSBWaWRlby5qcyBhbmQgaXMgdHJpZ2dlcmVkIGJ5IHRoZSB7QGxpbmsgVGVjaH0uXG4gICAqXG4gICAqIFRoZSBldmVudCBvYmplY3QgZm9yIHRoaXMgZXZlbnQgY29udGFpbnMgYSBgc3JjYCBwcm9wZXJ0eSB0aGF0IHdpbGwgY29udGFpbiB0aGUgc291cmNlXG4gICAqIHRoYXQgd2FzIGF2YWlsYWJsZSB3aGVuIHRoZSBldmVudCB3YXMgdHJpZ2dlcmVkLiBUaGlzIGlzIGdlbmVyYWxseSBvbmx5IG5lY2Vzc2FyeSBpZiBWaWRlby5qc1xuICAgKiBpcyBzd2l0Y2hpbmcgdGVjaHMgd2hpbGUgdGhlIHNvdXJjZSB3YXMgYmVpbmcgY2hhbmdlZC5cbiAgICpcbiAgICogSXQgaXMgYWxzbyBmaXJlZCB3aGVuIGBsb2FkYCBpcyBjYWxsZWQgb24gdGhlIHBsYXllciAob3IgbWVkaWEgZWxlbWVudClcbiAgICogYmVjYXVzZSB0aGUge0BsaW5rIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL21lZGlhLmh0bWwjZG9tLW1lZGlhLWxvYWR8c3BlY2lmaWNhdGlvbiBmb3IgYGxvYWRgfVxuICAgKiBzYXlzIHRoYXQgdGhlIHJlc291cmNlIHNlbGVjdGlvbiBhbGdvcml0aG0gbmVlZHMgdG8gYmUgYWJvcnRlZCBhbmQgcmVzdGFydGVkLlxuICAgKiBJbiB0aGlzIGNhc2UsIGl0IGlzIHZlcnkgbGlrZWx5IHRoYXQgdGhlIGBzcmNgIHByb3BlcnR5IHdpbGwgYmUgc2V0IHRvIHRoZVxuICAgKiBlbXB0eSBzdHJpbmcgYFwiXCJgIHRvIGluZGljYXRlIHdlIGRvIG5vdCBrbm93IHdoYXQgdGhlIHNvdXJjZSB3aWxsIGJlIGJ1dFxuICAgKiB0aGF0IGl0IGlzIGNoYW5naW5nLlxuICAgKlxuICAgKiAqVGhpcyBldmVudCBpcyBjdXJyZW50bHkgc3RpbGwgZXhwZXJpbWVudGFsIGFuZCBtYXkgY2hhbmdlIGluIG1pbm9yIHJlbGVhc2VzLipcbiAgICogX19UbyB1c2UgdGhpcywgcGFzcyBgZW5hYmxlU291cmNlc2V0YCBvcHRpb24gdG8gdGhlIHBsYXllci5fX1xuICAgKlxuICAgKiBAZXZlbnQgUGxheWVyI3NvdXJjZXNldFxuICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gICAqIEBwcm9wIHtzdHJpbmd9IHNyY1xuICAgKiAgICAgICAgICAgICAgICBUaGUgc291cmNlIHVybCBhdmFpbGFibGUgd2hlbiB0aGUgYHNvdXJjZXNldGAgd2FzIHRyaWdnZXJlZC5cbiAgICogICAgICAgICAgICAgICAgSXQgd2lsbCBiZSBhbiBlbXB0eSBzdHJpbmcgaWYgd2UgY2Fubm90IGtub3cgd2hhdCB0aGUgc291cmNlIGlzXG4gICAqICAgICAgICAgICAgICAgIGJ1dCBrbm93IHRoYXQgdGhlIHNvdXJjZSB3aWxsIGNoYW5nZS5cbiAgICovXG4gIC8qKlxuICAgKiBSZXRyaWdnZXIgdGhlIGBzb3VyY2VzZXRgIGV2ZW50IHRoYXQgd2FzIHRyaWdnZXJlZCBieSB0aGUge0BsaW5rIFRlY2h9LlxuICAgKlxuICAgKiBAZmlyZXMgUGxheWVyI3NvdXJjZXNldFxuICAgKiBAbGlzdGVucyBUZWNoI3NvdXJjZXNldFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuaGFuZGxlVGVjaFNvdXJjZXNldF8gPSBmdW5jdGlvbiBoYW5kbGVUZWNoU291cmNlc2V0XyhldmVudCkge1xuICAgIHZhciBfdGhpczUgPSB0aGlzO1xuXG4gICAgLy8gb25seSB1cGRhdGUgdGhlIHNvdXJjZSBjYWNoZSB3aGVuIHRoZSBzb3VyY2VcbiAgICAvLyB3YXMgbm90IHVwZGF0ZWQgdXNpbmcgdGhlIHBsYXllciBhcGlcbiAgICBpZiAoIXRoaXMuY2hhbmdpbmdTcmNfKSB7XG4gICAgICB2YXIgdXBkYXRlU291cmNlQ2FjaGVzID0gZnVuY3Rpb24gdXBkYXRlU291cmNlQ2FjaGVzKHNyYykge1xuICAgICAgICByZXR1cm4gX3RoaXM1LnVwZGF0ZVNvdXJjZUNhY2hlc18oc3JjKTtcbiAgICAgIH07XG4gICAgICB2YXIgcGxheWVyU3JjID0gdGhpcy5jdXJyZW50U291cmNlKCkuc3JjO1xuICAgICAgdmFyIGV2ZW50U3JjID0gZXZlbnQuc3JjO1xuXG4gICAgICAvLyBpZiB3ZSBoYXZlIGEgcGxheWVyU3JjIHRoYXQgaXMgbm90IGEgYmxvYiwgYW5kIGEgdGVjaCBzcmMgdGhhdCBpcyBhIGJsb2JcbiAgICAgIGlmIChwbGF5ZXJTcmMgJiYgIS9eYmxvYjovLnRlc3QocGxheWVyU3JjKSAmJiAvXmJsb2I6Ly50ZXN0KGV2ZW50U3JjKSkge1xuXG4gICAgICAgIC8vIGlmIGJvdGggdGhlIHRlY2ggc291cmNlIGFuZCB0aGUgcGxheWVyIHNvdXJjZSB3ZXJlIHVwZGF0ZWQgd2UgYXNzdW1lXG4gICAgICAgIC8vIHNvbWV0aGluZyBsaWtlIEB2aWRlb2pzL2h0dHAtc3RyZWFtaW5nIGRpZCB0aGUgc291cmNlc2V0IGFuZCBza2lwIHVwZGF0aW5nIHRoZSBzb3VyY2UgY2FjaGUuXG4gICAgICAgIGlmICghdGhpcy5sYXN0U291cmNlXyB8fCB0aGlzLmxhc3RTb3VyY2VfLnRlY2ggIT09IGV2ZW50U3JjICYmIHRoaXMubGFzdFNvdXJjZV8ucGxheWVyICE9PSBwbGF5ZXJTcmMpIHtcbiAgICAgICAgICB1cGRhdGVTb3VyY2VDYWNoZXMgPSBmdW5jdGlvbiB1cGRhdGVTb3VyY2VDYWNoZXMoKSB7fTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyB1cGRhdGUgdGhlIHNvdXJjZSB0byB0aGUgaW50aWFsIHNvdXJjZSByaWdodCBhd2F5XG4gICAgICAvLyBpbiBzb21lIGNhc2VzIHRoaXMgd2lsbCBiZSBlbXB0eSBzdHJpbmdcbiAgICAgIHVwZGF0ZVNvdXJjZUNhY2hlcyhldmVudFNyYyk7XG5cbiAgICAgIC8vIGlmIHRoZSBgc291cmNlc2V0YCBgc3JjYCB3YXMgYW4gZW1wdHkgc3RyaW5nXG4gICAgICAvLyB3YWl0IGZvciBhIGBsb2Fkc3RhcnRgIHRvIHVwZGF0ZSB0aGUgY2FjaGUgdG8gYGN1cnJlbnRTcmNgLlxuICAgICAgLy8gSWYgYSBzb3VyY2VzZXQgaGFwcGVucyBiZWZvcmUgYSBgbG9hZHN0YXJ0YCwgd2UgcmVzZXQgdGhlIHN0YXRlXG4gICAgICAvLyBhcyB0aGlzIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIGFnYWluLlxuICAgICAgaWYgKCFldmVudC5zcmMpIHtcbiAgICAgICAgdmFyIHVwZGF0ZUNhY2hlID0gZnVuY3Rpb24gdXBkYXRlQ2FjaGUoZSkge1xuICAgICAgICAgIGlmIChlLnR5cGUgIT09ICdzb3VyY2VzZXQnKSB7XG4gICAgICAgICAgICB2YXIgdGVjaFNyYyA9IF90aGlzNS50ZWNoR2V0KCdjdXJyZW50U3JjJyk7XG5cbiAgICAgICAgICAgIF90aGlzNS5sYXN0U291cmNlXy50ZWNoID0gdGVjaFNyYztcbiAgICAgICAgICAgIF90aGlzNS51cGRhdGVTb3VyY2VDYWNoZXNfKHRlY2hTcmMpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIF90aGlzNS50ZWNoXy5vZmYoWydzb3VyY2VzZXQnLCAnbG9hZHN0YXJ0J10sIHVwZGF0ZUNhY2hlKTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLnRlY2hfLm9uZShbJ3NvdXJjZXNldCcsICdsb2Fkc3RhcnQnXSwgdXBkYXRlQ2FjaGUpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmxhc3RTb3VyY2VfID0geyBwbGF5ZXI6IHRoaXMuY3VycmVudFNvdXJjZSgpLnNyYywgdGVjaDogZXZlbnQuc3JjIH07XG5cbiAgICB0aGlzLnRyaWdnZXIoe1xuICAgICAgc3JjOiBldmVudC5zcmMsXG4gICAgICB0eXBlOiAnc291cmNlc2V0J1xuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBZGQvcmVtb3ZlIHRoZSB2anMtaGFzLXN0YXJ0ZWQgY2xhc3NcbiAgICpcbiAgICogQGZpcmVzIFBsYXllciNmaXJzdHBsYXlcbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSByZXF1ZXN0XG4gICAqICAgICAgICAtIHRydWU6IGFkZHMgdGhlIGNsYXNzXG4gICAqICAgICAgICAtIGZhbHNlOiByZW1vdmUgdGhlIGNsYXNzXG4gICAqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqICAgICAgICAgdGhlIGJvb2xlYW4gdmFsdWUgb2YgaGFzU3RhcnRlZF9cbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLmhhc1N0YXJ0ZWQgPSBmdW5jdGlvbiBoYXNTdGFydGVkKHJlcXVlc3QpIHtcbiAgICBpZiAocmVxdWVzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBhY3QgYXMgZ2V0dGVyLCBpZiB3ZSBoYXZlIG5vIHJlcXVlc3QgdG8gY2hhbmdlXG4gICAgICByZXR1cm4gdGhpcy5oYXNTdGFydGVkXztcbiAgICB9XG5cbiAgICBpZiAocmVxdWVzdCA9PT0gdGhpcy5oYXNTdGFydGVkXykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuaGFzU3RhcnRlZF8gPSByZXF1ZXN0O1xuXG4gICAgaWYgKHRoaXMuaGFzU3RhcnRlZF8pIHtcbiAgICAgIHRoaXMuYWRkQ2xhc3MoJ3Zqcy1oYXMtc3RhcnRlZCcpO1xuICAgICAgdGhpcy50cmlnZ2VyKCdmaXJzdHBsYXknKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yZW1vdmVDbGFzcygndmpzLWhhcy1zdGFydGVkJyk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBGaXJlZCB3aGVuZXZlciB0aGUgbWVkaWEgYmVnaW5zIG9yIHJlc3VtZXMgcGxheWJhY2tcbiAgICpcbiAgICogQHNlZSBbU3BlY117QGxpbmsgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZW1iZWRkZWQtY29udGVudC5odG1sI2RvbS1tZWRpYS1wbGF5fVxuICAgKiBAZmlyZXMgUGxheWVyI3BsYXlcbiAgICogQGxpc3RlbnMgVGVjaCNwbGF5XG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5oYW5kbGVUZWNoUGxheV8gPSBmdW5jdGlvbiBoYW5kbGVUZWNoUGxheV8oKSB7XG4gICAgdGhpcy5yZW1vdmVDbGFzcygndmpzLWVuZGVkJyk7XG4gICAgdGhpcy5yZW1vdmVDbGFzcygndmpzLXBhdXNlZCcpO1xuICAgIHRoaXMuYWRkQ2xhc3MoJ3Zqcy1wbGF5aW5nJyk7XG5cbiAgICAvLyBoaWRlIHRoZSBwb3N0ZXIgd2hlbiB0aGUgdXNlciBoaXRzIHBsYXlcbiAgICB0aGlzLmhhc1N0YXJ0ZWQodHJ1ZSk7XG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIHdoZW5ldmVyIGFuIHtAbGluayBUZWNoI3BsYXl9IGV2ZW50IGhhcHBlbnMuIEluZGljYXRlcyB0aGF0XG4gICAgICogcGxheWJhY2sgaGFzIHN0YXJ0ZWQgb3IgcmVzdW1lZC5cbiAgICAgKlxuICAgICAqIEBldmVudCBQbGF5ZXIjcGxheVxuICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAgICAgKi9cbiAgICB0aGlzLnRyaWdnZXIoJ3BsYXknKTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0cmlnZ2VyIHRoZSBgcmF0ZWNoYW5nZWAgZXZlbnQgdGhhdCB3YXMgdHJpZ2dlcmVkIGJ5IHRoZSB7QGxpbmsgVGVjaH0uXG4gICAqXG4gICAqIElmIHRoZXJlIHdlcmUgYW55IGV2ZW50cyBxdWV1ZWQgd2hpbGUgdGhlIHBsYXliYWNrIHJhdGUgd2FzIHplcm8sIGZpcmVcbiAgICogdGhvc2UgZXZlbnRzIG5vdy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQG1ldGhvZCBQbGF5ZXIjaGFuZGxlVGVjaFJhdGVDaGFuZ2VfXG4gICAqIEBmaXJlcyBQbGF5ZXIjcmF0ZWNoYW5nZVxuICAgKiBAbGlzdGVucyBUZWNoI3JhdGVjaGFuZ2VcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLmhhbmRsZVRlY2hSYXRlQ2hhbmdlXyA9IGZ1bmN0aW9uIGhhbmRsZVRlY2hSYXRlQ2hhbmdlXygpIHtcbiAgICBpZiAodGhpcy50ZWNoXy5wbGF5YmFja1JhdGUoKSA+IDAgJiYgdGhpcy5jYWNoZV8ubGFzdFBsYXliYWNrUmF0ZSA9PT0gMCkge1xuICAgICAgdGhpcy5xdWV1ZWRDYWxsYmFja3NfLmZvckVhY2goZnVuY3Rpb24gKHF1ZXVlZCkge1xuICAgICAgICByZXR1cm4gcXVldWVkLmNhbGxiYWNrKHF1ZXVlZC5ldmVudCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMucXVldWVkQ2FsbGJhY2tzXyA9IFtdO1xuICAgIH1cbiAgICB0aGlzLmNhY2hlXy5sYXN0UGxheWJhY2tSYXRlID0gdGhpcy50ZWNoXy5wbGF5YmFja1JhdGUoKTtcbiAgICAvKipcbiAgICAgKiBGaXJlcyB3aGVuIHRoZSBwbGF5aW5nIHNwZWVkIG9mIHRoZSBhdWRpby92aWRlbyBpcyBjaGFuZ2VkXG4gICAgICpcbiAgICAgKiBAZXZlbnQgUGxheWVyI3JhdGVjaGFuZ2VcbiAgICAgKiBAdHlwZSB7ZXZlbnR9XG4gICAgICovXG4gICAgdGhpcy50cmlnZ2VyKCdyYXRlY2hhbmdlJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHJpZ2dlciB0aGUgYHdhaXRpbmdgIGV2ZW50IHRoYXQgd2FzIHRyaWdnZXJlZCBieSB0aGUge0BsaW5rIFRlY2h9LlxuICAgKlxuICAgKiBAZmlyZXMgUGxheWVyI3dhaXRpbmdcbiAgICogQGxpc3RlbnMgVGVjaCN3YWl0aW5nXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5oYW5kbGVUZWNoV2FpdGluZ18gPSBmdW5jdGlvbiBoYW5kbGVUZWNoV2FpdGluZ18oKSB7XG4gICAgdmFyIF90aGlzNiA9IHRoaXM7XG5cbiAgICB0aGlzLmFkZENsYXNzKCd2anMtd2FpdGluZycpO1xuICAgIC8qKlxuICAgICAqIEEgcmVhZHlTdGF0ZSBjaGFuZ2Ugb24gdGhlIERPTSBlbGVtZW50IGhhcyBjYXVzZWQgcGxheWJhY2sgdG8gc3RvcC5cbiAgICAgKlxuICAgICAqIEBldmVudCBQbGF5ZXIjd2FpdGluZ1xuICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAgICAgKi9cbiAgICB0aGlzLnRyaWdnZXIoJ3dhaXRpbmcnKTtcbiAgICB0aGlzLm9uZSgndGltZXVwZGF0ZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfdGhpczYucmVtb3ZlQ2xhc3MoJ3Zqcy13YWl0aW5nJyk7XG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHJpZ2dlciB0aGUgYGNhbnBsYXlgIGV2ZW50IHRoYXQgd2FzIHRyaWdnZXJlZCBieSB0aGUge0BsaW5rIFRlY2h9LlxuICAgKiA+IE5vdGU6IFRoaXMgaXMgbm90IGNvbnNpc3RlbnQgYmV0d2VlbiBicm93c2Vycy4gU2VlICMxMzUxXG4gICAqXG4gICAqIEBmaXJlcyBQbGF5ZXIjY2FucGxheVxuICAgKiBAbGlzdGVucyBUZWNoI2NhbnBsYXlcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLmhhbmRsZVRlY2hDYW5QbGF5XyA9IGZ1bmN0aW9uIGhhbmRsZVRlY2hDYW5QbGF5XygpIHtcbiAgICB0aGlzLnJlbW92ZUNsYXNzKCd2anMtd2FpdGluZycpO1xuICAgIC8qKlxuICAgICAqIFRoZSBtZWRpYSBoYXMgYSByZWFkeVN0YXRlIG9mIEhBVkVfRlVUVVJFX0RBVEEgb3IgZ3JlYXRlci5cbiAgICAgKlxuICAgICAqIEBldmVudCBQbGF5ZXIjY2FucGxheVxuICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAgICAgKi9cbiAgICB0aGlzLnRyaWdnZXIoJ2NhbnBsYXknKTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0cmlnZ2VyIHRoZSBgY2FucGxheXRocm91Z2hgIGV2ZW50IHRoYXQgd2FzIHRyaWdnZXJlZCBieSB0aGUge0BsaW5rIFRlY2h9LlxuICAgKlxuICAgKiBAZmlyZXMgUGxheWVyI2NhbnBsYXl0aHJvdWdoXG4gICAqIEBsaXN0ZW5zIFRlY2gjY2FucGxheXRocm91Z2hcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLmhhbmRsZVRlY2hDYW5QbGF5VGhyb3VnaF8gPSBmdW5jdGlvbiBoYW5kbGVUZWNoQ2FuUGxheVRocm91Z2hfKCkge1xuICAgIHRoaXMucmVtb3ZlQ2xhc3MoJ3Zqcy13YWl0aW5nJyk7XG4gICAgLyoqXG4gICAgICogVGhlIG1lZGlhIGhhcyBhIHJlYWR5U3RhdGUgb2YgSEFWRV9FTk9VR0hfREFUQSBvciBncmVhdGVyLiBUaGlzIG1lYW5zIHRoYXQgdGhlXG4gICAgICogZW50aXJlIG1lZGlhIGZpbGUgY2FuIGJlIHBsYXllZCB3aXRob3V0IGJ1ZmZlcmluZy5cbiAgICAgKlxuICAgICAqIEBldmVudCBQbGF5ZXIjY2FucGxheXRocm91Z2hcbiAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gICAgICovXG4gICAgdGhpcy50cmlnZ2VyKCdjYW5wbGF5dGhyb3VnaCcpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXRyaWdnZXIgdGhlIGBwbGF5aW5nYCBldmVudCB0aGF0IHdhcyB0cmlnZ2VyZWQgYnkgdGhlIHtAbGluayBUZWNofS5cbiAgICpcbiAgICogQGZpcmVzIFBsYXllciNwbGF5aW5nXG4gICAqIEBsaXN0ZW5zIFRlY2gjcGxheWluZ1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuaGFuZGxlVGVjaFBsYXlpbmdfID0gZnVuY3Rpb24gaGFuZGxlVGVjaFBsYXlpbmdfKCkge1xuICAgIHRoaXMucmVtb3ZlQ2xhc3MoJ3Zqcy13YWl0aW5nJyk7XG4gICAgLyoqXG4gICAgICogVGhlIG1lZGlhIGlzIG5vIGxvbmdlciBibG9ja2VkIGZyb20gcGxheWJhY2ssIGFuZCBoYXMgc3RhcnRlZCBwbGF5aW5nLlxuICAgICAqXG4gICAgICogQGV2ZW50IFBsYXllciNwbGF5aW5nXG4gICAgICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICAgICAqL1xuICAgIHRoaXMudHJpZ2dlcigncGxheWluZycpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXRyaWdnZXIgdGhlIGBzZWVraW5nYCBldmVudCB0aGF0IHdhcyB0cmlnZ2VyZWQgYnkgdGhlIHtAbGluayBUZWNofS5cbiAgICpcbiAgICogQGZpcmVzIFBsYXllciNzZWVraW5nXG4gICAqIEBsaXN0ZW5zIFRlY2gjc2Vla2luZ1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuaGFuZGxlVGVjaFNlZWtpbmdfID0gZnVuY3Rpb24gaGFuZGxlVGVjaFNlZWtpbmdfKCkge1xuICAgIHRoaXMuYWRkQ2xhc3MoJ3Zqcy1zZWVraW5nJyk7XG4gICAgLyoqXG4gICAgICogRmlyZWQgd2hlbmV2ZXIgdGhlIHBsYXllciBpcyBqdW1waW5nIHRvIGEgbmV3IHRpbWVcbiAgICAgKlxuICAgICAqIEBldmVudCBQbGF5ZXIjc2Vla2luZ1xuICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAgICAgKi9cbiAgICB0aGlzLnRyaWdnZXIoJ3NlZWtpbmcnKTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0cmlnZ2VyIHRoZSBgc2Vla2VkYCBldmVudCB0aGF0IHdhcyB0cmlnZ2VyZWQgYnkgdGhlIHtAbGluayBUZWNofS5cbiAgICpcbiAgICogQGZpcmVzIFBsYXllciNzZWVrZWRcbiAgICogQGxpc3RlbnMgVGVjaCNzZWVrZWRcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLmhhbmRsZVRlY2hTZWVrZWRfID0gZnVuY3Rpb24gaGFuZGxlVGVjaFNlZWtlZF8oKSB7XG4gICAgdGhpcy5yZW1vdmVDbGFzcygndmpzLXNlZWtpbmcnKTtcbiAgICAvKipcbiAgICAgKiBGaXJlZCB3aGVuIHRoZSBwbGF5ZXIgaGFzIGZpbmlzaGVkIGp1bXBpbmcgdG8gYSBuZXcgdGltZVxuICAgICAqXG4gICAgICogQGV2ZW50IFBsYXllciNzZWVrZWRcbiAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gICAgICovXG4gICAgdGhpcy50cmlnZ2VyKCdzZWVrZWQnKTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0cmlnZ2VyIHRoZSBgZmlyc3RwbGF5YCBldmVudCB0aGF0IHdhcyB0cmlnZ2VyZWQgYnkgdGhlIHtAbGluayBUZWNofS5cbiAgICpcbiAgICogQGZpcmVzIFBsYXllciNmaXJzdHBsYXlcbiAgICogQGxpc3RlbnMgVGVjaCNmaXJzdHBsYXlcbiAgICogQGRlcHJlY2F0ZWQgQXMgb2YgNi4wIGZpcnN0cGxheSBldmVudCBpcyBkZXByZWNhdGVkLlxuICAgKiAgICAgICAgICAgICBBcyBvZiA2LjAgcGFzc2luZyB0aGUgYHN0YXJ0dGltZWAgb3B0aW9uIHRvIHRoZSBwbGF5ZXIgYW5kIHRoZSBmaXJzdHBsYXkgZXZlbnQgYXJlIGRlcHJlY2F0ZWQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5oYW5kbGVUZWNoRmlyc3RQbGF5XyA9IGZ1bmN0aW9uIGhhbmRsZVRlY2hGaXJzdFBsYXlfKCkge1xuICAgIC8vIElmIHRoZSBmaXJzdCBzdGFydHRpbWUgYXR0cmlidXRlIGlzIHNwZWNpZmllZFxuICAgIC8vIHRoZW4gd2Ugd2lsbCBzdGFydCBhdCB0aGUgZ2l2ZW4gb2Zmc2V0IGluIHNlY29uZHNcbiAgICBpZiAodGhpcy5vcHRpb25zXy5zdGFydHRpbWUpIHtcbiAgICAgIGxvZy53YXJuKCdQYXNzaW5nIHRoZSBgc3RhcnR0aW1lYCBvcHRpb24gdG8gdGhlIHBsYXllciB3aWxsIGJlIGRlcHJlY2F0ZWQgaW4gNi4wJyk7XG4gICAgICB0aGlzLmN1cnJlbnRUaW1lKHRoaXMub3B0aW9uc18uc3RhcnR0aW1lKTtcbiAgICB9XG5cbiAgICB0aGlzLmFkZENsYXNzKCd2anMtaGFzLXN0YXJ0ZWQnKTtcbiAgICAvKipcbiAgICAgKiBGaXJlZCB0aGUgZmlyc3QgdGltZSBhIHZpZGVvIGlzIHBsYXllZC4gTm90IHBhcnQgb2YgdGhlIEhMUyBzcGVjLCBhbmQgdGhpcyBpc1xuICAgICAqIHByb2JhYmx5IG5vdCB0aGUgYmVzdCBpbXBsZW1lbnRhdGlvbiB5ZXQsIHNvIHVzZSBzcGFyaW5nbHkuIElmIHlvdSBkb24ndCBoYXZlIGFcbiAgICAgKiByZWFzb24gdG8gcHJldmVudCBwbGF5YmFjaywgdXNlIGBteVBsYXllci5vbmUoJ3BsYXknKTtgIGluc3RlYWQuXG4gICAgICpcbiAgICAgKiBAZXZlbnQgUGxheWVyI2ZpcnN0cGxheVxuICAgICAqIEBkZXByZWNhdGVkIEFzIG9mIDYuMCBmaXJzdHBsYXkgZXZlbnQgaXMgZGVwcmVjYXRlZC5cbiAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gICAgICovXG4gICAgdGhpcy50cmlnZ2VyKCdmaXJzdHBsYXknKTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0cmlnZ2VyIHRoZSBgcGF1c2VgIGV2ZW50IHRoYXQgd2FzIHRyaWdnZXJlZCBieSB0aGUge0BsaW5rIFRlY2h9LlxuICAgKlxuICAgKiBAZmlyZXMgUGxheWVyI3BhdXNlXG4gICAqIEBsaXN0ZW5zIFRlY2gjcGF1c2VcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLmhhbmRsZVRlY2hQYXVzZV8gPSBmdW5jdGlvbiBoYW5kbGVUZWNoUGF1c2VfKCkge1xuICAgIHRoaXMucmVtb3ZlQ2xhc3MoJ3Zqcy1wbGF5aW5nJyk7XG4gICAgdGhpcy5hZGRDbGFzcygndmpzLXBhdXNlZCcpO1xuICAgIC8qKlxuICAgICAqIEZpcmVkIHdoZW5ldmVyIHRoZSBtZWRpYSBoYXMgYmVlbiBwYXVzZWRcbiAgICAgKlxuICAgICAqIEBldmVudCBQbGF5ZXIjcGF1c2VcbiAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gICAgICovXG4gICAgdGhpcy50cmlnZ2VyKCdwYXVzZScpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXRyaWdnZXIgdGhlIGBlbmRlZGAgZXZlbnQgdGhhdCB3YXMgdHJpZ2dlcmVkIGJ5IHRoZSB7QGxpbmsgVGVjaH0uXG4gICAqXG4gICAqIEBmaXJlcyBQbGF5ZXIjZW5kZWRcbiAgICogQGxpc3RlbnMgVGVjaCNlbmRlZFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuaGFuZGxlVGVjaEVuZGVkXyA9IGZ1bmN0aW9uIGhhbmRsZVRlY2hFbmRlZF8oKSB7XG4gICAgdGhpcy5hZGRDbGFzcygndmpzLWVuZGVkJyk7XG4gICAgaWYgKHRoaXMub3B0aW9uc18ubG9vcCkge1xuICAgICAgdGhpcy5jdXJyZW50VGltZSgwKTtcbiAgICAgIHRoaXMucGxheSgpO1xuICAgIH0gZWxzZSBpZiAoIXRoaXMucGF1c2VkKCkpIHtcbiAgICAgIHRoaXMucGF1c2UoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGaXJlZCB3aGVuIHRoZSBlbmQgb2YgdGhlIG1lZGlhIHJlc291cmNlIGlzIHJlYWNoZWQgKGN1cnJlbnRUaW1lID09IGR1cmF0aW9uKVxuICAgICAqXG4gICAgICogQGV2ZW50IFBsYXllciNlbmRlZFxuICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAgICAgKi9cbiAgICB0aGlzLnRyaWdnZXIoJ2VuZGVkJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEZpcmVkIHdoZW4gdGhlIGR1cmF0aW9uIG9mIHRoZSBtZWRpYSByZXNvdXJjZSBpcyBmaXJzdCBrbm93biBvciBjaGFuZ2VkXG4gICAqXG4gICAqIEBsaXN0ZW5zIFRlY2gjZHVyYXRpb25jaGFuZ2VcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLmhhbmRsZVRlY2hEdXJhdGlvbkNoYW5nZV8gPSBmdW5jdGlvbiBoYW5kbGVUZWNoRHVyYXRpb25DaGFuZ2VfKCkge1xuICAgIHRoaXMuZHVyYXRpb24odGhpcy50ZWNoR2V0XygnZHVyYXRpb24nKSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBhIGNsaWNrIG9uIHRoZSBtZWRpYSBlbGVtZW50IHRvIHBsYXkvcGF1c2VcbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gZXZlbnRcbiAgICogICAgICAgIHRoZSBldmVudCB0aGF0IGNhdXNlZCB0aGlzIGZ1bmN0aW9uIHRvIHRyaWdnZXJcbiAgICpcbiAgICogQGxpc3RlbnMgVGVjaCNtb3VzZWRvd25cbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLmhhbmRsZVRlY2hDbGlja18gPSBmdW5jdGlvbiBoYW5kbGVUZWNoQ2xpY2tfKGV2ZW50KSB7XG4gICAgaWYgKCFpc1NpbmdsZUxlZnRDbGljayhldmVudCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBXaGVuIGNvbnRyb2xzIGFyZSBkaXNhYmxlZCBhIGNsaWNrIHNob3VsZCBub3QgdG9nZ2xlIHBsYXliYWNrIGJlY2F1c2VcbiAgICAvLyB0aGUgY2xpY2sgaXMgY29uc2lkZXJlZCBhIGNvbnRyb2xcbiAgICBpZiAoIXRoaXMuY29udHJvbHNfKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMucGF1c2VkKCkpIHtcbiAgICAgIHNpbGVuY2VQcm9taXNlKHRoaXMucGxheSgpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wYXVzZSgpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogSGFuZGxlIGEgdGFwIG9uIHRoZSBtZWRpYSBlbGVtZW50LiBJdCB3aWxsIHRvZ2dsZSB0aGUgdXNlclxuICAgKiBhY3Rpdml0eSBzdGF0ZSwgd2hpY2ggaGlkZXMgYW5kIHNob3dzIHRoZSBjb250cm9scy5cbiAgICpcbiAgICogQGxpc3RlbnMgVGVjaCN0YXBcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLmhhbmRsZVRlY2hUYXBfID0gZnVuY3Rpb24gaGFuZGxlVGVjaFRhcF8oKSB7XG4gICAgdGhpcy51c2VyQWN0aXZlKCF0aGlzLnVzZXJBY3RpdmUoKSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEhhbmRsZSB0b3VjaCB0byBzdGFydFxuICAgKlxuICAgKiBAbGlzdGVucyBUZWNoI3RvdWNoc3RhcnRcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLmhhbmRsZVRlY2hUb3VjaFN0YXJ0XyA9IGZ1bmN0aW9uIGhhbmRsZVRlY2hUb3VjaFN0YXJ0XygpIHtcbiAgICB0aGlzLnVzZXJXYXNBY3RpdmUgPSB0aGlzLnVzZXJBY3RpdmUoKTtcbiAgfTtcblxuICAvKipcbiAgICogSGFuZGxlIHRvdWNoIHRvIG1vdmVcbiAgICpcbiAgICogQGxpc3RlbnMgVGVjaCN0b3VjaG1vdmVcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLmhhbmRsZVRlY2hUb3VjaE1vdmVfID0gZnVuY3Rpb24gaGFuZGxlVGVjaFRvdWNoTW92ZV8oKSB7XG4gICAgaWYgKHRoaXMudXNlcldhc0FjdGl2ZSkge1xuICAgICAgdGhpcy5yZXBvcnRVc2VyQWN0aXZpdHkoKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEhhbmRsZSB0b3VjaCB0byBlbmRcbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gZXZlbnRcbiAgICogICAgICAgIHRoZSB0b3VjaGVuZCBldmVudCB0aGF0IHRyaWdnZXJlZFxuICAgKiAgICAgICAgdGhpcyBmdW5jdGlvblxuICAgKlxuICAgKiBAbGlzdGVucyBUZWNoI3RvdWNoZW5kXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5oYW5kbGVUZWNoVG91Y2hFbmRfID0gZnVuY3Rpb24gaGFuZGxlVGVjaFRvdWNoRW5kXyhldmVudCkge1xuICAgIC8vIFN0b3AgdGhlIG1vdXNlIGV2ZW50cyBmcm9tIGFsc28gaGFwcGVuaW5nXG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgfTtcblxuICAvKipcbiAgICogRmlyZWQgd2hlbiB0aGUgcGxheWVyIHN3aXRjaGVzIGluIG9yIG91dCBvZiBmdWxsc2NyZWVuIG1vZGVcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQGxpc3RlbnMgUGxheWVyI2Z1bGxzY3JlZW5jaGFuZ2VcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLmhhbmRsZUZ1bGxzY3JlZW5DaGFuZ2VfID0gZnVuY3Rpb24gaGFuZGxlRnVsbHNjcmVlbkNoYW5nZV8oKSB7XG4gICAgaWYgKHRoaXMuaXNGdWxsc2NyZWVuKCkpIHtcbiAgICAgIHRoaXMuYWRkQ2xhc3MoJ3Zqcy1mdWxsc2NyZWVuJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVtb3ZlQ2xhc3MoJ3Zqcy1mdWxsc2NyZWVuJyk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBuYXRpdmUgY2xpY2sgZXZlbnRzIG9uIHRoZSBTV0YgYXJlbid0IHRyaWdnZXJlZCBvbiBJRTExLCBXaW44LjFSVFxuICAgKiB1c2Ugc3RhZ2VjbGljayBldmVudHMgdHJpZ2dlcmVkIGZyb20gaW5zaWRlIHRoZSBTV0YgaW5zdGVhZFxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAbGlzdGVucyBzdGFnZWNsaWNrXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5oYW5kbGVTdGFnZUNsaWNrXyA9IGZ1bmN0aW9uIGhhbmRsZVN0YWdlQ2xpY2tfKCkge1xuICAgIHRoaXMucmVwb3J0VXNlckFjdGl2aXR5KCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBUZWNoIEZ1bGxzY3JlZW4gQ2hhbmdlXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IGV2ZW50XG4gICAqICAgICAgICB0aGUgZnVsbHNjcmVlbmNoYW5nZSBldmVudCB0aGF0IHRyaWdnZXJlZCB0aGlzIGZ1bmN0aW9uXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAqICAgICAgICB0aGUgZGF0YSB0aGF0IHdhcyBzZW50IHdpdGggdGhlIGV2ZW50XG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBsaXN0ZW5zIFRlY2gjZnVsbHNjcmVlbmNoYW5nZVxuICAgKiBAZmlyZXMgUGxheWVyI2Z1bGxzY3JlZW5jaGFuZ2VcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLmhhbmRsZVRlY2hGdWxsc2NyZWVuQ2hhbmdlXyA9IGZ1bmN0aW9uIGhhbmRsZVRlY2hGdWxsc2NyZWVuQ2hhbmdlXyhldmVudCwgZGF0YSkge1xuICAgIGlmIChkYXRhKSB7XG4gICAgICB0aGlzLmlzRnVsbHNjcmVlbihkYXRhLmlzRnVsbHNjcmVlbik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZpcmVkIHdoZW4gZ29pbmcgaW4gYW5kIG91dCBvZiBmdWxsc2NyZWVuLlxuICAgICAqXG4gICAgICogQGV2ZW50IFBsYXllciNmdWxsc2NyZWVuY2hhbmdlXG4gICAgICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICAgICAqL1xuICAgIHRoaXMudHJpZ2dlcignZnVsbHNjcmVlbmNoYW5nZScpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBGaXJlcyB3aGVuIGFuIGVycm9yIG9jY3VycmVkIGR1cmluZyB0aGUgbG9hZGluZyBvZiBhbiBhdWRpby92aWRlby5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQGxpc3RlbnMgVGVjaCNlcnJvclxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuaGFuZGxlVGVjaEVycm9yXyA9IGZ1bmN0aW9uIGhhbmRsZVRlY2hFcnJvcl8oKSB7XG4gICAgdmFyIGVycm9yID0gdGhpcy50ZWNoXy5lcnJvcigpO1xuXG4gICAgdGhpcy5lcnJvcihlcnJvcik7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHJpZ2dlciB0aGUgYHRleHRkYXRhYCBldmVudCB0aGF0IHdhcyB0cmlnZ2VyZWQgYnkgdGhlIHtAbGluayBUZWNofS5cbiAgICpcbiAgICogQGZpcmVzIFBsYXllciN0ZXh0ZGF0YVxuICAgKiBAbGlzdGVucyBUZWNoI3RleHRkYXRhXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5oYW5kbGVUZWNoVGV4dERhdGFfID0gZnVuY3Rpb24gaGFuZGxlVGVjaFRleHREYXRhXygpIHtcbiAgICB2YXIgZGF0YSA9IG51bGw7XG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgIGRhdGEgPSBhcmd1bWVudHNbMV07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmlyZXMgd2hlbiB3ZSBnZXQgYSB0ZXh0ZGF0YSBldmVudCBmcm9tIHRlY2hcbiAgICAgKlxuICAgICAqIEBldmVudCBQbGF5ZXIjdGV4dGRhdGFcbiAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gICAgICovXG4gICAgdGhpcy50cmlnZ2VyKCd0ZXh0ZGF0YScsIGRhdGEpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgb2JqZWN0IGZvciBjYWNoZWQgdmFsdWVzLlxuICAgKlxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqICAgICAgICAgZ2V0IHRoZSBjdXJyZW50IG9iamVjdCBjYWNoZVxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuZ2V0Q2FjaGUgPSBmdW5jdGlvbiBnZXRDYWNoZSgpIHtcbiAgICByZXR1cm4gdGhpcy5jYWNoZV87XG4gIH07XG5cbiAgLyoqXG4gICAqIFBhc3MgdmFsdWVzIHRvIHRoZSBwbGF5YmFjayB0ZWNoXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbbWV0aG9kXVxuICAgKiAgICAgICAgdGhlIG1ldGhvZCB0byBjYWxsXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBhcmdcbiAgICogICAgICAgIHRoZSBhcmd1bWVudCB0byBwYXNzXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS50ZWNoQ2FsbF8gPSBmdW5jdGlvbiB0ZWNoQ2FsbF8obWV0aG9kLCBhcmcpIHtcbiAgICAvLyBJZiBpdCdzIG5vdCByZWFkeSB5ZXQsIGNhbGwgbWV0aG9kIHdoZW4gaXQgaXNcblxuICAgIHRoaXMucmVhZHkoZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKG1ldGhvZCBpbiBhbGxvd2VkU2V0dGVycykge1xuICAgICAgICByZXR1cm4gc2V0JDEodGhpcy5taWRkbGV3YXJlXywgdGhpcy50ZWNoXywgbWV0aG9kLCBhcmcpO1xuICAgICAgfSBlbHNlIGlmIChtZXRob2QgaW4gYWxsb3dlZE1lZGlhdG9ycykge1xuICAgICAgICByZXR1cm4gbWVkaWF0ZSh0aGlzLm1pZGRsZXdhcmVfLCB0aGlzLnRlY2hfLCBtZXRob2QsIGFyZyk7XG4gICAgICB9XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICh0aGlzLnRlY2hfKSB7XG4gICAgICAgICAgdGhpcy50ZWNoX1ttZXRob2RdKGFyZyk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgbG9nKGUpO1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgIH0sIHRydWUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgY2FsbHMgY2FuJ3Qgd2FpdCBmb3IgdGhlIHRlY2gsIGFuZCBzb21ldGltZXMgZG9uJ3QgbmVlZCB0by5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IG1ldGhvZFxuICAgKiAgICAgICAgVGVjaCBtZXRob2RcbiAgICpcbiAgICogQHJldHVybiB7RnVuY3Rpb258dW5kZWZpbmVkfVxuICAgKiAgICAgICAgIHRoZSBtZXRob2Qgb3IgdW5kZWZpbmVkXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS50ZWNoR2V0XyA9IGZ1bmN0aW9uIHRlY2hHZXRfKG1ldGhvZCkge1xuICAgIGlmICghdGhpcy50ZWNoXyB8fCAhdGhpcy50ZWNoXy5pc1JlYWR5Xykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChtZXRob2QgaW4gYWxsb3dlZEdldHRlcnMpIHtcbiAgICAgIHJldHVybiBnZXQkMSh0aGlzLm1pZGRsZXdhcmVfLCB0aGlzLnRlY2hfLCBtZXRob2QpO1xuICAgIH0gZWxzZSBpZiAobWV0aG9kIGluIGFsbG93ZWRNZWRpYXRvcnMpIHtcbiAgICAgIHJldHVybiBtZWRpYXRlKHRoaXMubWlkZGxld2FyZV8sIHRoaXMudGVjaF8sIG1ldGhvZCk7XG4gICAgfVxuXG4gICAgLy8gRmxhc2ggbGlrZXMgdG8gZGllIGFuZCByZWxvYWQgd2hlbiB5b3UgaGlkZSBvciByZXBvc2l0aW9uIGl0LlxuICAgIC8vIEluIHRoZXNlIGNhc2VzIHRoZSBvYmplY3QgbWV0aG9kcyBnbyBhd2F5IGFuZCB3ZSBnZXQgZXJyb3JzLlxuICAgIC8vIFdoZW4gdGhhdCBoYXBwZW5zIHdlJ2xsIGNhdGNoIHRoZSBlcnJvcnMgYW5kIGluZm9ybSB0ZWNoIHRoYXQgaXQncyBub3QgcmVhZHkgYW55IG1vcmUuXG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB0aGlzLnRlY2hfW21ldGhvZF0oKTtcbiAgICB9IGNhdGNoIChlKSB7XG5cbiAgICAgIC8vIFdoZW4gYnVpbGRpbmcgYWRkaXRpb25hbCB0ZWNoIGxpYnMsIGFuIGV4cGVjdGVkIG1ldGhvZCBtYXkgbm90IGJlIGRlZmluZWQgeWV0XG4gICAgICBpZiAodGhpcy50ZWNoX1ttZXRob2RdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbG9nKCdWaWRlby5qczogJyArIG1ldGhvZCArICcgbWV0aG9kIG5vdCBkZWZpbmVkIGZvciAnICsgdGhpcy50ZWNoTmFtZV8gKyAnIHBsYXliYWNrIHRlY2hub2xvZ3kuJywgZSk7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG5cbiAgICAgIC8vIFdoZW4gYSBtZXRob2QgaXNuJ3QgYXZhaWxhYmxlIG9uIHRoZSBvYmplY3QgaXQgdGhyb3dzIGEgVHlwZUVycm9yXG4gICAgICBpZiAoZS5uYW1lID09PSAnVHlwZUVycm9yJykge1xuICAgICAgICBsb2coJ1ZpZGVvLmpzOiAnICsgbWV0aG9kICsgJyB1bmF2YWlsYWJsZSBvbiAnICsgdGhpcy50ZWNoTmFtZV8gKyAnIHBsYXliYWNrIHRlY2hub2xvZ3kgZWxlbWVudC4nLCBlKTtcbiAgICAgICAgdGhpcy50ZWNoXy5pc1JlYWR5XyA9IGZhbHNlO1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuXG4gICAgICAvLyBJZiBlcnJvciB1bmtub3duLCBqdXN0IGxvZyBhbmQgdGhyb3dcbiAgICAgIGxvZyhlKTtcbiAgICAgIHRocm93IGU7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBBdHRlbXB0IHRvIGJlZ2luIHBsYXliYWNrIGF0IHRoZSBmaXJzdCBvcHBvcnR1bml0eS5cbiAgICpcbiAgICogQHJldHVybiB7UHJvbWlzZXx1bmRlZmluZWR9XG4gICAqICAgICAgICAgUmV0dXJucyBhIHByb21pc2UgaWYgdGhlIGJyb3dzZXIgc3VwcG9ydHMgUHJvbWlzZXMgKG9yIG9uZVxuICAgKiAgICAgICAgIHdhcyBwYXNzZWQgaW4gYXMgYW4gb3B0aW9uKS4gVGhpcyBwcm9taXNlIHdpbGwgYmUgcmVzb2x2ZWQgb25cbiAgICogICAgICAgICB0aGUgcmV0dXJuIHZhbHVlIG9mIHBsYXkuIElmIHRoaXMgaXMgdW5kZWZpbmVkIGl0IHdpbGwgZnVsZmlsbCB0aGVcbiAgICogICAgICAgICBwcm9taXNlIGNoYWluIG90aGVyd2lzZSB0aGUgcHJvbWlzZSBjaGFpbiB3aWxsIGJlIGZ1bGZpbGxlZCB3aGVuXG4gICAqICAgICAgICAgdGhlIHByb21pc2UgZnJvbSBwbGF5IGlzIGZ1bGZpbGxlZC5cbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLnBsYXkgPSBmdW5jdGlvbiBwbGF5KCkge1xuICAgIHZhciBfdGhpczcgPSB0aGlzO1xuXG4gICAgdmFyIFByb21pc2VDbGFzcyA9IHRoaXMub3B0aW9uc18uUHJvbWlzZSB8fCB3aW5kb3cuUHJvbWlzZTtcblxuICAgIGlmIChQcm9taXNlQ2xhc3MpIHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZUNsYXNzKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgIF90aGlzNy5wbGF5XyhyZXNvbHZlKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnBsYXlfKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoZSBhY3R1YWwgbG9naWMgZm9yIHBsYXksIHRha2VzIGEgY2FsbGJhY2sgdGhhdCB3aWxsIGJlIHJlc29sdmVkIG9uIHRoZVxuICAgKiByZXR1cm4gdmFsdWUgb2YgcGxheS4gVGhpcyBhbGxvd3MgdXMgdG8gcmVzb2x2ZSB0byB0aGUgcGxheSBwcm9taXNlIGlmIHRoZXJlXG4gICAqIGlzIG9uZSBvbiBtb2Rlcm4gYnJvd3NlcnMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja11cbiAgICogICAgICAgIFRoZSBjYWxsYmFjayB0aGF0IHNob3VsZCBiZSBjYWxsZWQgd2hlbiB0aGUgdGVjaHMgcGxheSBpcyBhY3R1YWxseSBjYWxsZWRcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLnBsYXlfID0gZnVuY3Rpb24gcGxheV8oKSB7XG4gICAgdmFyIF90aGlzOCA9IHRoaXM7XG5cbiAgICB2YXIgY2FsbGJhY2sgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHNpbGVuY2VQcm9taXNlO1xuXG4gICAgLy8gSWYgdGhpcyBpcyBjYWxsZWQgd2hpbGUgd2UgaGF2ZSBhIHBsYXkgcXVldWVkIHVwIG9uIGEgbG9hZHN0YXJ0LCByZW1vdmVcbiAgICAvLyB0aGF0IGxpc3RlbmVyIHRvIGF2b2lkIGdldHRpbmcgaW4gYSBwb3RlbnRpYWxseSBiYWQgc3RhdGUuXG4gICAgaWYgKHRoaXMucGxheU9uTG9hZHN0YXJ0Xykge1xuICAgICAgdGhpcy5vZmYoJ2xvYWRzdGFydCcsIHRoaXMucGxheU9uTG9hZHN0YXJ0Xyk7XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIHBsYXllci90ZWNoIGlzIG5vdCByZWFkeSwgcXVldWUgdXAgYW5vdGhlciBjYWxsIHRvIGBwbGF5KClgIGZvclxuICAgIC8vIHdoZW4gaXQgaXMuIFRoaXMgd2lsbCBsb29wIGJhY2sgaW50byB0aGlzIG1ldGhvZCBmb3IgYW5vdGhlciBhdHRlbXB0IGF0XG4gICAgLy8gcGxheWJhY2sgd2hlbiB0aGUgdGVjaCBpcyByZWFkeS5cbiAgICBpZiAoIXRoaXMuaXNSZWFkeV8pIHtcblxuICAgICAgLy8gQmFpbCBvdXQgaWYgd2UncmUgYWxyZWFkeSB3YWl0aW5nIGZvciBgcmVhZHlgIVxuICAgICAgaWYgKHRoaXMucGxheVdhaXRpbmdGb3JSZWFkeV8pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnBsYXlXYWl0aW5nRm9yUmVhZHlfID0gdHJ1ZTtcbiAgICAgIHRoaXMucmVhZHkoZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpczgucGxheVdhaXRpbmdGb3JSZWFkeV8gPSBmYWxzZTtcbiAgICAgICAgY2FsbGJhY2soX3RoaXM4LnBsYXkoKSk7XG4gICAgICB9KTtcblxuICAgICAgLy8gSWYgdGhlIHBsYXllci90ZWNoIGlzIHJlYWR5IGFuZCB3ZSBoYXZlIGEgc291cmNlLCB3ZSBjYW4gYXR0ZW1wdCBwbGF5YmFjay5cbiAgICB9IGVsc2UgaWYgKCF0aGlzLmNoYW5naW5nU3JjXyAmJiAodGhpcy5zcmMoKSB8fCB0aGlzLmN1cnJlbnRTcmMoKSkpIHtcbiAgICAgIGNhbGxiYWNrKHRoaXMudGVjaEdldF8oJ3BsYXknKSk7XG4gICAgICByZXR1cm47XG5cbiAgICAgIC8vIElmIHRoZSB0ZWNoIGlzIHJlYWR5LCBidXQgd2UgZG8gbm90IGhhdmUgYSBzb3VyY2UsIHdlJ2xsIG5lZWQgdG8gd2FpdFxuICAgICAgLy8gZm9yIGJvdGggdGhlIGByZWFkeWAgYW5kIGEgYGxvYWRzdGFydGAgd2hlbiB0aGUgc291cmNlIGlzIGZpbmFsbHlcbiAgICAgIC8vIHJlc29sdmVkIGJ5IG1pZGRsZXdhcmUgYW5kIHNldCBvbiB0aGUgcGxheWVyLlxuICAgICAgLy9cbiAgICAgIC8vIFRoaXMgY2FuIGhhcHBlbiBpZiBgcGxheSgpYCBpcyBjYWxsZWQgd2hpbGUgY2hhbmdpbmcgc291cmNlcyBvciBiZWZvcmVcbiAgICAgIC8vIG9uZSBoYXMgYmVlbiBzZXQgb24gdGhlIHBsYXllci5cbiAgICB9IGVsc2Uge1xuXG4gICAgICB0aGlzLnBsYXlPbkxvYWRzdGFydF8gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzOC5wbGF5T25Mb2Fkc3RhcnRfID0gbnVsbDtcbiAgICAgICAgY2FsbGJhY2soX3RoaXM4LnBsYXkoKSk7XG4gICAgICB9O1xuXG4gICAgICB0aGlzLm9uZSgnbG9hZHN0YXJ0JywgdGhpcy5wbGF5T25Mb2Fkc3RhcnRfKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFBhdXNlIHRoZSB2aWRlbyBwbGF5YmFja1xuICAgKlxuICAgKiBAcmV0dXJuIHtQbGF5ZXJ9XG4gICAqICAgICAgICAgQSByZWZlcmVuY2UgdG8gdGhlIHBsYXllciBvYmplY3QgdGhpcyBmdW5jdGlvbiB3YXMgY2FsbGVkIG9uXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uIHBhdXNlKCkge1xuICAgIHRoaXMudGVjaENhbGxfKCdwYXVzZScpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDaGVjayBpZiB0aGUgcGxheWVyIGlzIHBhdXNlZCBvciBoYXMgeWV0IHRvIHBsYXlcbiAgICpcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICogICAgICAgICAtIGZhbHNlOiBpZiB0aGUgbWVkaWEgaXMgY3VycmVudGx5IHBsYXlpbmdcbiAgICogICAgICAgICAtIHRydWU6IGlmIG1lZGlhIGlzIG5vdCBjdXJyZW50bHkgcGxheWluZ1xuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUucGF1c2VkID0gZnVuY3Rpb24gcGF1c2VkKCkge1xuICAgIC8vIFRoZSBpbml0aWFsIHN0YXRlIG9mIHBhdXNlZCBzaG91bGQgYmUgdHJ1ZSAoaW4gU2FmYXJpIGl0J3MgYWN0dWFsbHkgZmFsc2UpXG4gICAgcmV0dXJuIHRoaXMudGVjaEdldF8oJ3BhdXNlZCcpID09PSBmYWxzZSA/IGZhbHNlIDogdHJ1ZTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IGEgVGltZVJhbmdlIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIGN1cnJlbnQgcmFuZ2VzIG9mIHRpbWUgdGhhdCB0aGUgdXNlclxuICAgKiBoYXMgcGxheWVkLlxuICAgKlxuICAgKiBAcmV0dXJuIHtUaW1lUmFuZ2V9XG4gICAqICAgICAgICAgQSB0aW1lIHJhbmdlIG9iamVjdCB0aGF0IHJlcHJlc2VudHMgYWxsIHRoZSBpbmNyZW1lbnRzIG9mIHRpbWUgdGhhdCBoYXZlXG4gICAqICAgICAgICAgYmVlbiBwbGF5ZWQuXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5wbGF5ZWQgPSBmdW5jdGlvbiBwbGF5ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMudGVjaEdldF8oJ3BsYXllZCcpIHx8IGNyZWF0ZVRpbWVSYW5nZXMoMCwgMCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHVzZXIgaXMgXCJzY3J1YmJpbmdcIi4gU2NydWJiaW5nIGlzXG4gICAqIHdoZW4gdGhlIHVzZXIgaGFzIGNsaWNrZWQgdGhlIHByb2dyZXNzIGJhciBoYW5kbGUgYW5kIGlzXG4gICAqIGRyYWdnaW5nIGl0IGFsb25nIHRoZSBwcm9ncmVzcyBiYXIuXG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzU2NydWJiaW5nXVxuICAgKiAgICAgICAgd2V0aGVyIHRoZSB1c2VyIGlzIG9yIGlzIG5vdCBzY3J1YmJpbmdcbiAgICpcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICogICAgICAgICBUaGUgdmFsdWUgb2Ygc2NydWJiaW5nIHdoZW4gZ2V0dGluZ1xuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuc2NydWJiaW5nID0gZnVuY3Rpb24gc2NydWJiaW5nKGlzU2NydWJiaW5nKSB7XG4gICAgaWYgKHR5cGVvZiBpc1NjcnViYmluZyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiB0aGlzLnNjcnViYmluZ187XG4gICAgfVxuICAgIHRoaXMuc2NydWJiaW5nXyA9ICEhaXNTY3J1YmJpbmc7XG5cbiAgICBpZiAoaXNTY3J1YmJpbmcpIHtcbiAgICAgIHRoaXMuYWRkQ2xhc3MoJ3Zqcy1zY3J1YmJpbmcnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yZW1vdmVDbGFzcygndmpzLXNjcnViYmluZycpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogR2V0IG9yIHNldCB0aGUgY3VycmVudCB0aW1lIChpbiBzZWNvbmRzKVxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IFtzZWNvbmRzXVxuICAgKiAgICAgICAgVGhlIHRpbWUgdG8gc2VlayB0byBpbiBzZWNvbmRzXG4gICAqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICogICAgICAgICAtIHRoZSBjdXJyZW50IHRpbWUgaW4gc2Vjb25kcyB3aGVuIGdldHRpbmdcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLmN1cnJlbnRUaW1lID0gZnVuY3Rpb24gY3VycmVudFRpbWUoc2Vjb25kcykge1xuICAgIGlmICh0eXBlb2Ygc2Vjb25kcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGlmIChzZWNvbmRzIDwgMCkge1xuICAgICAgICBzZWNvbmRzID0gMDtcbiAgICAgIH1cbiAgICAgIHRoaXMudGVjaENhbGxfKCdzZXRDdXJyZW50VGltZScsIHNlY29uZHMpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGNhY2hlIGxhc3QgY3VycmVudFRpbWUgYW5kIHJldHVybi4gZGVmYXVsdCB0byAwIHNlY29uZHNcbiAgICAvL1xuICAgIC8vIENhY2hpbmcgdGhlIGN1cnJlbnRUaW1lIGlzIG1lYW50IHRvIHByZXZlbnQgYSBtYXNzaXZlIGFtb3VudCBvZiByZWFkcyBvbiB0aGUgdGVjaCdzXG4gICAgLy8gY3VycmVudFRpbWUgd2hlbiBzY3J1YmJpbmcsIGJ1dCBtYXkgbm90IHByb3ZpZGUgbXVjaCBwZXJmb3JtYW5jZSBiZW5lZml0IGFmdGVyYWxsLlxuICAgIC8vIFNob3VsZCBiZSB0ZXN0ZWQuIEFsc28gc29tZXRoaW5nIGhhcyB0byByZWFkIHRoZSBhY3R1YWwgY3VycmVudCB0aW1lIG9yIHRoZSBjYWNoZSB3aWxsXG4gICAgLy8gbmV2ZXIgZ2V0IHVwZGF0ZWQuXG4gICAgdGhpcy5jYWNoZV8uY3VycmVudFRpbWUgPSB0aGlzLnRlY2hHZXRfKCdjdXJyZW50VGltZScpIHx8IDA7XG4gICAgcmV0dXJuIHRoaXMuY2FjaGVfLmN1cnJlbnRUaW1lO1xuICB9O1xuXG4gIC8qKlxuICAgKiBOb3JtYWxseSBnZXRzIHRoZSBsZW5ndGggaW4gdGltZSBvZiB0aGUgdmlkZW8gaW4gc2Vjb25kcztcbiAgICogaW4gYWxsIGJ1dCB0aGUgcmFyZXN0IHVzZSBjYXNlcyBhbiBhcmd1bWVudCB3aWxsIE5PVCBiZSBwYXNzZWQgdG8gdGhlIG1ldGhvZFxuICAgKlxuICAgKiA+ICoqTk9URSoqOiBUaGUgdmlkZW8gbXVzdCBoYXZlIHN0YXJ0ZWQgbG9hZGluZyBiZWZvcmUgdGhlIGR1cmF0aW9uIGNhbiBiZVxuICAgKiBrbm93biwgYW5kIGluIHRoZSBjYXNlIG9mIEZsYXNoLCBtYXkgbm90IGJlIGtub3duIHVudGlsIHRoZSB2aWRlbyBzdGFydHNcbiAgICogcGxheWluZy5cbiAgICpcbiAgICogQGZpcmVzIFBsYXllciNkdXJhdGlvbmNoYW5nZVxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gW3NlY29uZHNdXG4gICAqICAgICAgICBUaGUgZHVyYXRpb24gb2YgdGhlIHZpZGVvIHRvIHNldCBpbiBzZWNvbmRzXG4gICAqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICogICAgICAgICAtIFRoZSBkdXJhdGlvbiBvZiB0aGUgdmlkZW8gaW4gc2Vjb25kcyB3aGVuIGdldHRpbmdcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLmR1cmF0aW9uID0gZnVuY3Rpb24gZHVyYXRpb24oc2Vjb25kcykge1xuICAgIGlmIChzZWNvbmRzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIHJldHVybiBOYU4gaWYgdGhlIGR1cmF0aW9uIGlzIG5vdCBrbm93blxuICAgICAgcmV0dXJuIHRoaXMuY2FjaGVfLmR1cmF0aW9uICE9PSB1bmRlZmluZWQgPyB0aGlzLmNhY2hlXy5kdXJhdGlvbiA6IE5hTjtcbiAgICB9XG5cbiAgICBzZWNvbmRzID0gcGFyc2VGbG9hdChzZWNvbmRzKTtcblxuICAgIC8vIFN0YW5kYXJkaXplIG9uIEluaWZpdHkgZm9yIHNpZ25hbGluZyB2aWRlbyBpcyBsaXZlXG4gICAgaWYgKHNlY29uZHMgPCAwKSB7XG4gICAgICBzZWNvbmRzID0gSW5maW5pdHk7XG4gICAgfVxuXG4gICAgaWYgKHNlY29uZHMgIT09IHRoaXMuY2FjaGVfLmR1cmF0aW9uKSB7XG4gICAgICAvLyBDYWNoZSB0aGUgbGFzdCBzZXQgdmFsdWUgZm9yIG9wdGltaXplZCBzY3J1YmJpbmcgKGVzcC4gRmxhc2gpXG4gICAgICB0aGlzLmNhY2hlXy5kdXJhdGlvbiA9IHNlY29uZHM7XG5cbiAgICAgIGlmIChzZWNvbmRzID09PSBJbmZpbml0eSkge1xuICAgICAgICB0aGlzLmFkZENsYXNzKCd2anMtbGl2ZScpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5yZW1vdmVDbGFzcygndmpzLWxpdmUnKTtcbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICogQGV2ZW50IFBsYXllciNkdXJhdGlvbmNoYW5nZVxuICAgICAgICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICAgICAgICovXG4gICAgICB0aGlzLnRyaWdnZXIoJ2R1cmF0aW9uY2hhbmdlJyk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGVzIGhvdyBtdWNoIHRpbWUgaXMgbGVmdCBpbiB0aGUgdmlkZW8uIE5vdCBwYXJ0XG4gICAqIG9mIHRoZSBuYXRpdmUgdmlkZW8gQVBJLlxuICAgKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqICAgICAgICAgVGhlIHRpbWUgcmVtYWluaW5nIGluIHNlY29uZHNcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLnJlbWFpbmluZ1RpbWUgPSBmdW5jdGlvbiByZW1haW5pbmdUaW1lKCkge1xuICAgIHJldHVybiB0aGlzLmR1cmF0aW9uKCkgLSB0aGlzLmN1cnJlbnRUaW1lKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEEgcmVtYWluaW5nIHRpbWUgZnVuY3Rpb24gdGhhdCBpcyBpbnRlbnRlZCB0byBiZSB1c2VkIHdoZW5cbiAgICogdGhlIHRpbWUgaXMgdG8gYmUgZGlzcGxheWVkIGRpcmVjdGx5IHRvIHRoZSB1c2VyLlxuICAgKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqICAgICAgICAgVGhlIHJvdW5kZWQgdGltZSByZW1haW5pbmcgaW4gc2Vjb25kc1xuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUucmVtYWluaW5nVGltZURpc3BsYXkgPSBmdW5jdGlvbiByZW1haW5pbmdUaW1lRGlzcGxheSgpIHtcbiAgICByZXR1cm4gTWF0aC5mbG9vcih0aGlzLmR1cmF0aW9uKCkpIC0gTWF0aC5mbG9vcih0aGlzLmN1cnJlbnRUaW1lKCkpO1xuICB9O1xuXG4gIC8vXG4gIC8vIEtpbmQgb2YgbGlrZSBhbiBhcnJheSBvZiBwb3J0aW9ucyBvZiB0aGUgdmlkZW8gdGhhdCBoYXZlIGJlZW4gZG93bmxvYWRlZC5cblxuICAvKipcbiAgICogR2V0IGEgVGltZVJhbmdlIG9iamVjdCB3aXRoIGFuIGFycmF5IG9mIHRoZSB0aW1lcyBvZiB0aGUgdmlkZW9cbiAgICogdGhhdCBoYXZlIGJlZW4gZG93bmxvYWRlZC4gSWYgeW91IGp1c3Qgd2FudCB0aGUgcGVyY2VudCBvZiB0aGVcbiAgICogdmlkZW8gdGhhdCdzIGJlZW4gZG93bmxvYWRlZCwgdXNlIGJ1ZmZlcmVkUGVyY2VudC5cbiAgICpcbiAgICogQHNlZSBbQnVmZmVyZWQgU3BlY117QGxpbmsgaHR0cDovL2Rldi53My5vcmcvaHRtbDUvc3BlYy92aWRlby5odG1sI2RvbS1tZWRpYS1idWZmZXJlZH1cbiAgICpcbiAgICogQHJldHVybiB7VGltZVJhbmdlfVxuICAgKiAgICAgICAgIEEgbW9jayBUaW1lUmFuZ2Ugb2JqZWN0IChmb2xsb3dpbmcgSFRNTCBzcGVjKVxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuYnVmZmVyZWQgPSBmdW5jdGlvbiBidWZmZXJlZCgpIHtcbiAgICB2YXIgYnVmZmVyZWQgPSB0aGlzLnRlY2hHZXRfKCdidWZmZXJlZCcpO1xuXG4gICAgaWYgKCFidWZmZXJlZCB8fCAhYnVmZmVyZWQubGVuZ3RoKSB7XG4gICAgICBidWZmZXJlZCA9IGNyZWF0ZVRpbWVSYW5nZXMoMCwgMCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJ1ZmZlcmVkO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHBlcmNlbnQgKGFzIGEgZGVjaW1hbCkgb2YgdGhlIHZpZGVvIHRoYXQncyBiZWVuIGRvd25sb2FkZWQuXG4gICAqIFRoaXMgbWV0aG9kIGlzIG5vdCBhIHBhcnQgb2YgdGhlIG5hdGl2ZSBIVE1MIHZpZGVvIEFQSS5cbiAgICpcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKiAgICAgICAgIEEgZGVjaW1hbCBiZXR3ZWVuIDAgYW5kIDEgcmVwcmVzZW50aW5nIHRoZSBwZXJjZW50XG4gICAqICAgICAgICAgdGhhdCBpcyBidWZmZXJyZWQgMCBiZWluZyAwJSBhbmQgMSBiZWluZyAxMDAlXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5idWZmZXJlZFBlcmNlbnQgPSBmdW5jdGlvbiBidWZmZXJlZFBlcmNlbnQkJDEoKSB7XG4gICAgcmV0dXJuIGJ1ZmZlcmVkUGVyY2VudCh0aGlzLmJ1ZmZlcmVkKCksIHRoaXMuZHVyYXRpb24oKSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZW5kaW5nIHRpbWUgb2YgdGhlIGxhc3QgYnVmZmVyZWQgdGltZSByYW5nZVxuICAgKiBUaGlzIGlzIHVzZWQgaW4gdGhlIHByb2dyZXNzIGJhciB0byBlbmNhcHN1bGF0ZSBhbGwgdGltZSByYW5nZXMuXG4gICAqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICogICAgICAgICBUaGUgZW5kIG9mIHRoZSBsYXN0IGJ1ZmZlcmVkIHRpbWUgcmFuZ2VcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLmJ1ZmZlcmVkRW5kID0gZnVuY3Rpb24gYnVmZmVyZWRFbmQoKSB7XG4gICAgdmFyIGJ1ZmZlcmVkID0gdGhpcy5idWZmZXJlZCgpO1xuICAgIHZhciBkdXJhdGlvbiA9IHRoaXMuZHVyYXRpb24oKTtcbiAgICB2YXIgZW5kID0gYnVmZmVyZWQuZW5kKGJ1ZmZlcmVkLmxlbmd0aCAtIDEpO1xuXG4gICAgaWYgKGVuZCA+IGR1cmF0aW9uKSB7XG4gICAgICBlbmQgPSBkdXJhdGlvbjtcbiAgICB9XG5cbiAgICByZXR1cm4gZW5kO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgb3Igc2V0IHRoZSBjdXJyZW50IHZvbHVtZSBvZiB0aGUgbWVkaWFcbiAgICpcbiAgICogQHBhcmFtICB7bnVtYmVyfSBbcGVyY2VudEFzRGVjaW1hbF1cbiAgICogICAgICAgICBUaGUgbmV3IHZvbHVtZSBhcyBhIGRlY2ltYWwgcGVyY2VudDpcbiAgICogICAgICAgICAtIDAgaXMgbXV0ZWQvMCUvb2ZmXG4gICAqICAgICAgICAgLSAxLjAgaXMgMTAwJS9mdWxsXG4gICAqICAgICAgICAgLSAwLjUgaXMgaGFsZiB2b2x1bWUgb3IgNTAlXG4gICAqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICogICAgICAgICBUaGUgY3VycmVudCB2b2x1bWUgYXMgYSBwZXJjZW50IHdoZW4gZ2V0dGluZ1xuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUudm9sdW1lID0gZnVuY3Rpb24gdm9sdW1lKHBlcmNlbnRBc0RlY2ltYWwpIHtcbiAgICB2YXIgdm9sID0gdm9pZCAwO1xuXG4gICAgaWYgKHBlcmNlbnRBc0RlY2ltYWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gRm9yY2UgdmFsdWUgdG8gYmV0d2VlbiAwIGFuZCAxXG4gICAgICB2b2wgPSBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCBwYXJzZUZsb2F0KHBlcmNlbnRBc0RlY2ltYWwpKSk7XG4gICAgICB0aGlzLmNhY2hlXy52b2x1bWUgPSB2b2w7XG4gICAgICB0aGlzLnRlY2hDYWxsXygnc2V0Vm9sdW1lJywgdm9sKTtcblxuICAgICAgaWYgKHZvbCA+IDApIHtcbiAgICAgICAgdGhpcy5sYXN0Vm9sdW1lXyh2b2wpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gRGVmYXVsdCB0byAxIHdoZW4gcmV0dXJuaW5nIGN1cnJlbnQgdm9sdW1lLlxuICAgIHZvbCA9IHBhcnNlRmxvYXQodGhpcy50ZWNoR2V0Xygndm9sdW1lJykpO1xuICAgIHJldHVybiBpc05hTih2b2wpID8gMSA6IHZvbDtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSBjdXJyZW50IG11dGVkIHN0YXRlLCBvciB0dXJuIG11dGUgb24gb3Igb2ZmXG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW211dGVkXVxuICAgKiAgICAgICAgLSB0cnVlIHRvIG11dGVcbiAgICogICAgICAgIC0gZmFsc2UgdG8gdW5tdXRlXG4gICAqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqICAgICAgICAgLSB0cnVlIGlmIG11dGUgaXMgb24gYW5kIGdldHRpbmdcbiAgICogICAgICAgICAtIGZhbHNlIGlmIG11dGUgaXMgb2ZmIGFuZCBnZXR0aW5nXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5tdXRlZCA9IGZ1bmN0aW9uIG11dGVkKF9tdXRlZCkge1xuICAgIGlmIChfbXV0ZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy50ZWNoQ2FsbF8oJ3NldE11dGVkJywgX211dGVkKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMudGVjaEdldF8oJ211dGVkJykgfHwgZmFsc2U7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgY3VycmVudCBkZWZhdWx0TXV0ZWQgc3RhdGUsIG9yIHR1cm4gZGVmYXVsdE11dGVkIG9uIG9yIG9mZi4gZGVmYXVsdE11dGVkXG4gICAqIGluZGljYXRlcyB0aGUgc3RhdGUgb2YgbXV0ZWQgb24gaW50aWFsIHBsYXliYWNrLlxuICAgKlxuICAgKiBgYGBqc1xuICAgKiAgIHZhciBteVBsYXllciA9IHZpZGVvanMoJ3NvbWUtcGxheWVyLWlkJyk7XG4gICAqXG4gICAqICAgbXlQbGF5ZXIuc3JjKFwiaHR0cDovL3d3dy5leGFtcGxlLmNvbS9wYXRoL3RvL3ZpZGVvLm1wNFwiKTtcbiAgICpcbiAgICogICAvLyBnZXQsIHNob3VsZCBiZSBmYWxzZVxuICAgKiAgIGNvbnNvbGUubG9nKG15UGxheWVyLmRlZmF1bHRNdXRlZCgpKTtcbiAgICogICAvLyBzZXQgdG8gdHJ1ZVxuICAgKiAgIG15UGxheWVyLmRlZmF1bHRNdXRlZCh0cnVlKTtcbiAgICogICAvLyBnZXQgc2hvdWxkIGJlIHRydWVcbiAgICogICBjb25zb2xlLmxvZyhteVBsYXllci5kZWZhdWx0TXV0ZWQoKSk7XG4gICAqIGBgYFxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtkZWZhdWx0TXV0ZWRdXG4gICAqICAgICAgICAtIHRydWUgdG8gbXV0ZVxuICAgKiAgICAgICAgLSBmYWxzZSB0byB1bm11dGVcbiAgICpcbiAgICogQHJldHVybiB7Ym9vbGVhbnxQbGF5ZXJ9XG4gICAqICAgICAgICAgLSB0cnVlIGlmIGRlZmF1bHRNdXRlZCBpcyBvbiBhbmQgZ2V0dGluZ1xuICAgKiAgICAgICAgIC0gZmFsc2UgaWYgZGVmYXVsdE11dGVkIGlzIG9mZiBhbmQgZ2V0dGluZ1xuICAgKiAgICAgICAgIC0gQSByZWZlcmVuY2UgdG8gdGhlIGN1cnJlbnQgcGxheWVyIHdoZW4gc2V0dGluZ1xuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuZGVmYXVsdE11dGVkID0gZnVuY3Rpb24gZGVmYXVsdE11dGVkKF9kZWZhdWx0TXV0ZWQpIHtcbiAgICBpZiAoX2RlZmF1bHRNdXRlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdGhpcy50ZWNoQ2FsbF8oJ3NldERlZmF1bHRNdXRlZCcsIF9kZWZhdWx0TXV0ZWQpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy50ZWNoR2V0XygnZGVmYXVsdE11dGVkJykgfHwgZmFsc2U7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbGFzdCB2b2x1bWUsIG9yIHNldCBpdFxuICAgKlxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IFtwZXJjZW50QXNEZWNpbWFsXVxuICAgKiAgICAgICAgIFRoZSBuZXcgbGFzdCB2b2x1bWUgYXMgYSBkZWNpbWFsIHBlcmNlbnQ6XG4gICAqICAgICAgICAgLSAwIGlzIG11dGVkLzAlL29mZlxuICAgKiAgICAgICAgIC0gMS4wIGlzIDEwMCUvZnVsbFxuICAgKiAgICAgICAgIC0gMC41IGlzIGhhbGYgdm9sdW1lIG9yIDUwJVxuICAgKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqICAgICAgICAgdGhlIGN1cnJlbnQgdmFsdWUgb2YgbGFzdFZvbHVtZSBhcyBhIHBlcmNlbnQgd2hlbiBnZXR0aW5nXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5sYXN0Vm9sdW1lXyA9IGZ1bmN0aW9uIGxhc3RWb2x1bWVfKHBlcmNlbnRBc0RlY2ltYWwpIHtcbiAgICBpZiAocGVyY2VudEFzRGVjaW1hbCAhPT0gdW5kZWZpbmVkICYmIHBlcmNlbnRBc0RlY2ltYWwgIT09IDApIHtcbiAgICAgIHRoaXMuY2FjaGVfLmxhc3RWb2x1bWUgPSBwZXJjZW50QXNEZWNpbWFsO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jYWNoZV8ubGFzdFZvbHVtZTtcbiAgfTtcblxuICAvKipcbiAgICogQ2hlY2sgaWYgY3VycmVudCB0ZWNoIGNhbiBzdXBwb3J0IG5hdGl2ZSBmdWxsc2NyZWVuXG4gICAqIChlLmcuIHdpdGggYnVpbHQgaW4gY29udHJvbHMgbGlrZSBpT1MsIHNvIG5vdCBvdXIgZmxhc2ggc3dmKVxuICAgKlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKiAgICAgICAgIGlmIG5hdGl2ZSBmdWxsc2NyZWVuIGlzIHN1cHBvcnRlZFxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuc3VwcG9ydHNGdWxsU2NyZWVuID0gZnVuY3Rpb24gc3VwcG9ydHNGdWxsU2NyZWVuKCkge1xuICAgIHJldHVybiB0aGlzLnRlY2hHZXRfKCdzdXBwb3J0c0Z1bGxTY3JlZW4nKSB8fCBmYWxzZTtcbiAgfTtcblxuICAvKipcbiAgICogQ2hlY2sgaWYgdGhlIHBsYXllciBpcyBpbiBmdWxsc2NyZWVuIG1vZGUgb3IgdGVsbCB0aGUgcGxheWVyIHRoYXQgaXRcbiAgICogaXMgb3IgaXMgbm90IGluIGZ1bGxzY3JlZW4gbW9kZS5cbiAgICpcbiAgICogPiBOT1RFOiBBcyBvZiB0aGUgbGF0ZXN0IEhUTUw1IHNwZWMsIGlzRnVsbHNjcmVlbiBpcyBubyBsb25nZXIgYW4gb2ZmaWNpYWxcbiAgICogcHJvcGVydHkgYW5kIGluc3RlYWQgZG9jdW1lbnQuZnVsbHNjcmVlbkVsZW1lbnQgaXMgdXNlZC4gQnV0IGlzRnVsbHNjcmVlbiBpc1xuICAgKiBzdGlsbCBhIHZhbHVhYmxlIHByb3BlcnR5IGZvciBpbnRlcm5hbCBwbGF5ZXIgd29ya2luZ3MuXG4gICAqXG4gICAqIEBwYXJhbSAge2Jvb2xlYW59IFtpc0ZTXVxuICAgKiAgICAgICAgIFNldCB0aGUgcGxheWVycyBjdXJyZW50IGZ1bGxzY3JlZW4gc3RhdGVcbiAgICpcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICogICAgICAgICAtIHRydWUgaWYgZnVsbHNjcmVlbiBpcyBvbiBhbmQgZ2V0dGluZ1xuICAgKiAgICAgICAgIC0gZmFsc2UgaWYgZnVsbHNjcmVlbiBpcyBvZmYgYW5kIGdldHRpbmdcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLmlzRnVsbHNjcmVlbiA9IGZ1bmN0aW9uIGlzRnVsbHNjcmVlbihpc0ZTKSB7XG4gICAgaWYgKGlzRlMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5pc0Z1bGxzY3JlZW5fID0gISFpc0ZTO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXR1cm4gISF0aGlzLmlzRnVsbHNjcmVlbl87XG4gIH07XG5cbiAgLyoqXG4gICAqIEluY3JlYXNlIHRoZSBzaXplIG9mIHRoZSB2aWRlbyB0byBmdWxsIHNjcmVlblxuICAgKiBJbiBzb21lIGJyb3dzZXJzLCBmdWxsIHNjcmVlbiBpcyBub3Qgc3VwcG9ydGVkIG5hdGl2ZWx5LCBzbyBpdCBlbnRlcnNcbiAgICogXCJmdWxsIHdpbmRvdyBtb2RlXCIsIHdoZXJlIHRoZSB2aWRlbyBmaWxscyB0aGUgYnJvd3NlciB3aW5kb3cuXG4gICAqIEluIGJyb3dzZXJzIGFuZCBkZXZpY2VzIHRoYXQgc3VwcG9ydCBuYXRpdmUgZnVsbCBzY3JlZW4sIHNvbWV0aW1lcyB0aGVcbiAgICogYnJvd3NlcidzIGRlZmF1bHQgY29udHJvbHMgd2lsbCBiZSBzaG93biwgYW5kIG5vdCB0aGUgVmlkZW8uanMgY3VzdG9tIHNraW4uXG4gICAqIFRoaXMgaW5jbHVkZXMgbW9zdCBtb2JpbGUgZGV2aWNlcyAoaU9TLCBBbmRyb2lkKSBhbmQgb2xkZXIgdmVyc2lvbnMgb2ZcbiAgICogU2FmYXJpLlxuICAgKlxuICAgKiBAZmlyZXMgUGxheWVyI2Z1bGxzY3JlZW5jaGFuZ2VcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLnJlcXVlc3RGdWxsc2NyZWVuID0gZnVuY3Rpb24gcmVxdWVzdEZ1bGxzY3JlZW4oKSB7XG4gICAgdmFyIGZzQXBpID0gRnVsbHNjcmVlbkFwaTtcblxuICAgIHRoaXMuaXNGdWxsc2NyZWVuKHRydWUpO1xuXG4gICAgaWYgKGZzQXBpLnJlcXVlc3RGdWxsc2NyZWVuKSB7XG4gICAgICAvLyB0aGUgYnJvd3NlciBzdXBwb3J0cyBnb2luZyBmdWxsc2NyZWVuIGF0IHRoZSBlbGVtZW50IGxldmVsIHNvIHdlIGNhblxuICAgICAgLy8gdGFrZSB0aGUgY29udHJvbHMgZnVsbHNjcmVlbiBhcyB3ZWxsIGFzIHRoZSB2aWRlb1xuXG4gICAgICAvLyBUcmlnZ2VyIGZ1bGxzY3JlZW5jaGFuZ2UgZXZlbnQgYWZ0ZXIgY2hhbmdlXG4gICAgICAvLyBXZSBoYXZlIHRvIHNwZWNpZmljYWxseSBhZGQgdGhpcyBlYWNoIHRpbWUsIGFuZCByZW1vdmVcbiAgICAgIC8vIHdoZW4gY2FuY2VsaW5nIGZ1bGxzY3JlZW4uIE90aGVyd2lzZSBpZiB0aGVyZSdzIG11bHRpcGxlXG4gICAgICAvLyBwbGF5ZXJzIG9uIGEgcGFnZSwgdGhleSB3b3VsZCBhbGwgYmUgcmVhY3RpbmcgdG8gdGhlIHNhbWUgZnVsbHNjcmVlblxuICAgICAgLy8gZXZlbnRzXG4gICAgICBvbihkb2N1bWVudCwgZnNBcGkuZnVsbHNjcmVlbmNoYW5nZSwgYmluZCh0aGlzLCBmdW5jdGlvbiBkb2N1bWVudEZ1bGxzY3JlZW5DaGFuZ2UoZSkge1xuICAgICAgICB0aGlzLmlzRnVsbHNjcmVlbihkb2N1bWVudFtmc0FwaS5mdWxsc2NyZWVuRWxlbWVudF0pO1xuXG4gICAgICAgIC8vIElmIGNhbmNlbGxpbmcgZnVsbHNjcmVlbiwgcmVtb3ZlIGV2ZW50IGxpc3RlbmVyLlxuICAgICAgICBpZiAodGhpcy5pc0Z1bGxzY3JlZW4oKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICBvZmYoZG9jdW1lbnQsIGZzQXBpLmZ1bGxzY3JlZW5jaGFuZ2UsIGRvY3VtZW50RnVsbHNjcmVlbkNoYW5nZSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBldmVudCBQbGF5ZXIjZnVsbHNjcmVlbmNoYW5nZVxuICAgICAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnRyaWdnZXIoJ2Z1bGxzY3JlZW5jaGFuZ2UnKTtcbiAgICAgIH0pKTtcblxuICAgICAgdGhpcy5lbF9bZnNBcGkucmVxdWVzdEZ1bGxzY3JlZW5dKCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnRlY2hfLnN1cHBvcnRzRnVsbFNjcmVlbigpKSB7XG4gICAgICAvLyB3ZSBjYW4ndCB0YWtlIHRoZSB2aWRlby5qcyBjb250cm9scyBmdWxsc2NyZWVuIGJ1dCB3ZSBjYW4gZ28gZnVsbHNjcmVlblxuICAgICAgLy8gd2l0aCBuYXRpdmUgY29udHJvbHNcbiAgICAgIHRoaXMudGVjaENhbGxfKCdlbnRlckZ1bGxTY3JlZW4nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZnVsbHNjcmVlbiBpc24ndCBzdXBwb3J0ZWQgc28gd2UnbGwganVzdCBzdHJldGNoIHRoZSB2aWRlbyBlbGVtZW50IHRvXG4gICAgICAvLyBmaWxsIHRoZSB2aWV3cG9ydFxuICAgICAgdGhpcy5lbnRlckZ1bGxXaW5kb3coKTtcbiAgICAgIC8qKlxuICAgICAgICogQGV2ZW50IFBsYXllciNmdWxsc2NyZWVuY2hhbmdlXG4gICAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gICAgICAgKi9cbiAgICAgIHRoaXMudHJpZ2dlcignZnVsbHNjcmVlbmNoYW5nZScpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJuIHRoZSB2aWRlbyB0byBpdHMgbm9ybWFsIHNpemUgYWZ0ZXIgaGF2aW5nIGJlZW4gaW4gZnVsbCBzY3JlZW4gbW9kZVxuICAgKlxuICAgKiBAZmlyZXMgUGxheWVyI2Z1bGxzY3JlZW5jaGFuZ2VcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLmV4aXRGdWxsc2NyZWVuID0gZnVuY3Rpb24gZXhpdEZ1bGxzY3JlZW4oKSB7XG4gICAgdmFyIGZzQXBpID0gRnVsbHNjcmVlbkFwaTtcblxuICAgIHRoaXMuaXNGdWxsc2NyZWVuKGZhbHNlKTtcblxuICAgIC8vIENoZWNrIGZvciBicm93c2VyIGVsZW1lbnQgZnVsbHNjcmVlbiBzdXBwb3J0XG4gICAgaWYgKGZzQXBpLnJlcXVlc3RGdWxsc2NyZWVuKSB7XG4gICAgICBkb2N1bWVudFtmc0FwaS5leGl0RnVsbHNjcmVlbl0oKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMudGVjaF8uc3VwcG9ydHNGdWxsU2NyZWVuKCkpIHtcbiAgICAgIHRoaXMudGVjaENhbGxfKCdleGl0RnVsbFNjcmVlbicpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmV4aXRGdWxsV2luZG93KCk7XG4gICAgICAvKipcbiAgICAgICAqIEBldmVudCBQbGF5ZXIjZnVsbHNjcmVlbmNoYW5nZVxuICAgICAgICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICAgICAgICovXG4gICAgICB0aGlzLnRyaWdnZXIoJ2Z1bGxzY3JlZW5jaGFuZ2UnKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFdoZW4gZnVsbHNjcmVlbiBpc24ndCBzdXBwb3J0ZWQgd2UgY2FuIHN0cmV0Y2ggdGhlXG4gICAqIHZpZGVvIGNvbnRhaW5lciB0byBhcyB3aWRlIGFzIHRoZSBicm93c2VyIHdpbGwgbGV0IHVzLlxuICAgKlxuICAgKiBAZmlyZXMgUGxheWVyI2VudGVyRnVsbFdpbmRvd1xuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuZW50ZXJGdWxsV2luZG93ID0gZnVuY3Rpb24gZW50ZXJGdWxsV2luZG93KCkge1xuICAgIHRoaXMuaXNGdWxsV2luZG93ID0gdHJ1ZTtcblxuICAgIC8vIFN0b3Jpbmcgb3JpZ2luYWwgZG9jIG92ZXJmbG93IHZhbHVlIHRvIHJldHVybiB0byB3aGVuIGZ1bGxzY3JlZW4gaXMgb2ZmXG4gICAgdGhpcy5kb2NPcmlnT3ZlcmZsb3cgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUub3ZlcmZsb3c7XG5cbiAgICAvLyBBZGQgbGlzdGVuZXIgZm9yIGVzYyBrZXkgdG8gZXhpdCBmdWxsc2NyZWVuXG4gICAgb24oZG9jdW1lbnQsICdrZXlkb3duJywgYmluZCh0aGlzLCB0aGlzLmZ1bGxXaW5kb3dPbkVzY0tleSkpO1xuXG4gICAgLy8gSGlkZSBhbnkgc2Nyb2xsIGJhcnNcbiAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUub3ZlcmZsb3cgPSAnaGlkZGVuJztcblxuICAgIC8vIEFwcGx5IGZ1bGxzY3JlZW4gc3R5bGVzXG4gICAgYWRkQ2xhc3MoZG9jdW1lbnQuYm9keSwgJ3Zqcy1mdWxsLXdpbmRvdycpO1xuXG4gICAgLyoqXG4gICAgICogQGV2ZW50IFBsYXllciNlbnRlckZ1bGxXaW5kb3dcbiAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gICAgICovXG4gICAgdGhpcy50cmlnZ2VyKCdlbnRlckZ1bGxXaW5kb3cnKTtcbiAgfTtcblxuICAvKipcbiAgICogQ2hlY2sgZm9yIGNhbGwgdG8gZWl0aGVyIGV4aXQgZnVsbCB3aW5kb3cgb3JcbiAgICogZnVsbCBzY3JlZW4gb24gRVNDIGtleVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRcbiAgICogICAgICAgIEV2ZW50IHRvIGNoZWNrIGZvciBrZXkgcHJlc3NcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLmZ1bGxXaW5kb3dPbkVzY0tleSA9IGZ1bmN0aW9uIGZ1bGxXaW5kb3dPbkVzY0tleShldmVudCkge1xuICAgIGlmIChldmVudC5rZXlDb2RlID09PSAyNykge1xuICAgICAgaWYgKHRoaXMuaXNGdWxsc2NyZWVuKCkgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5leGl0RnVsbHNjcmVlbigpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5leGl0RnVsbFdpbmRvdygpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogRXhpdCBmdWxsIHdpbmRvd1xuICAgKlxuICAgKiBAZmlyZXMgUGxheWVyI2V4aXRGdWxsV2luZG93XG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5leGl0RnVsbFdpbmRvdyA9IGZ1bmN0aW9uIGV4aXRGdWxsV2luZG93KCkge1xuICAgIHRoaXMuaXNGdWxsV2luZG93ID0gZmFsc2U7XG4gICAgb2ZmKGRvY3VtZW50LCAna2V5ZG93bicsIHRoaXMuZnVsbFdpbmRvd09uRXNjS2V5KTtcblxuICAgIC8vIFVuaGlkZSBzY3JvbGwgYmFycy5cbiAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUub3ZlcmZsb3cgPSB0aGlzLmRvY09yaWdPdmVyZmxvdztcblxuICAgIC8vIFJlbW92ZSBmdWxsc2NyZWVuIHN0eWxlc1xuICAgIHJlbW92ZUNsYXNzKGRvY3VtZW50LmJvZHksICd2anMtZnVsbC13aW5kb3cnKTtcblxuICAgIC8vIFJlc2l6ZSB0aGUgYm94LCBjb250cm9sbGVyLCBhbmQgcG9zdGVyIHRvIG9yaWdpbmFsIHNpemVzXG4gICAgLy8gdGhpcy5wb3NpdGlvbkFsbCgpO1xuICAgIC8qKlxuICAgICAqIEBldmVudCBQbGF5ZXIjZXhpdEZ1bGxXaW5kb3dcbiAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gICAgICovXG4gICAgdGhpcy50cmlnZ2VyKCdleGl0RnVsbFdpbmRvdycpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDaGVjayB3aGV0aGVyIHRoZSBwbGF5ZXIgY2FuIHBsYXkgYSBnaXZlbiBtaW1ldHlwZVxuICAgKlxuICAgKiBAc2VlIGh0dHBzOi8vd3d3LnczLm9yZy9UUi8yMDExL1dELWh0bWw1LTIwMTEwMTEzL3ZpZGVvLmh0bWwjZG9tLW5hdmlnYXRvci1jYW5wbGF5dHlwZVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICAgKiAgICAgICAgVGhlIG1pbWV0eXBlIHRvIGNoZWNrXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICogICAgICAgICAncHJvYmFibHknLCAnbWF5YmUnLCBvciAnJyAoZW1wdHkgc3RyaW5nKVxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuY2FuUGxheVR5cGUgPSBmdW5jdGlvbiBjYW5QbGF5VHlwZSh0eXBlKSB7XG4gICAgdmFyIGNhbiA9IHZvaWQgMDtcblxuICAgIC8vIExvb3AgdGhyb3VnaCBlYWNoIHBsYXliYWNrIHRlY2hub2xvZ3kgaW4gdGhlIG9wdGlvbnMgb3JkZXJcbiAgICBmb3IgKHZhciBpID0gMCwgaiA9IHRoaXMub3B0aW9uc18udGVjaE9yZGVyOyBpIDwgai5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHRlY2hOYW1lID0galtpXTtcbiAgICAgIHZhciB0ZWNoID0gVGVjaC5nZXRUZWNoKHRlY2hOYW1lKTtcblxuICAgICAgLy8gU3VwcG9ydCBvbGQgYmVoYXZpb3Igb2YgdGVjaHMgYmVpbmcgcmVnaXN0ZXJlZCBhcyBjb21wb25lbnRzLlxuICAgICAgLy8gUmVtb3ZlIG9uY2UgdGhhdCBkZXByZWNhdGVkIGJlaGF2aW9yIGlzIHJlbW92ZWQuXG4gICAgICBpZiAoIXRlY2gpIHtcbiAgICAgICAgdGVjaCA9IENvbXBvbmVudC5nZXRDb21wb25lbnQodGVjaE5hbWUpO1xuICAgICAgfVxuXG4gICAgICAvLyBDaGVjayBpZiB0aGUgY3VycmVudCB0ZWNoIGlzIGRlZmluZWQgYmVmb3JlIGNvbnRpbnVpbmdcbiAgICAgIGlmICghdGVjaCkge1xuICAgICAgICBsb2cuZXJyb3IoJ1RoZSBcIicgKyB0ZWNoTmFtZSArICdcIiB0ZWNoIGlzIHVuZGVmaW5lZC4gU2tpcHBlZCBicm93c2VyIHN1cHBvcnQgY2hlY2sgZm9yIHRoYXQgdGVjaC4nKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIENoZWNrIGlmIHRoZSBicm93c2VyIHN1cHBvcnRzIHRoaXMgdGVjaG5vbG9neVxuICAgICAgaWYgKHRlY2guaXNTdXBwb3J0ZWQoKSkge1xuICAgICAgICBjYW4gPSB0ZWNoLmNhblBsYXlUeXBlKHR5cGUpO1xuXG4gICAgICAgIGlmIChjYW4pIHtcbiAgICAgICAgICByZXR1cm4gY2FuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuICcnO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZWxlY3Qgc291cmNlIGJhc2VkIG9uIHRlY2gtb3JkZXIgb3Igc291cmNlLW9yZGVyXG4gICAqIFVzZXMgc291cmNlLW9yZGVyIHNlbGVjdGlvbiBpZiBgb3B0aW9ucy5zb3VyY2VPcmRlcmAgaXMgdHJ1dGh5LiBPdGhlcndpc2UsXG4gICAqIGRlZmF1bHRzIHRvIHRlY2gtb3JkZXIgc2VsZWN0aW9uXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXl9IHNvdXJjZXNcbiAgICogICAgICAgIFRoZSBzb3VyY2VzIGZvciBhIG1lZGlhIGFzc2V0XG4gICAqXG4gICAqIEByZXR1cm4ge09iamVjdHxib29sZWFufVxuICAgKiAgICAgICAgIE9iamVjdCBvZiBzb3VyY2UgYW5kIHRlY2ggb3JkZXIgb3IgZmFsc2VcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLnNlbGVjdFNvdXJjZSA9IGZ1bmN0aW9uIHNlbGVjdFNvdXJjZShzb3VyY2VzKSB7XG4gICAgdmFyIF90aGlzOSA9IHRoaXM7XG5cbiAgICAvLyBHZXQgb25seSB0aGUgdGVjaHMgc3BlY2lmaWVkIGluIGB0ZWNoT3JkZXJgIHRoYXQgZXhpc3QgYW5kIGFyZSBzdXBwb3J0ZWQgYnkgdGhlXG4gICAgLy8gY3VycmVudCBwbGF0Zm9ybVxuICAgIHZhciB0ZWNocyA9IHRoaXMub3B0aW9uc18udGVjaE9yZGVyLm1hcChmdW5jdGlvbiAodGVjaE5hbWUpIHtcbiAgICAgIHJldHVybiBbdGVjaE5hbWUsIFRlY2guZ2V0VGVjaCh0ZWNoTmFtZSldO1xuICAgIH0pLmZpbHRlcihmdW5jdGlvbiAoX3JlZikge1xuICAgICAgdmFyIHRlY2hOYW1lID0gX3JlZlswXSxcbiAgICAgICAgICB0ZWNoID0gX3JlZlsxXTtcblxuICAgICAgLy8gQ2hlY2sgaWYgdGhlIGN1cnJlbnQgdGVjaCBpcyBkZWZpbmVkIGJlZm9yZSBjb250aW51aW5nXG4gICAgICBpZiAodGVjaCkge1xuICAgICAgICAvLyBDaGVjayBpZiB0aGUgYnJvd3NlciBzdXBwb3J0cyB0aGlzIHRlY2hub2xvZ3lcbiAgICAgICAgcmV0dXJuIHRlY2guaXNTdXBwb3J0ZWQoKTtcbiAgICAgIH1cblxuICAgICAgbG9nLmVycm9yKCdUaGUgXCInICsgdGVjaE5hbWUgKyAnXCIgdGVjaCBpcyB1bmRlZmluZWQuIFNraXBwZWQgYnJvd3NlciBzdXBwb3J0IGNoZWNrIGZvciB0aGF0IHRlY2guJyk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSk7XG5cbiAgICAvLyBJdGVyYXRlIG92ZXIgZWFjaCBgaW5uZXJBcnJheWAgZWxlbWVudCBvbmNlIHBlciBgb3V0ZXJBcnJheWAgZWxlbWVudCBhbmQgZXhlY3V0ZVxuICAgIC8vIGB0ZXN0ZXJgIHdpdGggYm90aC4gSWYgYHRlc3RlcmAgcmV0dXJucyBhIG5vbi1mYWxzeSB2YWx1ZSwgZXhpdCBlYXJseSBhbmQgcmV0dXJuXG4gICAgLy8gdGhhdCB2YWx1ZS5cbiAgICB2YXIgZmluZEZpcnN0UGFzc2luZ1RlY2hTb3VyY2VQYWlyID0gZnVuY3Rpb24gZmluZEZpcnN0UGFzc2luZ1RlY2hTb3VyY2VQYWlyKG91dGVyQXJyYXksIGlubmVyQXJyYXksIHRlc3Rlcikge1xuICAgICAgdmFyIGZvdW5kID0gdm9pZCAwO1xuXG4gICAgICBvdXRlckFycmF5LnNvbWUoZnVuY3Rpb24gKG91dGVyQ2hvaWNlKSB7XG4gICAgICAgIHJldHVybiBpbm5lckFycmF5LnNvbWUoZnVuY3Rpb24gKGlubmVyQ2hvaWNlKSB7XG4gICAgICAgICAgZm91bmQgPSB0ZXN0ZXIob3V0ZXJDaG9pY2UsIGlubmVyQ2hvaWNlKTtcblxuICAgICAgICAgIGlmIChmb3VuZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gZm91bmQ7XG4gICAgfTtcblxuICAgIHZhciBmb3VuZFNvdXJjZUFuZFRlY2ggPSB2b2lkIDA7XG4gICAgdmFyIGZsaXAgPSBmdW5jdGlvbiBmbGlwKGZuKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGZuKGIsIGEpO1xuICAgICAgfTtcbiAgICB9O1xuICAgIHZhciBmaW5kZXIgPSBmdW5jdGlvbiBmaW5kZXIoX3JlZjIsIHNvdXJjZSkge1xuICAgICAgdmFyIHRlY2hOYW1lID0gX3JlZjJbMF0sXG4gICAgICAgICAgdGVjaCA9IF9yZWYyWzFdO1xuXG4gICAgICBpZiAodGVjaC5jYW5QbGF5U291cmNlKHNvdXJjZSwgX3RoaXM5Lm9wdGlvbnNfW3RlY2hOYW1lLnRvTG93ZXJDYXNlKCldKSkge1xuICAgICAgICByZXR1cm4geyBzb3VyY2U6IHNvdXJjZSwgdGVjaDogdGVjaE5hbWUgfTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gRGVwZW5kaW5nIG9uIHRoZSB0cnV0aGluZXNzIG9mIGBvcHRpb25zLnNvdXJjZU9yZGVyYCwgd2Ugc3dhcCB0aGUgb3JkZXIgb2YgdGVjaHMgYW5kIHNvdXJjZXNcbiAgICAvLyB0byBzZWxlY3QgZnJvbSB0aGVtIGJhc2VkIG9uIHRoZWlyIHByaW9yaXR5LlxuICAgIGlmICh0aGlzLm9wdGlvbnNfLnNvdXJjZU9yZGVyKSB7XG4gICAgICAvLyBTb3VyY2UtZmlyc3Qgb3JkZXJpbmdcbiAgICAgIGZvdW5kU291cmNlQW5kVGVjaCA9IGZpbmRGaXJzdFBhc3NpbmdUZWNoU291cmNlUGFpcihzb3VyY2VzLCB0ZWNocywgZmxpcChmaW5kZXIpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGVjaC1maXJzdCBvcmRlcmluZ1xuICAgICAgZm91bmRTb3VyY2VBbmRUZWNoID0gZmluZEZpcnN0UGFzc2luZ1RlY2hTb3VyY2VQYWlyKHRlY2hzLCBzb3VyY2VzLCBmaW5kZXIpO1xuICAgIH1cblxuICAgIHJldHVybiBmb3VuZFNvdXJjZUFuZFRlY2ggfHwgZmFsc2U7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBvciBzZXQgdGhlIHZpZGVvIHNvdXJjZS5cbiAgICpcbiAgICogQHBhcmFtIHtUZWNoflNvdXJjZU9iamVjdHxUZWNoflNvdXJjZU9iamVjdFtdfHN0cmluZ30gW3NvdXJjZV1cbiAgICogICAgICAgIEEgU291cmNlT2JqZWN0LCBhbiBhcnJheSBvZiBTb3VyY2VPYmplY3RzLCBvciBhIHN0cmluZyByZWZlcmVuY2luZ1xuICAgKiAgICAgICAgYSBVUkwgdG8gYSBtZWRpYSBzb3VyY2UuIEl0IGlzIF9oaWdobHkgcmVjb21tZW5kZWRfIHRoYXQgYW4gb2JqZWN0XG4gICAqICAgICAgICBvciBhcnJheSBvZiBvYmplY3RzIGlzIHVzZWQgaGVyZSwgc28gdGhhdCBzb3VyY2Ugc2VsZWN0aW9uXG4gICAqICAgICAgICBhbGdvcml0aG1zIGNhbiB0YWtlIHRoZSBgdHlwZWAgaW50byBhY2NvdW50LlxuICAgKlxuICAgKiAgICAgICAgSWYgbm90IHByb3ZpZGVkLCB0aGlzIG1ldGhvZCBhY3RzIGFzIGEgZ2V0dGVyLlxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd8dW5kZWZpbmVkfVxuICAgKiAgICAgICAgIElmIHRoZSBgc291cmNlYCBhcmd1bWVudCBpcyBtaXNzaW5nLCByZXR1cm5zIHRoZSBjdXJyZW50IHNvdXJjZVxuICAgKiAgICAgICAgIFVSTC4gT3RoZXJ3aXNlLCByZXR1cm5zIG5vdGhpbmcvdW5kZWZpbmVkLlxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuc3JjID0gZnVuY3Rpb24gc3JjKHNvdXJjZSkge1xuICAgIHZhciBfdGhpczEwID0gdGhpcztcblxuICAgIC8vIGdldHRlciB1c2FnZVxuICAgIGlmICh0eXBlb2Ygc291cmNlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuIHRoaXMuY2FjaGVfLnNyYyB8fCAnJztcbiAgICB9XG4gICAgLy8gZmlsdGVyIG91dCBpbnZhbGlkIHNvdXJjZXMgYW5kIHR1cm4gb3VyIHNvdXJjZSBpbnRvXG4gICAgLy8gYW4gYXJyYXkgb2Ygc291cmNlIG9iamVjdHNcbiAgICB2YXIgc291cmNlcyA9IGZpbHRlclNvdXJjZShzb3VyY2UpO1xuXG4gICAgLy8gaWYgYSBzb3VyY2Ugd2FzIHBhc3NlZCBpbiB0aGVuIGl0IGlzIGludmFsaWQgYmVjYXVzZVxuICAgIC8vIGl0IHdhcyBmaWx0ZXJlZCB0byBhIHplcm8gbGVuZ3RoIEFycmF5LiBTbyB3ZSBoYXZlIHRvXG4gICAgLy8gc2hvdyBhbiBlcnJvclxuICAgIGlmICghc291cmNlcy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZXJyb3IoeyBjb2RlOiA0LCBtZXNzYWdlOiB0aGlzLmxvY2FsaXplKHRoaXMub3B0aW9uc18ubm90U3VwcG9ydGVkTWVzc2FnZSkgfSk7XG4gICAgICB9LCAwKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBpbnRpYWwgc291cmNlc1xuICAgIHRoaXMuY2hhbmdpbmdTcmNfID0gdHJ1ZTtcblxuICAgIHRoaXMuY2FjaGVfLnNvdXJjZXMgPSBzb3VyY2VzO1xuICAgIHRoaXMudXBkYXRlU291cmNlQ2FjaGVzXyhzb3VyY2VzWzBdKTtcblxuICAgIC8vIG1pZGRsZXdhcmVTb3VyY2UgaXMgdGhlIHNvdXJjZSBhZnRlciBpdCBoYXMgYmVlbiBjaGFuZ2VkIGJ5IG1pZGRsZXdhcmVcbiAgICBzZXRTb3VyY2UodGhpcywgc291cmNlc1swXSwgZnVuY3Rpb24gKG1pZGRsZXdhcmVTb3VyY2UsIG13cykge1xuICAgICAgX3RoaXMxMC5taWRkbGV3YXJlXyA9IG13cztcblxuICAgICAgLy8gc2luY2Ugc291cmNlU2V0IGlzIGFzeW5jIHdlIGhhdmUgdG8gdXBkYXRlIHRoZSBjYWNoZSBhZ2FpbiBhZnRlciB3ZSBzZWxlY3QgYSBzb3VyY2Ugc2luY2VcbiAgICAgIC8vIHRoZSBzb3VyY2UgdGhhdCBpcyBzZWxlY3RlZCBjb3VsZCBiZSBvdXQgb2Ygb3JkZXIgZnJvbSB0aGUgY2FjaGUgdXBkYXRlIGFib3ZlIHRoaXMgY2FsbGJhY2suXG4gICAgICBfdGhpczEwLmNhY2hlXy5zb3VyY2VzID0gc291cmNlcztcbiAgICAgIF90aGlzMTAudXBkYXRlU291cmNlQ2FjaGVzXyhtaWRkbGV3YXJlU291cmNlKTtcblxuICAgICAgdmFyIGVyciA9IF90aGlzMTAuc3JjXyhtaWRkbGV3YXJlU291cmNlKTtcblxuICAgICAgaWYgKGVycikge1xuICAgICAgICBpZiAoc291cmNlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzMTAuc3JjKHNvdXJjZXMuc2xpY2UoMSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgX3RoaXMxMC5jaGFuZ2luZ1NyY18gPSBmYWxzZTtcblxuICAgICAgICAvLyBXZSBuZWVkIHRvIHdyYXAgdGhpcyBpbiBhIHRpbWVvdXQgdG8gZ2l2ZSBmb2xrcyBhIGNoYW5jZSB0byBhZGQgZXJyb3IgZXZlbnQgaGFuZGxlcnNcbiAgICAgICAgX3RoaXMxMC5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aGlzLmVycm9yKHsgY29kZTogNCwgbWVzc2FnZTogdGhpcy5sb2NhbGl6ZSh0aGlzLm9wdGlvbnNfLm5vdFN1cHBvcnRlZE1lc3NhZ2UpIH0pO1xuICAgICAgICB9LCAwKTtcblxuICAgICAgICAvLyB3ZSBjb3VsZCBub3QgZmluZCBhbiBhcHByb3ByaWF0ZSB0ZWNoLCBidXQgbGV0J3Mgc3RpbGwgbm90aWZ5IHRoZSBkZWxlZ2F0ZSB0aGF0IHRoaXMgaXMgaXRcbiAgICAgICAgLy8gdGhpcyBuZWVkcyBhIGJldHRlciBjb21tZW50IGFib3V0IHdoeSB0aGlzIGlzIG5lZWRlZFxuICAgICAgICBfdGhpczEwLnRyaWdnZXJSZWFkeSgpO1xuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgc2V0VGVjaChtd3MsIF90aGlzMTAudGVjaF8pO1xuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHNvdXJjZSBvYmplY3Qgb24gdGhlIHRlY2gsIHJldHVybnMgYSBib29sZWFuIHRoYXQgaW5kaWNhdGVzIHdldGhlclxuICAgKiB0aGVyZSBpcyBhIHRlY2ggdGhhdCBjYW4gcGxheSB0aGUgc291cmNlIG9yIG5vdFxuICAgKlxuICAgKiBAcGFyYW0ge1RlY2h+U291cmNlT2JqZWN0fSBzb3VyY2VcbiAgICogICAgICAgIFRoZSBzb3VyY2Ugb2JqZWN0IHRvIHNldCBvbiB0aGUgVGVjaFxuICAgKlxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKiAgICAgICAgIC0gVHJ1ZSBpZiB0aGVyZSBpcyBubyBUZWNoIHRvIHBsYXliYWNrIHRoaXMgc291cmNlXG4gICAqICAgICAgICAgLSBGYWxzZSBvdGhlcndpc2VcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLnNyY18gPSBmdW5jdGlvbiBzcmNfKHNvdXJjZSkge1xuICAgIHZhciBfdGhpczExID0gdGhpcztcblxuICAgIHZhciBzb3VyY2VUZWNoID0gdGhpcy5zZWxlY3RTb3VyY2UoW3NvdXJjZV0pO1xuXG4gICAgaWYgKCFzb3VyY2VUZWNoKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoIXRpdGxlQ2FzZUVxdWFscyhzb3VyY2VUZWNoLnRlY2gsIHRoaXMudGVjaE5hbWVfKSkge1xuICAgICAgdGhpcy5jaGFuZ2luZ1NyY18gPSB0cnVlO1xuICAgICAgLy8gbG9hZCB0aGlzIHRlY2hub2xvZ3kgd2l0aCB0aGUgY2hvc2VuIHNvdXJjZVxuICAgICAgdGhpcy5sb2FkVGVjaF8oc291cmNlVGVjaC50ZWNoLCBzb3VyY2VUZWNoLnNvdXJjZSk7XG4gICAgICB0aGlzLnRlY2hfLnJlYWR5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMxMS5jaGFuZ2luZ1NyY18gPSBmYWxzZTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIHdhaXQgdW50aWwgdGhlIHRlY2ggaXMgcmVhZHkgdG8gc2V0IHRoZSBzb3VyY2VcbiAgICAvLyBhbmQgc2V0IGl0IHN5bmNocm9ub3VzbHkgaWYgcG9zc2libGUgKCMyMzI2KVxuICAgIHRoaXMucmVhZHkoZnVuY3Rpb24gKCkge1xuXG4gICAgICAvLyBUaGUgc2V0U291cmNlIHRlY2ggbWV0aG9kIHdhcyBhZGRlZCB3aXRoIHNvdXJjZSBoYW5kbGVyc1xuICAgICAgLy8gc28gb2xkZXIgdGVjaHMgd29uJ3Qgc3VwcG9ydCBpdFxuICAgICAgLy8gV2UgbmVlZCB0byBjaGVjayB0aGUgZGlyZWN0IHByb3RvdHlwZSBmb3IgdGhlIGNhc2Ugd2hlcmUgc3ViY2xhc3Nlc1xuICAgICAgLy8gb2YgdGhlIHRlY2ggZG8gbm90IHN1cHBvcnQgc291cmNlIGhhbmRsZXJzXG4gICAgICBpZiAodGhpcy50ZWNoXy5jb25zdHJ1Y3Rvci5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkoJ3NldFNvdXJjZScpKSB7XG4gICAgICAgIHRoaXMudGVjaENhbGxfKCdzZXRTb3VyY2UnLCBzb3VyY2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy50ZWNoQ2FsbF8oJ3NyYycsIHNvdXJjZS5zcmMpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmNoYW5naW5nU3JjXyA9IGZhbHNlO1xuICAgIH0sIHRydWUpO1xuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBCZWdpbiBsb2FkaW5nIHRoZSBzcmMgZGF0YS5cbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbiBsb2FkKCkge1xuICAgIHRoaXMudGVjaENhbGxfKCdsb2FkJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlc2V0IHRoZSBwbGF5ZXIuIExvYWRzIHRoZSBmaXJzdCB0ZWNoIGluIHRoZSB0ZWNoT3JkZXIsXG4gICAqIHJlbW92ZXMgYWxsIHRoZSB0ZXh0IHRyYWNrcyBpbiB0aGUgZXhpc3RpbmcgYHRlY2hgLFxuICAgKiBhbmQgY2FsbHMgYHJlc2V0YCBvbiB0aGUgYHRlY2hgLlxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiByZXNldCgpIHtcbiAgICBpZiAodGhpcy50ZWNoXykge1xuICAgICAgdGhpcy50ZWNoXy5jbGVhclRyYWNrcygndGV4dCcpO1xuICAgIH1cbiAgICB0aGlzLmxvYWRUZWNoXyh0aGlzLm9wdGlvbnNfLnRlY2hPcmRlclswXSwgbnVsbCk7XG4gICAgdGhpcy50ZWNoQ2FsbF8oJ3Jlc2V0Jyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYWxsIG9mIHRoZSBjdXJyZW50IHNvdXJjZSBvYmplY3RzLlxuICAgKlxuICAgKiBAcmV0dXJuIHtUZWNoflNvdXJjZU9iamVjdFtdfVxuICAgKiAgICAgICAgIFRoZSBjdXJyZW50IHNvdXJjZSBvYmplY3RzXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5jdXJyZW50U291cmNlcyA9IGZ1bmN0aW9uIGN1cnJlbnRTb3VyY2VzKCkge1xuICAgIHZhciBzb3VyY2UgPSB0aGlzLmN1cnJlbnRTb3VyY2UoKTtcbiAgICB2YXIgc291cmNlcyA9IFtdO1xuXG4gICAgLy8gYXNzdW1lIGB7fWAgb3IgYHsgc3JjIH1gXG4gICAgaWYgKE9iamVjdC5rZXlzKHNvdXJjZSkubGVuZ3RoICE9PSAwKSB7XG4gICAgICBzb3VyY2VzLnB1c2goc291cmNlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5jYWNoZV8uc291cmNlcyB8fCBzb3VyY2VzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IHNvdXJjZSBvYmplY3QuXG4gICAqXG4gICAqIEByZXR1cm4ge1RlY2h+U291cmNlT2JqZWN0fVxuICAgKiAgICAgICAgIFRoZSBjdXJyZW50IHNvdXJjZSBvYmplY3RcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLmN1cnJlbnRTb3VyY2UgPSBmdW5jdGlvbiBjdXJyZW50U291cmNlKCkge1xuICAgIHJldHVybiB0aGlzLmNhY2hlXy5zb3VyY2UgfHwge307XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGZ1bGx5IHF1YWxpZmllZCBVUkwgb2YgdGhlIGN1cnJlbnQgc291cmNlIHZhbHVlIGUuZy4gaHR0cDovL215c2l0ZS5jb20vdmlkZW8ubXA0XG4gICAqIENhbiBiZSB1c2VkIGluIGNvbmp1Y3Rpb24gd2l0aCBgY3VycmVudFR5cGVgIHRvIGFzc2lzdCBpbiByZWJ1aWxkaW5nIHRoZSBjdXJyZW50IHNvdXJjZSBvYmplY3QuXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICogICAgICAgICBUaGUgY3VycmVudCBzb3VyY2VcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLmN1cnJlbnRTcmMgPSBmdW5jdGlvbiBjdXJyZW50U3JjKCkge1xuICAgIHJldHVybiB0aGlzLmN1cnJlbnRTb3VyY2UoKSAmJiB0aGlzLmN1cnJlbnRTb3VyY2UoKS5zcmMgfHwgJyc7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgY3VycmVudCBzb3VyY2UgdHlwZSBlLmcuIHZpZGVvL21wNFxuICAgKiBUaGlzIGNhbiBhbGxvdyB5b3UgcmVidWlsZCB0aGUgY3VycmVudCBzb3VyY2Ugb2JqZWN0IHNvIHRoYXQgeW91IGNvdWxkIGxvYWQgdGhlIHNhbWVcbiAgICogc291cmNlIGFuZCB0ZWNoIGxhdGVyXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICogICAgICAgICBUaGUgc291cmNlIE1JTUUgdHlwZVxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuY3VycmVudFR5cGUgPSBmdW5jdGlvbiBjdXJyZW50VHlwZSgpIHtcbiAgICByZXR1cm4gdGhpcy5jdXJyZW50U291cmNlKCkgJiYgdGhpcy5jdXJyZW50U291cmNlKCkudHlwZSB8fCAnJztcbiAgfTtcblxuICAvKipcbiAgICogR2V0IG9yIHNldCB0aGUgcHJlbG9hZCBhdHRyaWJ1dGVcbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSBbdmFsdWVdXG4gICAqICAgICAgICAtIHRydWUgbWVhbnMgdGhhdCB3ZSBzaG91bGQgcHJlbG9hZFxuICAgKiAgICAgICAgLSBmYWxzZSBtYWVucyB0aGF0IHdlIHNob3VsZCBub3QgcHJlbG9hZFxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqICAgICAgICAgVGhlIHByZWxvYWQgYXR0cmlidXRlIHZhbHVlIHdoZW4gZ2V0dGluZ1xuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUucHJlbG9hZCA9IGZ1bmN0aW9uIHByZWxvYWQodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy50ZWNoQ2FsbF8oJ3NldFByZWxvYWQnLCB2YWx1ZSk7XG4gICAgICB0aGlzLm9wdGlvbnNfLnByZWxvYWQgPSB2YWx1ZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMudGVjaEdldF8oJ3ByZWxvYWQnKTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IG9yIHNldCB0aGUgYXV0b3BsYXkgb3B0aW9uLiBXaGVuIHRoaXMgaXMgYSBib29sZWFuIGl0IHdpbGxcbiAgICogbW9kaWZ5IHRoZSBhdHRyaWJ1dGUgb24gdGhlIHRlY2guIFdoZW4gdGhpcyBpcyBhIHN0cmluZyB0aGUgYXR0cmlidXRlIG9uXG4gICAqIHRoZSB0ZWNoIHdpbGwgYmUgcmVtb3ZlZCBhbmQgYFBsYXllcmAgd2lsbCBoYW5kbGUgYXV0b3BsYXkgb24gbG9hZHN0YXJ0cy5cbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufHN0cmluZ30gW3ZhbHVlXVxuICAgKiAgICAgICAgLSB0cnVlOiBhdXRvcGxheSB1c2luZyB0aGUgYnJvd3NlciBiZWhhdmlvclxuICAgKiAgICAgICAgLSBmYWxzZTogZG8gbm90IGF1dG9wbGF5XG4gICAqICAgICAgICAtICdwbGF5JzogY2FsbCBwbGF5KCkgb24gZXZlcnkgbG9hZHN0YXJ0XG4gICAqICAgICAgICAtICdtdXRlZCc6IGNhbGwgbXV0ZWQoKSB0aGVuIHBsYXkoKSBvbiBldmVyeSBsb2Fkc3RhcnRcbiAgICogICAgICAgIC0gJ2FueSc6IGNhbGwgcGxheSgpIG9uIGV2ZXJ5IGxvYWRzdGFydC4gaWYgdGhhdCBmYWlscyBjYWxsIG11dGVkKCkgdGhlbiBwbGF5KCkuXG4gICAqICAgICAgICAtICo6IHZhbHVlcyBvdGhlciB0aGFuIHRob3NlIGxpc3RlZCBoZXJlIHdpbGwgYmUgc2V0IGBhdXRvcGxheWAgdG8gdHJ1ZVxuICAgKlxuICAgKiBAcmV0dXJuIHtib29sZWFufHN0cmluZ31cbiAgICogICAgICAgICBUaGUgY3VycmVudCB2YWx1ZSBvZiBhdXRvcGxheSB3aGVuIGdldHRpbmdcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLmF1dG9wbGF5ID0gZnVuY3Rpb24gYXV0b3BsYXkodmFsdWUpIHtcbiAgICAvLyBnZXR0ZXIgdXNhZ2VcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHRoaXMub3B0aW9uc18uYXV0b3BsYXkgfHwgZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIHRlY2hBdXRvcGxheSA9IHZvaWQgMDtcblxuICAgIC8vIGlmIHRoZSB2YWx1ZSBpcyBhIHZhbGlkIHN0cmluZyBzZXQgaXQgdG8gdGhhdFxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIC8oYW55fHBsYXl8bXV0ZWQpLy50ZXN0KHZhbHVlKSkge1xuICAgICAgdGhpcy5vcHRpb25zXy5hdXRvcGxheSA9IHZhbHVlO1xuICAgICAgdGhpcy5tYW51YWxBdXRvcGxheV8odmFsdWUpO1xuICAgICAgdGVjaEF1dG9wbGF5ID0gZmFsc2U7XG5cbiAgICAgIC8vIGFueSBmYWxzeSB2YWx1ZSBzZXRzIGF1dG9wbGF5IHRvIGZhbHNlIGluIHRoZSBicm93c2VyLFxuICAgICAgLy8gbGV0cyBkbyB0aGUgc2FtZVxuICAgIH0gZWxzZSBpZiAoIXZhbHVlKSB7XG4gICAgICB0aGlzLm9wdGlvbnNfLmF1dG9wbGF5ID0gZmFsc2U7XG5cbiAgICAgIC8vIGFueSBvdGhlciB2YWx1ZSAoaWUgdHJ1dGh5KSBzZXRzIGF1dG9wbGF5IHRvIHRydWVcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5vcHRpb25zXy5hdXRvcGxheSA9IHRydWU7XG4gICAgfVxuXG4gICAgdGVjaEF1dG9wbGF5ID0gdGVjaEF1dG9wbGF5IHx8IHRoaXMub3B0aW9uc18uYXV0b3BsYXk7XG5cbiAgICAvLyBpZiB3ZSBkb24ndCBoYXZlIGEgdGVjaCB0aGVuIHdlIGRvIG5vdCBxdWV1ZSB1cFxuICAgIC8vIGEgc2V0QXV0b3BsYXkgY2FsbCBvbiB0ZWNoIHJlYWR5LiBXZSBkbyB0aGlzIGJlY2F1c2UgdGhlXG4gICAgLy8gYXV0b3BsYXkgb3B0aW9uIHdpbGwgYmUgcGFzc2VkIGluIHRoZSBjb25zdHJ1Y3RvciBhbmQgd2VcbiAgICAvLyBkbyBub3QgbmVlZCB0byBzZXQgaXQgdHdpY2VcbiAgICBpZiAodGhpcy50ZWNoXykge1xuICAgICAgdGhpcy50ZWNoQ2FsbF8oJ3NldEF1dG9wbGF5JywgdGVjaEF1dG9wbGF5KTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCBvciB1bnNldCB0aGUgcGxheXNpbmxpbmUgYXR0cmlidXRlLlxuICAgKiBQbGF5c2lubGluZSB0ZWxscyB0aGUgYnJvd3NlciB0aGF0IG5vbi1mdWxsc2NyZWVuIHBsYXliYWNrIGlzIHByZWZlcnJlZC5cbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSBbdmFsdWVdXG4gICAqICAgICAgICAtIHRydWUgbWVhbnMgdGhhdCB3ZSBzaG91bGQgdHJ5IHRvIHBsYXkgaW5saW5lIGJ5IGRlZmF1bHRcbiAgICogICAgICAgIC0gZmFsc2UgbWVhbnMgdGhhdCB3ZSBzaG91bGQgdXNlIHRoZSBicm93c2VyJ3MgZGVmYXVsdCBwbGF5YmFjayBtb2RlLFxuICAgKiAgICAgICAgICB3aGljaCBpbiBtb3N0IGNhc2VzIGlzIGlubGluZS4gaU9TIFNhZmFyaSBpcyBhIG5vdGFibGUgZXhjZXB0aW9uXG4gICAqICAgICAgICAgIGFuZCBwbGF5cyBmdWxsc2NyZWVuIGJ5IGRlZmF1bHQuXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ3xQbGF5ZXJ9XG4gICAqICAgICAgICAgLSB0aGUgY3VycmVudCB2YWx1ZSBvZiBwbGF5c2lubGluZVxuICAgKiAgICAgICAgIC0gdGhlIHBsYXllciB3aGVuIHNldHRpbmdcbiAgICpcbiAgICogQHNlZSBbU3BlY117QGxpbmsgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy8jYXR0ci12aWRlby1wbGF5c2lubGluZX1cbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLnBsYXlzaW5saW5lID0gZnVuY3Rpb24gcGxheXNpbmxpbmUodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy50ZWNoQ2FsbF8oJ3NldFBsYXlzaW5saW5lJywgdmFsdWUpO1xuICAgICAgdGhpcy5vcHRpb25zXy5wbGF5c2lubGluZSA9IHZhbHVlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnRlY2hHZXRfKCdwbGF5c2lubGluZScpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgb3Igc2V0IHRoZSBsb29wIGF0dHJpYnV0ZSBvbiB0aGUgdmlkZW8gZWxlbWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSBbdmFsdWVdXG4gICAqICAgICAgICAtIHRydWUgbWVhbnMgdGhhdCB3ZSBzaG91bGQgbG9vcCB0aGUgdmlkZW9cbiAgICogICAgICAgIC0gZmFsc2UgbWVhbnMgdGhhdCB3ZSBzaG91bGQgbm90IGxvb3AgdGhlIHZpZGVvXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICogICAgICAgICBUaGUgY3VycmVudCB2YWx1ZSBvZiBsb29wIHdoZW4gZ2V0dGluZ1xuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUubG9vcCA9IGZ1bmN0aW9uIGxvb3AodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy50ZWNoQ2FsbF8oJ3NldExvb3AnLCB2YWx1ZSk7XG4gICAgICB0aGlzLm9wdGlvbnNfLmxvb3AgPSB2YWx1ZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMudGVjaEdldF8oJ2xvb3AnKTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IG9yIHNldCB0aGUgcG9zdGVyIGltYWdlIHNvdXJjZSB1cmxcbiAgICpcbiAgICogQGZpcmVzIFBsYXllciNwb3N0ZXJjaGFuZ2VcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtzcmNdXG4gICAqICAgICAgICBQb3N0ZXIgaW1hZ2Ugc291cmNlIFVSTFxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqICAgICAgICAgVGhlIGN1cnJlbnQgdmFsdWUgb2YgcG9zdGVyIHdoZW4gZ2V0dGluZ1xuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUucG9zdGVyID0gZnVuY3Rpb24gcG9zdGVyKHNyYykge1xuICAgIGlmIChzcmMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHRoaXMucG9zdGVyXztcbiAgICB9XG5cbiAgICAvLyBUaGUgY29ycmVjdCB3YXkgdG8gcmVtb3ZlIGEgcG9zdGVyIGlzIHRvIHNldCBhcyBhbiBlbXB0eSBzdHJpbmdcbiAgICAvLyBvdGhlciBmYWxzZXkgdmFsdWVzIHdpbGwgdGhyb3cgZXJyb3JzXG4gICAgaWYgKCFzcmMpIHtcbiAgICAgIHNyYyA9ICcnO1xuICAgIH1cblxuICAgIGlmIChzcmMgPT09IHRoaXMucG9zdGVyXykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIHVwZGF0ZSB0aGUgaW50ZXJuYWwgcG9zdGVyIHZhcmlhYmxlXG4gICAgdGhpcy5wb3N0ZXJfID0gc3JjO1xuXG4gICAgLy8gdXBkYXRlIHRoZSB0ZWNoJ3MgcG9zdGVyXG4gICAgdGhpcy50ZWNoQ2FsbF8oJ3NldFBvc3RlcicsIHNyYyk7XG5cbiAgICB0aGlzLmlzUG9zdGVyRnJvbVRlY2hfID0gZmFsc2U7XG5cbiAgICAvLyBhbGVydCBjb21wb25lbnRzIHRoYXQgdGhlIHBvc3RlciBoYXMgYmVlbiBzZXRcbiAgICAvKipcbiAgICAgKiBUaGlzIGV2ZW50IGZpcmVzIHdoZW4gdGhlIHBvc3RlciBpbWFnZSBpcyBjaGFuZ2VkIG9uIHRoZSBwbGF5ZXIuXG4gICAgICpcbiAgICAgKiBAZXZlbnQgUGxheWVyI3Bvc3RlcmNoYW5nZVxuICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAgICAgKi9cbiAgICB0aGlzLnRyaWdnZXIoJ3Bvc3RlcmNoYW5nZScpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTb21lIHRlY2hzIChlLmcuIFlvdVR1YmUpIGNhbiBwcm92aWRlIGEgcG9zdGVyIHNvdXJjZSBpbiBhblxuICAgKiBhc3luY2hyb25vdXMgd2F5LiBXZSB3YW50IHRoZSBwb3N0ZXIgY29tcG9uZW50IHRvIHVzZSB0aGlzXG4gICAqIHBvc3RlciBzb3VyY2Ugc28gdGhhdCBpdCBjb3ZlcnMgdXAgdGhlIHRlY2gncyBjb250cm9scy5cbiAgICogKFlvdVR1YmUncyBwbGF5IGJ1dHRvbikuIEhvd2V2ZXIgd2Ugb25seSB3YW50IHRvIHVzZSB0aGlzXG4gICAqIHNvdXJjZSBpZiB0aGUgcGxheWVyIHVzZXIgaGFzbid0IHNldCBhIHBvc3RlciB0aHJvdWdoXG4gICAqIHRoZSBub3JtYWwgQVBJcy5cbiAgICpcbiAgICogQGZpcmVzIFBsYXllciNwb3N0ZXJjaGFuZ2VcbiAgICogQGxpc3RlbnMgVGVjaCNwb3N0ZXJjaGFuZ2VcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLmhhbmRsZVRlY2hQb3N0ZXJDaGFuZ2VfID0gZnVuY3Rpb24gaGFuZGxlVGVjaFBvc3RlckNoYW5nZV8oKSB7XG4gICAgaWYgKCghdGhpcy5wb3N0ZXJfIHx8IHRoaXMub3B0aW9uc18udGVjaENhbk92ZXJyaWRlUG9zdGVyKSAmJiB0aGlzLnRlY2hfICYmIHRoaXMudGVjaF8ucG9zdGVyKSB7XG4gICAgICB2YXIgbmV3UG9zdGVyID0gdGhpcy50ZWNoXy5wb3N0ZXIoKSB8fCAnJztcblxuICAgICAgaWYgKG5ld1Bvc3RlciAhPT0gdGhpcy5wb3N0ZXJfKSB7XG4gICAgICAgIHRoaXMucG9zdGVyXyA9IG5ld1Bvc3RlcjtcbiAgICAgICAgdGhpcy5pc1Bvc3RlckZyb21UZWNoXyA9IHRydWU7XG5cbiAgICAgICAgLy8gTGV0IGNvbXBvbmVudHMga25vdyB0aGUgcG9zdGVyIGhhcyBjaGFuZ2VkXG4gICAgICAgIHRoaXMudHJpZ2dlcigncG9zdGVyY2hhbmdlJyk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgb3Igc2V0IHdoZXRoZXIgb3Igbm90IHRoZSBjb250cm9scyBhcmUgc2hvd2luZy5cbiAgICpcbiAgICogQGZpcmVzIFBsYXllciNjb250cm9sc2VuYWJsZWRcbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSBbYm9vbF1cbiAgICogICAgICAgIC0gdHJ1ZSB0byB0dXJuIGNvbnRyb2xzIG9uXG4gICAqICAgICAgICAtIGZhbHNlIHRvIHR1cm4gY29udHJvbHMgb2ZmXG4gICAqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqICAgICAgICAgVGhlIGN1cnJlbnQgdmFsdWUgb2YgY29udHJvbHMgd2hlbiBnZXR0aW5nXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5jb250cm9scyA9IGZ1bmN0aW9uIGNvbnRyb2xzKGJvb2wpIHtcbiAgICBpZiAoYm9vbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gISF0aGlzLmNvbnRyb2xzXztcbiAgICB9XG5cbiAgICBib29sID0gISFib29sO1xuXG4gICAgLy8gRG9uJ3QgdHJpZ2dlciBhIGNoYW5nZSBldmVudCB1bmxlc3MgaXQgYWN0dWFsbHkgY2hhbmdlZFxuICAgIGlmICh0aGlzLmNvbnRyb2xzXyA9PT0gYm9vbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuY29udHJvbHNfID0gYm9vbDtcblxuICAgIGlmICh0aGlzLnVzaW5nTmF0aXZlQ29udHJvbHMoKSkge1xuICAgICAgdGhpcy50ZWNoQ2FsbF8oJ3NldENvbnRyb2xzJywgYm9vbCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuY29udHJvbHNfKSB7XG4gICAgICB0aGlzLnJlbW92ZUNsYXNzKCd2anMtY29udHJvbHMtZGlzYWJsZWQnKTtcbiAgICAgIHRoaXMuYWRkQ2xhc3MoJ3Zqcy1jb250cm9scy1lbmFibGVkJyk7XG4gICAgICAvKipcbiAgICAgICAqIEBldmVudCBQbGF5ZXIjY29udHJvbHNlbmFibGVkXG4gICAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gICAgICAgKi9cbiAgICAgIHRoaXMudHJpZ2dlcignY29udHJvbHNlbmFibGVkJyk7XG4gICAgICBpZiAoIXRoaXMudXNpbmdOYXRpdmVDb250cm9scygpKSB7XG4gICAgICAgIHRoaXMuYWRkVGVjaENvbnRyb2xzTGlzdGVuZXJzXygpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJlbW92ZUNsYXNzKCd2anMtY29udHJvbHMtZW5hYmxlZCcpO1xuICAgICAgdGhpcy5hZGRDbGFzcygndmpzLWNvbnRyb2xzLWRpc2FibGVkJyk7XG4gICAgICAvKipcbiAgICAgICAqIEBldmVudCBQbGF5ZXIjY29udHJvbHNkaXNhYmxlZFxuICAgICAgICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICAgICAgICovXG4gICAgICB0aGlzLnRyaWdnZXIoJ2NvbnRyb2xzZGlzYWJsZWQnKTtcbiAgICAgIGlmICghdGhpcy51c2luZ05hdGl2ZUNvbnRyb2xzKCkpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVUZWNoQ29udHJvbHNMaXN0ZW5lcnNfKCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBUb2dnbGUgbmF0aXZlIGNvbnRyb2xzIG9uL29mZi4gTmF0aXZlIGNvbnRyb2xzIGFyZSB0aGUgY29udHJvbHMgYnVpbHQgaW50b1xuICAgKiBkZXZpY2VzIChlLmcuIGRlZmF1bHQgaVBob25lIGNvbnRyb2xzKSwgRmxhc2gsIG9yIG90aGVyIHRlY2hzXG4gICAqIChlLmcuIFZpbWVvIENvbnRyb2xzKVxuICAgKiAqKlRoaXMgc2hvdWxkIG9ubHkgYmUgc2V0IGJ5IHRoZSBjdXJyZW50IHRlY2gsIGJlY2F1c2Ugb25seSB0aGUgdGVjaCBrbm93c1xuICAgKiBpZiBpdCBjYW4gc3VwcG9ydCBuYXRpdmUgY29udHJvbHMqKlxuICAgKlxuICAgKiBAZmlyZXMgUGxheWVyI3VzaW5nbmF0aXZlY29udHJvbHNcbiAgICogQGZpcmVzIFBsYXllciN1c2luZ2N1c3RvbWNvbnRyb2xzXG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Jvb2xdXG4gICAqICAgICAgICAtIHRydWUgdG8gdHVybiBuYXRpdmUgY29udHJvbHMgb25cbiAgICogICAgICAgIC0gZmFsc2UgdG8gdHVybiBuYXRpdmUgY29udHJvbHMgb2ZmXG4gICAqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqICAgICAgICAgVGhlIGN1cnJlbnQgdmFsdWUgb2YgbmF0aXZlIGNvbnRyb2xzIHdoZW4gZ2V0dGluZ1xuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUudXNpbmdOYXRpdmVDb250cm9scyA9IGZ1bmN0aW9uIHVzaW5nTmF0aXZlQ29udHJvbHMoYm9vbCkge1xuICAgIGlmIChib29sID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiAhIXRoaXMudXNpbmdOYXRpdmVDb250cm9sc187XG4gICAgfVxuXG4gICAgYm9vbCA9ICEhYm9vbDtcblxuICAgIC8vIERvbid0IHRyaWdnZXIgYSBjaGFuZ2UgZXZlbnQgdW5sZXNzIGl0IGFjdHVhbGx5IGNoYW5nZWRcbiAgICBpZiAodGhpcy51c2luZ05hdGl2ZUNvbnRyb2xzXyA9PT0gYm9vbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMudXNpbmdOYXRpdmVDb250cm9sc18gPSBib29sO1xuXG4gICAgaWYgKHRoaXMudXNpbmdOYXRpdmVDb250cm9sc18pIHtcbiAgICAgIHRoaXMuYWRkQ2xhc3MoJ3Zqcy11c2luZy1uYXRpdmUtY29udHJvbHMnKTtcblxuICAgICAgLyoqXG4gICAgICAgKiBwbGF5ZXIgaXMgdXNpbmcgdGhlIG5hdGl2ZSBkZXZpY2UgY29udHJvbHNcbiAgICAgICAqXG4gICAgICAgKiBAZXZlbnQgUGxheWVyI3VzaW5nbmF0aXZlY29udHJvbHNcbiAgICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAgICAgICAqL1xuICAgICAgdGhpcy50cmlnZ2VyKCd1c2luZ25hdGl2ZWNvbnRyb2xzJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVtb3ZlQ2xhc3MoJ3Zqcy11c2luZy1uYXRpdmUtY29udHJvbHMnKTtcblxuICAgICAgLyoqXG4gICAgICAgKiBwbGF5ZXIgaXMgdXNpbmcgdGhlIGN1c3RvbSBIVE1MIGNvbnRyb2xzXG4gICAgICAgKlxuICAgICAgICogQGV2ZW50IFBsYXllciN1c2luZ2N1c3RvbWNvbnRyb2xzXG4gICAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gICAgICAgKi9cbiAgICAgIHRoaXMudHJpZ2dlcigndXNpbmdjdXN0b21jb250cm9scycpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogU2V0IG9yIGdldCB0aGUgY3VycmVudCBNZWRpYUVycm9yXG4gICAqXG4gICAqIEBmaXJlcyBQbGF5ZXIjZXJyb3JcbiAgICpcbiAgICogQHBhcmFtICB7TWVkaWFFcnJvcnxzdHJpbmd8bnVtYmVyfSBbZXJyXVxuICAgKiAgICAgICAgIEEgTWVkaWFFcnJvciBvciBhIHN0cmluZy9udW1iZXIgdG8gYmUgdHVybmVkXG4gICAqICAgICAgICAgaW50byBhIE1lZGlhRXJyb3JcbiAgICpcbiAgICogQHJldHVybiB7TWVkaWFFcnJvcnxudWxsfVxuICAgKiAgICAgICAgIFRoZSBjdXJyZW50IE1lZGlhRXJyb3Igd2hlbiBnZXR0aW5nIChvciBudWxsKVxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiBlcnJvcihlcnIpIHtcbiAgICBpZiAoZXJyID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLmVycm9yXyB8fCBudWxsO1xuICAgIH1cblxuICAgIC8vIHJlc3RvcmluZyB0byBkZWZhdWx0XG4gICAgaWYgKGVyciA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5lcnJvcl8gPSBlcnI7XG4gICAgICB0aGlzLnJlbW92ZUNsYXNzKCd2anMtZXJyb3InKTtcbiAgICAgIGlmICh0aGlzLmVycm9yRGlzcGxheSkge1xuICAgICAgICB0aGlzLmVycm9yRGlzcGxheS5jbG9zZSgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuZXJyb3JfID0gbmV3IE1lZGlhRXJyb3IoZXJyKTtcblxuICAgIC8vIGFkZCB0aGUgdmpzLWVycm9yIGNsYXNzbmFtZSB0byB0aGUgcGxheWVyXG4gICAgdGhpcy5hZGRDbGFzcygndmpzLWVycm9yJyk7XG5cbiAgICAvLyBsb2cgdGhlIG5hbWUgb2YgdGhlIGVycm9yIHR5cGUgYW5kIGFueSBtZXNzYWdlXG4gICAgLy8gaWU4IGp1c3QgbG9ncyBcIltvYmplY3Qgb2JqZWN0XVwiIGlmIHlvdSBqdXN0IGxvZyB0aGUgZXJyb3Igb2JqZWN0XG4gICAgbG9nLmVycm9yKCcoQ09ERTonICsgdGhpcy5lcnJvcl8uY29kZSArICcgJyArIE1lZGlhRXJyb3IuZXJyb3JUeXBlc1t0aGlzLmVycm9yXy5jb2RlXSArICcpJywgdGhpcy5lcnJvcl8ubWVzc2FnZSwgdGhpcy5lcnJvcl8pO1xuXG4gICAgLyoqXG4gICAgICogQGV2ZW50IFBsYXllciNlcnJvclxuICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAgICAgKi9cbiAgICB0aGlzLnRyaWdnZXIoJ2Vycm9yJyk7XG5cbiAgICByZXR1cm47XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlcG9ydCB1c2VyIGFjdGl2aXR5XG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudFxuICAgKiAgICAgICAgRXZlbnQgb2JqZWN0XG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5yZXBvcnRVc2VyQWN0aXZpdHkgPSBmdW5jdGlvbiByZXBvcnRVc2VyQWN0aXZpdHkoZXZlbnQpIHtcbiAgICB0aGlzLnVzZXJBY3Rpdml0eV8gPSB0cnVlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQvc2V0IGlmIHVzZXIgaXMgYWN0aXZlXG4gICAqXG4gICAqIEBmaXJlcyBQbGF5ZXIjdXNlcmFjdGl2ZVxuICAgKiBAZmlyZXMgUGxheWVyI3VzZXJpbmFjdGl2ZVxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtib29sXVxuICAgKiAgICAgICAgLSB0cnVlIGlmIHRoZSB1c2VyIGlzIGFjdGl2ZVxuICAgKiAgICAgICAgLSBmYWxzZSBpZiB0aGUgdXNlciBpcyBpbmFjdGl2ZVxuICAgKlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKiAgICAgICAgIFRoZSBjdXJyZW50IHZhbHVlIG9mIHVzZXJBY3RpdmUgd2hlbiBnZXR0aW5nXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS51c2VyQWN0aXZlID0gZnVuY3Rpb24gdXNlckFjdGl2ZShib29sKSB7XG4gICAgaWYgKGJvb2wgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHRoaXMudXNlckFjdGl2ZV87XG4gICAgfVxuXG4gICAgYm9vbCA9ICEhYm9vbDtcblxuICAgIGlmIChib29sID09PSB0aGlzLnVzZXJBY3RpdmVfKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy51c2VyQWN0aXZlXyA9IGJvb2w7XG5cbiAgICBpZiAodGhpcy51c2VyQWN0aXZlXykge1xuICAgICAgdGhpcy51c2VyQWN0aXZpdHlfID0gdHJ1ZTtcbiAgICAgIHRoaXMucmVtb3ZlQ2xhc3MoJ3Zqcy11c2VyLWluYWN0aXZlJyk7XG4gICAgICB0aGlzLmFkZENsYXNzKCd2anMtdXNlci1hY3RpdmUnKTtcbiAgICAgIC8qKlxuICAgICAgICogQGV2ZW50IFBsYXllciN1c2VyYWN0aXZlXG4gICAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gICAgICAgKi9cbiAgICAgIHRoaXMudHJpZ2dlcigndXNlcmFjdGl2ZScpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIENocm9tZS9TYWZhcmkvSUUgaGF2ZSBidWdzIHdoZXJlIHdoZW4geW91IGNoYW5nZSB0aGUgY3Vyc29yIGl0IGNhblxuICAgIC8vIHRyaWdnZXIgYSBtb3VzZW1vdmUgZXZlbnQuIFRoaXMgY2F1c2VzIGFuIGlzc3VlIHdoZW4geW91J3JlIGhpZGluZ1xuICAgIC8vIHRoZSBjdXJzb3Igd2hlbiB0aGUgdXNlciBpcyBpbmFjdGl2ZSwgYW5kIGEgbW91c2Vtb3ZlIHNpZ25hbHMgdXNlclxuICAgIC8vIGFjdGl2aXR5LiBNYWtpbmcgaXQgaW1wb3NzaWJsZSB0byBnbyBpbnRvIGluYWN0aXZlIG1vZGUuIFNwZWNpZmljYWxseVxuICAgIC8vIHRoaXMgaGFwcGVucyBpbiBmdWxsc2NyZWVuIHdoZW4gd2UgcmVhbGx5IG5lZWQgdG8gaGlkZSB0aGUgY3Vyc29yLlxuICAgIC8vXG4gICAgLy8gV2hlbiB0aGlzIGdldHMgcmVzb2x2ZWQgaW4gQUxMIGJyb3dzZXJzIGl0IGNhbiBiZSByZW1vdmVkXG4gICAgLy8gaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTEwMzA0MVxuICAgIGlmICh0aGlzLnRlY2hfKSB7XG4gICAgICB0aGlzLnRlY2hfLm9uZSgnbW91c2Vtb3ZlJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdGhpcy51c2VyQWN0aXZpdHlfID0gZmFsc2U7XG4gICAgdGhpcy5yZW1vdmVDbGFzcygndmpzLXVzZXItYWN0aXZlJyk7XG4gICAgdGhpcy5hZGRDbGFzcygndmpzLXVzZXItaW5hY3RpdmUnKTtcbiAgICAvKipcbiAgICAgKiBAZXZlbnQgUGxheWVyI3VzZXJpbmFjdGl2ZVxuICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAgICAgKi9cbiAgICB0aGlzLnRyaWdnZXIoJ3VzZXJpbmFjdGl2ZScpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBMaXN0ZW4gZm9yIHVzZXIgYWN0aXZpdHkgYmFzZWQgb24gdGltZW91dCB2YWx1ZVxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUubGlzdGVuRm9yVXNlckFjdGl2aXR5XyA9IGZ1bmN0aW9uIGxpc3RlbkZvclVzZXJBY3Rpdml0eV8oKSB7XG4gICAgdmFyIG1vdXNlSW5Qcm9ncmVzcyA9IHZvaWQgMDtcbiAgICB2YXIgbGFzdE1vdmVYID0gdm9pZCAwO1xuICAgIHZhciBsYXN0TW92ZVkgPSB2b2lkIDA7XG4gICAgdmFyIGhhbmRsZUFjdGl2aXR5ID0gYmluZCh0aGlzLCB0aGlzLnJlcG9ydFVzZXJBY3Rpdml0eSk7XG5cbiAgICB2YXIgaGFuZGxlTW91c2VNb3ZlID0gZnVuY3Rpb24gaGFuZGxlTW91c2VNb3ZlKGUpIHtcbiAgICAgIC8vICMxMDY4IC0gUHJldmVudCBtb3VzZW1vdmUgc3BhbW1pbmdcbiAgICAgIC8vIENocm9tZSBCdWc6IGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0zNjY5NzBcbiAgICAgIGlmIChlLnNjcmVlblggIT09IGxhc3RNb3ZlWCB8fCBlLnNjcmVlblkgIT09IGxhc3RNb3ZlWSkge1xuICAgICAgICBsYXN0TW92ZVggPSBlLnNjcmVlblg7XG4gICAgICAgIGxhc3RNb3ZlWSA9IGUuc2NyZWVuWTtcbiAgICAgICAgaGFuZGxlQWN0aXZpdHkoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIGhhbmRsZU1vdXNlRG93biA9IGZ1bmN0aW9uIGhhbmRsZU1vdXNlRG93bigpIHtcbiAgICAgIGhhbmRsZUFjdGl2aXR5KCk7XG4gICAgICAvLyBGb3IgYXMgbG9uZyBhcyB0aGUgdGhleSBhcmUgdG91Y2hpbmcgdGhlIGRldmljZSBvciBoYXZlIHRoZWlyIG1vdXNlIGRvd24sXG4gICAgICAvLyB3ZSBjb25zaWRlciB0aGVtIGFjdGl2ZSBldmVuIGlmIHRoZXkncmUgbm90IG1vdmluZyB0aGVpciBmaW5nZXIgb3IgbW91c2UuXG4gICAgICAvLyBTbyB3ZSB3YW50IHRvIGNvbnRpbnVlIHRvIHVwZGF0ZSB0aGF0IHRoZXkgYXJlIGFjdGl2ZVxuICAgICAgdGhpcy5jbGVhckludGVydmFsKG1vdXNlSW5Qcm9ncmVzcyk7XG4gICAgICAvLyBTZXR0aW5nIHVzZXJBY3Rpdml0eT10cnVlIG5vdyBhbmQgc2V0dGluZyB0aGUgaW50ZXJ2YWwgdG8gdGhlIHNhbWUgdGltZVxuICAgICAgLy8gYXMgdGhlIGFjdGl2aXR5Q2hlY2sgaW50ZXJ2YWwgKDI1MCkgc2hvdWxkIGVuc3VyZSB3ZSBuZXZlciBtaXNzIHRoZVxuICAgICAgLy8gbmV4dCBhY3Rpdml0eUNoZWNrXG4gICAgICBtb3VzZUluUHJvZ3Jlc3MgPSB0aGlzLnNldEludGVydmFsKGhhbmRsZUFjdGl2aXR5LCAyNTApO1xuICAgIH07XG5cbiAgICB2YXIgaGFuZGxlTW91c2VVcCA9IGZ1bmN0aW9uIGhhbmRsZU1vdXNlVXAoZXZlbnQpIHtcbiAgICAgIGhhbmRsZUFjdGl2aXR5KCk7XG4gICAgICAvLyBTdG9wIHRoZSBpbnRlcnZhbCB0aGF0IG1haW50YWlucyBhY3Rpdml0eSBpZiB0aGUgbW91c2UvdG91Y2ggaXMgZG93blxuICAgICAgdGhpcy5jbGVhckludGVydmFsKG1vdXNlSW5Qcm9ncmVzcyk7XG4gICAgfTtcblxuICAgIC8vIEFueSBtb3VzZSBtb3ZlbWVudCB3aWxsIGJlIGNvbnNpZGVyZWQgdXNlciBhY3Rpdml0eVxuICAgIHRoaXMub24oJ21vdXNlZG93bicsIGhhbmRsZU1vdXNlRG93bik7XG4gICAgdGhpcy5vbignbW91c2Vtb3ZlJywgaGFuZGxlTW91c2VNb3ZlKTtcbiAgICB0aGlzLm9uKCdtb3VzZXVwJywgaGFuZGxlTW91c2VVcCk7XG5cbiAgICAvLyBMaXN0ZW4gZm9yIGtleWJvYXJkIG5hdmlnYXRpb25cbiAgICAvLyBTaG91bGRuJ3QgbmVlZCB0byB1c2UgaW5Qcm9ncmVzcyBpbnRlcnZhbCBiZWNhdXNlIG9mIGtleSByZXBlYXRcbiAgICB0aGlzLm9uKCdrZXlkb3duJywgaGFuZGxlQWN0aXZpdHkpO1xuICAgIHRoaXMub24oJ2tleXVwJywgaGFuZGxlQWN0aXZpdHkpO1xuXG4gICAgLy8gUnVuIGFuIGludGVydmFsIGV2ZXJ5IDI1MCBtaWxsaXNlY29uZHMgaW5zdGVhZCBvZiBzdHVmZmluZyBldmVyeXRoaW5nIGludG9cbiAgICAvLyB0aGUgbW91c2Vtb3ZlL3RvdWNobW92ZSBmdW5jdGlvbiBpdHNlbGYsIHRvIHByZXZlbnQgcGVyZm9ybWFuY2UgZGVncmFkYXRpb24uXG4gICAgLy8gYHRoaXMucmVwb3J0VXNlckFjdGl2aXR5YCBzaW1wbHkgc2V0cyB0aGlzLnVzZXJBY3Rpdml0eV8gdG8gdHJ1ZSwgd2hpY2hcbiAgICAvLyB0aGVuIGdldHMgcGlja2VkIHVwIGJ5IHRoaXMgbG9vcFxuICAgIC8vIGh0dHA6Ly9lam9obi5vcmcvYmxvZy9sZWFybmluZy1mcm9tLXR3aXR0ZXIvXG4gICAgdmFyIGluYWN0aXZpdHlUaW1lb3V0ID0gdm9pZCAwO1xuXG4gICAgdGhpcy5zZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBDaGVjayB0byBzZWUgaWYgbW91c2UvdG91Y2ggYWN0aXZpdHkgaGFzIGhhcHBlbmVkXG4gICAgICBpZiAoIXRoaXMudXNlckFjdGl2aXR5Xykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIFJlc2V0IHRoZSBhY3Rpdml0eSB0cmFja2VyXG4gICAgICB0aGlzLnVzZXJBY3Rpdml0eV8gPSBmYWxzZTtcblxuICAgICAgLy8gSWYgdGhlIHVzZXIgc3RhdGUgd2FzIGluYWN0aXZlLCBzZXQgdGhlIHN0YXRlIHRvIGFjdGl2ZVxuICAgICAgdGhpcy51c2VyQWN0aXZlKHRydWUpO1xuXG4gICAgICAvLyBDbGVhciBhbnkgZXhpc3RpbmcgaW5hY3Rpdml0eSB0aW1lb3V0IHRvIHN0YXJ0IHRoZSB0aW1lciBvdmVyXG4gICAgICB0aGlzLmNsZWFyVGltZW91dChpbmFjdGl2aXR5VGltZW91dCk7XG5cbiAgICAgIHZhciB0aW1lb3V0ID0gdGhpcy5vcHRpb25zXy5pbmFjdGl2aXR5VGltZW91dDtcblxuICAgICAgaWYgKHRpbWVvdXQgPD0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIEluIDx0aW1lb3V0PiBtaWxsaXNlY29uZHMsIGlmIG5vIG1vcmUgYWN0aXZpdHkgaGFzIG9jY3VycmVkIHRoZVxuICAgICAgLy8gdXNlciB3aWxsIGJlIGNvbnNpZGVyZWQgaW5hY3RpdmVcbiAgICAgIGluYWN0aXZpdHlUaW1lb3V0ID0gdGhpcy5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gUHJvdGVjdCBhZ2FpbnN0IHRoZSBjYXNlIHdoZXJlIHRoZSBpbmFjdGl2aXR5VGltZW91dCBjYW4gdHJpZ2dlciBqdXN0XG4gICAgICAgIC8vIGJlZm9yZSB0aGUgbmV4dCB1c2VyIGFjdGl2aXR5IGlzIHBpY2tlZCB1cCBieSB0aGUgYWN0aXZpdHkgY2hlY2sgbG9vcFxuICAgICAgICAvLyBjYXVzaW5nIGEgZmxpY2tlclxuICAgICAgICBpZiAoIXRoaXMudXNlckFjdGl2aXR5Xykge1xuICAgICAgICAgIHRoaXMudXNlckFjdGl2ZShmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgIH0sIHRpbWVvdXQpO1xuICAgIH0sIDI1MCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldHMgb3Igc2V0cyB0aGUgY3VycmVudCBwbGF5YmFjayByYXRlLiBBIHBsYXliYWNrIHJhdGUgb2ZcbiAgICogMS4wIHJlcHJlc2VudHMgbm9ybWFsIHNwZWVkIGFuZCAwLjUgd291bGQgaW5kaWNhdGUgaGFsZi1zcGVlZFxuICAgKiBwbGF5YmFjaywgZm9yIGluc3RhbmNlLlxuICAgKlxuICAgKiBAc2VlIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2VtYmVkZGVkLWNvbnRlbnQuaHRtbCNkb20tbWVkaWEtcGxheWJhY2tyYXRlXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbcmF0ZV1cbiAgICogICAgICAgTmV3IHBsYXliYWNrIHJhdGUgdG8gc2V0LlxuICAgKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqICAgICAgICAgVGhlIGN1cnJlbnQgcGxheWJhY2sgcmF0ZSB3aGVuIGdldHRpbmcgb3IgMS4wXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5wbGF5YmFja1JhdGUgPSBmdW5jdGlvbiBwbGF5YmFja1JhdGUocmF0ZSkge1xuICAgIGlmIChyYXRlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIE5PVEU6IHRoaXMuY2FjaGVfLmxhc3RQbGF5YmFja1JhdGUgaXMgc2V0IGZyb20gdGhlIHRlY2ggaGFuZGxlclxuICAgICAgLy8gdGhhdCBpcyByZWdpc3RlcmVkIGFib3ZlXG4gICAgICB0aGlzLnRlY2hDYWxsXygnc2V0UGxheWJhY2tSYXRlJywgcmF0ZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMudGVjaF8gJiYgdGhpcy50ZWNoXy5mZWF0dXJlc1BsYXliYWNrUmF0ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuY2FjaGVfLmxhc3RQbGF5YmFja1JhdGUgfHwgdGhpcy50ZWNoR2V0XygncGxheWJhY2tSYXRlJyk7XG4gICAgfVxuICAgIHJldHVybiAxLjA7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldHMgb3Igc2V0cyB0aGUgY3VycmVudCBkZWZhdWx0IHBsYXliYWNrIHJhdGUuIEEgZGVmYXVsdCBwbGF5YmFjayByYXRlIG9mXG4gICAqIDEuMCByZXByZXNlbnRzIG5vcm1hbCBzcGVlZCBhbmQgMC41IHdvdWxkIGluZGljYXRlIGhhbGYtc3BlZWQgcGxheWJhY2ssIGZvciBpbnN0YW5jZS5cbiAgICogZGVmYXVsdFBsYXliYWNrUmF0ZSB3aWxsIG9ubHkgcmVwcmVzZW50IHdoYXQgdGhlIGludGlhbCBwbGF5YmFja1JhdGUgb2YgYSB2aWRlbyB3YXMsIG5vdFxuICAgKiBub3QgdGhlIGN1cnJlbnQgcGxheWJhY2tSYXRlLlxuICAgKlxuICAgKiBAc2VlIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2VtYmVkZGVkLWNvbnRlbnQuaHRtbCNkb20tbWVkaWEtZGVmYXVsdHBsYXliYWNrcmF0ZVxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gW3JhdGVdXG4gICAqICAgICAgIE5ldyBkZWZhdWx0IHBsYXliYWNrIHJhdGUgdG8gc2V0LlxuICAgKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ8UGxheWVyfVxuICAgKiAgICAgICAgIC0gVGhlIGRlZmF1bHQgcGxheWJhY2sgcmF0ZSB3aGVuIGdldHRpbmcgb3IgMS4wXG4gICAqICAgICAgICAgLSB0aGUgcGxheWVyIHdoZW4gc2V0dGluZ1xuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuZGVmYXVsdFBsYXliYWNrUmF0ZSA9IGZ1bmN0aW9uIGRlZmF1bHRQbGF5YmFja1JhdGUocmF0ZSkge1xuICAgIGlmIChyYXRlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLnRlY2hDYWxsXygnc2V0RGVmYXVsdFBsYXliYWNrUmF0ZScsIHJhdGUpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnRlY2hfICYmIHRoaXMudGVjaF8uZmVhdHVyZXNQbGF5YmFja1JhdGUpIHtcbiAgICAgIHJldHVybiB0aGlzLnRlY2hHZXRfKCdkZWZhdWx0UGxheWJhY2tSYXRlJyk7XG4gICAgfVxuICAgIHJldHVybiAxLjA7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldHMgb3Igc2V0cyB0aGUgYXVkaW8gZmxhZ1xuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGJvb2xcbiAgICogICAgICAgIC0gdHJ1ZSBzaWduYWxzIHRoYXQgdGhpcyBpcyBhbiBhdWRpbyBwbGF5ZXJcbiAgICogICAgICAgIC0gZmFsc2Ugc2lnbmFscyB0aGF0IHRoaXMgaXMgbm90IGFuIGF1ZGlvIHBsYXllclxuICAgKlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKiAgICAgICAgIFRoZSBjdXJyZW50IHZhbHVlIG9mIGlzQXVkaW8gd2hlbiBnZXR0aW5nXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5pc0F1ZGlvID0gZnVuY3Rpb24gaXNBdWRpbyhib29sKSB7XG4gICAgaWYgKGJvb2wgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5pc0F1ZGlvXyA9ICEhYm9vbDtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICByZXR1cm4gISF0aGlzLmlzQXVkaW9fO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBIGhlbHBlciBtZXRob2QgZm9yIGFkZGluZyBhIHtAbGluayBUZXh0VHJhY2t9IHRvIG91clxuICAgKiB7QGxpbmsgVGV4dFRyYWNrTGlzdH0uXG4gICAqXG4gICAqIEluIGFkZGl0aW9uIHRvIHRoZSBXM0Mgc2V0dGluZ3Mgd2UgYWxsb3cgYWRkaW5nIGFkZGl0aW9uYWwgaW5mbyB0aHJvdWdoIG9wdGlvbnMuXG4gICAqXG4gICAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvaHRtbC93Zy9kcmFmdHMvaHRtbC9tYXN0ZXIvZW1iZWRkZWQtY29udGVudC0wLmh0bWwjZG9tLW1lZGlhLWFkZHRleHR0cmFja1xuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2tpbmRdXG4gICAqICAgICAgICB0aGUga2luZCBvZiBUZXh0VHJhY2sgeW91IGFyZSBhZGRpbmdcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtsYWJlbF1cbiAgICogICAgICAgIHRoZSBsYWJlbCB0byBnaXZlIHRoZSBUZXh0VHJhY2sgbGFiZWxcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtsYW5ndWFnZV1cbiAgICogICAgICAgIHRoZSBsYW5ndWFnZSB0byBzZXQgb24gdGhlIFRleHRUcmFja1xuICAgKlxuICAgKiBAcmV0dXJuIHtUZXh0VHJhY2t8dW5kZWZpbmVkfVxuICAgKiAgICAgICAgIHRoZSBUZXh0VHJhY2sgdGhhdCB3YXMgYWRkZWQgb3IgdW5kZWZpbmVkXG4gICAqICAgICAgICAgaWYgdGhlcmUgaXMgbm8gdGVjaFxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuYWRkVGV4dFRyYWNrID0gZnVuY3Rpb24gYWRkVGV4dFRyYWNrKGtpbmQsIGxhYmVsLCBsYW5ndWFnZSkge1xuICAgIGlmICh0aGlzLnRlY2hfKSB7XG4gICAgICByZXR1cm4gdGhpcy50ZWNoXy5hZGRUZXh0VHJhY2soa2luZCwgbGFiZWwsIGxhbmd1YWdlKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIHJlbW90ZSB7QGxpbmsgVGV4dFRyYWNrfSBhbmQgYW4ge0BsaW5rIEhUTUxUcmFja0VsZW1lbnR9LiBJdCB3aWxsXG4gICAqIGF1dG9tYXRpY2FsbHkgcmVtb3ZlZCBmcm9tIHRoZSB2aWRlbyBlbGVtZW50IHdoZW5ldmVyIHRoZSBzb3VyY2UgY2hhbmdlcywgdW5sZXNzXG4gICAqIG1hbnVhbENsZWFudXAgaXMgc2V0IHRvIGZhbHNlLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiAgICAgICAgT3B0aW9ucyB0byBwYXNzIHRvIHtAbGluayBIVE1MVHJhY2tFbGVtZW50fSBkdXJpbmcgY3JlYXRpb24uIFNlZVxuICAgKiAgICAgICAge0BsaW5rIEhUTUxUcmFja0VsZW1lbnR9IGZvciBvYmplY3QgcHJvcGVydGllcyB0aGF0IHlvdSBzaG91bGQgdXNlLlxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFttYW51YWxDbGVhbnVwPXRydWVdIGlmIHNldCB0byBmYWxzZSwgdGhlIFRleHRUcmFjayB3aWxsIGJlXG4gICAqXG4gICAqIEByZXR1cm4ge0h0bWxUcmFja0VsZW1lbnR9XG4gICAqICAgICAgICAgdGhlIEhUTUxUcmFja0VsZW1lbnQgdGhhdCB3YXMgY3JlYXRlZCBhbmQgYWRkZWRcbiAgICogICAgICAgICB0byB0aGUgSHRtbFRyYWNrRWxlbWVudExpc3QgYW5kIHRoZSByZW1vdGVcbiAgICogICAgICAgICBUZXh0VHJhY2tMaXN0XG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFRoZSBkZWZhdWx0IHZhbHVlIG9mIHRoZSBcIm1hbnVhbENsZWFudXBcIiBwYXJhbWV0ZXIgd2lsbCBkZWZhdWx0XG4gICAqICAgICAgICAgICAgIHRvIFwiZmFsc2VcIiBpbiB1cGNvbWluZyB2ZXJzaW9ucyBvZiBWaWRlby5qc1xuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuYWRkUmVtb3RlVGV4dFRyYWNrID0gZnVuY3Rpb24gYWRkUmVtb3RlVGV4dFRyYWNrKG9wdGlvbnMsIG1hbnVhbENsZWFudXApIHtcbiAgICBpZiAodGhpcy50ZWNoXykge1xuICAgICAgcmV0dXJuIHRoaXMudGVjaF8uYWRkUmVtb3RlVGV4dFRyYWNrKG9wdGlvbnMsIG1hbnVhbENsZWFudXApO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUmVtb3ZlIGEgcmVtb3RlIHtAbGluayBUZXh0VHJhY2t9IGZyb20gdGhlIHJlc3BlY3RpdmVcbiAgICoge0BsaW5rIFRleHRUcmFja0xpc3R9IGFuZCB7QGxpbmsgSHRtbFRyYWNrRWxlbWVudExpc3R9LlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gdHJhY2tcbiAgICogICAgICAgIFJlbW90ZSB7QGxpbmsgVGV4dFRyYWNrfSB0byByZW1vdmVcbiAgICpcbiAgICogQHJldHVybiB7dW5kZWZpbmVkfVxuICAgKiAgICAgICAgIGRvZXMgbm90IHJldHVybiBhbnl0aGluZ1xuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUucmVtb3ZlUmVtb3RlVGV4dFRyYWNrID0gZnVuY3Rpb24gcmVtb3ZlUmVtb3RlVGV4dFRyYWNrKCkge1xuICAgIHZhciBfcmVmMyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge30sXG4gICAgICAgIF9yZWYzJHRyYWNrID0gX3JlZjMudHJhY2ssXG4gICAgICAgIHRyYWNrID0gX3JlZjMkdHJhY2sgPT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IF9yZWYzJHRyYWNrO1xuXG4gICAgLy8gZGVzdHJ1Y3R1cmUgdGhlIGlucHV0IGludG8gYW4gb2JqZWN0IHdpdGggYSB0cmFjayBhcmd1bWVudCwgZGVmYXVsdGluZyB0byBhcmd1bWVudHNbMF1cbiAgICAvLyBkZWZhdWx0IHRoZSB3aG9sZSBhcmd1bWVudCB0byBhbiBlbXB0eSBvYmplY3QgaWYgbm90aGluZyB3YXMgcGFzc2VkIGluXG5cbiAgICBpZiAodGhpcy50ZWNoXykge1xuICAgICAgcmV0dXJuIHRoaXMudGVjaF8ucmVtb3ZlUmVtb3RlVGV4dFRyYWNrKHRyYWNrKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldHMgYXZhaWxhYmxlIG1lZGlhIHBsYXliYWNrIHF1YWxpdHkgbWV0cmljcyBhcyBzcGVjaWZpZWQgYnkgdGhlIFczQydzIE1lZGlhXG4gICAqIFBsYXliYWNrIFF1YWxpdHkgQVBJLlxuICAgKlxuICAgKiBAc2VlIFtTcGVjXXtAbGluayBodHRwczovL3dpY2cuZ2l0aHViLmlvL21lZGlhLXBsYXliYWNrLXF1YWxpdHl9XG4gICAqXG4gICAqIEByZXR1cm4ge09iamVjdHx1bmRlZmluZWR9XG4gICAqICAgICAgICAgQW4gb2JqZWN0IHdpdGggc3VwcG9ydGVkIG1lZGlhIHBsYXliYWNrIHF1YWxpdHkgbWV0cmljcyBvciB1bmRlZmluZWQgaWYgdGhlcmVcbiAgICogICAgICAgICBpcyBubyB0ZWNoIG9yIHRoZSB0ZWNoIGRvZXMgbm90IHN1cHBvcnQgaXQuXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5nZXRWaWRlb1BsYXliYWNrUXVhbGl0eSA9IGZ1bmN0aW9uIGdldFZpZGVvUGxheWJhY2tRdWFsaXR5KCkge1xuICAgIHJldHVybiB0aGlzLnRlY2hHZXRfKCdnZXRWaWRlb1BsYXliYWNrUXVhbGl0eScpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdmlkZW8gd2lkdGhcbiAgICpcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKiAgICAgICAgIGN1cnJlbnQgdmlkZW8gd2lkdGhcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLnZpZGVvV2lkdGggPSBmdW5jdGlvbiB2aWRlb1dpZHRoKCkge1xuICAgIHJldHVybiB0aGlzLnRlY2hfICYmIHRoaXMudGVjaF8udmlkZW9XaWR0aCAmJiB0aGlzLnRlY2hfLnZpZGVvV2lkdGgoKSB8fCAwO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdmlkZW8gaGVpZ2h0XG4gICAqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICogICAgICAgICBjdXJyZW50IHZpZGVvIGhlaWdodFxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUudmlkZW9IZWlnaHQgPSBmdW5jdGlvbiB2aWRlb0hlaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy50ZWNoXyAmJiB0aGlzLnRlY2hfLnZpZGVvSGVpZ2h0ICYmIHRoaXMudGVjaF8udmlkZW9IZWlnaHQoKSB8fCAwO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUaGUgcGxheWVyJ3MgbGFuZ3VhZ2UgY29kZVxuICAgKiBOT1RFOiBUaGUgbGFuZ3VhZ2Ugc2hvdWxkIGJlIHNldCBpbiB0aGUgcGxheWVyIG9wdGlvbnMgaWYgeW91IHdhbnQgdGhlXG4gICAqIHRoZSBjb250cm9scyB0byBiZSBidWlsdCB3aXRoIGEgc3BlY2lmaWMgbGFuZ3VhZ2UuIENoYW5naW5nIHRoZSBsYW51Z2FnZVxuICAgKiBsYXRlciB3aWxsIG5vdCB1cGRhdGUgY29udHJvbHMgdGV4dC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtjb2RlXVxuICAgKiAgICAgICAgdGhlIGxhbmd1YWdlIGNvZGUgdG8gc2V0IHRoZSBwbGF5ZXIgdG9cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKiAgICAgICAgIFRoZSBjdXJyZW50IGxhbmd1YWdlIGNvZGUgd2hlbiBnZXR0aW5nXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5sYW5ndWFnZSA9IGZ1bmN0aW9uIGxhbmd1YWdlKGNvZGUpIHtcbiAgICBpZiAoY29kZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdGhpcy5sYW5ndWFnZV87XG4gICAgfVxuXG4gICAgdGhpcy5sYW5ndWFnZV8gPSBTdHJpbmcoY29kZSkudG9Mb3dlckNhc2UoKTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSBwbGF5ZXIncyBsYW5ndWFnZSBkaWN0aW9uYXJ5XG4gICAqIE1lcmdlIGV2ZXJ5IHRpbWUsIGJlY2F1c2UgYSBuZXdseSBhZGRlZCBwbHVnaW4gbWlnaHQgY2FsbCB2aWRlb2pzLmFkZExhbmd1YWdlKCkgYXQgYW55IHRpbWVcbiAgICogTGFuZ3VhZ2VzIHNwZWNpZmllZCBkaXJlY3RseSBpbiB0aGUgcGxheWVyIG9wdGlvbnMgaGF2ZSBwcmVjZWRlbmNlXG4gICAqXG4gICAqIEByZXR1cm4ge0FycmF5fVxuICAgKiAgICAgICAgIEFuIGFycmF5IG9mIG9mIHN1cHBvcnRlZCBsYW5ndWFnZXNcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLmxhbmd1YWdlcyA9IGZ1bmN0aW9uIGxhbmd1YWdlcygpIHtcbiAgICByZXR1cm4gbWVyZ2VPcHRpb25zKFBsYXllci5wcm90b3R5cGUub3B0aW9uc18ubGFuZ3VhZ2VzLCB0aGlzLmxhbmd1YWdlc18pO1xuICB9O1xuXG4gIC8qKlxuICAgKiByZXR1cm5zIGEgSmF2YVNjcmlwdCBvYmplY3QgcmVwZXJlc2VudGluZyB0aGUgY3VycmVudCB0cmFja1xuICAgKiBpbmZvcm1hdGlvbi4gKipET0VTIG5vdCByZXR1cm4gaXQgYXMgSlNPTioqXG4gICAqXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICogICAgICAgICBPYmplY3QgcmVwcmVzZW50aW5nIHRoZSBjdXJyZW50IG9mIHRyYWNrIGluZm9cbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICB2YXIgb3B0aW9ucyA9IG1lcmdlT3B0aW9ucyh0aGlzLm9wdGlvbnNfKTtcbiAgICB2YXIgdHJhY2tzID0gb3B0aW9ucy50cmFja3M7XG5cbiAgICBvcHRpb25zLnRyYWNrcyA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB0cmFjayA9IHRyYWNrc1tpXTtcblxuICAgICAgLy8gZGVlcCBtZXJnZSB0cmFja3MgYW5kIG51bGwgb3V0IHBsYXllciBzbyBubyBjaXJjdWxhciByZWZlcmVuY2VzXG4gICAgICB0cmFjayA9IG1lcmdlT3B0aW9ucyh0cmFjayk7XG4gICAgICB0cmFjay5wbGF5ZXIgPSB1bmRlZmluZWQ7XG4gICAgICBvcHRpb25zLnRyYWNrc1tpXSA9IHRyYWNrO1xuICAgIH1cblxuICAgIHJldHVybiBvcHRpb25zO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgc2ltcGxlIG1vZGFsIGRpYWxvZyAoYW4gaW5zdGFuY2Ugb2YgdGhlIHtAbGluayBNb2RhbERpYWxvZ31cbiAgICogY29tcG9uZW50KSB0aGF0IGltbWVkaWF0ZWx5IG92ZXJsYXlzIHRoZSBwbGF5ZXIgd2l0aCBhcmJpdHJhcnlcbiAgICogY29udGVudCBhbmQgcmVtb3ZlcyBpdHNlbGYgd2hlbiBjbG9zZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfEZ1bmN0aW9ufEVsZW1lbnR8QXJyYXl8bnVsbH0gY29udGVudFxuICAgKiAgICAgICAgU2FtZSBhcyB7QGxpbmsgTW9kYWxEaWFsb2cjY29udGVudH0ncyBwYXJhbSBvZiB0aGUgc2FtZSBuYW1lLlxuICAgKiAgICAgICAgVGhlIG1vc3Qgc3RyYWlnaHQtZm9yd2FyZCB1c2FnZSBpcyB0byBwcm92aWRlIGEgc3RyaW5nIG9yIERPTVxuICAgKiAgICAgICAgZWxlbWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgICAgICAgRXh0cmEgb3B0aW9ucyB3aGljaCB3aWxsIGJlIHBhc3NlZCBvbiB0byB0aGUge0BsaW5rIE1vZGFsRGlhbG9nfS5cbiAgICpcbiAgICogQHJldHVybiB7TW9kYWxEaWFsb2d9XG4gICAqICAgICAgICAgdGhlIHtAbGluayBNb2RhbERpYWxvZ30gdGhhdCB3YXMgY3JlYXRlZFxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuY3JlYXRlTW9kYWwgPSBmdW5jdGlvbiBjcmVhdGVNb2RhbChjb250ZW50LCBvcHRpb25zKSB7XG4gICAgdmFyIF90aGlzMTIgPSB0aGlzO1xuXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgb3B0aW9ucy5jb250ZW50ID0gY29udGVudCB8fCAnJztcblxuICAgIHZhciBtb2RhbCA9IG5ldyBNb2RhbERpYWxvZyh0aGlzLCBvcHRpb25zKTtcblxuICAgIHRoaXMuYWRkQ2hpbGQobW9kYWwpO1xuICAgIG1vZGFsLm9uKCdkaXNwb3NlJywgZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMxMi5yZW1vdmVDaGlsZChtb2RhbCk7XG4gICAgfSk7XG5cbiAgICBtb2RhbC5vcGVuKCk7XG4gICAgcmV0dXJuIG1vZGFsO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDaGFuZ2UgYnJlYWtwb2ludCBjbGFzc2VzIHdoZW4gdGhlIHBsYXllciByZXNpemVzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUudXBkYXRlQ3VycmVudEJyZWFrcG9pbnRfID0gZnVuY3Rpb24gdXBkYXRlQ3VycmVudEJyZWFrcG9pbnRfKCkge1xuICAgIGlmICghdGhpcy5yZXNwb25zaXZlKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgY3VycmVudEJyZWFrcG9pbnQgPSB0aGlzLmN1cnJlbnRCcmVha3BvaW50KCk7XG4gICAgdmFyIGN1cnJlbnRXaWR0aCA9IHRoaXMuY3VycmVudFdpZHRoKCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IEJSRUFLUE9JTlRfT1JERVIubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjYW5kaWRhdGVCcmVha3BvaW50ID0gQlJFQUtQT0lOVF9PUkRFUltpXTtcbiAgICAgIHZhciBtYXhXaWR0aCA9IHRoaXMuYnJlYWtwb2ludHNfW2NhbmRpZGF0ZUJyZWFrcG9pbnRdO1xuXG4gICAgICBpZiAoY3VycmVudFdpZHRoIDw9IG1heFdpZHRoKSB7XG5cbiAgICAgICAgLy8gVGhlIGN1cnJlbnQgYnJlYWtwb2ludCBkaWQgbm90IGNoYW5nZSwgbm90aGluZyB0byBkby5cbiAgICAgICAgaWYgKGN1cnJlbnRCcmVha3BvaW50ID09PSBjYW5kaWRhdGVCcmVha3BvaW50KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gT25seSByZW1vdmUgYSBjbGFzcyBpZiB0aGVyZSBpcyBhIGN1cnJlbnQgYnJlYWtwb2ludC5cbiAgICAgICAgaWYgKGN1cnJlbnRCcmVha3BvaW50KSB7XG4gICAgICAgICAgdGhpcy5yZW1vdmVDbGFzcyhCUkVBS1BPSU5UX0NMQVNTRVNbY3VycmVudEJyZWFrcG9pbnRdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuYWRkQ2xhc3MoQlJFQUtQT0lOVF9DTEFTU0VTW2NhbmRpZGF0ZUJyZWFrcG9pbnRdKTtcbiAgICAgICAgdGhpcy5icmVha3BvaW50XyA9IGNhbmRpZGF0ZUJyZWFrcG9pbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUmVtb3ZlcyB0aGUgY3VycmVudCBicmVha3BvaW50LlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUucmVtb3ZlQ3VycmVudEJyZWFrcG9pbnRfID0gZnVuY3Rpb24gcmVtb3ZlQ3VycmVudEJyZWFrcG9pbnRfKCkge1xuICAgIHZhciBjbGFzc05hbWUgPSB0aGlzLmN1cnJlbnRCcmVha3BvaW50Q2xhc3MoKTtcblxuICAgIHRoaXMuYnJlYWtwb2ludF8gPSAnJztcblxuICAgIGlmIChjbGFzc05hbWUpIHtcbiAgICAgIHRoaXMucmVtb3ZlQ2xhc3MoY2xhc3NOYW1lKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBvciBzZXQgYnJlYWtwb2ludHMgb24gdGhlIHBsYXllci5cbiAgICpcbiAgICogQ2FsbGluZyB0aGlzIG1ldGhvZCB3aXRoIGFuIG9iamVjdCBvciBgdHJ1ZWAgd2lsbCByZW1vdmUgYW55IHByZXZpb3VzXG4gICAqIGN1c3RvbSBicmVha3BvaW50cyBhbmQgc3RhcnQgZnJvbSB0aGUgZGVmYXVsdHMgYWdhaW4uXG4gICAqXG4gICAqIEBwYXJhbSAge09iamVjdHxib29sZWFufSBbYnJlYWtwb2ludHNdXG4gICAqICAgICAgICAgSWYgYW4gb2JqZWN0IGlzIGdpdmVuLCBpdCBjYW4gYmUgdXNlZCB0byBwcm92aWRlIGN1c3RvbVxuICAgKiAgICAgICAgIGJyZWFrcG9pbnRzLiBJZiBgdHJ1ZWAgaXMgZ2l2ZW4sIHdpbGwgc2V0IGRlZmF1bHQgYnJlYWtwb2ludHMuXG4gICAqICAgICAgICAgSWYgdGhpcyBhcmd1bWVudCBpcyBub3QgZ2l2ZW4sIHdpbGwgc2ltcGx5IHJldHVybiB0aGUgY3VycmVudFxuICAgKiAgICAgICAgIGJyZWFrcG9pbnRzLlxuICAgKlxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IFticmVha3BvaW50cy50aW55XVxuICAgKiAgICAgICAgIFRoZSBtYXhpbXVtIHdpZHRoIGZvciB0aGUgXCJ2anMtbGF5b3V0LXRpbnlcIiBjbGFzcy5cbiAgICpcbiAgICogQHBhcmFtICB7bnVtYmVyfSBbYnJlYWtwb2ludHMueHNtYWxsXVxuICAgKiAgICAgICAgIFRoZSBtYXhpbXVtIHdpZHRoIGZvciB0aGUgXCJ2anMtbGF5b3V0LXgtc21hbGxcIiBjbGFzcy5cbiAgICpcbiAgICogQHBhcmFtICB7bnVtYmVyfSBbYnJlYWtwb2ludHMuc21hbGxdXG4gICAqICAgICAgICAgVGhlIG1heGltdW0gd2lkdGggZm9yIHRoZSBcInZqcy1sYXlvdXQtc21hbGxcIiBjbGFzcy5cbiAgICpcbiAgICogQHBhcmFtICB7bnVtYmVyfSBbYnJlYWtwb2ludHMubWVkaXVtXVxuICAgKiAgICAgICAgIFRoZSBtYXhpbXVtIHdpZHRoIGZvciB0aGUgXCJ2anMtbGF5b3V0LW1lZGl1bVwiIGNsYXNzLlxuICAgKlxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IFticmVha3BvaW50cy5sYXJnZV1cbiAgICogICAgICAgICBUaGUgbWF4aW11bSB3aWR0aCBmb3IgdGhlIFwidmpzLWxheW91dC1sYXJnZVwiIGNsYXNzLlxuICAgKlxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IFticmVha3BvaW50cy54bGFyZ2VdXG4gICAqICAgICAgICAgVGhlIG1heGltdW0gd2lkdGggZm9yIHRoZSBcInZqcy1sYXlvdXQteC1sYXJnZVwiIGNsYXNzLlxuICAgKlxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IFticmVha3BvaW50cy5odWdlXVxuICAgKiAgICAgICAgIFRoZSBtYXhpbXVtIHdpZHRoIGZvciB0aGUgXCJ2anMtbGF5b3V0LWh1Z2VcIiBjbGFzcy5cbiAgICpcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKiAgICAgICAgIEFuIG9iamVjdCBtYXBwaW5nIGJyZWFrcG9pbnQgbmFtZXMgdG8gbWF4aW11bSB3aWR0aCB2YWx1ZXMuXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5icmVha3BvaW50cyA9IGZ1bmN0aW9uIGJyZWFrcG9pbnRzKF9icmVha3BvaW50cykge1xuXG4gICAgLy8gVXNlZCBhcyBhIGdldHRlci5cbiAgICBpZiAoX2JyZWFrcG9pbnRzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBhc3NpZ24odGhpcy5icmVha3BvaW50c18pO1xuICAgIH1cblxuICAgIHRoaXMuYnJlYWtwb2ludF8gPSAnJztcbiAgICB0aGlzLmJyZWFrcG9pbnRzXyA9IGFzc2lnbih7fSwgREVGQVVMVF9CUkVBS1BPSU5UUywgX2JyZWFrcG9pbnRzKTtcblxuICAgIC8vIFdoZW4gYnJlYWtwb2ludCBkZWZpbml0aW9ucyBjaGFuZ2UsIHdlIG5lZWQgdG8gdXBkYXRlIHRoZSBjdXJyZW50bHlcbiAgICAvLyBzZWxlY3RlZCBicmVha3BvaW50LlxuICAgIHRoaXMudXBkYXRlQ3VycmVudEJyZWFrcG9pbnRfKCk7XG5cbiAgICAvLyBDbG9uZSB0aGUgYnJlYWtwb2ludHMgYmVmb3JlIHJldHVybmluZy5cbiAgICByZXR1cm4gYXNzaWduKHRoaXMuYnJlYWtwb2ludHNfKTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IG9yIHNldCBhIGZsYWcgaW5kaWNhdGluZyB3aGV0aGVyIG9yIG5vdCB0aGlzIHBsYXllciBzaG91bGQgYWRqdXN0XG4gICAqIGl0cyBVSSBiYXNlZCBvbiBpdHMgZGltZW5zaW9ucy5cbiAgICpcbiAgICogQHBhcmFtICB7Ym9vbGVhbn0gdmFsdWVcbiAgICogICAgICAgICBTaG91bGQgYmUgYHRydWVgIGlmIHRoZSBwbGF5ZXIgc2hvdWxkIGFkanVzdCBpdHMgVUkgYmFzZWQgb24gaXRzXG4gICAqICAgICAgICAgZGltZW5zaW9uczsgb3RoZXJ3aXNlLCBzaG91bGQgYmUgYGZhbHNlYC5cbiAgICpcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICogICAgICAgICBXaWxsIGJlIGB0cnVlYCBpZiB0aGlzIHBsYXllciBzaG91bGQgYWRqdXN0IGl0cyBVSSBiYXNlZCBvbiBpdHNcbiAgICogICAgICAgICBkaW1lbnNpb25zOyBvdGhlcndpc2UsIHdpbGwgYmUgYGZhbHNlYC5cbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLnJlc3BvbnNpdmUgPSBmdW5jdGlvbiByZXNwb25zaXZlKHZhbHVlKSB7XG5cbiAgICAvLyBVc2VkIGFzIGEgZ2V0dGVyLlxuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZXNwb25zaXZlXztcbiAgICB9XG5cbiAgICB2YWx1ZSA9IEJvb2xlYW4odmFsdWUpO1xuICAgIHZhciBjdXJyZW50ID0gdGhpcy5yZXNwb25zaXZlXztcblxuICAgIC8vIE5vdGhpbmcgY2hhbmdlZC5cbiAgICBpZiAodmFsdWUgPT09IGN1cnJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBUaGUgdmFsdWUgYWN0dWFsbHkgY2hhbmdlZCwgc2V0IGl0LlxuICAgIHRoaXMucmVzcG9uc2l2ZV8gPSB2YWx1ZTtcblxuICAgIC8vIFN0YXJ0IGxpc3RlbmluZyBmb3IgYnJlYWtwb2ludHMgYW5kIHNldCB0aGUgaW5pdGlhbCBicmVha3BvaW50IGlmIHRoZVxuICAgIC8vIHBsYXllciBpcyBub3cgcmVzcG9uc2l2ZS5cbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIHRoaXMub24oJ3BsYXllcnJlc2l6ZScsIHRoaXMudXBkYXRlQ3VycmVudEJyZWFrcG9pbnRfKTtcbiAgICAgIHRoaXMudXBkYXRlQ3VycmVudEJyZWFrcG9pbnRfKCk7XG5cbiAgICAgIC8vIFN0b3AgbGlzdGVuaW5nIGZvciBicmVha3BvaW50cyBpZiB0aGUgcGxheWVyIGlzIG5vIGxvbmdlciByZXNwb25zaXZlLlxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm9mZigncGxheWVycmVzaXplJywgdGhpcy51cGRhdGVDdXJyZW50QnJlYWtwb2ludF8pO1xuICAgICAgdGhpcy5yZW1vdmVDdXJyZW50QnJlYWtwb2ludF8oKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBjdXJyZW50IGJyZWFrcG9pbnQgbmFtZSwgaWYgYW55LlxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqICAgICAgICAgSWYgdGhlcmUgaXMgY3VycmVudGx5IGEgYnJlYWtwb2ludCBzZXQsIHJldHVybnMgYSB0aGUga2V5IGZyb20gdGhlXG4gICAqICAgICAgICAgYnJlYWtwb2ludHMgb2JqZWN0IG1hdGNoaW5nIGl0LiBPdGhlcndpc2UsIHJldHVybnMgYW4gZW1wdHkgc3RyaW5nLlxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuY3VycmVudEJyZWFrcG9pbnQgPSBmdW5jdGlvbiBjdXJyZW50QnJlYWtwb2ludCgpIHtcbiAgICByZXR1cm4gdGhpcy5icmVha3BvaW50XztcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSBjdXJyZW50IGJyZWFrcG9pbnQgY2xhc3MgbmFtZS5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKiAgICAgICAgIFRoZSBtYXRjaGluZyBjbGFzcyBuYW1lIChlLmcuIGBcInZqcy1sYXlvdXQtdGlueVwiYCBvclxuICAgKiAgICAgICAgIGBcInZqcy1sYXlvdXQtbGFyZ2VcImApIGZvciB0aGUgY3VycmVudCBicmVha3BvaW50LiBFbXB0eSBzdHJpbmcgaWZcbiAgICogICAgICAgICB0aGVyZSBpcyBubyBjdXJyZW50IGJyZWFrcG9pbnQuXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5jdXJyZW50QnJlYWtwb2ludENsYXNzID0gZnVuY3Rpb24gY3VycmVudEJyZWFrcG9pbnRDbGFzcygpIHtcbiAgICByZXR1cm4gQlJFQUtQT0lOVF9DTEFTU0VTW3RoaXMuYnJlYWtwb2ludF9dIHx8ICcnO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXRzIHRhZyBzZXR0aW5nc1xuICAgKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IHRhZ1xuICAgKiAgICAgICAgVGhlIHBsYXllciB0YWdcbiAgICpcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKiAgICAgICAgIEFuIG9iamVjdCBjb250YWluaW5nIGFsbCBvZiB0aGUgc2V0dGluZ3NcbiAgICogICAgICAgICBmb3IgYSBwbGF5ZXIgdGFnXG4gICAqL1xuXG5cbiAgUGxheWVyLmdldFRhZ1NldHRpbmdzID0gZnVuY3Rpb24gZ2V0VGFnU2V0dGluZ3ModGFnKSB7XG4gICAgdmFyIGJhc2VPcHRpb25zID0ge1xuICAgICAgc291cmNlczogW10sXG4gICAgICB0cmFja3M6IFtdXG4gICAgfTtcblxuICAgIHZhciB0YWdPcHRpb25zID0gZ2V0QXR0cmlidXRlcyh0YWcpO1xuICAgIHZhciBkYXRhU2V0dXAgPSB0YWdPcHRpb25zWydkYXRhLXNldHVwJ107XG5cbiAgICBpZiAoaGFzQ2xhc3ModGFnLCAndmpzLWZpbGwnKSkge1xuICAgICAgdGFnT3B0aW9ucy5maWxsID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGhhc0NsYXNzKHRhZywgJ3Zqcy1mbHVpZCcpKSB7XG4gICAgICB0YWdPcHRpb25zLmZsdWlkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBpZiBkYXRhLXNldHVwIGF0dHIgZXhpc3RzLlxuICAgIGlmIChkYXRhU2V0dXAgIT09IG51bGwpIHtcbiAgICAgIC8vIFBhcnNlIG9wdGlvbnMgSlNPTlxuICAgICAgLy8gSWYgZW1wdHkgc3RyaW5nLCBtYWtlIGl0IGEgcGFyc2FibGUganNvbiBvYmplY3QuXG4gICAgICB2YXIgX3NhZmVQYXJzZVR1cGxlID0gc2FmZVBhcnNlVHVwbGUoZGF0YVNldHVwIHx8ICd7fScpLFxuICAgICAgICAgIGVyciA9IF9zYWZlUGFyc2VUdXBsZVswXSxcbiAgICAgICAgICBkYXRhID0gX3NhZmVQYXJzZVR1cGxlWzFdO1xuXG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIGxvZy5lcnJvcihlcnIpO1xuICAgICAgfVxuICAgICAgYXNzaWduKHRhZ09wdGlvbnMsIGRhdGEpO1xuICAgIH1cblxuICAgIGFzc2lnbihiYXNlT3B0aW9ucywgdGFnT3B0aW9ucyk7XG5cbiAgICAvLyBHZXQgdGFnIGNoaWxkcmVuIHNldHRpbmdzXG4gICAgaWYgKHRhZy5oYXNDaGlsZE5vZGVzKCkpIHtcbiAgICAgIHZhciBjaGlsZHJlbiA9IHRhZy5jaGlsZE5vZGVzO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgaiA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuICAgICAgICB2YXIgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgICAgLy8gQ2hhbmdlIGNhc2UgbmVlZGVkOiBodHRwOi8vZWpvaG4ub3JnL2Jsb2cvbm9kZW5hbWUtY2FzZS1zZW5zaXRpdml0eS9cbiAgICAgICAgdmFyIGNoaWxkTmFtZSA9IGNoaWxkLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgICAgaWYgKGNoaWxkTmFtZSA9PT0gJ3NvdXJjZScpIHtcbiAgICAgICAgICBiYXNlT3B0aW9ucy5zb3VyY2VzLnB1c2goZ2V0QXR0cmlidXRlcyhjaGlsZCkpO1xuICAgICAgICB9IGVsc2UgaWYgKGNoaWxkTmFtZSA9PT0gJ3RyYWNrJykge1xuICAgICAgICAgIGJhc2VPcHRpb25zLnRyYWNrcy5wdXNoKGdldEF0dHJpYnV0ZXMoY2hpbGQpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBiYXNlT3B0aW9ucztcbiAgfTtcblxuICAvKipcbiAgICogRGV0ZXJtaW5lIHdldGhlciBvciBub3QgZmxleGJveCBpcyBzdXBwb3J0ZWRcbiAgICpcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICogICAgICAgICAtIHRydWUgaWYgZmxleGJveCBpcyBzdXBwb3J0ZWRcbiAgICogICAgICAgICAtIGZhbHNlIGlmIGZsZXhib3ggaXMgbm90IHN1cHBvcnRlZFxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuZmxleE5vdFN1cHBvcnRlZF8gPSBmdW5jdGlvbiBmbGV4Tm90U3VwcG9ydGVkXygpIHtcbiAgICB2YXIgZWxlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2knKTtcblxuICAgIC8vIE5vdGU6IFdlIGRvbid0IGFjdHVhbGx5IHVzZSBmbGV4QmFzaXMgKG9yIGZsZXhPcmRlciksIGJ1dCBpdCdzIG9uZSBvZiB0aGUgbW9yZVxuICAgIC8vIGNvbW1vbiBmbGV4IGZlYXR1cmVzIHRoYXQgd2UgY2FuIHJlbHkgb24gd2hlbiBjaGVja2luZyBmb3IgZmxleCBzdXBwb3J0LlxuICAgIHJldHVybiAhKCdmbGV4QmFzaXMnIGluIGVsZW0uc3R5bGUgfHwgJ3dlYmtpdEZsZXhCYXNpcycgaW4gZWxlbS5zdHlsZSB8fCAnbW96RmxleEJhc2lzJyBpbiBlbGVtLnN0eWxlIHx8ICdtc0ZsZXhCYXNpcycgaW4gZWxlbS5zdHlsZSB8fFxuICAgIC8vIElFMTAtc3BlY2lmaWMgKDIwMTIgZmxleCBzcGVjKVxuICAgICdtc0ZsZXhPcmRlcicgaW4gZWxlbS5zdHlsZSk7XG4gIH07XG5cbiAgcmV0dXJuIFBsYXllcjtcbn0oQ29tcG9uZW50KTtcblxuLyoqXG4gKiBHZXQgdGhlIHtAbGluayBWaWRlb1RyYWNrTGlzdH1cbiAqIEBsaW5rIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2VtYmVkZGVkLWNvbnRlbnQuaHRtbCN2aWRlb3RyYWNrbGlzdFxuICpcbiAqIEByZXR1cm4ge1ZpZGVvVHJhY2tMaXN0fVxuICogICAgICAgICB0aGUgY3VycmVudCB2aWRlbyB0cmFjayBsaXN0XG4gKlxuICogQG1ldGhvZCBQbGF5ZXIucHJvdG90eXBlLnZpZGVvVHJhY2tzXG4gKi9cblxuLyoqXG4gKiBHZXQgdGhlIHtAbGluayBBdWRpb1RyYWNrTGlzdH1cbiAqIEBsaW5rIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2VtYmVkZGVkLWNvbnRlbnQuaHRtbCNhdWRpb3RyYWNrbGlzdFxuICpcbiAqIEByZXR1cm4ge0F1ZGlvVHJhY2tMaXN0fVxuICogICAgICAgICB0aGUgY3VycmVudCBhdWRpbyB0cmFjayBsaXN0XG4gKlxuICogQG1ldGhvZCBQbGF5ZXIucHJvdG90eXBlLmF1ZGlvVHJhY2tzXG4gKi9cblxuLyoqXG4gKiBHZXQgdGhlIHtAbGluayBUZXh0VHJhY2tMaXN0fVxuICpcbiAqIEBsaW5rIGh0dHA6Ly93d3cudzMub3JnL2h0bWwvd2cvZHJhZnRzL2h0bWwvbWFzdGVyL2VtYmVkZGVkLWNvbnRlbnQtMC5odG1sI2RvbS1tZWRpYS10ZXh0dHJhY2tzXG4gKlxuICogQHJldHVybiB7VGV4dFRyYWNrTGlzdH1cbiAqICAgICAgICAgdGhlIGN1cnJlbnQgdGV4dCB0cmFjayBsaXN0XG4gKlxuICogQG1ldGhvZCBQbGF5ZXIucHJvdG90eXBlLnRleHRUcmFja3NcbiAqL1xuXG4vKipcbiAqIEdldCB0aGUgcmVtb3RlIHtAbGluayBUZXh0VHJhY2tMaXN0fVxuICpcbiAqIEByZXR1cm4ge1RleHRUcmFja0xpc3R9XG4gKiAgICAgICAgIFRoZSBjdXJyZW50IHJlbW90ZSB0ZXh0IHRyYWNrIGxpc3RcbiAqXG4gKiBAbWV0aG9kIFBsYXllci5wcm90b3R5cGUucmVtb3RlVGV4dFRyYWNrc1xuICovXG5cbi8qKlxuICogR2V0IHRoZSByZW1vdGUge0BsaW5rIEh0bWxUcmFja0VsZW1lbnRMaXN0fSB0cmFja3MuXG4gKlxuICogQHJldHVybiB7SHRtbFRyYWNrRWxlbWVudExpc3R9XG4gKiAgICAgICAgIFRoZSBjdXJyZW50IHJlbW90ZSB0ZXh0IHRyYWNrIGVsZW1lbnQgbGlzdFxuICpcbiAqIEBtZXRob2QgUGxheWVyLnByb3RvdHlwZS5yZW1vdGVUZXh0VHJhY2tFbHNcbiAqL1xuXG5BTEwubmFtZXMuZm9yRWFjaChmdW5jdGlvbiAobmFtZSQkMSkge1xuICB2YXIgcHJvcHMgPSBBTExbbmFtZSQkMV07XG5cbiAgUGxheWVyLnByb3RvdHlwZVtwcm9wcy5nZXR0ZXJOYW1lXSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy50ZWNoXykge1xuICAgICAgcmV0dXJuIHRoaXMudGVjaF9bcHJvcHMuZ2V0dGVyTmFtZV0oKTtcbiAgICB9XG5cbiAgICAvLyBpZiB3ZSBoYXZlIG5vdCB5ZXQgbG9hZFRlY2hfLCB3ZSBjcmVhdGUge3ZpZGVvLGF1ZGlvLHRleHR9VHJhY2tzX1xuICAgIC8vIHRoZXNlIHdpbGwgYmUgcGFzc2VkIHRvIHRoZSB0ZWNoIGR1cmluZyBsb2FkaW5nXG4gICAgdGhpc1twcm9wcy5wcml2YXRlTmFtZV0gPSB0aGlzW3Byb3BzLnByaXZhdGVOYW1lXSB8fCBuZXcgcHJvcHMuTGlzdENsYXNzKCk7XG4gICAgcmV0dXJuIHRoaXNbcHJvcHMucHJpdmF0ZU5hbWVdO1xuICB9O1xufSk7XG5cbi8qKlxuICogR2xvYmFsIHBsYXllciBsaXN0XG4gKlxuICogQHR5cGUge09iamVjdH1cbiAqL1xuUGxheWVyLnBsYXllcnMgPSB7fTtcblxudmFyIG5hdmlnYXRvciA9IHdpbmRvdy5uYXZpZ2F0b3I7XG5cbi8qXG4gKiBQbGF5ZXIgaW5zdGFuY2Ugb3B0aW9ucywgc3VyZmFjZWQgdXNpbmcgb3B0aW9uc1xuICogb3B0aW9ucyA9IFBsYXllci5wcm90b3R5cGUub3B0aW9uc19cbiAqIE1ha2UgY2hhbmdlcyBpbiBvcHRpb25zLCBub3QgaGVyZS5cbiAqXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQHByaXZhdGVcbiAqL1xuUGxheWVyLnByb3RvdHlwZS5vcHRpb25zXyA9IHtcbiAgLy8gRGVmYXVsdCBvcmRlciBvZiBmYWxsYmFjayB0ZWNobm9sb2d5XG4gIHRlY2hPcmRlcjogVGVjaC5kZWZhdWx0VGVjaE9yZGVyXyxcblxuICBodG1sNToge30sXG4gIGZsYXNoOiB7fSxcblxuICAvLyBkZWZhdWx0IGluYWN0aXZpdHkgdGltZW91dFxuICBpbmFjdGl2aXR5VGltZW91dDogMjAwMCxcblxuICAvLyBkZWZhdWx0IHBsYXliYWNrIHJhdGVzXG4gIHBsYXliYWNrUmF0ZXM6IFtdLFxuICAvLyBBZGQgcGxheWJhY2sgcmF0ZSBzZWxlY3Rpb24gYnkgYWRkaW5nIHJhdGVzXG4gIC8vICdwbGF5YmFja1JhdGVzJzogWzAuNSwgMSwgMS41LCAyXSxcblxuICAvLyBJbmNsdWRlZCBjb250cm9sIHNldHNcbiAgY2hpbGRyZW46IFsnbWVkaWFMb2FkZXInLCAncG9zdGVySW1hZ2UnLCAndGV4dFRyYWNrRGlzcGxheScsICdsb2FkaW5nU3Bpbm5lcicsICdiaWdQbGF5QnV0dG9uJywgJ2NvbnRyb2xCYXInLCAnZXJyb3JEaXNwbGF5JywgJ3RleHRUcmFja1NldHRpbmdzJ10sXG5cbiAgbGFuZ3VhZ2U6IG5hdmlnYXRvciAmJiAobmF2aWdhdG9yLmxhbmd1YWdlcyAmJiBuYXZpZ2F0b3IubGFuZ3VhZ2VzWzBdIHx8IG5hdmlnYXRvci51c2VyTGFuZ3VhZ2UgfHwgbmF2aWdhdG9yLmxhbmd1YWdlKSB8fCAnZW4nLFxuXG4gIC8vIGxvY2FsZXMgYW5kIHRoZWlyIGxhbmd1YWdlIHRyYW5zbGF0aW9uc1xuICBsYW5ndWFnZXM6IHt9LFxuXG4gIC8vIERlZmF1bHQgbWVzc2FnZSB0byBzaG93IHdoZW4gYSB2aWRlbyBjYW5ub3QgYmUgcGxheWVkLlxuICBub3RTdXBwb3J0ZWRNZXNzYWdlOiAnTm8gY29tcGF0aWJsZSBzb3VyY2Ugd2FzIGZvdW5kIGZvciB0aGlzIG1lZGlhLicsXG5cbiAgYnJlYWtwb2ludHM6IHt9LFxuICByZXNwb25zaXZlOiBmYWxzZVxufTtcblxuaWYgKCFJU19JRTgpIHtcbiAgUGxheWVyLnByb3RvdHlwZS5vcHRpb25zXy5jaGlsZHJlbi5wdXNoKCdyZXNpemVNYW5hZ2VyJyk7XG59XG5cbltcbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgcGxheWVyIGlzIGluIHRoZSBcImVuZGVkXCIgc3RhdGUuXG4gKlxuICogQHJldHVybiB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgcGxheWVyIGlzIGluIHRoZSBlbmRlZCBzdGF0ZSwgZmFsc2UgaWYgbm90LlxuICogQG1ldGhvZCBQbGF5ZXIjZW5kZWRcbiAqL1xuJ2VuZGVkJyxcbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgcGxheWVyIGlzIGluIHRoZSBcInNlZWtpbmdcIiBzdGF0ZS5cbiAqXG4gKiBAcmV0dXJuIHtCb29sZWFufSBUcnVlIGlmIHRoZSBwbGF5ZXIgaXMgaW4gdGhlIHNlZWtpbmcgc3RhdGUsIGZhbHNlIGlmIG5vdC5cbiAqIEBtZXRob2QgUGxheWVyI3NlZWtpbmdcbiAqL1xuJ3NlZWtpbmcnLFxuLyoqXG4gKiBSZXR1cm5zIHRoZSBUaW1lUmFuZ2VzIG9mIHRoZSBtZWRpYSB0aGF0IGFyZSBjdXJyZW50bHkgYXZhaWxhYmxlXG4gKiBmb3Igc2Vla2luZyB0by5cbiAqXG4gKiBAcmV0dXJuIHtUaW1lUmFuZ2VzfSB0aGUgc2Vla2FibGUgaW50ZXJ2YWxzIG9mIHRoZSBtZWRpYSB0aW1lbGluZVxuICogQG1ldGhvZCBQbGF5ZXIjc2Vla2FibGVcbiAqL1xuJ3NlZWthYmxlJyxcbi8qKlxuICogUmV0dXJucyB0aGUgY3VycmVudCBzdGF0ZSBvZiBuZXR3b3JrIGFjdGl2aXR5IGZvciB0aGUgZWxlbWVudCwgZnJvbVxuICogdGhlIGNvZGVzIGluIHRoZSBsaXN0IGJlbG93LlxuICogLSBORVRXT1JLX0VNUFRZIChudW1lcmljIHZhbHVlIDApXG4gKiAgIFRoZSBlbGVtZW50IGhhcyBub3QgeWV0IGJlZW4gaW5pdGlhbGlzZWQuIEFsbCBhdHRyaWJ1dGVzIGFyZSBpblxuICogICB0aGVpciBpbml0aWFsIHN0YXRlcy5cbiAqIC0gTkVUV09SS19JRExFIChudW1lcmljIHZhbHVlIDEpXG4gKiAgIFRoZSBlbGVtZW50J3MgcmVzb3VyY2Ugc2VsZWN0aW9uIGFsZ29yaXRobSBpcyBhY3RpdmUgYW5kIGhhc1xuICogICBzZWxlY3RlZCBhIHJlc291cmNlLCBidXQgaXQgaXMgbm90IGFjdHVhbGx5IHVzaW5nIHRoZSBuZXR3b3JrIGF0XG4gKiAgIHRoaXMgdGltZS5cbiAqIC0gTkVUV09SS19MT0FESU5HIChudW1lcmljIHZhbHVlIDIpXG4gKiAgIFRoZSB1c2VyIGFnZW50IGlzIGFjdGl2ZWx5IHRyeWluZyB0byBkb3dubG9hZCBkYXRhLlxuICogLSBORVRXT1JLX05PX1NPVVJDRSAobnVtZXJpYyB2YWx1ZSAzKVxuICogICBUaGUgZWxlbWVudCdzIHJlc291cmNlIHNlbGVjdGlvbiBhbGdvcml0aG0gaXMgYWN0aXZlLCBidXQgaXQgaGFzXG4gKiAgIG5vdCB5ZXQgZm91bmQgYSByZXNvdXJjZSB0byB1c2UuXG4gKlxuICogQHNlZSBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9lbWJlZGRlZC1jb250ZW50Lmh0bWwjbmV0d29yay1zdGF0ZXNcbiAqIEByZXR1cm4ge251bWJlcn0gdGhlIGN1cnJlbnQgbmV0d29yayBhY3Rpdml0eSBzdGF0ZVxuICogQG1ldGhvZCBQbGF5ZXIjbmV0d29ya1N0YXRlXG4gKi9cbiduZXR3b3JrU3RhdGUnLFxuLyoqXG4gKiBSZXR1cm5zIGEgdmFsdWUgdGhhdCBleHByZXNzZXMgdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIGVsZW1lbnRcbiAqIHdpdGggcmVzcGVjdCB0byByZW5kZXJpbmcgdGhlIGN1cnJlbnQgcGxheWJhY2sgcG9zaXRpb24sIGZyb20gdGhlXG4gKiBjb2RlcyBpbiB0aGUgbGlzdCBiZWxvdy5cbiAqIC0gSEFWRV9OT1RISU5HIChudW1lcmljIHZhbHVlIDApXG4gKiAgIE5vIGluZm9ybWF0aW9uIHJlZ2FyZGluZyB0aGUgbWVkaWEgcmVzb3VyY2UgaXMgYXZhaWxhYmxlLlxuICogLSBIQVZFX01FVEFEQVRBIChudW1lcmljIHZhbHVlIDEpXG4gKiAgIEVub3VnaCBvZiB0aGUgcmVzb3VyY2UgaGFzIGJlZW4gb2J0YWluZWQgdGhhdCB0aGUgZHVyYXRpb24gb2YgdGhlXG4gKiAgIHJlc291cmNlIGlzIGF2YWlsYWJsZS5cbiAqIC0gSEFWRV9DVVJSRU5UX0RBVEEgKG51bWVyaWMgdmFsdWUgMilcbiAqICAgRGF0YSBmb3IgdGhlIGltbWVkaWF0ZSBjdXJyZW50IHBsYXliYWNrIHBvc2l0aW9uIGlzIGF2YWlsYWJsZS5cbiAqIC0gSEFWRV9GVVRVUkVfREFUQSAobnVtZXJpYyB2YWx1ZSAzKVxuICogICBEYXRhIGZvciB0aGUgaW1tZWRpYXRlIGN1cnJlbnQgcGxheWJhY2sgcG9zaXRpb24gaXMgYXZhaWxhYmxlLCBhc1xuICogICB3ZWxsIGFzIGVub3VnaCBkYXRhIGZvciB0aGUgdXNlciBhZ2VudCB0byBhZHZhbmNlIHRoZSBjdXJyZW50XG4gKiAgIHBsYXliYWNrIHBvc2l0aW9uIGluIHRoZSBkaXJlY3Rpb24gb2YgcGxheWJhY2suXG4gKiAtIEhBVkVfRU5PVUdIX0RBVEEgKG51bWVyaWMgdmFsdWUgNClcbiAqICAgVGhlIHVzZXIgYWdlbnQgZXN0aW1hdGVzIHRoYXQgZW5vdWdoIGRhdGEgaXMgYXZhaWxhYmxlIGZvclxuICogICBwbGF5YmFjayB0byBwcm9jZWVkIHVuaW50ZXJydXB0ZWQuXG4gKlxuICogQHNlZSBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9lbWJlZGRlZC1jb250ZW50Lmh0bWwjZG9tLW1lZGlhLXJlYWR5c3RhdGVcbiAqIEByZXR1cm4ge251bWJlcn0gdGhlIGN1cnJlbnQgcGxheWJhY2sgcmVuZGVyaW5nIHN0YXRlXG4gKiBAbWV0aG9kIFBsYXllciNyZWFkeVN0YXRlXG4gKi9cbidyZWFkeVN0YXRlJ10uZm9yRWFjaChmdW5jdGlvbiAoZm4pIHtcbiAgUGxheWVyLnByb3RvdHlwZVtmbl0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMudGVjaEdldF8oZm4pO1xuICB9O1xufSk7XG5cblRFQ0hfRVZFTlRTX1JFVFJJR0dFUi5mb3JFYWNoKGZ1bmN0aW9uIChldmVudCkge1xuICBQbGF5ZXIucHJvdG90eXBlWydoYW5kbGVUZWNoJyArIHRvVGl0bGVDYXNlKGV2ZW50KSArICdfJ10gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMudHJpZ2dlcihldmVudCk7XG4gIH07XG59KTtcblxuLyoqXG4gKiBGaXJlZCB3aGVuIHRoZSBwbGF5ZXIgaGFzIGluaXRpYWwgZHVyYXRpb24gYW5kIGRpbWVuc2lvbiBpbmZvcm1hdGlvblxuICpcbiAqIEBldmVudCBQbGF5ZXIjbG9hZGVkbWV0YWRhdGFcbiAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAqL1xuXG4vKipcbiAqIEZpcmVkIHdoZW4gdGhlIHBsYXllciBoYXMgZG93bmxvYWRlZCBkYXRhIGF0IHRoZSBjdXJyZW50IHBsYXliYWNrIHBvc2l0aW9uXG4gKlxuICogQGV2ZW50IFBsYXllciNsb2FkZWRkYXRhXG4gKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gKi9cblxuLyoqXG4gKiBGaXJlZCB3aGVuIHRoZSBjdXJyZW50IHBsYXliYWNrIHBvc2l0aW9uIGhhcyBjaGFuZ2VkICpcbiAqIER1cmluZyBwbGF5YmFjayB0aGlzIGlzIGZpcmVkIGV2ZXJ5IDE1LTI1MCBtaWxsaXNlY29uZHMsIGRlcGVuZGluZyBvbiB0aGVcbiAqIHBsYXliYWNrIHRlY2hub2xvZ3kgaW4gdXNlLlxuICpcbiAqIEBldmVudCBQbGF5ZXIjdGltZXVwZGF0ZVxuICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICovXG5cbi8qKlxuICogRmlyZWQgd2hlbiB0aGUgdm9sdW1lIGNoYW5nZXNcbiAqXG4gKiBAZXZlbnQgUGxheWVyI3ZvbHVtZWNoYW5nZVxuICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICovXG5cbi8qKlxuICogUmVwb3J0cyB3aGV0aGVyIG9yIG5vdCBhIHBsYXllciBoYXMgYSBwbHVnaW4gYXZhaWxhYmxlLlxuICpcbiAqIFRoaXMgZG9lcyBub3QgcmVwb3J0IHdoZXRoZXIgb3Igbm90IHRoZSBwbHVnaW4gaGFzIGV2ZXIgYmVlbiBpbml0aWFsaXplZFxuICogb24gdGhpcyBwbGF5ZXIuIEZvciB0aGF0LCBbdXNpbmdQbHVnaW5de0BsaW5rIFBsYXllciN1c2luZ1BsdWdpbn0uXG4gKlxuICogQG1ldGhvZCBQbGF5ZXIjaGFzUGx1Z2luXG4gKiBAcGFyYW0gIHtzdHJpbmd9ICBuYW1lXG4gKiAgICAgICAgIFRoZSBuYW1lIG9mIGEgcGx1Z2luLlxuICpcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKiAgICAgICAgIFdoZXRoZXIgb3Igbm90IHRoaXMgcGxheWVyIGhhcyB0aGUgcmVxdWVzdGVkIHBsdWdpbiBhdmFpbGFibGUuXG4gKi9cblxuLyoqXG4gKiBSZXBvcnRzIHdoZXRoZXIgb3Igbm90IGEgcGxheWVyIGlzIHVzaW5nIGEgcGx1Z2luIGJ5IG5hbWUuXG4gKlxuICogRm9yIGJhc2ljIHBsdWdpbnMsIHRoaXMgb25seSByZXBvcnRzIHdoZXRoZXIgdGhlIHBsdWdpbiBoYXMgX2V2ZXJfIGJlZW5cbiAqIGluaXRpYWxpemVkIG9uIHRoaXMgcGxheWVyLlxuICpcbiAqIEBtZXRob2QgUGxheWVyI3VzaW5nUGx1Z2luXG4gKiBAcGFyYW0gIHtzdHJpbmd9IG5hbWVcbiAqICAgICAgICAgVGhlIG5hbWUgb2YgYSBwbHVnaW4uXG4gKlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqICAgICAgICAgV2hldGhlciBvciBub3QgdGhpcyBwbGF5ZXIgaXMgdXNpbmcgdGhlIHJlcXVlc3RlZCBwbHVnaW4uXG4gKi9cblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdQbGF5ZXInLCBQbGF5ZXIpO1xuXG4vKipcbiAqIEBmaWxlIHBsdWdpbi5qc1xuICovXG4vKipcbiAqIFRoZSBiYXNlIHBsdWdpbiBuYW1lLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RhbnRcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKi9cbnZhciBCQVNFX1BMVUdJTl9OQU1FID0gJ3BsdWdpbic7XG5cbi8qKlxuICogVGhlIGtleSBvbiB3aGljaCBhIHBsYXllcidzIGFjdGl2ZSBwbHVnaW5zIGNhY2hlIGlzIHN0b3JlZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0YW50XG4gKiBAdHlwZSAgICAge3N0cmluZ31cbiAqL1xudmFyIFBMVUdJTl9DQUNIRV9LRVkgPSAnYWN0aXZlUGx1Z2luc18nO1xuXG4vKipcbiAqIFN0b3JlcyByZWdpc3RlcmVkIHBsdWdpbnMgaW4gYSBwcml2YXRlIHNwYWNlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAdHlwZSAgICB7T2JqZWN0fVxuICovXG52YXIgcGx1Z2luU3RvcmFnZSA9IHt9O1xuXG4vKipcbiAqIFJlcG9ydHMgd2hldGhlciBvciBub3QgYSBwbHVnaW4gaGFzIGJlZW4gcmVnaXN0ZXJlZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtICAge3N0cmluZ30gbmFtZVxuICogICAgICAgICAgVGhlIG5hbWUgb2YgYSBwbHVnaW4uXG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKiAgICAgICAgICBXaGV0aGVyIG9yIG5vdCB0aGUgcGx1Z2luIGhhcyBiZWVuIHJlZ2lzdGVyZWQuXG4gKi9cbnZhciBwbHVnaW5FeGlzdHMgPSBmdW5jdGlvbiBwbHVnaW5FeGlzdHMobmFtZSkge1xuICByZXR1cm4gcGx1Z2luU3RvcmFnZS5oYXNPd25Qcm9wZXJ0eShuYW1lKTtcbn07XG5cbi8qKlxuICogR2V0IGEgc2luZ2xlIHJlZ2lzdGVyZWQgcGx1Z2luIGJ5IG5hbWUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSAgIHtzdHJpbmd9IG5hbWVcbiAqICAgICAgICAgIFRoZSBuYW1lIG9mIGEgcGx1Z2luLlxuICpcbiAqIEByZXR1cm5zIHtGdW5jdGlvbnx1bmRlZmluZWR9XG4gKiAgICAgICAgICBUaGUgcGx1Z2luIChvciB1bmRlZmluZWQpLlxuICovXG52YXIgZ2V0UGx1Z2luID0gZnVuY3Rpb24gZ2V0UGx1Z2luKG5hbWUpIHtcbiAgcmV0dXJuIHBsdWdpbkV4aXN0cyhuYW1lKSA/IHBsdWdpblN0b3JhZ2VbbmFtZV0gOiB1bmRlZmluZWQ7XG59O1xuXG4vKipcbiAqIE1hcmtzIGEgcGx1Z2luIGFzIFwiYWN0aXZlXCIgb24gYSBwbGF5ZXIuXG4gKlxuICogQWxzbywgZW5zdXJlcyB0aGF0IHRoZSBwbGF5ZXIgaGFzIGFuIG9iamVjdCBmb3IgdHJhY2tpbmcgYWN0aXZlIHBsdWdpbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSAgIHtQbGF5ZXJ9IHBsYXllclxuICogICAgICAgICAgQSBWaWRlby5qcyBwbGF5ZXIgaW5zdGFuY2UuXG4gKlxuICogQHBhcmFtICAge3N0cmluZ30gbmFtZVxuICogICAgICAgICAgVGhlIG5hbWUgb2YgYSBwbHVnaW4uXG4gKi9cbnZhciBtYXJrUGx1Z2luQXNBY3RpdmUgPSBmdW5jdGlvbiBtYXJrUGx1Z2luQXNBY3RpdmUocGxheWVyLCBuYW1lKSB7XG4gIHBsYXllcltQTFVHSU5fQ0FDSEVfS0VZXSA9IHBsYXllcltQTFVHSU5fQ0FDSEVfS0VZXSB8fCB7fTtcbiAgcGxheWVyW1BMVUdJTl9DQUNIRV9LRVldW25hbWVdID0gdHJ1ZTtcbn07XG5cbi8qKlxuICogVHJpZ2dlcnMgYSBwYWlyIG9mIHBsdWdpbiBzZXR1cCBldmVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSAge1BsYXllcn0gcGxheWVyXG4gKiAgICAgICAgIEEgVmlkZW8uanMgcGxheWVyIGluc3RhbmNlLlxuICpcbiAqIEBwYXJhbSAge1BsdWdpbn5QbHVnaW5FdmVudEhhc2h9IGhhc2hcbiAqICAgICAgICAgQSBwbHVnaW4gZXZlbnQgaGFzaC5cbiAqXG4gKiBAcGFyYW0gIHtCb29sZWFufSBbYmVmb3JlXVxuICogICAgICAgICBJZiB0cnVlLCBwcmVmaXhlcyB0aGUgZXZlbnQgbmFtZSB3aXRoIFwiYmVmb3JlXCIuIEluIG90aGVyIHdvcmRzLFxuICogICAgICAgICB1c2UgdGhpcyB0byB0cmlnZ2VyIFwiYmVmb3JlcGx1Z2luc2V0dXBcIiBpbnN0ZWFkIG9mIFwicGx1Z2luc2V0dXBcIi5cbiAqL1xudmFyIHRyaWdnZXJTZXR1cEV2ZW50ID0gZnVuY3Rpb24gdHJpZ2dlclNldHVwRXZlbnQocGxheWVyLCBoYXNoLCBiZWZvcmUpIHtcbiAgdmFyIGV2ZW50TmFtZSA9IChiZWZvcmUgPyAnYmVmb3JlJyA6ICcnKSArICdwbHVnaW5zZXR1cCc7XG5cbiAgcGxheWVyLnRyaWdnZXIoZXZlbnROYW1lLCBoYXNoKTtcbiAgcGxheWVyLnRyaWdnZXIoZXZlbnROYW1lICsgJzonICsgaGFzaC5uYW1lLCBoYXNoKTtcbn07XG5cbi8qKlxuICogVGFrZXMgYSBiYXNpYyBwbHVnaW4gZnVuY3Rpb24gYW5kIHJldHVybnMgYSB3cmFwcGVyIGZ1bmN0aW9uIHdoaWNoIG1hcmtzXG4gKiBvbiB0aGUgcGxheWVyIHRoYXQgdGhlIHBsdWdpbiBoYXMgYmVlbiBhY3RpdmF0ZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSAgIHtzdHJpbmd9IG5hbWVcbiAqICAgICAgICAgIFRoZSBuYW1lIG9mIHRoZSBwbHVnaW4uXG4gKlxuICogQHBhcmFtICAge0Z1bmN0aW9ufSBwbHVnaW5cbiAqICAgICAgICAgIFRoZSBiYXNpYyBwbHVnaW4uXG4gKlxuICogQHJldHVybnMge0Z1bmN0aW9ufVxuICogICAgICAgICAgQSB3cmFwcGVyIGZ1bmN0aW9uIGZvciB0aGUgZ2l2ZW4gcGx1Z2luLlxuICovXG52YXIgY3JlYXRlQmFzaWNQbHVnaW4gPSBmdW5jdGlvbiBjcmVhdGVCYXNpY1BsdWdpbihuYW1lLCBwbHVnaW4pIHtcbiAgdmFyIGJhc2ljUGx1Z2luV3JhcHBlciA9IGZ1bmN0aW9uIGJhc2ljUGx1Z2luV3JhcHBlcigpIHtcblxuICAgIC8vIFdlIHRyaWdnZXIgdGhlIFwiYmVmb3JlcGx1Z2luc2V0dXBcIiBhbmQgXCJwbHVnaW5zZXR1cFwiIGV2ZW50cyBvbiB0aGUgcGxheWVyXG4gICAgLy8gcmVnYXJkbGVzcywgYnV0IHdlIHdhbnQgdGhlIGhhc2ggdG8gYmUgY29uc2lzdGVudCB3aXRoIHRoZSBoYXNoIHByb3ZpZGVkXG4gICAgLy8gZm9yIGFkdmFuY2VkIHBsdWdpbnMuXG4gICAgLy9cbiAgICAvLyBUaGUgb25seSBwb3RlbnRpYWxseSBjb3VudGVyLWludHVpdGl2ZSB0aGluZyBoZXJlIGlzIHRoZSBgaW5zdGFuY2VgIGluXG4gICAgLy8gdGhlIFwicGx1Z2luc2V0dXBcIiBldmVudCBpcyB0aGUgdmFsdWUgcmV0dXJuZWQgYnkgdGhlIGBwbHVnaW5gIGZ1bmN0aW9uLlxuICAgIHRyaWdnZXJTZXR1cEV2ZW50KHRoaXMsIHsgbmFtZTogbmFtZSwgcGx1Z2luOiBwbHVnaW4sIGluc3RhbmNlOiBudWxsIH0sIHRydWUpO1xuXG4gICAgdmFyIGluc3RhbmNlID0gcGx1Z2luLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICBtYXJrUGx1Z2luQXNBY3RpdmUodGhpcywgbmFtZSk7XG4gICAgdHJpZ2dlclNldHVwRXZlbnQodGhpcywgeyBuYW1lOiBuYW1lLCBwbHVnaW46IHBsdWdpbiwgaW5zdGFuY2U6IGluc3RhbmNlIH0pO1xuXG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9O1xuXG4gIE9iamVjdC5rZXlzKHBsdWdpbikuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgIGJhc2ljUGx1Z2luV3JhcHBlcltwcm9wXSA9IHBsdWdpbltwcm9wXTtcbiAgfSk7XG5cbiAgcmV0dXJuIGJhc2ljUGx1Z2luV3JhcHBlcjtcbn07XG5cbi8qKlxuICogVGFrZXMgYSBwbHVnaW4gc3ViLWNsYXNzIGFuZCByZXR1cm5zIGEgZmFjdG9yeSBmdW5jdGlvbiBmb3IgZ2VuZXJhdGluZ1xuICogaW5zdGFuY2VzIG9mIGl0LlxuICpcbiAqIFRoaXMgZmFjdG9yeSBmdW5jdGlvbiB3aWxsIHJlcGxhY2UgaXRzZWxmIHdpdGggYW4gaW5zdGFuY2Ugb2YgdGhlIHJlcXVlc3RlZFxuICogc3ViLWNsYXNzIG9mIFBsdWdpbi5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtICAge3N0cmluZ30gbmFtZVxuICogICAgICAgICAgVGhlIG5hbWUgb2YgdGhlIHBsdWdpbi5cbiAqXG4gKiBAcGFyYW0gICB7UGx1Z2lufSBQbHVnaW5TdWJDbGFzc1xuICogICAgICAgICAgVGhlIGFkdmFuY2VkIHBsdWdpbi5cbiAqXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259XG4gKi9cbnZhciBjcmVhdGVQbHVnaW5GYWN0b3J5ID0gZnVuY3Rpb24gY3JlYXRlUGx1Z2luRmFjdG9yeShuYW1lLCBQbHVnaW5TdWJDbGFzcykge1xuXG4gIC8vIEFkZCBhIGBuYW1lYCBwcm9wZXJ0eSB0byB0aGUgcGx1Z2luIHByb3RvdHlwZSBzbyB0aGF0IGVhY2ggcGx1Z2luIGNhblxuICAvLyByZWZlciB0byBpdHNlbGYgYnkgbmFtZS5cbiAgUGx1Z2luU3ViQ2xhc3MucHJvdG90eXBlLm5hbWUgPSBuYW1lO1xuXG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdHJpZ2dlclNldHVwRXZlbnQodGhpcywgeyBuYW1lOiBuYW1lLCBwbHVnaW46IFBsdWdpblN1YkNsYXNzLCBpbnN0YW5jZTogbnVsbCB9LCB0cnVlKTtcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHZhciBpbnN0YW5jZSA9IG5ldyAoRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQuYXBwbHkoUGx1Z2luU3ViQ2xhc3MsIFtudWxsXS5jb25jYXQoW3RoaXNdLmNvbmNhdChhcmdzKSkpKSgpO1xuXG4gICAgLy8gVGhlIHBsdWdpbiBpcyByZXBsYWNlZCBieSBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgY3VycmVudCBpbnN0YW5jZS5cbiAgICB0aGlzW25hbWVdID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgIH07XG5cbiAgICB0cmlnZ2VyU2V0dXBFdmVudCh0aGlzLCBpbnN0YW5jZS5nZXRFdmVudEhhc2goKSk7XG5cbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH07XG59O1xuXG4vKipcbiAqIFBhcmVudCBjbGFzcyBmb3IgYWxsIGFkdmFuY2VkIHBsdWdpbnMuXG4gKlxuICogQG1peGVzICAgbW9kdWxlOmV2ZW50ZWR+RXZlbnRlZE1peGluXG4gKiBAbWl4ZXMgICBtb2R1bGU6c3RhdGVmdWx+U3RhdGVmdWxNaXhpblxuICogQGZpcmVzICAgUGxheWVyI2JlZm9yZXBsdWdpbnNldHVwXG4gKiBAZmlyZXMgICBQbGF5ZXIjYmVmb3JlcGx1Z2luc2V0dXA6JG5hbWVcbiAqIEBmaXJlcyAgIFBsYXllciNwbHVnaW5zZXR1cFxuICogQGZpcmVzICAgUGxheWVyI3BsdWdpbnNldHVwOiRuYW1lXG4gKiBAbGlzdGVucyBQbGF5ZXIjZGlzcG9zZVxuICogQHRocm93cyAge0Vycm9yfVxuICogICAgICAgICAgSWYgYXR0ZW1wdGluZyB0byBpbnN0YW50aWF0ZSB0aGUgYmFzZSB7QGxpbmsgUGx1Z2lufSBjbGFzc1xuICogICAgICAgICAgZGlyZWN0bHkgaW5zdGVhZCBvZiB2aWEgYSBzdWItY2xhc3MuXG4gKi9cblxudmFyIFBsdWdpbiA9IGZ1bmN0aW9uICgpIHtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxuICAgKlxuICAgKiBTdWItY2xhc3NlcyBzaG91bGQgY2FsbCBgc3VwZXJgIHRvIGVuc3VyZSBwbHVnaW5zIGFyZSBwcm9wZXJseSBpbml0aWFsaXplZC5cbiAgICpcbiAgICogQHBhcmFtIHtQbGF5ZXJ9IHBsYXllclxuICAgKiAgICAgICAgQSBWaWRlby5qcyBwbGF5ZXIgaW5zdGFuY2UuXG4gICAqL1xuICBmdW5jdGlvbiBQbHVnaW4ocGxheWVyKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgUGx1Z2luKTtcblxuICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yID09PSBQbHVnaW4pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUGx1Z2luIG11c3QgYmUgc3ViLWNsYXNzZWQ7IG5vdCBkaXJlY3RseSBpbnN0YW50aWF0ZWQuJyk7XG4gICAgfVxuXG4gICAgdGhpcy5wbGF5ZXIgPSBwbGF5ZXI7XG5cbiAgICAvLyBNYWtlIHRoaXMgb2JqZWN0IGV2ZW50ZWQsIGJ1dCByZW1vdmUgdGhlIGFkZGVkIGB0cmlnZ2VyYCBtZXRob2Qgc28gd2VcbiAgICAvLyB1c2UgdGhlIHByb3RvdHlwZSB2ZXJzaW9uIGluc3RlYWQuXG4gICAgZXZlbnRlZCh0aGlzKTtcbiAgICBkZWxldGUgdGhpcy50cmlnZ2VyO1xuXG4gICAgc3RhdGVmdWwodGhpcywgdGhpcy5jb25zdHJ1Y3Rvci5kZWZhdWx0U3RhdGUpO1xuICAgIG1hcmtQbHVnaW5Bc0FjdGl2ZShwbGF5ZXIsIHRoaXMubmFtZSk7XG5cbiAgICAvLyBBdXRvLWJpbmQgdGhlIGRpc3Bvc2UgbWV0aG9kIHNvIHdlIGNhbiB1c2UgaXQgYXMgYSBsaXN0ZW5lciBhbmQgdW5iaW5kXG4gICAgLy8gaXQgbGF0ZXIgZWFzaWx5LlxuICAgIHRoaXMuZGlzcG9zZSA9IGJpbmQodGhpcywgdGhpcy5kaXNwb3NlKTtcblxuICAgIC8vIElmIHRoZSBwbGF5ZXIgaXMgZGlzcG9zZWQsIGRpc3Bvc2UgdGhlIHBsdWdpbi5cbiAgICBwbGF5ZXIub24oJ2Rpc3Bvc2UnLCB0aGlzLmRpc3Bvc2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdmVyc2lvbiBvZiB0aGUgcGx1Z2luIHRoYXQgd2FzIHNldCBvbiA8cGx1Z2luTmFtZT4uVkVSU0lPTlxuICAgKi9cblxuXG4gIFBsdWdpbi5wcm90b3R5cGUudmVyc2lvbiA9IGZ1bmN0aW9uIHZlcnNpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IuVkVSU0lPTjtcbiAgfTtcblxuICAvKipcbiAgICogRWFjaCBldmVudCB0cmlnZ2VyZWQgYnkgcGx1Z2lucyBpbmNsdWRlcyBhIGhhc2ggb2YgYWRkaXRpb25hbCBkYXRhIHdpdGhcbiAgICogY29udmVudGlvbmFsIHByb3BlcnRpZXMuXG4gICAqXG4gICAqIFRoaXMgcmV0dXJucyB0aGF0IG9iamVjdCBvciBtdXRhdGVzIGFuIGV4aXN0aW5nIGhhc2guXG4gICAqXG4gICAqIEBwYXJhbSAgIHtPYmplY3R9IFtoYXNoPXt9XVxuICAgKiAgICAgICAgICBBbiBvYmplY3QgdG8gYmUgdXNlZCBhcyBldmVudCBhbiBldmVudCBoYXNoLlxuICAgKlxuICAgKiBAcmV0dXJucyB7UGx1Z2luflBsdWdpbkV2ZW50SGFzaH1cbiAgICogICAgICAgICAgQW4gZXZlbnQgaGFzaCBvYmplY3Qgd2l0aCBwcm92aWRlZCBwcm9wZXJ0aWVzIG1peGVkLWluLlxuICAgKi9cblxuXG4gIFBsdWdpbi5wcm90b3R5cGUuZ2V0RXZlbnRIYXNoID0gZnVuY3Rpb24gZ2V0RXZlbnRIYXNoKCkge1xuICAgIHZhciBoYXNoID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICAgIGhhc2gubmFtZSA9IHRoaXMubmFtZTtcbiAgICBoYXNoLnBsdWdpbiA9IHRoaXMuY29uc3RydWN0b3I7XG4gICAgaGFzaC5pbnN0YW5jZSA9IHRoaXM7XG4gICAgcmV0dXJuIGhhc2g7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRyaWdnZXJzIGFuIGV2ZW50IG9uIHRoZSBwbHVnaW4gb2JqZWN0IGFuZCBvdmVycmlkZXNcbiAgICoge0BsaW5rIG1vZHVsZTpldmVudGVkfkV2ZW50ZWRNaXhpbi50cmlnZ2VyfEV2ZW50ZWRNaXhpbi50cmlnZ2VyfS5cbiAgICpcbiAgICogQHBhcmFtICAge3N0cmluZ3xPYmplY3R9IGV2ZW50XG4gICAqICAgICAgICAgIEFuIGV2ZW50IHR5cGUgb3IgYW4gb2JqZWN0IHdpdGggYSB0eXBlIHByb3BlcnR5LlxuICAgKlxuICAgKiBAcGFyYW0gICB7T2JqZWN0fSBbaGFzaD17fV1cbiAgICogICAgICAgICAgQWRkaXRpb25hbCBkYXRhIGhhc2ggdG8gbWVyZ2Ugd2l0aCBhXG4gICAqICAgICAgICAgIHtAbGluayBQbHVnaW5+UGx1Z2luRXZlbnRIYXNofFBsdWdpbkV2ZW50SGFzaH0uXG4gICAqXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKiAgICAgICAgICBXaGV0aGVyIG9yIG5vdCBkZWZhdWx0IHdhcyBwcmV2ZW50ZWQuXG4gICAqL1xuXG5cbiAgUGx1Z2luLnByb3RvdHlwZS50cmlnZ2VyID0gZnVuY3Rpb24gdHJpZ2dlciQkMShldmVudCkge1xuICAgIHZhciBoYXNoID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICAgIHJldHVybiB0cmlnZ2VyKHRoaXMuZXZlbnRCdXNFbF8sIGV2ZW50LCB0aGlzLmdldEV2ZW50SGFzaChoYXNoKSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgXCJzdGF0ZWNoYW5nZWRcIiBldmVudHMgb24gdGhlIHBsdWdpbi4gTm8tb3AgYnkgZGVmYXVsdCwgb3ZlcnJpZGUgYnlcbiAgICogc3ViY2xhc3NpbmcuXG4gICAqXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAcGFyYW0gICAge0V2ZW50fSBlXG4gICAqICAgICAgICAgICBBbiBldmVudCBvYmplY3QgcHJvdmlkZWQgYnkgYSBcInN0YXRlY2hhbmdlZFwiIGV2ZW50LlxuICAgKlxuICAgKiBAcGFyYW0gICAge09iamVjdH0gZS5jaGFuZ2VzXG4gICAqICAgICAgICAgICBBbiBvYmplY3QgZGVzY3JpYmluZyBjaGFuZ2VzIHRoYXQgb2NjdXJyZWQgd2l0aCB0aGUgXCJzdGF0ZWNoYW5nZWRcIlxuICAgKiAgICAgICAgICAgZXZlbnQuXG4gICAqL1xuXG5cbiAgUGx1Z2luLnByb3RvdHlwZS5oYW5kbGVTdGF0ZUNoYW5nZWQgPSBmdW5jdGlvbiBoYW5kbGVTdGF0ZUNoYW5nZWQoZSkge307XG5cbiAgLyoqXG4gICAqIERpc3Bvc2VzIGEgcGx1Z2luLlxuICAgKlxuICAgKiBTdWJjbGFzc2VzIGNhbiBvdmVycmlkZSB0aGlzIGlmIHRoZXkgd2FudCwgYnV0IGZvciB0aGUgc2FrZSBvZiBzYWZldHksXG4gICAqIGl0J3MgcHJvYmFibHkgYmVzdCB0byBzdWJzY3JpYmUgdGhlIFwiZGlzcG9zZVwiIGV2ZW50LlxuICAgKlxuICAgKiBAZmlyZXMgUGx1Z2luI2Rpc3Bvc2VcbiAgICovXG5cblxuICBQbHVnaW4ucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiBkaXNwb3NlKCkge1xuICAgIHZhciBuYW1lID0gdGhpcy5uYW1lLFxuICAgICAgICBwbGF5ZXIgPSB0aGlzLnBsYXllcjtcblxuICAgIC8qKlxuICAgICAqIFNpZ25hbHMgdGhhdCBhIGFkdmFuY2VkIHBsdWdpbiBpcyBhYm91dCB0byBiZSBkaXNwb3NlZC5cbiAgICAgKlxuICAgICAqIEBldmVudCBQbHVnaW4jZGlzcG9zZVxuICAgICAqIEB0eXBlICB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gICAgICovXG5cbiAgICB0aGlzLnRyaWdnZXIoJ2Rpc3Bvc2UnKTtcbiAgICB0aGlzLm9mZigpO1xuICAgIHBsYXllci5vZmYoJ2Rpc3Bvc2UnLCB0aGlzLmRpc3Bvc2UpO1xuXG4gICAgLy8gRWxpbWluYXRlIGFueSBwb3NzaWJsZSBzb3VyY2VzIG9mIGxlYWtpbmcgbWVtb3J5IGJ5IGNsZWFyaW5nIHVwXG4gICAgLy8gcmVmZXJlbmNlcyBiZXR3ZWVuIHRoZSBwbGF5ZXIgYW5kIHRoZSBwbHVnaW4gaW5zdGFuY2UgYW5kIG51bGxpbmcgb3V0XG4gICAgLy8gdGhlIHBsdWdpbidzIHN0YXRlIGFuZCByZXBsYWNpbmcgbWV0aG9kcyB3aXRoIGEgZnVuY3Rpb24gdGhhdCB0aHJvd3MuXG4gICAgcGxheWVyW1BMVUdJTl9DQUNIRV9LRVldW25hbWVdID0gZmFsc2U7XG4gICAgdGhpcy5wbGF5ZXIgPSB0aGlzLnN0YXRlID0gbnVsbDtcblxuICAgIC8vIEZpbmFsbHksIHJlcGxhY2UgdGhlIHBsdWdpbiBuYW1lIG9uIHRoZSBwbGF5ZXIgd2l0aCBhIG5ldyBmYWN0b3J5XG4gICAgLy8gZnVuY3Rpb24sIHNvIHRoYXQgdGhlIHBsdWdpbiBpcyByZWFkeSB0byBiZSBzZXQgdXAgYWdhaW4uXG4gICAgcGxheWVyW25hbWVdID0gY3JlYXRlUGx1Z2luRmFjdG9yeShuYW1lLCBwbHVnaW5TdG9yYWdlW25hbWVdKTtcbiAgfTtcblxuICAvKipcbiAgICogRGV0ZXJtaW5lcyBpZiBhIHBsdWdpbiBpcyBhIGJhc2ljIHBsdWdpbiAoaS5lLiBub3QgYSBzdWItY2xhc3Mgb2YgYFBsdWdpbmApLlxuICAgKlxuICAgKiBAcGFyYW0gICB7c3RyaW5nfEZ1bmN0aW9ufSBwbHVnaW5cbiAgICogICAgICAgICAgSWYgYSBzdHJpbmcsIG1hdGNoZXMgdGhlIG5hbWUgb2YgYSBwbHVnaW4uIElmIGEgZnVuY3Rpb24sIHdpbGwgYmVcbiAgICogICAgICAgICAgdGVzdGVkIGRpcmVjdGx5LlxuICAgKlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICogICAgICAgICAgV2hldGhlciBvciBub3QgYSBwbHVnaW4gaXMgYSBiYXNpYyBwbHVnaW4uXG4gICAqL1xuXG5cbiAgUGx1Z2luLmlzQmFzaWMgPSBmdW5jdGlvbiBpc0Jhc2ljKHBsdWdpbikge1xuICAgIHZhciBwID0gdHlwZW9mIHBsdWdpbiA9PT0gJ3N0cmluZycgPyBnZXRQbHVnaW4ocGx1Z2luKSA6IHBsdWdpbjtcblxuICAgIHJldHVybiB0eXBlb2YgcCA9PT0gJ2Z1bmN0aW9uJyAmJiAhUGx1Z2luLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKHAucHJvdG90eXBlKTtcbiAgfTtcblxuICAvKipcbiAgICogUmVnaXN0ZXIgYSBWaWRlby5qcyBwbHVnaW4uXG4gICAqXG4gICAqIEBwYXJhbSAgIHtzdHJpbmd9IG5hbWVcbiAgICogICAgICAgICAgVGhlIG5hbWUgb2YgdGhlIHBsdWdpbiB0byBiZSByZWdpc3RlcmVkLiBNdXN0IGJlIGEgc3RyaW5nIGFuZFxuICAgKiAgICAgICAgICBtdXN0IG5vdCBtYXRjaCBhbiBleGlzdGluZyBwbHVnaW4gb3IgYSBtZXRob2Qgb24gdGhlIGBQbGF5ZXJgXG4gICAqICAgICAgICAgIHByb3RvdHlwZS5cbiAgICpcbiAgICogQHBhcmFtICAge0Z1bmN0aW9ufSBwbHVnaW5cbiAgICogICAgICAgICAgQSBzdWItY2xhc3Mgb2YgYFBsdWdpbmAgb3IgYSBmdW5jdGlvbiBmb3IgYmFzaWMgcGx1Z2lucy5cbiAgICpcbiAgICogQHJldHVybnMge0Z1bmN0aW9ufVxuICAgKiAgICAgICAgICBGb3IgYWR2YW5jZWQgcGx1Z2lucywgYSBmYWN0b3J5IGZ1bmN0aW9uIGZvciB0aGF0IHBsdWdpbi4gRm9yXG4gICAqICAgICAgICAgIGJhc2ljIHBsdWdpbnMsIGEgd3JhcHBlciBmdW5jdGlvbiB0aGF0IGluaXRpYWxpemVzIHRoZSBwbHVnaW4uXG4gICAqL1xuXG5cbiAgUGx1Z2luLnJlZ2lzdGVyUGx1Z2luID0gZnVuY3Rpb24gcmVnaXN0ZXJQbHVnaW4obmFtZSwgcGx1Z2luKSB7XG4gICAgaWYgKHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbGxlZ2FsIHBsdWdpbiBuYW1lLCBcIicgKyBuYW1lICsgJ1wiLCBtdXN0IGJlIGEgc3RyaW5nLCB3YXMgJyArICh0eXBlb2YgbmFtZSA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YobmFtZSkpICsgJy4nKTtcbiAgICB9XG5cbiAgICBpZiAocGx1Z2luRXhpc3RzKG5hbWUpKSB7XG4gICAgICBsb2cud2FybignQSBwbHVnaW4gbmFtZWQgXCInICsgbmFtZSArICdcIiBhbHJlYWR5IGV4aXN0cy4gWW91IG1heSB3YW50IHRvIGF2b2lkIHJlLXJlZ2lzdGVyaW5nIHBsdWdpbnMhJyk7XG4gICAgfSBlbHNlIGlmIChQbGF5ZXIucHJvdG90eXBlLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lsbGVnYWwgcGx1Z2luIG5hbWUsIFwiJyArIG5hbWUgKyAnXCIsIGNhbm5vdCBzaGFyZSBhIG5hbWUgd2l0aCBhbiBleGlzdGluZyBwbGF5ZXIgbWV0aG9kIScpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgcGx1Z2luICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lsbGVnYWwgcGx1Z2luIGZvciBcIicgKyBuYW1lICsgJ1wiLCBtdXN0IGJlIGEgZnVuY3Rpb24sIHdhcyAnICsgKHR5cGVvZiBwbHVnaW4gPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHBsdWdpbikpICsgJy4nKTtcbiAgICB9XG5cbiAgICBwbHVnaW5TdG9yYWdlW25hbWVdID0gcGx1Z2luO1xuXG4gICAgLy8gQWRkIGEgcGxheWVyIHByb3RvdHlwZSBtZXRob2QgZm9yIGFsbCBzdWItY2xhc3NlZCBwbHVnaW5zIChidXQgbm90IGZvclxuICAgIC8vIHRoZSBiYXNlIFBsdWdpbiBjbGFzcykuXG4gICAgaWYgKG5hbWUgIT09IEJBU0VfUExVR0lOX05BTUUpIHtcbiAgICAgIGlmIChQbHVnaW4uaXNCYXNpYyhwbHVnaW4pKSB7XG4gICAgICAgIFBsYXllci5wcm90b3R5cGVbbmFtZV0gPSBjcmVhdGVCYXNpY1BsdWdpbihuYW1lLCBwbHVnaW4pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgUGxheWVyLnByb3RvdHlwZVtuYW1lXSA9IGNyZWF0ZVBsdWdpbkZhY3RvcnkobmFtZSwgcGx1Z2luKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcGx1Z2luO1xuICB9O1xuXG4gIC8qKlxuICAgKiBEZS1yZWdpc3RlciBhIFZpZGVvLmpzIHBsdWdpbi5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICogICAgICAgIFRoZSBuYW1lIG9mIHRoZSBwbHVnaW4gdG8gYmUgZGVyZWdpc3RlcmVkLlxuICAgKi9cblxuXG4gIFBsdWdpbi5kZXJlZ2lzdGVyUGx1Z2luID0gZnVuY3Rpb24gZGVyZWdpc3RlclBsdWdpbihuYW1lKSB7XG4gICAgaWYgKG5hbWUgPT09IEJBU0VfUExVR0lOX05BTUUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGRlLXJlZ2lzdGVyIGJhc2UgcGx1Z2luLicpO1xuICAgIH1cbiAgICBpZiAocGx1Z2luRXhpc3RzKG5hbWUpKSB7XG4gICAgICBkZWxldGUgcGx1Z2luU3RvcmFnZVtuYW1lXTtcbiAgICAgIGRlbGV0ZSBQbGF5ZXIucHJvdG90eXBlW25hbWVdO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogR2V0cyBhbiBvYmplY3QgY29udGFpbmluZyBtdWx0aXBsZSBWaWRlby5qcyBwbHVnaW5zLlxuICAgKlxuICAgKiBAcGFyYW0gICB7QXJyYXl9IFtuYW1lc11cbiAgICogICAgICAgICAgSWYgcHJvdmlkZWQsIHNob3VsZCBiZSBhbiBhcnJheSBvZiBwbHVnaW4gbmFtZXMuIERlZmF1bHRzIHRvIF9hbGxfXG4gICAqICAgICAgICAgIHBsdWdpbiBuYW1lcy5cbiAgICpcbiAgICogQHJldHVybnMge09iamVjdHx1bmRlZmluZWR9XG4gICAqICAgICAgICAgIEFuIG9iamVjdCBjb250YWluaW5nIHBsdWdpbihzKSBhc3NvY2lhdGVkIHdpdGggdGhlaXIgbmFtZShzKSBvclxuICAgKiAgICAgICAgICBgdW5kZWZpbmVkYCBpZiBubyBtYXRjaGluZyBwbHVnaW5zIGV4aXN0KS5cbiAgICovXG5cblxuICBQbHVnaW4uZ2V0UGx1Z2lucyA9IGZ1bmN0aW9uIGdldFBsdWdpbnMoKSB7XG4gICAgdmFyIG5hbWVzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBPYmplY3Qua2V5cyhwbHVnaW5TdG9yYWdlKTtcblxuICAgIHZhciByZXN1bHQgPSB2b2lkIDA7XG5cbiAgICBuYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICB2YXIgcGx1Z2luID0gZ2V0UGx1Z2luKG5hbWUpO1xuXG4gICAgICBpZiAocGx1Z2luKSB7XG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdCB8fCB7fTtcbiAgICAgICAgcmVzdWx0W25hbWVdID0gcGx1Z2luO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvKipcbiAgICogR2V0cyBhIHBsdWdpbidzIHZlcnNpb24sIGlmIGF2YWlsYWJsZVxuICAgKlxuICAgKiBAcGFyYW0gICB7c3RyaW5nfSBuYW1lXG4gICAqICAgICAgICAgIFRoZSBuYW1lIG9mIGEgcGx1Z2luLlxuICAgKlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKiAgICAgICAgICBUaGUgcGx1Z2luJ3MgdmVyc2lvbiBvciBhbiBlbXB0eSBzdHJpbmcuXG4gICAqL1xuXG5cbiAgUGx1Z2luLmdldFBsdWdpblZlcnNpb24gPSBmdW5jdGlvbiBnZXRQbHVnaW5WZXJzaW9uKG5hbWUpIHtcbiAgICB2YXIgcGx1Z2luID0gZ2V0UGx1Z2luKG5hbWUpO1xuXG4gICAgcmV0dXJuIHBsdWdpbiAmJiBwbHVnaW4uVkVSU0lPTiB8fCAnJztcbiAgfTtcblxuICByZXR1cm4gUGx1Z2luO1xufSgpO1xuXG4vKipcbiAqIEdldHMgYSBwbHVnaW4gYnkgbmFtZSBpZiBpdCBleGlzdHMuXG4gKlxuICogQHN0YXRpY1xuICogQG1ldGhvZCAgIGdldFBsdWdpblxuICogQG1lbWJlck9mIFBsdWdpblxuICogQHBhcmFtICAgIHtzdHJpbmd9IG5hbWVcbiAqICAgICAgICAgICBUaGUgbmFtZSBvZiBhIHBsdWdpbi5cbiAqXG4gKiBAcmV0dXJucyAge0Z1bmN0aW9ufHVuZGVmaW5lZH1cbiAqICAgICAgICAgICBUaGUgcGx1Z2luIChvciBgdW5kZWZpbmVkYCkuXG4gKi9cblxuXG5QbHVnaW4uZ2V0UGx1Z2luID0gZ2V0UGx1Z2luO1xuXG4vKipcbiAqIFRoZSBuYW1lIG9mIHRoZSBiYXNlIHBsdWdpbiBjbGFzcyBhcyBpdCBpcyByZWdpc3RlcmVkLlxuICpcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKi9cblBsdWdpbi5CQVNFX1BMVUdJTl9OQU1FID0gQkFTRV9QTFVHSU5fTkFNRTtcblxuUGx1Z2luLnJlZ2lzdGVyUGx1Z2luKEJBU0VfUExVR0lOX05BTUUsIFBsdWdpbik7XG5cbi8qKlxuICogRG9jdW1lbnRlZCBpbiBwbGF5ZXIuanNcbiAqXG4gKiBAaWdub3JlXG4gKi9cblBsYXllci5wcm90b3R5cGUudXNpbmdQbHVnaW4gPSBmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4gISF0aGlzW1BMVUdJTl9DQUNIRV9LRVldICYmIHRoaXNbUExVR0lOX0NBQ0hFX0tFWV1bbmFtZV0gPT09IHRydWU7XG59O1xuXG4vKipcbiAqIERvY3VtZW50ZWQgaW4gcGxheWVyLmpzXG4gKlxuICogQGlnbm9yZVxuICovXG5QbGF5ZXIucHJvdG90eXBlLmhhc1BsdWdpbiA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiAhIXBsdWdpbkV4aXN0cyhuYW1lKTtcbn07XG5cbi8qKlxuICogU2lnbmFscyB0aGF0IGEgcGx1Z2luIGlzIGFib3V0IHRvIGJlIHNldCB1cCBvbiBhIHBsYXllci5cbiAqXG4gKiBAZXZlbnQgICAgUGxheWVyI2JlZm9yZXBsdWdpbnNldHVwXG4gKiBAdHlwZSAgICAge1BsdWdpbn5QbHVnaW5FdmVudEhhc2h9XG4gKi9cblxuLyoqXG4gKiBTaWduYWxzIHRoYXQgYSBwbHVnaW4gaXMgYWJvdXQgdG8gYmUgc2V0IHVwIG9uIGEgcGxheWVyIC0gYnkgbmFtZS4gVGhlIG5hbWVcbiAqIGlzIHRoZSBuYW1lIG9mIHRoZSBwbHVnaW4uXG4gKlxuICogQGV2ZW50ICAgIFBsYXllciNiZWZvcmVwbHVnaW5zZXR1cDokbmFtZVxuICogQHR5cGUgICAgIHtQbHVnaW5+UGx1Z2luRXZlbnRIYXNofVxuICovXG5cbi8qKlxuICogU2lnbmFscyB0aGF0IGEgcGx1Z2luIGhhcyBqdXN0IGJlZW4gc2V0IHVwIG9uIGEgcGxheWVyLlxuICpcbiAqIEBldmVudCAgICBQbGF5ZXIjcGx1Z2luc2V0dXBcbiAqIEB0eXBlICAgICB7UGx1Z2luflBsdWdpbkV2ZW50SGFzaH1cbiAqL1xuXG4vKipcbiAqIFNpZ25hbHMgdGhhdCBhIHBsdWdpbiBoYXMganVzdCBiZWVuIHNldCB1cCBvbiBhIHBsYXllciAtIGJ5IG5hbWUuIFRoZSBuYW1lXG4gKiBpcyB0aGUgbmFtZSBvZiB0aGUgcGx1Z2luLlxuICpcbiAqIEBldmVudCAgICBQbGF5ZXIjcGx1Z2luc2V0dXA6JG5hbWVcbiAqIEB0eXBlICAgICB7UGx1Z2luflBsdWdpbkV2ZW50SGFzaH1cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmICB7T2JqZWN0fSBQbHVnaW5+UGx1Z2luRXZlbnRIYXNoXG4gKlxuICogQHByb3BlcnR5IHtzdHJpbmd9IGluc3RhbmNlXG4gKiAgICAgICAgICAgRm9yIGJhc2ljIHBsdWdpbnMsIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIHBsdWdpbiBmdW5jdGlvbi4gRm9yXG4gKiAgICAgICAgICAgYWR2YW5jZWQgcGx1Z2lucywgdGhlIHBsdWdpbiBpbnN0YW5jZSBvbiB3aGljaCB0aGUgZXZlbnQgaXMgZmlyZWQuXG4gKlxuICogQHByb3BlcnR5IHtzdHJpbmd9IG5hbWVcbiAqICAgICAgICAgICBUaGUgbmFtZSBvZiB0aGUgcGx1Z2luLlxuICpcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBwbHVnaW5cbiAqICAgICAgICAgICBGb3IgYmFzaWMgcGx1Z2lucywgdGhlIHBsdWdpbiBmdW5jdGlvbi4gRm9yIGFkdmFuY2VkIHBsdWdpbnMsIHRoZVxuICogICAgICAgICAgIHBsdWdpbiBjbGFzcy9jb25zdHJ1Y3Rvci5cbiAqL1xuXG4vKipcbiAqIEBmaWxlIGV4dGVuZC5qc1xuICogQG1vZHVsZSBleHRlbmRcbiAqL1xuXG4vKipcbiAqIEEgY29tYmluYXRpb24gb2Ygbm9kZSBpbmhlcml0cyBhbmQgYmFiZWwncyBpbmhlcml0cyAoYWZ0ZXIgdHJhbnNwaWxlKS5cbiAqIEJvdGggd29yayB0aGUgc2FtZSBidXQgbm9kZSBhZGRzIGBzdXBlcl9gIHRvIHRoZSBzdWJDbGFzc1xuICogYW5kIEJhYmxlIGFkZHMgdGhlIHN1cGVyQ2xhc3MgYXMgX19wcm90b19fLiBCb3RoIHNlZW0gdXNlZnVsLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdWJDbGFzc1xuICogICAgICAgIFRoZSBjbGFzcyB0byBpbmhlcml0IHRvXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHN1cGVyQ2xhc3NcbiAqICAgICAgICBUaGUgY2xhc3MgdG8gaW5oZXJpdCBmcm9tXG4gKlxuICogQHByaXZhdGVcbiAqL1xudmFyIF9pbmhlcml0cyA9IGZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09ICdmdW5jdGlvbicgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1N1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgJyArICh0eXBlb2Ygc3VwZXJDbGFzcyA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2Yoc3VwZXJDbGFzcykpKTtcbiAgfVxuXG4gIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICB2YWx1ZTogc3ViQ2xhc3MsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfVxuICB9KTtcblxuICBpZiAoc3VwZXJDbGFzcykge1xuICAgIC8vIG5vZGVcbiAgICBzdWJDbGFzcy5zdXBlcl8gPSBzdXBlckNsYXNzO1xuICB9XG59O1xuXG4vKipcbiAqIEZ1bmN0aW9uIGZvciBzdWJjbGFzc2luZyB1c2luZyB0aGUgc2FtZSBpbmhlcml0YW5jZSB0aGF0XG4gKiB2aWRlb2pzIHVzZXMgaW50ZXJuYWxseVxuICpcbiAqIEBzdGF0aWNcbiAqIEBjb25zdFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdXBlckNsYXNzXG4gKiAgICAgICAgVGhlIGNsYXNzIHRvIGluaGVyaXQgZnJvbVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3ViQ2xhc3NNZXRob2RzPXt9XVxuICogICAgICAgIFRoZSBjbGFzcyB0byBpbmhlcml0IHRvXG4gKlxuICogQHJldHVybiB7T2JqZWN0fVxuICogICAgICAgICBUaGUgbmV3IG9iamVjdCB3aXRoIHN1YkNsYXNzTWV0aG9kcyB0aGF0IGluaGVyaXRlZCBzdXBlckNsYXNzLlxuICovXG52YXIgZXh0ZW5kRm4gPSBmdW5jdGlvbiBleHRlbmRGbihzdXBlckNsYXNzKSB7XG4gIHZhciBzdWJDbGFzc01ldGhvZHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gIHZhciBzdWJDbGFzcyA9IGZ1bmN0aW9uIHN1YkNsYXNzKCkge1xuICAgIHN1cGVyQ2xhc3MuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcblxuICB2YXIgbWV0aG9kcyA9IHt9O1xuXG4gIGlmICgodHlwZW9mIHN1YkNsYXNzTWV0aG9kcyA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2Yoc3ViQ2xhc3NNZXRob2RzKSkgPT09ICdvYmplY3QnKSB7XG4gICAgaWYgKHN1YkNsYXNzTWV0aG9kcy5jb25zdHJ1Y3RvciAhPT0gT2JqZWN0LnByb3RvdHlwZS5jb25zdHJ1Y3Rvcikge1xuICAgICAgc3ViQ2xhc3MgPSBzdWJDbGFzc01ldGhvZHMuY29uc3RydWN0b3I7XG4gICAgfVxuICAgIG1ldGhvZHMgPSBzdWJDbGFzc01ldGhvZHM7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHN1YkNsYXNzTWV0aG9kcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHN1YkNsYXNzID0gc3ViQ2xhc3NNZXRob2RzO1xuICB9XG5cbiAgX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKTtcblxuICAvLyBFeHRlbmQgc3ViT2JqJ3MgcHJvdG90eXBlIHdpdGggZnVuY3Rpb25zIGFuZCBvdGhlciBwcm9wZXJ0aWVzIGZyb20gcHJvcHNcbiAgZm9yICh2YXIgbmFtZSBpbiBtZXRob2RzKSB7XG4gICAgaWYgKG1ldGhvZHMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgIHN1YkNsYXNzLnByb3RvdHlwZVtuYW1lXSA9IG1ldGhvZHNbbmFtZV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN1YkNsYXNzO1xufTtcblxuLyoqXG4gKiBAZmlsZSB2aWRlby5qc1xuICogQG1vZHVsZSB2aWRlb2pzXG4gKi9cbi8vIEluY2x1ZGUgdGhlIGJ1aWx0LWluIHRlY2hzXG4vLyBIVE1MNSBFbGVtZW50IFNoaW0gZm9yIElFOFxuaWYgKHR5cGVvZiBIVE1MVmlkZW9FbGVtZW50ID09PSAndW5kZWZpbmVkJyAmJiBpc1JlYWwoKSkge1xuICBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd2aWRlbycpO1xuICBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhdWRpbycpO1xuICBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0cmFjaycpO1xuICBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd2aWRlby1qcycpO1xufVxuXG4vKipcbiAqIE5vcm1hbGl6ZSBhbiBgaWRgIHZhbHVlIGJ5IHRyaW1taW5nIG9mZiBhIGxlYWRpbmcgYCNgXG4gKlxuICogQHBhcmFtICAge3N0cmluZ30gaWRcbiAqICAgICAgICAgIEEgc3RyaW5nLCBtYXliZSB3aXRoIGEgbGVhZGluZyBgI2AuXG4gKlxuICogQHJldHVybnMge3N0cmluZ31cbiAqICAgICAgICAgIFRoZSBzdHJpbmcsIHdpdGhvdXQgYW55IGxlYWRpbmcgYCNgLlxuICovXG52YXIgbm9ybWFsaXplSWQgPSBmdW5jdGlvbiBub3JtYWxpemVJZChpZCkge1xuICByZXR1cm4gaWQuaW5kZXhPZignIycpID09PSAwID8gaWQuc2xpY2UoMSkgOiBpZDtcbn07XG5cbi8qKlxuICogRG91YmxlcyBhcyB0aGUgbWFpbiBmdW5jdGlvbiBmb3IgdXNlcnMgdG8gY3JlYXRlIGEgcGxheWVyIGluc3RhbmNlIGFuZCBhbHNvXG4gKiB0aGUgbWFpbiBsaWJyYXJ5IG9iamVjdC5cbiAqIFRoZSBgdmlkZW9qc2AgZnVuY3Rpb24gY2FuIGJlIHVzZWQgdG8gaW5pdGlhbGl6ZSBvciByZXRyaWV2ZSBhIHBsYXllci5cbiAgKlxuICogQHBhcmFtIHtzdHJpbmd8RWxlbWVudH0gaWRcbiAqICAgICAgICBWaWRlbyBlbGVtZW50IG9yIHZpZGVvIGVsZW1lbnQgSURcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiAgICAgICAgT3B0aW9uYWwgb3B0aW9ucyBvYmplY3QgZm9yIGNvbmZpZy9zZXR0aW5nc1xuICpcbiAqIEBwYXJhbSB7Q29tcG9uZW50flJlYWR5Q2FsbGJhY2t9IFtyZWFkeV1cbiAqICAgICAgICBPcHRpb25hbCByZWFkeSBjYWxsYmFja1xuICpcbiAqIEByZXR1cm4ge1BsYXllcn1cbiAqICAgICAgICAgQSBwbGF5ZXIgaW5zdGFuY2VcbiAqL1xuZnVuY3Rpb24gdmlkZW9qcyhpZCwgb3B0aW9ucywgcmVhZHkpIHtcbiAgdmFyIHBsYXllciA9IHZpZGVvanMuZ2V0UGxheWVyKGlkKTtcblxuICBpZiAocGxheWVyKSB7XG4gICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgIGxvZy53YXJuKCdQbGF5ZXIgXCInICsgaWQgKyAnXCIgaXMgYWxyZWFkeSBpbml0aWFsaXNlZC4gT3B0aW9ucyB3aWxsIG5vdCBiZSBhcHBsaWVkLicpO1xuICAgIH1cbiAgICBpZiAocmVhZHkpIHtcbiAgICAgIHBsYXllci5yZWFkeShyZWFkeSk7XG4gICAgfVxuICAgIHJldHVybiBwbGF5ZXI7XG4gIH1cblxuICB2YXIgZWwgPSB0eXBlb2YgaWQgPT09ICdzdHJpbmcnID8gJCgnIycgKyBub3JtYWxpemVJZChpZCkpIDogaWQ7XG5cbiAgaWYgKCFpc0VsKGVsKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBlbGVtZW50IG9yIElEIHN1cHBsaWVkIGlzIG5vdCB2YWxpZC4gKHZpZGVvanMpJyk7XG4gIH1cblxuICBpZiAoIWRvY3VtZW50LmJvZHkuY29udGFpbnMoZWwpKSB7XG4gICAgbG9nLndhcm4oJ1RoZSBlbGVtZW50IHN1cHBsaWVkIGlzIG5vdCBpbmNsdWRlZCBpbiB0aGUgRE9NJyk7XG4gIH1cblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICB2aWRlb2pzLmhvb2tzKCdiZWZvcmVzZXR1cCcpLmZvckVhY2goZnVuY3Rpb24gKGhvb2tGdW5jdGlvbikge1xuICAgIHZhciBvcHRzID0gaG9va0Z1bmN0aW9uKGVsLCBtZXJnZU9wdGlvbnMob3B0aW9ucykpO1xuXG4gICAgaWYgKCFpc09iamVjdChvcHRzKSB8fCBBcnJheS5pc0FycmF5KG9wdHMpKSB7XG4gICAgICBsb2cuZXJyb3IoJ3BsZWFzZSByZXR1cm4gYW4gb2JqZWN0IGluIGJlZm9yZXNldHVwIGhvb2tzJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgb3B0aW9ucyA9IG1lcmdlT3B0aW9ucyhvcHRpb25zLCBvcHRzKTtcbiAgfSk7XG5cbiAgLy8gV2UgZ2V0IHRoZSBjdXJyZW50IFwiUGxheWVyXCIgY29tcG9uZW50IGhlcmUgaW4gY2FzZSBhbiBpbnRlZ3JhdGlvbiBoYXNcbiAgLy8gcmVwbGFjZWQgaXQgd2l0aCBhIGN1c3RvbSBwbGF5ZXIuXG4gIHZhciBQbGF5ZXJDb21wb25lbnQgPSBDb21wb25lbnQuZ2V0Q29tcG9uZW50KCdQbGF5ZXInKTtcblxuICBwbGF5ZXIgPSBuZXcgUGxheWVyQ29tcG9uZW50KGVsLCBvcHRpb25zLCByZWFkeSk7XG5cbiAgdmlkZW9qcy5ob29rcygnc2V0dXAnKS5mb3JFYWNoKGZ1bmN0aW9uIChob29rRnVuY3Rpb24pIHtcbiAgICByZXR1cm4gaG9va0Z1bmN0aW9uKHBsYXllcik7XG4gIH0pO1xuXG4gIHJldHVybiBwbGF5ZXI7XG59XG5cbi8qKlxuICogQW4gT2JqZWN0IHRoYXQgY29udGFpbnMgbGlmZWN5Y2xlIGhvb2tzIGFzIGtleXMgd2hpY2ggcG9pbnQgdG8gYW4gYXJyYXlcbiAqIG9mIGZ1bmN0aW9ucyB0aGF0IGFyZSBydW4gd2hlbiBhIGxpZmVjeWNsZSBpcyB0cmlnZ2VyZWRcbiAqL1xudmlkZW9qcy5ob29rc18gPSB7fTtcblxuLyoqXG4gKiBHZXQgYSBsaXN0IG9mIGhvb2tzIGZvciBhIHNwZWNpZmljIGxpZmVjeWNsZVxuICogQGZ1bmN0aW9uIHZpZGVvanMuaG9va3NcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICogICAgICAgIHRoZSBsaWZlY3lsZSB0byBnZXQgaG9va3MgZnJvbVxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb258RnVuY3Rpb25bXX0gW2ZuXVxuICogICAgICAgIE9wdGlvbmFsbHkgYWRkIGEgaG9vayAob3IgaG9va3MpIHRvIHRoZSBsaWZlY3ljbGUgdGhhdCB5b3VyIGFyZSBnZXR0aW5nLlxuICpcbiAqIEByZXR1cm4ge0FycmF5fVxuICogICAgICAgICBhbiBhcnJheSBvZiBob29rcywgb3IgYW4gZW1wdHkgYXJyYXkgaWYgdGhlcmUgYXJlIG5vbmUuXG4gKi9cbnZpZGVvanMuaG9va3MgPSBmdW5jdGlvbiAodHlwZSwgZm4pIHtcbiAgdmlkZW9qcy5ob29rc19bdHlwZV0gPSB2aWRlb2pzLmhvb2tzX1t0eXBlXSB8fCBbXTtcbiAgaWYgKGZuKSB7XG4gICAgdmlkZW9qcy5ob29rc19bdHlwZV0gPSB2aWRlb2pzLmhvb2tzX1t0eXBlXS5jb25jYXQoZm4pO1xuICB9XG4gIHJldHVybiB2aWRlb2pzLmhvb2tzX1t0eXBlXTtcbn07XG5cbi8qKlxuICogQWRkIGEgZnVuY3Rpb24gaG9vayB0byBhIHNwZWNpZmljIHZpZGVvanMgbGlmZWN5Y2xlLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gKiAgICAgICAgdGhlIGxpZmVjeWNsZSB0byBob29rIHRoZSBmdW5jdGlvbiB0by5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufEZ1bmN0aW9uW119XG4gKiAgICAgICAgVGhlIGZ1bmN0aW9uIG9yIGFycmF5IG9mIGZ1bmN0aW9ucyB0byBhdHRhY2guXG4gKi9cbnZpZGVvanMuaG9vayA9IGZ1bmN0aW9uICh0eXBlLCBmbikge1xuICB2aWRlb2pzLmhvb2tzKHR5cGUsIGZuKTtcbn07XG5cbi8qKlxuICogQWRkIGEgZnVuY3Rpb24gaG9vayB0aGF0IHdpbGwgb25seSBydW4gb25jZSB0byBhIHNwZWNpZmljIHZpZGVvanMgbGlmZWN5Y2xlLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gKiAgICAgICAgdGhlIGxpZmVjeWNsZSB0byBob29rIHRoZSBmdW5jdGlvbiB0by5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufEZ1bmN0aW9uW119XG4gKiAgICAgICAgVGhlIGZ1bmN0aW9uIG9yIGFycmF5IG9mIGZ1bmN0aW9ucyB0byBhdHRhY2guXG4gKi9cbnZpZGVvanMuaG9va09uY2UgPSBmdW5jdGlvbiAodHlwZSwgZm4pIHtcbiAgdmlkZW9qcy5ob29rcyh0eXBlLCBbXS5jb25jYXQoZm4pLm1hcChmdW5jdGlvbiAob3JpZ2luYWwpIHtcbiAgICB2YXIgd3JhcHBlciA9IGZ1bmN0aW9uIHdyYXBwZXIoKSB7XG4gICAgICB2aWRlb2pzLnJlbW92ZUhvb2sodHlwZSwgd3JhcHBlcik7XG4gICAgICByZXR1cm4gb3JpZ2luYWwuYXBwbHkodW5kZWZpbmVkLCBhcmd1bWVudHMpO1xuICAgIH07XG5cbiAgICByZXR1cm4gd3JhcHBlcjtcbiAgfSkpO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgYSBob29rIGZyb20gYSBzcGVjaWZpYyB2aWRlb2pzIGxpZmVjeWNsZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICogICAgICAgIHRoZSBsaWZlY3ljbGUgdGhhdCB0aGUgZnVuY3Rpb24gaG9va2VkIHRvXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqICAgICAgICBUaGUgaG9va2VkIGZ1bmN0aW9uIHRvIHJlbW92ZVxuICpcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKiAgICAgICAgIFRoZSBmdW5jdGlvbiB0aGF0IHdhcyByZW1vdmVkIG9yIHVuZGVmXG4gKi9cbnZpZGVvanMucmVtb3ZlSG9vayA9IGZ1bmN0aW9uICh0eXBlLCBmbikge1xuICB2YXIgaW5kZXggPSB2aWRlb2pzLmhvb2tzKHR5cGUpLmluZGV4T2YoZm4pO1xuXG4gIGlmIChpbmRleCA8PSAtMSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZpZGVvanMuaG9va3NfW3R5cGVdID0gdmlkZW9qcy5ob29rc19bdHlwZV0uc2xpY2UoKTtcbiAgdmlkZW9qcy5ob29rc19bdHlwZV0uc3BsaWNlKGluZGV4LCAxKTtcblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8vIEFkZCBkZWZhdWx0IHN0eWxlc1xuaWYgKHdpbmRvdy5WSURFT0pTX05PX0RZTkFNSUNfU1RZTEUgIT09IHRydWUgJiYgaXNSZWFsKCkpIHtcbiAgdmFyIHN0eWxlID0gJCgnLnZqcy1zdHlsZXMtZGVmYXVsdHMnKTtcblxuICBpZiAoIXN0eWxlKSB7XG4gICAgc3R5bGUgPSBjcmVhdGVTdHlsZUVsZW1lbnQoJ3Zqcy1zdHlsZXMtZGVmYXVsdHMnKTtcbiAgICB2YXIgaGVhZCA9ICQoJ2hlYWQnKTtcblxuICAgIGlmIChoZWFkKSB7XG4gICAgICBoZWFkLmluc2VydEJlZm9yZShzdHlsZSwgaGVhZC5maXJzdENoaWxkKTtcbiAgICB9XG4gICAgc2V0VGV4dENvbnRlbnQoc3R5bGUsICdcXG4gICAgICAudmlkZW8tanMge1xcbiAgICAgICAgd2lkdGg6IDMwMHB4O1xcbiAgICAgICAgaGVpZ2h0OiAxNTBweDtcXG4gICAgICB9XFxuXFxuICAgICAgLnZqcy1mbHVpZCB7XFxuICAgICAgICBwYWRkaW5nLXRvcDogNTYuMjUlXFxuICAgICAgfVxcbiAgICAnKTtcbiAgfVxufVxuXG4vLyBSdW4gQXV0by1sb2FkIHBsYXllcnNcbi8vIFlvdSBoYXZlIHRvIHdhaXQgYXQgbGVhc3Qgb25jZSBpbiBjYXNlIHRoaXMgc2NyaXB0IGlzIGxvYWRlZCBhZnRlciB5b3VyXG4vLyB2aWRlbyBpbiB0aGUgRE9NICh3ZWlyZCBiZWhhdmlvciBvbmx5IHdpdGggbWluaWZpZWQgdmVyc2lvbilcbmF1dG9TZXR1cFRpbWVvdXQoMSwgdmlkZW9qcyk7XG5cbi8qKlxuICogQ3VycmVudCBzb2Z0d2FyZSB2ZXJzaW9uLiBGb2xsb3dzIHNlbXZlci5cbiAqXG4gKiBAdHlwZSB7c3RyaW5nfVxuICovXG52aWRlb2pzLlZFUlNJT04gPSB2ZXJzaW9uO1xuXG4vKipcbiAqIFRoZSBnbG9iYWwgb3B0aW9ucyBvYmplY3QuIFRoZXNlIGFyZSB0aGUgc2V0dGluZ3MgdGhhdCB0YWtlIGVmZmVjdFxuICogaWYgbm8gb3ZlcnJpZGVzIGFyZSBzcGVjaWZpZWQgd2hlbiB0aGUgcGxheWVyIGlzIGNyZWF0ZWQuXG4gKlxuICogQHR5cGUge09iamVjdH1cbiAqL1xudmlkZW9qcy5vcHRpb25zID0gUGxheWVyLnByb3RvdHlwZS5vcHRpb25zXztcblxuLyoqXG4gKiBHZXQgYW4gb2JqZWN0IHdpdGggdGhlIGN1cnJlbnRseSBjcmVhdGVkIHBsYXllcnMsIGtleWVkIGJ5IHBsYXllciBJRFxuICpcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqICAgICAgICAgVGhlIGNyZWF0ZWQgcGxheWVyc1xuICovXG52aWRlb2pzLmdldFBsYXllcnMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBQbGF5ZXIucGxheWVycztcbn07XG5cbi8qKlxuICogR2V0IGEgc2luZ2xlIHBsYXllciBiYXNlZCBvbiBhbiBJRCBvciBET00gZWxlbWVudC5cbiAqXG4gKiBUaGlzIGlzIHVzZWZ1bCBpZiB5b3Ugd2FudCB0byBjaGVjayBpZiBhbiBlbGVtZW50IG9yIElEIGhhcyBhbiBhc3NvY2lhdGVkXG4gKiBWaWRlby5qcyBwbGF5ZXIsIGJ1dCBub3QgY3JlYXRlIG9uZSBpZiBpdCBkb2Vzbid0LlxuICpcbiAqIEBwYXJhbSAgIHtzdHJpbmd8RWxlbWVudH0gaWRcbiAqICAgICAgICAgIEFuIEhUTUwgZWxlbWVudCAtIGA8dmlkZW8+YCwgYDxhdWRpbz5gLCBvciBgPHZpZGVvLWpzPmAgLVxuICogICAgICAgICAgb3IgYSBzdHJpbmcgbWF0Y2hpbmcgdGhlIGBpZGAgb2Ygc3VjaCBhbiBlbGVtZW50LlxuICpcbiAqIEByZXR1cm5zIHtQbGF5ZXJ8dW5kZWZpbmVkfVxuICogICAgICAgICAgQSBwbGF5ZXIgaW5zdGFuY2Ugb3IgYHVuZGVmaW5lZGAgaWYgdGhlcmUgaXMgbm8gcGxheWVyIGluc3RhbmNlXG4gKiAgICAgICAgICBtYXRjaGluZyB0aGUgYXJndW1lbnQuXG4gKi9cbnZpZGVvanMuZ2V0UGxheWVyID0gZnVuY3Rpb24gKGlkKSB7XG4gIHZhciBwbGF5ZXJzID0gUGxheWVyLnBsYXllcnM7XG4gIHZhciB0YWcgPSB2b2lkIDA7XG5cbiAgaWYgKHR5cGVvZiBpZCA9PT0gJ3N0cmluZycpIHtcbiAgICB2YXIgbklkID0gbm9ybWFsaXplSWQoaWQpO1xuICAgIHZhciBwbGF5ZXIgPSBwbGF5ZXJzW25JZF07XG5cbiAgICBpZiAocGxheWVyKSB7XG4gICAgICByZXR1cm4gcGxheWVyO1xuICAgIH1cblxuICAgIHRhZyA9ICQoJyMnICsgbklkKTtcbiAgfSBlbHNlIHtcbiAgICB0YWcgPSBpZDtcbiAgfVxuXG4gIGlmIChpc0VsKHRhZykpIHtcbiAgICB2YXIgX3RhZyA9IHRhZyxcbiAgICAgICAgX3BsYXllciA9IF90YWcucGxheWVyLFxuICAgICAgICBwbGF5ZXJJZCA9IF90YWcucGxheWVySWQ7XG5cbiAgICAvLyBFbGVtZW50IG1heSBoYXZlIGEgYHBsYXllcmAgcHJvcGVydHkgcmVmZXJyaW5nIHRvIGFuIGFscmVhZHkgY3JlYXRlZFxuICAgIC8vIHBsYXllciBpbnN0YW5jZS4gSWYgc28sIHJldHVybiB0aGF0LlxuXG4gICAgaWYgKF9wbGF5ZXIgfHwgcGxheWVyc1twbGF5ZXJJZF0pIHtcbiAgICAgIHJldHVybiBfcGxheWVyIHx8IHBsYXllcnNbcGxheWVySWRdO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBSZXR1cm5zIGFuIGFycmF5IG9mIGFsbCBjdXJyZW50IHBsYXllcnMuXG4gKlxuICogQHJldHVybiB7QXJyYXl9XG4gKiAgICAgICAgIEFuIGFycmF5IG9mIGFsbCBwbGF5ZXJzLiBUaGUgYXJyYXkgd2lsbCBiZSBpbiB0aGUgb3JkZXIgdGhhdFxuICogICAgICAgICBgT2JqZWN0LmtleXNgIHByb3ZpZGVzLCB3aGljaCBjb3VsZCBwb3RlbnRpYWxseSB2YXJ5IGJldHdlZW5cbiAqICAgICAgICAgSmF2YVNjcmlwdCBlbmdpbmVzLlxuICpcbiAqL1xudmlkZW9qcy5nZXRBbGxQbGF5ZXJzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gKFxuXG4gICAgLy8gRGlzcG9zZWQgcGxheWVycyBsZWF2ZSBhIGtleSB3aXRoIGEgYG51bGxgIHZhbHVlLCBzbyB3ZSBuZWVkIHRvIG1ha2Ugc3VyZVxuICAgIC8vIHdlIGZpbHRlciB0aG9zZSBvdXQuXG4gICAgT2JqZWN0LmtleXMoUGxheWVyLnBsYXllcnMpLm1hcChmdW5jdGlvbiAoaykge1xuICAgICAgcmV0dXJuIFBsYXllci5wbGF5ZXJzW2tdO1xuICAgIH0pLmZpbHRlcihCb29sZWFuKVxuICApO1xufTtcblxuLyoqXG4gKiBFeHBvc2UgcGxheWVycyBvYmplY3QuXG4gKlxuICogQG1lbWJlck9mIHZpZGVvanNcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBwbGF5ZXJzXG4gKi9cbnZpZGVvanMucGxheWVycyA9IFBsYXllci5wbGF5ZXJzO1xuXG4vKipcbiAqIEdldCBhIGNvbXBvbmVudCBjbGFzcyBvYmplY3QgYnkgbmFtZVxuICpcbiAqIEBib3Jyb3dzIENvbXBvbmVudC5nZXRDb21wb25lbnQgYXMgdmlkZW9qcy5nZXRDb21wb25lbnRcbiAqL1xudmlkZW9qcy5nZXRDb21wb25lbnQgPSBDb21wb25lbnQuZ2V0Q29tcG9uZW50O1xuXG4vKipcbiAqIFJlZ2lzdGVyIGEgY29tcG9uZW50IHNvIGl0IGNhbiByZWZlcnJlZCB0byBieSBuYW1lLiBVc2VkIHdoZW4gYWRkaW5nIHRvIG90aGVyXG4gKiBjb21wb25lbnRzLCBlaXRoZXIgdGhyb3VnaCBhZGRDaGlsZCBgY29tcG9uZW50LmFkZENoaWxkKCdteUNvbXBvbmVudCcpYCBvciB0aHJvdWdoXG4gKiBkZWZhdWx0IGNoaWxkcmVuIG9wdGlvbnMgIGB7IGNoaWxkcmVuOiBbJ215Q29tcG9uZW50J10gfWAuXG4gKlxuICogPiBOT1RFOiBZb3UgY291bGQgYWxzbyBqdXN0IGluaXRpYWxpemUgdGhlIGNvbXBvbmVudCBiZWZvcmUgYWRkaW5nLlxuICogYGNvbXBvbmVudC5hZGRDaGlsZChuZXcgTXlDb21wb25lbnQoKSk7YFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiAgICAgICAgVGhlIGNsYXNzIG5hbWUgb2YgdGhlIGNvbXBvbmVudFxuICpcbiAqIEBwYXJhbSB7Q29tcG9uZW50fSBjb21wXG4gKiAgICAgICAgVGhlIGNvbXBvbmVudCBjbGFzc1xuICpcbiAqIEByZXR1cm4ge0NvbXBvbmVudH1cbiAqICAgICAgICAgVGhlIG5ld2x5IHJlZ2lzdGVyZWQgY29tcG9uZW50XG4gKi9cbnZpZGVvanMucmVnaXN0ZXJDb21wb25lbnQgPSBmdW5jdGlvbiAobmFtZSQkMSwgY29tcCkge1xuICBpZiAoVGVjaC5pc1RlY2goY29tcCkpIHtcbiAgICBsb2cud2FybignVGhlICcgKyBuYW1lJCQxICsgJyB0ZWNoIHdhcyByZWdpc3RlcmVkIGFzIGEgY29tcG9uZW50LiBJdCBzaG91bGQgaW5zdGVhZCBiZSByZWdpc3RlcmVkIHVzaW5nIHZpZGVvanMucmVnaXN0ZXJUZWNoKG5hbWUsIHRlY2gpJyk7XG4gIH1cblxuICBDb21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQuY2FsbChDb21wb25lbnQsIG5hbWUkJDEsIGNvbXApO1xufTtcblxuLyoqXG4gKiBHZXQgYSBUZWNoIGNsYXNzIG9iamVjdCBieSBuYW1lXG4gKlxuICogQGJvcnJvd3MgVGVjaC5nZXRUZWNoIGFzIHZpZGVvanMuZ2V0VGVjaFxuICovXG52aWRlb2pzLmdldFRlY2ggPSBUZWNoLmdldFRlY2g7XG5cbi8qKlxuICogUmVnaXN0ZXIgYSBUZWNoIHNvIGl0IGNhbiByZWZlcnJlZCB0byBieSBuYW1lLlxuICogVGhpcyBpcyB1c2VkIGluIHRoZSB0ZWNoIG9yZGVyIGZvciB0aGUgcGxheWVyLlxuICpcbiAqIEBib3Jyb3dzIFRlY2gucmVnaXN0ZXJUZWNoIGFzIHZpZGVvanMucmVnaXN0ZXJUZWNoXG4gKi9cbnZpZGVvanMucmVnaXN0ZXJUZWNoID0gVGVjaC5yZWdpc3RlclRlY2g7XG5cbi8qKlxuICogUmVnaXN0ZXIgYSBtaWRkbGV3YXJlIHRvIGEgc291cmNlIHR5cGUuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgQSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgTUlNRSB0eXBlLlxuICogQHBhcmFtIHtmdW5jdGlvbihwbGF5ZXIpOm9iamVjdH0gbWlkZGxld2FyZSBBIG1pZGRsZXdhcmUgZmFjdG9yeSB0aGF0IHRha2VzIGEgcGxheWVyLlxuICovXG52aWRlb2pzLnVzZSA9IHVzZTtcblxuLyoqXG4gKiBBbiBvYmplY3QgdGhhdCBjYW4gYmUgcmV0dXJuZWQgYnkgYSBtaWRkbGV3YXJlIHRvIHNpZ25pZnlcbiAqIHRoYXQgdGhlIG1pZGRsZXdhcmUgaXMgYmVpbmcgdGVybWluYXRlZC5cbiAqXG4gKiBAdHlwZSB7b2JqZWN0fVxuICogQG1lbWJlck9mIHt2aWRlb2pzfVxuICogQHByb3BlcnR5IHtvYmplY3R9IG1pZGRsZXdhcmUuVEVSTUlOQVRPUlxuICovXG4vLyBPYmplY3QuZGVmaW5lUHJvcGVydHkgaXMgbm90IGF2YWlsYWJsZSBpbiBJRThcbmlmICghSVNfSUU4ICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodmlkZW9qcywgJ21pZGRsZXdhcmUnLCB7XG4gICAgdmFsdWU6IHt9LFxuICAgIHdyaXRlYWJsZTogZmFsc2UsXG4gICAgZW51bWVyYWJsZTogdHJ1ZVxuICB9KTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodmlkZW9qcy5taWRkbGV3YXJlLCAnVEVSTUlOQVRPUicsIHtcbiAgICB2YWx1ZTogVEVSTUlOQVRPUixcbiAgICB3cml0ZWFibGU6IGZhbHNlLFxuICAgIGVudW1lcmFibGU6IHRydWVcbiAgfSk7XG59IGVsc2Uge1xuICB2aWRlb2pzLm1pZGRsZXdhcmUgPSB7IFRFUk1JTkFUT1I6IFRFUk1JTkFUT1IgfTtcbn1cblxuLyoqXG4gKiBBIHN1aXRlIG9mIGJyb3dzZXIgYW5kIGRldmljZSB0ZXN0cyBmcm9tIHtAbGluayBicm93c2VyfS5cbiAqXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQHByaXZhdGVcbiAqL1xudmlkZW9qcy5icm93c2VyID0gYnJvd3NlcjtcblxuLyoqXG4gKiBXaGV0aGVyIG9yIG5vdCB0aGUgYnJvd3NlciBzdXBwb3J0cyB0b3VjaCBldmVudHMuIEluY2x1ZGVkIGZvciBiYWNrd2FyZFxuICogY29tcGF0aWJpbGl0eSB3aXRoIDQueCwgYnV0IGRlcHJlY2F0ZWQuIFVzZSBgdmlkZW9qcy5icm93c2VyLlRPVUNIX0VOQUJMRURgXG4gKiBpbnN0ZWFkIGdvaW5nIGZvcndhcmQuXG4gKlxuICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiA1LjBcbiAqIEB0eXBlIHtib29sZWFufVxuICovXG52aWRlb2pzLlRPVUNIX0VOQUJMRUQgPSBUT1VDSF9FTkFCTEVEO1xuXG4vKipcbiAqIFN1YmNsYXNzIGFuIGV4aXN0aW5nIGNsYXNzXG4gKiBNaW1pY3MgRVM2IHN1YmNsYXNzaW5nIHdpdGggdGhlIGBleHRlbmRgIGtleXdvcmRcbiAqXG4gKiBAYm9ycm93cyBleHRlbmQ6ZXh0ZW5kRm4gYXMgdmlkZW9qcy5leHRlbmRcbiAqL1xudmlkZW9qcy5leHRlbmQgPSBleHRlbmRGbjtcblxuLyoqXG4gKiBNZXJnZSB0d28gb3B0aW9ucyBvYmplY3RzIHJlY3Vyc2l2ZWx5XG4gKiBQZXJmb3JtcyBhIGRlZXAgbWVyZ2UgbGlrZSBsb2Rhc2gubWVyZ2UgYnV0ICoqb25seSBtZXJnZXMgcGxhaW4gb2JqZWN0cyoqXG4gKiAobm90IGFycmF5cywgZWxlbWVudHMsIGFueXRoaW5nIGVsc2UpXG4gKiBPdGhlciB2YWx1ZXMgd2lsbCBiZSBjb3BpZWQgZGlyZWN0bHkgZnJvbSB0aGUgc2Vjb25kIG9iamVjdC5cbiAqXG4gKiBAYm9ycm93cyBtZXJnZS1vcHRpb25zOm1lcmdlT3B0aW9ucyBhcyB2aWRlb2pzLm1lcmdlT3B0aW9uc1xuICovXG52aWRlb2pzLm1lcmdlT3B0aW9ucyA9IG1lcmdlT3B0aW9ucztcblxuLyoqXG4gKiBDaGFuZ2UgdGhlIGNvbnRleHQgKHRoaXMpIG9mIGEgZnVuY3Rpb25cbiAqXG4gKiA+IE5PVEU6IGFzIG9mIHY1LjAgd2UgcmVxdWlyZSBhbiBFUzUgc2hpbSwgc28geW91IHNob3VsZCB1c2UgdGhlIG5hdGl2ZVxuICogYGZ1bmN0aW9uKCkge30uYmluZChuZXdDb250ZXh0KTtgIGluc3RlYWQgb2YgdGhpcy5cbiAqXG4gKiBAYm9ycm93cyBmbjpiaW5kIGFzIHZpZGVvanMuYmluZFxuICovXG52aWRlb2pzLmJpbmQgPSBiaW5kO1xuXG4vKipcbiAqIFJlZ2lzdGVyIGEgVmlkZW8uanMgcGx1Z2luLlxuICpcbiAqIEBib3Jyb3dzIHBsdWdpbjpyZWdpc3RlclBsdWdpbiBhcyB2aWRlb2pzLnJlZ2lzdGVyUGx1Z2luXG4gKiBAbWV0aG9kIHJlZ2lzdGVyUGx1Z2luXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfSBuYW1lXG4gKiAgICAgICAgIFRoZSBuYW1lIG9mIHRoZSBwbHVnaW4gdG8gYmUgcmVnaXN0ZXJlZC4gTXVzdCBiZSBhIHN0cmluZyBhbmRcbiAqICAgICAgICAgbXVzdCBub3QgbWF0Y2ggYW4gZXhpc3RpbmcgcGx1Z2luIG9yIGEgbWV0aG9kIG9uIHRoZSBgUGxheWVyYFxuICogICAgICAgICBwcm90b3R5cGUuXG4gKlxuICogQHBhcmFtICB7RnVuY3Rpb259IHBsdWdpblxuICogICAgICAgICBBIHN1Yi1jbGFzcyBvZiBgUGx1Z2luYCBvciBhIGZ1bmN0aW9uIGZvciBiYXNpYyBwbHVnaW5zLlxuICpcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICogICAgICAgICBGb3IgYWR2YW5jZWQgcGx1Z2lucywgYSBmYWN0b3J5IGZ1bmN0aW9uIGZvciB0aGF0IHBsdWdpbi4gRm9yXG4gKiAgICAgICAgIGJhc2ljIHBsdWdpbnMsIGEgd3JhcHBlciBmdW5jdGlvbiB0aGF0IGluaXRpYWxpemVzIHRoZSBwbHVnaW4uXG4gKi9cbnZpZGVvanMucmVnaXN0ZXJQbHVnaW4gPSBQbHVnaW4ucmVnaXN0ZXJQbHVnaW47XG5cbi8qKlxuICogRGVyZWdpc3RlciBhIFZpZGVvLmpzIHBsdWdpbi5cbiAqXG4gKiBAYm9ycm93cyBwbHVnaW46ZGVyZWdpc3RlclBsdWdpbiBhcyB2aWRlb2pzLmRlcmVnaXN0ZXJQbHVnaW5cbiAqIEBtZXRob2QgZGVyZWdpc3RlclBsdWdpblxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gbmFtZVxuICogICAgICAgICBUaGUgbmFtZSBvZiB0aGUgcGx1Z2luIHRvIGJlIGRlcmVnaXN0ZXJlZC4gTXVzdCBiZSBhIHN0cmluZyBhbmRcbiAqICAgICAgICAgbXVzdCBtYXRjaCBhbiBleGlzdGluZyBwbHVnaW4gb3IgYSBtZXRob2Qgb24gdGhlIGBQbGF5ZXJgXG4gKiAgICAgICAgIHByb3RvdHlwZS5cbiAqXG4gKi9cbnZpZGVvanMuZGVyZWdpc3RlclBsdWdpbiA9IFBsdWdpbi5kZXJlZ2lzdGVyUGx1Z2luO1xuXG4vKipcbiAqIERlcHJlY2F0ZWQgbWV0aG9kIHRvIHJlZ2lzdGVyIGEgcGx1Z2luIHdpdGggVmlkZW8uanNcbiAqXG4gKiBAZGVwcmVjYXRlZFxuICogICAgICAgIHZpZGVvanMucGx1Z2luKCkgaXMgZGVwcmVjYXRlZDsgdXNlIHZpZGVvanMucmVnaXN0ZXJQbHVnaW4oKSBpbnN0ZWFkXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqICAgICAgICBUaGUgcGx1Z2luIG5hbWVcbiAqXG4gKiBAcGFyYW0ge1BsdWdpbnxGdW5jdGlvbn0gcGx1Z2luXG4gKiAgICAgICAgIFRoZSBwbHVnaW4gc3ViLWNsYXNzIG9yIGZ1bmN0aW9uXG4gKi9cbnZpZGVvanMucGx1Z2luID0gZnVuY3Rpb24gKG5hbWUkJDEsIHBsdWdpbikge1xuICBsb2cud2FybigndmlkZW9qcy5wbHVnaW4oKSBpcyBkZXByZWNhdGVkOyB1c2UgdmlkZW9qcy5yZWdpc3RlclBsdWdpbigpIGluc3RlYWQnKTtcbiAgcmV0dXJuIFBsdWdpbi5yZWdpc3RlclBsdWdpbihuYW1lJCQxLCBwbHVnaW4pO1xufTtcblxuLyoqXG4gKiBHZXRzIGFuIG9iamVjdCBjb250YWluaW5nIG11bHRpcGxlIFZpZGVvLmpzIHBsdWdpbnMuXG4gKlxuICogQHBhcmFtICB7QXJyYXl9IFtuYW1lc11cbiAqICAgICAgICAgSWYgcHJvdmlkZWQsIHNob3VsZCBiZSBhbiBhcnJheSBvZiBwbHVnaW4gbmFtZXMuIERlZmF1bHRzIHRvIF9hbGxfXG4gKiAgICAgICAgIHBsdWdpbiBuYW1lcy5cbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R8dW5kZWZpbmVkfVxuICogICAgICAgICBBbiBvYmplY3QgY29udGFpbmluZyBwbHVnaW4ocykgYXNzb2NpYXRlZCB3aXRoIHRoZWlyIG5hbWUocykgb3JcbiAqICAgICAgICAgYHVuZGVmaW5lZGAgaWYgbm8gbWF0Y2hpbmcgcGx1Z2lucyBleGlzdCkuXG4gKi9cbnZpZGVvanMuZ2V0UGx1Z2lucyA9IFBsdWdpbi5nZXRQbHVnaW5zO1xuXG4vKipcbiAqIEdldHMgYSBwbHVnaW4gYnkgbmFtZSBpZiBpdCBleGlzdHMuXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfSBuYW1lXG4gKiAgICAgICAgIFRoZSBuYW1lIG9mIGEgcGx1Z2luLlxuICpcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufHVuZGVmaW5lZH1cbiAqICAgICAgICAgVGhlIHBsdWdpbiAob3IgYHVuZGVmaW5lZGApLlxuICovXG52aWRlb2pzLmdldFBsdWdpbiA9IFBsdWdpbi5nZXRQbHVnaW47XG5cbi8qKlxuICogR2V0cyBhIHBsdWdpbidzIHZlcnNpb24sIGlmIGF2YWlsYWJsZVxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gbmFtZVxuICogICAgICAgICBUaGUgbmFtZSBvZiBhIHBsdWdpbi5cbiAqXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKiAgICAgICAgIFRoZSBwbHVnaW4ncyB2ZXJzaW9uIG9yIGFuIGVtcHR5IHN0cmluZy5cbiAqL1xudmlkZW9qcy5nZXRQbHVnaW5WZXJzaW9uID0gUGx1Z2luLmdldFBsdWdpblZlcnNpb247XG5cbi8qKlxuICogQWRkaW5nIGxhbmd1YWdlcyBzbyB0aGF0IHRoZXkncmUgYXZhaWxhYmxlIHRvIGFsbCBwbGF5ZXJzLlxuICogRXhhbXBsZTogYHZpZGVvanMuYWRkTGFuZ3VhZ2UoJ2VzJywgeyAnSGVsbG8nOiAnSG9sYScgfSk7YFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb2RlXG4gKiAgICAgICAgVGhlIGxhbmd1YWdlIGNvZGUgb3IgZGljdGlvbmFyeSBwcm9wZXJ0eVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gKiAgICAgICAgVGhlIGRhdGEgdmFsdWVzIHRvIGJlIHRyYW5zbGF0ZWRcbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKiAgICAgICAgIFRoZSByZXN1bHRpbmcgbGFuZ3VhZ2UgZGljdGlvbmFyeSBvYmplY3RcbiAqL1xudmlkZW9qcy5hZGRMYW5ndWFnZSA9IGZ1bmN0aW9uIChjb2RlLCBkYXRhKSB7XG4gIHZhciBfbWVyZ2VPcHRpb25zO1xuXG4gIGNvZGUgPSAoJycgKyBjb2RlKS50b0xvd2VyQ2FzZSgpO1xuXG4gIHZpZGVvanMub3B0aW9ucy5sYW5ndWFnZXMgPSBtZXJnZU9wdGlvbnModmlkZW9qcy5vcHRpb25zLmxhbmd1YWdlcywgKF9tZXJnZU9wdGlvbnMgPSB7fSwgX21lcmdlT3B0aW9uc1tjb2RlXSA9IGRhdGEsIF9tZXJnZU9wdGlvbnMpKTtcblxuICByZXR1cm4gdmlkZW9qcy5vcHRpb25zLmxhbmd1YWdlc1tjb2RlXTtcbn07XG5cbi8qKlxuICogTG9nIG1lc3NhZ2VzXG4gKlxuICogQGJvcnJvd3MgbG9nOmxvZyBhcyB2aWRlb2pzLmxvZ1xuICovXG52aWRlb2pzLmxvZyA9IGxvZztcbnZpZGVvanMuY3JlYXRlTG9nZ2VyID0gY3JlYXRlTG9nZ2VyO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gZW11bGF0ZWQgVGltZVJhbmdlIG9iamVjdC5cbiAqXG4gKiBAYm9ycm93cyB0aW1lLXJhbmdlczpjcmVhdGVUaW1lUmFuZ2VzIGFzIHZpZGVvanMuY3JlYXRlVGltZVJhbmdlXG4gKi9cbi8qKlxuICogQGJvcnJvd3MgdGltZS1yYW5nZXM6Y3JlYXRlVGltZVJhbmdlcyBhcyB2aWRlb2pzLmNyZWF0ZVRpbWVSYW5nZXNcbiAqL1xudmlkZW9qcy5jcmVhdGVUaW1lUmFuZ2UgPSB2aWRlb2pzLmNyZWF0ZVRpbWVSYW5nZXMgPSBjcmVhdGVUaW1lUmFuZ2VzO1xuXG4vKipcbiAqIEZvcm1hdCBzZWNvbmRzIGFzIGEgdGltZSBzdHJpbmcsIEg6TU06U1Mgb3IgTTpTU1xuICogU3VwcGx5aW5nIGEgZ3VpZGUgKGluIHNlY29uZHMpIHdpbGwgZm9yY2UgYSBudW1iZXIgb2YgbGVhZGluZyB6ZXJvc1xuICogdG8gY292ZXIgdGhlIGxlbmd0aCBvZiB0aGUgZ3VpZGVcbiAqXG4gKiBAYm9ycm93cyBmb3JtYXQtdGltZTpmb3JtYXRUaW1lIGFzIHZpZGVvanMuZm9ybWF0VGltZVxuICovXG52aWRlb2pzLmZvcm1hdFRpbWUgPSBmb3JtYXRUaW1lO1xuXG4vKipcbiAqIFJlcGxhY2VzIGZvcm1hdC10aW1lIHdpdGggYSBjdXN0b20gaW1wbGVtZW50YXRpb24sIHRvIGJlIHVzZWQgaW4gcGxhY2Ugb2YgdGhlIGRlZmF1bHQuXG4gKlxuICogQGJvcnJvd3MgZm9ybWF0LXRpbWU6c2V0Rm9ybWF0VGltZSBhcyB2aWRlb2pzLnNldEZvcm1hdFRpbWVcbiAqXG4gKiBAbWV0aG9kIHNldEZvcm1hdFRpbWVcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21GblxuICogICAgICAgIEEgY3VzdG9tIGZvcm1hdC10aW1lIGZ1bmN0aW9uIHdoaWNoIHdpbGwgYmUgY2FsbGVkIHdpdGggdGhlIGN1cnJlbnQgdGltZSBhbmQgZ3VpZGUgKGluIHNlY29uZHMpIGFzIGFyZ3VtZW50cy5cbiAqICAgICAgICBQYXNzZWQgZm4gc2hvdWxkIHJldHVybiBhIHN0cmluZy5cbiAqL1xudmlkZW9qcy5zZXRGb3JtYXRUaW1lID0gc2V0Rm9ybWF0VGltZTtcblxuLyoqXG4gKiBSZXNldHMgZm9ybWF0LXRpbWUgdG8gdGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24uXG4gKlxuICogQGJvcnJvd3MgZm9ybWF0LXRpbWU6cmVzZXRGb3JtYXRUaW1lIGFzIHZpZGVvanMucmVzZXRGb3JtYXRUaW1lXG4gKlxuICogQG1ldGhvZCByZXNldEZvcm1hdFRpbWVcbiAqL1xudmlkZW9qcy5yZXNldEZvcm1hdFRpbWUgPSByZXNldEZvcm1hdFRpbWU7XG5cbi8qKlxuICogUmVzb2x2ZSBhbmQgcGFyc2UgdGhlIGVsZW1lbnRzIG9mIGEgVVJMXG4gKlxuICogQGJvcnJvd3MgdXJsOnBhcnNlVXJsIGFzIHZpZGVvanMucGFyc2VVcmxcbiAqXG4gKi9cbnZpZGVvanMucGFyc2VVcmwgPSBwYXJzZVVybDtcblxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgdGhlIHVybCBwYXNzZWQgaXMgYSBjcm9zcyBkb21haW4gcmVxdWVzdCBvciBub3QuXG4gKlxuICogQGJvcnJvd3MgdXJsOmlzQ3Jvc3NPcmlnaW4gYXMgdmlkZW9qcy5pc0Nyb3NzT3JpZ2luXG4gKi9cbnZpZGVvanMuaXNDcm9zc09yaWdpbiA9IGlzQ3Jvc3NPcmlnaW47XG5cbi8qKlxuICogRXZlbnQgdGFyZ2V0IGNsYXNzLlxuICpcbiAqIEBib3Jyb3dzIEV2ZW50VGFyZ2V0IGFzIHZpZGVvanMuRXZlbnRUYXJnZXRcbiAqL1xudmlkZW9qcy5FdmVudFRhcmdldCA9IEV2ZW50VGFyZ2V0O1xuXG4vKipcbiAqIEFkZCBhbiBldmVudCBsaXN0ZW5lciB0byBlbGVtZW50XG4gKiBJdCBzdG9yZXMgdGhlIGhhbmRsZXIgZnVuY3Rpb24gaW4gYSBzZXBhcmF0ZSBjYWNoZSBvYmplY3RcbiAqIGFuZCBhZGRzIGEgZ2VuZXJpYyBoYW5kbGVyIHRvIHRoZSBlbGVtZW50J3MgZXZlbnQsXG4gKiBhbG9uZyB3aXRoIGEgdW5pcXVlIGlkIChndWlkKSB0byB0aGUgZWxlbWVudC5cbiAqXG4gKiBAYm9ycm93cyBldmVudHM6b24gYXMgdmlkZW9qcy5vblxuICovXG52aWRlb2pzLm9uID0gb247XG5cbi8qKlxuICogVHJpZ2dlciBhIGxpc3RlbmVyIG9ubHkgb25jZSBmb3IgYW4gZXZlbnRcbiAqXG4gKiBAYm9ycm93cyBldmVudHM6b25lIGFzIHZpZGVvanMub25lXG4gKi9cbnZpZGVvanMub25lID0gb25lO1xuXG4vKipcbiAqIFJlbW92ZXMgZXZlbnQgbGlzdGVuZXJzIGZyb20gYW4gZWxlbWVudFxuICpcbiAqIEBib3Jyb3dzIGV2ZW50czpvZmYgYXMgdmlkZW9qcy5vZmZcbiAqL1xudmlkZW9qcy5vZmYgPSBvZmY7XG5cbi8qKlxuICogVHJpZ2dlciBhbiBldmVudCBmb3IgYW4gZWxlbWVudFxuICpcbiAqIEBib3Jyb3dzIGV2ZW50czp0cmlnZ2VyIGFzIHZpZGVvanMudHJpZ2dlclxuICovXG52aWRlb2pzLnRyaWdnZXIgPSB0cmlnZ2VyO1xuXG4vKipcbiAqIEEgY3Jvc3MtYnJvd3NlciBYTUxIdHRwUmVxdWVzdCB3cmFwcGVyLiBIZXJlJ3MgYSBzaW1wbGUgZXhhbXBsZTpcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogICAgICAgIHNldHRpbmdzIGZvciB0aGUgcmVxdWVzdC5cbiAqXG4gKiBAcmV0dXJuIHtYTUxIdHRwUmVxdWVzdHxYRG9tYWluUmVxdWVzdH1cbiAqICAgICAgICAgVGhlIHJlcXVlc3Qgb2JqZWN0LlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL1JheW5vcy94aHJcbiAqL1xudmlkZW9qcy54aHIgPSB4aHI7XG5cbi8qKlxuICogVGV4dFRyYWNrIGNsYXNzXG4gKlxuICogQGJvcnJvd3MgVGV4dFRyYWNrIGFzIHZpZGVvanMuVGV4dFRyYWNrXG4gKi9cbnZpZGVvanMuVGV4dFRyYWNrID0gVGV4dFRyYWNrO1xuXG4vKipcbiAqIGV4cG9ydCB0aGUgQXVkaW9UcmFjayBjbGFzcyBzbyB0aGF0IHNvdXJjZSBoYW5kbGVycyBjYW4gY3JlYXRlXG4gKiBBdWRpb1RyYWNrcyBhbmQgdGhlbiBhZGQgdGhlbSB0byB0aGUgcGxheWVycyBBdWRpb1RyYWNrTGlzdFxuICpcbiAqIEBib3Jyb3dzIEF1ZGlvVHJhY2sgYXMgdmlkZW9qcy5BdWRpb1RyYWNrXG4gKi9cbnZpZGVvanMuQXVkaW9UcmFjayA9IEF1ZGlvVHJhY2s7XG5cbi8qKlxuICogZXhwb3J0IHRoZSBWaWRlb1RyYWNrIGNsYXNzIHNvIHRoYXQgc291cmNlIGhhbmRsZXJzIGNhbiBjcmVhdGVcbiAqIFZpZGVvVHJhY2tzIGFuZCB0aGVuIGFkZCB0aGVtIHRvIHRoZSBwbGF5ZXJzIFZpZGVvVHJhY2tMaXN0XG4gKlxuICogQGJvcnJvd3MgVmlkZW9UcmFjayBhcyB2aWRlb2pzLlZpZGVvVHJhY2tcbiAqL1xudmlkZW9qcy5WaWRlb1RyYWNrID0gVmlkZW9UcmFjaztcblxuLyoqXG4gKiBEZXRlcm1pbmVzLCB2aWEgZHVjayB0eXBpbmcsIHdoZXRoZXIgb3Igbm90IGEgdmFsdWUgaXMgYSBET00gZWxlbWVudC5cbiAqXG4gKiBAYm9ycm93cyBkb206aXNFbCBhcyB2aWRlb2pzLmlzRWxcbiAqIEBkZXByZWNhdGVkIFVzZSB2aWRlb2pzLmRvbS5pc0VsKCkgaW5zdGVhZFxuICovXG5cbi8qKlxuICogRGV0ZXJtaW5lcywgdmlhIGR1Y2sgdHlwaW5nLCB3aGV0aGVyIG9yIG5vdCBhIHZhbHVlIGlzIGEgdGV4dCBub2RlLlxuICpcbiAqIEBib3Jyb3dzIGRvbTppc1RleHROb2RlIGFzIHZpZGVvanMuaXNUZXh0Tm9kZVxuICogQGRlcHJlY2F0ZWQgVXNlIHZpZGVvanMuZG9tLmlzVGV4dE5vZGUoKSBpbnN0ZWFkXG4gKi9cblxuLyoqXG4gKiBDcmVhdGVzIGFuIGVsZW1lbnQgYW5kIGFwcGxpZXMgcHJvcGVydGllcy5cbiAqXG4gKiBAYm9ycm93cyBkb206Y3JlYXRlRWwgYXMgdmlkZW9qcy5jcmVhdGVFbFxuICogQGRlcHJlY2F0ZWQgVXNlIHZpZGVvanMuZG9tLmNyZWF0ZUVsKCkgaW5zdGVhZFxuICovXG5cbi8qKlxuICogQ2hlY2sgaWYgYW4gZWxlbWVudCBoYXMgYSBDU1MgY2xhc3NcbiAqXG4gKiBAYm9ycm93cyBkb206aGFzRWxDbGFzcyBhcyB2aWRlb2pzLmhhc0NsYXNzXG4gKiBAZGVwcmVjYXRlZCBVc2UgdmlkZW9qcy5kb20uaGFzQ2xhc3MoKSBpbnN0ZWFkXG4gKi9cblxuLyoqXG4gKiBBZGQgYSBDU1MgY2xhc3MgbmFtZSB0byBhbiBlbGVtZW50XG4gKlxuICogQGJvcnJvd3MgZG9tOmFkZEVsQ2xhc3MgYXMgdmlkZW9qcy5hZGRDbGFzc1xuICogQGRlcHJlY2F0ZWQgVXNlIHZpZGVvanMuZG9tLmFkZENsYXNzKCkgaW5zdGVhZFxuICovXG5cbi8qKlxuICogUmVtb3ZlIGEgQ1NTIGNsYXNzIG5hbWUgZnJvbSBhbiBlbGVtZW50XG4gKlxuICogQGJvcnJvd3MgZG9tOnJlbW92ZUVsQ2xhc3MgYXMgdmlkZW9qcy5yZW1vdmVDbGFzc1xuICogQGRlcHJlY2F0ZWQgVXNlIHZpZGVvanMuZG9tLnJlbW92ZUNsYXNzKCkgaW5zdGVhZFxuICovXG5cbi8qKlxuICogQWRkcyBvciByZW1vdmVzIGEgQ1NTIGNsYXNzIG5hbWUgb24gYW4gZWxlbWVudCBkZXBlbmRpbmcgb24gYW4gb3B0aW9uYWxcbiAqIGNvbmRpdGlvbiBvciB0aGUgcHJlc2VuY2UvYWJzZW5jZSBvZiB0aGUgY2xhc3MgbmFtZS5cbiAqXG4gKiBAYm9ycm93cyBkb206dG9nZ2xlRWxDbGFzcyBhcyB2aWRlb2pzLnRvZ2dsZUNsYXNzXG4gKiBAZGVwcmVjYXRlZCBVc2UgdmlkZW9qcy5kb20udG9nZ2xlQ2xhc3MoKSBpbnN0ZWFkXG4gKi9cblxuLyoqXG4gKiBBcHBseSBhdHRyaWJ1dGVzIHRvIGFuIEhUTUwgZWxlbWVudC5cbiAqXG4gKiBAYm9ycm93cyBkb206c2V0RWxBdHRyaWJ1dGVzIGFzIHZpZGVvanMuc2V0QXR0cmlidXRlXG4gKiBAZGVwcmVjYXRlZCBVc2UgdmlkZW9qcy5kb20uc2V0QXR0cmlidXRlcygpIGluc3RlYWRcbiAqL1xuXG4vKipcbiAqIEdldCBhbiBlbGVtZW50J3MgYXR0cmlidXRlIHZhbHVlcywgYXMgZGVmaW5lZCBvbiB0aGUgSFRNTCB0YWdcbiAqIEF0dHJpYnV0ZXMgYXJlIG5vdCB0aGUgc2FtZSBhcyBwcm9wZXJ0aWVzLiBUaGV5J3JlIGRlZmluZWQgb24gdGhlIHRhZ1xuICogb3Igd2l0aCBzZXRBdHRyaWJ1dGUgKHdoaWNoIHNob3VsZG4ndCBiZSB1c2VkIHdpdGggSFRNTClcbiAqIFRoaXMgd2lsbCByZXR1cm4gdHJ1ZSBvciBmYWxzZSBmb3IgYm9vbGVhbiBhdHRyaWJ1dGVzLlxuICpcbiAqIEBib3Jyb3dzIGRvbTpnZXRFbEF0dHJpYnV0ZXMgYXMgdmlkZW9qcy5nZXRBdHRyaWJ1dGVzXG4gKiBAZGVwcmVjYXRlZCBVc2UgdmlkZW9qcy5kb20uZ2V0QXR0cmlidXRlcygpIGluc3RlYWRcbiAqL1xuXG4vKipcbiAqIEVtcHRpZXMgdGhlIGNvbnRlbnRzIG9mIGFuIGVsZW1lbnQuXG4gKlxuICogQGJvcnJvd3MgZG9tOmVtcHR5RWwgYXMgdmlkZW9qcy5lbXB0eUVsXG4gKiBAZGVwcmVjYXRlZCBVc2UgdmlkZW9qcy5kb20uZW1wdHlFbCgpIGluc3RlYWRcbiAqL1xuXG4vKipcbiAqIE5vcm1hbGl6ZXMgYW5kIGFwcGVuZHMgY29udGVudCB0byBhbiBlbGVtZW50LlxuICpcbiAqIFRoZSBjb250ZW50IGZvciBhbiBlbGVtZW50IGNhbiBiZSBwYXNzZWQgaW4gbXVsdGlwbGUgdHlwZXMgYW5kXG4gKiBjb21iaW5hdGlvbnMsIHdob3NlIGJlaGF2aW9yIGlzIGFzIGZvbGxvd3M6XG4gKlxuICogLSBTdHJpbmdcbiAqICAgTm9ybWFsaXplZCBpbnRvIGEgdGV4dCBub2RlLlxuICpcbiAqIC0gRWxlbWVudCwgVGV4dE5vZGVcbiAqICAgUGFzc2VkIHRocm91Z2guXG4gKlxuICogLSBBcnJheVxuICogICBBIG9uZS1kaW1lbnNpb25hbCBhcnJheSBvZiBzdHJpbmdzLCBlbGVtZW50cywgbm9kZXMsIG9yIGZ1bmN0aW9ucyAod2hpY2hcbiAqICAgcmV0dXJuIHNpbmdsZSBzdHJpbmdzLCBlbGVtZW50cywgb3Igbm9kZXMpLlxuICpcbiAqIC0gRnVuY3Rpb25cbiAqICAgSWYgdGhlIHNvbGUgYXJndW1lbnQsIGlzIGV4cGVjdGVkIHRvIHByb2R1Y2UgYSBzdHJpbmcsIGVsZW1lbnQsXG4gKiAgIG5vZGUsIG9yIGFycmF5LlxuICpcbiAqIEBib3Jyb3dzIGRvbTphcHBlbmRDb250ZW50cyBhcyB2aWRlb2pzLmFwcGVuZENvbnRldFxuICogQGRlcHJlY2F0ZWQgVXNlIHZpZGVvanMuZG9tLmFwcGVuZENvbnRlbnQoKSBpbnN0ZWFkXG4gKi9cblxuLyoqXG4gKiBOb3JtYWxpemVzIGFuZCBpbnNlcnRzIGNvbnRlbnQgaW50byBhbiBlbGVtZW50OyB0aGlzIGlzIGlkZW50aWNhbCB0b1xuICogYGFwcGVuZENvbnRlbnQoKWAsIGV4Y2VwdCBpdCBlbXB0aWVzIHRoZSBlbGVtZW50IGZpcnN0LlxuICpcbiAqIFRoZSBjb250ZW50IGZvciBhbiBlbGVtZW50IGNhbiBiZSBwYXNzZWQgaW4gbXVsdGlwbGUgdHlwZXMgYW5kXG4gKiBjb21iaW5hdGlvbnMsIHdob3NlIGJlaGF2aW9yIGlzIGFzIGZvbGxvd3M6XG4gKlxuICogLSBTdHJpbmdcbiAqICAgTm9ybWFsaXplZCBpbnRvIGEgdGV4dCBub2RlLlxuICpcbiAqIC0gRWxlbWVudCwgVGV4dE5vZGVcbiAqICAgUGFzc2VkIHRocm91Z2guXG4gKlxuICogLSBBcnJheVxuICogICBBIG9uZS1kaW1lbnNpb25hbCBhcnJheSBvZiBzdHJpbmdzLCBlbGVtZW50cywgbm9kZXMsIG9yIGZ1bmN0aW9ucyAod2hpY2hcbiAqICAgcmV0dXJuIHNpbmdsZSBzdHJpbmdzLCBlbGVtZW50cywgb3Igbm9kZXMpLlxuICpcbiAqIC0gRnVuY3Rpb25cbiAqICAgSWYgdGhlIHNvbGUgYXJndW1lbnQsIGlzIGV4cGVjdGVkIHRvIHByb2R1Y2UgYSBzdHJpbmcsIGVsZW1lbnQsXG4gKiAgIG5vZGUsIG9yIGFycmF5LlxuICpcbiAqIEBib3Jyb3dzIGRvbTppbnNlcnRDb250ZW50IGFzIHZpZGVvanMuaW5zZXJ0Q29udGVudFxuICogQGRlcHJlY2F0ZWQgVXNlIHZpZGVvanMuZG9tLmluc2VydENvbnRlbnQoKSBpbnN0ZWFkXG4gKi9cblsnaXNFbCcsICdpc1RleHROb2RlJywgJ2NyZWF0ZUVsJywgJ2hhc0NsYXNzJywgJ2FkZENsYXNzJywgJ3JlbW92ZUNsYXNzJywgJ3RvZ2dsZUNsYXNzJywgJ3NldEF0dHJpYnV0ZXMnLCAnZ2V0QXR0cmlidXRlcycsICdlbXB0eUVsJywgJ2FwcGVuZENvbnRlbnQnLCAnaW5zZXJ0Q29udGVudCddLmZvckVhY2goZnVuY3Rpb24gKGspIHtcbiAgdmlkZW9qc1trXSA9IGZ1bmN0aW9uICgpIHtcbiAgICBsb2cud2FybigndmlkZW9qcy4nICsgayArICcoKSBpcyBkZXByZWNhdGVkOyB1c2UgdmlkZW9qcy5kb20uJyArIGsgKyAnKCkgaW5zdGVhZCcpO1xuICAgIHJldHVybiBEb21ba10uYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgfTtcbn0pO1xuXG4vKipcbiAqIEEgc2FmZSBnZXRDb21wdXRlZFN0eWxlIHdpdGggYW4gSUU4IGZhbGxiYWNrLlxuICpcbiAqIFRoaXMgaXMgYmVjYXVzZSBpbiBGaXJlZm94LCBpZiB0aGUgcGxheWVyIGlzIGxvYWRlZCBpbiBhbiBpZnJhbWUgd2l0aCBgZGlzcGxheTpub25lYCxcbiAqIHRoZW4gYGdldENvbXB1dGVkU3R5bGVgIHJldHVybnMgYG51bGxgLCBzbywgd2UgZG8gYSBudWxsLWNoZWNrIHRvIG1ha2Ugc3VyZVxuICogdGhhdCB0aGUgcGxheWVyIGRvZXNuJ3QgYnJlYWsgaW4gdGhlc2UgY2FzZXMuXG4gKiBTZWUgaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9NTQ4Mzk3IGZvciBtb3JlIGRldGFpbHMuXG4gKlxuICogQGJvcnJvd3MgY29tcHV0ZWQtc3R5bGU6Y29tcHV0ZWRTdHlsZSBhcyB2aWRlb2pzLmNvbXB1dGVkU3R5bGVcbiAqL1xudmlkZW9qcy5jb21wdXRlZFN0eWxlID0gY29tcHV0ZWRTdHlsZTtcblxuLyoqXG4gKiBFeHBvcnQgdGhlIERvbSB1dGlsaXRpZXMgZm9yIHVzZSBpbiBleHRlcm5hbCBwbHVnaW5zXG4gKiBhbmQgVGVjaCdzXG4gKi9cbnZpZGVvanMuZG9tID0gRG9tO1xuXG4vKipcbiAqIEV4cG9ydCB0aGUgVXJsIHV0aWxpdGllcyBmb3IgdXNlIGluIGV4dGVybmFsIHBsdWdpbnNcbiAqIGFuZCBUZWNoJ3NcbiAqL1xudmlkZW9qcy51cmwgPSBVcmw7XG5cbm1vZHVsZS5leHBvcnRzID0gdmlkZW9qcztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/videojs-contrib-media-sources/node_modules/video.js/dist/video.cjs.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/videojs-contrib-media-sources/node_modules/videojs-vtt.js/lib/browser-index.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/videojs-contrib-media-sources/node_modules/videojs-vtt.js/lib/browser-index.js ***!
  \*****************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Copyright 2013 vtt.js Contributors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// Default exports for Node. Export the extended versions of VTTCue and\n// VTTRegion in Node since we likely want the capability to convert back and\n// forth between JSON. If we don't then it's not that big of a deal since we're\n// off browser.\n\nvar window = __webpack_require__(/*! global/window */ \"(ssr)/./node_modules/videojs-contrib-media-sources/node_modules/global/window.js\");\n\nvar vttjs = module.exports = {\n  WebVTT: __webpack_require__(/*! ./vtt.js */ \"(ssr)/./node_modules/videojs-contrib-media-sources/node_modules/videojs-vtt.js/lib/vtt.js\"),\n  VTTCue: __webpack_require__(/*! ./vttcue.js */ \"(ssr)/./node_modules/videojs-contrib-media-sources/node_modules/videojs-vtt.js/lib/vttcue.js\"),\n  VTTRegion: __webpack_require__(/*! ./vttregion.js */ \"(ssr)/./node_modules/videojs-contrib-media-sources/node_modules/videojs-vtt.js/lib/vttregion.js\")\n};\n\nwindow.vttjs = vttjs;\nwindow.WebVTT = vttjs.WebVTT;\n\nvar cueShim = vttjs.VTTCue;\nvar regionShim = vttjs.VTTRegion;\nvar nativeVTTCue = window.VTTCue;\nvar nativeVTTRegion = window.VTTRegion;\n\nvttjs.shim = function() {\n  window.VTTCue = cueShim;\n  window.VTTRegion = regionShim;\n};\n\nvttjs.restore = function() {\n  window.VTTCue = nativeVTTCue;\n  window.VTTRegion = nativeVTTRegion;\n};\n\nif (!window.VTTCue) {\n  vttjs.shim();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdmlkZW9qcy1jb250cmliLW1lZGlhLXNvdXJjZXMvbm9kZV9tb2R1bGVzL3ZpZGVvanMtdnR0LmpzL2xpYi9icm93c2VyLWluZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhLG1CQUFPLENBQUMsdUdBQWU7O0FBRXBDO0FBQ0EsVUFBVSxtQkFBTyxDQUFDLDJHQUFVO0FBQzVCLFVBQVUsbUJBQU8sQ0FBQyxpSEFBYTtBQUMvQixhQUFhLG1CQUFPLENBQUMsdUhBQWdCO0FBQ3JDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktdjAtcHJvamVjdC8uL25vZGVfbW9kdWxlcy92aWRlb2pzLWNvbnRyaWItbWVkaWEtc291cmNlcy9ub2RlX21vZHVsZXMvdmlkZW9qcy12dHQuanMvbGliL2Jyb3dzZXItaW5kZXguanM/NWRlNiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAyMDEzIHZ0dC5qcyBDb250cmlidXRvcnNcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8vIERlZmF1bHQgZXhwb3J0cyBmb3IgTm9kZS4gRXhwb3J0IHRoZSBleHRlbmRlZCB2ZXJzaW9ucyBvZiBWVFRDdWUgYW5kXG4vLyBWVFRSZWdpb24gaW4gTm9kZSBzaW5jZSB3ZSBsaWtlbHkgd2FudCB0aGUgY2FwYWJpbGl0eSB0byBjb252ZXJ0IGJhY2sgYW5kXG4vLyBmb3J0aCBiZXR3ZWVuIEpTT04uIElmIHdlIGRvbid0IHRoZW4gaXQncyBub3QgdGhhdCBiaWcgb2YgYSBkZWFsIHNpbmNlIHdlJ3JlXG4vLyBvZmYgYnJvd3Nlci5cblxudmFyIHdpbmRvdyA9IHJlcXVpcmUoJ2dsb2JhbC93aW5kb3cnKTtcblxudmFyIHZ0dGpzID0gbW9kdWxlLmV4cG9ydHMgPSB7XG4gIFdlYlZUVDogcmVxdWlyZShcIi4vdnR0LmpzXCIpLFxuICBWVFRDdWU6IHJlcXVpcmUoXCIuL3Z0dGN1ZS5qc1wiKSxcbiAgVlRUUmVnaW9uOiByZXF1aXJlKFwiLi92dHRyZWdpb24uanNcIilcbn07XG5cbndpbmRvdy52dHRqcyA9IHZ0dGpzO1xud2luZG93LldlYlZUVCA9IHZ0dGpzLldlYlZUVDtcblxudmFyIGN1ZVNoaW0gPSB2dHRqcy5WVFRDdWU7XG52YXIgcmVnaW9uU2hpbSA9IHZ0dGpzLlZUVFJlZ2lvbjtcbnZhciBuYXRpdmVWVFRDdWUgPSB3aW5kb3cuVlRUQ3VlO1xudmFyIG5hdGl2ZVZUVFJlZ2lvbiA9IHdpbmRvdy5WVFRSZWdpb247XG5cbnZ0dGpzLnNoaW0gPSBmdW5jdGlvbigpIHtcbiAgd2luZG93LlZUVEN1ZSA9IGN1ZVNoaW07XG4gIHdpbmRvdy5WVFRSZWdpb24gPSByZWdpb25TaGltO1xufTtcblxudnR0anMucmVzdG9yZSA9IGZ1bmN0aW9uKCkge1xuICB3aW5kb3cuVlRUQ3VlID0gbmF0aXZlVlRUQ3VlO1xuICB3aW5kb3cuVlRUUmVnaW9uID0gbmF0aXZlVlRUUmVnaW9uO1xufTtcblxuaWYgKCF3aW5kb3cuVlRUQ3VlKSB7XG4gIHZ0dGpzLnNoaW0oKTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/videojs-contrib-media-sources/node_modules/videojs-vtt.js/lib/browser-index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/videojs-contrib-media-sources/node_modules/videojs-vtt.js/lib/vtt.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/videojs-contrib-media-sources/node_modules/videojs-vtt.js/lib/vtt.js ***!
  \*******************************************************************************************/
/***/ ((module) => {

eval("/**\n * Copyright 2013 vtt.js Contributors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/* -*- Mode: Java; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */\n/* vim: set shiftwidth=2 tabstop=2 autoindent cindent expandtab: */\nvar _objCreate = Object.create || (function() {\n  function F() {}\n  return function(o) {\n    if (arguments.length !== 1) {\n      throw new Error('Object.create shim only accepts one parameter.');\n    }\n    F.prototype = o;\n    return new F();\n  };\n})();\n\n// Creates a new ParserError object from an errorData object. The errorData\n// object should have default code and message properties. The default message\n// property can be overriden by passing in a message parameter.\n// See ParsingError.Errors below for acceptable errors.\nfunction ParsingError(errorData, message) {\n  this.name = \"ParsingError\";\n  this.code = errorData.code;\n  this.message = message || errorData.message;\n}\nParsingError.prototype = _objCreate(Error.prototype);\nParsingError.prototype.constructor = ParsingError;\n\n// ParsingError metadata for acceptable ParsingErrors.\nParsingError.Errors = {\n  BadSignature: {\n    code: 0,\n    message: \"Malformed WebVTT signature.\"\n  },\n  BadTimeStamp: {\n    code: 1,\n    message: \"Malformed time stamp.\"\n  }\n};\n\n// Try to parse input as a time stamp.\nfunction parseTimeStamp(input) {\n\n  function computeSeconds(h, m, s, f) {\n    return (h | 0) * 3600 + (m | 0) * 60 + (s | 0) + (f | 0) / 1000;\n  }\n\n  var m = input.match(/^(\\d+):(\\d{2})(:\\d{2})?\\.(\\d{3})/);\n  if (!m) {\n    return null;\n  }\n\n  if (m[3]) {\n    // Timestamp takes the form of [hours]:[minutes]:[seconds].[milliseconds]\n    return computeSeconds(m[1], m[2], m[3].replace(\":\", \"\"), m[4]);\n  } else if (m[1] > 59) {\n    // Timestamp takes the form of [hours]:[minutes].[milliseconds]\n    // First position is hours as it's over 59.\n    return computeSeconds(m[1], m[2], 0,  m[4]);\n  } else {\n    // Timestamp takes the form of [minutes]:[seconds].[milliseconds]\n    return computeSeconds(0, m[1], m[2], m[4]);\n  }\n}\n\n// A settings object holds key/value pairs and will ignore anything but the first\n// assignment to a specific key.\nfunction Settings() {\n  this.values = _objCreate(null);\n}\n\nSettings.prototype = {\n  // Only accept the first assignment to any key.\n  set: function(k, v) {\n    if (!this.get(k) && v !== \"\") {\n      this.values[k] = v;\n    }\n  },\n  // Return the value for a key, or a default value.\n  // If 'defaultKey' is passed then 'dflt' is assumed to be an object with\n  // a number of possible default values as properties where 'defaultKey' is\n  // the key of the property that will be chosen; otherwise it's assumed to be\n  // a single value.\n  get: function(k, dflt, defaultKey) {\n    if (defaultKey) {\n      return this.has(k) ? this.values[k] : dflt[defaultKey];\n    }\n    return this.has(k) ? this.values[k] : dflt;\n  },\n  // Check whether we have a value for a key.\n  has: function(k) {\n    return k in this.values;\n  },\n  // Accept a setting if its one of the given alternatives.\n  alt: function(k, v, a) {\n    for (var n = 0; n < a.length; ++n) {\n      if (v === a[n]) {\n        this.set(k, v);\n        break;\n      }\n    }\n  },\n  // Accept a setting if its a valid (signed) integer.\n  integer: function(k, v) {\n    if (/^-?\\d+$/.test(v)) { // integer\n      this.set(k, parseInt(v, 10));\n    }\n  },\n  // Accept a setting if its a valid percentage.\n  percent: function(k, v) {\n    var m;\n    if ((m = v.match(/^([\\d]{1,3})(\\.[\\d]*)?%$/))) {\n      v = parseFloat(v);\n      if (v >= 0 && v <= 100) {\n        this.set(k, v);\n        return true;\n      }\n    }\n    return false;\n  }\n};\n\n// Helper function to parse input into groups separated by 'groupDelim', and\n// interprete each group as a key/value pair separated by 'keyValueDelim'.\nfunction parseOptions(input, callback, keyValueDelim, groupDelim) {\n  var groups = groupDelim ? input.split(groupDelim) : [input];\n  for (var i in groups) {\n    if (typeof groups[i] !== \"string\") {\n      continue;\n    }\n    var kv = groups[i].split(keyValueDelim);\n    if (kv.length !== 2) {\n      continue;\n    }\n    var k = kv[0];\n    var v = kv[1];\n    callback(k, v);\n  }\n}\n\nfunction parseCue(input, cue, regionList) {\n  // Remember the original input if we need to throw an error.\n  var oInput = input;\n  // 4.1 WebVTT timestamp\n  function consumeTimeStamp() {\n    var ts = parseTimeStamp(input);\n    if (ts === null) {\n      throw new ParsingError(ParsingError.Errors.BadTimeStamp,\n                            \"Malformed timestamp: \" + oInput);\n    }\n    // Remove time stamp from input.\n    input = input.replace(/^[^\\sa-zA-Z-]+/, \"\");\n    return ts;\n  }\n\n  // 4.4.2 WebVTT cue settings\n  function consumeCueSettings(input, cue) {\n    var settings = new Settings();\n\n    parseOptions(input, function (k, v) {\n      switch (k) {\n      case \"region\":\n        // Find the last region we parsed with the same region id.\n        for (var i = regionList.length - 1; i >= 0; i--) {\n          if (regionList[i].id === v) {\n            settings.set(k, regionList[i].region);\n            break;\n          }\n        }\n        break;\n      case \"vertical\":\n        settings.alt(k, v, [\"rl\", \"lr\"]);\n        break;\n      case \"line\":\n        var vals = v.split(\",\"),\n            vals0 = vals[0];\n        settings.integer(k, vals0);\n        settings.percent(k, vals0) ? settings.set(\"snapToLines\", false) : null;\n        settings.alt(k, vals0, [\"auto\"]);\n        if (vals.length === 2) {\n          settings.alt(\"lineAlign\", vals[1], [\"start\", \"middle\", \"end\"]);\n        }\n        break;\n      case \"position\":\n        vals = v.split(\",\");\n        settings.percent(k, vals[0]);\n        if (vals.length === 2) {\n          settings.alt(\"positionAlign\", vals[1], [\"start\", \"middle\", \"end\"]);\n        }\n        break;\n      case \"size\":\n        settings.percent(k, v);\n        break;\n      case \"align\":\n        settings.alt(k, v, [\"start\", \"middle\", \"end\", \"left\", \"right\"]);\n        break;\n      }\n    }, /:/, /\\s/);\n\n    // Apply default values for any missing fields.\n    cue.region = settings.get(\"region\", null);\n    cue.vertical = settings.get(\"vertical\", \"\");\n    cue.line = settings.get(\"line\", \"auto\");\n    cue.lineAlign = settings.get(\"lineAlign\", \"start\");\n    cue.snapToLines = settings.get(\"snapToLines\", true);\n    cue.size = settings.get(\"size\", 100);\n    cue.align = settings.get(\"align\", \"middle\");\n    cue.position = settings.get(\"position\", {\n      start: 0,\n      left: 0,\n      middle: 50,\n      end: 100,\n      right: 100\n    }, cue.align);\n    cue.positionAlign = settings.get(\"positionAlign\", {\n      start: \"start\",\n      left: \"start\",\n      middle: \"middle\",\n      end: \"end\",\n      right: \"end\"\n    }, cue.align);\n  }\n\n  function skipWhitespace() {\n    input = input.replace(/^\\s+/, \"\");\n  }\n\n  // 4.1 WebVTT cue timings.\n  skipWhitespace();\n  cue.startTime = consumeTimeStamp();   // (1) collect cue start time\n  skipWhitespace();\n  if (input.substr(0, 3) !== \"-->\") {     // (3) next characters must match \"-->\"\n    throw new ParsingError(ParsingError.Errors.BadTimeStamp,\n                           \"Malformed time stamp (time stamps must be separated by '-->'): \" +\n                           oInput);\n  }\n  input = input.substr(3);\n  skipWhitespace();\n  cue.endTime = consumeTimeStamp();     // (5) collect cue end time\n\n  // 4.1 WebVTT cue settings list.\n  skipWhitespace();\n  consumeCueSettings(input, cue);\n}\n\nvar ESCAPE = {\n  \"&amp;\": \"&\",\n  \"&lt;\": \"<\",\n  \"&gt;\": \">\",\n  \"&lrm;\": \"\\u200e\",\n  \"&rlm;\": \"\\u200f\",\n  \"&nbsp;\": \"\\u00a0\"\n};\n\nvar TAG_NAME = {\n  c: \"span\",\n  i: \"i\",\n  b: \"b\",\n  u: \"u\",\n  ruby: \"ruby\",\n  rt: \"rt\",\n  v: \"span\",\n  lang: \"span\"\n};\n\nvar TAG_ANNOTATION = {\n  v: \"title\",\n  lang: \"lang\"\n};\n\nvar NEEDS_PARENT = {\n  rt: \"ruby\"\n};\n\n// Parse content into a document fragment.\nfunction parseContent(window, input) {\n  function nextToken() {\n    // Check for end-of-string.\n    if (!input) {\n      return null;\n    }\n\n    // Consume 'n' characters from the input.\n    function consume(result) {\n      input = input.substr(result.length);\n      return result;\n    }\n\n    var m = input.match(/^([^<]*)(<[^>]*>?)?/);\n    // If there is some text before the next tag, return it, otherwise return\n    // the tag.\n    return consume(m[1] ? m[1] : m[2]);\n  }\n\n  // Unescape a string 's'.\n  function unescape1(e) {\n    return ESCAPE[e];\n  }\n  function unescape(s) {\n    while ((m = s.match(/&(amp|lt|gt|lrm|rlm|nbsp);/))) {\n      s = s.replace(m[0], unescape1);\n    }\n    return s;\n  }\n\n  function shouldAdd(current, element) {\n    return !NEEDS_PARENT[element.localName] ||\n           NEEDS_PARENT[element.localName] === current.localName;\n  }\n\n  // Create an element for this tag.\n  function createElement(type, annotation) {\n    var tagName = TAG_NAME[type];\n    if (!tagName) {\n      return null;\n    }\n    var element = window.document.createElement(tagName);\n    element.localName = tagName;\n    var name = TAG_ANNOTATION[type];\n    if (name && annotation) {\n      element[name] = annotation.trim();\n    }\n    return element;\n  }\n\n  var rootDiv = window.document.createElement(\"div\"),\n      current = rootDiv,\n      t,\n      tagStack = [];\n\n  while ((t = nextToken()) !== null) {\n    if (t[0] === '<') {\n      if (t[1] === \"/\") {\n        // If the closing tag matches, move back up to the parent node.\n        if (tagStack.length &&\n            tagStack[tagStack.length - 1] === t.substr(2).replace(\">\", \"\")) {\n          tagStack.pop();\n          current = current.parentNode;\n        }\n        // Otherwise just ignore the end tag.\n        continue;\n      }\n      var ts = parseTimeStamp(t.substr(1, t.length - 2));\n      var node;\n      if (ts) {\n        // Timestamps are lead nodes as well.\n        node = window.document.createProcessingInstruction(\"timestamp\", ts);\n        current.appendChild(node);\n        continue;\n      }\n      var m = t.match(/^<([^.\\s/0-9>]+)(\\.[^\\s\\\\>]+)?([^>\\\\]+)?(\\\\?)>?$/);\n      // If we can't parse the tag, skip to the next tag.\n      if (!m) {\n        continue;\n      }\n      // Try to construct an element, and ignore the tag if we couldn't.\n      node = createElement(m[1], m[3]);\n      if (!node) {\n        continue;\n      }\n      // Determine if the tag should be added based on the context of where it\n      // is placed in the cuetext.\n      if (!shouldAdd(current, node)) {\n        continue;\n      }\n      // Set the class list (as a list of classes, separated by space).\n      if (m[2]) {\n        node.className = m[2].substr(1).replace('.', ' ');\n      }\n      // Append the node to the current node, and enter the scope of the new\n      // node.\n      tagStack.push(m[1]);\n      current.appendChild(node);\n      current = node;\n      continue;\n    }\n\n    // Text nodes are leaf nodes.\n    current.appendChild(window.document.createTextNode(unescape(t)));\n  }\n\n  return rootDiv;\n}\n\n// This is a list of all the Unicode characters that have a strong\n// right-to-left category. What this means is that these characters are\n// written right-to-left for sure. It was generated by pulling all the strong\n// right-to-left characters out of the Unicode data table. That table can\n// found at: http://www.unicode.org/Public/UNIDATA/UnicodeData.txt\nvar strongRTLRanges = [[0x5be, 0x5be], [0x5c0, 0x5c0], [0x5c3, 0x5c3], [0x5c6, 0x5c6],\n [0x5d0, 0x5ea], [0x5f0, 0x5f4], [0x608, 0x608], [0x60b, 0x60b], [0x60d, 0x60d],\n [0x61b, 0x61b], [0x61e, 0x64a], [0x66d, 0x66f], [0x671, 0x6d5], [0x6e5, 0x6e6],\n [0x6ee, 0x6ef], [0x6fa, 0x70d], [0x70f, 0x710], [0x712, 0x72f], [0x74d, 0x7a5],\n [0x7b1, 0x7b1], [0x7c0, 0x7ea], [0x7f4, 0x7f5], [0x7fa, 0x7fa], [0x800, 0x815],\n [0x81a, 0x81a], [0x824, 0x824], [0x828, 0x828], [0x830, 0x83e], [0x840, 0x858],\n [0x85e, 0x85e], [0x8a0, 0x8a0], [0x8a2, 0x8ac], [0x200f, 0x200f],\n [0xfb1d, 0xfb1d], [0xfb1f, 0xfb28], [0xfb2a, 0xfb36], [0xfb38, 0xfb3c],\n [0xfb3e, 0xfb3e], [0xfb40, 0xfb41], [0xfb43, 0xfb44], [0xfb46, 0xfbc1],\n [0xfbd3, 0xfd3d], [0xfd50, 0xfd8f], [0xfd92, 0xfdc7], [0xfdf0, 0xfdfc],\n [0xfe70, 0xfe74], [0xfe76, 0xfefc], [0x10800, 0x10805], [0x10808, 0x10808],\n [0x1080a, 0x10835], [0x10837, 0x10838], [0x1083c, 0x1083c], [0x1083f, 0x10855],\n [0x10857, 0x1085f], [0x10900, 0x1091b], [0x10920, 0x10939], [0x1093f, 0x1093f],\n [0x10980, 0x109b7], [0x109be, 0x109bf], [0x10a00, 0x10a00], [0x10a10, 0x10a13],\n [0x10a15, 0x10a17], [0x10a19, 0x10a33], [0x10a40, 0x10a47], [0x10a50, 0x10a58],\n [0x10a60, 0x10a7f], [0x10b00, 0x10b35], [0x10b40, 0x10b55], [0x10b58, 0x10b72],\n [0x10b78, 0x10b7f], [0x10c00, 0x10c48], [0x1ee00, 0x1ee03], [0x1ee05, 0x1ee1f],\n [0x1ee21, 0x1ee22], [0x1ee24, 0x1ee24], [0x1ee27, 0x1ee27], [0x1ee29, 0x1ee32],\n [0x1ee34, 0x1ee37], [0x1ee39, 0x1ee39], [0x1ee3b, 0x1ee3b], [0x1ee42, 0x1ee42],\n [0x1ee47, 0x1ee47], [0x1ee49, 0x1ee49], [0x1ee4b, 0x1ee4b], [0x1ee4d, 0x1ee4f],\n [0x1ee51, 0x1ee52], [0x1ee54, 0x1ee54], [0x1ee57, 0x1ee57], [0x1ee59, 0x1ee59],\n [0x1ee5b, 0x1ee5b], [0x1ee5d, 0x1ee5d], [0x1ee5f, 0x1ee5f], [0x1ee61, 0x1ee62],\n [0x1ee64, 0x1ee64], [0x1ee67, 0x1ee6a], [0x1ee6c, 0x1ee72], [0x1ee74, 0x1ee77],\n [0x1ee79, 0x1ee7c], [0x1ee7e, 0x1ee7e], [0x1ee80, 0x1ee89], [0x1ee8b, 0x1ee9b],\n [0x1eea1, 0x1eea3], [0x1eea5, 0x1eea9], [0x1eeab, 0x1eebb], [0x10fffd, 0x10fffd]];\n\nfunction isStrongRTLChar(charCode) {\n  for (var i = 0; i < strongRTLRanges.length; i++) {\n    var currentRange = strongRTLRanges[i];\n    if (charCode >= currentRange[0] && charCode <= currentRange[1]) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction determineBidi(cueDiv) {\n  var nodeStack = [],\n      text = \"\",\n      charCode;\n\n  if (!cueDiv || !cueDiv.childNodes) {\n    return \"ltr\";\n  }\n\n  function pushNodes(nodeStack, node) {\n    for (var i = node.childNodes.length - 1; i >= 0; i--) {\n      nodeStack.push(node.childNodes[i]);\n    }\n  }\n\n  function nextTextNode(nodeStack) {\n    if (!nodeStack || !nodeStack.length) {\n      return null;\n    }\n\n    var node = nodeStack.pop(),\n        text = node.textContent || node.innerText;\n    if (text) {\n      // TODO: This should match all unicode type B characters (paragraph\n      // separator characters). See issue #115.\n      var m = text.match(/^.*(\\n|\\r)/);\n      if (m) {\n        nodeStack.length = 0;\n        return m[0];\n      }\n      return text;\n    }\n    if (node.tagName === \"ruby\") {\n      return nextTextNode(nodeStack);\n    }\n    if (node.childNodes) {\n      pushNodes(nodeStack, node);\n      return nextTextNode(nodeStack);\n    }\n  }\n\n  pushNodes(nodeStack, cueDiv);\n  while ((text = nextTextNode(nodeStack))) {\n    for (var i = 0; i < text.length; i++) {\n      charCode = text.charCodeAt(i);\n      if (isStrongRTLChar(charCode)) {\n        return \"rtl\";\n      }\n    }\n  }\n  return \"ltr\";\n}\n\nfunction computeLinePos(cue) {\n  if (typeof cue.line === \"number\" &&\n      (cue.snapToLines || (cue.line >= 0 && cue.line <= 100))) {\n    return cue.line;\n  }\n  if (!cue.track || !cue.track.textTrackList ||\n      !cue.track.textTrackList.mediaElement) {\n    return -1;\n  }\n  var track = cue.track,\n      trackList = track.textTrackList,\n      count = 0;\n  for (var i = 0; i < trackList.length && trackList[i] !== track; i++) {\n    if (trackList[i].mode === \"showing\") {\n      count++;\n    }\n  }\n  return ++count * -1;\n}\n\nfunction StyleBox() {\n}\n\n// Apply styles to a div. If there is no div passed then it defaults to the\n// div on 'this'.\nStyleBox.prototype.applyStyles = function(styles, div) {\n  div = div || this.div;\n  for (var prop in styles) {\n    if (styles.hasOwnProperty(prop)) {\n      div.style[prop] = styles[prop];\n    }\n  }\n};\n\nStyleBox.prototype.formatStyle = function(val, unit) {\n  return val === 0 ? 0 : val + unit;\n};\n\n// Constructs the computed display state of the cue (a div). Places the div\n// into the overlay which should be a block level element (usually a div).\nfunction CueStyleBox(window, cue, styleOptions) {\n  var isIE8 = (/MSIE\\s8\\.0/).test(navigator.userAgent);\n  var color = \"rgba(255, 255, 255, 1)\";\n  var backgroundColor = \"rgba(0, 0, 0, 0.8)\";\n\n  if (isIE8) {\n    color = \"rgb(255, 255, 255)\";\n    backgroundColor = \"rgb(0, 0, 0)\";\n  }\n\n  StyleBox.call(this);\n  this.cue = cue;\n\n  // Parse our cue's text into a DOM tree rooted at 'cueDiv'. This div will\n  // have inline positioning and will function as the cue background box.\n  this.cueDiv = parseContent(window, cue.text);\n  var styles = {\n    color: color,\n    backgroundColor: backgroundColor,\n    position: \"relative\",\n    left: 0,\n    right: 0,\n    top: 0,\n    bottom: 0,\n    display: \"inline\"\n  };\n\n  if (!isIE8) {\n    styles.writingMode = cue.vertical === \"\" ? \"horizontal-tb\"\n                                             : cue.vertical === \"lr\" ? \"vertical-lr\"\n                                                                     : \"vertical-rl\";\n    styles.unicodeBidi = \"plaintext\";\n  }\n  this.applyStyles(styles, this.cueDiv);\n\n  // Create an absolutely positioned div that will be used to position the cue\n  // div. Note, all WebVTT cue-setting alignments are equivalent to the CSS\n  // mirrors of them except \"middle\" which is \"center\" in CSS.\n  this.div = window.document.createElement(\"div\");\n  styles = {\n    textAlign: cue.align === \"middle\" ? \"center\" : cue.align,\n    font: styleOptions.font,\n    whiteSpace: \"pre-line\",\n    position: \"absolute\"\n  };\n\n  if (!isIE8) {\n    styles.direction = determineBidi(this.cueDiv);\n    styles.writingMode = cue.vertical === \"\" ? \"horizontal-tb\"\n                                             : cue.vertical === \"lr\" ? \"vertical-lr\"\n                                                                     : \"vertical-rl\".\n    stylesunicodeBidi =  \"plaintext\";\n  }\n\n  this.applyStyles(styles);\n\n  this.div.appendChild(this.cueDiv);\n\n  // Calculate the distance from the reference edge of the viewport to the text\n  // position of the cue box. The reference edge will be resolved later when\n  // the box orientation styles are applied.\n  var textPos = 0;\n  switch (cue.positionAlign) {\n  case \"start\":\n    textPos = cue.position;\n    break;\n  case \"middle\":\n    textPos = cue.position - (cue.size / 2);\n    break;\n  case \"end\":\n    textPos = cue.position - cue.size;\n    break;\n  }\n\n  // Horizontal box orientation; textPos is the distance from the left edge of the\n  // area to the left edge of the box and cue.size is the distance extending to\n  // the right from there.\n  if (cue.vertical === \"\") {\n    this.applyStyles({\n      left:  this.formatStyle(textPos, \"%\"),\n      width: this.formatStyle(cue.size, \"%\")\n    });\n  // Vertical box orientation; textPos is the distance from the top edge of the\n  // area to the top edge of the box and cue.size is the height extending\n  // downwards from there.\n  } else {\n    this.applyStyles({\n      top: this.formatStyle(textPos, \"%\"),\n      height: this.formatStyle(cue.size, \"%\")\n    });\n  }\n\n  this.move = function(box) {\n    this.applyStyles({\n      top: this.formatStyle(box.top, \"px\"),\n      bottom: this.formatStyle(box.bottom, \"px\"),\n      left: this.formatStyle(box.left, \"px\"),\n      right: this.formatStyle(box.right, \"px\"),\n      height: this.formatStyle(box.height, \"px\"),\n      width: this.formatStyle(box.width, \"px\")\n    });\n  };\n}\nCueStyleBox.prototype = _objCreate(StyleBox.prototype);\nCueStyleBox.prototype.constructor = CueStyleBox;\n\n// Represents the co-ordinates of an Element in a way that we can easily\n// compute things with such as if it overlaps or intersects with another Element.\n// Can initialize it with either a StyleBox or another BoxPosition.\nfunction BoxPosition(obj) {\n  var isIE8 = (/MSIE\\s8\\.0/).test(navigator.userAgent);\n\n  // Either a BoxPosition was passed in and we need to copy it, or a StyleBox\n  // was passed in and we need to copy the results of 'getBoundingClientRect'\n  // as the object returned is readonly. All co-ordinate values are in reference\n  // to the viewport origin (top left).\n  var lh, height, width, top;\n  if (obj.div) {\n    height = obj.div.offsetHeight;\n    width = obj.div.offsetWidth;\n    top = obj.div.offsetTop;\n\n    var rects = (rects = obj.div.childNodes) && (rects = rects[0]) &&\n                rects.getClientRects && rects.getClientRects();\n    obj = obj.div.getBoundingClientRect();\n    // In certain cases the outter div will be slightly larger then the sum of\n    // the inner div's lines. This could be due to bold text, etc, on some platforms.\n    // In this case we should get the average line height and use that. This will\n    // result in the desired behaviour.\n    lh = rects ? Math.max((rects[0] && rects[0].height) || 0, obj.height / rects.length)\n               : 0;\n\n  }\n  this.left = obj.left;\n  this.right = obj.right;\n  this.top = obj.top || top;\n  this.height = obj.height || height;\n  this.bottom = obj.bottom || (top + (obj.height || height));\n  this.width = obj.width || width;\n  this.lineHeight = lh !== undefined ? lh : obj.lineHeight;\n\n  if (isIE8 && !this.lineHeight) {\n    this.lineHeight = 13;\n  }\n}\n\n// Move the box along a particular axis. Optionally pass in an amount to move\n// the box. If no amount is passed then the default is the line height of the\n// box.\nBoxPosition.prototype.move = function(axis, toMove) {\n  toMove = toMove !== undefined ? toMove : this.lineHeight;\n  switch (axis) {\n  case \"+x\":\n    this.left += toMove;\n    this.right += toMove;\n    break;\n  case \"-x\":\n    this.left -= toMove;\n    this.right -= toMove;\n    break;\n  case \"+y\":\n    this.top += toMove;\n    this.bottom += toMove;\n    break;\n  case \"-y\":\n    this.top -= toMove;\n    this.bottom -= toMove;\n    break;\n  }\n};\n\n// Check if this box overlaps another box, b2.\nBoxPosition.prototype.overlaps = function(b2) {\n  return this.left < b2.right &&\n         this.right > b2.left &&\n         this.top < b2.bottom &&\n         this.bottom > b2.top;\n};\n\n// Check if this box overlaps any other boxes in boxes.\nBoxPosition.prototype.overlapsAny = function(boxes) {\n  for (var i = 0; i < boxes.length; i++) {\n    if (this.overlaps(boxes[i])) {\n      return true;\n    }\n  }\n  return false;\n};\n\n// Check if this box is within another box.\nBoxPosition.prototype.within = function(container) {\n  return this.top >= container.top &&\n         this.bottom <= container.bottom &&\n         this.left >= container.left &&\n         this.right <= container.right;\n};\n\n// Check if this box is entirely within the container or it is overlapping\n// on the edge opposite of the axis direction passed. For example, if \"+x\" is\n// passed and the box is overlapping on the left edge of the container, then\n// return true.\nBoxPosition.prototype.overlapsOppositeAxis = function(container, axis) {\n  switch (axis) {\n  case \"+x\":\n    return this.left < container.left;\n  case \"-x\":\n    return this.right > container.right;\n  case \"+y\":\n    return this.top < container.top;\n  case \"-y\":\n    return this.bottom > container.bottom;\n  }\n};\n\n// Find the percentage of the area that this box is overlapping with another\n// box.\nBoxPosition.prototype.intersectPercentage = function(b2) {\n  var x = Math.max(0, Math.min(this.right, b2.right) - Math.max(this.left, b2.left)),\n      y = Math.max(0, Math.min(this.bottom, b2.bottom) - Math.max(this.top, b2.top)),\n      intersectArea = x * y;\n  return intersectArea / (this.height * this.width);\n};\n\n// Convert the positions from this box to CSS compatible positions using\n// the reference container's positions. This has to be done because this\n// box's positions are in reference to the viewport origin, whereas, CSS\n// values are in referecne to their respective edges.\nBoxPosition.prototype.toCSSCompatValues = function(reference) {\n  return {\n    top: this.top - reference.top,\n    bottom: reference.bottom - this.bottom,\n    left: this.left - reference.left,\n    right: reference.right - this.right,\n    height: this.height,\n    width: this.width\n  };\n};\n\n// Get an object that represents the box's position without anything extra.\n// Can pass a StyleBox, HTMLElement, or another BoxPositon.\nBoxPosition.getSimpleBoxPosition = function(obj) {\n  var height = obj.div ? obj.div.offsetHeight : obj.tagName ? obj.offsetHeight : 0;\n  var width = obj.div ? obj.div.offsetWidth : obj.tagName ? obj.offsetWidth : 0;\n  var top = obj.div ? obj.div.offsetTop : obj.tagName ? obj.offsetTop : 0;\n\n  obj = obj.div ? obj.div.getBoundingClientRect() :\n                obj.tagName ? obj.getBoundingClientRect() : obj;\n  var ret = {\n    left: obj.left,\n    right: obj.right,\n    top: obj.top || top,\n    height: obj.height || height,\n    bottom: obj.bottom || (top + (obj.height || height)),\n    width: obj.width || width\n  };\n  return ret;\n};\n\n// Move a StyleBox to its specified, or next best, position. The containerBox\n// is the box that contains the StyleBox, such as a div. boxPositions are\n// a list of other boxes that the styleBox can't overlap with.\nfunction moveBoxToLinePosition(window, styleBox, containerBox, boxPositions) {\n\n  // Find the best position for a cue box, b, on the video. The axis parameter\n  // is a list of axis, the order of which, it will move the box along. For example:\n  // Passing [\"+x\", \"-x\"] will move the box first along the x axis in the positive\n  // direction. If it doesn't find a good position for it there it will then move\n  // it along the x axis in the negative direction.\n  function findBestPosition(b, axis) {\n    var bestPosition,\n        specifiedPosition = new BoxPosition(b),\n        percentage = 1; // Highest possible so the first thing we get is better.\n\n    for (var i = 0; i < axis.length; i++) {\n      while (b.overlapsOppositeAxis(containerBox, axis[i]) ||\n             (b.within(containerBox) && b.overlapsAny(boxPositions))) {\n        b.move(axis[i]);\n      }\n      // We found a spot where we aren't overlapping anything. This is our\n      // best position.\n      if (b.within(containerBox)) {\n        return b;\n      }\n      var p = b.intersectPercentage(containerBox);\n      // If we're outside the container box less then we were on our last try\n      // then remember this position as the best position.\n      if (percentage > p) {\n        bestPosition = new BoxPosition(b);\n        percentage = p;\n      }\n      // Reset the box position to the specified position.\n      b = new BoxPosition(specifiedPosition);\n    }\n    return bestPosition || specifiedPosition;\n  }\n\n  var boxPosition = new BoxPosition(styleBox),\n      cue = styleBox.cue,\n      linePos = computeLinePos(cue),\n      axis = [];\n\n  // If we have a line number to align the cue to.\n  if (cue.snapToLines) {\n    var size;\n    switch (cue.vertical) {\n    case \"\":\n      axis = [ \"+y\", \"-y\" ];\n      size = \"height\";\n      break;\n    case \"rl\":\n      axis = [ \"+x\", \"-x\" ];\n      size = \"width\";\n      break;\n    case \"lr\":\n      axis = [ \"-x\", \"+x\" ];\n      size = \"width\";\n      break;\n    }\n\n    var step = boxPosition.lineHeight,\n        position = step * Math.round(linePos),\n        maxPosition = containerBox[size] + step,\n        initialAxis = axis[0];\n\n    // If the specified intial position is greater then the max position then\n    // clamp the box to the amount of steps it would take for the box to\n    // reach the max position.\n    if (Math.abs(position) > maxPosition) {\n      position = position < 0 ? -1 : 1;\n      position *= Math.ceil(maxPosition / step) * step;\n    }\n\n    // If computed line position returns negative then line numbers are\n    // relative to the bottom of the video instead of the top. Therefore, we\n    // need to increase our initial position by the length or width of the\n    // video, depending on the writing direction, and reverse our axis directions.\n    if (linePos < 0) {\n      position += cue.vertical === \"\" ? containerBox.height : containerBox.width;\n      axis = axis.reverse();\n    }\n\n    // Move the box to the specified position. This may not be its best\n    // position.\n    boxPosition.move(initialAxis, position);\n\n  } else {\n    // If we have a percentage line value for the cue.\n    var calculatedPercentage = (boxPosition.lineHeight / containerBox.height) * 100;\n\n    switch (cue.lineAlign) {\n    case \"middle\":\n      linePos -= (calculatedPercentage / 2);\n      break;\n    case \"end\":\n      linePos -= calculatedPercentage;\n      break;\n    }\n\n    // Apply initial line position to the cue box.\n    switch (cue.vertical) {\n    case \"\":\n      styleBox.applyStyles({\n        top: styleBox.formatStyle(linePos, \"%\")\n      });\n      break;\n    case \"rl\":\n      styleBox.applyStyles({\n        left: styleBox.formatStyle(linePos, \"%\")\n      });\n      break;\n    case \"lr\":\n      styleBox.applyStyles({\n        right: styleBox.formatStyle(linePos, \"%\")\n      });\n      break;\n    }\n\n    axis = [ \"+y\", \"-x\", \"+x\", \"-y\" ];\n\n    // Get the box position again after we've applied the specified positioning\n    // to it.\n    boxPosition = new BoxPosition(styleBox);\n  }\n\n  var bestPosition = findBestPosition(boxPosition, axis);\n  styleBox.move(bestPosition.toCSSCompatValues(containerBox));\n}\n\nfunction WebVTT() {\n  // Nothing\n}\n\n// Helper to allow strings to be decoded instead of the default binary utf8 data.\nWebVTT.StringDecoder = function() {\n  return {\n    decode: function(data) {\n      if (!data) {\n        return \"\";\n      }\n      if (typeof data !== \"string\") {\n        throw new Error(\"Error - expected string data.\");\n      }\n      return decodeURIComponent(encodeURIComponent(data));\n    }\n  };\n};\n\nWebVTT.convertCueToDOMTree = function(window, cuetext) {\n  if (!window || !cuetext) {\n    return null;\n  }\n  return parseContent(window, cuetext);\n};\n\nvar FONT_SIZE_PERCENT = 0.05;\nvar FONT_STYLE = \"sans-serif\";\nvar CUE_BACKGROUND_PADDING = \"1.5%\";\n\n// Runs the processing model over the cues and regions passed to it.\n// @param overlay A block level element (usually a div) that the computed cues\n//                and regions will be placed into.\nWebVTT.processCues = function(window, cues, overlay) {\n  if (!window || !cues || !overlay) {\n    return null;\n  }\n\n  // Remove all previous children.\n  while (overlay.firstChild) {\n    overlay.removeChild(overlay.firstChild);\n  }\n\n  var paddedOverlay = window.document.createElement(\"div\");\n  paddedOverlay.style.position = \"absolute\";\n  paddedOverlay.style.left = \"0\";\n  paddedOverlay.style.right = \"0\";\n  paddedOverlay.style.top = \"0\";\n  paddedOverlay.style.bottom = \"0\";\n  paddedOverlay.style.margin = CUE_BACKGROUND_PADDING;\n  overlay.appendChild(paddedOverlay);\n\n  // Determine if we need to compute the display states of the cues. This could\n  // be the case if a cue's state has been changed since the last computation or\n  // if it has not been computed yet.\n  function shouldCompute(cues) {\n    for (var i = 0; i < cues.length; i++) {\n      if (cues[i].hasBeenReset || !cues[i].displayState) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  // We don't need to recompute the cues' display states. Just reuse them.\n  if (!shouldCompute(cues)) {\n    for (var i = 0; i < cues.length; i++) {\n      paddedOverlay.appendChild(cues[i].displayState);\n    }\n    return;\n  }\n\n  var boxPositions = [],\n      containerBox = BoxPosition.getSimpleBoxPosition(paddedOverlay),\n      fontSize = Math.round(containerBox.height * FONT_SIZE_PERCENT * 100) / 100;\n  var styleOptions = {\n    font: fontSize + \"px \" + FONT_STYLE\n  };\n\n  (function() {\n    var styleBox, cue;\n\n    for (var i = 0; i < cues.length; i++) {\n      cue = cues[i];\n\n      // Compute the intial position and styles of the cue div.\n      styleBox = new CueStyleBox(window, cue, styleOptions);\n      paddedOverlay.appendChild(styleBox.div);\n\n      // Move the cue div to it's correct line position.\n      moveBoxToLinePosition(window, styleBox, containerBox, boxPositions);\n\n      // Remember the computed div so that we don't have to recompute it later\n      // if we don't have too.\n      cue.displayState = styleBox.div;\n\n      boxPositions.push(BoxPosition.getSimpleBoxPosition(styleBox));\n    }\n  })();\n};\n\nWebVTT.Parser = function(window, vttjs, decoder) {\n  if (!decoder) {\n    decoder = vttjs;\n    vttjs = {};\n  }\n  if (!vttjs) {\n    vttjs = {};\n  }\n\n  this.window = window;\n  this.vttjs = vttjs;\n  this.state = \"INITIAL\";\n  this.buffer = \"\";\n  this.decoder = decoder || new TextDecoder(\"utf8\");\n  this.regionList = [];\n};\n\nWebVTT.Parser.prototype = {\n  // If the error is a ParsingError then report it to the consumer if\n  // possible. If it's not a ParsingError then throw it like normal.\n  reportOrThrowError: function(e) {\n    if (e instanceof ParsingError) {\n      this.onparsingerror && this.onparsingerror(e);\n    } else {\n      throw e;\n    }\n  },\n  parse: function (data) {\n    var self = this;\n\n    // If there is no data then we won't decode it, but will just try to parse\n    // whatever is in buffer already. This may occur in circumstances, for\n    // example when flush() is called.\n    if (data) {\n      // Try to decode the data that we received.\n      self.buffer += self.decoder.decode(data, {stream: true});\n    }\n\n    function collectNextLine() {\n      var buffer = self.buffer;\n      var pos = 0;\n      while (pos < buffer.length && buffer[pos] !== '\\r' && buffer[pos] !== '\\n') {\n        ++pos;\n      }\n      var line = buffer.substr(0, pos);\n      // Advance the buffer early in case we fail below.\n      if (buffer[pos] === '\\r') {\n        ++pos;\n      }\n      if (buffer[pos] === '\\n') {\n        ++pos;\n      }\n      self.buffer = buffer.substr(pos);\n      return line;\n    }\n\n    // 3.4 WebVTT region and WebVTT region settings syntax\n    function parseRegion(input) {\n      var settings = new Settings();\n\n      parseOptions(input, function (k, v) {\n        switch (k) {\n        case \"id\":\n          settings.set(k, v);\n          break;\n        case \"width\":\n          settings.percent(k, v);\n          break;\n        case \"lines\":\n          settings.integer(k, v);\n          break;\n        case \"regionanchor\":\n        case \"viewportanchor\":\n          var xy = v.split(',');\n          if (xy.length !== 2) {\n            break;\n          }\n          // We have to make sure both x and y parse, so use a temporary\n          // settings object here.\n          var anchor = new Settings();\n          anchor.percent(\"x\", xy[0]);\n          anchor.percent(\"y\", xy[1]);\n          if (!anchor.has(\"x\") || !anchor.has(\"y\")) {\n            break;\n          }\n          settings.set(k + \"X\", anchor.get(\"x\"));\n          settings.set(k + \"Y\", anchor.get(\"y\"));\n          break;\n        case \"scroll\":\n          settings.alt(k, v, [\"up\"]);\n          break;\n        }\n      }, /=/, /\\s/);\n\n      // Create the region, using default values for any values that were not\n      // specified.\n      if (settings.has(\"id\")) {\n        var region = new (self.vttjs.VTTRegion || self.window.VTTRegion)();\n        region.width = settings.get(\"width\", 100);\n        region.lines = settings.get(\"lines\", 3);\n        region.regionAnchorX = settings.get(\"regionanchorX\", 0);\n        region.regionAnchorY = settings.get(\"regionanchorY\", 100);\n        region.viewportAnchorX = settings.get(\"viewportanchorX\", 0);\n        region.viewportAnchorY = settings.get(\"viewportanchorY\", 100);\n        region.scroll = settings.get(\"scroll\", \"\");\n        // Register the region.\n        self.onregion && self.onregion(region);\n        // Remember the VTTRegion for later in case we parse any VTTCues that\n        // reference it.\n        self.regionList.push({\n          id: settings.get(\"id\"),\n          region: region\n        });\n      }\n    }\n\n    // draft-pantos-http-live-streaming-20\n    // https://tools.ietf.org/html/draft-pantos-http-live-streaming-20#section-3.5\n    // 3.5 WebVTT\n    function parseTimestampMap(input) {\n      var settings = new Settings();\n\n      parseOptions(input, function(k, v) {\n        switch(k) {\n        case \"MPEGT\":\n          settings.integer(k + 'S', v);\n          break;\n        case \"LOCA\":\n          settings.set(k + 'L', parseTimeStamp(v));\n          break;\n        }\n      }, /[^\\d]:/, /,/);\n\n      self.ontimestampmap && self.ontimestampmap({\n        \"MPEGTS\": settings.get(\"MPEGTS\"),\n        \"LOCAL\": settings.get(\"LOCAL\")\n      });\n    }\n\n    // 3.2 WebVTT metadata header syntax\n    function parseHeader(input) {\n      if (input.match(/X-TIMESTAMP-MAP/)) {\n        // This line contains HLS X-TIMESTAMP-MAP metadata\n        parseOptions(input, function(k, v) {\n          switch(k) {\n          case \"X-TIMESTAMP-MAP\":\n            parseTimestampMap(v);\n            break;\n          }\n        }, /=/);\n      } else {\n        parseOptions(input, function (k, v) {\n          switch (k) {\n          case \"Region\":\n            // 3.3 WebVTT region metadata header syntax\n            parseRegion(v);\n            break;\n          }\n        }, /:/);\n      }\n\n    }\n\n    // 5.1 WebVTT file parsing.\n    try {\n      var line;\n      if (self.state === \"INITIAL\") {\n        // We can't start parsing until we have the first line.\n        if (!/\\r\\n|\\n/.test(self.buffer)) {\n          return this;\n        }\n\n        line = collectNextLine();\n\n        var m = line.match(/^WEBVTT([ \\t].*)?$/);\n        if (!m || !m[0]) {\n          throw new ParsingError(ParsingError.Errors.BadSignature);\n        }\n\n        self.state = \"HEADER\";\n      }\n\n      var alreadyCollectedLine = false;\n      while (self.buffer) {\n        // We can't parse a line until we have the full line.\n        if (!/\\r\\n|\\n/.test(self.buffer)) {\n          return this;\n        }\n\n        if (!alreadyCollectedLine) {\n          line = collectNextLine();\n        } else {\n          alreadyCollectedLine = false;\n        }\n\n        switch (self.state) {\n        case \"HEADER\":\n          // 13-18 - Allow a header (metadata) under the WEBVTT line.\n          if (/:/.test(line)) {\n            parseHeader(line);\n          } else if (!line) {\n            // An empty line terminates the header and starts the body (cues).\n            self.state = \"ID\";\n          }\n          continue;\n        case \"NOTE\":\n          // Ignore NOTE blocks.\n          if (!line) {\n            self.state = \"ID\";\n          }\n          continue;\n        case \"ID\":\n          // Check for the start of NOTE blocks.\n          if (/^NOTE($|[ \\t])/.test(line)) {\n            self.state = \"NOTE\";\n            break;\n          }\n          // 19-29 - Allow any number of line terminators, then initialize new cue values.\n          if (!line) {\n            continue;\n          }\n          self.cue = new (self.vttjs.VTTCue || self.window.VTTCue)(0, 0, \"\");\n          self.state = \"CUE\";\n          // 30-39 - Check if self line contains an optional identifier or timing data.\n          if (line.indexOf(\"-->\") === -1) {\n            self.cue.id = line;\n            continue;\n          }\n          // Process line as start of a cue.\n          /*falls through*/\n        case \"CUE\":\n          // 40 - Collect cue timings and settings.\n          try {\n            parseCue(line, self.cue, self.regionList);\n          } catch (e) {\n            self.reportOrThrowError(e);\n            // In case of an error ignore rest of the cue.\n            self.cue = null;\n            self.state = \"BADCUE\";\n            continue;\n          }\n          self.state = \"CUETEXT\";\n          continue;\n        case \"CUETEXT\":\n          var hasSubstring = line.indexOf(\"-->\") !== -1;\n          // 34 - If we have an empty line then report the cue.\n          // 35 - If we have the special substring '-->' then report the cue,\n          // but do not collect the line as we need to process the current\n          // one as a new cue.\n          if (!line || hasSubstring && (alreadyCollectedLine = true)) {\n            // We are done parsing self cue.\n            self.oncue && self.oncue(self.cue);\n            self.cue = null;\n            self.state = \"ID\";\n            continue;\n          }\n          if (self.cue.text) {\n            self.cue.text += \"\\n\";\n          }\n          self.cue.text += line;\n          continue;\n        case \"BADCUE\": // BADCUE\n          // 54-62 - Collect and discard the remaining cue.\n          if (!line) {\n            self.state = \"ID\";\n          }\n          continue;\n        }\n      }\n    } catch (e) {\n      self.reportOrThrowError(e);\n\n      // If we are currently parsing a cue, report what we have.\n      if (self.state === \"CUETEXT\" && self.cue && self.oncue) {\n        self.oncue(self.cue);\n      }\n      self.cue = null;\n      // Enter BADWEBVTT state if header was not parsed correctly otherwise\n      // another exception occurred so enter BADCUE state.\n      self.state = self.state === \"INITIAL\" ? \"BADWEBVTT\" : \"BADCUE\";\n    }\n    return this;\n  },\n  flush: function () {\n    var self = this;\n    try {\n      // Finish decoding the stream.\n      self.buffer += self.decoder.decode();\n      // Synthesize the end of the current cue or region.\n      if (self.cue || self.state === \"HEADER\") {\n        self.buffer += \"\\n\\n\";\n        self.parse();\n      }\n      // If we've flushed, parsed, and we're still on the INITIAL state then\n      // that means we don't have enough of the stream to parse the first\n      // line.\n      if (self.state === \"INITIAL\") {\n        throw new ParsingError(ParsingError.Errors.BadSignature);\n      }\n    } catch(e) {\n      self.reportOrThrowError(e);\n    }\n    self.onflush && self.onflush();\n    return this;\n  }\n};\n\nmodule.exports = WebVTT;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdmlkZW9qcy1jb250cmliLW1lZGlhLXNvdXJjZXMvbm9kZV9tb2R1bGVzL3ZpZGVvanMtdnR0LmpzL2xpYi92dHQuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixjQUFjLHVCQUF1QjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsa0NBQWtDLEVBQUUsTUFBTSxFQUFFLFFBQVEsRUFBRTtBQUN0RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0Esb0JBQW9CLGNBQWM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLElBQUk7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsUUFBUTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3Qzs7QUFFeEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRO0FBQ1IsT0FBTztBQUNQLE9BQU87QUFDUCxRQUFRO0FBQ1IsUUFBUTtBQUNSLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IsNEJBQTRCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2Q0FBNkMsUUFBUTtBQUNyRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixnREFBZ0Q7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qjs7QUFFeEIsb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsb0JBQW9CLGlCQUFpQjtBQUNyQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxhQUFhO0FBQzdEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL215LXYwLXByb2plY3QvLi9ub2RlX21vZHVsZXMvdmlkZW9qcy1jb250cmliLW1lZGlhLXNvdXJjZXMvbm9kZV9tb2R1bGVzL3ZpZGVvanMtdnR0LmpzL2xpYi92dHQuanM/MzE3ZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAyMDEzIHZ0dC5qcyBDb250cmlidXRvcnNcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qIC0qLSBNb2RlOiBKYXZhOyB0YWItd2lkdGg6IDI7IGluZGVudC10YWJzLW1vZGU6IG5pbDsgYy1iYXNpYy1vZmZzZXQ6IDIgLSotICovXG4vKiB2aW06IHNldCBzaGlmdHdpZHRoPTIgdGFic3RvcD0yIGF1dG9pbmRlbnQgY2luZGVudCBleHBhbmR0YWI6ICovXG52YXIgX29iakNyZWF0ZSA9IE9iamVjdC5jcmVhdGUgfHwgKGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBGKCkge31cbiAgcmV0dXJuIGZ1bmN0aW9uKG8pIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdPYmplY3QuY3JlYXRlIHNoaW0gb25seSBhY2NlcHRzIG9uZSBwYXJhbWV0ZXIuJyk7XG4gICAgfVxuICAgIEYucHJvdG90eXBlID0gbztcbiAgICByZXR1cm4gbmV3IEYoKTtcbiAgfTtcbn0pKCk7XG5cbi8vIENyZWF0ZXMgYSBuZXcgUGFyc2VyRXJyb3Igb2JqZWN0IGZyb20gYW4gZXJyb3JEYXRhIG9iamVjdC4gVGhlIGVycm9yRGF0YVxuLy8gb2JqZWN0IHNob3VsZCBoYXZlIGRlZmF1bHQgY29kZSBhbmQgbWVzc2FnZSBwcm9wZXJ0aWVzLiBUaGUgZGVmYXVsdCBtZXNzYWdlXG4vLyBwcm9wZXJ0eSBjYW4gYmUgb3ZlcnJpZGVuIGJ5IHBhc3NpbmcgaW4gYSBtZXNzYWdlIHBhcmFtZXRlci5cbi8vIFNlZSBQYXJzaW5nRXJyb3IuRXJyb3JzIGJlbG93IGZvciBhY2NlcHRhYmxlIGVycm9ycy5cbmZ1bmN0aW9uIFBhcnNpbmdFcnJvcihlcnJvckRhdGEsIG1lc3NhZ2UpIHtcbiAgdGhpcy5uYW1lID0gXCJQYXJzaW5nRXJyb3JcIjtcbiAgdGhpcy5jb2RlID0gZXJyb3JEYXRhLmNvZGU7XG4gIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2UgfHwgZXJyb3JEYXRhLm1lc3NhZ2U7XG59XG5QYXJzaW5nRXJyb3IucHJvdG90eXBlID0gX29iakNyZWF0ZShFcnJvci5wcm90b3R5cGUpO1xuUGFyc2luZ0Vycm9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFBhcnNpbmdFcnJvcjtcblxuLy8gUGFyc2luZ0Vycm9yIG1ldGFkYXRhIGZvciBhY2NlcHRhYmxlIFBhcnNpbmdFcnJvcnMuXG5QYXJzaW5nRXJyb3IuRXJyb3JzID0ge1xuICBCYWRTaWduYXR1cmU6IHtcbiAgICBjb2RlOiAwLFxuICAgIG1lc3NhZ2U6IFwiTWFsZm9ybWVkIFdlYlZUVCBzaWduYXR1cmUuXCJcbiAgfSxcbiAgQmFkVGltZVN0YW1wOiB7XG4gICAgY29kZTogMSxcbiAgICBtZXNzYWdlOiBcIk1hbGZvcm1lZCB0aW1lIHN0YW1wLlwiXG4gIH1cbn07XG5cbi8vIFRyeSB0byBwYXJzZSBpbnB1dCBhcyBhIHRpbWUgc3RhbXAuXG5mdW5jdGlvbiBwYXJzZVRpbWVTdGFtcChpbnB1dCkge1xuXG4gIGZ1bmN0aW9uIGNvbXB1dGVTZWNvbmRzKGgsIG0sIHMsIGYpIHtcbiAgICByZXR1cm4gKGggfCAwKSAqIDM2MDAgKyAobSB8IDApICogNjAgKyAocyB8IDApICsgKGYgfCAwKSAvIDEwMDA7XG4gIH1cblxuICB2YXIgbSA9IGlucHV0Lm1hdGNoKC9eKFxcZCspOihcXGR7Mn0pKDpcXGR7Mn0pP1xcLihcXGR7M30pLyk7XG4gIGlmICghbSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKG1bM10pIHtcbiAgICAvLyBUaW1lc3RhbXAgdGFrZXMgdGhlIGZvcm0gb2YgW2hvdXJzXTpbbWludXRlc106W3NlY29uZHNdLlttaWxsaXNlY29uZHNdXG4gICAgcmV0dXJuIGNvbXB1dGVTZWNvbmRzKG1bMV0sIG1bMl0sIG1bM10ucmVwbGFjZShcIjpcIiwgXCJcIiksIG1bNF0pO1xuICB9IGVsc2UgaWYgKG1bMV0gPiA1OSkge1xuICAgIC8vIFRpbWVzdGFtcCB0YWtlcyB0aGUgZm9ybSBvZiBbaG91cnNdOlttaW51dGVzXS5bbWlsbGlzZWNvbmRzXVxuICAgIC8vIEZpcnN0IHBvc2l0aW9uIGlzIGhvdXJzIGFzIGl0J3Mgb3ZlciA1OS5cbiAgICByZXR1cm4gY29tcHV0ZVNlY29uZHMobVsxXSwgbVsyXSwgMCwgIG1bNF0pO1xuICB9IGVsc2Uge1xuICAgIC8vIFRpbWVzdGFtcCB0YWtlcyB0aGUgZm9ybSBvZiBbbWludXRlc106W3NlY29uZHNdLlttaWxsaXNlY29uZHNdXG4gICAgcmV0dXJuIGNvbXB1dGVTZWNvbmRzKDAsIG1bMV0sIG1bMl0sIG1bNF0pO1xuICB9XG59XG5cbi8vIEEgc2V0dGluZ3Mgb2JqZWN0IGhvbGRzIGtleS92YWx1ZSBwYWlycyBhbmQgd2lsbCBpZ25vcmUgYW55dGhpbmcgYnV0IHRoZSBmaXJzdFxuLy8gYXNzaWdubWVudCB0byBhIHNwZWNpZmljIGtleS5cbmZ1bmN0aW9uIFNldHRpbmdzKCkge1xuICB0aGlzLnZhbHVlcyA9IF9vYmpDcmVhdGUobnVsbCk7XG59XG5cblNldHRpbmdzLnByb3RvdHlwZSA9IHtcbiAgLy8gT25seSBhY2NlcHQgdGhlIGZpcnN0IGFzc2lnbm1lbnQgdG8gYW55IGtleS5cbiAgc2V0OiBmdW5jdGlvbihrLCB2KSB7XG4gICAgaWYgKCF0aGlzLmdldChrKSAmJiB2ICE9PSBcIlwiKSB7XG4gICAgICB0aGlzLnZhbHVlc1trXSA9IHY7XG4gICAgfVxuICB9LFxuICAvLyBSZXR1cm4gdGhlIHZhbHVlIGZvciBhIGtleSwgb3IgYSBkZWZhdWx0IHZhbHVlLlxuICAvLyBJZiAnZGVmYXVsdEtleScgaXMgcGFzc2VkIHRoZW4gJ2RmbHQnIGlzIGFzc3VtZWQgdG8gYmUgYW4gb2JqZWN0IHdpdGhcbiAgLy8gYSBudW1iZXIgb2YgcG9zc2libGUgZGVmYXVsdCB2YWx1ZXMgYXMgcHJvcGVydGllcyB3aGVyZSAnZGVmYXVsdEtleScgaXNcbiAgLy8gdGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdGhhdCB3aWxsIGJlIGNob3Nlbjsgb3RoZXJ3aXNlIGl0J3MgYXNzdW1lZCB0byBiZVxuICAvLyBhIHNpbmdsZSB2YWx1ZS5cbiAgZ2V0OiBmdW5jdGlvbihrLCBkZmx0LCBkZWZhdWx0S2V5KSB7XG4gICAgaWYgKGRlZmF1bHRLZXkpIHtcbiAgICAgIHJldHVybiB0aGlzLmhhcyhrKSA/IHRoaXMudmFsdWVzW2tdIDogZGZsdFtkZWZhdWx0S2V5XTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuaGFzKGspID8gdGhpcy52YWx1ZXNba10gOiBkZmx0O1xuICB9LFxuICAvLyBDaGVjayB3aGV0aGVyIHdlIGhhdmUgYSB2YWx1ZSBmb3IgYSBrZXkuXG4gIGhhczogZnVuY3Rpb24oaykge1xuICAgIHJldHVybiBrIGluIHRoaXMudmFsdWVzO1xuICB9LFxuICAvLyBBY2NlcHQgYSBzZXR0aW5nIGlmIGl0cyBvbmUgb2YgdGhlIGdpdmVuIGFsdGVybmF0aXZlcy5cbiAgYWx0OiBmdW5jdGlvbihrLCB2LCBhKSB7XG4gICAgZm9yICh2YXIgbiA9IDA7IG4gPCBhLmxlbmd0aDsgKytuKSB7XG4gICAgICBpZiAodiA9PT0gYVtuXSkge1xuICAgICAgICB0aGlzLnNldChrLCB2KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICAvLyBBY2NlcHQgYSBzZXR0aW5nIGlmIGl0cyBhIHZhbGlkIChzaWduZWQpIGludGVnZXIuXG4gIGludGVnZXI6IGZ1bmN0aW9uKGssIHYpIHtcbiAgICBpZiAoL14tP1xcZCskLy50ZXN0KHYpKSB7IC8vIGludGVnZXJcbiAgICAgIHRoaXMuc2V0KGssIHBhcnNlSW50KHYsIDEwKSk7XG4gICAgfVxuICB9LFxuICAvLyBBY2NlcHQgYSBzZXR0aW5nIGlmIGl0cyBhIHZhbGlkIHBlcmNlbnRhZ2UuXG4gIHBlcmNlbnQ6IGZ1bmN0aW9uKGssIHYpIHtcbiAgICB2YXIgbTtcbiAgICBpZiAoKG0gPSB2Lm1hdGNoKC9eKFtcXGRdezEsM30pKFxcLltcXGRdKik/JSQvKSkpIHtcbiAgICAgIHYgPSBwYXJzZUZsb2F0KHYpO1xuICAgICAgaWYgKHYgPj0gMCAmJiB2IDw9IDEwMCkge1xuICAgICAgICB0aGlzLnNldChrLCB2KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcblxuLy8gSGVscGVyIGZ1bmN0aW9uIHRvIHBhcnNlIGlucHV0IGludG8gZ3JvdXBzIHNlcGFyYXRlZCBieSAnZ3JvdXBEZWxpbScsIGFuZFxuLy8gaW50ZXJwcmV0ZSBlYWNoIGdyb3VwIGFzIGEga2V5L3ZhbHVlIHBhaXIgc2VwYXJhdGVkIGJ5ICdrZXlWYWx1ZURlbGltJy5cbmZ1bmN0aW9uIHBhcnNlT3B0aW9ucyhpbnB1dCwgY2FsbGJhY2ssIGtleVZhbHVlRGVsaW0sIGdyb3VwRGVsaW0pIHtcbiAgdmFyIGdyb3VwcyA9IGdyb3VwRGVsaW0gPyBpbnB1dC5zcGxpdChncm91cERlbGltKSA6IFtpbnB1dF07XG4gIGZvciAodmFyIGkgaW4gZ3JvdXBzKSB7XG4gICAgaWYgKHR5cGVvZiBncm91cHNbaV0gIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB2YXIga3YgPSBncm91cHNbaV0uc3BsaXQoa2V5VmFsdWVEZWxpbSk7XG4gICAgaWYgKGt2Lmxlbmd0aCAhPT0gMikge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHZhciBrID0ga3ZbMF07XG4gICAgdmFyIHYgPSBrdlsxXTtcbiAgICBjYWxsYmFjayhrLCB2KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwYXJzZUN1ZShpbnB1dCwgY3VlLCByZWdpb25MaXN0KSB7XG4gIC8vIFJlbWVtYmVyIHRoZSBvcmlnaW5hbCBpbnB1dCBpZiB3ZSBuZWVkIHRvIHRocm93IGFuIGVycm9yLlxuICB2YXIgb0lucHV0ID0gaW5wdXQ7XG4gIC8vIDQuMSBXZWJWVFQgdGltZXN0YW1wXG4gIGZ1bmN0aW9uIGNvbnN1bWVUaW1lU3RhbXAoKSB7XG4gICAgdmFyIHRzID0gcGFyc2VUaW1lU3RhbXAoaW5wdXQpO1xuICAgIGlmICh0cyA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IFBhcnNpbmdFcnJvcihQYXJzaW5nRXJyb3IuRXJyb3JzLkJhZFRpbWVTdGFtcCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIk1hbGZvcm1lZCB0aW1lc3RhbXA6IFwiICsgb0lucHV0KTtcbiAgICB9XG4gICAgLy8gUmVtb3ZlIHRpbWUgc3RhbXAgZnJvbSBpbnB1dC5cbiAgICBpbnB1dCA9IGlucHV0LnJlcGxhY2UoL15bXlxcc2EtekEtWi1dKy8sIFwiXCIpO1xuICAgIHJldHVybiB0cztcbiAgfVxuXG4gIC8vIDQuNC4yIFdlYlZUVCBjdWUgc2V0dGluZ3NcbiAgZnVuY3Rpb24gY29uc3VtZUN1ZVNldHRpbmdzKGlucHV0LCBjdWUpIHtcbiAgICB2YXIgc2V0dGluZ3MgPSBuZXcgU2V0dGluZ3MoKTtcblxuICAgIHBhcnNlT3B0aW9ucyhpbnB1dCwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICAgIHN3aXRjaCAoaykge1xuICAgICAgY2FzZSBcInJlZ2lvblwiOlxuICAgICAgICAvLyBGaW5kIHRoZSBsYXN0IHJlZ2lvbiB3ZSBwYXJzZWQgd2l0aCB0aGUgc2FtZSByZWdpb24gaWQuXG4gICAgICAgIGZvciAodmFyIGkgPSByZWdpb25MaXN0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgaWYgKHJlZ2lvbkxpc3RbaV0uaWQgPT09IHYpIHtcbiAgICAgICAgICAgIHNldHRpbmdzLnNldChrLCByZWdpb25MaXN0W2ldLnJlZ2lvbik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwidmVydGljYWxcIjpcbiAgICAgICAgc2V0dGluZ3MuYWx0KGssIHYsIFtcInJsXCIsIFwibHJcIl0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJsaW5lXCI6XG4gICAgICAgIHZhciB2YWxzID0gdi5zcGxpdChcIixcIiksXG4gICAgICAgICAgICB2YWxzMCA9IHZhbHNbMF07XG4gICAgICAgIHNldHRpbmdzLmludGVnZXIoaywgdmFsczApO1xuICAgICAgICBzZXR0aW5ncy5wZXJjZW50KGssIHZhbHMwKSA/IHNldHRpbmdzLnNldChcInNuYXBUb0xpbmVzXCIsIGZhbHNlKSA6IG51bGw7XG4gICAgICAgIHNldHRpbmdzLmFsdChrLCB2YWxzMCwgW1wiYXV0b1wiXSk7XG4gICAgICAgIGlmICh2YWxzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgIHNldHRpbmdzLmFsdChcImxpbmVBbGlnblwiLCB2YWxzWzFdLCBbXCJzdGFydFwiLCBcIm1pZGRsZVwiLCBcImVuZFwiXSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwicG9zaXRpb25cIjpcbiAgICAgICAgdmFscyA9IHYuc3BsaXQoXCIsXCIpO1xuICAgICAgICBzZXR0aW5ncy5wZXJjZW50KGssIHZhbHNbMF0pO1xuICAgICAgICBpZiAodmFscy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICBzZXR0aW5ncy5hbHQoXCJwb3NpdGlvbkFsaWduXCIsIHZhbHNbMV0sIFtcInN0YXJ0XCIsIFwibWlkZGxlXCIsIFwiZW5kXCJdKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJzaXplXCI6XG4gICAgICAgIHNldHRpbmdzLnBlcmNlbnQoaywgdik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImFsaWduXCI6XG4gICAgICAgIHNldHRpbmdzLmFsdChrLCB2LCBbXCJzdGFydFwiLCBcIm1pZGRsZVwiLCBcImVuZFwiLCBcImxlZnRcIiwgXCJyaWdodFwiXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0sIC86LywgL1xccy8pO1xuXG4gICAgLy8gQXBwbHkgZGVmYXVsdCB2YWx1ZXMgZm9yIGFueSBtaXNzaW5nIGZpZWxkcy5cbiAgICBjdWUucmVnaW9uID0gc2V0dGluZ3MuZ2V0KFwicmVnaW9uXCIsIG51bGwpO1xuICAgIGN1ZS52ZXJ0aWNhbCA9IHNldHRpbmdzLmdldChcInZlcnRpY2FsXCIsIFwiXCIpO1xuICAgIGN1ZS5saW5lID0gc2V0dGluZ3MuZ2V0KFwibGluZVwiLCBcImF1dG9cIik7XG4gICAgY3VlLmxpbmVBbGlnbiA9IHNldHRpbmdzLmdldChcImxpbmVBbGlnblwiLCBcInN0YXJ0XCIpO1xuICAgIGN1ZS5zbmFwVG9MaW5lcyA9IHNldHRpbmdzLmdldChcInNuYXBUb0xpbmVzXCIsIHRydWUpO1xuICAgIGN1ZS5zaXplID0gc2V0dGluZ3MuZ2V0KFwic2l6ZVwiLCAxMDApO1xuICAgIGN1ZS5hbGlnbiA9IHNldHRpbmdzLmdldChcImFsaWduXCIsIFwibWlkZGxlXCIpO1xuICAgIGN1ZS5wb3NpdGlvbiA9IHNldHRpbmdzLmdldChcInBvc2l0aW9uXCIsIHtcbiAgICAgIHN0YXJ0OiAwLFxuICAgICAgbGVmdDogMCxcbiAgICAgIG1pZGRsZTogNTAsXG4gICAgICBlbmQ6IDEwMCxcbiAgICAgIHJpZ2h0OiAxMDBcbiAgICB9LCBjdWUuYWxpZ24pO1xuICAgIGN1ZS5wb3NpdGlvbkFsaWduID0gc2V0dGluZ3MuZ2V0KFwicG9zaXRpb25BbGlnblwiLCB7XG4gICAgICBzdGFydDogXCJzdGFydFwiLFxuICAgICAgbGVmdDogXCJzdGFydFwiLFxuICAgICAgbWlkZGxlOiBcIm1pZGRsZVwiLFxuICAgICAgZW5kOiBcImVuZFwiLFxuICAgICAgcmlnaHQ6IFwiZW5kXCJcbiAgICB9LCBjdWUuYWxpZ24pO1xuICB9XG5cbiAgZnVuY3Rpb24gc2tpcFdoaXRlc3BhY2UoKSB7XG4gICAgaW5wdXQgPSBpbnB1dC5yZXBsYWNlKC9eXFxzKy8sIFwiXCIpO1xuICB9XG5cbiAgLy8gNC4xIFdlYlZUVCBjdWUgdGltaW5ncy5cbiAgc2tpcFdoaXRlc3BhY2UoKTtcbiAgY3VlLnN0YXJ0VGltZSA9IGNvbnN1bWVUaW1lU3RhbXAoKTsgICAvLyAoMSkgY29sbGVjdCBjdWUgc3RhcnQgdGltZVxuICBza2lwV2hpdGVzcGFjZSgpO1xuICBpZiAoaW5wdXQuc3Vic3RyKDAsIDMpICE9PSBcIi0tPlwiKSB7ICAgICAvLyAoMykgbmV4dCBjaGFyYWN0ZXJzIG11c3QgbWF0Y2ggXCItLT5cIlxuICAgIHRocm93IG5ldyBQYXJzaW5nRXJyb3IoUGFyc2luZ0Vycm9yLkVycm9ycy5CYWRUaW1lU3RhbXAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBcIk1hbGZvcm1lZCB0aW1lIHN0YW1wICh0aW1lIHN0YW1wcyBtdXN0IGJlIHNlcGFyYXRlZCBieSAnLS0+Jyk6IFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIG9JbnB1dCk7XG4gIH1cbiAgaW5wdXQgPSBpbnB1dC5zdWJzdHIoMyk7XG4gIHNraXBXaGl0ZXNwYWNlKCk7XG4gIGN1ZS5lbmRUaW1lID0gY29uc3VtZVRpbWVTdGFtcCgpOyAgICAgLy8gKDUpIGNvbGxlY3QgY3VlIGVuZCB0aW1lXG5cbiAgLy8gNC4xIFdlYlZUVCBjdWUgc2V0dGluZ3MgbGlzdC5cbiAgc2tpcFdoaXRlc3BhY2UoKTtcbiAgY29uc3VtZUN1ZVNldHRpbmdzKGlucHV0LCBjdWUpO1xufVxuXG52YXIgRVNDQVBFID0ge1xuICBcIiZhbXA7XCI6IFwiJlwiLFxuICBcIiZsdDtcIjogXCI8XCIsXG4gIFwiJmd0O1wiOiBcIj5cIixcbiAgXCImbHJtO1wiOiBcIlxcdTIwMGVcIixcbiAgXCImcmxtO1wiOiBcIlxcdTIwMGZcIixcbiAgXCImbmJzcDtcIjogXCJcXHUwMGEwXCJcbn07XG5cbnZhciBUQUdfTkFNRSA9IHtcbiAgYzogXCJzcGFuXCIsXG4gIGk6IFwiaVwiLFxuICBiOiBcImJcIixcbiAgdTogXCJ1XCIsXG4gIHJ1Ynk6IFwicnVieVwiLFxuICBydDogXCJydFwiLFxuICB2OiBcInNwYW5cIixcbiAgbGFuZzogXCJzcGFuXCJcbn07XG5cbnZhciBUQUdfQU5OT1RBVElPTiA9IHtcbiAgdjogXCJ0aXRsZVwiLFxuICBsYW5nOiBcImxhbmdcIlxufTtcblxudmFyIE5FRURTX1BBUkVOVCA9IHtcbiAgcnQ6IFwicnVieVwiXG59O1xuXG4vLyBQYXJzZSBjb250ZW50IGludG8gYSBkb2N1bWVudCBmcmFnbWVudC5cbmZ1bmN0aW9uIHBhcnNlQ29udGVudCh3aW5kb3csIGlucHV0KSB7XG4gIGZ1bmN0aW9uIG5leHRUb2tlbigpIHtcbiAgICAvLyBDaGVjayBmb3IgZW5kLW9mLXN0cmluZy5cbiAgICBpZiAoIWlucHV0KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBDb25zdW1lICduJyBjaGFyYWN0ZXJzIGZyb20gdGhlIGlucHV0LlxuICAgIGZ1bmN0aW9uIGNvbnN1bWUocmVzdWx0KSB7XG4gICAgICBpbnB1dCA9IGlucHV0LnN1YnN0cihyZXN1bHQubGVuZ3RoKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgdmFyIG0gPSBpbnB1dC5tYXRjaCgvXihbXjxdKikoPFtePl0qPj8pPy8pO1xuICAgIC8vIElmIHRoZXJlIGlzIHNvbWUgdGV4dCBiZWZvcmUgdGhlIG5leHQgdGFnLCByZXR1cm4gaXQsIG90aGVyd2lzZSByZXR1cm5cbiAgICAvLyB0aGUgdGFnLlxuICAgIHJldHVybiBjb25zdW1lKG1bMV0gPyBtWzFdIDogbVsyXSk7XG4gIH1cblxuICAvLyBVbmVzY2FwZSBhIHN0cmluZyAncycuXG4gIGZ1bmN0aW9uIHVuZXNjYXBlMShlKSB7XG4gICAgcmV0dXJuIEVTQ0FQRVtlXTtcbiAgfVxuICBmdW5jdGlvbiB1bmVzY2FwZShzKSB7XG4gICAgd2hpbGUgKChtID0gcy5tYXRjaCgvJihhbXB8bHR8Z3R8bHJtfHJsbXxuYnNwKTsvKSkpIHtcbiAgICAgIHMgPSBzLnJlcGxhY2UobVswXSwgdW5lc2NhcGUxKTtcbiAgICB9XG4gICAgcmV0dXJuIHM7XG4gIH1cblxuICBmdW5jdGlvbiBzaG91bGRBZGQoY3VycmVudCwgZWxlbWVudCkge1xuICAgIHJldHVybiAhTkVFRFNfUEFSRU5UW2VsZW1lbnQubG9jYWxOYW1lXSB8fFxuICAgICAgICAgICBORUVEU19QQVJFTlRbZWxlbWVudC5sb2NhbE5hbWVdID09PSBjdXJyZW50LmxvY2FsTmFtZTtcbiAgfVxuXG4gIC8vIENyZWF0ZSBhbiBlbGVtZW50IGZvciB0aGlzIHRhZy5cbiAgZnVuY3Rpb24gY3JlYXRlRWxlbWVudCh0eXBlLCBhbm5vdGF0aW9uKSB7XG4gICAgdmFyIHRhZ05hbWUgPSBUQUdfTkFNRVt0eXBlXTtcbiAgICBpZiAoIXRhZ05hbWUpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgZWxlbWVudCA9IHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZ05hbWUpO1xuICAgIGVsZW1lbnQubG9jYWxOYW1lID0gdGFnTmFtZTtcbiAgICB2YXIgbmFtZSA9IFRBR19BTk5PVEFUSU9OW3R5cGVdO1xuICAgIGlmIChuYW1lICYmIGFubm90YXRpb24pIHtcbiAgICAgIGVsZW1lbnRbbmFtZV0gPSBhbm5vdGF0aW9uLnRyaW0oKTtcbiAgICB9XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cblxuICB2YXIgcm9vdERpdiA9IHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLFxuICAgICAgY3VycmVudCA9IHJvb3REaXYsXG4gICAgICB0LFxuICAgICAgdGFnU3RhY2sgPSBbXTtcblxuICB3aGlsZSAoKHQgPSBuZXh0VG9rZW4oKSkgIT09IG51bGwpIHtcbiAgICBpZiAodFswXSA9PT0gJzwnKSB7XG4gICAgICBpZiAodFsxXSA9PT0gXCIvXCIpIHtcbiAgICAgICAgLy8gSWYgdGhlIGNsb3NpbmcgdGFnIG1hdGNoZXMsIG1vdmUgYmFjayB1cCB0byB0aGUgcGFyZW50IG5vZGUuXG4gICAgICAgIGlmICh0YWdTdGFjay5sZW5ndGggJiZcbiAgICAgICAgICAgIHRhZ1N0YWNrW3RhZ1N0YWNrLmxlbmd0aCAtIDFdID09PSB0LnN1YnN0cigyKS5yZXBsYWNlKFwiPlwiLCBcIlwiKSkge1xuICAgICAgICAgIHRhZ1N0YWNrLnBvcCgpO1xuICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnBhcmVudE5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gT3RoZXJ3aXNlIGp1c3QgaWdub3JlIHRoZSBlbmQgdGFnLlxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHZhciB0cyA9IHBhcnNlVGltZVN0YW1wKHQuc3Vic3RyKDEsIHQubGVuZ3RoIC0gMikpO1xuICAgICAgdmFyIG5vZGU7XG4gICAgICBpZiAodHMpIHtcbiAgICAgICAgLy8gVGltZXN0YW1wcyBhcmUgbGVhZCBub2RlcyBhcyB3ZWxsLlxuICAgICAgICBub2RlID0gd2luZG93LmRvY3VtZW50LmNyZWF0ZVByb2Nlc3NpbmdJbnN0cnVjdGlvbihcInRpbWVzdGFtcFwiLCB0cyk7XG4gICAgICAgIGN1cnJlbnQuYXBwZW5kQ2hpbGQobm9kZSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdmFyIG0gPSB0Lm1hdGNoKC9ePChbXi5cXHMvMC05Pl0rKShcXC5bXlxcc1xcXFw+XSspPyhbXj5cXFxcXSspPyhcXFxcPyk+PyQvKTtcbiAgICAgIC8vIElmIHdlIGNhbid0IHBhcnNlIHRoZSB0YWcsIHNraXAgdG8gdGhlIG5leHQgdGFnLlxuICAgICAgaWYgKCFtKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgLy8gVHJ5IHRvIGNvbnN0cnVjdCBhbiBlbGVtZW50LCBhbmQgaWdub3JlIHRoZSB0YWcgaWYgd2UgY291bGRuJ3QuXG4gICAgICBub2RlID0gY3JlYXRlRWxlbWVudChtWzFdLCBtWzNdKTtcbiAgICAgIGlmICghbm9kZSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIC8vIERldGVybWluZSBpZiB0aGUgdGFnIHNob3VsZCBiZSBhZGRlZCBiYXNlZCBvbiB0aGUgY29udGV4dCBvZiB3aGVyZSBpdFxuICAgICAgLy8gaXMgcGxhY2VkIGluIHRoZSBjdWV0ZXh0LlxuICAgICAgaWYgKCFzaG91bGRBZGQoY3VycmVudCwgbm9kZSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICAvLyBTZXQgdGhlIGNsYXNzIGxpc3QgKGFzIGEgbGlzdCBvZiBjbGFzc2VzLCBzZXBhcmF0ZWQgYnkgc3BhY2UpLlxuICAgICAgaWYgKG1bMl0pIHtcbiAgICAgICAgbm9kZS5jbGFzc05hbWUgPSBtWzJdLnN1YnN0cigxKS5yZXBsYWNlKCcuJywgJyAnKTtcbiAgICAgIH1cbiAgICAgIC8vIEFwcGVuZCB0aGUgbm9kZSB0byB0aGUgY3VycmVudCBub2RlLCBhbmQgZW50ZXIgdGhlIHNjb3BlIG9mIHRoZSBuZXdcbiAgICAgIC8vIG5vZGUuXG4gICAgICB0YWdTdGFjay5wdXNoKG1bMV0pO1xuICAgICAgY3VycmVudC5hcHBlbmRDaGlsZChub2RlKTtcbiAgICAgIGN1cnJlbnQgPSBub2RlO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gVGV4dCBub2RlcyBhcmUgbGVhZiBub2Rlcy5cbiAgICBjdXJyZW50LmFwcGVuZENoaWxkKHdpbmRvdy5kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh1bmVzY2FwZSh0KSkpO1xuICB9XG5cbiAgcmV0dXJuIHJvb3REaXY7XG59XG5cbi8vIFRoaXMgaXMgYSBsaXN0IG9mIGFsbCB0aGUgVW5pY29kZSBjaGFyYWN0ZXJzIHRoYXQgaGF2ZSBhIHN0cm9uZ1xuLy8gcmlnaHQtdG8tbGVmdCBjYXRlZ29yeS4gV2hhdCB0aGlzIG1lYW5zIGlzIHRoYXQgdGhlc2UgY2hhcmFjdGVycyBhcmVcbi8vIHdyaXR0ZW4gcmlnaHQtdG8tbGVmdCBmb3Igc3VyZS4gSXQgd2FzIGdlbmVyYXRlZCBieSBwdWxsaW5nIGFsbCB0aGUgc3Ryb25nXG4vLyByaWdodC10by1sZWZ0IGNoYXJhY3RlcnMgb3V0IG9mIHRoZSBVbmljb2RlIGRhdGEgdGFibGUuIFRoYXQgdGFibGUgY2FuXG4vLyBmb3VuZCBhdDogaHR0cDovL3d3dy51bmljb2RlLm9yZy9QdWJsaWMvVU5JREFUQS9Vbmljb2RlRGF0YS50eHRcbnZhciBzdHJvbmdSVExSYW5nZXMgPSBbWzB4NWJlLCAweDViZV0sIFsweDVjMCwgMHg1YzBdLCBbMHg1YzMsIDB4NWMzXSwgWzB4NWM2LCAweDVjNl0sXG4gWzB4NWQwLCAweDVlYV0sIFsweDVmMCwgMHg1ZjRdLCBbMHg2MDgsIDB4NjA4XSwgWzB4NjBiLCAweDYwYl0sIFsweDYwZCwgMHg2MGRdLFxuIFsweDYxYiwgMHg2MWJdLCBbMHg2MWUsIDB4NjRhXSwgWzB4NjZkLCAweDY2Zl0sIFsweDY3MSwgMHg2ZDVdLCBbMHg2ZTUsIDB4NmU2XSxcbiBbMHg2ZWUsIDB4NmVmXSwgWzB4NmZhLCAweDcwZF0sIFsweDcwZiwgMHg3MTBdLCBbMHg3MTIsIDB4NzJmXSwgWzB4NzRkLCAweDdhNV0sXG4gWzB4N2IxLCAweDdiMV0sIFsweDdjMCwgMHg3ZWFdLCBbMHg3ZjQsIDB4N2Y1XSwgWzB4N2ZhLCAweDdmYV0sIFsweDgwMCwgMHg4MTVdLFxuIFsweDgxYSwgMHg4MWFdLCBbMHg4MjQsIDB4ODI0XSwgWzB4ODI4LCAweDgyOF0sIFsweDgzMCwgMHg4M2VdLCBbMHg4NDAsIDB4ODU4XSxcbiBbMHg4NWUsIDB4ODVlXSwgWzB4OGEwLCAweDhhMF0sIFsweDhhMiwgMHg4YWNdLCBbMHgyMDBmLCAweDIwMGZdLFxuIFsweGZiMWQsIDB4ZmIxZF0sIFsweGZiMWYsIDB4ZmIyOF0sIFsweGZiMmEsIDB4ZmIzNl0sIFsweGZiMzgsIDB4ZmIzY10sXG4gWzB4ZmIzZSwgMHhmYjNlXSwgWzB4ZmI0MCwgMHhmYjQxXSwgWzB4ZmI0MywgMHhmYjQ0XSwgWzB4ZmI0NiwgMHhmYmMxXSxcbiBbMHhmYmQzLCAweGZkM2RdLCBbMHhmZDUwLCAweGZkOGZdLCBbMHhmZDkyLCAweGZkYzddLCBbMHhmZGYwLCAweGZkZmNdLFxuIFsweGZlNzAsIDB4ZmU3NF0sIFsweGZlNzYsIDB4ZmVmY10sIFsweDEwODAwLCAweDEwODA1XSwgWzB4MTA4MDgsIDB4MTA4MDhdLFxuIFsweDEwODBhLCAweDEwODM1XSwgWzB4MTA4MzcsIDB4MTA4MzhdLCBbMHgxMDgzYywgMHgxMDgzY10sIFsweDEwODNmLCAweDEwODU1XSxcbiBbMHgxMDg1NywgMHgxMDg1Zl0sIFsweDEwOTAwLCAweDEwOTFiXSwgWzB4MTA5MjAsIDB4MTA5MzldLCBbMHgxMDkzZiwgMHgxMDkzZl0sXG4gWzB4MTA5ODAsIDB4MTA5YjddLCBbMHgxMDliZSwgMHgxMDliZl0sIFsweDEwYTAwLCAweDEwYTAwXSwgWzB4MTBhMTAsIDB4MTBhMTNdLFxuIFsweDEwYTE1LCAweDEwYTE3XSwgWzB4MTBhMTksIDB4MTBhMzNdLCBbMHgxMGE0MCwgMHgxMGE0N10sIFsweDEwYTUwLCAweDEwYTU4XSxcbiBbMHgxMGE2MCwgMHgxMGE3Zl0sIFsweDEwYjAwLCAweDEwYjM1XSwgWzB4MTBiNDAsIDB4MTBiNTVdLCBbMHgxMGI1OCwgMHgxMGI3Ml0sXG4gWzB4MTBiNzgsIDB4MTBiN2ZdLCBbMHgxMGMwMCwgMHgxMGM0OF0sIFsweDFlZTAwLCAweDFlZTAzXSwgWzB4MWVlMDUsIDB4MWVlMWZdLFxuIFsweDFlZTIxLCAweDFlZTIyXSwgWzB4MWVlMjQsIDB4MWVlMjRdLCBbMHgxZWUyNywgMHgxZWUyN10sIFsweDFlZTI5LCAweDFlZTMyXSxcbiBbMHgxZWUzNCwgMHgxZWUzN10sIFsweDFlZTM5LCAweDFlZTM5XSwgWzB4MWVlM2IsIDB4MWVlM2JdLCBbMHgxZWU0MiwgMHgxZWU0Ml0sXG4gWzB4MWVlNDcsIDB4MWVlNDddLCBbMHgxZWU0OSwgMHgxZWU0OV0sIFsweDFlZTRiLCAweDFlZTRiXSwgWzB4MWVlNGQsIDB4MWVlNGZdLFxuIFsweDFlZTUxLCAweDFlZTUyXSwgWzB4MWVlNTQsIDB4MWVlNTRdLCBbMHgxZWU1NywgMHgxZWU1N10sIFsweDFlZTU5LCAweDFlZTU5XSxcbiBbMHgxZWU1YiwgMHgxZWU1Yl0sIFsweDFlZTVkLCAweDFlZTVkXSwgWzB4MWVlNWYsIDB4MWVlNWZdLCBbMHgxZWU2MSwgMHgxZWU2Ml0sXG4gWzB4MWVlNjQsIDB4MWVlNjRdLCBbMHgxZWU2NywgMHgxZWU2YV0sIFsweDFlZTZjLCAweDFlZTcyXSwgWzB4MWVlNzQsIDB4MWVlNzddLFxuIFsweDFlZTc5LCAweDFlZTdjXSwgWzB4MWVlN2UsIDB4MWVlN2VdLCBbMHgxZWU4MCwgMHgxZWU4OV0sIFsweDFlZThiLCAweDFlZTliXSxcbiBbMHgxZWVhMSwgMHgxZWVhM10sIFsweDFlZWE1LCAweDFlZWE5XSwgWzB4MWVlYWIsIDB4MWVlYmJdLCBbMHgxMGZmZmQsIDB4MTBmZmZkXV07XG5cbmZ1bmN0aW9uIGlzU3Ryb25nUlRMQ2hhcihjaGFyQ29kZSkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0cm9uZ1JUTFJhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBjdXJyZW50UmFuZ2UgPSBzdHJvbmdSVExSYW5nZXNbaV07XG4gICAgaWYgKGNoYXJDb2RlID49IGN1cnJlbnRSYW5nZVswXSAmJiBjaGFyQ29kZSA8PSBjdXJyZW50UmFuZ2VbMV0pIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gZGV0ZXJtaW5lQmlkaShjdWVEaXYpIHtcbiAgdmFyIG5vZGVTdGFjayA9IFtdLFxuICAgICAgdGV4dCA9IFwiXCIsXG4gICAgICBjaGFyQ29kZTtcblxuICBpZiAoIWN1ZURpdiB8fCAhY3VlRGl2LmNoaWxkTm9kZXMpIHtcbiAgICByZXR1cm4gXCJsdHJcIjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHB1c2hOb2Rlcyhub2RlU3RhY2ssIG5vZGUpIHtcbiAgICBmb3IgKHZhciBpID0gbm9kZS5jaGlsZE5vZGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBub2RlU3RhY2sucHVzaChub2RlLmNoaWxkTm9kZXNbaV0pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG5leHRUZXh0Tm9kZShub2RlU3RhY2spIHtcbiAgICBpZiAoIW5vZGVTdGFjayB8fCAhbm9kZVN0YWNrLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIG5vZGUgPSBub2RlU3RhY2sucG9wKCksXG4gICAgICAgIHRleHQgPSBub2RlLnRleHRDb250ZW50IHx8IG5vZGUuaW5uZXJUZXh0O1xuICAgIGlmICh0ZXh0KSB7XG4gICAgICAvLyBUT0RPOiBUaGlzIHNob3VsZCBtYXRjaCBhbGwgdW5pY29kZSB0eXBlIEIgY2hhcmFjdGVycyAocGFyYWdyYXBoXG4gICAgICAvLyBzZXBhcmF0b3IgY2hhcmFjdGVycykuIFNlZSBpc3N1ZSAjMTE1LlxuICAgICAgdmFyIG0gPSB0ZXh0Lm1hdGNoKC9eLiooXFxufFxccikvKTtcbiAgICAgIGlmIChtKSB7XG4gICAgICAgIG5vZGVTdGFjay5sZW5ndGggPSAwO1xuICAgICAgICByZXR1cm4gbVswXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0ZXh0O1xuICAgIH1cbiAgICBpZiAobm9kZS50YWdOYW1lID09PSBcInJ1YnlcIikge1xuICAgICAgcmV0dXJuIG5leHRUZXh0Tm9kZShub2RlU3RhY2spO1xuICAgIH1cbiAgICBpZiAobm9kZS5jaGlsZE5vZGVzKSB7XG4gICAgICBwdXNoTm9kZXMobm9kZVN0YWNrLCBub2RlKTtcbiAgICAgIHJldHVybiBuZXh0VGV4dE5vZGUobm9kZVN0YWNrKTtcbiAgICB9XG4gIH1cblxuICBwdXNoTm9kZXMobm9kZVN0YWNrLCBjdWVEaXYpO1xuICB3aGlsZSAoKHRleHQgPSBuZXh0VGV4dE5vZGUobm9kZVN0YWNrKSkpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRleHQubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNoYXJDb2RlID0gdGV4dC5jaGFyQ29kZUF0KGkpO1xuICAgICAgaWYgKGlzU3Ryb25nUlRMQ2hhcihjaGFyQ29kZSkpIHtcbiAgICAgICAgcmV0dXJuIFwicnRsXCI7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBcImx0clwiO1xufVxuXG5mdW5jdGlvbiBjb21wdXRlTGluZVBvcyhjdWUpIHtcbiAgaWYgKHR5cGVvZiBjdWUubGluZSA9PT0gXCJudW1iZXJcIiAmJlxuICAgICAgKGN1ZS5zbmFwVG9MaW5lcyB8fCAoY3VlLmxpbmUgPj0gMCAmJiBjdWUubGluZSA8PSAxMDApKSkge1xuICAgIHJldHVybiBjdWUubGluZTtcbiAgfVxuICBpZiAoIWN1ZS50cmFjayB8fCAhY3VlLnRyYWNrLnRleHRUcmFja0xpc3QgfHxcbiAgICAgICFjdWUudHJhY2sudGV4dFRyYWNrTGlzdC5tZWRpYUVsZW1lbnQpIHtcbiAgICByZXR1cm4gLTE7XG4gIH1cbiAgdmFyIHRyYWNrID0gY3VlLnRyYWNrLFxuICAgICAgdHJhY2tMaXN0ID0gdHJhY2sudGV4dFRyYWNrTGlzdCxcbiAgICAgIGNvdW50ID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmFja0xpc3QubGVuZ3RoICYmIHRyYWNrTGlzdFtpXSAhPT0gdHJhY2s7IGkrKykge1xuICAgIGlmICh0cmFja0xpc3RbaV0ubW9kZSA9PT0gXCJzaG93aW5nXCIpIHtcbiAgICAgIGNvdW50Kys7XG4gICAgfVxuICB9XG4gIHJldHVybiArK2NvdW50ICogLTE7XG59XG5cbmZ1bmN0aW9uIFN0eWxlQm94KCkge1xufVxuXG4vLyBBcHBseSBzdHlsZXMgdG8gYSBkaXYuIElmIHRoZXJlIGlzIG5vIGRpdiBwYXNzZWQgdGhlbiBpdCBkZWZhdWx0cyB0byB0aGVcbi8vIGRpdiBvbiAndGhpcycuXG5TdHlsZUJveC5wcm90b3R5cGUuYXBwbHlTdHlsZXMgPSBmdW5jdGlvbihzdHlsZXMsIGRpdikge1xuICBkaXYgPSBkaXYgfHwgdGhpcy5kaXY7XG4gIGZvciAodmFyIHByb3AgaW4gc3R5bGVzKSB7XG4gICAgaWYgKHN0eWxlcy5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICAgICAgZGl2LnN0eWxlW3Byb3BdID0gc3R5bGVzW3Byb3BdO1xuICAgIH1cbiAgfVxufTtcblxuU3R5bGVCb3gucHJvdG90eXBlLmZvcm1hdFN0eWxlID0gZnVuY3Rpb24odmFsLCB1bml0KSB7XG4gIHJldHVybiB2YWwgPT09IDAgPyAwIDogdmFsICsgdW5pdDtcbn07XG5cbi8vIENvbnN0cnVjdHMgdGhlIGNvbXB1dGVkIGRpc3BsYXkgc3RhdGUgb2YgdGhlIGN1ZSAoYSBkaXYpLiBQbGFjZXMgdGhlIGRpdlxuLy8gaW50byB0aGUgb3ZlcmxheSB3aGljaCBzaG91bGQgYmUgYSBibG9jayBsZXZlbCBlbGVtZW50ICh1c3VhbGx5IGEgZGl2KS5cbmZ1bmN0aW9uIEN1ZVN0eWxlQm94KHdpbmRvdywgY3VlLCBzdHlsZU9wdGlvbnMpIHtcbiAgdmFyIGlzSUU4ID0gKC9NU0lFXFxzOFxcLjAvKS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuICB2YXIgY29sb3IgPSBcInJnYmEoMjU1LCAyNTUsIDI1NSwgMSlcIjtcbiAgdmFyIGJhY2tncm91bmRDb2xvciA9IFwicmdiYSgwLCAwLCAwLCAwLjgpXCI7XG5cbiAgaWYgKGlzSUU4KSB7XG4gICAgY29sb3IgPSBcInJnYigyNTUsIDI1NSwgMjU1KVwiO1xuICAgIGJhY2tncm91bmRDb2xvciA9IFwicmdiKDAsIDAsIDApXCI7XG4gIH1cblxuICBTdHlsZUJveC5jYWxsKHRoaXMpO1xuICB0aGlzLmN1ZSA9IGN1ZTtcblxuICAvLyBQYXJzZSBvdXIgY3VlJ3MgdGV4dCBpbnRvIGEgRE9NIHRyZWUgcm9vdGVkIGF0ICdjdWVEaXYnLiBUaGlzIGRpdiB3aWxsXG4gIC8vIGhhdmUgaW5saW5lIHBvc2l0aW9uaW5nIGFuZCB3aWxsIGZ1bmN0aW9uIGFzIHRoZSBjdWUgYmFja2dyb3VuZCBib3guXG4gIHRoaXMuY3VlRGl2ID0gcGFyc2VDb250ZW50KHdpbmRvdywgY3VlLnRleHQpO1xuICB2YXIgc3R5bGVzID0ge1xuICAgIGNvbG9yOiBjb2xvcixcbiAgICBiYWNrZ3JvdW5kQ29sb3I6IGJhY2tncm91bmRDb2xvcixcbiAgICBwb3NpdGlvbjogXCJyZWxhdGl2ZVwiLFxuICAgIGxlZnQ6IDAsXG4gICAgcmlnaHQ6IDAsXG4gICAgdG9wOiAwLFxuICAgIGJvdHRvbTogMCxcbiAgICBkaXNwbGF5OiBcImlubGluZVwiXG4gIH07XG5cbiAgaWYgKCFpc0lFOCkge1xuICAgIHN0eWxlcy53cml0aW5nTW9kZSA9IGN1ZS52ZXJ0aWNhbCA9PT0gXCJcIiA/IFwiaG9yaXpvbnRhbC10YlwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGN1ZS52ZXJ0aWNhbCA9PT0gXCJsclwiID8gXCJ2ZXJ0aWNhbC1sclwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IFwidmVydGljYWwtcmxcIjtcbiAgICBzdHlsZXMudW5pY29kZUJpZGkgPSBcInBsYWludGV4dFwiO1xuICB9XG4gIHRoaXMuYXBwbHlTdHlsZXMoc3R5bGVzLCB0aGlzLmN1ZURpdik7XG5cbiAgLy8gQ3JlYXRlIGFuIGFic29sdXRlbHkgcG9zaXRpb25lZCBkaXYgdGhhdCB3aWxsIGJlIHVzZWQgdG8gcG9zaXRpb24gdGhlIGN1ZVxuICAvLyBkaXYuIE5vdGUsIGFsbCBXZWJWVFQgY3VlLXNldHRpbmcgYWxpZ25tZW50cyBhcmUgZXF1aXZhbGVudCB0byB0aGUgQ1NTXG4gIC8vIG1pcnJvcnMgb2YgdGhlbSBleGNlcHQgXCJtaWRkbGVcIiB3aGljaCBpcyBcImNlbnRlclwiIGluIENTUy5cbiAgdGhpcy5kaXYgPSB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgc3R5bGVzID0ge1xuICAgIHRleHRBbGlnbjogY3VlLmFsaWduID09PSBcIm1pZGRsZVwiID8gXCJjZW50ZXJcIiA6IGN1ZS5hbGlnbixcbiAgICBmb250OiBzdHlsZU9wdGlvbnMuZm9udCxcbiAgICB3aGl0ZVNwYWNlOiBcInByZS1saW5lXCIsXG4gICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIlxuICB9O1xuXG4gIGlmICghaXNJRTgpIHtcbiAgICBzdHlsZXMuZGlyZWN0aW9uID0gZGV0ZXJtaW5lQmlkaSh0aGlzLmN1ZURpdik7XG4gICAgc3R5bGVzLndyaXRpbmdNb2RlID0gY3VlLnZlcnRpY2FsID09PSBcIlwiID8gXCJob3Jpem9udGFsLXRiXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogY3VlLnZlcnRpY2FsID09PSBcImxyXCIgPyBcInZlcnRpY2FsLWxyXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogXCJ2ZXJ0aWNhbC1ybFwiLlxuICAgIHN0eWxlc3VuaWNvZGVCaWRpID0gIFwicGxhaW50ZXh0XCI7XG4gIH1cblxuICB0aGlzLmFwcGx5U3R5bGVzKHN0eWxlcyk7XG5cbiAgdGhpcy5kaXYuYXBwZW5kQ2hpbGQodGhpcy5jdWVEaXYpO1xuXG4gIC8vIENhbGN1bGF0ZSB0aGUgZGlzdGFuY2UgZnJvbSB0aGUgcmVmZXJlbmNlIGVkZ2Ugb2YgdGhlIHZpZXdwb3J0IHRvIHRoZSB0ZXh0XG4gIC8vIHBvc2l0aW9uIG9mIHRoZSBjdWUgYm94LiBUaGUgcmVmZXJlbmNlIGVkZ2Ugd2lsbCBiZSByZXNvbHZlZCBsYXRlciB3aGVuXG4gIC8vIHRoZSBib3ggb3JpZW50YXRpb24gc3R5bGVzIGFyZSBhcHBsaWVkLlxuICB2YXIgdGV4dFBvcyA9IDA7XG4gIHN3aXRjaCAoY3VlLnBvc2l0aW9uQWxpZ24pIHtcbiAgY2FzZSBcInN0YXJ0XCI6XG4gICAgdGV4dFBvcyA9IGN1ZS5wb3NpdGlvbjtcbiAgICBicmVhaztcbiAgY2FzZSBcIm1pZGRsZVwiOlxuICAgIHRleHRQb3MgPSBjdWUucG9zaXRpb24gLSAoY3VlLnNpemUgLyAyKTtcbiAgICBicmVhaztcbiAgY2FzZSBcImVuZFwiOlxuICAgIHRleHRQb3MgPSBjdWUucG9zaXRpb24gLSBjdWUuc2l6ZTtcbiAgICBicmVhaztcbiAgfVxuXG4gIC8vIEhvcml6b250YWwgYm94IG9yaWVudGF0aW9uOyB0ZXh0UG9zIGlzIHRoZSBkaXN0YW5jZSBmcm9tIHRoZSBsZWZ0IGVkZ2Ugb2YgdGhlXG4gIC8vIGFyZWEgdG8gdGhlIGxlZnQgZWRnZSBvZiB0aGUgYm94IGFuZCBjdWUuc2l6ZSBpcyB0aGUgZGlzdGFuY2UgZXh0ZW5kaW5nIHRvXG4gIC8vIHRoZSByaWdodCBmcm9tIHRoZXJlLlxuICBpZiAoY3VlLnZlcnRpY2FsID09PSBcIlwiKSB7XG4gICAgdGhpcy5hcHBseVN0eWxlcyh7XG4gICAgICBsZWZ0OiAgdGhpcy5mb3JtYXRTdHlsZSh0ZXh0UG9zLCBcIiVcIiksXG4gICAgICB3aWR0aDogdGhpcy5mb3JtYXRTdHlsZShjdWUuc2l6ZSwgXCIlXCIpXG4gICAgfSk7XG4gIC8vIFZlcnRpY2FsIGJveCBvcmllbnRhdGlvbjsgdGV4dFBvcyBpcyB0aGUgZGlzdGFuY2UgZnJvbSB0aGUgdG9wIGVkZ2Ugb2YgdGhlXG4gIC8vIGFyZWEgdG8gdGhlIHRvcCBlZGdlIG9mIHRoZSBib3ggYW5kIGN1ZS5zaXplIGlzIHRoZSBoZWlnaHQgZXh0ZW5kaW5nXG4gIC8vIGRvd253YXJkcyBmcm9tIHRoZXJlLlxuICB9IGVsc2Uge1xuICAgIHRoaXMuYXBwbHlTdHlsZXMoe1xuICAgICAgdG9wOiB0aGlzLmZvcm1hdFN0eWxlKHRleHRQb3MsIFwiJVwiKSxcbiAgICAgIGhlaWdodDogdGhpcy5mb3JtYXRTdHlsZShjdWUuc2l6ZSwgXCIlXCIpXG4gICAgfSk7XG4gIH1cblxuICB0aGlzLm1vdmUgPSBmdW5jdGlvbihib3gpIHtcbiAgICB0aGlzLmFwcGx5U3R5bGVzKHtcbiAgICAgIHRvcDogdGhpcy5mb3JtYXRTdHlsZShib3gudG9wLCBcInB4XCIpLFxuICAgICAgYm90dG9tOiB0aGlzLmZvcm1hdFN0eWxlKGJveC5ib3R0b20sIFwicHhcIiksXG4gICAgICBsZWZ0OiB0aGlzLmZvcm1hdFN0eWxlKGJveC5sZWZ0LCBcInB4XCIpLFxuICAgICAgcmlnaHQ6IHRoaXMuZm9ybWF0U3R5bGUoYm94LnJpZ2h0LCBcInB4XCIpLFxuICAgICAgaGVpZ2h0OiB0aGlzLmZvcm1hdFN0eWxlKGJveC5oZWlnaHQsIFwicHhcIiksXG4gICAgICB3aWR0aDogdGhpcy5mb3JtYXRTdHlsZShib3gud2lkdGgsIFwicHhcIilcbiAgICB9KTtcbiAgfTtcbn1cbkN1ZVN0eWxlQm94LnByb3RvdHlwZSA9IF9vYmpDcmVhdGUoU3R5bGVCb3gucHJvdG90eXBlKTtcbkN1ZVN0eWxlQm94LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEN1ZVN0eWxlQm94O1xuXG4vLyBSZXByZXNlbnRzIHRoZSBjby1vcmRpbmF0ZXMgb2YgYW4gRWxlbWVudCBpbiBhIHdheSB0aGF0IHdlIGNhbiBlYXNpbHlcbi8vIGNvbXB1dGUgdGhpbmdzIHdpdGggc3VjaCBhcyBpZiBpdCBvdmVybGFwcyBvciBpbnRlcnNlY3RzIHdpdGggYW5vdGhlciBFbGVtZW50LlxuLy8gQ2FuIGluaXRpYWxpemUgaXQgd2l0aCBlaXRoZXIgYSBTdHlsZUJveCBvciBhbm90aGVyIEJveFBvc2l0aW9uLlxuZnVuY3Rpb24gQm94UG9zaXRpb24ob2JqKSB7XG4gIHZhciBpc0lFOCA9ICgvTVNJRVxcczhcXC4wLykudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcblxuICAvLyBFaXRoZXIgYSBCb3hQb3NpdGlvbiB3YXMgcGFzc2VkIGluIGFuZCB3ZSBuZWVkIHRvIGNvcHkgaXQsIG9yIGEgU3R5bGVCb3hcbiAgLy8gd2FzIHBhc3NlZCBpbiBhbmQgd2UgbmVlZCB0byBjb3B5IHRoZSByZXN1bHRzIG9mICdnZXRCb3VuZGluZ0NsaWVudFJlY3QnXG4gIC8vIGFzIHRoZSBvYmplY3QgcmV0dXJuZWQgaXMgcmVhZG9ubHkuIEFsbCBjby1vcmRpbmF0ZSB2YWx1ZXMgYXJlIGluIHJlZmVyZW5jZVxuICAvLyB0byB0aGUgdmlld3BvcnQgb3JpZ2luICh0b3AgbGVmdCkuXG4gIHZhciBsaCwgaGVpZ2h0LCB3aWR0aCwgdG9wO1xuICBpZiAob2JqLmRpdikge1xuICAgIGhlaWdodCA9IG9iai5kaXYub2Zmc2V0SGVpZ2h0O1xuICAgIHdpZHRoID0gb2JqLmRpdi5vZmZzZXRXaWR0aDtcbiAgICB0b3AgPSBvYmouZGl2Lm9mZnNldFRvcDtcblxuICAgIHZhciByZWN0cyA9IChyZWN0cyA9IG9iai5kaXYuY2hpbGROb2RlcykgJiYgKHJlY3RzID0gcmVjdHNbMF0pICYmXG4gICAgICAgICAgICAgICAgcmVjdHMuZ2V0Q2xpZW50UmVjdHMgJiYgcmVjdHMuZ2V0Q2xpZW50UmVjdHMoKTtcbiAgICBvYmogPSBvYmouZGl2LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIC8vIEluIGNlcnRhaW4gY2FzZXMgdGhlIG91dHRlciBkaXYgd2lsbCBiZSBzbGlnaHRseSBsYXJnZXIgdGhlbiB0aGUgc3VtIG9mXG4gICAgLy8gdGhlIGlubmVyIGRpdidzIGxpbmVzLiBUaGlzIGNvdWxkIGJlIGR1ZSB0byBib2xkIHRleHQsIGV0Yywgb24gc29tZSBwbGF0Zm9ybXMuXG4gICAgLy8gSW4gdGhpcyBjYXNlIHdlIHNob3VsZCBnZXQgdGhlIGF2ZXJhZ2UgbGluZSBoZWlnaHQgYW5kIHVzZSB0aGF0LiBUaGlzIHdpbGxcbiAgICAvLyByZXN1bHQgaW4gdGhlIGRlc2lyZWQgYmVoYXZpb3VyLlxuICAgIGxoID0gcmVjdHMgPyBNYXRoLm1heCgocmVjdHNbMF0gJiYgcmVjdHNbMF0uaGVpZ2h0KSB8fCAwLCBvYmouaGVpZ2h0IC8gcmVjdHMubGVuZ3RoKVxuICAgICAgICAgICAgICAgOiAwO1xuXG4gIH1cbiAgdGhpcy5sZWZ0ID0gb2JqLmxlZnQ7XG4gIHRoaXMucmlnaHQgPSBvYmoucmlnaHQ7XG4gIHRoaXMudG9wID0gb2JqLnRvcCB8fCB0b3A7XG4gIHRoaXMuaGVpZ2h0ID0gb2JqLmhlaWdodCB8fCBoZWlnaHQ7XG4gIHRoaXMuYm90dG9tID0gb2JqLmJvdHRvbSB8fCAodG9wICsgKG9iai5oZWlnaHQgfHwgaGVpZ2h0KSk7XG4gIHRoaXMud2lkdGggPSBvYmoud2lkdGggfHwgd2lkdGg7XG4gIHRoaXMubGluZUhlaWdodCA9IGxoICE9PSB1bmRlZmluZWQgPyBsaCA6IG9iai5saW5lSGVpZ2h0O1xuXG4gIGlmIChpc0lFOCAmJiAhdGhpcy5saW5lSGVpZ2h0KSB7XG4gICAgdGhpcy5saW5lSGVpZ2h0ID0gMTM7XG4gIH1cbn1cblxuLy8gTW92ZSB0aGUgYm94IGFsb25nIGEgcGFydGljdWxhciBheGlzLiBPcHRpb25hbGx5IHBhc3MgaW4gYW4gYW1vdW50IHRvIG1vdmVcbi8vIHRoZSBib3guIElmIG5vIGFtb3VudCBpcyBwYXNzZWQgdGhlbiB0aGUgZGVmYXVsdCBpcyB0aGUgbGluZSBoZWlnaHQgb2YgdGhlXG4vLyBib3guXG5Cb3hQb3NpdGlvbi5wcm90b3R5cGUubW92ZSA9IGZ1bmN0aW9uKGF4aXMsIHRvTW92ZSkge1xuICB0b01vdmUgPSB0b01vdmUgIT09IHVuZGVmaW5lZCA/IHRvTW92ZSA6IHRoaXMubGluZUhlaWdodDtcbiAgc3dpdGNoIChheGlzKSB7XG4gIGNhc2UgXCIreFwiOlxuICAgIHRoaXMubGVmdCArPSB0b01vdmU7XG4gICAgdGhpcy5yaWdodCArPSB0b01vdmU7XG4gICAgYnJlYWs7XG4gIGNhc2UgXCIteFwiOlxuICAgIHRoaXMubGVmdCAtPSB0b01vdmU7XG4gICAgdGhpcy5yaWdodCAtPSB0b01vdmU7XG4gICAgYnJlYWs7XG4gIGNhc2UgXCIreVwiOlxuICAgIHRoaXMudG9wICs9IHRvTW92ZTtcbiAgICB0aGlzLmJvdHRvbSArPSB0b01vdmU7XG4gICAgYnJlYWs7XG4gIGNhc2UgXCIteVwiOlxuICAgIHRoaXMudG9wIC09IHRvTW92ZTtcbiAgICB0aGlzLmJvdHRvbSAtPSB0b01vdmU7XG4gICAgYnJlYWs7XG4gIH1cbn07XG5cbi8vIENoZWNrIGlmIHRoaXMgYm94IG92ZXJsYXBzIGFub3RoZXIgYm94LCBiMi5cbkJveFBvc2l0aW9uLnByb3RvdHlwZS5vdmVybGFwcyA9IGZ1bmN0aW9uKGIyKSB7XG4gIHJldHVybiB0aGlzLmxlZnQgPCBiMi5yaWdodCAmJlxuICAgICAgICAgdGhpcy5yaWdodCA+IGIyLmxlZnQgJiZcbiAgICAgICAgIHRoaXMudG9wIDwgYjIuYm90dG9tICYmXG4gICAgICAgICB0aGlzLmJvdHRvbSA+IGIyLnRvcDtcbn07XG5cbi8vIENoZWNrIGlmIHRoaXMgYm94IG92ZXJsYXBzIGFueSBvdGhlciBib3hlcyBpbiBib3hlcy5cbkJveFBvc2l0aW9uLnByb3RvdHlwZS5vdmVybGFwc0FueSA9IGZ1bmN0aW9uKGJveGVzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYm94ZXMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAodGhpcy5vdmVybGFwcyhib3hlc1tpXSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vLyBDaGVjayBpZiB0aGlzIGJveCBpcyB3aXRoaW4gYW5vdGhlciBib3guXG5Cb3hQb3NpdGlvbi5wcm90b3R5cGUud2l0aGluID0gZnVuY3Rpb24oY29udGFpbmVyKSB7XG4gIHJldHVybiB0aGlzLnRvcCA+PSBjb250YWluZXIudG9wICYmXG4gICAgICAgICB0aGlzLmJvdHRvbSA8PSBjb250YWluZXIuYm90dG9tICYmXG4gICAgICAgICB0aGlzLmxlZnQgPj0gY29udGFpbmVyLmxlZnQgJiZcbiAgICAgICAgIHRoaXMucmlnaHQgPD0gY29udGFpbmVyLnJpZ2h0O1xufTtcblxuLy8gQ2hlY2sgaWYgdGhpcyBib3ggaXMgZW50aXJlbHkgd2l0aGluIHRoZSBjb250YWluZXIgb3IgaXQgaXMgb3ZlcmxhcHBpbmdcbi8vIG9uIHRoZSBlZGdlIG9wcG9zaXRlIG9mIHRoZSBheGlzIGRpcmVjdGlvbiBwYXNzZWQuIEZvciBleGFtcGxlLCBpZiBcIit4XCIgaXNcbi8vIHBhc3NlZCBhbmQgdGhlIGJveCBpcyBvdmVybGFwcGluZyBvbiB0aGUgbGVmdCBlZGdlIG9mIHRoZSBjb250YWluZXIsIHRoZW5cbi8vIHJldHVybiB0cnVlLlxuQm94UG9zaXRpb24ucHJvdG90eXBlLm92ZXJsYXBzT3Bwb3NpdGVBeGlzID0gZnVuY3Rpb24oY29udGFpbmVyLCBheGlzKSB7XG4gIHN3aXRjaCAoYXhpcykge1xuICBjYXNlIFwiK3hcIjpcbiAgICByZXR1cm4gdGhpcy5sZWZ0IDwgY29udGFpbmVyLmxlZnQ7XG4gIGNhc2UgXCIteFwiOlxuICAgIHJldHVybiB0aGlzLnJpZ2h0ID4gY29udGFpbmVyLnJpZ2h0O1xuICBjYXNlIFwiK3lcIjpcbiAgICByZXR1cm4gdGhpcy50b3AgPCBjb250YWluZXIudG9wO1xuICBjYXNlIFwiLXlcIjpcbiAgICByZXR1cm4gdGhpcy5ib3R0b20gPiBjb250YWluZXIuYm90dG9tO1xuICB9XG59O1xuXG4vLyBGaW5kIHRoZSBwZXJjZW50YWdlIG9mIHRoZSBhcmVhIHRoYXQgdGhpcyBib3ggaXMgb3ZlcmxhcHBpbmcgd2l0aCBhbm90aGVyXG4vLyBib3guXG5Cb3hQb3NpdGlvbi5wcm90b3R5cGUuaW50ZXJzZWN0UGVyY2VudGFnZSA9IGZ1bmN0aW9uKGIyKSB7XG4gIHZhciB4ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4odGhpcy5yaWdodCwgYjIucmlnaHQpIC0gTWF0aC5tYXgodGhpcy5sZWZ0LCBiMi5sZWZ0KSksXG4gICAgICB5ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4odGhpcy5ib3R0b20sIGIyLmJvdHRvbSkgLSBNYXRoLm1heCh0aGlzLnRvcCwgYjIudG9wKSksXG4gICAgICBpbnRlcnNlY3RBcmVhID0geCAqIHk7XG4gIHJldHVybiBpbnRlcnNlY3RBcmVhIC8gKHRoaXMuaGVpZ2h0ICogdGhpcy53aWR0aCk7XG59O1xuXG4vLyBDb252ZXJ0IHRoZSBwb3NpdGlvbnMgZnJvbSB0aGlzIGJveCB0byBDU1MgY29tcGF0aWJsZSBwb3NpdGlvbnMgdXNpbmdcbi8vIHRoZSByZWZlcmVuY2UgY29udGFpbmVyJ3MgcG9zaXRpb25zLiBUaGlzIGhhcyB0byBiZSBkb25lIGJlY2F1c2UgdGhpc1xuLy8gYm94J3MgcG9zaXRpb25zIGFyZSBpbiByZWZlcmVuY2UgdG8gdGhlIHZpZXdwb3J0IG9yaWdpbiwgd2hlcmVhcywgQ1NTXG4vLyB2YWx1ZXMgYXJlIGluIHJlZmVyZWNuZSB0byB0aGVpciByZXNwZWN0aXZlIGVkZ2VzLlxuQm94UG9zaXRpb24ucHJvdG90eXBlLnRvQ1NTQ29tcGF0VmFsdWVzID0gZnVuY3Rpb24ocmVmZXJlbmNlKSB7XG4gIHJldHVybiB7XG4gICAgdG9wOiB0aGlzLnRvcCAtIHJlZmVyZW5jZS50b3AsXG4gICAgYm90dG9tOiByZWZlcmVuY2UuYm90dG9tIC0gdGhpcy5ib3R0b20sXG4gICAgbGVmdDogdGhpcy5sZWZ0IC0gcmVmZXJlbmNlLmxlZnQsXG4gICAgcmlnaHQ6IHJlZmVyZW5jZS5yaWdodCAtIHRoaXMucmlnaHQsXG4gICAgaGVpZ2h0OiB0aGlzLmhlaWdodCxcbiAgICB3aWR0aDogdGhpcy53aWR0aFxuICB9O1xufTtcblxuLy8gR2V0IGFuIG9iamVjdCB0aGF0IHJlcHJlc2VudHMgdGhlIGJveCdzIHBvc2l0aW9uIHdpdGhvdXQgYW55dGhpbmcgZXh0cmEuXG4vLyBDYW4gcGFzcyBhIFN0eWxlQm94LCBIVE1MRWxlbWVudCwgb3IgYW5vdGhlciBCb3hQb3NpdG9uLlxuQm94UG9zaXRpb24uZ2V0U2ltcGxlQm94UG9zaXRpb24gPSBmdW5jdGlvbihvYmopIHtcbiAgdmFyIGhlaWdodCA9IG9iai5kaXYgPyBvYmouZGl2Lm9mZnNldEhlaWdodCA6IG9iai50YWdOYW1lID8gb2JqLm9mZnNldEhlaWdodCA6IDA7XG4gIHZhciB3aWR0aCA9IG9iai5kaXYgPyBvYmouZGl2Lm9mZnNldFdpZHRoIDogb2JqLnRhZ05hbWUgPyBvYmoub2Zmc2V0V2lkdGggOiAwO1xuICB2YXIgdG9wID0gb2JqLmRpdiA/IG9iai5kaXYub2Zmc2V0VG9wIDogb2JqLnRhZ05hbWUgPyBvYmoub2Zmc2V0VG9wIDogMDtcblxuICBvYmogPSBvYmouZGl2ID8gb2JqLmRpdi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSA6XG4gICAgICAgICAgICAgICAgb2JqLnRhZ05hbWUgPyBvYmouZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkgOiBvYmo7XG4gIHZhciByZXQgPSB7XG4gICAgbGVmdDogb2JqLmxlZnQsXG4gICAgcmlnaHQ6IG9iai5yaWdodCxcbiAgICB0b3A6IG9iai50b3AgfHwgdG9wLFxuICAgIGhlaWdodDogb2JqLmhlaWdodCB8fCBoZWlnaHQsXG4gICAgYm90dG9tOiBvYmouYm90dG9tIHx8ICh0b3AgKyAob2JqLmhlaWdodCB8fCBoZWlnaHQpKSxcbiAgICB3aWR0aDogb2JqLndpZHRoIHx8IHdpZHRoXG4gIH07XG4gIHJldHVybiByZXQ7XG59O1xuXG4vLyBNb3ZlIGEgU3R5bGVCb3ggdG8gaXRzIHNwZWNpZmllZCwgb3IgbmV4dCBiZXN0LCBwb3NpdGlvbi4gVGhlIGNvbnRhaW5lckJveFxuLy8gaXMgdGhlIGJveCB0aGF0IGNvbnRhaW5zIHRoZSBTdHlsZUJveCwgc3VjaCBhcyBhIGRpdi4gYm94UG9zaXRpb25zIGFyZVxuLy8gYSBsaXN0IG9mIG90aGVyIGJveGVzIHRoYXQgdGhlIHN0eWxlQm94IGNhbid0IG92ZXJsYXAgd2l0aC5cbmZ1bmN0aW9uIG1vdmVCb3hUb0xpbmVQb3NpdGlvbih3aW5kb3csIHN0eWxlQm94LCBjb250YWluZXJCb3gsIGJveFBvc2l0aW9ucykge1xuXG4gIC8vIEZpbmQgdGhlIGJlc3QgcG9zaXRpb24gZm9yIGEgY3VlIGJveCwgYiwgb24gdGhlIHZpZGVvLiBUaGUgYXhpcyBwYXJhbWV0ZXJcbiAgLy8gaXMgYSBsaXN0IG9mIGF4aXMsIHRoZSBvcmRlciBvZiB3aGljaCwgaXQgd2lsbCBtb3ZlIHRoZSBib3ggYWxvbmcuIEZvciBleGFtcGxlOlxuICAvLyBQYXNzaW5nIFtcIit4XCIsIFwiLXhcIl0gd2lsbCBtb3ZlIHRoZSBib3ggZmlyc3QgYWxvbmcgdGhlIHggYXhpcyBpbiB0aGUgcG9zaXRpdmVcbiAgLy8gZGlyZWN0aW9uLiBJZiBpdCBkb2Vzbid0IGZpbmQgYSBnb29kIHBvc2l0aW9uIGZvciBpdCB0aGVyZSBpdCB3aWxsIHRoZW4gbW92ZVxuICAvLyBpdCBhbG9uZyB0aGUgeCBheGlzIGluIHRoZSBuZWdhdGl2ZSBkaXJlY3Rpb24uXG4gIGZ1bmN0aW9uIGZpbmRCZXN0UG9zaXRpb24oYiwgYXhpcykge1xuICAgIHZhciBiZXN0UG9zaXRpb24sXG4gICAgICAgIHNwZWNpZmllZFBvc2l0aW9uID0gbmV3IEJveFBvc2l0aW9uKGIpLFxuICAgICAgICBwZXJjZW50YWdlID0gMTsgLy8gSGlnaGVzdCBwb3NzaWJsZSBzbyB0aGUgZmlyc3QgdGhpbmcgd2UgZ2V0IGlzIGJldHRlci5cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgd2hpbGUgKGIub3ZlcmxhcHNPcHBvc2l0ZUF4aXMoY29udGFpbmVyQm94LCBheGlzW2ldKSB8fFxuICAgICAgICAgICAgIChiLndpdGhpbihjb250YWluZXJCb3gpICYmIGIub3ZlcmxhcHNBbnkoYm94UG9zaXRpb25zKSkpIHtcbiAgICAgICAgYi5tb3ZlKGF4aXNbaV0pO1xuICAgICAgfVxuICAgICAgLy8gV2UgZm91bmQgYSBzcG90IHdoZXJlIHdlIGFyZW4ndCBvdmVybGFwcGluZyBhbnl0aGluZy4gVGhpcyBpcyBvdXJcbiAgICAgIC8vIGJlc3QgcG9zaXRpb24uXG4gICAgICBpZiAoYi53aXRoaW4oY29udGFpbmVyQm94KSkge1xuICAgICAgICByZXR1cm4gYjtcbiAgICAgIH1cbiAgICAgIHZhciBwID0gYi5pbnRlcnNlY3RQZXJjZW50YWdlKGNvbnRhaW5lckJveCk7XG4gICAgICAvLyBJZiB3ZSdyZSBvdXRzaWRlIHRoZSBjb250YWluZXIgYm94IGxlc3MgdGhlbiB3ZSB3ZXJlIG9uIG91ciBsYXN0IHRyeVxuICAgICAgLy8gdGhlbiByZW1lbWJlciB0aGlzIHBvc2l0aW9uIGFzIHRoZSBiZXN0IHBvc2l0aW9uLlxuICAgICAgaWYgKHBlcmNlbnRhZ2UgPiBwKSB7XG4gICAgICAgIGJlc3RQb3NpdGlvbiA9IG5ldyBCb3hQb3NpdGlvbihiKTtcbiAgICAgICAgcGVyY2VudGFnZSA9IHA7XG4gICAgICB9XG4gICAgICAvLyBSZXNldCB0aGUgYm94IHBvc2l0aW9uIHRvIHRoZSBzcGVjaWZpZWQgcG9zaXRpb24uXG4gICAgICBiID0gbmV3IEJveFBvc2l0aW9uKHNwZWNpZmllZFBvc2l0aW9uKTtcbiAgICB9XG4gICAgcmV0dXJuIGJlc3RQb3NpdGlvbiB8fCBzcGVjaWZpZWRQb3NpdGlvbjtcbiAgfVxuXG4gIHZhciBib3hQb3NpdGlvbiA9IG5ldyBCb3hQb3NpdGlvbihzdHlsZUJveCksXG4gICAgICBjdWUgPSBzdHlsZUJveC5jdWUsXG4gICAgICBsaW5lUG9zID0gY29tcHV0ZUxpbmVQb3MoY3VlKSxcbiAgICAgIGF4aXMgPSBbXTtcblxuICAvLyBJZiB3ZSBoYXZlIGEgbGluZSBudW1iZXIgdG8gYWxpZ24gdGhlIGN1ZSB0by5cbiAgaWYgKGN1ZS5zbmFwVG9MaW5lcykge1xuICAgIHZhciBzaXplO1xuICAgIHN3aXRjaCAoY3VlLnZlcnRpY2FsKSB7XG4gICAgY2FzZSBcIlwiOlxuICAgICAgYXhpcyA9IFsgXCIreVwiLCBcIi15XCIgXTtcbiAgICAgIHNpemUgPSBcImhlaWdodFwiO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcInJsXCI6XG4gICAgICBheGlzID0gWyBcIit4XCIsIFwiLXhcIiBdO1xuICAgICAgc2l6ZSA9IFwid2lkdGhcIjtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJsclwiOlxuICAgICAgYXhpcyA9IFsgXCIteFwiLCBcIit4XCIgXTtcbiAgICAgIHNpemUgPSBcIndpZHRoXCI7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICB2YXIgc3RlcCA9IGJveFBvc2l0aW9uLmxpbmVIZWlnaHQsXG4gICAgICAgIHBvc2l0aW9uID0gc3RlcCAqIE1hdGgucm91bmQobGluZVBvcyksXG4gICAgICAgIG1heFBvc2l0aW9uID0gY29udGFpbmVyQm94W3NpemVdICsgc3RlcCxcbiAgICAgICAgaW5pdGlhbEF4aXMgPSBheGlzWzBdO1xuXG4gICAgLy8gSWYgdGhlIHNwZWNpZmllZCBpbnRpYWwgcG9zaXRpb24gaXMgZ3JlYXRlciB0aGVuIHRoZSBtYXggcG9zaXRpb24gdGhlblxuICAgIC8vIGNsYW1wIHRoZSBib3ggdG8gdGhlIGFtb3VudCBvZiBzdGVwcyBpdCB3b3VsZCB0YWtlIGZvciB0aGUgYm94IHRvXG4gICAgLy8gcmVhY2ggdGhlIG1heCBwb3NpdGlvbi5cbiAgICBpZiAoTWF0aC5hYnMocG9zaXRpb24pID4gbWF4UG9zaXRpb24pIHtcbiAgICAgIHBvc2l0aW9uID0gcG9zaXRpb24gPCAwID8gLTEgOiAxO1xuICAgICAgcG9zaXRpb24gKj0gTWF0aC5jZWlsKG1heFBvc2l0aW9uIC8gc3RlcCkgKiBzdGVwO1xuICAgIH1cblxuICAgIC8vIElmIGNvbXB1dGVkIGxpbmUgcG9zaXRpb24gcmV0dXJucyBuZWdhdGl2ZSB0aGVuIGxpbmUgbnVtYmVycyBhcmVcbiAgICAvLyByZWxhdGl2ZSB0byB0aGUgYm90dG9tIG9mIHRoZSB2aWRlbyBpbnN0ZWFkIG9mIHRoZSB0b3AuIFRoZXJlZm9yZSwgd2VcbiAgICAvLyBuZWVkIHRvIGluY3JlYXNlIG91ciBpbml0aWFsIHBvc2l0aW9uIGJ5IHRoZSBsZW5ndGggb3Igd2lkdGggb2YgdGhlXG4gICAgLy8gdmlkZW8sIGRlcGVuZGluZyBvbiB0aGUgd3JpdGluZyBkaXJlY3Rpb24sIGFuZCByZXZlcnNlIG91ciBheGlzIGRpcmVjdGlvbnMuXG4gICAgaWYgKGxpbmVQb3MgPCAwKSB7XG4gICAgICBwb3NpdGlvbiArPSBjdWUudmVydGljYWwgPT09IFwiXCIgPyBjb250YWluZXJCb3guaGVpZ2h0IDogY29udGFpbmVyQm94LndpZHRoO1xuICAgICAgYXhpcyA9IGF4aXMucmV2ZXJzZSgpO1xuICAgIH1cblxuICAgIC8vIE1vdmUgdGhlIGJveCB0byB0aGUgc3BlY2lmaWVkIHBvc2l0aW9uLiBUaGlzIG1heSBub3QgYmUgaXRzIGJlc3RcbiAgICAvLyBwb3NpdGlvbi5cbiAgICBib3hQb3NpdGlvbi5tb3ZlKGluaXRpYWxBeGlzLCBwb3NpdGlvbik7XG5cbiAgfSBlbHNlIHtcbiAgICAvLyBJZiB3ZSBoYXZlIGEgcGVyY2VudGFnZSBsaW5lIHZhbHVlIGZvciB0aGUgY3VlLlxuICAgIHZhciBjYWxjdWxhdGVkUGVyY2VudGFnZSA9IChib3hQb3NpdGlvbi5saW5lSGVpZ2h0IC8gY29udGFpbmVyQm94LmhlaWdodCkgKiAxMDA7XG5cbiAgICBzd2l0Y2ggKGN1ZS5saW5lQWxpZ24pIHtcbiAgICBjYXNlIFwibWlkZGxlXCI6XG4gICAgICBsaW5lUG9zIC09IChjYWxjdWxhdGVkUGVyY2VudGFnZSAvIDIpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImVuZFwiOlxuICAgICAgbGluZVBvcyAtPSBjYWxjdWxhdGVkUGVyY2VudGFnZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8vIEFwcGx5IGluaXRpYWwgbGluZSBwb3NpdGlvbiB0byB0aGUgY3VlIGJveC5cbiAgICBzd2l0Y2ggKGN1ZS52ZXJ0aWNhbCkge1xuICAgIGNhc2UgXCJcIjpcbiAgICAgIHN0eWxlQm94LmFwcGx5U3R5bGVzKHtcbiAgICAgICAgdG9wOiBzdHlsZUJveC5mb3JtYXRTdHlsZShsaW5lUG9zLCBcIiVcIilcbiAgICAgIH0pO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcInJsXCI6XG4gICAgICBzdHlsZUJveC5hcHBseVN0eWxlcyh7XG4gICAgICAgIGxlZnQ6IHN0eWxlQm94LmZvcm1hdFN0eWxlKGxpbmVQb3MsIFwiJVwiKVxuICAgICAgfSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwibHJcIjpcbiAgICAgIHN0eWxlQm94LmFwcGx5U3R5bGVzKHtcbiAgICAgICAgcmlnaHQ6IHN0eWxlQm94LmZvcm1hdFN0eWxlKGxpbmVQb3MsIFwiJVwiKVxuICAgICAgfSk7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBheGlzID0gWyBcIit5XCIsIFwiLXhcIiwgXCIreFwiLCBcIi15XCIgXTtcblxuICAgIC8vIEdldCB0aGUgYm94IHBvc2l0aW9uIGFnYWluIGFmdGVyIHdlJ3ZlIGFwcGxpZWQgdGhlIHNwZWNpZmllZCBwb3NpdGlvbmluZ1xuICAgIC8vIHRvIGl0LlxuICAgIGJveFBvc2l0aW9uID0gbmV3IEJveFBvc2l0aW9uKHN0eWxlQm94KTtcbiAgfVxuXG4gIHZhciBiZXN0UG9zaXRpb24gPSBmaW5kQmVzdFBvc2l0aW9uKGJveFBvc2l0aW9uLCBheGlzKTtcbiAgc3R5bGVCb3gubW92ZShiZXN0UG9zaXRpb24udG9DU1NDb21wYXRWYWx1ZXMoY29udGFpbmVyQm94KSk7XG59XG5cbmZ1bmN0aW9uIFdlYlZUVCgpIHtcbiAgLy8gTm90aGluZ1xufVxuXG4vLyBIZWxwZXIgdG8gYWxsb3cgc3RyaW5ncyB0byBiZSBkZWNvZGVkIGluc3RlYWQgb2YgdGhlIGRlZmF1bHQgYmluYXJ5IHV0ZjggZGF0YS5cbldlYlZUVC5TdHJpbmdEZWNvZGVyID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB7XG4gICAgZGVjb2RlOiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGRhdGEgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXJyb3IgLSBleHBlY3RlZCBzdHJpbmcgZGF0YS5cIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KGVuY29kZVVSSUNvbXBvbmVudChkYXRhKSk7XG4gICAgfVxuICB9O1xufTtcblxuV2ViVlRULmNvbnZlcnRDdWVUb0RPTVRyZWUgPSBmdW5jdGlvbih3aW5kb3csIGN1ZXRleHQpIHtcbiAgaWYgKCF3aW5kb3cgfHwgIWN1ZXRleHQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gcGFyc2VDb250ZW50KHdpbmRvdywgY3VldGV4dCk7XG59O1xuXG52YXIgRk9OVF9TSVpFX1BFUkNFTlQgPSAwLjA1O1xudmFyIEZPTlRfU1RZTEUgPSBcInNhbnMtc2VyaWZcIjtcbnZhciBDVUVfQkFDS0dST1VORF9QQURESU5HID0gXCIxLjUlXCI7XG5cbi8vIFJ1bnMgdGhlIHByb2Nlc3NpbmcgbW9kZWwgb3ZlciB0aGUgY3VlcyBhbmQgcmVnaW9ucyBwYXNzZWQgdG8gaXQuXG4vLyBAcGFyYW0gb3ZlcmxheSBBIGJsb2NrIGxldmVsIGVsZW1lbnQgKHVzdWFsbHkgYSBkaXYpIHRoYXQgdGhlIGNvbXB1dGVkIGN1ZXNcbi8vICAgICAgICAgICAgICAgIGFuZCByZWdpb25zIHdpbGwgYmUgcGxhY2VkIGludG8uXG5XZWJWVFQucHJvY2Vzc0N1ZXMgPSBmdW5jdGlvbih3aW5kb3csIGN1ZXMsIG92ZXJsYXkpIHtcbiAgaWYgKCF3aW5kb3cgfHwgIWN1ZXMgfHwgIW92ZXJsYXkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIFJlbW92ZSBhbGwgcHJldmlvdXMgY2hpbGRyZW4uXG4gIHdoaWxlIChvdmVybGF5LmZpcnN0Q2hpbGQpIHtcbiAgICBvdmVybGF5LnJlbW92ZUNoaWxkKG92ZXJsYXkuZmlyc3RDaGlsZCk7XG4gIH1cblxuICB2YXIgcGFkZGVkT3ZlcmxheSA9IHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICBwYWRkZWRPdmVybGF5LnN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xuICBwYWRkZWRPdmVybGF5LnN0eWxlLmxlZnQgPSBcIjBcIjtcbiAgcGFkZGVkT3ZlcmxheS5zdHlsZS5yaWdodCA9IFwiMFwiO1xuICBwYWRkZWRPdmVybGF5LnN0eWxlLnRvcCA9IFwiMFwiO1xuICBwYWRkZWRPdmVybGF5LnN0eWxlLmJvdHRvbSA9IFwiMFwiO1xuICBwYWRkZWRPdmVybGF5LnN0eWxlLm1hcmdpbiA9IENVRV9CQUNLR1JPVU5EX1BBRERJTkc7XG4gIG92ZXJsYXkuYXBwZW5kQ2hpbGQocGFkZGVkT3ZlcmxheSk7XG5cbiAgLy8gRGV0ZXJtaW5lIGlmIHdlIG5lZWQgdG8gY29tcHV0ZSB0aGUgZGlzcGxheSBzdGF0ZXMgb2YgdGhlIGN1ZXMuIFRoaXMgY291bGRcbiAgLy8gYmUgdGhlIGNhc2UgaWYgYSBjdWUncyBzdGF0ZSBoYXMgYmVlbiBjaGFuZ2VkIHNpbmNlIHRoZSBsYXN0IGNvbXB1dGF0aW9uIG9yXG4gIC8vIGlmIGl0IGhhcyBub3QgYmVlbiBjb21wdXRlZCB5ZXQuXG4gIGZ1bmN0aW9uIHNob3VsZENvbXB1dGUoY3Vlcykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY3Vlcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGN1ZXNbaV0uaGFzQmVlblJlc2V0IHx8ICFjdWVzW2ldLmRpc3BsYXlTdGF0ZSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gV2UgZG9uJ3QgbmVlZCB0byByZWNvbXB1dGUgdGhlIGN1ZXMnIGRpc3BsYXkgc3RhdGVzLiBKdXN0IHJldXNlIHRoZW0uXG4gIGlmICghc2hvdWxkQ29tcHV0ZShjdWVzKSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY3Vlcy5sZW5ndGg7IGkrKykge1xuICAgICAgcGFkZGVkT3ZlcmxheS5hcHBlbmRDaGlsZChjdWVzW2ldLmRpc3BsYXlTdGF0ZSk7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBib3hQb3NpdGlvbnMgPSBbXSxcbiAgICAgIGNvbnRhaW5lckJveCA9IEJveFBvc2l0aW9uLmdldFNpbXBsZUJveFBvc2l0aW9uKHBhZGRlZE92ZXJsYXkpLFxuICAgICAgZm9udFNpemUgPSBNYXRoLnJvdW5kKGNvbnRhaW5lckJveC5oZWlnaHQgKiBGT05UX1NJWkVfUEVSQ0VOVCAqIDEwMCkgLyAxMDA7XG4gIHZhciBzdHlsZU9wdGlvbnMgPSB7XG4gICAgZm9udDogZm9udFNpemUgKyBcInB4IFwiICsgRk9OVF9TVFlMRVxuICB9O1xuXG4gIChmdW5jdGlvbigpIHtcbiAgICB2YXIgc3R5bGVCb3gsIGN1ZTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY3Vlcy5sZW5ndGg7IGkrKykge1xuICAgICAgY3VlID0gY3Vlc1tpXTtcblxuICAgICAgLy8gQ29tcHV0ZSB0aGUgaW50aWFsIHBvc2l0aW9uIGFuZCBzdHlsZXMgb2YgdGhlIGN1ZSBkaXYuXG4gICAgICBzdHlsZUJveCA9IG5ldyBDdWVTdHlsZUJveCh3aW5kb3csIGN1ZSwgc3R5bGVPcHRpb25zKTtcbiAgICAgIHBhZGRlZE92ZXJsYXkuYXBwZW5kQ2hpbGQoc3R5bGVCb3guZGl2KTtcblxuICAgICAgLy8gTW92ZSB0aGUgY3VlIGRpdiB0byBpdCdzIGNvcnJlY3QgbGluZSBwb3NpdGlvbi5cbiAgICAgIG1vdmVCb3hUb0xpbmVQb3NpdGlvbih3aW5kb3csIHN0eWxlQm94LCBjb250YWluZXJCb3gsIGJveFBvc2l0aW9ucyk7XG5cbiAgICAgIC8vIFJlbWVtYmVyIHRoZSBjb21wdXRlZCBkaXYgc28gdGhhdCB3ZSBkb24ndCBoYXZlIHRvIHJlY29tcHV0ZSBpdCBsYXRlclxuICAgICAgLy8gaWYgd2UgZG9uJ3QgaGF2ZSB0b28uXG4gICAgICBjdWUuZGlzcGxheVN0YXRlID0gc3R5bGVCb3guZGl2O1xuXG4gICAgICBib3hQb3NpdGlvbnMucHVzaChCb3hQb3NpdGlvbi5nZXRTaW1wbGVCb3hQb3NpdGlvbihzdHlsZUJveCkpO1xuICAgIH1cbiAgfSkoKTtcbn07XG5cbldlYlZUVC5QYXJzZXIgPSBmdW5jdGlvbih3aW5kb3csIHZ0dGpzLCBkZWNvZGVyKSB7XG4gIGlmICghZGVjb2Rlcikge1xuICAgIGRlY29kZXIgPSB2dHRqcztcbiAgICB2dHRqcyA9IHt9O1xuICB9XG4gIGlmICghdnR0anMpIHtcbiAgICB2dHRqcyA9IHt9O1xuICB9XG5cbiAgdGhpcy53aW5kb3cgPSB3aW5kb3c7XG4gIHRoaXMudnR0anMgPSB2dHRqcztcbiAgdGhpcy5zdGF0ZSA9IFwiSU5JVElBTFwiO1xuICB0aGlzLmJ1ZmZlciA9IFwiXCI7XG4gIHRoaXMuZGVjb2RlciA9IGRlY29kZXIgfHwgbmV3IFRleHREZWNvZGVyKFwidXRmOFwiKTtcbiAgdGhpcy5yZWdpb25MaXN0ID0gW107XG59O1xuXG5XZWJWVFQuUGFyc2VyLnByb3RvdHlwZSA9IHtcbiAgLy8gSWYgdGhlIGVycm9yIGlzIGEgUGFyc2luZ0Vycm9yIHRoZW4gcmVwb3J0IGl0IHRvIHRoZSBjb25zdW1lciBpZlxuICAvLyBwb3NzaWJsZS4gSWYgaXQncyBub3QgYSBQYXJzaW5nRXJyb3IgdGhlbiB0aHJvdyBpdCBsaWtlIG5vcm1hbC5cbiAgcmVwb3J0T3JUaHJvd0Vycm9yOiBmdW5jdGlvbihlKSB7XG4gICAgaWYgKGUgaW5zdGFuY2VvZiBQYXJzaW5nRXJyb3IpIHtcbiAgICAgIHRoaXMub25wYXJzaW5nZXJyb3IgJiYgdGhpcy5vbnBhcnNpbmdlcnJvcihlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgZTtcbiAgICB9XG4gIH0sXG4gIHBhcnNlOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIC8vIElmIHRoZXJlIGlzIG5vIGRhdGEgdGhlbiB3ZSB3b24ndCBkZWNvZGUgaXQsIGJ1dCB3aWxsIGp1c3QgdHJ5IHRvIHBhcnNlXG4gICAgLy8gd2hhdGV2ZXIgaXMgaW4gYnVmZmVyIGFscmVhZHkuIFRoaXMgbWF5IG9jY3VyIGluIGNpcmN1bXN0YW5jZXMsIGZvclxuICAgIC8vIGV4YW1wbGUgd2hlbiBmbHVzaCgpIGlzIGNhbGxlZC5cbiAgICBpZiAoZGF0YSkge1xuICAgICAgLy8gVHJ5IHRvIGRlY29kZSB0aGUgZGF0YSB0aGF0IHdlIHJlY2VpdmVkLlxuICAgICAgc2VsZi5idWZmZXIgKz0gc2VsZi5kZWNvZGVyLmRlY29kZShkYXRhLCB7c3RyZWFtOiB0cnVlfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29sbGVjdE5leHRMaW5lKCkge1xuICAgICAgdmFyIGJ1ZmZlciA9IHNlbGYuYnVmZmVyO1xuICAgICAgdmFyIHBvcyA9IDA7XG4gICAgICB3aGlsZSAocG9zIDwgYnVmZmVyLmxlbmd0aCAmJiBidWZmZXJbcG9zXSAhPT0gJ1xccicgJiYgYnVmZmVyW3Bvc10gIT09ICdcXG4nKSB7XG4gICAgICAgICsrcG9zO1xuICAgICAgfVxuICAgICAgdmFyIGxpbmUgPSBidWZmZXIuc3Vic3RyKDAsIHBvcyk7XG4gICAgICAvLyBBZHZhbmNlIHRoZSBidWZmZXIgZWFybHkgaW4gY2FzZSB3ZSBmYWlsIGJlbG93LlxuICAgICAgaWYgKGJ1ZmZlcltwb3NdID09PSAnXFxyJykge1xuICAgICAgICArK3BvcztcbiAgICAgIH1cbiAgICAgIGlmIChidWZmZXJbcG9zXSA9PT0gJ1xcbicpIHtcbiAgICAgICAgKytwb3M7XG4gICAgICB9XG4gICAgICBzZWxmLmJ1ZmZlciA9IGJ1ZmZlci5zdWJzdHIocG9zKTtcbiAgICAgIHJldHVybiBsaW5lO1xuICAgIH1cblxuICAgIC8vIDMuNCBXZWJWVFQgcmVnaW9uIGFuZCBXZWJWVFQgcmVnaW9uIHNldHRpbmdzIHN5bnRheFxuICAgIGZ1bmN0aW9uIHBhcnNlUmVnaW9uKGlucHV0KSB7XG4gICAgICB2YXIgc2V0dGluZ3MgPSBuZXcgU2V0dGluZ3MoKTtcblxuICAgICAgcGFyc2VPcHRpb25zKGlucHV0LCBmdW5jdGlvbiAoaywgdikge1xuICAgICAgICBzd2l0Y2ggKGspIHtcbiAgICAgICAgY2FzZSBcImlkXCI6XG4gICAgICAgICAgc2V0dGluZ3Muc2V0KGssIHYpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwid2lkdGhcIjpcbiAgICAgICAgICBzZXR0aW5ncy5wZXJjZW50KGssIHYpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwibGluZXNcIjpcbiAgICAgICAgICBzZXR0aW5ncy5pbnRlZ2VyKGssIHYpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwicmVnaW9uYW5jaG9yXCI6XG4gICAgICAgIGNhc2UgXCJ2aWV3cG9ydGFuY2hvclwiOlxuICAgICAgICAgIHZhciB4eSA9IHYuc3BsaXQoJywnKTtcbiAgICAgICAgICBpZiAoeHkubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gV2UgaGF2ZSB0byBtYWtlIHN1cmUgYm90aCB4IGFuZCB5IHBhcnNlLCBzbyB1c2UgYSB0ZW1wb3JhcnlcbiAgICAgICAgICAvLyBzZXR0aW5ncyBvYmplY3QgaGVyZS5cbiAgICAgICAgICB2YXIgYW5jaG9yID0gbmV3IFNldHRpbmdzKCk7XG4gICAgICAgICAgYW5jaG9yLnBlcmNlbnQoXCJ4XCIsIHh5WzBdKTtcbiAgICAgICAgICBhbmNob3IucGVyY2VudChcInlcIiwgeHlbMV0pO1xuICAgICAgICAgIGlmICghYW5jaG9yLmhhcyhcInhcIikgfHwgIWFuY2hvci5oYXMoXCJ5XCIpKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgc2V0dGluZ3Muc2V0KGsgKyBcIlhcIiwgYW5jaG9yLmdldChcInhcIikpO1xuICAgICAgICAgIHNldHRpbmdzLnNldChrICsgXCJZXCIsIGFuY2hvci5nZXQoXCJ5XCIpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInNjcm9sbFwiOlxuICAgICAgICAgIHNldHRpbmdzLmFsdChrLCB2LCBbXCJ1cFwiXSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0sIC89LywgL1xccy8pO1xuXG4gICAgICAvLyBDcmVhdGUgdGhlIHJlZ2lvbiwgdXNpbmcgZGVmYXVsdCB2YWx1ZXMgZm9yIGFueSB2YWx1ZXMgdGhhdCB3ZXJlIG5vdFxuICAgICAgLy8gc3BlY2lmaWVkLlxuICAgICAgaWYgKHNldHRpbmdzLmhhcyhcImlkXCIpKSB7XG4gICAgICAgIHZhciByZWdpb24gPSBuZXcgKHNlbGYudnR0anMuVlRUUmVnaW9uIHx8IHNlbGYud2luZG93LlZUVFJlZ2lvbikoKTtcbiAgICAgICAgcmVnaW9uLndpZHRoID0gc2V0dGluZ3MuZ2V0KFwid2lkdGhcIiwgMTAwKTtcbiAgICAgICAgcmVnaW9uLmxpbmVzID0gc2V0dGluZ3MuZ2V0KFwibGluZXNcIiwgMyk7XG4gICAgICAgIHJlZ2lvbi5yZWdpb25BbmNob3JYID0gc2V0dGluZ3MuZ2V0KFwicmVnaW9uYW5jaG9yWFwiLCAwKTtcbiAgICAgICAgcmVnaW9uLnJlZ2lvbkFuY2hvclkgPSBzZXR0aW5ncy5nZXQoXCJyZWdpb25hbmNob3JZXCIsIDEwMCk7XG4gICAgICAgIHJlZ2lvbi52aWV3cG9ydEFuY2hvclggPSBzZXR0aW5ncy5nZXQoXCJ2aWV3cG9ydGFuY2hvclhcIiwgMCk7XG4gICAgICAgIHJlZ2lvbi52aWV3cG9ydEFuY2hvclkgPSBzZXR0aW5ncy5nZXQoXCJ2aWV3cG9ydGFuY2hvcllcIiwgMTAwKTtcbiAgICAgICAgcmVnaW9uLnNjcm9sbCA9IHNldHRpbmdzLmdldChcInNjcm9sbFwiLCBcIlwiKTtcbiAgICAgICAgLy8gUmVnaXN0ZXIgdGhlIHJlZ2lvbi5cbiAgICAgICAgc2VsZi5vbnJlZ2lvbiAmJiBzZWxmLm9ucmVnaW9uKHJlZ2lvbik7XG4gICAgICAgIC8vIFJlbWVtYmVyIHRoZSBWVFRSZWdpb24gZm9yIGxhdGVyIGluIGNhc2Ugd2UgcGFyc2UgYW55IFZUVEN1ZXMgdGhhdFxuICAgICAgICAvLyByZWZlcmVuY2UgaXQuXG4gICAgICAgIHNlbGYucmVnaW9uTGlzdC5wdXNoKHtcbiAgICAgICAgICBpZDogc2V0dGluZ3MuZ2V0KFwiaWRcIiksXG4gICAgICAgICAgcmVnaW9uOiByZWdpb25cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gZHJhZnQtcGFudG9zLWh0dHAtbGl2ZS1zdHJlYW1pbmctMjBcbiAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvZHJhZnQtcGFudG9zLWh0dHAtbGl2ZS1zdHJlYW1pbmctMjAjc2VjdGlvbi0zLjVcbiAgICAvLyAzLjUgV2ViVlRUXG4gICAgZnVuY3Rpb24gcGFyc2VUaW1lc3RhbXBNYXAoaW5wdXQpIHtcbiAgICAgIHZhciBzZXR0aW5ncyA9IG5ldyBTZXR0aW5ncygpO1xuXG4gICAgICBwYXJzZU9wdGlvbnMoaW5wdXQsIGZ1bmN0aW9uKGssIHYpIHtcbiAgICAgICAgc3dpdGNoKGspIHtcbiAgICAgICAgY2FzZSBcIk1QRUdUXCI6XG4gICAgICAgICAgc2V0dGluZ3MuaW50ZWdlcihrICsgJ1MnLCB2KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIkxPQ0FcIjpcbiAgICAgICAgICBzZXR0aW5ncy5zZXQoayArICdMJywgcGFyc2VUaW1lU3RhbXAodikpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9LCAvW15cXGRdOi8sIC8sLyk7XG5cbiAgICAgIHNlbGYub250aW1lc3RhbXBtYXAgJiYgc2VsZi5vbnRpbWVzdGFtcG1hcCh7XG4gICAgICAgIFwiTVBFR1RTXCI6IHNldHRpbmdzLmdldChcIk1QRUdUU1wiKSxcbiAgICAgICAgXCJMT0NBTFwiOiBzZXR0aW5ncy5nZXQoXCJMT0NBTFwiKVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gMy4yIFdlYlZUVCBtZXRhZGF0YSBoZWFkZXIgc3ludGF4XG4gICAgZnVuY3Rpb24gcGFyc2VIZWFkZXIoaW5wdXQpIHtcbiAgICAgIGlmIChpbnB1dC5tYXRjaCgvWC1USU1FU1RBTVAtTUFQLykpIHtcbiAgICAgICAgLy8gVGhpcyBsaW5lIGNvbnRhaW5zIEhMUyBYLVRJTUVTVEFNUC1NQVAgbWV0YWRhdGFcbiAgICAgICAgcGFyc2VPcHRpb25zKGlucHV0LCBmdW5jdGlvbihrLCB2KSB7XG4gICAgICAgICAgc3dpdGNoKGspIHtcbiAgICAgICAgICBjYXNlIFwiWC1USU1FU1RBTVAtTUFQXCI6XG4gICAgICAgICAgICBwYXJzZVRpbWVzdGFtcE1hcCh2KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgLz0vKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcnNlT3B0aW9ucyhpbnB1dCwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICAgICAgICBzd2l0Y2ggKGspIHtcbiAgICAgICAgICBjYXNlIFwiUmVnaW9uXCI6XG4gICAgICAgICAgICAvLyAzLjMgV2ViVlRUIHJlZ2lvbiBtZXRhZGF0YSBoZWFkZXIgc3ludGF4XG4gICAgICAgICAgICBwYXJzZVJlZ2lvbih2KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgLzovKTtcbiAgICAgIH1cblxuICAgIH1cblxuICAgIC8vIDUuMSBXZWJWVFQgZmlsZSBwYXJzaW5nLlxuICAgIHRyeSB7XG4gICAgICB2YXIgbGluZTtcbiAgICAgIGlmIChzZWxmLnN0YXRlID09PSBcIklOSVRJQUxcIikge1xuICAgICAgICAvLyBXZSBjYW4ndCBzdGFydCBwYXJzaW5nIHVudGlsIHdlIGhhdmUgdGhlIGZpcnN0IGxpbmUuXG4gICAgICAgIGlmICghL1xcclxcbnxcXG4vLnRlc3Qoc2VsZi5idWZmZXIpKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICBsaW5lID0gY29sbGVjdE5leHRMaW5lKCk7XG5cbiAgICAgICAgdmFyIG0gPSBsaW5lLm1hdGNoKC9eV0VCVlRUKFsgXFx0XS4qKT8kLyk7XG4gICAgICAgIGlmICghbSB8fCAhbVswXSkge1xuICAgICAgICAgIHRocm93IG5ldyBQYXJzaW5nRXJyb3IoUGFyc2luZ0Vycm9yLkVycm9ycy5CYWRTaWduYXR1cmUpO1xuICAgICAgICB9XG5cbiAgICAgICAgc2VsZi5zdGF0ZSA9IFwiSEVBREVSXCI7XG4gICAgICB9XG5cbiAgICAgIHZhciBhbHJlYWR5Q29sbGVjdGVkTGluZSA9IGZhbHNlO1xuICAgICAgd2hpbGUgKHNlbGYuYnVmZmVyKSB7XG4gICAgICAgIC8vIFdlIGNhbid0IHBhcnNlIGEgbGluZSB1bnRpbCB3ZSBoYXZlIHRoZSBmdWxsIGxpbmUuXG4gICAgICAgIGlmICghL1xcclxcbnxcXG4vLnRlc3Qoc2VsZi5idWZmZXIpKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWFscmVhZHlDb2xsZWN0ZWRMaW5lKSB7XG4gICAgICAgICAgbGluZSA9IGNvbGxlY3ROZXh0TGluZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFscmVhZHlDb2xsZWN0ZWRMaW5lID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBzd2l0Y2ggKHNlbGYuc3RhdGUpIHtcbiAgICAgICAgY2FzZSBcIkhFQURFUlwiOlxuICAgICAgICAgIC8vIDEzLTE4IC0gQWxsb3cgYSBoZWFkZXIgKG1ldGFkYXRhKSB1bmRlciB0aGUgV0VCVlRUIGxpbmUuXG4gICAgICAgICAgaWYgKC86Ly50ZXN0KGxpbmUpKSB7XG4gICAgICAgICAgICBwYXJzZUhlYWRlcihsaW5lKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCFsaW5lKSB7XG4gICAgICAgICAgICAvLyBBbiBlbXB0eSBsaW5lIHRlcm1pbmF0ZXMgdGhlIGhlYWRlciBhbmQgc3RhcnRzIHRoZSBib2R5IChjdWVzKS5cbiAgICAgICAgICAgIHNlbGYuc3RhdGUgPSBcIklEXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBjYXNlIFwiTk9URVwiOlxuICAgICAgICAgIC8vIElnbm9yZSBOT1RFIGJsb2Nrcy5cbiAgICAgICAgICBpZiAoIWxpbmUpIHtcbiAgICAgICAgICAgIHNlbGYuc3RhdGUgPSBcIklEXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBjYXNlIFwiSURcIjpcbiAgICAgICAgICAvLyBDaGVjayBmb3IgdGhlIHN0YXJ0IG9mIE5PVEUgYmxvY2tzLlxuICAgICAgICAgIGlmICgvXk5PVEUoJHxbIFxcdF0pLy50ZXN0KGxpbmUpKSB7XG4gICAgICAgICAgICBzZWxmLnN0YXRlID0gXCJOT1RFXCI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gMTktMjkgLSBBbGxvdyBhbnkgbnVtYmVyIG9mIGxpbmUgdGVybWluYXRvcnMsIHRoZW4gaW5pdGlhbGl6ZSBuZXcgY3VlIHZhbHVlcy5cbiAgICAgICAgICBpZiAoIWxpbmUpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzZWxmLmN1ZSA9IG5ldyAoc2VsZi52dHRqcy5WVFRDdWUgfHwgc2VsZi53aW5kb3cuVlRUQ3VlKSgwLCAwLCBcIlwiKTtcbiAgICAgICAgICBzZWxmLnN0YXRlID0gXCJDVUVcIjtcbiAgICAgICAgICAvLyAzMC0zOSAtIENoZWNrIGlmIHNlbGYgbGluZSBjb250YWlucyBhbiBvcHRpb25hbCBpZGVudGlmaWVyIG9yIHRpbWluZyBkYXRhLlxuICAgICAgICAgIGlmIChsaW5lLmluZGV4T2YoXCItLT5cIikgPT09IC0xKSB7XG4gICAgICAgICAgICBzZWxmLmN1ZS5pZCA9IGxpbmU7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gUHJvY2VzcyBsaW5lIGFzIHN0YXJ0IG9mIGEgY3VlLlxuICAgICAgICAgIC8qZmFsbHMgdGhyb3VnaCovXG4gICAgICAgIGNhc2UgXCJDVUVcIjpcbiAgICAgICAgICAvLyA0MCAtIENvbGxlY3QgY3VlIHRpbWluZ3MgYW5kIHNldHRpbmdzLlxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBwYXJzZUN1ZShsaW5lLCBzZWxmLmN1ZSwgc2VsZi5yZWdpb25MaXN0KTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBzZWxmLnJlcG9ydE9yVGhyb3dFcnJvcihlKTtcbiAgICAgICAgICAgIC8vIEluIGNhc2Ugb2YgYW4gZXJyb3IgaWdub3JlIHJlc3Qgb2YgdGhlIGN1ZS5cbiAgICAgICAgICAgIHNlbGYuY3VlID0gbnVsbDtcbiAgICAgICAgICAgIHNlbGYuc3RhdGUgPSBcIkJBRENVRVwiO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNlbGYuc3RhdGUgPSBcIkNVRVRFWFRcIjtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgY2FzZSBcIkNVRVRFWFRcIjpcbiAgICAgICAgICB2YXIgaGFzU3Vic3RyaW5nID0gbGluZS5pbmRleE9mKFwiLS0+XCIpICE9PSAtMTtcbiAgICAgICAgICAvLyAzNCAtIElmIHdlIGhhdmUgYW4gZW1wdHkgbGluZSB0aGVuIHJlcG9ydCB0aGUgY3VlLlxuICAgICAgICAgIC8vIDM1IC0gSWYgd2UgaGF2ZSB0aGUgc3BlY2lhbCBzdWJzdHJpbmcgJy0tPicgdGhlbiByZXBvcnQgdGhlIGN1ZSxcbiAgICAgICAgICAvLyBidXQgZG8gbm90IGNvbGxlY3QgdGhlIGxpbmUgYXMgd2UgbmVlZCB0byBwcm9jZXNzIHRoZSBjdXJyZW50XG4gICAgICAgICAgLy8gb25lIGFzIGEgbmV3IGN1ZS5cbiAgICAgICAgICBpZiAoIWxpbmUgfHwgaGFzU3Vic3RyaW5nICYmIChhbHJlYWR5Q29sbGVjdGVkTGluZSA9IHRydWUpKSB7XG4gICAgICAgICAgICAvLyBXZSBhcmUgZG9uZSBwYXJzaW5nIHNlbGYgY3VlLlxuICAgICAgICAgICAgc2VsZi5vbmN1ZSAmJiBzZWxmLm9uY3VlKHNlbGYuY3VlKTtcbiAgICAgICAgICAgIHNlbGYuY3VlID0gbnVsbDtcbiAgICAgICAgICAgIHNlbGYuc3RhdGUgPSBcIklEXCI7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHNlbGYuY3VlLnRleHQpIHtcbiAgICAgICAgICAgIHNlbGYuY3VlLnRleHQgKz0gXCJcXG5cIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2VsZi5jdWUudGV4dCArPSBsaW5lO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBjYXNlIFwiQkFEQ1VFXCI6IC8vIEJBRENVRVxuICAgICAgICAgIC8vIDU0LTYyIC0gQ29sbGVjdCBhbmQgZGlzY2FyZCB0aGUgcmVtYWluaW5nIGN1ZS5cbiAgICAgICAgICBpZiAoIWxpbmUpIHtcbiAgICAgICAgICAgIHNlbGYuc3RhdGUgPSBcIklEXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgc2VsZi5yZXBvcnRPclRocm93RXJyb3IoZSk7XG5cbiAgICAgIC8vIElmIHdlIGFyZSBjdXJyZW50bHkgcGFyc2luZyBhIGN1ZSwgcmVwb3J0IHdoYXQgd2UgaGF2ZS5cbiAgICAgIGlmIChzZWxmLnN0YXRlID09PSBcIkNVRVRFWFRcIiAmJiBzZWxmLmN1ZSAmJiBzZWxmLm9uY3VlKSB7XG4gICAgICAgIHNlbGYub25jdWUoc2VsZi5jdWUpO1xuICAgICAgfVxuICAgICAgc2VsZi5jdWUgPSBudWxsO1xuICAgICAgLy8gRW50ZXIgQkFEV0VCVlRUIHN0YXRlIGlmIGhlYWRlciB3YXMgbm90IHBhcnNlZCBjb3JyZWN0bHkgb3RoZXJ3aXNlXG4gICAgICAvLyBhbm90aGVyIGV4Y2VwdGlvbiBvY2N1cnJlZCBzbyBlbnRlciBCQURDVUUgc3RhdGUuXG4gICAgICBzZWxmLnN0YXRlID0gc2VsZi5zdGF0ZSA9PT0gXCJJTklUSUFMXCIgPyBcIkJBRFdFQlZUVFwiIDogXCJCQURDVUVcIjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIGZsdXNoOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHRyeSB7XG4gICAgICAvLyBGaW5pc2ggZGVjb2RpbmcgdGhlIHN0cmVhbS5cbiAgICAgIHNlbGYuYnVmZmVyICs9IHNlbGYuZGVjb2Rlci5kZWNvZGUoKTtcbiAgICAgIC8vIFN5bnRoZXNpemUgdGhlIGVuZCBvZiB0aGUgY3VycmVudCBjdWUgb3IgcmVnaW9uLlxuICAgICAgaWYgKHNlbGYuY3VlIHx8IHNlbGYuc3RhdGUgPT09IFwiSEVBREVSXCIpIHtcbiAgICAgICAgc2VsZi5idWZmZXIgKz0gXCJcXG5cXG5cIjtcbiAgICAgICAgc2VsZi5wYXJzZSgpO1xuICAgICAgfVxuICAgICAgLy8gSWYgd2UndmUgZmx1c2hlZCwgcGFyc2VkLCBhbmQgd2UncmUgc3RpbGwgb24gdGhlIElOSVRJQUwgc3RhdGUgdGhlblxuICAgICAgLy8gdGhhdCBtZWFucyB3ZSBkb24ndCBoYXZlIGVub3VnaCBvZiB0aGUgc3RyZWFtIHRvIHBhcnNlIHRoZSBmaXJzdFxuICAgICAgLy8gbGluZS5cbiAgICAgIGlmIChzZWxmLnN0YXRlID09PSBcIklOSVRJQUxcIikge1xuICAgICAgICB0aHJvdyBuZXcgUGFyc2luZ0Vycm9yKFBhcnNpbmdFcnJvci5FcnJvcnMuQmFkU2lnbmF0dXJlKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoKGUpIHtcbiAgICAgIHNlbGYucmVwb3J0T3JUaHJvd0Vycm9yKGUpO1xuICAgIH1cbiAgICBzZWxmLm9uZmx1c2ggJiYgc2VsZi5vbmZsdXNoKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gV2ViVlRUO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/videojs-contrib-media-sources/node_modules/videojs-vtt.js/lib/vtt.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/videojs-contrib-media-sources/node_modules/videojs-vtt.js/lib/vttcue.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/videojs-contrib-media-sources/node_modules/videojs-vtt.js/lib/vttcue.js ***!
  \**********************************************************************************************/
/***/ ((module) => {

eval("/**\n * Copyright 2013 vtt.js Contributors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar autoKeyword = \"auto\";\nvar directionSetting = {\n  \"\": true,\n  \"lr\": true,\n  \"rl\": true\n};\nvar alignSetting = {\n  \"start\": true,\n  \"middle\": true,\n  \"end\": true,\n  \"left\": true,\n  \"right\": true\n};\n\nfunction findDirectionSetting(value) {\n  if (typeof value !== \"string\") {\n    return false;\n  }\n  var dir = directionSetting[value.toLowerCase()];\n  return dir ? value.toLowerCase() : false;\n}\n\nfunction findAlignSetting(value) {\n  if (typeof value !== \"string\") {\n    return false;\n  }\n  var align = alignSetting[value.toLowerCase()];\n  return align ? value.toLowerCase() : false;\n}\n\nfunction extend(obj) {\n  var i = 1;\n  for (; i < arguments.length; i++) {\n    var cobj = arguments[i];\n    for (var p in cobj) {\n      obj[p] = cobj[p];\n    }\n  }\n\n  return obj;\n}\n\nfunction VTTCue(startTime, endTime, text) {\n  var cue = this;\n  var isIE8 = (/MSIE\\s8\\.0/).test(navigator.userAgent);\n  var baseObj = {};\n\n  if (isIE8) {\n    cue = document.createElement('custom');\n  } else {\n    baseObj.enumerable = true;\n  }\n\n  /**\n   * Shim implementation specific properties. These properties are not in\n   * the spec.\n   */\n\n  // Lets us know when the VTTCue's data has changed in such a way that we need\n  // to recompute its display state. This lets us compute its display state\n  // lazily.\n  cue.hasBeenReset = false;\n\n  /**\n   * VTTCue and TextTrackCue properties\n   * http://dev.w3.org/html5/webvtt/#vttcue-interface\n   */\n\n  var _id = \"\";\n  var _pauseOnExit = false;\n  var _startTime = startTime;\n  var _endTime = endTime;\n  var _text = text;\n  var _region = null;\n  var _vertical = \"\";\n  var _snapToLines = true;\n  var _line = \"auto\";\n  var _lineAlign = \"start\";\n  var _position = 50;\n  var _positionAlign = \"middle\";\n  var _size = 50;\n  var _align = \"middle\";\n\n  Object.defineProperty(cue,\n    \"id\", extend({}, baseObj, {\n      get: function() {\n        return _id;\n      },\n      set: function(value) {\n        _id = \"\" + value;\n      }\n    }));\n\n  Object.defineProperty(cue,\n    \"pauseOnExit\", extend({}, baseObj, {\n      get: function() {\n        return _pauseOnExit;\n      },\n      set: function(value) {\n        _pauseOnExit = !!value;\n      }\n    }));\n\n  Object.defineProperty(cue,\n    \"startTime\", extend({}, baseObj, {\n      get: function() {\n        return _startTime;\n      },\n      set: function(value) {\n        if (typeof value !== \"number\") {\n          throw new TypeError(\"Start time must be set to a number.\");\n        }\n        _startTime = value;\n        this.hasBeenReset = true;\n      }\n    }));\n\n  Object.defineProperty(cue,\n    \"endTime\", extend({}, baseObj, {\n      get: function() {\n        return _endTime;\n      },\n      set: function(value) {\n        if (typeof value !== \"number\") {\n          throw new TypeError(\"End time must be set to a number.\");\n        }\n        _endTime = value;\n        this.hasBeenReset = true;\n      }\n    }));\n\n  Object.defineProperty(cue,\n    \"text\", extend({}, baseObj, {\n      get: function() {\n        return _text;\n      },\n      set: function(value) {\n        _text = \"\" + value;\n        this.hasBeenReset = true;\n      }\n    }));\n\n  Object.defineProperty(cue,\n    \"region\", extend({}, baseObj, {\n      get: function() {\n        return _region;\n      },\n      set: function(value) {\n        _region = value;\n        this.hasBeenReset = true;\n      }\n    }));\n\n  Object.defineProperty(cue,\n    \"vertical\", extend({}, baseObj, {\n      get: function() {\n        return _vertical;\n      },\n      set: function(value) {\n        var setting = findDirectionSetting(value);\n        // Have to check for false because the setting an be an empty string.\n        if (setting === false) {\n          throw new SyntaxError(\"An invalid or illegal string was specified.\");\n        }\n        _vertical = setting;\n        this.hasBeenReset = true;\n      }\n    }));\n\n  Object.defineProperty(cue,\n    \"snapToLines\", extend({}, baseObj, {\n      get: function() {\n        return _snapToLines;\n      },\n      set: function(value) {\n        _snapToLines = !!value;\n        this.hasBeenReset = true;\n      }\n    }));\n\n  Object.defineProperty(cue,\n    \"line\", extend({}, baseObj, {\n      get: function() {\n        return _line;\n      },\n      set: function(value) {\n        if (typeof value !== \"number\" && value !== autoKeyword) {\n          throw new SyntaxError(\"An invalid number or illegal string was specified.\");\n        }\n        _line = value;\n        this.hasBeenReset = true;\n      }\n    }));\n\n  Object.defineProperty(cue,\n    \"lineAlign\", extend({}, baseObj, {\n      get: function() {\n        return _lineAlign;\n      },\n      set: function(value) {\n        var setting = findAlignSetting(value);\n        if (!setting) {\n          throw new SyntaxError(\"An invalid or illegal string was specified.\");\n        }\n        _lineAlign = setting;\n        this.hasBeenReset = true;\n      }\n    }));\n\n  Object.defineProperty(cue,\n    \"position\", extend({}, baseObj, {\n      get: function() {\n        return _position;\n      },\n      set: function(value) {\n        if (value < 0 || value > 100) {\n          throw new Error(\"Position must be between 0 and 100.\");\n        }\n        _position = value;\n        this.hasBeenReset = true;\n      }\n    }));\n\n  Object.defineProperty(cue,\n    \"positionAlign\", extend({}, baseObj, {\n      get: function() {\n        return _positionAlign;\n      },\n      set: function(value) {\n        var setting = findAlignSetting(value);\n        if (!setting) {\n          throw new SyntaxError(\"An invalid or illegal string was specified.\");\n        }\n        _positionAlign = setting;\n        this.hasBeenReset = true;\n      }\n    }));\n\n  Object.defineProperty(cue,\n    \"size\", extend({}, baseObj, {\n      get: function() {\n        return _size;\n      },\n      set: function(value) {\n        if (value < 0 || value > 100) {\n          throw new Error(\"Size must be between 0 and 100.\");\n        }\n        _size = value;\n        this.hasBeenReset = true;\n      }\n    }));\n\n  Object.defineProperty(cue,\n    \"align\", extend({}, baseObj, {\n      get: function() {\n        return _align;\n      },\n      set: function(value) {\n        var setting = findAlignSetting(value);\n        if (!setting) {\n          throw new SyntaxError(\"An invalid or illegal string was specified.\");\n        }\n        _align = setting;\n        this.hasBeenReset = true;\n      }\n    }));\n\n  /**\n   * Other <track> spec defined properties\n   */\n\n  // http://www.whatwg.org/specs/web-apps/current-work/multipage/the-video-element.html#text-track-cue-display-state\n  cue.displayState = undefined;\n\n  if (isIE8) {\n    return cue;\n  }\n}\n\n/**\n * VTTCue methods\n */\n\nVTTCue.prototype.getCueAsHTML = function() {\n  // Assume WebVTT.convertCueToDOMTree is on the global.\n  return WebVTT.convertCueToDOMTree(window, this.text);\n};\n\nmodule.exports = VTTCue;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdmlkZW9qcy1jb250cmliLW1lZGlhLXNvdXJjZXMvbm9kZV9tb2R1bGVzL3ZpZGVvanMtdnR0LmpzL2xpYi92dHRjdWUuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTLHNCQUFzQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktdjAtcHJvamVjdC8uL25vZGVfbW9kdWxlcy92aWRlb2pzLWNvbnRyaWItbWVkaWEtc291cmNlcy9ub2RlX21vZHVsZXMvdmlkZW9qcy12dHQuanMvbGliL3Z0dGN1ZS5qcz9iNDA5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IDIwMTMgdnR0LmpzIENvbnRyaWJ1dG9yc1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxudmFyIGF1dG9LZXl3b3JkID0gXCJhdXRvXCI7XG52YXIgZGlyZWN0aW9uU2V0dGluZyA9IHtcbiAgXCJcIjogdHJ1ZSxcbiAgXCJsclwiOiB0cnVlLFxuICBcInJsXCI6IHRydWVcbn07XG52YXIgYWxpZ25TZXR0aW5nID0ge1xuICBcInN0YXJ0XCI6IHRydWUsXG4gIFwibWlkZGxlXCI6IHRydWUsXG4gIFwiZW5kXCI6IHRydWUsXG4gIFwibGVmdFwiOiB0cnVlLFxuICBcInJpZ2h0XCI6IHRydWVcbn07XG5cbmZ1bmN0aW9uIGZpbmREaXJlY3Rpb25TZXR0aW5nKHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIGRpciA9IGRpcmVjdGlvblNldHRpbmdbdmFsdWUudG9Mb3dlckNhc2UoKV07XG4gIHJldHVybiBkaXIgPyB2YWx1ZS50b0xvd2VyQ2FzZSgpIDogZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGZpbmRBbGlnblNldHRpbmcodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgYWxpZ24gPSBhbGlnblNldHRpbmdbdmFsdWUudG9Mb3dlckNhc2UoKV07XG4gIHJldHVybiBhbGlnbiA/IHZhbHVlLnRvTG93ZXJDYXNlKCkgOiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gZXh0ZW5kKG9iaikge1xuICB2YXIgaSA9IDE7XG4gIGZvciAoOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGNvYmogPSBhcmd1bWVudHNbaV07XG4gICAgZm9yICh2YXIgcCBpbiBjb2JqKSB7XG4gICAgICBvYmpbcF0gPSBjb2JqW3BdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvYmo7XG59XG5cbmZ1bmN0aW9uIFZUVEN1ZShzdGFydFRpbWUsIGVuZFRpbWUsIHRleHQpIHtcbiAgdmFyIGN1ZSA9IHRoaXM7XG4gIHZhciBpc0lFOCA9ICgvTVNJRVxcczhcXC4wLykudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgdmFyIGJhc2VPYmogPSB7fTtcblxuICBpZiAoaXNJRTgpIHtcbiAgICBjdWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjdXN0b20nKTtcbiAgfSBlbHNlIHtcbiAgICBiYXNlT2JqLmVudW1lcmFibGUgPSB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIFNoaW0gaW1wbGVtZW50YXRpb24gc3BlY2lmaWMgcHJvcGVydGllcy4gVGhlc2UgcHJvcGVydGllcyBhcmUgbm90IGluXG4gICAqIHRoZSBzcGVjLlxuICAgKi9cblxuICAvLyBMZXRzIHVzIGtub3cgd2hlbiB0aGUgVlRUQ3VlJ3MgZGF0YSBoYXMgY2hhbmdlZCBpbiBzdWNoIGEgd2F5IHRoYXQgd2UgbmVlZFxuICAvLyB0byByZWNvbXB1dGUgaXRzIGRpc3BsYXkgc3RhdGUuIFRoaXMgbGV0cyB1cyBjb21wdXRlIGl0cyBkaXNwbGF5IHN0YXRlXG4gIC8vIGxhemlseS5cbiAgY3VlLmhhc0JlZW5SZXNldCA9IGZhbHNlO1xuXG4gIC8qKlxuICAgKiBWVFRDdWUgYW5kIFRleHRUcmFja0N1ZSBwcm9wZXJ0aWVzXG4gICAqIGh0dHA6Ly9kZXYudzMub3JnL2h0bWw1L3dlYnZ0dC8jdnR0Y3VlLWludGVyZmFjZVxuICAgKi9cblxuICB2YXIgX2lkID0gXCJcIjtcbiAgdmFyIF9wYXVzZU9uRXhpdCA9IGZhbHNlO1xuICB2YXIgX3N0YXJ0VGltZSA9IHN0YXJ0VGltZTtcbiAgdmFyIF9lbmRUaW1lID0gZW5kVGltZTtcbiAgdmFyIF90ZXh0ID0gdGV4dDtcbiAgdmFyIF9yZWdpb24gPSBudWxsO1xuICB2YXIgX3ZlcnRpY2FsID0gXCJcIjtcbiAgdmFyIF9zbmFwVG9MaW5lcyA9IHRydWU7XG4gIHZhciBfbGluZSA9IFwiYXV0b1wiO1xuICB2YXIgX2xpbmVBbGlnbiA9IFwic3RhcnRcIjtcbiAgdmFyIF9wb3NpdGlvbiA9IDUwO1xuICB2YXIgX3Bvc2l0aW9uQWxpZ24gPSBcIm1pZGRsZVwiO1xuICB2YXIgX3NpemUgPSA1MDtcbiAgdmFyIF9hbGlnbiA9IFwibWlkZGxlXCI7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSxcbiAgICBcImlkXCIsIGV4dGVuZCh7fSwgYmFzZU9iaiwge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF9pZDtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIF9pZCA9IFwiXCIgKyB2YWx1ZTtcbiAgICAgIH1cbiAgICB9KSk7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSxcbiAgICBcInBhdXNlT25FeGl0XCIsIGV4dGVuZCh7fSwgYmFzZU9iaiwge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF9wYXVzZU9uRXhpdDtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIF9wYXVzZU9uRXhpdCA9ICEhdmFsdWU7XG4gICAgICB9XG4gICAgfSkpO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdWUsXG4gICAgXCJzdGFydFRpbWVcIiwgZXh0ZW5kKHt9LCBiYXNlT2JqLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gX3N0YXJ0VGltZTtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3RhcnQgdGltZSBtdXN0IGJlIHNldCB0byBhIG51bWJlci5cIik7XG4gICAgICAgIH1cbiAgICAgICAgX3N0YXJ0VGltZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLmhhc0JlZW5SZXNldCA9IHRydWU7XG4gICAgICB9XG4gICAgfSkpO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdWUsXG4gICAgXCJlbmRUaW1lXCIsIGV4dGVuZCh7fSwgYmFzZU9iaiwge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF9lbmRUaW1lO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJFbmQgdGltZSBtdXN0IGJlIHNldCB0byBhIG51bWJlci5cIik7XG4gICAgICAgIH1cbiAgICAgICAgX2VuZFRpbWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5oYXNCZWVuUmVzZXQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pKTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VlLFxuICAgIFwidGV4dFwiLCBleHRlbmQoe30sIGJhc2VPYmosIHtcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfdGV4dDtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIF90ZXh0ID0gXCJcIiArIHZhbHVlO1xuICAgICAgICB0aGlzLmhhc0JlZW5SZXNldCA9IHRydWU7XG4gICAgICB9XG4gICAgfSkpO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdWUsXG4gICAgXCJyZWdpb25cIiwgZXh0ZW5kKHt9LCBiYXNlT2JqLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gX3JlZ2lvbjtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIF9yZWdpb24gPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5oYXNCZWVuUmVzZXQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pKTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VlLFxuICAgIFwidmVydGljYWxcIiwgZXh0ZW5kKHt9LCBiYXNlT2JqLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gX3ZlcnRpY2FsO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgdmFyIHNldHRpbmcgPSBmaW5kRGlyZWN0aW9uU2V0dGluZyh2YWx1ZSk7XG4gICAgICAgIC8vIEhhdmUgdG8gY2hlY2sgZm9yIGZhbHNlIGJlY2F1c2UgdGhlIHNldHRpbmcgYW4gYmUgYW4gZW1wdHkgc3RyaW5nLlxuICAgICAgICBpZiAoc2V0dGluZyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXCJBbiBpbnZhbGlkIG9yIGlsbGVnYWwgc3RyaW5nIHdhcyBzcGVjaWZpZWQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIF92ZXJ0aWNhbCA9IHNldHRpbmc7XG4gICAgICAgIHRoaXMuaGFzQmVlblJlc2V0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KSk7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSxcbiAgICBcInNuYXBUb0xpbmVzXCIsIGV4dGVuZCh7fSwgYmFzZU9iaiwge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF9zbmFwVG9MaW5lcztcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIF9zbmFwVG9MaW5lcyA9ICEhdmFsdWU7XG4gICAgICAgIHRoaXMuaGFzQmVlblJlc2V0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KSk7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSxcbiAgICBcImxpbmVcIiwgZXh0ZW5kKHt9LCBiYXNlT2JqLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gX2xpbmU7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcIm51bWJlclwiICYmIHZhbHVlICE9PSBhdXRvS2V5d29yZCkge1xuICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcIkFuIGludmFsaWQgbnVtYmVyIG9yIGlsbGVnYWwgc3RyaW5nIHdhcyBzcGVjaWZpZWQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIF9saW5lID0gdmFsdWU7XG4gICAgICAgIHRoaXMuaGFzQmVlblJlc2V0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KSk7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSxcbiAgICBcImxpbmVBbGlnblwiLCBleHRlbmQoe30sIGJhc2VPYmosIHtcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfbGluZUFsaWduO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgdmFyIHNldHRpbmcgPSBmaW5kQWxpZ25TZXR0aW5nKHZhbHVlKTtcbiAgICAgICAgaWYgKCFzZXR0aW5nKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFwiQW4gaW52YWxpZCBvciBpbGxlZ2FsIHN0cmluZyB3YXMgc3BlY2lmaWVkLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBfbGluZUFsaWduID0gc2V0dGluZztcbiAgICAgICAgdGhpcy5oYXNCZWVuUmVzZXQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pKTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VlLFxuICAgIFwicG9zaXRpb25cIiwgZXh0ZW5kKHt9LCBiYXNlT2JqLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gX3Bvc2l0aW9uO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlIDwgMCB8fCB2YWx1ZSA+IDEwMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBvc2l0aW9uIG11c3QgYmUgYmV0d2VlbiAwIGFuZCAxMDAuXCIpO1xuICAgICAgICB9XG4gICAgICAgIF9wb3NpdGlvbiA9IHZhbHVlO1xuICAgICAgICB0aGlzLmhhc0JlZW5SZXNldCA9IHRydWU7XG4gICAgICB9XG4gICAgfSkpO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdWUsXG4gICAgXCJwb3NpdGlvbkFsaWduXCIsIGV4dGVuZCh7fSwgYmFzZU9iaiwge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF9wb3NpdGlvbkFsaWduO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgdmFyIHNldHRpbmcgPSBmaW5kQWxpZ25TZXR0aW5nKHZhbHVlKTtcbiAgICAgICAgaWYgKCFzZXR0aW5nKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFwiQW4gaW52YWxpZCBvciBpbGxlZ2FsIHN0cmluZyB3YXMgc3BlY2lmaWVkLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBfcG9zaXRpb25BbGlnbiA9IHNldHRpbmc7XG4gICAgICAgIHRoaXMuaGFzQmVlblJlc2V0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KSk7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSxcbiAgICBcInNpemVcIiwgZXh0ZW5kKHt9LCBiYXNlT2JqLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gX3NpemU7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgPCAwIHx8IHZhbHVlID4gMTAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2l6ZSBtdXN0IGJlIGJldHdlZW4gMCBhbmQgMTAwLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBfc2l6ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLmhhc0JlZW5SZXNldCA9IHRydWU7XG4gICAgICB9XG4gICAgfSkpO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdWUsXG4gICAgXCJhbGlnblwiLCBleHRlbmQoe30sIGJhc2VPYmosIHtcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfYWxpZ247XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICB2YXIgc2V0dGluZyA9IGZpbmRBbGlnblNldHRpbmcodmFsdWUpO1xuICAgICAgICBpZiAoIXNldHRpbmcpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXCJBbiBpbnZhbGlkIG9yIGlsbGVnYWwgc3RyaW5nIHdhcyBzcGVjaWZpZWQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIF9hbGlnbiA9IHNldHRpbmc7XG4gICAgICAgIHRoaXMuaGFzQmVlblJlc2V0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KSk7XG5cbiAgLyoqXG4gICAqIE90aGVyIDx0cmFjaz4gc3BlYyBkZWZpbmVkIHByb3BlcnRpZXNcbiAgICovXG5cbiAgLy8gaHR0cDovL3d3dy53aGF0d2cub3JnL3NwZWNzL3dlYi1hcHBzL2N1cnJlbnQtd29yay9tdWx0aXBhZ2UvdGhlLXZpZGVvLWVsZW1lbnQuaHRtbCN0ZXh0LXRyYWNrLWN1ZS1kaXNwbGF5LXN0YXRlXG4gIGN1ZS5kaXNwbGF5U3RhdGUgPSB1bmRlZmluZWQ7XG5cbiAgaWYgKGlzSUU4KSB7XG4gICAgcmV0dXJuIGN1ZTtcbiAgfVxufVxuXG4vKipcbiAqIFZUVEN1ZSBtZXRob2RzXG4gKi9cblxuVlRUQ3VlLnByb3RvdHlwZS5nZXRDdWVBc0hUTUwgPSBmdW5jdGlvbigpIHtcbiAgLy8gQXNzdW1lIFdlYlZUVC5jb252ZXJ0Q3VlVG9ET01UcmVlIGlzIG9uIHRoZSBnbG9iYWwuXG4gIHJldHVybiBXZWJWVFQuY29udmVydEN1ZVRvRE9NVHJlZSh3aW5kb3csIHRoaXMudGV4dCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFZUVEN1ZTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/videojs-contrib-media-sources/node_modules/videojs-vtt.js/lib/vttcue.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/videojs-contrib-media-sources/node_modules/videojs-vtt.js/lib/vttregion.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/videojs-contrib-media-sources/node_modules/videojs-vtt.js/lib/vttregion.js ***!
  \*************************************************************************************************/
/***/ ((module) => {

eval("/**\n * Copyright 2013 vtt.js Contributors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar scrollSetting = {\n  \"\": true,\n  \"up\": true\n};\n\nfunction findScrollSetting(value) {\n  if (typeof value !== \"string\") {\n    return false;\n  }\n  var scroll = scrollSetting[value.toLowerCase()];\n  return scroll ? value.toLowerCase() : false;\n}\n\nfunction isValidPercentValue(value) {\n  return typeof value === \"number\" && (value >= 0 && value <= 100);\n}\n\n// VTTRegion shim http://dev.w3.org/html5/webvtt/#vttregion-interface\nfunction VTTRegion() {\n  var _width = 100;\n  var _lines = 3;\n  var _regionAnchorX = 0;\n  var _regionAnchorY = 100;\n  var _viewportAnchorX = 0;\n  var _viewportAnchorY = 100;\n  var _scroll = \"\";\n\n  Object.defineProperties(this, {\n    \"width\": {\n      enumerable: true,\n      get: function() {\n        return _width;\n      },\n      set: function(value) {\n        if (!isValidPercentValue(value)) {\n          throw new Error(\"Width must be between 0 and 100.\");\n        }\n        _width = value;\n      }\n    },\n    \"lines\": {\n      enumerable: true,\n      get: function() {\n        return _lines;\n      },\n      set: function(value) {\n        if (typeof value !== \"number\") {\n          throw new TypeError(\"Lines must be set to a number.\");\n        }\n        _lines = value;\n      }\n    },\n    \"regionAnchorY\": {\n      enumerable: true,\n      get: function() {\n        return _regionAnchorY;\n      },\n      set: function(value) {\n        if (!isValidPercentValue(value)) {\n          throw new Error(\"RegionAnchorX must be between 0 and 100.\");\n        }\n        _regionAnchorY = value;\n      }\n    },\n    \"regionAnchorX\": {\n      enumerable: true,\n      get: function() {\n        return _regionAnchorX;\n      },\n      set: function(value) {\n        if(!isValidPercentValue(value)) {\n          throw new Error(\"RegionAnchorY must be between 0 and 100.\");\n        }\n        _regionAnchorX = value;\n      }\n    },\n    \"viewportAnchorY\": {\n      enumerable: true,\n      get: function() {\n        return _viewportAnchorY;\n      },\n      set: function(value) {\n        if (!isValidPercentValue(value)) {\n          throw new Error(\"ViewportAnchorY must be between 0 and 100.\");\n        }\n        _viewportAnchorY = value;\n      }\n    },\n    \"viewportAnchorX\": {\n      enumerable: true,\n      get: function() {\n        return _viewportAnchorX;\n      },\n      set: function(value) {\n        if (!isValidPercentValue(value)) {\n          throw new Error(\"ViewportAnchorX must be between 0 and 100.\");\n        }\n        _viewportAnchorX = value;\n      }\n    },\n    \"scroll\": {\n      enumerable: true,\n      get: function() {\n        return _scroll;\n      },\n      set: function(value) {\n        var setting = findScrollSetting(value);\n        // Have to check for false as an empty string is a legal value.\n        if (setting === false) {\n          throw new SyntaxError(\"An invalid or illegal string was specified.\");\n        }\n        _scroll = setting;\n      }\n    }\n  });\n}\n\nmodule.exports = VTTRegion;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdmlkZW9qcy1jb250cmliLW1lZGlhLXNvdXJjZXMvbm9kZV9tb2R1bGVzL3ZpZGVvanMtdnR0LmpzL2xpYi92dHRyZWdpb24uanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS12MC1wcm9qZWN0Ly4vbm9kZV9tb2R1bGVzL3ZpZGVvanMtY29udHJpYi1tZWRpYS1zb3VyY2VzL25vZGVfbW9kdWxlcy92aWRlb2pzLXZ0dC5qcy9saWIvdnR0cmVnaW9uLmpzPzAzOTUiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMyB2dHQuanMgQ29udHJpYnV0b3JzXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG52YXIgc2Nyb2xsU2V0dGluZyA9IHtcbiAgXCJcIjogdHJ1ZSxcbiAgXCJ1cFwiOiB0cnVlXG59O1xuXG5mdW5jdGlvbiBmaW5kU2Nyb2xsU2V0dGluZyh2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBzY3JvbGwgPSBzY3JvbGxTZXR0aW5nW3ZhbHVlLnRvTG93ZXJDYXNlKCldO1xuICByZXR1cm4gc2Nyb2xsID8gdmFsdWUudG9Mb3dlckNhc2UoKSA6IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1ZhbGlkUGVyY2VudFZhbHVlKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIgJiYgKHZhbHVlID49IDAgJiYgdmFsdWUgPD0gMTAwKTtcbn1cblxuLy8gVlRUUmVnaW9uIHNoaW0gaHR0cDovL2Rldi53My5vcmcvaHRtbDUvd2VidnR0LyN2dHRyZWdpb24taW50ZXJmYWNlXG5mdW5jdGlvbiBWVFRSZWdpb24oKSB7XG4gIHZhciBfd2lkdGggPSAxMDA7XG4gIHZhciBfbGluZXMgPSAzO1xuICB2YXIgX3JlZ2lvbkFuY2hvclggPSAwO1xuICB2YXIgX3JlZ2lvbkFuY2hvclkgPSAxMDA7XG4gIHZhciBfdmlld3BvcnRBbmNob3JYID0gMDtcbiAgdmFyIF92aWV3cG9ydEFuY2hvclkgPSAxMDA7XG4gIHZhciBfc2Nyb2xsID0gXCJcIjtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG4gICAgXCJ3aWR0aFwiOiB7XG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF93aWR0aDtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIGlmICghaXNWYWxpZFBlcmNlbnRWYWx1ZSh2YWx1ZSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJXaWR0aCBtdXN0IGJlIGJldHdlZW4gMCBhbmQgMTAwLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBfd2lkdGggPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9LFxuICAgIFwibGluZXNcIjoge1xuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfbGluZXM7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkxpbmVzIG11c3QgYmUgc2V0IHRvIGEgbnVtYmVyLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBfbGluZXMgPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9LFxuICAgIFwicmVnaW9uQW5jaG9yWVwiOiB7XG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF9yZWdpb25BbmNob3JZO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgaWYgKCFpc1ZhbGlkUGVyY2VudFZhbHVlKHZhbHVlKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlJlZ2lvbkFuY2hvclggbXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDEwMC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgX3JlZ2lvbkFuY2hvclkgPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9LFxuICAgIFwicmVnaW9uQW5jaG9yWFwiOiB7XG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF9yZWdpb25BbmNob3JYO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgaWYoIWlzVmFsaWRQZXJjZW50VmFsdWUodmFsdWUpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUmVnaW9uQW5jaG9yWSBtdXN0IGJlIGJldHdlZW4gMCBhbmQgMTAwLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBfcmVnaW9uQW5jaG9yWCA9IHZhbHVlO1xuICAgICAgfVxuICAgIH0sXG4gICAgXCJ2aWV3cG9ydEFuY2hvcllcIjoge1xuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfdmlld3BvcnRBbmNob3JZO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgaWYgKCFpc1ZhbGlkUGVyY2VudFZhbHVlKHZhbHVlKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlZpZXdwb3J0QW5jaG9yWSBtdXN0IGJlIGJldHdlZW4gMCBhbmQgMTAwLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBfdmlld3BvcnRBbmNob3JZID0gdmFsdWU7XG4gICAgICB9XG4gICAgfSxcbiAgICBcInZpZXdwb3J0QW5jaG9yWFwiOiB7XG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF92aWV3cG9ydEFuY2hvclg7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICBpZiAoIWlzVmFsaWRQZXJjZW50VmFsdWUodmFsdWUpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVmlld3BvcnRBbmNob3JYIG11c3QgYmUgYmV0d2VlbiAwIGFuZCAxMDAuXCIpO1xuICAgICAgICB9XG4gICAgICAgIF92aWV3cG9ydEFuY2hvclggPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9LFxuICAgIFwic2Nyb2xsXCI6IHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gX3Njcm9sbDtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHZhciBzZXR0aW5nID0gZmluZFNjcm9sbFNldHRpbmcodmFsdWUpO1xuICAgICAgICAvLyBIYXZlIHRvIGNoZWNrIGZvciBmYWxzZSBhcyBhbiBlbXB0eSBzdHJpbmcgaXMgYSBsZWdhbCB2YWx1ZS5cbiAgICAgICAgaWYgKHNldHRpbmcgPT09IGZhbHNlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFwiQW4gaW52YWxpZCBvciBpbGxlZ2FsIHN0cmluZyB3YXMgc3BlY2lmaWVkLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBfc2Nyb2xsID0gc2V0dGluZztcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFZUVFJlZ2lvbjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/videojs-contrib-media-sources/node_modules/videojs-vtt.js/lib/vttregion.js\n");

/***/ })

};
;