"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/mpd-parser";
exports.ids = ["vendor-chunks/mpd-parser"];
exports.modules = {

/***/ "(ssr)/./node_modules/mpd-parser/dist/mpd-parser.cjs.js":
/*!********************************************************!*\
  !*** ./node_modules/mpd-parser/dist/mpd-parser.cjs.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/*! @name mpd-parser @version 1.3.1 @license Apache-2.0 */\n\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\nvar resolveUrl = __webpack_require__(/*! @videojs/vhs-utils/cjs/resolve-url */ \"(ssr)/./node_modules/@videojs/vhs-utils/cjs/resolve-url.js\");\nvar window = __webpack_require__(/*! global/window */ \"(ssr)/./node_modules/global/window.js\");\nvar mediaGroups = __webpack_require__(/*! @videojs/vhs-utils/cjs/media-groups */ \"(ssr)/./node_modules/@videojs/vhs-utils/cjs/media-groups.js\");\nvar decodeB64ToUint8Array = __webpack_require__(/*! @videojs/vhs-utils/cjs/decode-b64-to-uint8-array */ \"(ssr)/./node_modules/@videojs/vhs-utils/cjs/decode-b64-to-uint8-array.js\");\nvar xmldom = __webpack_require__(/*! @xmldom/xmldom */ \"(ssr)/./node_modules/@xmldom/xmldom/lib/index.js\");\n\nfunction _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }\n\nvar resolveUrl__default = /*#__PURE__*/_interopDefaultLegacy(resolveUrl);\nvar window__default = /*#__PURE__*/_interopDefaultLegacy(window);\nvar decodeB64ToUint8Array__default = /*#__PURE__*/_interopDefaultLegacy(decodeB64ToUint8Array);\n\nvar version = \"1.3.1\";\n\nconst isObject = obj => {\n  return !!obj && typeof obj === 'object';\n};\n\nconst merge = (...objects) => {\n  return objects.reduce((result, source) => {\n    if (typeof source !== 'object') {\n      return result;\n    }\n\n    Object.keys(source).forEach(key => {\n      if (Array.isArray(result[key]) && Array.isArray(source[key])) {\n        result[key] = result[key].concat(source[key]);\n      } else if (isObject(result[key]) && isObject(source[key])) {\n        result[key] = merge(result[key], source[key]);\n      } else {\n        result[key] = source[key];\n      }\n    });\n    return result;\n  }, {});\n};\nconst values = o => Object.keys(o).map(k => o[k]);\n\nconst range = (start, end) => {\n  const result = [];\n\n  for (let i = start; i < end; i++) {\n    result.push(i);\n  }\n\n  return result;\n};\nconst flatten = lists => lists.reduce((x, y) => x.concat(y), []);\nconst from = list => {\n  if (!list.length) {\n    return [];\n  }\n\n  const result = [];\n\n  for (let i = 0; i < list.length; i++) {\n    result.push(list[i]);\n  }\n\n  return result;\n};\nconst findIndexes = (l, key) => l.reduce((a, e, i) => {\n  if (e[key]) {\n    a.push(i);\n  }\n\n  return a;\n}, []);\n/**\n * Returns a union of the included lists provided each element can be identified by a key.\n *\n * @param {Array} list - list of lists to get the union of\n * @param {Function} keyFunction - the function to use as a key for each element\n *\n * @return {Array} the union of the arrays\n */\n\nconst union = (lists, keyFunction) => {\n  return values(lists.reduce((acc, list) => {\n    list.forEach(el => {\n      acc[keyFunction(el)] = el;\n    });\n    return acc;\n  }, {}));\n};\n\nvar errors = {\n  INVALID_NUMBER_OF_PERIOD: 'INVALID_NUMBER_OF_PERIOD',\n  INVALID_NUMBER_OF_CONTENT_STEERING: 'INVALID_NUMBER_OF_CONTENT_STEERING',\n  DASH_EMPTY_MANIFEST: 'DASH_EMPTY_MANIFEST',\n  DASH_INVALID_XML: 'DASH_INVALID_XML',\n  NO_BASE_URL: 'NO_BASE_URL',\n  MISSING_SEGMENT_INFORMATION: 'MISSING_SEGMENT_INFORMATION',\n  SEGMENT_TIME_UNSPECIFIED: 'SEGMENT_TIME_UNSPECIFIED',\n  UNSUPPORTED_UTC_TIMING_SCHEME: 'UNSUPPORTED_UTC_TIMING_SCHEME'\n};\n\n/**\n * @typedef {Object} SingleUri\n * @property {string} uri - relative location of segment\n * @property {string} resolvedUri - resolved location of segment\n * @property {Object} byterange - Object containing information on how to make byte range\n *   requests following byte-range-spec per RFC2616.\n * @property {String} byterange.length - length of range request\n * @property {String} byterange.offset - byte offset of range request\n *\n * @see https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.35.1\n */\n\n/**\n * Converts a URLType node (5.3.9.2.3 Table 13) to a segment object\n * that conforms to how m3u8-parser is structured\n *\n * @see https://github.com/videojs/m3u8-parser\n *\n * @param {string} baseUrl - baseUrl provided by <BaseUrl> nodes\n * @param {string} source - source url for segment\n * @param {string} range - optional range used for range calls,\n *   follows  RFC 2616, Clause 14.35.1\n * @return {SingleUri} full segment information transformed into a format similar\n *   to m3u8-parser\n */\n\nconst urlTypeToSegment = ({\n  baseUrl = '',\n  source = '',\n  range = '',\n  indexRange = ''\n}) => {\n  const segment = {\n    uri: source,\n    resolvedUri: resolveUrl__default['default'](baseUrl || '', source)\n  };\n\n  if (range || indexRange) {\n    const rangeStr = range ? range : indexRange;\n    const ranges = rangeStr.split('-'); // default to parsing this as a BigInt if possible\n\n    let startRange = window__default['default'].BigInt ? window__default['default'].BigInt(ranges[0]) : parseInt(ranges[0], 10);\n    let endRange = window__default['default'].BigInt ? window__default['default'].BigInt(ranges[1]) : parseInt(ranges[1], 10); // convert back to a number if less than MAX_SAFE_INTEGER\n\n    if (startRange < Number.MAX_SAFE_INTEGER && typeof startRange === 'bigint') {\n      startRange = Number(startRange);\n    }\n\n    if (endRange < Number.MAX_SAFE_INTEGER && typeof endRange === 'bigint') {\n      endRange = Number(endRange);\n    }\n\n    let length;\n\n    if (typeof endRange === 'bigint' || typeof startRange === 'bigint') {\n      length = window__default['default'].BigInt(endRange) - window__default['default'].BigInt(startRange) + window__default['default'].BigInt(1);\n    } else {\n      length = endRange - startRange + 1;\n    }\n\n    if (typeof length === 'bigint' && length < Number.MAX_SAFE_INTEGER) {\n      length = Number(length);\n    } // byterange should be inclusive according to\n    // RFC 2616, Clause 14.35.1\n\n\n    segment.byterange = {\n      length,\n      offset: startRange\n    };\n  }\n\n  return segment;\n};\nconst byteRangeToString = byterange => {\n  // `endRange` is one less than `offset + length` because the HTTP range\n  // header uses inclusive ranges\n  let endRange;\n\n  if (typeof byterange.offset === 'bigint' || typeof byterange.length === 'bigint') {\n    endRange = window__default['default'].BigInt(byterange.offset) + window__default['default'].BigInt(byterange.length) - window__default['default'].BigInt(1);\n  } else {\n    endRange = byterange.offset + byterange.length - 1;\n  }\n\n  return `${byterange.offset}-${endRange}`;\n};\n\n/**\n * parse the end number attribue that can be a string\n * number, or undefined.\n *\n * @param {string|number|undefined} endNumber\n *        The end number attribute.\n *\n * @return {number|null}\n *          The result of parsing the end number.\n */\n\nconst parseEndNumber = endNumber => {\n  if (endNumber && typeof endNumber !== 'number') {\n    endNumber = parseInt(endNumber, 10);\n  }\n\n  if (isNaN(endNumber)) {\n    return null;\n  }\n\n  return endNumber;\n};\n/**\n * Functions for calculating the range of available segments in static and dynamic\n * manifests.\n */\n\n\nconst segmentRange = {\n  /**\n   * Returns the entire range of available segments for a static MPD\n   *\n   * @param {Object} attributes\n   *        Inheritied MPD attributes\n   * @return {{ start: number, end: number }}\n   *         The start and end numbers for available segments\n   */\n  static(attributes) {\n    const {\n      duration,\n      timescale = 1,\n      sourceDuration,\n      periodDuration\n    } = attributes;\n    const endNumber = parseEndNumber(attributes.endNumber);\n    const segmentDuration = duration / timescale;\n\n    if (typeof endNumber === 'number') {\n      return {\n        start: 0,\n        end: endNumber\n      };\n    }\n\n    if (typeof periodDuration === 'number') {\n      return {\n        start: 0,\n        end: periodDuration / segmentDuration\n      };\n    }\n\n    return {\n      start: 0,\n      end: sourceDuration / segmentDuration\n    };\n  },\n\n  /**\n   * Returns the current live window range of available segments for a dynamic MPD\n   *\n   * @param {Object} attributes\n   *        Inheritied MPD attributes\n   * @return {{ start: number, end: number }}\n   *         The start and end numbers for available segments\n   */\n  dynamic(attributes) {\n    const {\n      NOW,\n      clientOffset,\n      availabilityStartTime,\n      timescale = 1,\n      duration,\n      periodStart = 0,\n      minimumUpdatePeriod = 0,\n      timeShiftBufferDepth = Infinity\n    } = attributes;\n    const endNumber = parseEndNumber(attributes.endNumber); // clientOffset is passed in at the top level of mpd-parser and is an offset calculated\n    // after retrieving UTC server time.\n\n    const now = (NOW + clientOffset) / 1000; // WC stands for Wall Clock.\n    // Convert the period start time to EPOCH.\n\n    const periodStartWC = availabilityStartTime + periodStart; // Period end in EPOCH is manifest's retrieval time + time until next update.\n\n    const periodEndWC = now + minimumUpdatePeriod;\n    const periodDuration = periodEndWC - periodStartWC;\n    const segmentCount = Math.ceil(periodDuration * timescale / duration);\n    const availableStart = Math.floor((now - periodStartWC - timeShiftBufferDepth) * timescale / duration);\n    const availableEnd = Math.floor((now - periodStartWC) * timescale / duration);\n    return {\n      start: Math.max(0, availableStart),\n      end: typeof endNumber === 'number' ? endNumber : Math.min(segmentCount, availableEnd)\n    };\n  }\n\n};\n/**\n * Maps a range of numbers to objects with information needed to build the corresponding\n * segment list\n *\n * @name toSegmentsCallback\n * @function\n * @param {number} number\n *        Number of the segment\n * @param {number} index\n *        Index of the number in the range list\n * @return {{ number: Number, duration: Number, timeline: Number, time: Number }}\n *         Object with segment timing and duration info\n */\n\n/**\n * Returns a callback for Array.prototype.map for mapping a range of numbers to\n * information needed to build the segment list.\n *\n * @param {Object} attributes\n *        Inherited MPD attributes\n * @return {toSegmentsCallback}\n *         Callback map function\n */\n\nconst toSegments = attributes => number => {\n  const {\n    duration,\n    timescale = 1,\n    periodStart,\n    startNumber = 1\n  } = attributes;\n  return {\n    number: startNumber + number,\n    duration: duration / timescale,\n    timeline: periodStart,\n    time: number * duration\n  };\n};\n/**\n * Returns a list of objects containing segment timing and duration info used for\n * building the list of segments. This uses the @duration attribute specified\n * in the MPD manifest to derive the range of segments.\n *\n * @param {Object} attributes\n *        Inherited MPD attributes\n * @return {{number: number, duration: number, time: number, timeline: number}[]}\n *         List of Objects with segment timing and duration info\n */\n\nconst parseByDuration = attributes => {\n  const {\n    type,\n    duration,\n    timescale = 1,\n    periodDuration,\n    sourceDuration\n  } = attributes;\n  const {\n    start,\n    end\n  } = segmentRange[type](attributes);\n  const segments = range(start, end).map(toSegments(attributes));\n\n  if (type === 'static') {\n    const index = segments.length - 1; // section is either a period or the full source\n\n    const sectionDuration = typeof periodDuration === 'number' ? periodDuration : sourceDuration; // final segment may be less than full segment duration\n\n    segments[index].duration = sectionDuration - duration / timescale * index;\n  }\n\n  return segments;\n};\n\n/**\n * Translates SegmentBase into a set of segments.\n * (DASH SPEC Section 5.3.9.3.2) contains a set of <SegmentURL> nodes.  Each\n * node should be translated into segment.\n *\n * @param {Object} attributes\n *   Object containing all inherited attributes from parent elements with attribute\n *   names as keys\n * @return {Object.<Array>} list of segments\n */\n\nconst segmentsFromBase = attributes => {\n  const {\n    baseUrl,\n    initialization = {},\n    sourceDuration,\n    indexRange = '',\n    periodStart,\n    presentationTime,\n    number = 0,\n    duration\n  } = attributes; // base url is required for SegmentBase to work, per spec (Section 5.3.9.2.1)\n\n  if (!baseUrl) {\n    throw new Error(errors.NO_BASE_URL);\n  }\n\n  const initSegment = urlTypeToSegment({\n    baseUrl,\n    source: initialization.sourceURL,\n    range: initialization.range\n  });\n  const segment = urlTypeToSegment({\n    baseUrl,\n    source: baseUrl,\n    indexRange\n  });\n  segment.map = initSegment; // If there is a duration, use it, otherwise use the given duration of the source\n  // (since SegmentBase is only for one total segment)\n\n  if (duration) {\n    const segmentTimeInfo = parseByDuration(attributes);\n\n    if (segmentTimeInfo.length) {\n      segment.duration = segmentTimeInfo[0].duration;\n      segment.timeline = segmentTimeInfo[0].timeline;\n    }\n  } else if (sourceDuration) {\n    segment.duration = sourceDuration;\n    segment.timeline = periodStart;\n  } // If presentation time is provided, these segments are being generated by SIDX\n  // references, and should use the time provided. For the general case of SegmentBase,\n  // there should only be one segment in the period, so its presentation time is the same\n  // as its period start.\n\n\n  segment.presentationTime = presentationTime || periodStart;\n  segment.number = number;\n  return [segment];\n};\n/**\n * Given a playlist, a sidx box, and a baseUrl, update the segment list of the playlist\n * according to the sidx information given.\n *\n * playlist.sidx has metadadata about the sidx where-as the sidx param\n * is the parsed sidx box itself.\n *\n * @param {Object} playlist the playlist to update the sidx information for\n * @param {Object} sidx the parsed sidx box\n * @return {Object} the playlist object with the updated sidx information\n */\n\nconst addSidxSegmentsToPlaylist$1 = (playlist, sidx, baseUrl) => {\n  // Retain init segment information\n  const initSegment = playlist.sidx.map ? playlist.sidx.map : null; // Retain source duration from initial main manifest parsing\n\n  const sourceDuration = playlist.sidx.duration; // Retain source timeline\n\n  const timeline = playlist.timeline || 0;\n  const sidxByteRange = playlist.sidx.byterange;\n  const sidxEnd = sidxByteRange.offset + sidxByteRange.length; // Retain timescale of the parsed sidx\n\n  const timescale = sidx.timescale; // referenceType 1 refers to other sidx boxes\n\n  const mediaReferences = sidx.references.filter(r => r.referenceType !== 1);\n  const segments = [];\n  const type = playlist.endList ? 'static' : 'dynamic';\n  const periodStart = playlist.sidx.timeline;\n  let presentationTime = periodStart;\n  let number = playlist.mediaSequence || 0; // firstOffset is the offset from the end of the sidx box\n\n  let startIndex; // eslint-disable-next-line\n\n  if (typeof sidx.firstOffset === 'bigint') {\n    startIndex = window__default['default'].BigInt(sidxEnd) + sidx.firstOffset;\n  } else {\n    startIndex = sidxEnd + sidx.firstOffset;\n  }\n\n  for (let i = 0; i < mediaReferences.length; i++) {\n    const reference = sidx.references[i]; // size of the referenced (sub)segment\n\n    const size = reference.referencedSize; // duration of the referenced (sub)segment, in  the  timescale\n    // this will be converted to seconds when generating segments\n\n    const duration = reference.subsegmentDuration; // should be an inclusive range\n\n    let endIndex; // eslint-disable-next-line\n\n    if (typeof startIndex === 'bigint') {\n      endIndex = startIndex + window__default['default'].BigInt(size) - window__default['default'].BigInt(1);\n    } else {\n      endIndex = startIndex + size - 1;\n    }\n\n    const indexRange = `${startIndex}-${endIndex}`;\n    const attributes = {\n      baseUrl,\n      timescale,\n      timeline,\n      periodStart,\n      presentationTime,\n      number,\n      duration,\n      sourceDuration,\n      indexRange,\n      type\n    };\n    const segment = segmentsFromBase(attributes)[0];\n\n    if (initSegment) {\n      segment.map = initSegment;\n    }\n\n    segments.push(segment);\n\n    if (typeof startIndex === 'bigint') {\n      startIndex += window__default['default'].BigInt(size);\n    } else {\n      startIndex += size;\n    }\n\n    presentationTime += duration / timescale;\n    number++;\n  }\n\n  playlist.segments = segments;\n  return playlist;\n};\n\nconst SUPPORTED_MEDIA_TYPES = ['AUDIO', 'SUBTITLES']; // allow one 60fps frame as leniency (arbitrarily chosen)\n\nconst TIME_FUDGE = 1 / 60;\n/**\n * Given a list of timelineStarts, combines, dedupes, and sorts them.\n *\n * @param {TimelineStart[]} timelineStarts - list of timeline starts\n *\n * @return {TimelineStart[]} the combined and deduped timeline starts\n */\n\nconst getUniqueTimelineStarts = timelineStarts => {\n  return union(timelineStarts, ({\n    timeline\n  }) => timeline).sort((a, b) => a.timeline > b.timeline ? 1 : -1);\n};\n/**\n * Finds the playlist with the matching NAME attribute.\n *\n * @param {Array} playlists - playlists to search through\n * @param {string} name - the NAME attribute to search for\n *\n * @return {Object|null} the matching playlist object, or null\n */\n\nconst findPlaylistWithName = (playlists, name) => {\n  for (let i = 0; i < playlists.length; i++) {\n    if (playlists[i].attributes.NAME === name) {\n      return playlists[i];\n    }\n  }\n\n  return null;\n};\n/**\n * Gets a flattened array of media group playlists.\n *\n * @param {Object} manifest - the main manifest object\n *\n * @return {Array} the media group playlists\n */\n\nconst getMediaGroupPlaylists = manifest => {\n  let mediaGroupPlaylists = [];\n  mediaGroups.forEachMediaGroup(manifest, SUPPORTED_MEDIA_TYPES, (properties, type, group, label) => {\n    mediaGroupPlaylists = mediaGroupPlaylists.concat(properties.playlists || []);\n  });\n  return mediaGroupPlaylists;\n};\n/**\n * Updates the playlist's media sequence numbers.\n *\n * @param {Object} config - options object\n * @param {Object} config.playlist - the playlist to update\n * @param {number} config.mediaSequence - the mediaSequence number to start with\n */\n\nconst updateMediaSequenceForPlaylist = ({\n  playlist,\n  mediaSequence\n}) => {\n  playlist.mediaSequence = mediaSequence;\n  playlist.segments.forEach((segment, index) => {\n    segment.number = playlist.mediaSequence + index;\n  });\n};\n/**\n * Updates the media and discontinuity sequence numbers of newPlaylists given oldPlaylists\n * and a complete list of timeline starts.\n *\n * If no matching playlist is found, only the discontinuity sequence number of the playlist\n * will be updated.\n *\n * Since early available timelines are not supported, at least one segment must be present.\n *\n * @param {Object} config - options object\n * @param {Object[]} oldPlaylists - the old playlists to use as a reference\n * @param {Object[]} newPlaylists - the new playlists to update\n * @param {Object} timelineStarts - all timelineStarts seen in the stream to this point\n */\n\nconst updateSequenceNumbers = ({\n  oldPlaylists,\n  newPlaylists,\n  timelineStarts\n}) => {\n  newPlaylists.forEach(playlist => {\n    playlist.discontinuitySequence = timelineStarts.findIndex(function ({\n      timeline\n    }) {\n      return timeline === playlist.timeline;\n    }); // Playlists NAMEs come from DASH Representation IDs, which are mandatory\n    // (see ISO_23009-1-2012 5.3.5.2).\n    //\n    // If the same Representation existed in a prior Period, it will retain the same NAME.\n\n    const oldPlaylist = findPlaylistWithName(oldPlaylists, playlist.attributes.NAME);\n\n    if (!oldPlaylist) {\n      // Since this is a new playlist, the media sequence values can start from 0 without\n      // consequence.\n      return;\n    } // TODO better support for live SIDX\n    //\n    // As of this writing, mpd-parser does not support multiperiod SIDX (in live or VOD).\n    // This is evident by a playlist only having a single SIDX reference. In a multiperiod\n    // playlist there would need to be multiple SIDX references. In addition, live SIDX is\n    // not supported when the SIDX properties change on refreshes.\n    //\n    // In the future, if support needs to be added, the merging logic here can be called\n    // after SIDX references are resolved. For now, exit early to prevent exceptions being\n    // thrown due to undefined references.\n\n\n    if (playlist.sidx) {\n      return;\n    } // Since we don't yet support early available timelines, we don't need to support\n    // playlists with no segments.\n\n\n    const firstNewSegment = playlist.segments[0];\n    const oldMatchingSegmentIndex = oldPlaylist.segments.findIndex(function (oldSegment) {\n      return Math.abs(oldSegment.presentationTime - firstNewSegment.presentationTime) < TIME_FUDGE;\n    }); // No matching segment from the old playlist means the entire playlist was refreshed.\n    // In this case the media sequence should account for this update, and the new segments\n    // should be marked as discontinuous from the prior content, since the last prior\n    // timeline was removed.\n\n    if (oldMatchingSegmentIndex === -1) {\n      updateMediaSequenceForPlaylist({\n        playlist,\n        mediaSequence: oldPlaylist.mediaSequence + oldPlaylist.segments.length\n      });\n      playlist.segments[0].discontinuity = true;\n      playlist.discontinuityStarts.unshift(0); // No matching segment does not necessarily mean there's missing content.\n      //\n      // If the new playlist's timeline is the same as the last seen segment's timeline,\n      // then a discontinuity can be added to identify that there's potentially missing\n      // content. If there's no missing content, the discontinuity should still be rather\n      // harmless. It's possible that if segment durations are accurate enough, that the\n      // existence of a gap can be determined using the presentation times and durations,\n      // but if the segment timing info is off, it may introduce more problems than simply\n      // adding the discontinuity.\n      //\n      // If the new playlist's timeline is different from the last seen segment's timeline,\n      // then a discontinuity can be added to identify that this is the first seen segment\n      // of a new timeline. However, the logic at the start of this function that\n      // determined the disconinuity sequence by timeline index is now off by one (the\n      // discontinuity of the newest timeline hasn't yet fallen off the manifest...since\n      // we added it), so the disconinuity sequence must be decremented.\n      //\n      // A period may also have a duration of zero, so the case of no segments is handled\n      // here even though we don't yet support early available periods.\n\n      if (!oldPlaylist.segments.length && playlist.timeline > oldPlaylist.timeline || oldPlaylist.segments.length && playlist.timeline > oldPlaylist.segments[oldPlaylist.segments.length - 1].timeline) {\n        playlist.discontinuitySequence--;\n      }\n\n      return;\n    } // If the first segment matched with a prior segment on a discontinuity (it's matching\n    // on the first segment of a period), then the discontinuitySequence shouldn't be the\n    // timeline's matching one, but instead should be the one prior, and the first segment\n    // of the new manifest should be marked with a discontinuity.\n    //\n    // The reason for this special case is that discontinuity sequence shows how many\n    // discontinuities have fallen off of the playlist, and discontinuities are marked on\n    // the first segment of a new \"timeline.\" Because of this, while DASH will retain that\n    // Period while the \"timeline\" exists, HLS keeps track of it via the discontinuity\n    // sequence, and that first segment is an indicator, but can be removed before that\n    // timeline is gone.\n\n\n    const oldMatchingSegment = oldPlaylist.segments[oldMatchingSegmentIndex];\n\n    if (oldMatchingSegment.discontinuity && !firstNewSegment.discontinuity) {\n      firstNewSegment.discontinuity = true;\n      playlist.discontinuityStarts.unshift(0);\n      playlist.discontinuitySequence--;\n    }\n\n    updateMediaSequenceForPlaylist({\n      playlist,\n      mediaSequence: oldPlaylist.segments[oldMatchingSegmentIndex].number\n    });\n  });\n};\n/**\n * Given an old parsed manifest object and a new parsed manifest object, updates the\n * sequence and timing values within the new manifest to ensure that it lines up with the\n * old.\n *\n * @param {Array} oldManifest - the old main manifest object\n * @param {Array} newManifest - the new main manifest object\n *\n * @return {Object} the updated new manifest object\n */\n\nconst positionManifestOnTimeline = ({\n  oldManifest,\n  newManifest\n}) => {\n  // Starting from v4.1.2 of the IOP, section 4.4.3.3 states:\n  //\n  // \"MPD@availabilityStartTime and Period@start shall not be changed over MPD updates.\"\n  //\n  // This was added from https://github.com/Dash-Industry-Forum/DASH-IF-IOP/issues/160\n  //\n  // Because of this change, and the difficulty of supporting periods with changing start\n  // times, periods with changing start times are not supported. This makes the logic much\n  // simpler, since periods with the same start time can be considerred the same period\n  // across refreshes.\n  //\n  // To give an example as to the difficulty of handling periods where the start time may\n  // change, if a single period manifest is refreshed with another manifest with a single\n  // period, and both the start and end times are increased, then the only way to determine\n  // if it's a new period or an old one that has changed is to look through the segments of\n  // each playlist and determine the presentation time bounds to find a match. In addition,\n  // if the period start changed to exceed the old period end, then there would be no\n  // match, and it would not be possible to determine whether the refreshed period is a new\n  // one or the old one.\n  const oldPlaylists = oldManifest.playlists.concat(getMediaGroupPlaylists(oldManifest));\n  const newPlaylists = newManifest.playlists.concat(getMediaGroupPlaylists(newManifest)); // Save all seen timelineStarts to the new manifest. Although this potentially means that\n  // there's a \"memory leak\" in that it will never stop growing, in reality, only a couple\n  // of properties are saved for each seen Period. Even long running live streams won't\n  // generate too many Periods, unless the stream is watched for decades. In the future,\n  // this can be optimized by mapping to discontinuity sequence numbers for each timeline,\n  // but it may not become an issue, and the additional info can be useful for debugging.\n\n  newManifest.timelineStarts = getUniqueTimelineStarts([oldManifest.timelineStarts, newManifest.timelineStarts]);\n  updateSequenceNumbers({\n    oldPlaylists,\n    newPlaylists,\n    timelineStarts: newManifest.timelineStarts\n  });\n  return newManifest;\n};\n\nconst generateSidxKey = sidx => sidx && sidx.uri + '-' + byteRangeToString(sidx.byterange);\n\nconst mergeDiscontiguousPlaylists = playlists => {\n  // Break out playlists into groups based on their baseUrl\n  const playlistsByBaseUrl = playlists.reduce(function (acc, cur) {\n    if (!acc[cur.attributes.baseUrl]) {\n      acc[cur.attributes.baseUrl] = [];\n    }\n\n    acc[cur.attributes.baseUrl].push(cur);\n    return acc;\n  }, {});\n  let allPlaylists = [];\n  Object.values(playlistsByBaseUrl).forEach(playlistGroup => {\n    const mergedPlaylists = values(playlistGroup.reduce((acc, playlist) => {\n      // assuming playlist IDs are the same across periods\n      // TODO: handle multiperiod where representation sets are not the same\n      // across periods\n      const name = playlist.attributes.id + (playlist.attributes.lang || '');\n\n      if (!acc[name]) {\n        // First Period\n        acc[name] = playlist;\n        acc[name].attributes.timelineStarts = [];\n      } else {\n        // Subsequent Periods\n        if (playlist.segments) {\n          // first segment of subsequent periods signal a discontinuity\n          if (playlist.segments[0]) {\n            playlist.segments[0].discontinuity = true;\n          }\n\n          acc[name].segments.push(...playlist.segments);\n        } // bubble up contentProtection, this assumes all DRM content\n        // has the same contentProtection\n\n\n        if (playlist.attributes.contentProtection) {\n          acc[name].attributes.contentProtection = playlist.attributes.contentProtection;\n        }\n      }\n\n      acc[name].attributes.timelineStarts.push({\n        // Although they represent the same number, it's important to have both to make it\n        // compatible with HLS potentially having a similar attribute.\n        start: playlist.attributes.periodStart,\n        timeline: playlist.attributes.periodStart\n      });\n      return acc;\n    }, {}));\n    allPlaylists = allPlaylists.concat(mergedPlaylists);\n  });\n  return allPlaylists.map(playlist => {\n    playlist.discontinuityStarts = findIndexes(playlist.segments || [], 'discontinuity');\n    return playlist;\n  });\n};\n\nconst addSidxSegmentsToPlaylist = (playlist, sidxMapping) => {\n  const sidxKey = generateSidxKey(playlist.sidx);\n  const sidxMatch = sidxKey && sidxMapping[sidxKey] && sidxMapping[sidxKey].sidx;\n\n  if (sidxMatch) {\n    addSidxSegmentsToPlaylist$1(playlist, sidxMatch, playlist.sidx.resolvedUri);\n  }\n\n  return playlist;\n};\nconst addSidxSegmentsToPlaylists = (playlists, sidxMapping = {}) => {\n  if (!Object.keys(sidxMapping).length) {\n    return playlists;\n  }\n\n  for (const i in playlists) {\n    playlists[i] = addSidxSegmentsToPlaylist(playlists[i], sidxMapping);\n  }\n\n  return playlists;\n};\nconst formatAudioPlaylist = ({\n  attributes,\n  segments,\n  sidx,\n  mediaSequence,\n  discontinuitySequence,\n  discontinuityStarts\n}, isAudioOnly) => {\n  const playlist = {\n    attributes: {\n      NAME: attributes.id,\n      BANDWIDTH: attributes.bandwidth,\n      CODECS: attributes.codecs,\n      ['PROGRAM-ID']: 1\n    },\n    uri: '',\n    endList: attributes.type === 'static',\n    timeline: attributes.periodStart,\n    resolvedUri: attributes.baseUrl || '',\n    targetDuration: attributes.duration,\n    discontinuitySequence,\n    discontinuityStarts,\n    timelineStarts: attributes.timelineStarts,\n    mediaSequence,\n    segments\n  };\n\n  if (attributes.contentProtection) {\n    playlist.contentProtection = attributes.contentProtection;\n  }\n\n  if (attributes.serviceLocation) {\n    playlist.attributes.serviceLocation = attributes.serviceLocation;\n  }\n\n  if (sidx) {\n    playlist.sidx = sidx;\n  }\n\n  if (isAudioOnly) {\n    playlist.attributes.AUDIO = 'audio';\n    playlist.attributes.SUBTITLES = 'subs';\n  }\n\n  return playlist;\n};\nconst formatVttPlaylist = ({\n  attributes,\n  segments,\n  mediaSequence,\n  discontinuityStarts,\n  discontinuitySequence\n}) => {\n  if (typeof segments === 'undefined') {\n    // vtt tracks may use single file in BaseURL\n    segments = [{\n      uri: attributes.baseUrl,\n      timeline: attributes.periodStart,\n      resolvedUri: attributes.baseUrl || '',\n      duration: attributes.sourceDuration,\n      number: 0\n    }]; // targetDuration should be the same duration as the only segment\n\n    attributes.duration = attributes.sourceDuration;\n  }\n\n  const m3u8Attributes = {\n    NAME: attributes.id,\n    BANDWIDTH: attributes.bandwidth,\n    ['PROGRAM-ID']: 1\n  };\n\n  if (attributes.codecs) {\n    m3u8Attributes.CODECS = attributes.codecs;\n  }\n\n  const vttPlaylist = {\n    attributes: m3u8Attributes,\n    uri: '',\n    endList: attributes.type === 'static',\n    timeline: attributes.periodStart,\n    resolvedUri: attributes.baseUrl || '',\n    targetDuration: attributes.duration,\n    timelineStarts: attributes.timelineStarts,\n    discontinuityStarts,\n    discontinuitySequence,\n    mediaSequence,\n    segments\n  };\n\n  if (attributes.serviceLocation) {\n    vttPlaylist.attributes.serviceLocation = attributes.serviceLocation;\n  }\n\n  return vttPlaylist;\n};\nconst organizeAudioPlaylists = (playlists, sidxMapping = {}, isAudioOnly = false) => {\n  let mainPlaylist;\n  const formattedPlaylists = playlists.reduce((a, playlist) => {\n    const role = playlist.attributes.role && playlist.attributes.role.value || '';\n    const language = playlist.attributes.lang || '';\n    let label = playlist.attributes.label || 'main';\n\n    if (language && !playlist.attributes.label) {\n      const roleLabel = role ? ` (${role})` : '';\n      label = `${playlist.attributes.lang}${roleLabel}`;\n    }\n\n    if (!a[label]) {\n      a[label] = {\n        language,\n        autoselect: true,\n        default: role === 'main',\n        playlists: [],\n        uri: ''\n      };\n    }\n\n    const formatted = addSidxSegmentsToPlaylist(formatAudioPlaylist(playlist, isAudioOnly), sidxMapping);\n    a[label].playlists.push(formatted);\n\n    if (typeof mainPlaylist === 'undefined' && role === 'main') {\n      mainPlaylist = playlist;\n      mainPlaylist.default = true;\n    }\n\n    return a;\n  }, {}); // if no playlists have role \"main\", mark the first as main\n\n  if (!mainPlaylist) {\n    const firstLabel = Object.keys(formattedPlaylists)[0];\n    formattedPlaylists[firstLabel].default = true;\n  }\n\n  return formattedPlaylists;\n};\nconst organizeVttPlaylists = (playlists, sidxMapping = {}) => {\n  return playlists.reduce((a, playlist) => {\n    const label = playlist.attributes.label || playlist.attributes.lang || 'text';\n    const language = playlist.attributes.lang || 'und';\n\n    if (!a[label]) {\n      a[label] = {\n        language,\n        default: false,\n        autoselect: false,\n        playlists: [],\n        uri: ''\n      };\n    }\n\n    a[label].playlists.push(addSidxSegmentsToPlaylist(formatVttPlaylist(playlist), sidxMapping));\n    return a;\n  }, {});\n};\n\nconst organizeCaptionServices = captionServices => captionServices.reduce((svcObj, svc) => {\n  if (!svc) {\n    return svcObj;\n  }\n\n  svc.forEach(service => {\n    const {\n      channel,\n      language\n    } = service;\n    svcObj[language] = {\n      autoselect: false,\n      default: false,\n      instreamId: channel,\n      language\n    };\n\n    if (service.hasOwnProperty('aspectRatio')) {\n      svcObj[language].aspectRatio = service.aspectRatio;\n    }\n\n    if (service.hasOwnProperty('easyReader')) {\n      svcObj[language].easyReader = service.easyReader;\n    }\n\n    if (service.hasOwnProperty('3D')) {\n      svcObj[language]['3D'] = service['3D'];\n    }\n  });\n  return svcObj;\n}, {});\n\nconst formatVideoPlaylist = ({\n  attributes,\n  segments,\n  sidx,\n  discontinuityStarts\n}) => {\n  const playlist = {\n    attributes: {\n      NAME: attributes.id,\n      AUDIO: 'audio',\n      SUBTITLES: 'subs',\n      RESOLUTION: {\n        width: attributes.width,\n        height: attributes.height\n      },\n      CODECS: attributes.codecs,\n      BANDWIDTH: attributes.bandwidth,\n      ['PROGRAM-ID']: 1\n    },\n    uri: '',\n    endList: attributes.type === 'static',\n    timeline: attributes.periodStart,\n    resolvedUri: attributes.baseUrl || '',\n    targetDuration: attributes.duration,\n    discontinuityStarts,\n    timelineStarts: attributes.timelineStarts,\n    segments\n  };\n\n  if (attributes.frameRate) {\n    playlist.attributes['FRAME-RATE'] = attributes.frameRate;\n  }\n\n  if (attributes.contentProtection) {\n    playlist.contentProtection = attributes.contentProtection;\n  }\n\n  if (attributes.serviceLocation) {\n    playlist.attributes.serviceLocation = attributes.serviceLocation;\n  }\n\n  if (sidx) {\n    playlist.sidx = sidx;\n  }\n\n  return playlist;\n};\n\nconst videoOnly = ({\n  attributes\n}) => attributes.mimeType === 'video/mp4' || attributes.mimeType === 'video/webm' || attributes.contentType === 'video';\n\nconst audioOnly = ({\n  attributes\n}) => attributes.mimeType === 'audio/mp4' || attributes.mimeType === 'audio/webm' || attributes.contentType === 'audio';\n\nconst vttOnly = ({\n  attributes\n}) => attributes.mimeType === 'text/vtt' || attributes.contentType === 'text';\n/**\n * Contains start and timeline properties denoting a timeline start. For DASH, these will\n * be the same number.\n *\n * @typedef {Object} TimelineStart\n * @property {number} start - the start time of the timeline\n * @property {number} timeline - the timeline number\n */\n\n/**\n * Adds appropriate media and discontinuity sequence values to the segments and playlists.\n *\n * Throughout mpd-parser, the `number` attribute is used in relation to `startNumber`, a\n * DASH specific attribute used in constructing segment URI's from templates. However, from\n * an HLS perspective, the `number` attribute on a segment would be its `mediaSequence`\n * value, which should start at the original media sequence value (or 0) and increment by 1\n * for each segment thereafter. Since DASH's `startNumber` values are independent per\n * period, it doesn't make sense to use it for `number`. Instead, assume everything starts\n * from a 0 mediaSequence value and increment from there.\n *\n * Note that VHS currently doesn't use the `number` property, but it can be helpful for\n * debugging and making sense of the manifest.\n *\n * For live playlists, to account for values increasing in manifests when periods are\n * removed on refreshes, merging logic should be used to update the numbers to their\n * appropriate values (to ensure they're sequential and increasing).\n *\n * @param {Object[]} playlists - the playlists to update\n * @param {TimelineStart[]} timelineStarts - the timeline starts for the manifest\n */\n\n\nconst addMediaSequenceValues = (playlists, timelineStarts) => {\n  // increment all segments sequentially\n  playlists.forEach(playlist => {\n    playlist.mediaSequence = 0;\n    playlist.discontinuitySequence = timelineStarts.findIndex(function ({\n      timeline\n    }) {\n      return timeline === playlist.timeline;\n    });\n\n    if (!playlist.segments) {\n      return;\n    }\n\n    playlist.segments.forEach((segment, index) => {\n      segment.number = index;\n    });\n  });\n};\n/**\n * Given a media group object, flattens all playlists within the media group into a single\n * array.\n *\n * @param {Object} mediaGroupObject - the media group object\n *\n * @return {Object[]}\n *         The media group playlists\n */\n\nconst flattenMediaGroupPlaylists = mediaGroupObject => {\n  if (!mediaGroupObject) {\n    return [];\n  }\n\n  return Object.keys(mediaGroupObject).reduce((acc, label) => {\n    const labelContents = mediaGroupObject[label];\n    return acc.concat(labelContents.playlists);\n  }, []);\n};\nconst toM3u8 = ({\n  dashPlaylists,\n  locations,\n  contentSteering,\n  sidxMapping = {},\n  previousManifest,\n  eventStream\n}) => {\n  if (!dashPlaylists.length) {\n    return {};\n  } // grab all main manifest attributes\n\n\n  const {\n    sourceDuration: duration,\n    type,\n    suggestedPresentationDelay,\n    minimumUpdatePeriod\n  } = dashPlaylists[0].attributes;\n  const videoPlaylists = mergeDiscontiguousPlaylists(dashPlaylists.filter(videoOnly)).map(formatVideoPlaylist);\n  const audioPlaylists = mergeDiscontiguousPlaylists(dashPlaylists.filter(audioOnly));\n  const vttPlaylists = mergeDiscontiguousPlaylists(dashPlaylists.filter(vttOnly));\n  const captions = dashPlaylists.map(playlist => playlist.attributes.captionServices).filter(Boolean);\n  const manifest = {\n    allowCache: true,\n    discontinuityStarts: [],\n    segments: [],\n    endList: true,\n    mediaGroups: {\n      AUDIO: {},\n      VIDEO: {},\n      ['CLOSED-CAPTIONS']: {},\n      SUBTITLES: {}\n    },\n    uri: '',\n    duration,\n    playlists: addSidxSegmentsToPlaylists(videoPlaylists, sidxMapping)\n  };\n\n  if (minimumUpdatePeriod >= 0) {\n    manifest.minimumUpdatePeriod = minimumUpdatePeriod * 1000;\n  }\n\n  if (locations) {\n    manifest.locations = locations;\n  }\n\n  if (contentSteering) {\n    manifest.contentSteering = contentSteering;\n  }\n\n  if (type === 'dynamic') {\n    manifest.suggestedPresentationDelay = suggestedPresentationDelay;\n  }\n\n  if (eventStream && eventStream.length > 0) {\n    manifest.eventStream = eventStream;\n  }\n\n  const isAudioOnly = manifest.playlists.length === 0;\n  const organizedAudioGroup = audioPlaylists.length ? organizeAudioPlaylists(audioPlaylists, sidxMapping, isAudioOnly) : null;\n  const organizedVttGroup = vttPlaylists.length ? organizeVttPlaylists(vttPlaylists, sidxMapping) : null;\n  const formattedPlaylists = videoPlaylists.concat(flattenMediaGroupPlaylists(organizedAudioGroup), flattenMediaGroupPlaylists(organizedVttGroup));\n  const playlistTimelineStarts = formattedPlaylists.map(({\n    timelineStarts\n  }) => timelineStarts);\n  manifest.timelineStarts = getUniqueTimelineStarts(playlistTimelineStarts);\n  addMediaSequenceValues(formattedPlaylists, manifest.timelineStarts);\n\n  if (organizedAudioGroup) {\n    manifest.mediaGroups.AUDIO.audio = organizedAudioGroup;\n  }\n\n  if (organizedVttGroup) {\n    manifest.mediaGroups.SUBTITLES.subs = organizedVttGroup;\n  }\n\n  if (captions.length) {\n    manifest.mediaGroups['CLOSED-CAPTIONS'].cc = organizeCaptionServices(captions);\n  }\n\n  if (previousManifest) {\n    return positionManifestOnTimeline({\n      oldManifest: previousManifest,\n      newManifest: manifest\n    });\n  }\n\n  return manifest;\n};\n\n/**\n * Calculates the R (repetition) value for a live stream (for the final segment\n * in a manifest where the r value is negative 1)\n *\n * @param {Object} attributes\n *        Object containing all inherited attributes from parent elements with attribute\n *        names as keys\n * @param {number} time\n *        current time (typically the total time up until the final segment)\n * @param {number} duration\n *        duration property for the given <S />\n *\n * @return {number}\n *        R value to reach the end of the given period\n */\nconst getLiveRValue = (attributes, time, duration) => {\n  const {\n    NOW,\n    clientOffset,\n    availabilityStartTime,\n    timescale = 1,\n    periodStart = 0,\n    minimumUpdatePeriod = 0\n  } = attributes;\n  const now = (NOW + clientOffset) / 1000;\n  const periodStartWC = availabilityStartTime + periodStart;\n  const periodEndWC = now + minimumUpdatePeriod;\n  const periodDuration = periodEndWC - periodStartWC;\n  return Math.ceil((periodDuration * timescale - time) / duration);\n};\n/**\n * Uses information provided by SegmentTemplate.SegmentTimeline to determine segment\n * timing and duration\n *\n * @param {Object} attributes\n *        Object containing all inherited attributes from parent elements with attribute\n *        names as keys\n * @param {Object[]} segmentTimeline\n *        List of objects representing the attributes of each S element contained within\n *\n * @return {{number: number, duration: number, time: number, timeline: number}[]}\n *         List of Objects with segment timing and duration info\n */\n\n\nconst parseByTimeline = (attributes, segmentTimeline) => {\n  const {\n    type,\n    minimumUpdatePeriod = 0,\n    media = '',\n    sourceDuration,\n    timescale = 1,\n    startNumber = 1,\n    periodStart: timeline\n  } = attributes;\n  const segments = [];\n  let time = -1;\n\n  for (let sIndex = 0; sIndex < segmentTimeline.length; sIndex++) {\n    const S = segmentTimeline[sIndex];\n    const duration = S.d;\n    const repeat = S.r || 0;\n    const segmentTime = S.t || 0;\n\n    if (time < 0) {\n      // first segment\n      time = segmentTime;\n    }\n\n    if (segmentTime && segmentTime > time) {\n      // discontinuity\n      // TODO: How to handle this type of discontinuity\n      // timeline++ here would treat it like HLS discontuity and content would\n      // get appended without gap\n      // E.G.\n      //  <S t=\"0\" d=\"1\" />\n      //  <S d=\"1\" />\n      //  <S d=\"1\" />\n      //  <S t=\"5\" d=\"1\" />\n      // would have $Time$ values of [0, 1, 2, 5]\n      // should this be appened at time positions [0, 1, 2, 3],(#EXT-X-DISCONTINUITY)\n      // or [0, 1, 2, gap, gap, 5]? (#EXT-X-GAP)\n      // does the value of sourceDuration consider this when calculating arbitrary\n      // negative @r repeat value?\n      // E.G. Same elements as above with this added at the end\n      //  <S d=\"1\" r=\"-1\" />\n      //  with a sourceDuration of 10\n      // Would the 2 gaps be included in the time duration calculations resulting in\n      // 8 segments with $Time$ values of [0, 1, 2, 5, 6, 7, 8, 9] or 10 segments\n      // with $Time$ values of [0, 1, 2, 5, 6, 7, 8, 9, 10, 11] ?\n      time = segmentTime;\n    }\n\n    let count;\n\n    if (repeat < 0) {\n      const nextS = sIndex + 1;\n\n      if (nextS === segmentTimeline.length) {\n        // last segment\n        if (type === 'dynamic' && minimumUpdatePeriod > 0 && media.indexOf('$Number$') > 0) {\n          count = getLiveRValue(attributes, time, duration);\n        } else {\n          // TODO: This may be incorrect depending on conclusion of TODO above\n          count = (sourceDuration * timescale - time) / duration;\n        }\n      } else {\n        count = (segmentTimeline[nextS].t - time) / duration;\n      }\n    } else {\n      count = repeat + 1;\n    }\n\n    const end = startNumber + segments.length + count;\n    let number = startNumber + segments.length;\n\n    while (number < end) {\n      segments.push({\n        number,\n        duration: duration / timescale,\n        time,\n        timeline\n      });\n      time += duration;\n      number++;\n    }\n  }\n\n  return segments;\n};\n\nconst identifierPattern = /\\$([A-z]*)(?:(%0)([0-9]+)d)?\\$/g;\n/**\n * Replaces template identifiers with corresponding values. To be used as the callback\n * for String.prototype.replace\n *\n * @name replaceCallback\n * @function\n * @param {string} match\n *        Entire match of identifier\n * @param {string} identifier\n *        Name of matched identifier\n * @param {string} format\n *        Format tag string. Its presence indicates that padding is expected\n * @param {string} width\n *        Desired length of the replaced value. Values less than this width shall be left\n *        zero padded\n * @return {string}\n *         Replacement for the matched identifier\n */\n\n/**\n * Returns a function to be used as a callback for String.prototype.replace to replace\n * template identifiers\n *\n * @param {Obect} values\n *        Object containing values that shall be used to replace known identifiers\n * @param {number} values.RepresentationID\n *        Value of the Representation@id attribute\n * @param {number} values.Number\n *        Number of the corresponding segment\n * @param {number} values.Bandwidth\n *        Value of the Representation@bandwidth attribute.\n * @param {number} values.Time\n *        Timestamp value of the corresponding segment\n * @return {replaceCallback}\n *         Callback to be used with String.prototype.replace to replace identifiers\n */\n\nconst identifierReplacement = values => (match, identifier, format, width) => {\n  if (match === '$$') {\n    // escape sequence\n    return '$';\n  }\n\n  if (typeof values[identifier] === 'undefined') {\n    return match;\n  }\n\n  const value = '' + values[identifier];\n\n  if (identifier === 'RepresentationID') {\n    // Format tag shall not be present with RepresentationID\n    return value;\n  }\n\n  if (!format) {\n    width = 1;\n  } else {\n    width = parseInt(width, 10);\n  }\n\n  if (value.length >= width) {\n    return value;\n  }\n\n  return `${new Array(width - value.length + 1).join('0')}${value}`;\n};\n/**\n * Constructs a segment url from a template string\n *\n * @param {string} url\n *        Template string to construct url from\n * @param {Obect} values\n *        Object containing values that shall be used to replace known identifiers\n * @param {number} values.RepresentationID\n *        Value of the Representation@id attribute\n * @param {number} values.Number\n *        Number of the corresponding segment\n * @param {number} values.Bandwidth\n *        Value of the Representation@bandwidth attribute.\n * @param {number} values.Time\n *        Timestamp value of the corresponding segment\n * @return {string}\n *         Segment url with identifiers replaced\n */\n\nconst constructTemplateUrl = (url, values) => url.replace(identifierPattern, identifierReplacement(values));\n/**\n * Generates a list of objects containing timing and duration information about each\n * segment needed to generate segment uris and the complete segment object\n *\n * @param {Object} attributes\n *        Object containing all inherited attributes from parent elements with attribute\n *        names as keys\n * @param {Object[]|undefined} segmentTimeline\n *        List of objects representing the attributes of each S element contained within\n *        the SegmentTimeline element\n * @return {{number: number, duration: number, time: number, timeline: number}[]}\n *         List of Objects with segment timing and duration info\n */\n\nconst parseTemplateInfo = (attributes, segmentTimeline) => {\n  if (!attributes.duration && !segmentTimeline) {\n    // if neither @duration or SegmentTimeline are present, then there shall be exactly\n    // one media segment\n    return [{\n      number: attributes.startNumber || 1,\n      duration: attributes.sourceDuration,\n      time: 0,\n      timeline: attributes.periodStart\n    }];\n  }\n\n  if (attributes.duration) {\n    return parseByDuration(attributes);\n  }\n\n  return parseByTimeline(attributes, segmentTimeline);\n};\n/**\n * Generates a list of segments using information provided by the SegmentTemplate element\n *\n * @param {Object} attributes\n *        Object containing all inherited attributes from parent elements with attribute\n *        names as keys\n * @param {Object[]|undefined} segmentTimeline\n *        List of objects representing the attributes of each S element contained within\n *        the SegmentTimeline element\n * @return {Object[]}\n *         List of segment objects\n */\n\nconst segmentsFromTemplate = (attributes, segmentTimeline) => {\n  const templateValues = {\n    RepresentationID: attributes.id,\n    Bandwidth: attributes.bandwidth || 0\n  };\n  const {\n    initialization = {\n      sourceURL: '',\n      range: ''\n    }\n  } = attributes;\n  const mapSegment = urlTypeToSegment({\n    baseUrl: attributes.baseUrl,\n    source: constructTemplateUrl(initialization.sourceURL, templateValues),\n    range: initialization.range\n  });\n  const segments = parseTemplateInfo(attributes, segmentTimeline);\n  return segments.map(segment => {\n    templateValues.Number = segment.number;\n    templateValues.Time = segment.time;\n    const uri = constructTemplateUrl(attributes.media || '', templateValues); // See DASH spec section 5.3.9.2.2\n    // - if timescale isn't present on any level, default to 1.\n\n    const timescale = attributes.timescale || 1; // - if presentationTimeOffset isn't present on any level, default to 0\n\n    const presentationTimeOffset = attributes.presentationTimeOffset || 0;\n    const presentationTime = // Even if the @t attribute is not specified for the segment, segment.time is\n    // calculated in mpd-parser prior to this, so it's assumed to be available.\n    attributes.periodStart + (segment.time - presentationTimeOffset) / timescale;\n    const map = {\n      uri,\n      timeline: segment.timeline,\n      duration: segment.duration,\n      resolvedUri: resolveUrl__default['default'](attributes.baseUrl || '', uri),\n      map: mapSegment,\n      number: segment.number,\n      presentationTime\n    };\n    return map;\n  });\n};\n\n/**\n * Converts a <SegmentUrl> (of type URLType from the DASH spec 5.3.9.2 Table 14)\n * to an object that matches the output of a segment in videojs/mpd-parser\n *\n * @param {Object} attributes\n *   Object containing all inherited attributes from parent elements with attribute\n *   names as keys\n * @param {Object} segmentUrl\n *   <SegmentURL> node to translate into a segment object\n * @return {Object} translated segment object\n */\n\nconst SegmentURLToSegmentObject = (attributes, segmentUrl) => {\n  const {\n    baseUrl,\n    initialization = {}\n  } = attributes;\n  const initSegment = urlTypeToSegment({\n    baseUrl,\n    source: initialization.sourceURL,\n    range: initialization.range\n  });\n  const segment = urlTypeToSegment({\n    baseUrl,\n    source: segmentUrl.media,\n    range: segmentUrl.mediaRange\n  });\n  segment.map = initSegment;\n  return segment;\n};\n/**\n * Generates a list of segments using information provided by the SegmentList element\n * SegmentList (DASH SPEC Section 5.3.9.3.2) contains a set of <SegmentURL> nodes.  Each\n * node should be translated into segment.\n *\n * @param {Object} attributes\n *   Object containing all inherited attributes from parent elements with attribute\n *   names as keys\n * @param {Object[]|undefined} segmentTimeline\n *        List of objects representing the attributes of each S element contained within\n *        the SegmentTimeline element\n * @return {Object.<Array>} list of segments\n */\n\n\nconst segmentsFromList = (attributes, segmentTimeline) => {\n  const {\n    duration,\n    segmentUrls = [],\n    periodStart\n  } = attributes; // Per spec (5.3.9.2.1) no way to determine segment duration OR\n  // if both SegmentTimeline and @duration are defined, it is outside of spec.\n\n  if (!duration && !segmentTimeline || duration && segmentTimeline) {\n    throw new Error(errors.SEGMENT_TIME_UNSPECIFIED);\n  }\n\n  const segmentUrlMap = segmentUrls.map(segmentUrlObject => SegmentURLToSegmentObject(attributes, segmentUrlObject));\n  let segmentTimeInfo;\n\n  if (duration) {\n    segmentTimeInfo = parseByDuration(attributes);\n  }\n\n  if (segmentTimeline) {\n    segmentTimeInfo = parseByTimeline(attributes, segmentTimeline);\n  }\n\n  const segments = segmentTimeInfo.map((segmentTime, index) => {\n    if (segmentUrlMap[index]) {\n      const segment = segmentUrlMap[index]; // See DASH spec section 5.3.9.2.2\n      // - if timescale isn't present on any level, default to 1.\n\n      const timescale = attributes.timescale || 1; // - if presentationTimeOffset isn't present on any level, default to 0\n\n      const presentationTimeOffset = attributes.presentationTimeOffset || 0;\n      segment.timeline = segmentTime.timeline;\n      segment.duration = segmentTime.duration;\n      segment.number = segmentTime.number;\n      segment.presentationTime = periodStart + (segmentTime.time - presentationTimeOffset) / timescale;\n      return segment;\n    } // Since we're mapping we should get rid of any blank segments (in case\n    // the given SegmentTimeline is handling for more elements than we have\n    // SegmentURLs for).\n\n  }).filter(segment => segment);\n  return segments;\n};\n\nconst generateSegments = ({\n  attributes,\n  segmentInfo\n}) => {\n  let segmentAttributes;\n  let segmentsFn;\n\n  if (segmentInfo.template) {\n    segmentsFn = segmentsFromTemplate;\n    segmentAttributes = merge(attributes, segmentInfo.template);\n  } else if (segmentInfo.base) {\n    segmentsFn = segmentsFromBase;\n    segmentAttributes = merge(attributes, segmentInfo.base);\n  } else if (segmentInfo.list) {\n    segmentsFn = segmentsFromList;\n    segmentAttributes = merge(attributes, segmentInfo.list);\n  }\n\n  const segmentsInfo = {\n    attributes\n  };\n\n  if (!segmentsFn) {\n    return segmentsInfo;\n  }\n\n  const segments = segmentsFn(segmentAttributes, segmentInfo.segmentTimeline); // The @duration attribute will be used to determin the playlist's targetDuration which\n  // must be in seconds. Since we've generated the segment list, we no longer need\n  // @duration to be in @timescale units, so we can convert it here.\n\n  if (segmentAttributes.duration) {\n    const {\n      duration,\n      timescale = 1\n    } = segmentAttributes;\n    segmentAttributes.duration = duration / timescale;\n  } else if (segments.length) {\n    // if there is no @duration attribute, use the largest segment duration as\n    // as target duration\n    segmentAttributes.duration = segments.reduce((max, segment) => {\n      return Math.max(max, Math.ceil(segment.duration));\n    }, 0);\n  } else {\n    segmentAttributes.duration = 0;\n  }\n\n  segmentsInfo.attributes = segmentAttributes;\n  segmentsInfo.segments = segments; // This is a sidx box without actual segment information\n\n  if (segmentInfo.base && segmentAttributes.indexRange) {\n    segmentsInfo.sidx = segments[0];\n    segmentsInfo.segments = [];\n  }\n\n  return segmentsInfo;\n};\nconst toPlaylists = representations => representations.map(generateSegments);\n\nconst findChildren = (element, name) => from(element.childNodes).filter(({\n  tagName\n}) => tagName === name);\nconst getContent = element => element.textContent.trim();\n\n/**\n * Converts the provided string that may contain a division operation to a number.\n *\n * @param {string} value - the provided string value\n *\n * @return {number} the parsed string value\n */\nconst parseDivisionValue = value => {\n  return parseFloat(value.split('/').reduce((prev, current) => prev / current));\n};\n\nconst parseDuration = str => {\n  const SECONDS_IN_YEAR = 365 * 24 * 60 * 60;\n  const SECONDS_IN_MONTH = 30 * 24 * 60 * 60;\n  const SECONDS_IN_DAY = 24 * 60 * 60;\n  const SECONDS_IN_HOUR = 60 * 60;\n  const SECONDS_IN_MIN = 60; // P10Y10M10DT10H10M10.1S\n\n  const durationRegex = /P(?:(\\d*)Y)?(?:(\\d*)M)?(?:(\\d*)D)?(?:T(?:(\\d*)H)?(?:(\\d*)M)?(?:([\\d.]*)S)?)?/;\n  const match = durationRegex.exec(str);\n\n  if (!match) {\n    return 0;\n  }\n\n  const [year, month, day, hour, minute, second] = match.slice(1);\n  return parseFloat(year || 0) * SECONDS_IN_YEAR + parseFloat(month || 0) * SECONDS_IN_MONTH + parseFloat(day || 0) * SECONDS_IN_DAY + parseFloat(hour || 0) * SECONDS_IN_HOUR + parseFloat(minute || 0) * SECONDS_IN_MIN + parseFloat(second || 0);\n};\nconst parseDate = str => {\n  // Date format without timezone according to ISO 8601\n  // YYY-MM-DDThh:mm:ss.ssssss\n  const dateRegex = /^\\d+-\\d+-\\d+T\\d+:\\d+:\\d+(\\.\\d+)?$/; // If the date string does not specifiy a timezone, we must specifiy UTC. This is\n  // expressed by ending with 'Z'\n\n  if (dateRegex.test(str)) {\n    str += 'Z';\n  }\n\n  return Date.parse(str);\n};\n\nconst parsers = {\n  /**\n   * Specifies the duration of the entire Media Presentation. Format is a duration string\n   * as specified in ISO 8601\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The duration in seconds\n   */\n  mediaPresentationDuration(value) {\n    return parseDuration(value);\n  },\n\n  /**\n   * Specifies the Segment availability start time for all Segments referred to in this\n   * MPD. For a dynamic manifest, it specifies the anchor for the earliest availability\n   * time. Format is a date string as specified in ISO 8601\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The date as seconds from unix epoch\n   */\n  availabilityStartTime(value) {\n    return parseDate(value) / 1000;\n  },\n\n  /**\n   * Specifies the smallest period between potential changes to the MPD. Format is a\n   * duration string as specified in ISO 8601\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The duration in seconds\n   */\n  minimumUpdatePeriod(value) {\n    return parseDuration(value);\n  },\n\n  /**\n   * Specifies the suggested presentation delay. Format is a\n   * duration string as specified in ISO 8601\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The duration in seconds\n   */\n  suggestedPresentationDelay(value) {\n    return parseDuration(value);\n  },\n\n  /**\n   * specifices the type of mpd. Can be either \"static\" or \"dynamic\"\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   *\n   * @return {string}\n   *         The type as a string\n   */\n  type(value) {\n    return value;\n  },\n\n  /**\n   * Specifies the duration of the smallest time shifting buffer for any Representation\n   * in the MPD. Format is a duration string as specified in ISO 8601\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The duration in seconds\n   */\n  timeShiftBufferDepth(value) {\n    return parseDuration(value);\n  },\n\n  /**\n   * Specifies the PeriodStart time of the Period relative to the availabilityStarttime.\n   * Format is a duration string as specified in ISO 8601\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The duration in seconds\n   */\n  start(value) {\n    return parseDuration(value);\n  },\n\n  /**\n   * Specifies the width of the visual presentation\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The parsed width\n   */\n  width(value) {\n    return parseInt(value, 10);\n  },\n\n  /**\n   * Specifies the height of the visual presentation\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The parsed height\n   */\n  height(value) {\n    return parseInt(value, 10);\n  },\n\n  /**\n   * Specifies the bitrate of the representation\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The parsed bandwidth\n   */\n  bandwidth(value) {\n    return parseInt(value, 10);\n  },\n\n  /**\n   * Specifies the frame rate of the representation\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The parsed frame rate\n   */\n  frameRate(value) {\n    return parseDivisionValue(value);\n  },\n\n  /**\n   * Specifies the number of the first Media Segment in this Representation in the Period\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The parsed number\n   */\n  startNumber(value) {\n    return parseInt(value, 10);\n  },\n\n  /**\n   * Specifies the timescale in units per seconds\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The parsed timescale\n   */\n  timescale(value) {\n    return parseInt(value, 10);\n  },\n\n  /**\n   * Specifies the presentationTimeOffset.\n   *\n   * @param {string} value\n   *        value of the attribute as a string\n   *\n   * @return {number}\n   *         The parsed presentationTimeOffset\n   */\n  presentationTimeOffset(value) {\n    return parseInt(value, 10);\n  },\n\n  /**\n   * Specifies the constant approximate Segment duration\n   * NOTE: The <Period> element also contains an @duration attribute. This duration\n   *       specifies the duration of the Period. This attribute is currently not\n   *       supported by the rest of the parser, however we still check for it to prevent\n   *       errors.\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The parsed duration\n   */\n  duration(value) {\n    const parsedValue = parseInt(value, 10);\n\n    if (isNaN(parsedValue)) {\n      return parseDuration(value);\n    }\n\n    return parsedValue;\n  },\n\n  /**\n   * Specifies the Segment duration, in units of the value of the @timescale.\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The parsed duration\n   */\n  d(value) {\n    return parseInt(value, 10);\n  },\n\n  /**\n   * Specifies the MPD start time, in @timescale units, the first Segment in the series\n   * starts relative to the beginning of the Period\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The parsed time\n   */\n  t(value) {\n    return parseInt(value, 10);\n  },\n\n  /**\n   * Specifies the repeat count of the number of following contiguous Segments with the\n   * same duration expressed by the value of @d\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The parsed number\n   */\n  r(value) {\n    return parseInt(value, 10);\n  },\n\n  /**\n   * Specifies the presentationTime.\n   *\n   * @param {string} value\n   *        value of the attribute as a string\n   *\n   * @return {number}\n   *         The parsed presentationTime\n   */\n  presentationTime(value) {\n    return parseInt(value, 10);\n  },\n\n  /**\n   * Default parser for all other attributes. Acts as a no-op and just returns the value\n   * as a string\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {string}\n   *         Unparsed value\n   */\n  DEFAULT(value) {\n    return value;\n  }\n\n};\n/**\n * Gets all the attributes and values of the provided node, parses attributes with known\n * types, and returns an object with attribute names mapped to values.\n *\n * @param {Node} el\n *        The node to parse attributes from\n * @return {Object}\n *         Object with all attributes of el parsed\n */\n\nconst parseAttributes = el => {\n  if (!(el && el.attributes)) {\n    return {};\n  }\n\n  return from(el.attributes).reduce((a, e) => {\n    const parseFn = parsers[e.name] || parsers.DEFAULT;\n    a[e.name] = parseFn(e.value);\n    return a;\n  }, {});\n};\n\nconst keySystemsMap = {\n  'urn:uuid:1077efec-c0b2-4d02-ace3-3c1e52e2fb4b': 'org.w3.clearkey',\n  'urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed': 'com.widevine.alpha',\n  'urn:uuid:9a04f079-9840-4286-ab92-e65be0885f95': 'com.microsoft.playready',\n  'urn:uuid:f239e769-efa3-4850-9c16-a903c6932efb': 'com.adobe.primetime',\n  // ISO_IEC 23009-1_2022 5.8.5.2.2 The mp4 Protection Scheme\n  'urn:mpeg:dash:mp4protection:2011': 'mp4protection'\n};\n/**\n * Builds a list of urls that is the product of the reference urls and BaseURL values\n *\n * @param {Object[]} references\n *        List of objects containing the reference URL as well as its attributes\n * @param {Node[]} baseUrlElements\n *        List of BaseURL nodes from the mpd\n * @return {Object[]}\n *         List of objects with resolved urls and attributes\n */\n\nconst buildBaseUrls = (references, baseUrlElements) => {\n  if (!baseUrlElements.length) {\n    return references;\n  }\n\n  return flatten(references.map(function (reference) {\n    return baseUrlElements.map(function (baseUrlElement) {\n      const initialBaseUrl = getContent(baseUrlElement);\n      const resolvedBaseUrl = resolveUrl__default['default'](reference.baseUrl, initialBaseUrl);\n      const finalBaseUrl = merge(parseAttributes(baseUrlElement), {\n        baseUrl: resolvedBaseUrl\n      }); // If the URL is resolved, we want to get the serviceLocation from the reference\n      // assuming there is no serviceLocation on the initialBaseUrl\n\n      if (resolvedBaseUrl !== initialBaseUrl && !finalBaseUrl.serviceLocation && reference.serviceLocation) {\n        finalBaseUrl.serviceLocation = reference.serviceLocation;\n      }\n\n      return finalBaseUrl;\n    });\n  }));\n};\n/**\n * Contains all Segment information for its containing AdaptationSet\n *\n * @typedef {Object} SegmentInformation\n * @property {Object|undefined} template\n *           Contains the attributes for the SegmentTemplate node\n * @property {Object[]|undefined} segmentTimeline\n *           Contains a list of atrributes for each S node within the SegmentTimeline node\n * @property {Object|undefined} list\n *           Contains the attributes for the SegmentList node\n * @property {Object|undefined} base\n *           Contains the attributes for the SegmentBase node\n */\n\n/**\n * Returns all available Segment information contained within the AdaptationSet node\n *\n * @param {Node} adaptationSet\n *        The AdaptationSet node to get Segment information from\n * @return {SegmentInformation}\n *         The Segment information contained within the provided AdaptationSet\n */\n\nconst getSegmentInformation = adaptationSet => {\n  const segmentTemplate = findChildren(adaptationSet, 'SegmentTemplate')[0];\n  const segmentList = findChildren(adaptationSet, 'SegmentList')[0];\n  const segmentUrls = segmentList && findChildren(segmentList, 'SegmentURL').map(s => merge({\n    tag: 'SegmentURL'\n  }, parseAttributes(s)));\n  const segmentBase = findChildren(adaptationSet, 'SegmentBase')[0];\n  const segmentTimelineParentNode = segmentList || segmentTemplate;\n  const segmentTimeline = segmentTimelineParentNode && findChildren(segmentTimelineParentNode, 'SegmentTimeline')[0];\n  const segmentInitializationParentNode = segmentList || segmentBase || segmentTemplate;\n  const segmentInitialization = segmentInitializationParentNode && findChildren(segmentInitializationParentNode, 'Initialization')[0]; // SegmentTemplate is handled slightly differently, since it can have both\n  // @initialization and an <Initialization> node.  @initialization can be templated,\n  // while the node can have a url and range specified.  If the <SegmentTemplate> has\n  // both @initialization and an <Initialization> subelement we opt to override with\n  // the node, as this interaction is not defined in the spec.\n\n  const template = segmentTemplate && parseAttributes(segmentTemplate);\n\n  if (template && segmentInitialization) {\n    template.initialization = segmentInitialization && parseAttributes(segmentInitialization);\n  } else if (template && template.initialization) {\n    // If it is @initialization we convert it to an object since this is the format that\n    // later functions will rely on for the initialization segment.  This is only valid\n    // for <SegmentTemplate>\n    template.initialization = {\n      sourceURL: template.initialization\n    };\n  }\n\n  const segmentInfo = {\n    template,\n    segmentTimeline: segmentTimeline && findChildren(segmentTimeline, 'S').map(s => parseAttributes(s)),\n    list: segmentList && merge(parseAttributes(segmentList), {\n      segmentUrls,\n      initialization: parseAttributes(segmentInitialization)\n    }),\n    base: segmentBase && merge(parseAttributes(segmentBase), {\n      initialization: parseAttributes(segmentInitialization)\n    })\n  };\n  Object.keys(segmentInfo).forEach(key => {\n    if (!segmentInfo[key]) {\n      delete segmentInfo[key];\n    }\n  });\n  return segmentInfo;\n};\n/**\n * Contains Segment information and attributes needed to construct a Playlist object\n * from a Representation\n *\n * @typedef {Object} RepresentationInformation\n * @property {SegmentInformation} segmentInfo\n *           Segment information for this Representation\n * @property {Object} attributes\n *           Inherited attributes for this Representation\n */\n\n/**\n * Maps a Representation node to an object containing Segment information and attributes\n *\n * @name inheritBaseUrlsCallback\n * @function\n * @param {Node} representation\n *        Representation node from the mpd\n * @return {RepresentationInformation}\n *         Representation information needed to construct a Playlist object\n */\n\n/**\n * Returns a callback for Array.prototype.map for mapping Representation nodes to\n * Segment information and attributes using inherited BaseURL nodes.\n *\n * @param {Object} adaptationSetAttributes\n *        Contains attributes inherited by the AdaptationSet\n * @param {Object[]} adaptationSetBaseUrls\n *        List of objects containing resolved base URLs and attributes\n *        inherited by the AdaptationSet\n * @param {SegmentInformation} adaptationSetSegmentInfo\n *        Contains Segment information for the AdaptationSet\n * @return {inheritBaseUrlsCallback}\n *         Callback map function\n */\n\nconst inheritBaseUrls = (adaptationSetAttributes, adaptationSetBaseUrls, adaptationSetSegmentInfo) => representation => {\n  const repBaseUrlElements = findChildren(representation, 'BaseURL');\n  const repBaseUrls = buildBaseUrls(adaptationSetBaseUrls, repBaseUrlElements);\n  const attributes = merge(adaptationSetAttributes, parseAttributes(representation));\n  const representationSegmentInfo = getSegmentInformation(representation);\n  return repBaseUrls.map(baseUrl => {\n    return {\n      segmentInfo: merge(adaptationSetSegmentInfo, representationSegmentInfo),\n      attributes: merge(attributes, baseUrl)\n    };\n  });\n};\n/**\n * Tranforms a series of content protection nodes to\n * an object containing pssh data by key system\n *\n * @param {Node[]} contentProtectionNodes\n *        Content protection nodes\n * @return {Object}\n *        Object containing pssh data by key system\n */\n\nconst generateKeySystemInformation = contentProtectionNodes => {\n  return contentProtectionNodes.reduce((acc, node) => {\n    const attributes = parseAttributes(node); // Although it could be argued that according to the UUID RFC spec the UUID string (a-f chars) should be generated\n    // as a lowercase string it also mentions it should be treated as case-insensitive on input. Since the key system\n    // UUIDs in the keySystemsMap are hardcoded as lowercase in the codebase there isn't any reason not to do\n    // .toLowerCase() on the input UUID string from the manifest (at least I could not think of one).\n\n    if (attributes.schemeIdUri) {\n      attributes.schemeIdUri = attributes.schemeIdUri.toLowerCase();\n    }\n\n    const keySystem = keySystemsMap[attributes.schemeIdUri];\n\n    if (keySystem) {\n      acc[keySystem] = {\n        attributes\n      };\n      const psshNode = findChildren(node, 'cenc:pssh')[0];\n\n      if (psshNode) {\n        const pssh = getContent(psshNode);\n        acc[keySystem].pssh = pssh && decodeB64ToUint8Array__default['default'](pssh);\n      }\n    }\n\n    return acc;\n  }, {});\n}; // defined in ANSI_SCTE 214-1 2016\n\n\nconst parseCaptionServiceMetadata = service => {\n  // 608 captions\n  if (service.schemeIdUri === 'urn:scte:dash:cc:cea-608:2015') {\n    const values = typeof service.value !== 'string' ? [] : service.value.split(';');\n    return values.map(value => {\n      let channel;\n      let language; // default language to value\n\n      language = value;\n\n      if (/^CC\\d=/.test(value)) {\n        [channel, language] = value.split('=');\n      } else if (/^CC\\d$/.test(value)) {\n        channel = value;\n      }\n\n      return {\n        channel,\n        language\n      };\n    });\n  } else if (service.schemeIdUri === 'urn:scte:dash:cc:cea-708:2015') {\n    const values = typeof service.value !== 'string' ? [] : service.value.split(';');\n    return values.map(value => {\n      const flags = {\n        // service or channel number 1-63\n        'channel': undefined,\n        // language is a 3ALPHA per ISO 639.2/B\n        // field is required\n        'language': undefined,\n        // BIT 1/0 or ?\n        // default value is 1, meaning 16:9 aspect ratio, 0 is 4:3, ? is unknown\n        'aspectRatio': 1,\n        // BIT 1/0\n        // easy reader flag indicated the text is tailed to the needs of beginning readers\n        // default 0, or off\n        'easyReader': 0,\n        // BIT 1/0\n        // If 3d metadata is present (CEA-708.1) then 1\n        // default 0\n        '3D': 0\n      };\n\n      if (/=/.test(value)) {\n        const [channel, opts = ''] = value.split('=');\n        flags.channel = channel;\n        flags.language = value;\n        opts.split(',').forEach(opt => {\n          const [name, val] = opt.split(':');\n\n          if (name === 'lang') {\n            flags.language = val; // er for easyReadery\n          } else if (name === 'er') {\n            flags.easyReader = Number(val); // war for wide aspect ratio\n          } else if (name === 'war') {\n            flags.aspectRatio = Number(val);\n          } else if (name === '3D') {\n            flags['3D'] = Number(val);\n          }\n        });\n      } else {\n        flags.language = value;\n      }\n\n      if (flags.channel) {\n        flags.channel = 'SERVICE' + flags.channel;\n      }\n\n      return flags;\n    });\n  }\n};\n/**\n * A map callback that will parse all event stream data for a collection of periods\n * DASH ISO_IEC_23009 5.10.2.2\n * https://dashif-documents.azurewebsites.net/Events/master/event.html#mpd-event-timing\n *\n * @param {PeriodInformation} period object containing necessary period information\n * @return a collection of parsed eventstream event objects\n */\n\nconst toEventStream = period => {\n  // get and flatten all EventStreams tags and parse attributes and children\n  return flatten(findChildren(period.node, 'EventStream').map(eventStream => {\n    const eventStreamAttributes = parseAttributes(eventStream);\n    const schemeIdUri = eventStreamAttributes.schemeIdUri; // find all Events per EventStream tag and map to return objects\n\n    return findChildren(eventStream, 'Event').map(event => {\n      const eventAttributes = parseAttributes(event);\n      const presentationTime = eventAttributes.presentationTime || 0;\n      const timescale = eventStreamAttributes.timescale || 1;\n      const duration = eventAttributes.duration || 0;\n      const start = presentationTime / timescale + period.attributes.start;\n      return {\n        schemeIdUri,\n        value: eventStreamAttributes.value,\n        id: eventAttributes.id,\n        start,\n        end: start + duration / timescale,\n        messageData: getContent(event) || eventAttributes.messageData,\n        contentEncoding: eventStreamAttributes.contentEncoding,\n        presentationTimeOffset: eventStreamAttributes.presentationTimeOffset || 0\n      };\n    });\n  }));\n};\n/**\n * Maps an AdaptationSet node to a list of Representation information objects\n *\n * @name toRepresentationsCallback\n * @function\n * @param {Node} adaptationSet\n *        AdaptationSet node from the mpd\n * @return {RepresentationInformation[]}\n *         List of objects containing Representaion information\n */\n\n/**\n * Returns a callback for Array.prototype.map for mapping AdaptationSet nodes to a list of\n * Representation information objects\n *\n * @param {Object} periodAttributes\n *        Contains attributes inherited by the Period\n * @param {Object[]} periodBaseUrls\n *        Contains list of objects with resolved base urls and attributes\n *        inherited by the Period\n * @param {string[]} periodSegmentInfo\n *        Contains Segment Information at the period level\n * @return {toRepresentationsCallback}\n *         Callback map function\n */\n\nconst toRepresentations = (periodAttributes, periodBaseUrls, periodSegmentInfo) => adaptationSet => {\n  const adaptationSetAttributes = parseAttributes(adaptationSet);\n  const adaptationSetBaseUrls = buildBaseUrls(periodBaseUrls, findChildren(adaptationSet, 'BaseURL'));\n  const role = findChildren(adaptationSet, 'Role')[0];\n  const roleAttributes = {\n    role: parseAttributes(role)\n  };\n  let attrs = merge(periodAttributes, adaptationSetAttributes, roleAttributes);\n  const accessibility = findChildren(adaptationSet, 'Accessibility')[0];\n  const captionServices = parseCaptionServiceMetadata(parseAttributes(accessibility));\n\n  if (captionServices) {\n    attrs = merge(attrs, {\n      captionServices\n    });\n  }\n\n  const label = findChildren(adaptationSet, 'Label')[0];\n\n  if (label && label.childNodes.length) {\n    const labelVal = label.childNodes[0].nodeValue.trim();\n    attrs = merge(attrs, {\n      label: labelVal\n    });\n  }\n\n  const contentProtection = generateKeySystemInformation(findChildren(adaptationSet, 'ContentProtection'));\n\n  if (Object.keys(contentProtection).length) {\n    attrs = merge(attrs, {\n      contentProtection\n    });\n  }\n\n  const segmentInfo = getSegmentInformation(adaptationSet);\n  const representations = findChildren(adaptationSet, 'Representation');\n  const adaptationSetSegmentInfo = merge(periodSegmentInfo, segmentInfo);\n  return flatten(representations.map(inheritBaseUrls(attrs, adaptationSetBaseUrls, adaptationSetSegmentInfo)));\n};\n/**\n * Contains all period information for mapping nodes onto adaptation sets.\n *\n * @typedef {Object} PeriodInformation\n * @property {Node} period.node\n *           Period node from the mpd\n * @property {Object} period.attributes\n *           Parsed period attributes from node plus any added\n */\n\n/**\n * Maps a PeriodInformation object to a list of Representation information objects for all\n * AdaptationSet nodes contained within the Period.\n *\n * @name toAdaptationSetsCallback\n * @function\n * @param {PeriodInformation} period\n *        Period object containing necessary period information\n * @param {number} periodStart\n *        Start time of the Period within the mpd\n * @return {RepresentationInformation[]}\n *         List of objects containing Representaion information\n */\n\n/**\n * Returns a callback for Array.prototype.map for mapping Period nodes to a list of\n * Representation information objects\n *\n * @param {Object} mpdAttributes\n *        Contains attributes inherited by the mpd\n  * @param {Object[]} mpdBaseUrls\n *        Contains list of objects with resolved base urls and attributes\n *        inherited by the mpd\n * @return {toAdaptationSetsCallback}\n *         Callback map function\n */\n\nconst toAdaptationSets = (mpdAttributes, mpdBaseUrls) => (period, index) => {\n  const periodBaseUrls = buildBaseUrls(mpdBaseUrls, findChildren(period.node, 'BaseURL'));\n  const periodAttributes = merge(mpdAttributes, {\n    periodStart: period.attributes.start\n  });\n\n  if (typeof period.attributes.duration === 'number') {\n    periodAttributes.periodDuration = period.attributes.duration;\n  }\n\n  const adaptationSets = findChildren(period.node, 'AdaptationSet');\n  const periodSegmentInfo = getSegmentInformation(period.node);\n  return flatten(adaptationSets.map(toRepresentations(periodAttributes, periodBaseUrls, periodSegmentInfo)));\n};\n/**\n * Tranforms an array of content steering nodes into an object\n * containing CDN content steering information from the MPD manifest.\n *\n * For more information on the DASH spec for Content Steering parsing, see:\n * https://dashif.org/docs/DASH-IF-CTS-00XX-Content-Steering-Community-Review.pdf\n *\n * @param {Node[]} contentSteeringNodes\n *        Content steering nodes\n * @param {Function} eventHandler\n *        The event handler passed into the parser options to handle warnings\n * @return {Object}\n *        Object containing content steering data\n */\n\nconst generateContentSteeringInformation = (contentSteeringNodes, eventHandler) => {\n  // If there are more than one ContentSteering tags, throw an error\n  if (contentSteeringNodes.length > 1) {\n    eventHandler({\n      type: 'warn',\n      message: 'The MPD manifest should contain no more than one ContentSteering tag'\n    });\n  } // Return a null value if there are no ContentSteering tags\n\n\n  if (!contentSteeringNodes.length) {\n    return null;\n  }\n\n  const infoFromContentSteeringTag = merge({\n    serverURL: getContent(contentSteeringNodes[0])\n  }, parseAttributes(contentSteeringNodes[0])); // Converts `queryBeforeStart` to a boolean, as well as setting the default value\n  // to `false` if it doesn't exist\n\n  infoFromContentSteeringTag.queryBeforeStart = infoFromContentSteeringTag.queryBeforeStart === 'true';\n  return infoFromContentSteeringTag;\n};\n/**\n * Gets Period@start property for a given period.\n *\n * @param {Object} options\n *        Options object\n * @param {Object} options.attributes\n *        Period attributes\n * @param {Object} [options.priorPeriodAttributes]\n *        Prior period attributes (if prior period is available)\n * @param {string} options.mpdType\n *        The MPD@type these periods came from\n * @return {number|null}\n *         The period start, or null if it's an early available period or error\n */\n\nconst getPeriodStart = ({\n  attributes,\n  priorPeriodAttributes,\n  mpdType\n}) => {\n  // Summary of period start time calculation from DASH spec section 5.3.2.1\n  //\n  // A period's start is the first period's start + time elapsed after playing all\n  // prior periods to this one. Periods continue one after the other in time (without\n  // gaps) until the end of the presentation.\n  //\n  // The value of Period@start should be:\n  // 1. if Period@start is present: value of Period@start\n  // 2. if previous period exists and it has @duration: previous Period@start +\n  //    previous Period@duration\n  // 3. if this is first period and MPD@type is 'static': 0\n  // 4. in all other cases, consider the period an \"early available period\" (note: not\n  //    currently supported)\n  // (1)\n  if (typeof attributes.start === 'number') {\n    return attributes.start;\n  } // (2)\n\n\n  if (priorPeriodAttributes && typeof priorPeriodAttributes.start === 'number' && typeof priorPeriodAttributes.duration === 'number') {\n    return priorPeriodAttributes.start + priorPeriodAttributes.duration;\n  } // (3)\n\n\n  if (!priorPeriodAttributes && mpdType === 'static') {\n    return 0;\n  } // (4)\n  // There is currently no logic for calculating the Period@start value if there is\n  // no Period@start or prior Period@start and Period@duration available. This is not made\n  // explicit by the DASH interop guidelines or the DASH spec, however, since there's\n  // nothing about any other resolution strategies, it's implied. Thus, this case should\n  // be considered an early available period, or error, and null should suffice for both\n  // of those cases.\n\n\n  return null;\n};\n/**\n * Traverses the mpd xml tree to generate a list of Representation information objects\n * that have inherited attributes from parent nodes\n *\n * @param {Node} mpd\n *        The root node of the mpd\n * @param {Object} options\n *        Available options for inheritAttributes\n * @param {string} options.manifestUri\n *        The uri source of the mpd\n * @param {number} options.NOW\n *        Current time per DASH IOP.  Default is current time in ms since epoch\n * @param {number} options.clientOffset\n *        Client time difference from NOW (in milliseconds)\n * @return {RepresentationInformation[]}\n *         List of objects containing Representation information\n */\n\nconst inheritAttributes = (mpd, options = {}) => {\n  const {\n    manifestUri = '',\n    NOW = Date.now(),\n    clientOffset = 0,\n    // TODO: For now, we are expecting an eventHandler callback function\n    // to be passed into the mpd parser as an option.\n    // In the future, we should enable stream parsing by using the Stream class from vhs-utils.\n    // This will support new features including a standardized event handler.\n    // See the m3u8 parser for examples of how stream parsing is currently used for HLS parsing.\n    // https://github.com/videojs/vhs-utils/blob/88d6e10c631e57a5af02c5a62bc7376cd456b4f5/src/stream.js#L9\n    eventHandler = function () {}\n  } = options;\n  const periodNodes = findChildren(mpd, 'Period');\n\n  if (!periodNodes.length) {\n    throw new Error(errors.INVALID_NUMBER_OF_PERIOD);\n  }\n\n  const locations = findChildren(mpd, 'Location');\n  const mpdAttributes = parseAttributes(mpd);\n  const mpdBaseUrls = buildBaseUrls([{\n    baseUrl: manifestUri\n  }], findChildren(mpd, 'BaseURL'));\n  const contentSteeringNodes = findChildren(mpd, 'ContentSteering'); // See DASH spec section 5.3.1.2, Semantics of MPD element. Default type to 'static'.\n\n  mpdAttributes.type = mpdAttributes.type || 'static';\n  mpdAttributes.sourceDuration = mpdAttributes.mediaPresentationDuration || 0;\n  mpdAttributes.NOW = NOW;\n  mpdAttributes.clientOffset = clientOffset;\n\n  if (locations.length) {\n    mpdAttributes.locations = locations.map(getContent);\n  }\n\n  const periods = []; // Since toAdaptationSets acts on individual periods right now, the simplest approach to\n  // adding properties that require looking at prior periods is to parse attributes and add\n  // missing ones before toAdaptationSets is called. If more such properties are added, it\n  // may be better to refactor toAdaptationSets.\n\n  periodNodes.forEach((node, index) => {\n    const attributes = parseAttributes(node); // Use the last modified prior period, as it may contain added information necessary\n    // for this period.\n\n    const priorPeriod = periods[index - 1];\n    attributes.start = getPeriodStart({\n      attributes,\n      priorPeriodAttributes: priorPeriod ? priorPeriod.attributes : null,\n      mpdType: mpdAttributes.type\n    });\n    periods.push({\n      node,\n      attributes\n    });\n  });\n  return {\n    locations: mpdAttributes.locations,\n    contentSteeringInfo: generateContentSteeringInformation(contentSteeringNodes, eventHandler),\n    // TODO: There are occurences where this `representationInfo` array contains undesired\n    // duplicates. This generally occurs when there are multiple BaseURL nodes that are\n    // direct children of the MPD node. When we attempt to resolve URLs from a combination of the\n    // parent BaseURL and a child BaseURL, and the value does not resolve,\n    // we end up returning the child BaseURL multiple times.\n    // We need to determine a way to remove these duplicates in a safe way.\n    // See: https://github.com/videojs/mpd-parser/pull/17#discussion_r162750527\n    representationInfo: flatten(periods.map(toAdaptationSets(mpdAttributes, mpdBaseUrls))),\n    eventStream: flatten(periods.map(toEventStream))\n  };\n};\n\nconst stringToMpdXml = manifestString => {\n  if (manifestString === '') {\n    throw new Error(errors.DASH_EMPTY_MANIFEST);\n  }\n\n  const parser = new xmldom.DOMParser();\n  let xml;\n  let mpd;\n\n  try {\n    xml = parser.parseFromString(manifestString, 'application/xml');\n    mpd = xml && xml.documentElement.tagName === 'MPD' ? xml.documentElement : null;\n  } catch (e) {// ie 11 throws on invalid xml\n  }\n\n  if (!mpd || mpd && mpd.getElementsByTagName('parsererror').length > 0) {\n    throw new Error(errors.DASH_INVALID_XML);\n  }\n\n  return mpd;\n};\n\n/**\n * Parses the manifest for a UTCTiming node, returning the nodes attributes if found\n *\n * @param {string} mpd\n *        XML string of the MPD manifest\n * @return {Object|null}\n *         Attributes of UTCTiming node specified in the manifest. Null if none found\n */\n\nconst parseUTCTimingScheme = mpd => {\n  const UTCTimingNode = findChildren(mpd, 'UTCTiming')[0];\n\n  if (!UTCTimingNode) {\n    return null;\n  }\n\n  const attributes = parseAttributes(UTCTimingNode);\n\n  switch (attributes.schemeIdUri) {\n    case 'urn:mpeg:dash:utc:http-head:2014':\n    case 'urn:mpeg:dash:utc:http-head:2012':\n      attributes.method = 'HEAD';\n      break;\n\n    case 'urn:mpeg:dash:utc:http-xsdate:2014':\n    case 'urn:mpeg:dash:utc:http-iso:2014':\n    case 'urn:mpeg:dash:utc:http-xsdate:2012':\n    case 'urn:mpeg:dash:utc:http-iso:2012':\n      attributes.method = 'GET';\n      break;\n\n    case 'urn:mpeg:dash:utc:direct:2014':\n    case 'urn:mpeg:dash:utc:direct:2012':\n      attributes.method = 'DIRECT';\n      attributes.value = Date.parse(attributes.value);\n      break;\n\n    case 'urn:mpeg:dash:utc:http-ntp:2014':\n    case 'urn:mpeg:dash:utc:ntp:2014':\n    case 'urn:mpeg:dash:utc:sntp:2014':\n    default:\n      throw new Error(errors.UNSUPPORTED_UTC_TIMING_SCHEME);\n  }\n\n  return attributes;\n};\n\nconst VERSION = version;\n/*\n * Given a DASH manifest string and options, parses the DASH manifest into an object in the\n * form outputed by m3u8-parser and accepted by videojs/http-streaming.\n *\n * For live DASH manifests, if `previousManifest` is provided in options, then the newly\n * parsed DASH manifest will have its media sequence and discontinuity sequence values\n * updated to reflect its position relative to the prior manifest.\n *\n * @param {string} manifestString - the DASH manifest as a string\n * @param {options} [options] - any options\n *\n * @return {Object} the manifest object\n */\n\nconst parse = (manifestString, options = {}) => {\n  const parsedManifestInfo = inheritAttributes(stringToMpdXml(manifestString), options);\n  const playlists = toPlaylists(parsedManifestInfo.representationInfo);\n  return toM3u8({\n    dashPlaylists: playlists,\n    locations: parsedManifestInfo.locations,\n    contentSteering: parsedManifestInfo.contentSteeringInfo,\n    sidxMapping: options.sidxMapping,\n    previousManifest: options.previousManifest,\n    eventStream: parsedManifestInfo.eventStream\n  });\n};\n/**\n * Parses the manifest for a UTCTiming node, returning the nodes attributes if found\n *\n * @param {string} manifestString\n *        XML string of the MPD manifest\n * @return {Object|null}\n *         Attributes of UTCTiming node specified in the manifest. Null if none found\n */\n\n\nconst parseUTCTiming = manifestString => parseUTCTimingScheme(stringToMpdXml(manifestString));\n\nexports.VERSION = VERSION;\nexports.addSidxSegmentsToPlaylist = addSidxSegmentsToPlaylist$1;\nexports.generateSidxKey = generateSidxKey;\nexports.inheritAttributes = inheritAttributes;\nexports.parse = parse;\nexports.parseUTCTiming = parseUTCTiming;\nexports.stringToMpdXml = stringToMpdXml;\nexports.toM3u8 = toM3u8;\nexports.toPlaylists = toPlaylists;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbXBkLXBhcnNlci9kaXN0L21wZC1wYXJzZXIuY2pzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ2E7O0FBRWIsOENBQTZDLEVBQUUsYUFBYSxFQUFDOztBQUU3RCxpQkFBaUIsbUJBQU8sQ0FBQyxzR0FBb0M7QUFDN0QsYUFBYSxtQkFBTyxDQUFDLDREQUFlO0FBQ3BDLGtCQUFrQixtQkFBTyxDQUFDLHdHQUFxQztBQUMvRCw0QkFBNEIsbUJBQU8sQ0FBQyxrSUFBa0Q7QUFDdEYsYUFBYSxtQkFBTyxDQUFDLHdFQUFnQjs7QUFFckMscUNBQXFDLDREQUE0RDs7QUFFakc7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRyxJQUFJO0FBQ1A7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHNCQUFzQixTQUFTO0FBQy9CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsa0JBQWtCLGlCQUFpQjtBQUNuQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxVQUFVO0FBQ3JCO0FBQ0EsWUFBWSxPQUFPO0FBQ25COztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRyxJQUFJO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEI7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBLFlBQVksV0FBVztBQUN2QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdDQUF3Qzs7QUFFeEM7QUFDQSwrSEFBK0g7O0FBRS9IO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQSxZQUFZLGlCQUFpQixHQUFHLFNBQVM7QUFDekM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHlCQUF5QjtBQUNwQztBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sNERBQTREO0FBQzVEOztBQUVBLDZDQUE2QztBQUM3Qzs7QUFFQSwrREFBK0Q7O0FBRS9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsYUFBYSxpRUFBaUU7QUFDOUU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQSx1Q0FBdUM7O0FBRXZDLGtHQUFrRzs7QUFFbEc7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBLFlBQVksZ0JBQWdCO0FBQzVCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGNBQWM7O0FBRWxCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCw2QkFBNkI7QUFDN0I7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsWUFBWSxRQUFRO0FBQ3BCOztBQUVBO0FBQ0E7QUFDQSxvRUFBb0U7O0FBRXBFLGlEQUFpRDs7QUFFakQ7QUFDQTtBQUNBLCtEQUErRDs7QUFFL0Qsb0NBQW9DOztBQUVwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDOztBQUU1QyxrQkFBa0I7O0FBRWxCO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQSxrQkFBa0IsNEJBQTRCO0FBQzlDLDBDQUEwQzs7QUFFMUMsMkNBQTJDO0FBQzNDOztBQUVBLG1EQUFtRDs7QUFFbkQsa0JBQWtCOztBQUVsQjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUEsMEJBQTBCLFdBQVcsR0FBRyxTQUFTO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxzREFBc0Q7O0FBRXREO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxpQkFBaUI7QUFDNUI7QUFDQSxZQUFZLGlCQUFpQjtBQUM3Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsWUFBWSxhQUFhO0FBQ3pCOztBQUVBO0FBQ0Esa0JBQWtCLHNCQUFzQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsWUFBWSxPQUFPO0FBQ25COztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsVUFBVTtBQUNyQixXQUFXLFVBQVU7QUFDckIsV0FBVyxRQUFRO0FBQ25COztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUssR0FBRztBQUNSO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxNQUFNO0FBQ047OztBQUdBO0FBQ0E7QUFDQTtBQUNBLEtBQUssR0FBRztBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQjtBQUNBLFlBQVksUUFBUTtBQUNwQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBGQUEwRjtBQUMxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUcsSUFBSTtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUssSUFBSTtBQUNUO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwrREFBK0Q7QUFDL0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxHQUFHOztBQUVSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7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O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUksV0FBVztBQUNmOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQjtBQUNBLFlBQVksUUFBUTtBQUNwQjs7QUFFQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7OztBQUdBOztBQUVBLGVBQWU7QUFDZixpQ0FBaUM7QUFDakMsdUJBQXVCO0FBQ3ZCLHlCQUF5QjtBQUN6QixhQUFhO0FBQ2Isc0JBQXNCO0FBQ3RCLHNCQUFzQjtBQUN0QixjQUFjO0FBQ2QsbUJBQW1CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktdjAtcHJvamVjdC8uL25vZGVfbW9kdWxlcy9tcGQtcGFyc2VyL2Rpc3QvbXBkLXBhcnNlci5janMuanM/OGQwNSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiEgQG5hbWUgbXBkLXBhcnNlciBAdmVyc2lvbiAxLjMuMSBAbGljZW5zZSBBcGFjaGUtMi4wICovXG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciByZXNvbHZlVXJsID0gcmVxdWlyZSgnQHZpZGVvanMvdmhzLXV0aWxzL2Nqcy9yZXNvbHZlLXVybCcpO1xudmFyIHdpbmRvdyA9IHJlcXVpcmUoJ2dsb2JhbC93aW5kb3cnKTtcbnZhciBtZWRpYUdyb3VwcyA9IHJlcXVpcmUoJ0B2aWRlb2pzL3Zocy11dGlscy9janMvbWVkaWEtZ3JvdXBzJyk7XG52YXIgZGVjb2RlQjY0VG9VaW50OEFycmF5ID0gcmVxdWlyZSgnQHZpZGVvanMvdmhzLXV0aWxzL2Nqcy9kZWNvZGUtYjY0LXRvLXVpbnQ4LWFycmF5Jyk7XG52YXIgeG1sZG9tID0gcmVxdWlyZSgnQHhtbGRvbS94bWxkb20nKTtcblxuZnVuY3Rpb24gX2ludGVyb3BEZWZhdWx0TGVnYWN5IChlKSB7IHJldHVybiBlICYmIHR5cGVvZiBlID09PSAnb2JqZWN0JyAmJiAnZGVmYXVsdCcgaW4gZSA/IGUgOiB7ICdkZWZhdWx0JzogZSB9OyB9XG5cbnZhciByZXNvbHZlVXJsX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19pbnRlcm9wRGVmYXVsdExlZ2FjeShyZXNvbHZlVXJsKTtcbnZhciB3aW5kb3dfX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX2ludGVyb3BEZWZhdWx0TGVnYWN5KHdpbmRvdyk7XG52YXIgZGVjb2RlQjY0VG9VaW50OEFycmF5X19kZWZhdWx0ID0gLyojX19QVVJFX18qL19pbnRlcm9wRGVmYXVsdExlZ2FjeShkZWNvZGVCNjRUb1VpbnQ4QXJyYXkpO1xuXG52YXIgdmVyc2lvbiA9IFwiMS4zLjFcIjtcblxuY29uc3QgaXNPYmplY3QgPSBvYmogPT4ge1xuICByZXR1cm4gISFvYmogJiYgdHlwZW9mIG9iaiA9PT0gJ29iamVjdCc7XG59O1xuXG5jb25zdCBtZXJnZSA9ICguLi5vYmplY3RzKSA9PiB7XG4gIHJldHVybiBvYmplY3RzLnJlZHVjZSgocmVzdWx0LCBzb3VyY2UpID0+IHtcbiAgICBpZiAodHlwZW9mIHNvdXJjZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgT2JqZWN0LmtleXMoc291cmNlKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShyZXN1bHRba2V5XSkgJiYgQXJyYXkuaXNBcnJheShzb3VyY2Vba2V5XSkpIHtcbiAgICAgICAgcmVzdWx0W2tleV0gPSByZXN1bHRba2V5XS5jb25jYXQoc291cmNlW2tleV0pO1xuICAgICAgfSBlbHNlIGlmIChpc09iamVjdChyZXN1bHRba2V5XSkgJiYgaXNPYmplY3Qoc291cmNlW2tleV0pKSB7XG4gICAgICAgIHJlc3VsdFtrZXldID0gbWVyZ2UocmVzdWx0W2tleV0sIHNvdXJjZVtrZXldKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdFtrZXldID0gc291cmNlW2tleV07XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSwge30pO1xufTtcbmNvbnN0IHZhbHVlcyA9IG8gPT4gT2JqZWN0LmtleXMobykubWFwKGsgPT4gb1trXSk7XG5cbmNvbnN0IHJhbmdlID0gKHN0YXJ0LCBlbmQpID0+IHtcbiAgY29uc3QgcmVzdWx0ID0gW107XG5cbiAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICByZXN1bHQucHVzaChpKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuY29uc3QgZmxhdHRlbiA9IGxpc3RzID0+IGxpc3RzLnJlZHVjZSgoeCwgeSkgPT4geC5jb25jYXQoeSksIFtdKTtcbmNvbnN0IGZyb20gPSBsaXN0ID0+IHtcbiAgaWYgKCFsaXN0Lmxlbmd0aCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIHJlc3VsdC5wdXNoKGxpc3RbaV0pO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5jb25zdCBmaW5kSW5kZXhlcyA9IChsLCBrZXkpID0+IGwucmVkdWNlKChhLCBlLCBpKSA9PiB7XG4gIGlmIChlW2tleV0pIHtcbiAgICBhLnB1c2goaSk7XG4gIH1cblxuICByZXR1cm4gYTtcbn0sIFtdKTtcbi8qKlxuICogUmV0dXJucyBhIHVuaW9uIG9mIHRoZSBpbmNsdWRlZCBsaXN0cyBwcm92aWRlZCBlYWNoIGVsZW1lbnQgY2FuIGJlIGlkZW50aWZpZWQgYnkgYSBrZXkuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gbGlzdCAtIGxpc3Qgb2YgbGlzdHMgdG8gZ2V0IHRoZSB1bmlvbiBvZlxuICogQHBhcmFtIHtGdW5jdGlvbn0ga2V5RnVuY3Rpb24gLSB0aGUgZnVuY3Rpb24gdG8gdXNlIGFzIGEga2V5IGZvciBlYWNoIGVsZW1lbnRcbiAqXG4gKiBAcmV0dXJuIHtBcnJheX0gdGhlIHVuaW9uIG9mIHRoZSBhcnJheXNcbiAqL1xuXG5jb25zdCB1bmlvbiA9IChsaXN0cywga2V5RnVuY3Rpb24pID0+IHtcbiAgcmV0dXJuIHZhbHVlcyhsaXN0cy5yZWR1Y2UoKGFjYywgbGlzdCkgPT4ge1xuICAgIGxpc3QuZm9yRWFjaChlbCA9PiB7XG4gICAgICBhY2Nba2V5RnVuY3Rpb24oZWwpXSA9IGVsO1xuICAgIH0pO1xuICAgIHJldHVybiBhY2M7XG4gIH0sIHt9KSk7XG59O1xuXG52YXIgZXJyb3JzID0ge1xuICBJTlZBTElEX05VTUJFUl9PRl9QRVJJT0Q6ICdJTlZBTElEX05VTUJFUl9PRl9QRVJJT0QnLFxuICBJTlZBTElEX05VTUJFUl9PRl9DT05URU5UX1NURUVSSU5HOiAnSU5WQUxJRF9OVU1CRVJfT0ZfQ09OVEVOVF9TVEVFUklORycsXG4gIERBU0hfRU1QVFlfTUFOSUZFU1Q6ICdEQVNIX0VNUFRZX01BTklGRVNUJyxcbiAgREFTSF9JTlZBTElEX1hNTDogJ0RBU0hfSU5WQUxJRF9YTUwnLFxuICBOT19CQVNFX1VSTDogJ05PX0JBU0VfVVJMJyxcbiAgTUlTU0lOR19TRUdNRU5UX0lORk9STUFUSU9OOiAnTUlTU0lOR19TRUdNRU5UX0lORk9STUFUSU9OJyxcbiAgU0VHTUVOVF9USU1FX1VOU1BFQ0lGSUVEOiAnU0VHTUVOVF9USU1FX1VOU1BFQ0lGSUVEJyxcbiAgVU5TVVBQT1JURURfVVRDX1RJTUlOR19TQ0hFTUU6ICdVTlNVUFBPUlRFRF9VVENfVElNSU5HX1NDSEVNRSdcbn07XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gU2luZ2xlVXJpXG4gKiBAcHJvcGVydHkge3N0cmluZ30gdXJpIC0gcmVsYXRpdmUgbG9jYXRpb24gb2Ygc2VnbWVudFxuICogQHByb3BlcnR5IHtzdHJpbmd9IHJlc29sdmVkVXJpIC0gcmVzb2x2ZWQgbG9jYXRpb24gb2Ygc2VnbWVudFxuICogQHByb3BlcnR5IHtPYmplY3R9IGJ5dGVyYW5nZSAtIE9iamVjdCBjb250YWluaW5nIGluZm9ybWF0aW9uIG9uIGhvdyB0byBtYWtlIGJ5dGUgcmFuZ2VcbiAqICAgcmVxdWVzdHMgZm9sbG93aW5nIGJ5dGUtcmFuZ2Utc3BlYyBwZXIgUkZDMjYxNi5cbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBieXRlcmFuZ2UubGVuZ3RoIC0gbGVuZ3RoIG9mIHJhbmdlIHJlcXVlc3RcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBieXRlcmFuZ2Uub2Zmc2V0IC0gYnl0ZSBvZmZzZXQgb2YgcmFuZ2UgcmVxdWVzdFxuICpcbiAqIEBzZWUgaHR0cHM6Ly93d3cudzMub3JnL1Byb3RvY29scy9yZmMyNjE2L3JmYzI2MTYtc2VjMTQuaHRtbCNzZWMxNC4zNS4xXG4gKi9cblxuLyoqXG4gKiBDb252ZXJ0cyBhIFVSTFR5cGUgbm9kZSAoNS4zLjkuMi4zIFRhYmxlIDEzKSB0byBhIHNlZ21lbnQgb2JqZWN0XG4gKiB0aGF0IGNvbmZvcm1zIHRvIGhvdyBtM3U4LXBhcnNlciBpcyBzdHJ1Y3R1cmVkXG4gKlxuICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vdmlkZW9qcy9tM3U4LXBhcnNlclxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBiYXNlVXJsIC0gYmFzZVVybCBwcm92aWRlZCBieSA8QmFzZVVybD4gbm9kZXNcbiAqIEBwYXJhbSB7c3RyaW5nfSBzb3VyY2UgLSBzb3VyY2UgdXJsIGZvciBzZWdtZW50XG4gKiBAcGFyYW0ge3N0cmluZ30gcmFuZ2UgLSBvcHRpb25hbCByYW5nZSB1c2VkIGZvciByYW5nZSBjYWxscyxcbiAqICAgZm9sbG93cyAgUkZDIDI2MTYsIENsYXVzZSAxNC4zNS4xXG4gKiBAcmV0dXJuIHtTaW5nbGVVcml9IGZ1bGwgc2VnbWVudCBpbmZvcm1hdGlvbiB0cmFuc2Zvcm1lZCBpbnRvIGEgZm9ybWF0IHNpbWlsYXJcbiAqICAgdG8gbTN1OC1wYXJzZXJcbiAqL1xuXG5jb25zdCB1cmxUeXBlVG9TZWdtZW50ID0gKHtcbiAgYmFzZVVybCA9ICcnLFxuICBzb3VyY2UgPSAnJyxcbiAgcmFuZ2UgPSAnJyxcbiAgaW5kZXhSYW5nZSA9ICcnXG59KSA9PiB7XG4gIGNvbnN0IHNlZ21lbnQgPSB7XG4gICAgdXJpOiBzb3VyY2UsXG4gICAgcmVzb2x2ZWRVcmk6IHJlc29sdmVVcmxfX2RlZmF1bHRbJ2RlZmF1bHQnXShiYXNlVXJsIHx8ICcnLCBzb3VyY2UpXG4gIH07XG5cbiAgaWYgKHJhbmdlIHx8IGluZGV4UmFuZ2UpIHtcbiAgICBjb25zdCByYW5nZVN0ciA9IHJhbmdlID8gcmFuZ2UgOiBpbmRleFJhbmdlO1xuICAgIGNvbnN0IHJhbmdlcyA9IHJhbmdlU3RyLnNwbGl0KCctJyk7IC8vIGRlZmF1bHQgdG8gcGFyc2luZyB0aGlzIGFzIGEgQmlnSW50IGlmIHBvc3NpYmxlXG5cbiAgICBsZXQgc3RhcnRSYW5nZSA9IHdpbmRvd19fZGVmYXVsdFsnZGVmYXVsdCddLkJpZ0ludCA/IHdpbmRvd19fZGVmYXVsdFsnZGVmYXVsdCddLkJpZ0ludChyYW5nZXNbMF0pIDogcGFyc2VJbnQocmFuZ2VzWzBdLCAxMCk7XG4gICAgbGV0IGVuZFJhbmdlID0gd2luZG93X19kZWZhdWx0WydkZWZhdWx0J10uQmlnSW50ID8gd2luZG93X19kZWZhdWx0WydkZWZhdWx0J10uQmlnSW50KHJhbmdlc1sxXSkgOiBwYXJzZUludChyYW5nZXNbMV0sIDEwKTsgLy8gY29udmVydCBiYWNrIHRvIGEgbnVtYmVyIGlmIGxlc3MgdGhhbiBNQVhfU0FGRV9JTlRFR0VSXG5cbiAgICBpZiAoc3RhcnRSYW5nZSA8IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSICYmIHR5cGVvZiBzdGFydFJhbmdlID09PSAnYmlnaW50Jykge1xuICAgICAgc3RhcnRSYW5nZSA9IE51bWJlcihzdGFydFJhbmdlKTtcbiAgICB9XG5cbiAgICBpZiAoZW5kUmFuZ2UgPCBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiAmJiB0eXBlb2YgZW5kUmFuZ2UgPT09ICdiaWdpbnQnKSB7XG4gICAgICBlbmRSYW5nZSA9IE51bWJlcihlbmRSYW5nZSk7XG4gICAgfVxuXG4gICAgbGV0IGxlbmd0aDtcblxuICAgIGlmICh0eXBlb2YgZW5kUmFuZ2UgPT09ICdiaWdpbnQnIHx8IHR5cGVvZiBzdGFydFJhbmdlID09PSAnYmlnaW50Jykge1xuICAgICAgbGVuZ3RoID0gd2luZG93X19kZWZhdWx0WydkZWZhdWx0J10uQmlnSW50KGVuZFJhbmdlKSAtIHdpbmRvd19fZGVmYXVsdFsnZGVmYXVsdCddLkJpZ0ludChzdGFydFJhbmdlKSArIHdpbmRvd19fZGVmYXVsdFsnZGVmYXVsdCddLkJpZ0ludCgxKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGVuZ3RoID0gZW5kUmFuZ2UgLSBzdGFydFJhbmdlICsgMTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGxlbmd0aCA9PT0gJ2JpZ2ludCcgJiYgbGVuZ3RoIDwgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpIHtcbiAgICAgIGxlbmd0aCA9IE51bWJlcihsZW5ndGgpO1xuICAgIH0gLy8gYnl0ZXJhbmdlIHNob3VsZCBiZSBpbmNsdXNpdmUgYWNjb3JkaW5nIHRvXG4gICAgLy8gUkZDIDI2MTYsIENsYXVzZSAxNC4zNS4xXG5cblxuICAgIHNlZ21lbnQuYnl0ZXJhbmdlID0ge1xuICAgICAgbGVuZ3RoLFxuICAgICAgb2Zmc2V0OiBzdGFydFJhbmdlXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBzZWdtZW50O1xufTtcbmNvbnN0IGJ5dGVSYW5nZVRvU3RyaW5nID0gYnl0ZXJhbmdlID0+IHtcbiAgLy8gYGVuZFJhbmdlYCBpcyBvbmUgbGVzcyB0aGFuIGBvZmZzZXQgKyBsZW5ndGhgIGJlY2F1c2UgdGhlIEhUVFAgcmFuZ2VcbiAgLy8gaGVhZGVyIHVzZXMgaW5jbHVzaXZlIHJhbmdlc1xuICBsZXQgZW5kUmFuZ2U7XG5cbiAgaWYgKHR5cGVvZiBieXRlcmFuZ2Uub2Zmc2V0ID09PSAnYmlnaW50JyB8fCB0eXBlb2YgYnl0ZXJhbmdlLmxlbmd0aCA9PT0gJ2JpZ2ludCcpIHtcbiAgICBlbmRSYW5nZSA9IHdpbmRvd19fZGVmYXVsdFsnZGVmYXVsdCddLkJpZ0ludChieXRlcmFuZ2Uub2Zmc2V0KSArIHdpbmRvd19fZGVmYXVsdFsnZGVmYXVsdCddLkJpZ0ludChieXRlcmFuZ2UubGVuZ3RoKSAtIHdpbmRvd19fZGVmYXVsdFsnZGVmYXVsdCddLkJpZ0ludCgxKTtcbiAgfSBlbHNlIHtcbiAgICBlbmRSYW5nZSA9IGJ5dGVyYW5nZS5vZmZzZXQgKyBieXRlcmFuZ2UubGVuZ3RoIC0gMTtcbiAgfVxuXG4gIHJldHVybiBgJHtieXRlcmFuZ2Uub2Zmc2V0fS0ke2VuZFJhbmdlfWA7XG59O1xuXG4vKipcbiAqIHBhcnNlIHRoZSBlbmQgbnVtYmVyIGF0dHJpYnVlIHRoYXQgY2FuIGJlIGEgc3RyaW5nXG4gKiBudW1iZXIsIG9yIHVuZGVmaW5lZC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ8dW5kZWZpbmVkfSBlbmROdW1iZXJcbiAqICAgICAgICBUaGUgZW5kIG51bWJlciBhdHRyaWJ1dGUuXG4gKlxuICogQHJldHVybiB7bnVtYmVyfG51bGx9XG4gKiAgICAgICAgICBUaGUgcmVzdWx0IG9mIHBhcnNpbmcgdGhlIGVuZCBudW1iZXIuXG4gKi9cblxuY29uc3QgcGFyc2VFbmROdW1iZXIgPSBlbmROdW1iZXIgPT4ge1xuICBpZiAoZW5kTnVtYmVyICYmIHR5cGVvZiBlbmROdW1iZXIgIT09ICdudW1iZXInKSB7XG4gICAgZW5kTnVtYmVyID0gcGFyc2VJbnQoZW5kTnVtYmVyLCAxMCk7XG4gIH1cblxuICBpZiAoaXNOYU4oZW5kTnVtYmVyKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIGVuZE51bWJlcjtcbn07XG4vKipcbiAqIEZ1bmN0aW9ucyBmb3IgY2FsY3VsYXRpbmcgdGhlIHJhbmdlIG9mIGF2YWlsYWJsZSBzZWdtZW50cyBpbiBzdGF0aWMgYW5kIGR5bmFtaWNcbiAqIG1hbmlmZXN0cy5cbiAqL1xuXG5cbmNvbnN0IHNlZ21lbnRSYW5nZSA9IHtcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGVudGlyZSByYW5nZSBvZiBhdmFpbGFibGUgc2VnbWVudHMgZm9yIGEgc3RhdGljIE1QRFxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gYXR0cmlidXRlc1xuICAgKiAgICAgICAgSW5oZXJpdGllZCBNUEQgYXR0cmlidXRlc1xuICAgKiBAcmV0dXJuIHt7IHN0YXJ0OiBudW1iZXIsIGVuZDogbnVtYmVyIH19XG4gICAqICAgICAgICAgVGhlIHN0YXJ0IGFuZCBlbmQgbnVtYmVycyBmb3IgYXZhaWxhYmxlIHNlZ21lbnRzXG4gICAqL1xuICBzdGF0aWMoYXR0cmlidXRlcykge1xuICAgIGNvbnN0IHtcbiAgICAgIGR1cmF0aW9uLFxuICAgICAgdGltZXNjYWxlID0gMSxcbiAgICAgIHNvdXJjZUR1cmF0aW9uLFxuICAgICAgcGVyaW9kRHVyYXRpb25cbiAgICB9ID0gYXR0cmlidXRlcztcbiAgICBjb25zdCBlbmROdW1iZXIgPSBwYXJzZUVuZE51bWJlcihhdHRyaWJ1dGVzLmVuZE51bWJlcik7XG4gICAgY29uc3Qgc2VnbWVudER1cmF0aW9uID0gZHVyYXRpb24gLyB0aW1lc2NhbGU7XG5cbiAgICBpZiAodHlwZW9mIGVuZE51bWJlciA9PT0gJ251bWJlcicpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN0YXJ0OiAwLFxuICAgICAgICBlbmQ6IGVuZE51bWJlclxuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHBlcmlvZER1cmF0aW9uID09PSAnbnVtYmVyJykge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3RhcnQ6IDAsXG4gICAgICAgIGVuZDogcGVyaW9kRHVyYXRpb24gLyBzZWdtZW50RHVyYXRpb25cbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXJ0OiAwLFxuICAgICAgZW5kOiBzb3VyY2VEdXJhdGlvbiAvIHNlZ21lbnREdXJhdGlvblxuICAgIH07XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGN1cnJlbnQgbGl2ZSB3aW5kb3cgcmFuZ2Ugb2YgYXZhaWxhYmxlIHNlZ21lbnRzIGZvciBhIGR5bmFtaWMgTVBEXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBhdHRyaWJ1dGVzXG4gICAqICAgICAgICBJbmhlcml0aWVkIE1QRCBhdHRyaWJ1dGVzXG4gICAqIEByZXR1cm4ge3sgc3RhcnQ6IG51bWJlciwgZW5kOiBudW1iZXIgfX1cbiAgICogICAgICAgICBUaGUgc3RhcnQgYW5kIGVuZCBudW1iZXJzIGZvciBhdmFpbGFibGUgc2VnbWVudHNcbiAgICovXG4gIGR5bmFtaWMoYXR0cmlidXRlcykge1xuICAgIGNvbnN0IHtcbiAgICAgIE5PVyxcbiAgICAgIGNsaWVudE9mZnNldCxcbiAgICAgIGF2YWlsYWJpbGl0eVN0YXJ0VGltZSxcbiAgICAgIHRpbWVzY2FsZSA9IDEsXG4gICAgICBkdXJhdGlvbixcbiAgICAgIHBlcmlvZFN0YXJ0ID0gMCxcbiAgICAgIG1pbmltdW1VcGRhdGVQZXJpb2QgPSAwLFxuICAgICAgdGltZVNoaWZ0QnVmZmVyRGVwdGggPSBJbmZpbml0eVxuICAgIH0gPSBhdHRyaWJ1dGVzO1xuICAgIGNvbnN0IGVuZE51bWJlciA9IHBhcnNlRW5kTnVtYmVyKGF0dHJpYnV0ZXMuZW5kTnVtYmVyKTsgLy8gY2xpZW50T2Zmc2V0IGlzIHBhc3NlZCBpbiBhdCB0aGUgdG9wIGxldmVsIG9mIG1wZC1wYXJzZXIgYW5kIGlzIGFuIG9mZnNldCBjYWxjdWxhdGVkXG4gICAgLy8gYWZ0ZXIgcmV0cmlldmluZyBVVEMgc2VydmVyIHRpbWUuXG5cbiAgICBjb25zdCBub3cgPSAoTk9XICsgY2xpZW50T2Zmc2V0KSAvIDEwMDA7IC8vIFdDIHN0YW5kcyBmb3IgV2FsbCBDbG9jay5cbiAgICAvLyBDb252ZXJ0IHRoZSBwZXJpb2Qgc3RhcnQgdGltZSB0byBFUE9DSC5cblxuICAgIGNvbnN0IHBlcmlvZFN0YXJ0V0MgPSBhdmFpbGFiaWxpdHlTdGFydFRpbWUgKyBwZXJpb2RTdGFydDsgLy8gUGVyaW9kIGVuZCBpbiBFUE9DSCBpcyBtYW5pZmVzdCdzIHJldHJpZXZhbCB0aW1lICsgdGltZSB1bnRpbCBuZXh0IHVwZGF0ZS5cblxuICAgIGNvbnN0IHBlcmlvZEVuZFdDID0gbm93ICsgbWluaW11bVVwZGF0ZVBlcmlvZDtcbiAgICBjb25zdCBwZXJpb2REdXJhdGlvbiA9IHBlcmlvZEVuZFdDIC0gcGVyaW9kU3RhcnRXQztcbiAgICBjb25zdCBzZWdtZW50Q291bnQgPSBNYXRoLmNlaWwocGVyaW9kRHVyYXRpb24gKiB0aW1lc2NhbGUgLyBkdXJhdGlvbik7XG4gICAgY29uc3QgYXZhaWxhYmxlU3RhcnQgPSBNYXRoLmZsb29yKChub3cgLSBwZXJpb2RTdGFydFdDIC0gdGltZVNoaWZ0QnVmZmVyRGVwdGgpICogdGltZXNjYWxlIC8gZHVyYXRpb24pO1xuICAgIGNvbnN0IGF2YWlsYWJsZUVuZCA9IE1hdGguZmxvb3IoKG5vdyAtIHBlcmlvZFN0YXJ0V0MpICogdGltZXNjYWxlIC8gZHVyYXRpb24pO1xuICAgIHJldHVybiB7XG4gICAgICBzdGFydDogTWF0aC5tYXgoMCwgYXZhaWxhYmxlU3RhcnQpLFxuICAgICAgZW5kOiB0eXBlb2YgZW5kTnVtYmVyID09PSAnbnVtYmVyJyA/IGVuZE51bWJlciA6IE1hdGgubWluKHNlZ21lbnRDb3VudCwgYXZhaWxhYmxlRW5kKVxuICAgIH07XG4gIH1cblxufTtcbi8qKlxuICogTWFwcyBhIHJhbmdlIG9mIG51bWJlcnMgdG8gb2JqZWN0cyB3aXRoIGluZm9ybWF0aW9uIG5lZWRlZCB0byBidWlsZCB0aGUgY29ycmVzcG9uZGluZ1xuICogc2VnbWVudCBsaXN0XG4gKlxuICogQG5hbWUgdG9TZWdtZW50c0NhbGxiYWNrXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7bnVtYmVyfSBudW1iZXJcbiAqICAgICAgICBOdW1iZXIgb2YgdGhlIHNlZ21lbnRcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICogICAgICAgIEluZGV4IG9mIHRoZSBudW1iZXIgaW4gdGhlIHJhbmdlIGxpc3RcbiAqIEByZXR1cm4ge3sgbnVtYmVyOiBOdW1iZXIsIGR1cmF0aW9uOiBOdW1iZXIsIHRpbWVsaW5lOiBOdW1iZXIsIHRpbWU6IE51bWJlciB9fVxuICogICAgICAgICBPYmplY3Qgd2l0aCBzZWdtZW50IHRpbWluZyBhbmQgZHVyYXRpb24gaW5mb1xuICovXG5cbi8qKlxuICogUmV0dXJucyBhIGNhbGxiYWNrIGZvciBBcnJheS5wcm90b3R5cGUubWFwIGZvciBtYXBwaW5nIGEgcmFuZ2Ugb2YgbnVtYmVycyB0b1xuICogaW5mb3JtYXRpb24gbmVlZGVkIHRvIGJ1aWxkIHRoZSBzZWdtZW50IGxpc3QuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGF0dHJpYnV0ZXNcbiAqICAgICAgICBJbmhlcml0ZWQgTVBEIGF0dHJpYnV0ZXNcbiAqIEByZXR1cm4ge3RvU2VnbWVudHNDYWxsYmFja31cbiAqICAgICAgICAgQ2FsbGJhY2sgbWFwIGZ1bmN0aW9uXG4gKi9cblxuY29uc3QgdG9TZWdtZW50cyA9IGF0dHJpYnV0ZXMgPT4gbnVtYmVyID0+IHtcbiAgY29uc3Qge1xuICAgIGR1cmF0aW9uLFxuICAgIHRpbWVzY2FsZSA9IDEsXG4gICAgcGVyaW9kU3RhcnQsXG4gICAgc3RhcnROdW1iZXIgPSAxXG4gIH0gPSBhdHRyaWJ1dGVzO1xuICByZXR1cm4ge1xuICAgIG51bWJlcjogc3RhcnROdW1iZXIgKyBudW1iZXIsXG4gICAgZHVyYXRpb246IGR1cmF0aW9uIC8gdGltZXNjYWxlLFxuICAgIHRpbWVsaW5lOiBwZXJpb2RTdGFydCxcbiAgICB0aW1lOiBudW1iZXIgKiBkdXJhdGlvblxuICB9O1xufTtcbi8qKlxuICogUmV0dXJucyBhIGxpc3Qgb2Ygb2JqZWN0cyBjb250YWluaW5nIHNlZ21lbnQgdGltaW5nIGFuZCBkdXJhdGlvbiBpbmZvIHVzZWQgZm9yXG4gKiBidWlsZGluZyB0aGUgbGlzdCBvZiBzZWdtZW50cy4gVGhpcyB1c2VzIHRoZSBAZHVyYXRpb24gYXR0cmlidXRlIHNwZWNpZmllZFxuICogaW4gdGhlIE1QRCBtYW5pZmVzdCB0byBkZXJpdmUgdGhlIHJhbmdlIG9mIHNlZ21lbnRzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBhdHRyaWJ1dGVzXG4gKiAgICAgICAgSW5oZXJpdGVkIE1QRCBhdHRyaWJ1dGVzXG4gKiBAcmV0dXJuIHt7bnVtYmVyOiBudW1iZXIsIGR1cmF0aW9uOiBudW1iZXIsIHRpbWU6IG51bWJlciwgdGltZWxpbmU6IG51bWJlcn1bXX1cbiAqICAgICAgICAgTGlzdCBvZiBPYmplY3RzIHdpdGggc2VnbWVudCB0aW1pbmcgYW5kIGR1cmF0aW9uIGluZm9cbiAqL1xuXG5jb25zdCBwYXJzZUJ5RHVyYXRpb24gPSBhdHRyaWJ1dGVzID0+IHtcbiAgY29uc3Qge1xuICAgIHR5cGUsXG4gICAgZHVyYXRpb24sXG4gICAgdGltZXNjYWxlID0gMSxcbiAgICBwZXJpb2REdXJhdGlvbixcbiAgICBzb3VyY2VEdXJhdGlvblxuICB9ID0gYXR0cmlidXRlcztcbiAgY29uc3Qge1xuICAgIHN0YXJ0LFxuICAgIGVuZFxuICB9ID0gc2VnbWVudFJhbmdlW3R5cGVdKGF0dHJpYnV0ZXMpO1xuICBjb25zdCBzZWdtZW50cyA9IHJhbmdlKHN0YXJ0LCBlbmQpLm1hcCh0b1NlZ21lbnRzKGF0dHJpYnV0ZXMpKTtcblxuICBpZiAodHlwZSA9PT0gJ3N0YXRpYycpIHtcbiAgICBjb25zdCBpbmRleCA9IHNlZ21lbnRzLmxlbmd0aCAtIDE7IC8vIHNlY3Rpb24gaXMgZWl0aGVyIGEgcGVyaW9kIG9yIHRoZSBmdWxsIHNvdXJjZVxuXG4gICAgY29uc3Qgc2VjdGlvbkR1cmF0aW9uID0gdHlwZW9mIHBlcmlvZER1cmF0aW9uID09PSAnbnVtYmVyJyA/IHBlcmlvZER1cmF0aW9uIDogc291cmNlRHVyYXRpb247IC8vIGZpbmFsIHNlZ21lbnQgbWF5IGJlIGxlc3MgdGhhbiBmdWxsIHNlZ21lbnQgZHVyYXRpb25cblxuICAgIHNlZ21lbnRzW2luZGV4XS5kdXJhdGlvbiA9IHNlY3Rpb25EdXJhdGlvbiAtIGR1cmF0aW9uIC8gdGltZXNjYWxlICogaW5kZXg7XG4gIH1cblxuICByZXR1cm4gc2VnbWVudHM7XG59O1xuXG4vKipcbiAqIFRyYW5zbGF0ZXMgU2VnbWVudEJhc2UgaW50byBhIHNldCBvZiBzZWdtZW50cy5cbiAqIChEQVNIIFNQRUMgU2VjdGlvbiA1LjMuOS4zLjIpIGNvbnRhaW5zIGEgc2V0IG9mIDxTZWdtZW50VVJMPiBub2Rlcy4gIEVhY2hcbiAqIG5vZGUgc2hvdWxkIGJlIHRyYW5zbGF0ZWQgaW50byBzZWdtZW50LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBhdHRyaWJ1dGVzXG4gKiAgIE9iamVjdCBjb250YWluaW5nIGFsbCBpbmhlcml0ZWQgYXR0cmlidXRlcyBmcm9tIHBhcmVudCBlbGVtZW50cyB3aXRoIGF0dHJpYnV0ZVxuICogICBuYW1lcyBhcyBrZXlzXG4gKiBAcmV0dXJuIHtPYmplY3QuPEFycmF5Pn0gbGlzdCBvZiBzZWdtZW50c1xuICovXG5cbmNvbnN0IHNlZ21lbnRzRnJvbUJhc2UgPSBhdHRyaWJ1dGVzID0+IHtcbiAgY29uc3Qge1xuICAgIGJhc2VVcmwsXG4gICAgaW5pdGlhbGl6YXRpb24gPSB7fSxcbiAgICBzb3VyY2VEdXJhdGlvbixcbiAgICBpbmRleFJhbmdlID0gJycsXG4gICAgcGVyaW9kU3RhcnQsXG4gICAgcHJlc2VudGF0aW9uVGltZSxcbiAgICBudW1iZXIgPSAwLFxuICAgIGR1cmF0aW9uXG4gIH0gPSBhdHRyaWJ1dGVzOyAvLyBiYXNlIHVybCBpcyByZXF1aXJlZCBmb3IgU2VnbWVudEJhc2UgdG8gd29yaywgcGVyIHNwZWMgKFNlY3Rpb24gNS4zLjkuMi4xKVxuXG4gIGlmICghYmFzZVVybCkge1xuICAgIHRocm93IG5ldyBFcnJvcihlcnJvcnMuTk9fQkFTRV9VUkwpO1xuICB9XG5cbiAgY29uc3QgaW5pdFNlZ21lbnQgPSB1cmxUeXBlVG9TZWdtZW50KHtcbiAgICBiYXNlVXJsLFxuICAgIHNvdXJjZTogaW5pdGlhbGl6YXRpb24uc291cmNlVVJMLFxuICAgIHJhbmdlOiBpbml0aWFsaXphdGlvbi5yYW5nZVxuICB9KTtcbiAgY29uc3Qgc2VnbWVudCA9IHVybFR5cGVUb1NlZ21lbnQoe1xuICAgIGJhc2VVcmwsXG4gICAgc291cmNlOiBiYXNlVXJsLFxuICAgIGluZGV4UmFuZ2VcbiAgfSk7XG4gIHNlZ21lbnQubWFwID0gaW5pdFNlZ21lbnQ7IC8vIElmIHRoZXJlIGlzIGEgZHVyYXRpb24sIHVzZSBpdCwgb3RoZXJ3aXNlIHVzZSB0aGUgZ2l2ZW4gZHVyYXRpb24gb2YgdGhlIHNvdXJjZVxuICAvLyAoc2luY2UgU2VnbWVudEJhc2UgaXMgb25seSBmb3Igb25lIHRvdGFsIHNlZ21lbnQpXG5cbiAgaWYgKGR1cmF0aW9uKSB7XG4gICAgY29uc3Qgc2VnbWVudFRpbWVJbmZvID0gcGFyc2VCeUR1cmF0aW9uKGF0dHJpYnV0ZXMpO1xuXG4gICAgaWYgKHNlZ21lbnRUaW1lSW5mby5sZW5ndGgpIHtcbiAgICAgIHNlZ21lbnQuZHVyYXRpb24gPSBzZWdtZW50VGltZUluZm9bMF0uZHVyYXRpb247XG4gICAgICBzZWdtZW50LnRpbWVsaW5lID0gc2VnbWVudFRpbWVJbmZvWzBdLnRpbWVsaW5lO1xuICAgIH1cbiAgfSBlbHNlIGlmIChzb3VyY2VEdXJhdGlvbikge1xuICAgIHNlZ21lbnQuZHVyYXRpb24gPSBzb3VyY2VEdXJhdGlvbjtcbiAgICBzZWdtZW50LnRpbWVsaW5lID0gcGVyaW9kU3RhcnQ7XG4gIH0gLy8gSWYgcHJlc2VudGF0aW9uIHRpbWUgaXMgcHJvdmlkZWQsIHRoZXNlIHNlZ21lbnRzIGFyZSBiZWluZyBnZW5lcmF0ZWQgYnkgU0lEWFxuICAvLyByZWZlcmVuY2VzLCBhbmQgc2hvdWxkIHVzZSB0aGUgdGltZSBwcm92aWRlZC4gRm9yIHRoZSBnZW5lcmFsIGNhc2Ugb2YgU2VnbWVudEJhc2UsXG4gIC8vIHRoZXJlIHNob3VsZCBvbmx5IGJlIG9uZSBzZWdtZW50IGluIHRoZSBwZXJpb2QsIHNvIGl0cyBwcmVzZW50YXRpb24gdGltZSBpcyB0aGUgc2FtZVxuICAvLyBhcyBpdHMgcGVyaW9kIHN0YXJ0LlxuXG5cbiAgc2VnbWVudC5wcmVzZW50YXRpb25UaW1lID0gcHJlc2VudGF0aW9uVGltZSB8fCBwZXJpb2RTdGFydDtcbiAgc2VnbWVudC5udW1iZXIgPSBudW1iZXI7XG4gIHJldHVybiBbc2VnbWVudF07XG59O1xuLyoqXG4gKiBHaXZlbiBhIHBsYXlsaXN0LCBhIHNpZHggYm94LCBhbmQgYSBiYXNlVXJsLCB1cGRhdGUgdGhlIHNlZ21lbnQgbGlzdCBvZiB0aGUgcGxheWxpc3RcbiAqIGFjY29yZGluZyB0byB0aGUgc2lkeCBpbmZvcm1hdGlvbiBnaXZlbi5cbiAqXG4gKiBwbGF5bGlzdC5zaWR4IGhhcyBtZXRhZGFkYXRhIGFib3V0IHRoZSBzaWR4IHdoZXJlLWFzIHRoZSBzaWR4IHBhcmFtXG4gKiBpcyB0aGUgcGFyc2VkIHNpZHggYm94IGl0c2VsZi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGxheWxpc3QgdGhlIHBsYXlsaXN0IHRvIHVwZGF0ZSB0aGUgc2lkeCBpbmZvcm1hdGlvbiBmb3JcbiAqIEBwYXJhbSB7T2JqZWN0fSBzaWR4IHRoZSBwYXJzZWQgc2lkeCBib3hcbiAqIEByZXR1cm4ge09iamVjdH0gdGhlIHBsYXlsaXN0IG9iamVjdCB3aXRoIHRoZSB1cGRhdGVkIHNpZHggaW5mb3JtYXRpb25cbiAqL1xuXG5jb25zdCBhZGRTaWR4U2VnbWVudHNUb1BsYXlsaXN0JDEgPSAocGxheWxpc3QsIHNpZHgsIGJhc2VVcmwpID0+IHtcbiAgLy8gUmV0YWluIGluaXQgc2VnbWVudCBpbmZvcm1hdGlvblxuICBjb25zdCBpbml0U2VnbWVudCA9IHBsYXlsaXN0LnNpZHgubWFwID8gcGxheWxpc3Quc2lkeC5tYXAgOiBudWxsOyAvLyBSZXRhaW4gc291cmNlIGR1cmF0aW9uIGZyb20gaW5pdGlhbCBtYWluIG1hbmlmZXN0IHBhcnNpbmdcblxuICBjb25zdCBzb3VyY2VEdXJhdGlvbiA9IHBsYXlsaXN0LnNpZHguZHVyYXRpb247IC8vIFJldGFpbiBzb3VyY2UgdGltZWxpbmVcblxuICBjb25zdCB0aW1lbGluZSA9IHBsYXlsaXN0LnRpbWVsaW5lIHx8IDA7XG4gIGNvbnN0IHNpZHhCeXRlUmFuZ2UgPSBwbGF5bGlzdC5zaWR4LmJ5dGVyYW5nZTtcbiAgY29uc3Qgc2lkeEVuZCA9IHNpZHhCeXRlUmFuZ2Uub2Zmc2V0ICsgc2lkeEJ5dGVSYW5nZS5sZW5ndGg7IC8vIFJldGFpbiB0aW1lc2NhbGUgb2YgdGhlIHBhcnNlZCBzaWR4XG5cbiAgY29uc3QgdGltZXNjYWxlID0gc2lkeC50aW1lc2NhbGU7IC8vIHJlZmVyZW5jZVR5cGUgMSByZWZlcnMgdG8gb3RoZXIgc2lkeCBib3hlc1xuXG4gIGNvbnN0IG1lZGlhUmVmZXJlbmNlcyA9IHNpZHgucmVmZXJlbmNlcy5maWx0ZXIociA9PiByLnJlZmVyZW5jZVR5cGUgIT09IDEpO1xuICBjb25zdCBzZWdtZW50cyA9IFtdO1xuICBjb25zdCB0eXBlID0gcGxheWxpc3QuZW5kTGlzdCA/ICdzdGF0aWMnIDogJ2R5bmFtaWMnO1xuICBjb25zdCBwZXJpb2RTdGFydCA9IHBsYXlsaXN0LnNpZHgudGltZWxpbmU7XG4gIGxldCBwcmVzZW50YXRpb25UaW1lID0gcGVyaW9kU3RhcnQ7XG4gIGxldCBudW1iZXIgPSBwbGF5bGlzdC5tZWRpYVNlcXVlbmNlIHx8IDA7IC8vIGZpcnN0T2Zmc2V0IGlzIHRoZSBvZmZzZXQgZnJvbSB0aGUgZW5kIG9mIHRoZSBzaWR4IGJveFxuXG4gIGxldCBzdGFydEluZGV4OyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcblxuICBpZiAodHlwZW9mIHNpZHguZmlyc3RPZmZzZXQgPT09ICdiaWdpbnQnKSB7XG4gICAgc3RhcnRJbmRleCA9IHdpbmRvd19fZGVmYXVsdFsnZGVmYXVsdCddLkJpZ0ludChzaWR4RW5kKSArIHNpZHguZmlyc3RPZmZzZXQ7XG4gIH0gZWxzZSB7XG4gICAgc3RhcnRJbmRleCA9IHNpZHhFbmQgKyBzaWR4LmZpcnN0T2Zmc2V0O1xuICB9XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBtZWRpYVJlZmVyZW5jZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCByZWZlcmVuY2UgPSBzaWR4LnJlZmVyZW5jZXNbaV07IC8vIHNpemUgb2YgdGhlIHJlZmVyZW5jZWQgKHN1YilzZWdtZW50XG5cbiAgICBjb25zdCBzaXplID0gcmVmZXJlbmNlLnJlZmVyZW5jZWRTaXplOyAvLyBkdXJhdGlvbiBvZiB0aGUgcmVmZXJlbmNlZCAoc3ViKXNlZ21lbnQsIGluICB0aGUgIHRpbWVzY2FsZVxuICAgIC8vIHRoaXMgd2lsbCBiZSBjb252ZXJ0ZWQgdG8gc2Vjb25kcyB3aGVuIGdlbmVyYXRpbmcgc2VnbWVudHNcblxuICAgIGNvbnN0IGR1cmF0aW9uID0gcmVmZXJlbmNlLnN1YnNlZ21lbnREdXJhdGlvbjsgLy8gc2hvdWxkIGJlIGFuIGluY2x1c2l2ZSByYW5nZVxuXG4gICAgbGV0IGVuZEluZGV4OyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcblxuICAgIGlmICh0eXBlb2Ygc3RhcnRJbmRleCA9PT0gJ2JpZ2ludCcpIHtcbiAgICAgIGVuZEluZGV4ID0gc3RhcnRJbmRleCArIHdpbmRvd19fZGVmYXVsdFsnZGVmYXVsdCddLkJpZ0ludChzaXplKSAtIHdpbmRvd19fZGVmYXVsdFsnZGVmYXVsdCddLkJpZ0ludCgxKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZW5kSW5kZXggPSBzdGFydEluZGV4ICsgc2l6ZSAtIDE7XG4gICAgfVxuXG4gICAgY29uc3QgaW5kZXhSYW5nZSA9IGAke3N0YXJ0SW5kZXh9LSR7ZW5kSW5kZXh9YDtcbiAgICBjb25zdCBhdHRyaWJ1dGVzID0ge1xuICAgICAgYmFzZVVybCxcbiAgICAgIHRpbWVzY2FsZSxcbiAgICAgIHRpbWVsaW5lLFxuICAgICAgcGVyaW9kU3RhcnQsXG4gICAgICBwcmVzZW50YXRpb25UaW1lLFxuICAgICAgbnVtYmVyLFxuICAgICAgZHVyYXRpb24sXG4gICAgICBzb3VyY2VEdXJhdGlvbixcbiAgICAgIGluZGV4UmFuZ2UsXG4gICAgICB0eXBlXG4gICAgfTtcbiAgICBjb25zdCBzZWdtZW50ID0gc2VnbWVudHNGcm9tQmFzZShhdHRyaWJ1dGVzKVswXTtcblxuICAgIGlmIChpbml0U2VnbWVudCkge1xuICAgICAgc2VnbWVudC5tYXAgPSBpbml0U2VnbWVudDtcbiAgICB9XG5cbiAgICBzZWdtZW50cy5wdXNoKHNlZ21lbnQpO1xuXG4gICAgaWYgKHR5cGVvZiBzdGFydEluZGV4ID09PSAnYmlnaW50Jykge1xuICAgICAgc3RhcnRJbmRleCArPSB3aW5kb3dfX2RlZmF1bHRbJ2RlZmF1bHQnXS5CaWdJbnQoc2l6ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXJ0SW5kZXggKz0gc2l6ZTtcbiAgICB9XG5cbiAgICBwcmVzZW50YXRpb25UaW1lICs9IGR1cmF0aW9uIC8gdGltZXNjYWxlO1xuICAgIG51bWJlcisrO1xuICB9XG5cbiAgcGxheWxpc3Quc2VnbWVudHMgPSBzZWdtZW50cztcbiAgcmV0dXJuIHBsYXlsaXN0O1xufTtcblxuY29uc3QgU1VQUE9SVEVEX01FRElBX1RZUEVTID0gWydBVURJTycsICdTVUJUSVRMRVMnXTsgLy8gYWxsb3cgb25lIDYwZnBzIGZyYW1lIGFzIGxlbmllbmN5IChhcmJpdHJhcmlseSBjaG9zZW4pXG5cbmNvbnN0IFRJTUVfRlVER0UgPSAxIC8gNjA7XG4vKipcbiAqIEdpdmVuIGEgbGlzdCBvZiB0aW1lbGluZVN0YXJ0cywgY29tYmluZXMsIGRlZHVwZXMsIGFuZCBzb3J0cyB0aGVtLlxuICpcbiAqIEBwYXJhbSB7VGltZWxpbmVTdGFydFtdfSB0aW1lbGluZVN0YXJ0cyAtIGxpc3Qgb2YgdGltZWxpbmUgc3RhcnRzXG4gKlxuICogQHJldHVybiB7VGltZWxpbmVTdGFydFtdfSB0aGUgY29tYmluZWQgYW5kIGRlZHVwZWQgdGltZWxpbmUgc3RhcnRzXG4gKi9cblxuY29uc3QgZ2V0VW5pcXVlVGltZWxpbmVTdGFydHMgPSB0aW1lbGluZVN0YXJ0cyA9PiB7XG4gIHJldHVybiB1bmlvbih0aW1lbGluZVN0YXJ0cywgKHtcbiAgICB0aW1lbGluZVxuICB9KSA9PiB0aW1lbGluZSkuc29ydCgoYSwgYikgPT4gYS50aW1lbGluZSA+IGIudGltZWxpbmUgPyAxIDogLTEpO1xufTtcbi8qKlxuICogRmluZHMgdGhlIHBsYXlsaXN0IHdpdGggdGhlIG1hdGNoaW5nIE5BTUUgYXR0cmlidXRlLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHBsYXlsaXN0cyAtIHBsYXlsaXN0cyB0byBzZWFyY2ggdGhyb3VnaFxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSB0aGUgTkFNRSBhdHRyaWJ1dGUgdG8gc2VhcmNoIGZvclxuICpcbiAqIEByZXR1cm4ge09iamVjdHxudWxsfSB0aGUgbWF0Y2hpbmcgcGxheWxpc3Qgb2JqZWN0LCBvciBudWxsXG4gKi9cblxuY29uc3QgZmluZFBsYXlsaXN0V2l0aE5hbWUgPSAocGxheWxpc3RzLCBuYW1lKSA9PiB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcGxheWxpc3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHBsYXlsaXN0c1tpXS5hdHRyaWJ1dGVzLk5BTUUgPT09IG5hbWUpIHtcbiAgICAgIHJldHVybiBwbGF5bGlzdHNbaV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59O1xuLyoqXG4gKiBHZXRzIGEgZmxhdHRlbmVkIGFycmF5IG9mIG1lZGlhIGdyb3VwIHBsYXlsaXN0cy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gbWFuaWZlc3QgLSB0aGUgbWFpbiBtYW5pZmVzdCBvYmplY3RcbiAqXG4gKiBAcmV0dXJuIHtBcnJheX0gdGhlIG1lZGlhIGdyb3VwIHBsYXlsaXN0c1xuICovXG5cbmNvbnN0IGdldE1lZGlhR3JvdXBQbGF5bGlzdHMgPSBtYW5pZmVzdCA9PiB7XG4gIGxldCBtZWRpYUdyb3VwUGxheWxpc3RzID0gW107XG4gIG1lZGlhR3JvdXBzLmZvckVhY2hNZWRpYUdyb3VwKG1hbmlmZXN0LCBTVVBQT1JURURfTUVESUFfVFlQRVMsIChwcm9wZXJ0aWVzLCB0eXBlLCBncm91cCwgbGFiZWwpID0+IHtcbiAgICBtZWRpYUdyb3VwUGxheWxpc3RzID0gbWVkaWFHcm91cFBsYXlsaXN0cy5jb25jYXQocHJvcGVydGllcy5wbGF5bGlzdHMgfHwgW10pO1xuICB9KTtcbiAgcmV0dXJuIG1lZGlhR3JvdXBQbGF5bGlzdHM7XG59O1xuLyoqXG4gKiBVcGRhdGVzIHRoZSBwbGF5bGlzdCdzIG1lZGlhIHNlcXVlbmNlIG51bWJlcnMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyAtIG9wdGlvbnMgb2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnLnBsYXlsaXN0IC0gdGhlIHBsYXlsaXN0IHRvIHVwZGF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IGNvbmZpZy5tZWRpYVNlcXVlbmNlIC0gdGhlIG1lZGlhU2VxdWVuY2UgbnVtYmVyIHRvIHN0YXJ0IHdpdGhcbiAqL1xuXG5jb25zdCB1cGRhdGVNZWRpYVNlcXVlbmNlRm9yUGxheWxpc3QgPSAoe1xuICBwbGF5bGlzdCxcbiAgbWVkaWFTZXF1ZW5jZVxufSkgPT4ge1xuICBwbGF5bGlzdC5tZWRpYVNlcXVlbmNlID0gbWVkaWFTZXF1ZW5jZTtcbiAgcGxheWxpc3Quc2VnbWVudHMuZm9yRWFjaCgoc2VnbWVudCwgaW5kZXgpID0+IHtcbiAgICBzZWdtZW50Lm51bWJlciA9IHBsYXlsaXN0Lm1lZGlhU2VxdWVuY2UgKyBpbmRleDtcbiAgfSk7XG59O1xuLyoqXG4gKiBVcGRhdGVzIHRoZSBtZWRpYSBhbmQgZGlzY29udGludWl0eSBzZXF1ZW5jZSBudW1iZXJzIG9mIG5ld1BsYXlsaXN0cyBnaXZlbiBvbGRQbGF5bGlzdHNcbiAqIGFuZCBhIGNvbXBsZXRlIGxpc3Qgb2YgdGltZWxpbmUgc3RhcnRzLlxuICpcbiAqIElmIG5vIG1hdGNoaW5nIHBsYXlsaXN0IGlzIGZvdW5kLCBvbmx5IHRoZSBkaXNjb250aW51aXR5IHNlcXVlbmNlIG51bWJlciBvZiB0aGUgcGxheWxpc3RcbiAqIHdpbGwgYmUgdXBkYXRlZC5cbiAqXG4gKiBTaW5jZSBlYXJseSBhdmFpbGFibGUgdGltZWxpbmVzIGFyZSBub3Qgc3VwcG9ydGVkLCBhdCBsZWFzdCBvbmUgc2VnbWVudCBtdXN0IGJlIHByZXNlbnQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyAtIG9wdGlvbnMgb2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdFtdfSBvbGRQbGF5bGlzdHMgLSB0aGUgb2xkIHBsYXlsaXN0cyB0byB1c2UgYXMgYSByZWZlcmVuY2VcbiAqIEBwYXJhbSB7T2JqZWN0W119IG5ld1BsYXlsaXN0cyAtIHRoZSBuZXcgcGxheWxpc3RzIHRvIHVwZGF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHRpbWVsaW5lU3RhcnRzIC0gYWxsIHRpbWVsaW5lU3RhcnRzIHNlZW4gaW4gdGhlIHN0cmVhbSB0byB0aGlzIHBvaW50XG4gKi9cblxuY29uc3QgdXBkYXRlU2VxdWVuY2VOdW1iZXJzID0gKHtcbiAgb2xkUGxheWxpc3RzLFxuICBuZXdQbGF5bGlzdHMsXG4gIHRpbWVsaW5lU3RhcnRzXG59KSA9PiB7XG4gIG5ld1BsYXlsaXN0cy5mb3JFYWNoKHBsYXlsaXN0ID0+IHtcbiAgICBwbGF5bGlzdC5kaXNjb250aW51aXR5U2VxdWVuY2UgPSB0aW1lbGluZVN0YXJ0cy5maW5kSW5kZXgoZnVuY3Rpb24gKHtcbiAgICAgIHRpbWVsaW5lXG4gICAgfSkge1xuICAgICAgcmV0dXJuIHRpbWVsaW5lID09PSBwbGF5bGlzdC50aW1lbGluZTtcbiAgICB9KTsgLy8gUGxheWxpc3RzIE5BTUVzIGNvbWUgZnJvbSBEQVNIIFJlcHJlc2VudGF0aW9uIElEcywgd2hpY2ggYXJlIG1hbmRhdG9yeVxuICAgIC8vIChzZWUgSVNPXzIzMDA5LTEtMjAxMiA1LjMuNS4yKS5cbiAgICAvL1xuICAgIC8vIElmIHRoZSBzYW1lIFJlcHJlc2VudGF0aW9uIGV4aXN0ZWQgaW4gYSBwcmlvciBQZXJpb2QsIGl0IHdpbGwgcmV0YWluIHRoZSBzYW1lIE5BTUUuXG5cbiAgICBjb25zdCBvbGRQbGF5bGlzdCA9IGZpbmRQbGF5bGlzdFdpdGhOYW1lKG9sZFBsYXlsaXN0cywgcGxheWxpc3QuYXR0cmlidXRlcy5OQU1FKTtcblxuICAgIGlmICghb2xkUGxheWxpc3QpIHtcbiAgICAgIC8vIFNpbmNlIHRoaXMgaXMgYSBuZXcgcGxheWxpc3QsIHRoZSBtZWRpYSBzZXF1ZW5jZSB2YWx1ZXMgY2FuIHN0YXJ0IGZyb20gMCB3aXRob3V0XG4gICAgICAvLyBjb25zZXF1ZW5jZS5cbiAgICAgIHJldHVybjtcbiAgICB9IC8vIFRPRE8gYmV0dGVyIHN1cHBvcnQgZm9yIGxpdmUgU0lEWFxuICAgIC8vXG4gICAgLy8gQXMgb2YgdGhpcyB3cml0aW5nLCBtcGQtcGFyc2VyIGRvZXMgbm90IHN1cHBvcnQgbXVsdGlwZXJpb2QgU0lEWCAoaW4gbGl2ZSBvciBWT0QpLlxuICAgIC8vIFRoaXMgaXMgZXZpZGVudCBieSBhIHBsYXlsaXN0IG9ubHkgaGF2aW5nIGEgc2luZ2xlIFNJRFggcmVmZXJlbmNlLiBJbiBhIG11bHRpcGVyaW9kXG4gICAgLy8gcGxheWxpc3QgdGhlcmUgd291bGQgbmVlZCB0byBiZSBtdWx0aXBsZSBTSURYIHJlZmVyZW5jZXMuIEluIGFkZGl0aW9uLCBsaXZlIFNJRFggaXNcbiAgICAvLyBub3Qgc3VwcG9ydGVkIHdoZW4gdGhlIFNJRFggcHJvcGVydGllcyBjaGFuZ2Ugb24gcmVmcmVzaGVzLlxuICAgIC8vXG4gICAgLy8gSW4gdGhlIGZ1dHVyZSwgaWYgc3VwcG9ydCBuZWVkcyB0byBiZSBhZGRlZCwgdGhlIG1lcmdpbmcgbG9naWMgaGVyZSBjYW4gYmUgY2FsbGVkXG4gICAgLy8gYWZ0ZXIgU0lEWCByZWZlcmVuY2VzIGFyZSByZXNvbHZlZC4gRm9yIG5vdywgZXhpdCBlYXJseSB0byBwcmV2ZW50IGV4Y2VwdGlvbnMgYmVpbmdcbiAgICAvLyB0aHJvd24gZHVlIHRvIHVuZGVmaW5lZCByZWZlcmVuY2VzLlxuXG5cbiAgICBpZiAocGxheWxpc3Quc2lkeCkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gU2luY2Ugd2UgZG9uJ3QgeWV0IHN1cHBvcnQgZWFybHkgYXZhaWxhYmxlIHRpbWVsaW5lcywgd2UgZG9uJ3QgbmVlZCB0byBzdXBwb3J0XG4gICAgLy8gcGxheWxpc3RzIHdpdGggbm8gc2VnbWVudHMuXG5cblxuICAgIGNvbnN0IGZpcnN0TmV3U2VnbWVudCA9IHBsYXlsaXN0LnNlZ21lbnRzWzBdO1xuICAgIGNvbnN0IG9sZE1hdGNoaW5nU2VnbWVudEluZGV4ID0gb2xkUGxheWxpc3Quc2VnbWVudHMuZmluZEluZGV4KGZ1bmN0aW9uIChvbGRTZWdtZW50KSB7XG4gICAgICByZXR1cm4gTWF0aC5hYnMob2xkU2VnbWVudC5wcmVzZW50YXRpb25UaW1lIC0gZmlyc3ROZXdTZWdtZW50LnByZXNlbnRhdGlvblRpbWUpIDwgVElNRV9GVURHRTtcbiAgICB9KTsgLy8gTm8gbWF0Y2hpbmcgc2VnbWVudCBmcm9tIHRoZSBvbGQgcGxheWxpc3QgbWVhbnMgdGhlIGVudGlyZSBwbGF5bGlzdCB3YXMgcmVmcmVzaGVkLlxuICAgIC8vIEluIHRoaXMgY2FzZSB0aGUgbWVkaWEgc2VxdWVuY2Ugc2hvdWxkIGFjY291bnQgZm9yIHRoaXMgdXBkYXRlLCBhbmQgdGhlIG5ldyBzZWdtZW50c1xuICAgIC8vIHNob3VsZCBiZSBtYXJrZWQgYXMgZGlzY29udGludW91cyBmcm9tIHRoZSBwcmlvciBjb250ZW50LCBzaW5jZSB0aGUgbGFzdCBwcmlvclxuICAgIC8vIHRpbWVsaW5lIHdhcyByZW1vdmVkLlxuXG4gICAgaWYgKG9sZE1hdGNoaW5nU2VnbWVudEluZGV4ID09PSAtMSkge1xuICAgICAgdXBkYXRlTWVkaWFTZXF1ZW5jZUZvclBsYXlsaXN0KHtcbiAgICAgICAgcGxheWxpc3QsXG4gICAgICAgIG1lZGlhU2VxdWVuY2U6IG9sZFBsYXlsaXN0Lm1lZGlhU2VxdWVuY2UgKyBvbGRQbGF5bGlzdC5zZWdtZW50cy5sZW5ndGhcbiAgICAgIH0pO1xuICAgICAgcGxheWxpc3Quc2VnbWVudHNbMF0uZGlzY29udGludWl0eSA9IHRydWU7XG4gICAgICBwbGF5bGlzdC5kaXNjb250aW51aXR5U3RhcnRzLnVuc2hpZnQoMCk7IC8vIE5vIG1hdGNoaW5nIHNlZ21lbnQgZG9lcyBub3QgbmVjZXNzYXJpbHkgbWVhbiB0aGVyZSdzIG1pc3NpbmcgY29udGVudC5cbiAgICAgIC8vXG4gICAgICAvLyBJZiB0aGUgbmV3IHBsYXlsaXN0J3MgdGltZWxpbmUgaXMgdGhlIHNhbWUgYXMgdGhlIGxhc3Qgc2VlbiBzZWdtZW50J3MgdGltZWxpbmUsXG4gICAgICAvLyB0aGVuIGEgZGlzY29udGludWl0eSBjYW4gYmUgYWRkZWQgdG8gaWRlbnRpZnkgdGhhdCB0aGVyZSdzIHBvdGVudGlhbGx5IG1pc3NpbmdcbiAgICAgIC8vIGNvbnRlbnQuIElmIHRoZXJlJ3Mgbm8gbWlzc2luZyBjb250ZW50LCB0aGUgZGlzY29udGludWl0eSBzaG91bGQgc3RpbGwgYmUgcmF0aGVyXG4gICAgICAvLyBoYXJtbGVzcy4gSXQncyBwb3NzaWJsZSB0aGF0IGlmIHNlZ21lbnQgZHVyYXRpb25zIGFyZSBhY2N1cmF0ZSBlbm91Z2gsIHRoYXQgdGhlXG4gICAgICAvLyBleGlzdGVuY2Ugb2YgYSBnYXAgY2FuIGJlIGRldGVybWluZWQgdXNpbmcgdGhlIHByZXNlbnRhdGlvbiB0aW1lcyBhbmQgZHVyYXRpb25zLFxuICAgICAgLy8gYnV0IGlmIHRoZSBzZWdtZW50IHRpbWluZyBpbmZvIGlzIG9mZiwgaXQgbWF5IGludHJvZHVjZSBtb3JlIHByb2JsZW1zIHRoYW4gc2ltcGx5XG4gICAgICAvLyBhZGRpbmcgdGhlIGRpc2NvbnRpbnVpdHkuXG4gICAgICAvL1xuICAgICAgLy8gSWYgdGhlIG5ldyBwbGF5bGlzdCdzIHRpbWVsaW5lIGlzIGRpZmZlcmVudCBmcm9tIHRoZSBsYXN0IHNlZW4gc2VnbWVudCdzIHRpbWVsaW5lLFxuICAgICAgLy8gdGhlbiBhIGRpc2NvbnRpbnVpdHkgY2FuIGJlIGFkZGVkIHRvIGlkZW50aWZ5IHRoYXQgdGhpcyBpcyB0aGUgZmlyc3Qgc2VlbiBzZWdtZW50XG4gICAgICAvLyBvZiBhIG5ldyB0aW1lbGluZS4gSG93ZXZlciwgdGhlIGxvZ2ljIGF0IHRoZSBzdGFydCBvZiB0aGlzIGZ1bmN0aW9uIHRoYXRcbiAgICAgIC8vIGRldGVybWluZWQgdGhlIGRpc2NvbmludWl0eSBzZXF1ZW5jZSBieSB0aW1lbGluZSBpbmRleCBpcyBub3cgb2ZmIGJ5IG9uZSAodGhlXG4gICAgICAvLyBkaXNjb250aW51aXR5IG9mIHRoZSBuZXdlc3QgdGltZWxpbmUgaGFzbid0IHlldCBmYWxsZW4gb2ZmIHRoZSBtYW5pZmVzdC4uLnNpbmNlXG4gICAgICAvLyB3ZSBhZGRlZCBpdCksIHNvIHRoZSBkaXNjb25pbnVpdHkgc2VxdWVuY2UgbXVzdCBiZSBkZWNyZW1lbnRlZC5cbiAgICAgIC8vXG4gICAgICAvLyBBIHBlcmlvZCBtYXkgYWxzbyBoYXZlIGEgZHVyYXRpb24gb2YgemVybywgc28gdGhlIGNhc2Ugb2Ygbm8gc2VnbWVudHMgaXMgaGFuZGxlZFxuICAgICAgLy8gaGVyZSBldmVuIHRob3VnaCB3ZSBkb24ndCB5ZXQgc3VwcG9ydCBlYXJseSBhdmFpbGFibGUgcGVyaW9kcy5cblxuICAgICAgaWYgKCFvbGRQbGF5bGlzdC5zZWdtZW50cy5sZW5ndGggJiYgcGxheWxpc3QudGltZWxpbmUgPiBvbGRQbGF5bGlzdC50aW1lbGluZSB8fCBvbGRQbGF5bGlzdC5zZWdtZW50cy5sZW5ndGggJiYgcGxheWxpc3QudGltZWxpbmUgPiBvbGRQbGF5bGlzdC5zZWdtZW50c1tvbGRQbGF5bGlzdC5zZWdtZW50cy5sZW5ndGggLSAxXS50aW1lbGluZSkge1xuICAgICAgICBwbGF5bGlzdC5kaXNjb250aW51aXR5U2VxdWVuY2UtLTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gSWYgdGhlIGZpcnN0IHNlZ21lbnQgbWF0Y2hlZCB3aXRoIGEgcHJpb3Igc2VnbWVudCBvbiBhIGRpc2NvbnRpbnVpdHkgKGl0J3MgbWF0Y2hpbmdcbiAgICAvLyBvbiB0aGUgZmlyc3Qgc2VnbWVudCBvZiBhIHBlcmlvZCksIHRoZW4gdGhlIGRpc2NvbnRpbnVpdHlTZXF1ZW5jZSBzaG91bGRuJ3QgYmUgdGhlXG4gICAgLy8gdGltZWxpbmUncyBtYXRjaGluZyBvbmUsIGJ1dCBpbnN0ZWFkIHNob3VsZCBiZSB0aGUgb25lIHByaW9yLCBhbmQgdGhlIGZpcnN0IHNlZ21lbnRcbiAgICAvLyBvZiB0aGUgbmV3IG1hbmlmZXN0IHNob3VsZCBiZSBtYXJrZWQgd2l0aCBhIGRpc2NvbnRpbnVpdHkuXG4gICAgLy9cbiAgICAvLyBUaGUgcmVhc29uIGZvciB0aGlzIHNwZWNpYWwgY2FzZSBpcyB0aGF0IGRpc2NvbnRpbnVpdHkgc2VxdWVuY2Ugc2hvd3MgaG93IG1hbnlcbiAgICAvLyBkaXNjb250aW51aXRpZXMgaGF2ZSBmYWxsZW4gb2ZmIG9mIHRoZSBwbGF5bGlzdCwgYW5kIGRpc2NvbnRpbnVpdGllcyBhcmUgbWFya2VkIG9uXG4gICAgLy8gdGhlIGZpcnN0IHNlZ21lbnQgb2YgYSBuZXcgXCJ0aW1lbGluZS5cIiBCZWNhdXNlIG9mIHRoaXMsIHdoaWxlIERBU0ggd2lsbCByZXRhaW4gdGhhdFxuICAgIC8vIFBlcmlvZCB3aGlsZSB0aGUgXCJ0aW1lbGluZVwiIGV4aXN0cywgSExTIGtlZXBzIHRyYWNrIG9mIGl0IHZpYSB0aGUgZGlzY29udGludWl0eVxuICAgIC8vIHNlcXVlbmNlLCBhbmQgdGhhdCBmaXJzdCBzZWdtZW50IGlzIGFuIGluZGljYXRvciwgYnV0IGNhbiBiZSByZW1vdmVkIGJlZm9yZSB0aGF0XG4gICAgLy8gdGltZWxpbmUgaXMgZ29uZS5cblxuXG4gICAgY29uc3Qgb2xkTWF0Y2hpbmdTZWdtZW50ID0gb2xkUGxheWxpc3Quc2VnbWVudHNbb2xkTWF0Y2hpbmdTZWdtZW50SW5kZXhdO1xuXG4gICAgaWYgKG9sZE1hdGNoaW5nU2VnbWVudC5kaXNjb250aW51aXR5ICYmICFmaXJzdE5ld1NlZ21lbnQuZGlzY29udGludWl0eSkge1xuICAgICAgZmlyc3ROZXdTZWdtZW50LmRpc2NvbnRpbnVpdHkgPSB0cnVlO1xuICAgICAgcGxheWxpc3QuZGlzY29udGludWl0eVN0YXJ0cy51bnNoaWZ0KDApO1xuICAgICAgcGxheWxpc3QuZGlzY29udGludWl0eVNlcXVlbmNlLS07XG4gICAgfVxuXG4gICAgdXBkYXRlTWVkaWFTZXF1ZW5jZUZvclBsYXlsaXN0KHtcbiAgICAgIHBsYXlsaXN0LFxuICAgICAgbWVkaWFTZXF1ZW5jZTogb2xkUGxheWxpc3Quc2VnbWVudHNbb2xkTWF0Y2hpbmdTZWdtZW50SW5kZXhdLm51bWJlclxuICAgIH0pO1xuICB9KTtcbn07XG4vKipcbiAqIEdpdmVuIGFuIG9sZCBwYXJzZWQgbWFuaWZlc3Qgb2JqZWN0IGFuZCBhIG5ldyBwYXJzZWQgbWFuaWZlc3Qgb2JqZWN0LCB1cGRhdGVzIHRoZVxuICogc2VxdWVuY2UgYW5kIHRpbWluZyB2YWx1ZXMgd2l0aGluIHRoZSBuZXcgbWFuaWZlc3QgdG8gZW5zdXJlIHRoYXQgaXQgbGluZXMgdXAgd2l0aCB0aGVcbiAqIG9sZC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBvbGRNYW5pZmVzdCAtIHRoZSBvbGQgbWFpbiBtYW5pZmVzdCBvYmplY3RcbiAqIEBwYXJhbSB7QXJyYXl9IG5ld01hbmlmZXN0IC0gdGhlIG5ldyBtYWluIG1hbmlmZXN0IG9iamVjdFxuICpcbiAqIEByZXR1cm4ge09iamVjdH0gdGhlIHVwZGF0ZWQgbmV3IG1hbmlmZXN0IG9iamVjdFxuICovXG5cbmNvbnN0IHBvc2l0aW9uTWFuaWZlc3RPblRpbWVsaW5lID0gKHtcbiAgb2xkTWFuaWZlc3QsXG4gIG5ld01hbmlmZXN0XG59KSA9PiB7XG4gIC8vIFN0YXJ0aW5nIGZyb20gdjQuMS4yIG9mIHRoZSBJT1AsIHNlY3Rpb24gNC40LjMuMyBzdGF0ZXM6XG4gIC8vXG4gIC8vIFwiTVBEQGF2YWlsYWJpbGl0eVN0YXJ0VGltZSBhbmQgUGVyaW9kQHN0YXJ0IHNoYWxsIG5vdCBiZSBjaGFuZ2VkIG92ZXIgTVBEIHVwZGF0ZXMuXCJcbiAgLy9cbiAgLy8gVGhpcyB3YXMgYWRkZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vRGFzaC1JbmR1c3RyeS1Gb3J1bS9EQVNILUlGLUlPUC9pc3N1ZXMvMTYwXG4gIC8vXG4gIC8vIEJlY2F1c2Ugb2YgdGhpcyBjaGFuZ2UsIGFuZCB0aGUgZGlmZmljdWx0eSBvZiBzdXBwb3J0aW5nIHBlcmlvZHMgd2l0aCBjaGFuZ2luZyBzdGFydFxuICAvLyB0aW1lcywgcGVyaW9kcyB3aXRoIGNoYW5naW5nIHN0YXJ0IHRpbWVzIGFyZSBub3Qgc3VwcG9ydGVkLiBUaGlzIG1ha2VzIHRoZSBsb2dpYyBtdWNoXG4gIC8vIHNpbXBsZXIsIHNpbmNlIHBlcmlvZHMgd2l0aCB0aGUgc2FtZSBzdGFydCB0aW1lIGNhbiBiZSBjb25zaWRlcnJlZCB0aGUgc2FtZSBwZXJpb2RcbiAgLy8gYWNyb3NzIHJlZnJlc2hlcy5cbiAgLy9cbiAgLy8gVG8gZ2l2ZSBhbiBleGFtcGxlIGFzIHRvIHRoZSBkaWZmaWN1bHR5IG9mIGhhbmRsaW5nIHBlcmlvZHMgd2hlcmUgdGhlIHN0YXJ0IHRpbWUgbWF5XG4gIC8vIGNoYW5nZSwgaWYgYSBzaW5nbGUgcGVyaW9kIG1hbmlmZXN0IGlzIHJlZnJlc2hlZCB3aXRoIGFub3RoZXIgbWFuaWZlc3Qgd2l0aCBhIHNpbmdsZVxuICAvLyBwZXJpb2QsIGFuZCBib3RoIHRoZSBzdGFydCBhbmQgZW5kIHRpbWVzIGFyZSBpbmNyZWFzZWQsIHRoZW4gdGhlIG9ubHkgd2F5IHRvIGRldGVybWluZVxuICAvLyBpZiBpdCdzIGEgbmV3IHBlcmlvZCBvciBhbiBvbGQgb25lIHRoYXQgaGFzIGNoYW5nZWQgaXMgdG8gbG9vayB0aHJvdWdoIHRoZSBzZWdtZW50cyBvZlxuICAvLyBlYWNoIHBsYXlsaXN0IGFuZCBkZXRlcm1pbmUgdGhlIHByZXNlbnRhdGlvbiB0aW1lIGJvdW5kcyB0byBmaW5kIGEgbWF0Y2guIEluIGFkZGl0aW9uLFxuICAvLyBpZiB0aGUgcGVyaW9kIHN0YXJ0IGNoYW5nZWQgdG8gZXhjZWVkIHRoZSBvbGQgcGVyaW9kIGVuZCwgdGhlbiB0aGVyZSB3b3VsZCBiZSBub1xuICAvLyBtYXRjaCwgYW5kIGl0IHdvdWxkIG5vdCBiZSBwb3NzaWJsZSB0byBkZXRlcm1pbmUgd2hldGhlciB0aGUgcmVmcmVzaGVkIHBlcmlvZCBpcyBhIG5ld1xuICAvLyBvbmUgb3IgdGhlIG9sZCBvbmUuXG4gIGNvbnN0IG9sZFBsYXlsaXN0cyA9IG9sZE1hbmlmZXN0LnBsYXlsaXN0cy5jb25jYXQoZ2V0TWVkaWFHcm91cFBsYXlsaXN0cyhvbGRNYW5pZmVzdCkpO1xuICBjb25zdCBuZXdQbGF5bGlzdHMgPSBuZXdNYW5pZmVzdC5wbGF5bGlzdHMuY29uY2F0KGdldE1lZGlhR3JvdXBQbGF5bGlzdHMobmV3TWFuaWZlc3QpKTsgLy8gU2F2ZSBhbGwgc2VlbiB0aW1lbGluZVN0YXJ0cyB0byB0aGUgbmV3IG1hbmlmZXN0LiBBbHRob3VnaCB0aGlzIHBvdGVudGlhbGx5IG1lYW5zIHRoYXRcbiAgLy8gdGhlcmUncyBhIFwibWVtb3J5IGxlYWtcIiBpbiB0aGF0IGl0IHdpbGwgbmV2ZXIgc3RvcCBncm93aW5nLCBpbiByZWFsaXR5LCBvbmx5IGEgY291cGxlXG4gIC8vIG9mIHByb3BlcnRpZXMgYXJlIHNhdmVkIGZvciBlYWNoIHNlZW4gUGVyaW9kLiBFdmVuIGxvbmcgcnVubmluZyBsaXZlIHN0cmVhbXMgd29uJ3RcbiAgLy8gZ2VuZXJhdGUgdG9vIG1hbnkgUGVyaW9kcywgdW5sZXNzIHRoZSBzdHJlYW0gaXMgd2F0Y2hlZCBmb3IgZGVjYWRlcy4gSW4gdGhlIGZ1dHVyZSxcbiAgLy8gdGhpcyBjYW4gYmUgb3B0aW1pemVkIGJ5IG1hcHBpbmcgdG8gZGlzY29udGludWl0eSBzZXF1ZW5jZSBudW1iZXJzIGZvciBlYWNoIHRpbWVsaW5lLFxuICAvLyBidXQgaXQgbWF5IG5vdCBiZWNvbWUgYW4gaXNzdWUsIGFuZCB0aGUgYWRkaXRpb25hbCBpbmZvIGNhbiBiZSB1c2VmdWwgZm9yIGRlYnVnZ2luZy5cblxuICBuZXdNYW5pZmVzdC50aW1lbGluZVN0YXJ0cyA9IGdldFVuaXF1ZVRpbWVsaW5lU3RhcnRzKFtvbGRNYW5pZmVzdC50aW1lbGluZVN0YXJ0cywgbmV3TWFuaWZlc3QudGltZWxpbmVTdGFydHNdKTtcbiAgdXBkYXRlU2VxdWVuY2VOdW1iZXJzKHtcbiAgICBvbGRQbGF5bGlzdHMsXG4gICAgbmV3UGxheWxpc3RzLFxuICAgIHRpbWVsaW5lU3RhcnRzOiBuZXdNYW5pZmVzdC50aW1lbGluZVN0YXJ0c1xuICB9KTtcbiAgcmV0dXJuIG5ld01hbmlmZXN0O1xufTtcblxuY29uc3QgZ2VuZXJhdGVTaWR4S2V5ID0gc2lkeCA9PiBzaWR4ICYmIHNpZHgudXJpICsgJy0nICsgYnl0ZVJhbmdlVG9TdHJpbmcoc2lkeC5ieXRlcmFuZ2UpO1xuXG5jb25zdCBtZXJnZURpc2NvbnRpZ3VvdXNQbGF5bGlzdHMgPSBwbGF5bGlzdHMgPT4ge1xuICAvLyBCcmVhayBvdXQgcGxheWxpc3RzIGludG8gZ3JvdXBzIGJhc2VkIG9uIHRoZWlyIGJhc2VVcmxcbiAgY29uc3QgcGxheWxpc3RzQnlCYXNlVXJsID0gcGxheWxpc3RzLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBjdXIpIHtcbiAgICBpZiAoIWFjY1tjdXIuYXR0cmlidXRlcy5iYXNlVXJsXSkge1xuICAgICAgYWNjW2N1ci5hdHRyaWJ1dGVzLmJhc2VVcmxdID0gW107XG4gICAgfVxuXG4gICAgYWNjW2N1ci5hdHRyaWJ1dGVzLmJhc2VVcmxdLnB1c2goY3VyKTtcbiAgICByZXR1cm4gYWNjO1xuICB9LCB7fSk7XG4gIGxldCBhbGxQbGF5bGlzdHMgPSBbXTtcbiAgT2JqZWN0LnZhbHVlcyhwbGF5bGlzdHNCeUJhc2VVcmwpLmZvckVhY2gocGxheWxpc3RHcm91cCA9PiB7XG4gICAgY29uc3QgbWVyZ2VkUGxheWxpc3RzID0gdmFsdWVzKHBsYXlsaXN0R3JvdXAucmVkdWNlKChhY2MsIHBsYXlsaXN0KSA9PiB7XG4gICAgICAvLyBhc3N1bWluZyBwbGF5bGlzdCBJRHMgYXJlIHRoZSBzYW1lIGFjcm9zcyBwZXJpb2RzXG4gICAgICAvLyBUT0RPOiBoYW5kbGUgbXVsdGlwZXJpb2Qgd2hlcmUgcmVwcmVzZW50YXRpb24gc2V0cyBhcmUgbm90IHRoZSBzYW1lXG4gICAgICAvLyBhY3Jvc3MgcGVyaW9kc1xuICAgICAgY29uc3QgbmFtZSA9IHBsYXlsaXN0LmF0dHJpYnV0ZXMuaWQgKyAocGxheWxpc3QuYXR0cmlidXRlcy5sYW5nIHx8ICcnKTtcblxuICAgICAgaWYgKCFhY2NbbmFtZV0pIHtcbiAgICAgICAgLy8gRmlyc3QgUGVyaW9kXG4gICAgICAgIGFjY1tuYW1lXSA9IHBsYXlsaXN0O1xuICAgICAgICBhY2NbbmFtZV0uYXR0cmlidXRlcy50aW1lbGluZVN0YXJ0cyA9IFtdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gU3Vic2VxdWVudCBQZXJpb2RzXG4gICAgICAgIGlmIChwbGF5bGlzdC5zZWdtZW50cykge1xuICAgICAgICAgIC8vIGZpcnN0IHNlZ21lbnQgb2Ygc3Vic2VxdWVudCBwZXJpb2RzIHNpZ25hbCBhIGRpc2NvbnRpbnVpdHlcbiAgICAgICAgICBpZiAocGxheWxpc3Quc2VnbWVudHNbMF0pIHtcbiAgICAgICAgICAgIHBsYXlsaXN0LnNlZ21lbnRzWzBdLmRpc2NvbnRpbnVpdHkgPSB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGFjY1tuYW1lXS5zZWdtZW50cy5wdXNoKC4uLnBsYXlsaXN0LnNlZ21lbnRzKTtcbiAgICAgICAgfSAvLyBidWJibGUgdXAgY29udGVudFByb3RlY3Rpb24sIHRoaXMgYXNzdW1lcyBhbGwgRFJNIGNvbnRlbnRcbiAgICAgICAgLy8gaGFzIHRoZSBzYW1lIGNvbnRlbnRQcm90ZWN0aW9uXG5cblxuICAgICAgICBpZiAocGxheWxpc3QuYXR0cmlidXRlcy5jb250ZW50UHJvdGVjdGlvbikge1xuICAgICAgICAgIGFjY1tuYW1lXS5hdHRyaWJ1dGVzLmNvbnRlbnRQcm90ZWN0aW9uID0gcGxheWxpc3QuYXR0cmlidXRlcy5jb250ZW50UHJvdGVjdGlvbjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBhY2NbbmFtZV0uYXR0cmlidXRlcy50aW1lbGluZVN0YXJ0cy5wdXNoKHtcbiAgICAgICAgLy8gQWx0aG91Z2ggdGhleSByZXByZXNlbnQgdGhlIHNhbWUgbnVtYmVyLCBpdCdzIGltcG9ydGFudCB0byBoYXZlIGJvdGggdG8gbWFrZSBpdFxuICAgICAgICAvLyBjb21wYXRpYmxlIHdpdGggSExTIHBvdGVudGlhbGx5IGhhdmluZyBhIHNpbWlsYXIgYXR0cmlidXRlLlxuICAgICAgICBzdGFydDogcGxheWxpc3QuYXR0cmlidXRlcy5wZXJpb2RTdGFydCxcbiAgICAgICAgdGltZWxpbmU6IHBsYXlsaXN0LmF0dHJpYnV0ZXMucGVyaW9kU3RhcnRcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCB7fSkpO1xuICAgIGFsbFBsYXlsaXN0cyA9IGFsbFBsYXlsaXN0cy5jb25jYXQobWVyZ2VkUGxheWxpc3RzKTtcbiAgfSk7XG4gIHJldHVybiBhbGxQbGF5bGlzdHMubWFwKHBsYXlsaXN0ID0+IHtcbiAgICBwbGF5bGlzdC5kaXNjb250aW51aXR5U3RhcnRzID0gZmluZEluZGV4ZXMocGxheWxpc3Quc2VnbWVudHMgfHwgW10sICdkaXNjb250aW51aXR5Jyk7XG4gICAgcmV0dXJuIHBsYXlsaXN0O1xuICB9KTtcbn07XG5cbmNvbnN0IGFkZFNpZHhTZWdtZW50c1RvUGxheWxpc3QgPSAocGxheWxpc3QsIHNpZHhNYXBwaW5nKSA9PiB7XG4gIGNvbnN0IHNpZHhLZXkgPSBnZW5lcmF0ZVNpZHhLZXkocGxheWxpc3Quc2lkeCk7XG4gIGNvbnN0IHNpZHhNYXRjaCA9IHNpZHhLZXkgJiYgc2lkeE1hcHBpbmdbc2lkeEtleV0gJiYgc2lkeE1hcHBpbmdbc2lkeEtleV0uc2lkeDtcblxuICBpZiAoc2lkeE1hdGNoKSB7XG4gICAgYWRkU2lkeFNlZ21lbnRzVG9QbGF5bGlzdCQxKHBsYXlsaXN0LCBzaWR4TWF0Y2gsIHBsYXlsaXN0LnNpZHgucmVzb2x2ZWRVcmkpO1xuICB9XG5cbiAgcmV0dXJuIHBsYXlsaXN0O1xufTtcbmNvbnN0IGFkZFNpZHhTZWdtZW50c1RvUGxheWxpc3RzID0gKHBsYXlsaXN0cywgc2lkeE1hcHBpbmcgPSB7fSkgPT4ge1xuICBpZiAoIU9iamVjdC5rZXlzKHNpZHhNYXBwaW5nKS5sZW5ndGgpIHtcbiAgICByZXR1cm4gcGxheWxpc3RzO1xuICB9XG5cbiAgZm9yIChjb25zdCBpIGluIHBsYXlsaXN0cykge1xuICAgIHBsYXlsaXN0c1tpXSA9IGFkZFNpZHhTZWdtZW50c1RvUGxheWxpc3QocGxheWxpc3RzW2ldLCBzaWR4TWFwcGluZyk7XG4gIH1cblxuICByZXR1cm4gcGxheWxpc3RzO1xufTtcbmNvbnN0IGZvcm1hdEF1ZGlvUGxheWxpc3QgPSAoe1xuICBhdHRyaWJ1dGVzLFxuICBzZWdtZW50cyxcbiAgc2lkeCxcbiAgbWVkaWFTZXF1ZW5jZSxcbiAgZGlzY29udGludWl0eVNlcXVlbmNlLFxuICBkaXNjb250aW51aXR5U3RhcnRzXG59LCBpc0F1ZGlvT25seSkgPT4ge1xuICBjb25zdCBwbGF5bGlzdCA9IHtcbiAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICBOQU1FOiBhdHRyaWJ1dGVzLmlkLFxuICAgICAgQkFORFdJRFRIOiBhdHRyaWJ1dGVzLmJhbmR3aWR0aCxcbiAgICAgIENPREVDUzogYXR0cmlidXRlcy5jb2RlY3MsXG4gICAgICBbJ1BST0dSQU0tSUQnXTogMVxuICAgIH0sXG4gICAgdXJpOiAnJyxcbiAgICBlbmRMaXN0OiBhdHRyaWJ1dGVzLnR5cGUgPT09ICdzdGF0aWMnLFxuICAgIHRpbWVsaW5lOiBhdHRyaWJ1dGVzLnBlcmlvZFN0YXJ0LFxuICAgIHJlc29sdmVkVXJpOiBhdHRyaWJ1dGVzLmJhc2VVcmwgfHwgJycsXG4gICAgdGFyZ2V0RHVyYXRpb246IGF0dHJpYnV0ZXMuZHVyYXRpb24sXG4gICAgZGlzY29udGludWl0eVNlcXVlbmNlLFxuICAgIGRpc2NvbnRpbnVpdHlTdGFydHMsXG4gICAgdGltZWxpbmVTdGFydHM6IGF0dHJpYnV0ZXMudGltZWxpbmVTdGFydHMsXG4gICAgbWVkaWFTZXF1ZW5jZSxcbiAgICBzZWdtZW50c1xuICB9O1xuXG4gIGlmIChhdHRyaWJ1dGVzLmNvbnRlbnRQcm90ZWN0aW9uKSB7XG4gICAgcGxheWxpc3QuY29udGVudFByb3RlY3Rpb24gPSBhdHRyaWJ1dGVzLmNvbnRlbnRQcm90ZWN0aW9uO1xuICB9XG5cbiAgaWYgKGF0dHJpYnV0ZXMuc2VydmljZUxvY2F0aW9uKSB7XG4gICAgcGxheWxpc3QuYXR0cmlidXRlcy5zZXJ2aWNlTG9jYXRpb24gPSBhdHRyaWJ1dGVzLnNlcnZpY2VMb2NhdGlvbjtcbiAgfVxuXG4gIGlmIChzaWR4KSB7XG4gICAgcGxheWxpc3Quc2lkeCA9IHNpZHg7XG4gIH1cblxuICBpZiAoaXNBdWRpb09ubHkpIHtcbiAgICBwbGF5bGlzdC5hdHRyaWJ1dGVzLkFVRElPID0gJ2F1ZGlvJztcbiAgICBwbGF5bGlzdC5hdHRyaWJ1dGVzLlNVQlRJVExFUyA9ICdzdWJzJztcbiAgfVxuXG4gIHJldHVybiBwbGF5bGlzdDtcbn07XG5jb25zdCBmb3JtYXRWdHRQbGF5bGlzdCA9ICh7XG4gIGF0dHJpYnV0ZXMsXG4gIHNlZ21lbnRzLFxuICBtZWRpYVNlcXVlbmNlLFxuICBkaXNjb250aW51aXR5U3RhcnRzLFxuICBkaXNjb250aW51aXR5U2VxdWVuY2Vcbn0pID0+IHtcbiAgaWYgKHR5cGVvZiBzZWdtZW50cyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAvLyB2dHQgdHJhY2tzIG1heSB1c2Ugc2luZ2xlIGZpbGUgaW4gQmFzZVVSTFxuICAgIHNlZ21lbnRzID0gW3tcbiAgICAgIHVyaTogYXR0cmlidXRlcy5iYXNlVXJsLFxuICAgICAgdGltZWxpbmU6IGF0dHJpYnV0ZXMucGVyaW9kU3RhcnQsXG4gICAgICByZXNvbHZlZFVyaTogYXR0cmlidXRlcy5iYXNlVXJsIHx8ICcnLFxuICAgICAgZHVyYXRpb246IGF0dHJpYnV0ZXMuc291cmNlRHVyYXRpb24sXG4gICAgICBudW1iZXI6IDBcbiAgICB9XTsgLy8gdGFyZ2V0RHVyYXRpb24gc2hvdWxkIGJlIHRoZSBzYW1lIGR1cmF0aW9uIGFzIHRoZSBvbmx5IHNlZ21lbnRcblxuICAgIGF0dHJpYnV0ZXMuZHVyYXRpb24gPSBhdHRyaWJ1dGVzLnNvdXJjZUR1cmF0aW9uO1xuICB9XG5cbiAgY29uc3QgbTN1OEF0dHJpYnV0ZXMgPSB7XG4gICAgTkFNRTogYXR0cmlidXRlcy5pZCxcbiAgICBCQU5EV0lEVEg6IGF0dHJpYnV0ZXMuYmFuZHdpZHRoLFxuICAgIFsnUFJPR1JBTS1JRCddOiAxXG4gIH07XG5cbiAgaWYgKGF0dHJpYnV0ZXMuY29kZWNzKSB7XG4gICAgbTN1OEF0dHJpYnV0ZXMuQ09ERUNTID0gYXR0cmlidXRlcy5jb2RlY3M7XG4gIH1cblxuICBjb25zdCB2dHRQbGF5bGlzdCA9IHtcbiAgICBhdHRyaWJ1dGVzOiBtM3U4QXR0cmlidXRlcyxcbiAgICB1cmk6ICcnLFxuICAgIGVuZExpc3Q6IGF0dHJpYnV0ZXMudHlwZSA9PT0gJ3N0YXRpYycsXG4gICAgdGltZWxpbmU6IGF0dHJpYnV0ZXMucGVyaW9kU3RhcnQsXG4gICAgcmVzb2x2ZWRVcmk6IGF0dHJpYnV0ZXMuYmFzZVVybCB8fCAnJyxcbiAgICB0YXJnZXREdXJhdGlvbjogYXR0cmlidXRlcy5kdXJhdGlvbixcbiAgICB0aW1lbGluZVN0YXJ0czogYXR0cmlidXRlcy50aW1lbGluZVN0YXJ0cyxcbiAgICBkaXNjb250aW51aXR5U3RhcnRzLFxuICAgIGRpc2NvbnRpbnVpdHlTZXF1ZW5jZSxcbiAgICBtZWRpYVNlcXVlbmNlLFxuICAgIHNlZ21lbnRzXG4gIH07XG5cbiAgaWYgKGF0dHJpYnV0ZXMuc2VydmljZUxvY2F0aW9uKSB7XG4gICAgdnR0UGxheWxpc3QuYXR0cmlidXRlcy5zZXJ2aWNlTG9jYXRpb24gPSBhdHRyaWJ1dGVzLnNlcnZpY2VMb2NhdGlvbjtcbiAgfVxuXG4gIHJldHVybiB2dHRQbGF5bGlzdDtcbn07XG5jb25zdCBvcmdhbml6ZUF1ZGlvUGxheWxpc3RzID0gKHBsYXlsaXN0cywgc2lkeE1hcHBpbmcgPSB7fSwgaXNBdWRpb09ubHkgPSBmYWxzZSkgPT4ge1xuICBsZXQgbWFpblBsYXlsaXN0O1xuICBjb25zdCBmb3JtYXR0ZWRQbGF5bGlzdHMgPSBwbGF5bGlzdHMucmVkdWNlKChhLCBwbGF5bGlzdCkgPT4ge1xuICAgIGNvbnN0IHJvbGUgPSBwbGF5bGlzdC5hdHRyaWJ1dGVzLnJvbGUgJiYgcGxheWxpc3QuYXR0cmlidXRlcy5yb2xlLnZhbHVlIHx8ICcnO1xuICAgIGNvbnN0IGxhbmd1YWdlID0gcGxheWxpc3QuYXR0cmlidXRlcy5sYW5nIHx8ICcnO1xuICAgIGxldCBsYWJlbCA9IHBsYXlsaXN0LmF0dHJpYnV0ZXMubGFiZWwgfHwgJ21haW4nO1xuXG4gICAgaWYgKGxhbmd1YWdlICYmICFwbGF5bGlzdC5hdHRyaWJ1dGVzLmxhYmVsKSB7XG4gICAgICBjb25zdCByb2xlTGFiZWwgPSByb2xlID8gYCAoJHtyb2xlfSlgIDogJyc7XG4gICAgICBsYWJlbCA9IGAke3BsYXlsaXN0LmF0dHJpYnV0ZXMubGFuZ30ke3JvbGVMYWJlbH1gO1xuICAgIH1cblxuICAgIGlmICghYVtsYWJlbF0pIHtcbiAgICAgIGFbbGFiZWxdID0ge1xuICAgICAgICBsYW5ndWFnZSxcbiAgICAgICAgYXV0b3NlbGVjdDogdHJ1ZSxcbiAgICAgICAgZGVmYXVsdDogcm9sZSA9PT0gJ21haW4nLFxuICAgICAgICBwbGF5bGlzdHM6IFtdLFxuICAgICAgICB1cmk6ICcnXG4gICAgICB9O1xuICAgIH1cblxuICAgIGNvbnN0IGZvcm1hdHRlZCA9IGFkZFNpZHhTZWdtZW50c1RvUGxheWxpc3QoZm9ybWF0QXVkaW9QbGF5bGlzdChwbGF5bGlzdCwgaXNBdWRpb09ubHkpLCBzaWR4TWFwcGluZyk7XG4gICAgYVtsYWJlbF0ucGxheWxpc3RzLnB1c2goZm9ybWF0dGVkKTtcblxuICAgIGlmICh0eXBlb2YgbWFpblBsYXlsaXN0ID09PSAndW5kZWZpbmVkJyAmJiByb2xlID09PSAnbWFpbicpIHtcbiAgICAgIG1haW5QbGF5bGlzdCA9IHBsYXlsaXN0O1xuICAgICAgbWFpblBsYXlsaXN0LmRlZmF1bHQgPSB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBhO1xuICB9LCB7fSk7IC8vIGlmIG5vIHBsYXlsaXN0cyBoYXZlIHJvbGUgXCJtYWluXCIsIG1hcmsgdGhlIGZpcnN0IGFzIG1haW5cblxuICBpZiAoIW1haW5QbGF5bGlzdCkge1xuICAgIGNvbnN0IGZpcnN0TGFiZWwgPSBPYmplY3Qua2V5cyhmb3JtYXR0ZWRQbGF5bGlzdHMpWzBdO1xuICAgIGZvcm1hdHRlZFBsYXlsaXN0c1tmaXJzdExhYmVsXS5kZWZhdWx0ID0gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmb3JtYXR0ZWRQbGF5bGlzdHM7XG59O1xuY29uc3Qgb3JnYW5pemVWdHRQbGF5bGlzdHMgPSAocGxheWxpc3RzLCBzaWR4TWFwcGluZyA9IHt9KSA9PiB7XG4gIHJldHVybiBwbGF5bGlzdHMucmVkdWNlKChhLCBwbGF5bGlzdCkgPT4ge1xuICAgIGNvbnN0IGxhYmVsID0gcGxheWxpc3QuYXR0cmlidXRlcy5sYWJlbCB8fCBwbGF5bGlzdC5hdHRyaWJ1dGVzLmxhbmcgfHwgJ3RleHQnO1xuICAgIGNvbnN0IGxhbmd1YWdlID0gcGxheWxpc3QuYXR0cmlidXRlcy5sYW5nIHx8ICd1bmQnO1xuXG4gICAgaWYgKCFhW2xhYmVsXSkge1xuICAgICAgYVtsYWJlbF0gPSB7XG4gICAgICAgIGxhbmd1YWdlLFxuICAgICAgICBkZWZhdWx0OiBmYWxzZSxcbiAgICAgICAgYXV0b3NlbGVjdDogZmFsc2UsXG4gICAgICAgIHBsYXlsaXN0czogW10sXG4gICAgICAgIHVyaTogJydcbiAgICAgIH07XG4gICAgfVxuXG4gICAgYVtsYWJlbF0ucGxheWxpc3RzLnB1c2goYWRkU2lkeFNlZ21lbnRzVG9QbGF5bGlzdChmb3JtYXRWdHRQbGF5bGlzdChwbGF5bGlzdCksIHNpZHhNYXBwaW5nKSk7XG4gICAgcmV0dXJuIGE7XG4gIH0sIHt9KTtcbn07XG5cbmNvbnN0IG9yZ2FuaXplQ2FwdGlvblNlcnZpY2VzID0gY2FwdGlvblNlcnZpY2VzID0+IGNhcHRpb25TZXJ2aWNlcy5yZWR1Y2UoKHN2Y09iaiwgc3ZjKSA9PiB7XG4gIGlmICghc3ZjKSB7XG4gICAgcmV0dXJuIHN2Y09iajtcbiAgfVxuXG4gIHN2Yy5mb3JFYWNoKHNlcnZpY2UgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIGNoYW5uZWwsXG4gICAgICBsYW5ndWFnZVxuICAgIH0gPSBzZXJ2aWNlO1xuICAgIHN2Y09ialtsYW5ndWFnZV0gPSB7XG4gICAgICBhdXRvc2VsZWN0OiBmYWxzZSxcbiAgICAgIGRlZmF1bHQ6IGZhbHNlLFxuICAgICAgaW5zdHJlYW1JZDogY2hhbm5lbCxcbiAgICAgIGxhbmd1YWdlXG4gICAgfTtcblxuICAgIGlmIChzZXJ2aWNlLmhhc093blByb3BlcnR5KCdhc3BlY3RSYXRpbycpKSB7XG4gICAgICBzdmNPYmpbbGFuZ3VhZ2VdLmFzcGVjdFJhdGlvID0gc2VydmljZS5hc3BlY3RSYXRpbztcbiAgICB9XG5cbiAgICBpZiAoc2VydmljZS5oYXNPd25Qcm9wZXJ0eSgnZWFzeVJlYWRlcicpKSB7XG4gICAgICBzdmNPYmpbbGFuZ3VhZ2VdLmVhc3lSZWFkZXIgPSBzZXJ2aWNlLmVhc3lSZWFkZXI7XG4gICAgfVxuXG4gICAgaWYgKHNlcnZpY2UuaGFzT3duUHJvcGVydHkoJzNEJykpIHtcbiAgICAgIHN2Y09ialtsYW5ndWFnZV1bJzNEJ10gPSBzZXJ2aWNlWyczRCddO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBzdmNPYmo7XG59LCB7fSk7XG5cbmNvbnN0IGZvcm1hdFZpZGVvUGxheWxpc3QgPSAoe1xuICBhdHRyaWJ1dGVzLFxuICBzZWdtZW50cyxcbiAgc2lkeCxcbiAgZGlzY29udGludWl0eVN0YXJ0c1xufSkgPT4ge1xuICBjb25zdCBwbGF5bGlzdCA9IHtcbiAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICBOQU1FOiBhdHRyaWJ1dGVzLmlkLFxuICAgICAgQVVESU86ICdhdWRpbycsXG4gICAgICBTVUJUSVRMRVM6ICdzdWJzJyxcbiAgICAgIFJFU09MVVRJT046IHtcbiAgICAgICAgd2lkdGg6IGF0dHJpYnV0ZXMud2lkdGgsXG4gICAgICAgIGhlaWdodDogYXR0cmlidXRlcy5oZWlnaHRcbiAgICAgIH0sXG4gICAgICBDT0RFQ1M6IGF0dHJpYnV0ZXMuY29kZWNzLFxuICAgICAgQkFORFdJRFRIOiBhdHRyaWJ1dGVzLmJhbmR3aWR0aCxcbiAgICAgIFsnUFJPR1JBTS1JRCddOiAxXG4gICAgfSxcbiAgICB1cmk6ICcnLFxuICAgIGVuZExpc3Q6IGF0dHJpYnV0ZXMudHlwZSA9PT0gJ3N0YXRpYycsXG4gICAgdGltZWxpbmU6IGF0dHJpYnV0ZXMucGVyaW9kU3RhcnQsXG4gICAgcmVzb2x2ZWRVcmk6IGF0dHJpYnV0ZXMuYmFzZVVybCB8fCAnJyxcbiAgICB0YXJnZXREdXJhdGlvbjogYXR0cmlidXRlcy5kdXJhdGlvbixcbiAgICBkaXNjb250aW51aXR5U3RhcnRzLFxuICAgIHRpbWVsaW5lU3RhcnRzOiBhdHRyaWJ1dGVzLnRpbWVsaW5lU3RhcnRzLFxuICAgIHNlZ21lbnRzXG4gIH07XG5cbiAgaWYgKGF0dHJpYnV0ZXMuZnJhbWVSYXRlKSB7XG4gICAgcGxheWxpc3QuYXR0cmlidXRlc1snRlJBTUUtUkFURSddID0gYXR0cmlidXRlcy5mcmFtZVJhdGU7XG4gIH1cblxuICBpZiAoYXR0cmlidXRlcy5jb250ZW50UHJvdGVjdGlvbikge1xuICAgIHBsYXlsaXN0LmNvbnRlbnRQcm90ZWN0aW9uID0gYXR0cmlidXRlcy5jb250ZW50UHJvdGVjdGlvbjtcbiAgfVxuXG4gIGlmIChhdHRyaWJ1dGVzLnNlcnZpY2VMb2NhdGlvbikge1xuICAgIHBsYXlsaXN0LmF0dHJpYnV0ZXMuc2VydmljZUxvY2F0aW9uID0gYXR0cmlidXRlcy5zZXJ2aWNlTG9jYXRpb247XG4gIH1cblxuICBpZiAoc2lkeCkge1xuICAgIHBsYXlsaXN0LnNpZHggPSBzaWR4O1xuICB9XG5cbiAgcmV0dXJuIHBsYXlsaXN0O1xufTtcblxuY29uc3QgdmlkZW9Pbmx5ID0gKHtcbiAgYXR0cmlidXRlc1xufSkgPT4gYXR0cmlidXRlcy5taW1lVHlwZSA9PT0gJ3ZpZGVvL21wNCcgfHwgYXR0cmlidXRlcy5taW1lVHlwZSA9PT0gJ3ZpZGVvL3dlYm0nIHx8IGF0dHJpYnV0ZXMuY29udGVudFR5cGUgPT09ICd2aWRlbyc7XG5cbmNvbnN0IGF1ZGlvT25seSA9ICh7XG4gIGF0dHJpYnV0ZXNcbn0pID0+IGF0dHJpYnV0ZXMubWltZVR5cGUgPT09ICdhdWRpby9tcDQnIHx8IGF0dHJpYnV0ZXMubWltZVR5cGUgPT09ICdhdWRpby93ZWJtJyB8fCBhdHRyaWJ1dGVzLmNvbnRlbnRUeXBlID09PSAnYXVkaW8nO1xuXG5jb25zdCB2dHRPbmx5ID0gKHtcbiAgYXR0cmlidXRlc1xufSkgPT4gYXR0cmlidXRlcy5taW1lVHlwZSA9PT0gJ3RleHQvdnR0JyB8fCBhdHRyaWJ1dGVzLmNvbnRlbnRUeXBlID09PSAndGV4dCc7XG4vKipcbiAqIENvbnRhaW5zIHN0YXJ0IGFuZCB0aW1lbGluZSBwcm9wZXJ0aWVzIGRlbm90aW5nIGEgdGltZWxpbmUgc3RhcnQuIEZvciBEQVNILCB0aGVzZSB3aWxsXG4gKiBiZSB0aGUgc2FtZSBudW1iZXIuXG4gKlxuICogQHR5cGVkZWYge09iamVjdH0gVGltZWxpbmVTdGFydFxuICogQHByb3BlcnR5IHtudW1iZXJ9IHN0YXJ0IC0gdGhlIHN0YXJ0IHRpbWUgb2YgdGhlIHRpbWVsaW5lXG4gKiBAcHJvcGVydHkge251bWJlcn0gdGltZWxpbmUgLSB0aGUgdGltZWxpbmUgbnVtYmVyXG4gKi9cblxuLyoqXG4gKiBBZGRzIGFwcHJvcHJpYXRlIG1lZGlhIGFuZCBkaXNjb250aW51aXR5IHNlcXVlbmNlIHZhbHVlcyB0byB0aGUgc2VnbWVudHMgYW5kIHBsYXlsaXN0cy5cbiAqXG4gKiBUaHJvdWdob3V0IG1wZC1wYXJzZXIsIHRoZSBgbnVtYmVyYCBhdHRyaWJ1dGUgaXMgdXNlZCBpbiByZWxhdGlvbiB0byBgc3RhcnROdW1iZXJgLCBhXG4gKiBEQVNIIHNwZWNpZmljIGF0dHJpYnV0ZSB1c2VkIGluIGNvbnN0cnVjdGluZyBzZWdtZW50IFVSSSdzIGZyb20gdGVtcGxhdGVzLiBIb3dldmVyLCBmcm9tXG4gKiBhbiBITFMgcGVyc3BlY3RpdmUsIHRoZSBgbnVtYmVyYCBhdHRyaWJ1dGUgb24gYSBzZWdtZW50IHdvdWxkIGJlIGl0cyBgbWVkaWFTZXF1ZW5jZWBcbiAqIHZhbHVlLCB3aGljaCBzaG91bGQgc3RhcnQgYXQgdGhlIG9yaWdpbmFsIG1lZGlhIHNlcXVlbmNlIHZhbHVlIChvciAwKSBhbmQgaW5jcmVtZW50IGJ5IDFcbiAqIGZvciBlYWNoIHNlZ21lbnQgdGhlcmVhZnRlci4gU2luY2UgREFTSCdzIGBzdGFydE51bWJlcmAgdmFsdWVzIGFyZSBpbmRlcGVuZGVudCBwZXJcbiAqIHBlcmlvZCwgaXQgZG9lc24ndCBtYWtlIHNlbnNlIHRvIHVzZSBpdCBmb3IgYG51bWJlcmAuIEluc3RlYWQsIGFzc3VtZSBldmVyeXRoaW5nIHN0YXJ0c1xuICogZnJvbSBhIDAgbWVkaWFTZXF1ZW5jZSB2YWx1ZSBhbmQgaW5jcmVtZW50IGZyb20gdGhlcmUuXG4gKlxuICogTm90ZSB0aGF0IFZIUyBjdXJyZW50bHkgZG9lc24ndCB1c2UgdGhlIGBudW1iZXJgIHByb3BlcnR5LCBidXQgaXQgY2FuIGJlIGhlbHBmdWwgZm9yXG4gKiBkZWJ1Z2dpbmcgYW5kIG1ha2luZyBzZW5zZSBvZiB0aGUgbWFuaWZlc3QuXG4gKlxuICogRm9yIGxpdmUgcGxheWxpc3RzLCB0byBhY2NvdW50IGZvciB2YWx1ZXMgaW5jcmVhc2luZyBpbiBtYW5pZmVzdHMgd2hlbiBwZXJpb2RzIGFyZVxuICogcmVtb3ZlZCBvbiByZWZyZXNoZXMsIG1lcmdpbmcgbG9naWMgc2hvdWxkIGJlIHVzZWQgdG8gdXBkYXRlIHRoZSBudW1iZXJzIHRvIHRoZWlyXG4gKiBhcHByb3ByaWF0ZSB2YWx1ZXMgKHRvIGVuc3VyZSB0aGV5J3JlIHNlcXVlbnRpYWwgYW5kIGluY3JlYXNpbmcpLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0W119IHBsYXlsaXN0cyAtIHRoZSBwbGF5bGlzdHMgdG8gdXBkYXRlXG4gKiBAcGFyYW0ge1RpbWVsaW5lU3RhcnRbXX0gdGltZWxpbmVTdGFydHMgLSB0aGUgdGltZWxpbmUgc3RhcnRzIGZvciB0aGUgbWFuaWZlc3RcbiAqL1xuXG5cbmNvbnN0IGFkZE1lZGlhU2VxdWVuY2VWYWx1ZXMgPSAocGxheWxpc3RzLCB0aW1lbGluZVN0YXJ0cykgPT4ge1xuICAvLyBpbmNyZW1lbnQgYWxsIHNlZ21lbnRzIHNlcXVlbnRpYWxseVxuICBwbGF5bGlzdHMuZm9yRWFjaChwbGF5bGlzdCA9PiB7XG4gICAgcGxheWxpc3QubWVkaWFTZXF1ZW5jZSA9IDA7XG4gICAgcGxheWxpc3QuZGlzY29udGludWl0eVNlcXVlbmNlID0gdGltZWxpbmVTdGFydHMuZmluZEluZGV4KGZ1bmN0aW9uICh7XG4gICAgICB0aW1lbGluZVxuICAgIH0pIHtcbiAgICAgIHJldHVybiB0aW1lbGluZSA9PT0gcGxheWxpc3QudGltZWxpbmU7XG4gICAgfSk7XG5cbiAgICBpZiAoIXBsYXlsaXN0LnNlZ21lbnRzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcGxheWxpc3Quc2VnbWVudHMuZm9yRWFjaCgoc2VnbWVudCwgaW5kZXgpID0+IHtcbiAgICAgIHNlZ21lbnQubnVtYmVyID0gaW5kZXg7XG4gICAgfSk7XG4gIH0pO1xufTtcbi8qKlxuICogR2l2ZW4gYSBtZWRpYSBncm91cCBvYmplY3QsIGZsYXR0ZW5zIGFsbCBwbGF5bGlzdHMgd2l0aGluIHRoZSBtZWRpYSBncm91cCBpbnRvIGEgc2luZ2xlXG4gKiBhcnJheS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gbWVkaWFHcm91cE9iamVjdCAtIHRoZSBtZWRpYSBncm91cCBvYmplY3RcbiAqXG4gKiBAcmV0dXJuIHtPYmplY3RbXX1cbiAqICAgICAgICAgVGhlIG1lZGlhIGdyb3VwIHBsYXlsaXN0c1xuICovXG5cbmNvbnN0IGZsYXR0ZW5NZWRpYUdyb3VwUGxheWxpc3RzID0gbWVkaWFHcm91cE9iamVjdCA9PiB7XG4gIGlmICghbWVkaWFHcm91cE9iamVjdCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIHJldHVybiBPYmplY3Qua2V5cyhtZWRpYUdyb3VwT2JqZWN0KS5yZWR1Y2UoKGFjYywgbGFiZWwpID0+IHtcbiAgICBjb25zdCBsYWJlbENvbnRlbnRzID0gbWVkaWFHcm91cE9iamVjdFtsYWJlbF07XG4gICAgcmV0dXJuIGFjYy5jb25jYXQobGFiZWxDb250ZW50cy5wbGF5bGlzdHMpO1xuICB9LCBbXSk7XG59O1xuY29uc3QgdG9NM3U4ID0gKHtcbiAgZGFzaFBsYXlsaXN0cyxcbiAgbG9jYXRpb25zLFxuICBjb250ZW50U3RlZXJpbmcsXG4gIHNpZHhNYXBwaW5nID0ge30sXG4gIHByZXZpb3VzTWFuaWZlc3QsXG4gIGV2ZW50U3RyZWFtXG59KSA9PiB7XG4gIGlmICghZGFzaFBsYXlsaXN0cy5sZW5ndGgpIHtcbiAgICByZXR1cm4ge307XG4gIH0gLy8gZ3JhYiBhbGwgbWFpbiBtYW5pZmVzdCBhdHRyaWJ1dGVzXG5cblxuICBjb25zdCB7XG4gICAgc291cmNlRHVyYXRpb246IGR1cmF0aW9uLFxuICAgIHR5cGUsXG4gICAgc3VnZ2VzdGVkUHJlc2VudGF0aW9uRGVsYXksXG4gICAgbWluaW11bVVwZGF0ZVBlcmlvZFxuICB9ID0gZGFzaFBsYXlsaXN0c1swXS5hdHRyaWJ1dGVzO1xuICBjb25zdCB2aWRlb1BsYXlsaXN0cyA9IG1lcmdlRGlzY29udGlndW91c1BsYXlsaXN0cyhkYXNoUGxheWxpc3RzLmZpbHRlcih2aWRlb09ubHkpKS5tYXAoZm9ybWF0VmlkZW9QbGF5bGlzdCk7XG4gIGNvbnN0IGF1ZGlvUGxheWxpc3RzID0gbWVyZ2VEaXNjb250aWd1b3VzUGxheWxpc3RzKGRhc2hQbGF5bGlzdHMuZmlsdGVyKGF1ZGlvT25seSkpO1xuICBjb25zdCB2dHRQbGF5bGlzdHMgPSBtZXJnZURpc2NvbnRpZ3VvdXNQbGF5bGlzdHMoZGFzaFBsYXlsaXN0cy5maWx0ZXIodnR0T25seSkpO1xuICBjb25zdCBjYXB0aW9ucyA9IGRhc2hQbGF5bGlzdHMubWFwKHBsYXlsaXN0ID0+IHBsYXlsaXN0LmF0dHJpYnV0ZXMuY2FwdGlvblNlcnZpY2VzKS5maWx0ZXIoQm9vbGVhbik7XG4gIGNvbnN0IG1hbmlmZXN0ID0ge1xuICAgIGFsbG93Q2FjaGU6IHRydWUsXG4gICAgZGlzY29udGludWl0eVN0YXJ0czogW10sXG4gICAgc2VnbWVudHM6IFtdLFxuICAgIGVuZExpc3Q6IHRydWUsXG4gICAgbWVkaWFHcm91cHM6IHtcbiAgICAgIEFVRElPOiB7fSxcbiAgICAgIFZJREVPOiB7fSxcbiAgICAgIFsnQ0xPU0VELUNBUFRJT05TJ106IHt9LFxuICAgICAgU1VCVElUTEVTOiB7fVxuICAgIH0sXG4gICAgdXJpOiAnJyxcbiAgICBkdXJhdGlvbixcbiAgICBwbGF5bGlzdHM6IGFkZFNpZHhTZWdtZW50c1RvUGxheWxpc3RzKHZpZGVvUGxheWxpc3RzLCBzaWR4TWFwcGluZylcbiAgfTtcblxuICBpZiAobWluaW11bVVwZGF0ZVBlcmlvZCA+PSAwKSB7XG4gICAgbWFuaWZlc3QubWluaW11bVVwZGF0ZVBlcmlvZCA9IG1pbmltdW1VcGRhdGVQZXJpb2QgKiAxMDAwO1xuICB9XG5cbiAgaWYgKGxvY2F0aW9ucykge1xuICAgIG1hbmlmZXN0LmxvY2F0aW9ucyA9IGxvY2F0aW9ucztcbiAgfVxuXG4gIGlmIChjb250ZW50U3RlZXJpbmcpIHtcbiAgICBtYW5pZmVzdC5jb250ZW50U3RlZXJpbmcgPSBjb250ZW50U3RlZXJpbmc7XG4gIH1cblxuICBpZiAodHlwZSA9PT0gJ2R5bmFtaWMnKSB7XG4gICAgbWFuaWZlc3Quc3VnZ2VzdGVkUHJlc2VudGF0aW9uRGVsYXkgPSBzdWdnZXN0ZWRQcmVzZW50YXRpb25EZWxheTtcbiAgfVxuXG4gIGlmIChldmVudFN0cmVhbSAmJiBldmVudFN0cmVhbS5sZW5ndGggPiAwKSB7XG4gICAgbWFuaWZlc3QuZXZlbnRTdHJlYW0gPSBldmVudFN0cmVhbTtcbiAgfVxuXG4gIGNvbnN0IGlzQXVkaW9Pbmx5ID0gbWFuaWZlc3QucGxheWxpc3RzLmxlbmd0aCA9PT0gMDtcbiAgY29uc3Qgb3JnYW5pemVkQXVkaW9Hcm91cCA9IGF1ZGlvUGxheWxpc3RzLmxlbmd0aCA/IG9yZ2FuaXplQXVkaW9QbGF5bGlzdHMoYXVkaW9QbGF5bGlzdHMsIHNpZHhNYXBwaW5nLCBpc0F1ZGlvT25seSkgOiBudWxsO1xuICBjb25zdCBvcmdhbml6ZWRWdHRHcm91cCA9IHZ0dFBsYXlsaXN0cy5sZW5ndGggPyBvcmdhbml6ZVZ0dFBsYXlsaXN0cyh2dHRQbGF5bGlzdHMsIHNpZHhNYXBwaW5nKSA6IG51bGw7XG4gIGNvbnN0IGZvcm1hdHRlZFBsYXlsaXN0cyA9IHZpZGVvUGxheWxpc3RzLmNvbmNhdChmbGF0dGVuTWVkaWFHcm91cFBsYXlsaXN0cyhvcmdhbml6ZWRBdWRpb0dyb3VwKSwgZmxhdHRlbk1lZGlhR3JvdXBQbGF5bGlzdHMob3JnYW5pemVkVnR0R3JvdXApKTtcbiAgY29uc3QgcGxheWxpc3RUaW1lbGluZVN0YXJ0cyA9IGZvcm1hdHRlZFBsYXlsaXN0cy5tYXAoKHtcbiAgICB0aW1lbGluZVN0YXJ0c1xuICB9KSA9PiB0aW1lbGluZVN0YXJ0cyk7XG4gIG1hbmlmZXN0LnRpbWVsaW5lU3RhcnRzID0gZ2V0VW5pcXVlVGltZWxpbmVTdGFydHMocGxheWxpc3RUaW1lbGluZVN0YXJ0cyk7XG4gIGFkZE1lZGlhU2VxdWVuY2VWYWx1ZXMoZm9ybWF0dGVkUGxheWxpc3RzLCBtYW5pZmVzdC50aW1lbGluZVN0YXJ0cyk7XG5cbiAgaWYgKG9yZ2FuaXplZEF1ZGlvR3JvdXApIHtcbiAgICBtYW5pZmVzdC5tZWRpYUdyb3Vwcy5BVURJTy5hdWRpbyA9IG9yZ2FuaXplZEF1ZGlvR3JvdXA7XG4gIH1cblxuICBpZiAob3JnYW5pemVkVnR0R3JvdXApIHtcbiAgICBtYW5pZmVzdC5tZWRpYUdyb3Vwcy5TVUJUSVRMRVMuc3VicyA9IG9yZ2FuaXplZFZ0dEdyb3VwO1xuICB9XG5cbiAgaWYgKGNhcHRpb25zLmxlbmd0aCkge1xuICAgIG1hbmlmZXN0Lm1lZGlhR3JvdXBzWydDTE9TRUQtQ0FQVElPTlMnXS5jYyA9IG9yZ2FuaXplQ2FwdGlvblNlcnZpY2VzKGNhcHRpb25zKTtcbiAgfVxuXG4gIGlmIChwcmV2aW91c01hbmlmZXN0KSB7XG4gICAgcmV0dXJuIHBvc2l0aW9uTWFuaWZlc3RPblRpbWVsaW5lKHtcbiAgICAgIG9sZE1hbmlmZXN0OiBwcmV2aW91c01hbmlmZXN0LFxuICAgICAgbmV3TWFuaWZlc3Q6IG1hbmlmZXN0XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gbWFuaWZlc3Q7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIFIgKHJlcGV0aXRpb24pIHZhbHVlIGZvciBhIGxpdmUgc3RyZWFtIChmb3IgdGhlIGZpbmFsIHNlZ21lbnRcbiAqIGluIGEgbWFuaWZlc3Qgd2hlcmUgdGhlIHIgdmFsdWUgaXMgbmVnYXRpdmUgMSlcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gYXR0cmlidXRlc1xuICogICAgICAgIE9iamVjdCBjb250YWluaW5nIGFsbCBpbmhlcml0ZWQgYXR0cmlidXRlcyBmcm9tIHBhcmVudCBlbGVtZW50cyB3aXRoIGF0dHJpYnV0ZVxuICogICAgICAgIG5hbWVzIGFzIGtleXNcbiAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lXG4gKiAgICAgICAgY3VycmVudCB0aW1lICh0eXBpY2FsbHkgdGhlIHRvdGFsIHRpbWUgdXAgdW50aWwgdGhlIGZpbmFsIHNlZ21lbnQpXG4gKiBAcGFyYW0ge251bWJlcn0gZHVyYXRpb25cbiAqICAgICAgICBkdXJhdGlvbiBwcm9wZXJ0eSBmb3IgdGhlIGdpdmVuIDxTIC8+XG4gKlxuICogQHJldHVybiB7bnVtYmVyfVxuICogICAgICAgIFIgdmFsdWUgdG8gcmVhY2ggdGhlIGVuZCBvZiB0aGUgZ2l2ZW4gcGVyaW9kXG4gKi9cbmNvbnN0IGdldExpdmVSVmFsdWUgPSAoYXR0cmlidXRlcywgdGltZSwgZHVyYXRpb24pID0+IHtcbiAgY29uc3Qge1xuICAgIE5PVyxcbiAgICBjbGllbnRPZmZzZXQsXG4gICAgYXZhaWxhYmlsaXR5U3RhcnRUaW1lLFxuICAgIHRpbWVzY2FsZSA9IDEsXG4gICAgcGVyaW9kU3RhcnQgPSAwLFxuICAgIG1pbmltdW1VcGRhdGVQZXJpb2QgPSAwXG4gIH0gPSBhdHRyaWJ1dGVzO1xuICBjb25zdCBub3cgPSAoTk9XICsgY2xpZW50T2Zmc2V0KSAvIDEwMDA7XG4gIGNvbnN0IHBlcmlvZFN0YXJ0V0MgPSBhdmFpbGFiaWxpdHlTdGFydFRpbWUgKyBwZXJpb2RTdGFydDtcbiAgY29uc3QgcGVyaW9kRW5kV0MgPSBub3cgKyBtaW5pbXVtVXBkYXRlUGVyaW9kO1xuICBjb25zdCBwZXJpb2REdXJhdGlvbiA9IHBlcmlvZEVuZFdDIC0gcGVyaW9kU3RhcnRXQztcbiAgcmV0dXJuIE1hdGguY2VpbCgocGVyaW9kRHVyYXRpb24gKiB0aW1lc2NhbGUgLSB0aW1lKSAvIGR1cmF0aW9uKTtcbn07XG4vKipcbiAqIFVzZXMgaW5mb3JtYXRpb24gcHJvdmlkZWQgYnkgU2VnbWVudFRlbXBsYXRlLlNlZ21lbnRUaW1lbGluZSB0byBkZXRlcm1pbmUgc2VnbWVudFxuICogdGltaW5nIGFuZCBkdXJhdGlvblxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBhdHRyaWJ1dGVzXG4gKiAgICAgICAgT2JqZWN0IGNvbnRhaW5pbmcgYWxsIGluaGVyaXRlZCBhdHRyaWJ1dGVzIGZyb20gcGFyZW50IGVsZW1lbnRzIHdpdGggYXR0cmlidXRlXG4gKiAgICAgICAgbmFtZXMgYXMga2V5c1xuICogQHBhcmFtIHtPYmplY3RbXX0gc2VnbWVudFRpbWVsaW5lXG4gKiAgICAgICAgTGlzdCBvZiBvYmplY3RzIHJlcHJlc2VudGluZyB0aGUgYXR0cmlidXRlcyBvZiBlYWNoIFMgZWxlbWVudCBjb250YWluZWQgd2l0aGluXG4gKlxuICogQHJldHVybiB7e251bWJlcjogbnVtYmVyLCBkdXJhdGlvbjogbnVtYmVyLCB0aW1lOiBudW1iZXIsIHRpbWVsaW5lOiBudW1iZXJ9W119XG4gKiAgICAgICAgIExpc3Qgb2YgT2JqZWN0cyB3aXRoIHNlZ21lbnQgdGltaW5nIGFuZCBkdXJhdGlvbiBpbmZvXG4gKi9cblxuXG5jb25zdCBwYXJzZUJ5VGltZWxpbmUgPSAoYXR0cmlidXRlcywgc2VnbWVudFRpbWVsaW5lKSA9PiB7XG4gIGNvbnN0IHtcbiAgICB0eXBlLFxuICAgIG1pbmltdW1VcGRhdGVQZXJpb2QgPSAwLFxuICAgIG1lZGlhID0gJycsXG4gICAgc291cmNlRHVyYXRpb24sXG4gICAgdGltZXNjYWxlID0gMSxcbiAgICBzdGFydE51bWJlciA9IDEsXG4gICAgcGVyaW9kU3RhcnQ6IHRpbWVsaW5lXG4gIH0gPSBhdHRyaWJ1dGVzO1xuICBjb25zdCBzZWdtZW50cyA9IFtdO1xuICBsZXQgdGltZSA9IC0xO1xuXG4gIGZvciAobGV0IHNJbmRleCA9IDA7IHNJbmRleCA8IHNlZ21lbnRUaW1lbGluZS5sZW5ndGg7IHNJbmRleCsrKSB7XG4gICAgY29uc3QgUyA9IHNlZ21lbnRUaW1lbGluZVtzSW5kZXhdO1xuICAgIGNvbnN0IGR1cmF0aW9uID0gUy5kO1xuICAgIGNvbnN0IHJlcGVhdCA9IFMuciB8fCAwO1xuICAgIGNvbnN0IHNlZ21lbnRUaW1lID0gUy50IHx8IDA7XG5cbiAgICBpZiAodGltZSA8IDApIHtcbiAgICAgIC8vIGZpcnN0IHNlZ21lbnRcbiAgICAgIHRpbWUgPSBzZWdtZW50VGltZTtcbiAgICB9XG5cbiAgICBpZiAoc2VnbWVudFRpbWUgJiYgc2VnbWVudFRpbWUgPiB0aW1lKSB7XG4gICAgICAvLyBkaXNjb250aW51aXR5XG4gICAgICAvLyBUT0RPOiBIb3cgdG8gaGFuZGxlIHRoaXMgdHlwZSBvZiBkaXNjb250aW51aXR5XG4gICAgICAvLyB0aW1lbGluZSsrIGhlcmUgd291bGQgdHJlYXQgaXQgbGlrZSBITFMgZGlzY29udHVpdHkgYW5kIGNvbnRlbnQgd291bGRcbiAgICAgIC8vIGdldCBhcHBlbmRlZCB3aXRob3V0IGdhcFxuICAgICAgLy8gRS5HLlxuICAgICAgLy8gIDxTIHQ9XCIwXCIgZD1cIjFcIiAvPlxuICAgICAgLy8gIDxTIGQ9XCIxXCIgLz5cbiAgICAgIC8vICA8UyBkPVwiMVwiIC8+XG4gICAgICAvLyAgPFMgdD1cIjVcIiBkPVwiMVwiIC8+XG4gICAgICAvLyB3b3VsZCBoYXZlICRUaW1lJCB2YWx1ZXMgb2YgWzAsIDEsIDIsIDVdXG4gICAgICAvLyBzaG91bGQgdGhpcyBiZSBhcHBlbmVkIGF0IHRpbWUgcG9zaXRpb25zIFswLCAxLCAyLCAzXSwoI0VYVC1YLURJU0NPTlRJTlVJVFkpXG4gICAgICAvLyBvciBbMCwgMSwgMiwgZ2FwLCBnYXAsIDVdPyAoI0VYVC1YLUdBUClcbiAgICAgIC8vIGRvZXMgdGhlIHZhbHVlIG9mIHNvdXJjZUR1cmF0aW9uIGNvbnNpZGVyIHRoaXMgd2hlbiBjYWxjdWxhdGluZyBhcmJpdHJhcnlcbiAgICAgIC8vIG5lZ2F0aXZlIEByIHJlcGVhdCB2YWx1ZT9cbiAgICAgIC8vIEUuRy4gU2FtZSBlbGVtZW50cyBhcyBhYm92ZSB3aXRoIHRoaXMgYWRkZWQgYXQgdGhlIGVuZFxuICAgICAgLy8gIDxTIGQ9XCIxXCIgcj1cIi0xXCIgLz5cbiAgICAgIC8vICB3aXRoIGEgc291cmNlRHVyYXRpb24gb2YgMTBcbiAgICAgIC8vIFdvdWxkIHRoZSAyIGdhcHMgYmUgaW5jbHVkZWQgaW4gdGhlIHRpbWUgZHVyYXRpb24gY2FsY3VsYXRpb25zIHJlc3VsdGluZyBpblxuICAgICAgLy8gOCBzZWdtZW50cyB3aXRoICRUaW1lJCB2YWx1ZXMgb2YgWzAsIDEsIDIsIDUsIDYsIDcsIDgsIDldIG9yIDEwIHNlZ21lbnRzXG4gICAgICAvLyB3aXRoICRUaW1lJCB2YWx1ZXMgb2YgWzAsIDEsIDIsIDUsIDYsIDcsIDgsIDksIDEwLCAxMV0gP1xuICAgICAgdGltZSA9IHNlZ21lbnRUaW1lO1xuICAgIH1cblxuICAgIGxldCBjb3VudDtcblxuICAgIGlmIChyZXBlYXQgPCAwKSB7XG4gICAgICBjb25zdCBuZXh0UyA9IHNJbmRleCArIDE7XG5cbiAgICAgIGlmIChuZXh0UyA9PT0gc2VnbWVudFRpbWVsaW5lLmxlbmd0aCkge1xuICAgICAgICAvLyBsYXN0IHNlZ21lbnRcbiAgICAgICAgaWYgKHR5cGUgPT09ICdkeW5hbWljJyAmJiBtaW5pbXVtVXBkYXRlUGVyaW9kID4gMCAmJiBtZWRpYS5pbmRleE9mKCckTnVtYmVyJCcpID4gMCkge1xuICAgICAgICAgIGNvdW50ID0gZ2V0TGl2ZVJWYWx1ZShhdHRyaWJ1dGVzLCB0aW1lLCBkdXJhdGlvbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gVE9ETzogVGhpcyBtYXkgYmUgaW5jb3JyZWN0IGRlcGVuZGluZyBvbiBjb25jbHVzaW9uIG9mIFRPRE8gYWJvdmVcbiAgICAgICAgICBjb3VudCA9IChzb3VyY2VEdXJhdGlvbiAqIHRpbWVzY2FsZSAtIHRpbWUpIC8gZHVyYXRpb247XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvdW50ID0gKHNlZ21lbnRUaW1lbGluZVtuZXh0U10udCAtIHRpbWUpIC8gZHVyYXRpb247XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvdW50ID0gcmVwZWF0ICsgMTtcbiAgICB9XG5cbiAgICBjb25zdCBlbmQgPSBzdGFydE51bWJlciArIHNlZ21lbnRzLmxlbmd0aCArIGNvdW50O1xuICAgIGxldCBudW1iZXIgPSBzdGFydE51bWJlciArIHNlZ21lbnRzLmxlbmd0aDtcblxuICAgIHdoaWxlIChudW1iZXIgPCBlbmQpIHtcbiAgICAgIHNlZ21lbnRzLnB1c2goe1xuICAgICAgICBudW1iZXIsXG4gICAgICAgIGR1cmF0aW9uOiBkdXJhdGlvbiAvIHRpbWVzY2FsZSxcbiAgICAgICAgdGltZSxcbiAgICAgICAgdGltZWxpbmVcbiAgICAgIH0pO1xuICAgICAgdGltZSArPSBkdXJhdGlvbjtcbiAgICAgIG51bWJlcisrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzZWdtZW50cztcbn07XG5cbmNvbnN0IGlkZW50aWZpZXJQYXR0ZXJuID0gL1xcJChbQS16XSopKD86KCUwKShbMC05XSspZCk/XFwkL2c7XG4vKipcbiAqIFJlcGxhY2VzIHRlbXBsYXRlIGlkZW50aWZpZXJzIHdpdGggY29ycmVzcG9uZGluZyB2YWx1ZXMuIFRvIGJlIHVzZWQgYXMgdGhlIGNhbGxiYWNrXG4gKiBmb3IgU3RyaW5nLnByb3RvdHlwZS5yZXBsYWNlXG4gKlxuICogQG5hbWUgcmVwbGFjZUNhbGxiYWNrXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7c3RyaW5nfSBtYXRjaFxuICogICAgICAgIEVudGlyZSBtYXRjaCBvZiBpZGVudGlmaWVyXG4gKiBAcGFyYW0ge3N0cmluZ30gaWRlbnRpZmllclxuICogICAgICAgIE5hbWUgb2YgbWF0Y2hlZCBpZGVudGlmaWVyXG4gKiBAcGFyYW0ge3N0cmluZ30gZm9ybWF0XG4gKiAgICAgICAgRm9ybWF0IHRhZyBzdHJpbmcuIEl0cyBwcmVzZW5jZSBpbmRpY2F0ZXMgdGhhdCBwYWRkaW5nIGlzIGV4cGVjdGVkXG4gKiBAcGFyYW0ge3N0cmluZ30gd2lkdGhcbiAqICAgICAgICBEZXNpcmVkIGxlbmd0aCBvZiB0aGUgcmVwbGFjZWQgdmFsdWUuIFZhbHVlcyBsZXNzIHRoYW4gdGhpcyB3aWR0aCBzaGFsbCBiZSBsZWZ0XG4gKiAgICAgICAgemVybyBwYWRkZWRcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqICAgICAgICAgUmVwbGFjZW1lbnQgZm9yIHRoZSBtYXRjaGVkIGlkZW50aWZpZXJcbiAqL1xuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0byBiZSB1c2VkIGFzIGEgY2FsbGJhY2sgZm9yIFN0cmluZy5wcm90b3R5cGUucmVwbGFjZSB0byByZXBsYWNlXG4gKiB0ZW1wbGF0ZSBpZGVudGlmaWVyc1xuICpcbiAqIEBwYXJhbSB7T2JlY3R9IHZhbHVlc1xuICogICAgICAgIE9iamVjdCBjb250YWluaW5nIHZhbHVlcyB0aGF0IHNoYWxsIGJlIHVzZWQgdG8gcmVwbGFjZSBrbm93biBpZGVudGlmaWVyc1xuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlcy5SZXByZXNlbnRhdGlvbklEXG4gKiAgICAgICAgVmFsdWUgb2YgdGhlIFJlcHJlc2VudGF0aW9uQGlkIGF0dHJpYnV0ZVxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlcy5OdW1iZXJcbiAqICAgICAgICBOdW1iZXIgb2YgdGhlIGNvcnJlc3BvbmRpbmcgc2VnbWVudFxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlcy5CYW5kd2lkdGhcbiAqICAgICAgICBWYWx1ZSBvZiB0aGUgUmVwcmVzZW50YXRpb25AYmFuZHdpZHRoIGF0dHJpYnV0ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZXMuVGltZVxuICogICAgICAgIFRpbWVzdGFtcCB2YWx1ZSBvZiB0aGUgY29ycmVzcG9uZGluZyBzZWdtZW50XG4gKiBAcmV0dXJuIHtyZXBsYWNlQ2FsbGJhY2t9XG4gKiAgICAgICAgIENhbGxiYWNrIHRvIGJlIHVzZWQgd2l0aCBTdHJpbmcucHJvdG90eXBlLnJlcGxhY2UgdG8gcmVwbGFjZSBpZGVudGlmaWVyc1xuICovXG5cbmNvbnN0IGlkZW50aWZpZXJSZXBsYWNlbWVudCA9IHZhbHVlcyA9PiAobWF0Y2gsIGlkZW50aWZpZXIsIGZvcm1hdCwgd2lkdGgpID0+IHtcbiAgaWYgKG1hdGNoID09PSAnJCQnKSB7XG4gICAgLy8gZXNjYXBlIHNlcXVlbmNlXG4gICAgcmV0dXJuICckJztcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsdWVzW2lkZW50aWZpZXJdID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBtYXRjaDtcbiAgfVxuXG4gIGNvbnN0IHZhbHVlID0gJycgKyB2YWx1ZXNbaWRlbnRpZmllcl07XG5cbiAgaWYgKGlkZW50aWZpZXIgPT09ICdSZXByZXNlbnRhdGlvbklEJykge1xuICAgIC8vIEZvcm1hdCB0YWcgc2hhbGwgbm90IGJlIHByZXNlbnQgd2l0aCBSZXByZXNlbnRhdGlvbklEXG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgaWYgKCFmb3JtYXQpIHtcbiAgICB3aWR0aCA9IDE7XG4gIH0gZWxzZSB7XG4gICAgd2lkdGggPSBwYXJzZUludCh3aWR0aCwgMTApO1xuICB9XG5cbiAgaWYgKHZhbHVlLmxlbmd0aCA+PSB3aWR0aCkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIHJldHVybiBgJHtuZXcgQXJyYXkod2lkdGggLSB2YWx1ZS5sZW5ndGggKyAxKS5qb2luKCcwJyl9JHt2YWx1ZX1gO1xufTtcbi8qKlxuICogQ29uc3RydWN0cyBhIHNlZ21lbnQgdXJsIGZyb20gYSB0ZW1wbGF0ZSBzdHJpbmdcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsXG4gKiAgICAgICAgVGVtcGxhdGUgc3RyaW5nIHRvIGNvbnN0cnVjdCB1cmwgZnJvbVxuICogQHBhcmFtIHtPYmVjdH0gdmFsdWVzXG4gKiAgICAgICAgT2JqZWN0IGNvbnRhaW5pbmcgdmFsdWVzIHRoYXQgc2hhbGwgYmUgdXNlZCB0byByZXBsYWNlIGtub3duIGlkZW50aWZpZXJzXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWVzLlJlcHJlc2VudGF0aW9uSURcbiAqICAgICAgICBWYWx1ZSBvZiB0aGUgUmVwcmVzZW50YXRpb25AaWQgYXR0cmlidXRlXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWVzLk51bWJlclxuICogICAgICAgIE51bWJlciBvZiB0aGUgY29ycmVzcG9uZGluZyBzZWdtZW50XG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWVzLkJhbmR3aWR0aFxuICogICAgICAgIFZhbHVlIG9mIHRoZSBSZXByZXNlbnRhdGlvbkBiYW5kd2lkdGggYXR0cmlidXRlLlxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlcy5UaW1lXG4gKiAgICAgICAgVGltZXN0YW1wIHZhbHVlIG9mIHRoZSBjb3JyZXNwb25kaW5nIHNlZ21lbnRcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqICAgICAgICAgU2VnbWVudCB1cmwgd2l0aCBpZGVudGlmaWVycyByZXBsYWNlZFxuICovXG5cbmNvbnN0IGNvbnN0cnVjdFRlbXBsYXRlVXJsID0gKHVybCwgdmFsdWVzKSA9PiB1cmwucmVwbGFjZShpZGVudGlmaWVyUGF0dGVybiwgaWRlbnRpZmllclJlcGxhY2VtZW50KHZhbHVlcykpO1xuLyoqXG4gKiBHZW5lcmF0ZXMgYSBsaXN0IG9mIG9iamVjdHMgY29udGFpbmluZyB0aW1pbmcgYW5kIGR1cmF0aW9uIGluZm9ybWF0aW9uIGFib3V0IGVhY2hcbiAqIHNlZ21lbnQgbmVlZGVkIHRvIGdlbmVyYXRlIHNlZ21lbnQgdXJpcyBhbmQgdGhlIGNvbXBsZXRlIHNlZ21lbnQgb2JqZWN0XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGF0dHJpYnV0ZXNcbiAqICAgICAgICBPYmplY3QgY29udGFpbmluZyBhbGwgaW5oZXJpdGVkIGF0dHJpYnV0ZXMgZnJvbSBwYXJlbnQgZWxlbWVudHMgd2l0aCBhdHRyaWJ1dGVcbiAqICAgICAgICBuYW1lcyBhcyBrZXlzXG4gKiBAcGFyYW0ge09iamVjdFtdfHVuZGVmaW5lZH0gc2VnbWVudFRpbWVsaW5lXG4gKiAgICAgICAgTGlzdCBvZiBvYmplY3RzIHJlcHJlc2VudGluZyB0aGUgYXR0cmlidXRlcyBvZiBlYWNoIFMgZWxlbWVudCBjb250YWluZWQgd2l0aGluXG4gKiAgICAgICAgdGhlIFNlZ21lbnRUaW1lbGluZSBlbGVtZW50XG4gKiBAcmV0dXJuIHt7bnVtYmVyOiBudW1iZXIsIGR1cmF0aW9uOiBudW1iZXIsIHRpbWU6IG51bWJlciwgdGltZWxpbmU6IG51bWJlcn1bXX1cbiAqICAgICAgICAgTGlzdCBvZiBPYmplY3RzIHdpdGggc2VnbWVudCB0aW1pbmcgYW5kIGR1cmF0aW9uIGluZm9cbiAqL1xuXG5jb25zdCBwYXJzZVRlbXBsYXRlSW5mbyA9IChhdHRyaWJ1dGVzLCBzZWdtZW50VGltZWxpbmUpID0+IHtcbiAgaWYgKCFhdHRyaWJ1dGVzLmR1cmF0aW9uICYmICFzZWdtZW50VGltZWxpbmUpIHtcbiAgICAvLyBpZiBuZWl0aGVyIEBkdXJhdGlvbiBvciBTZWdtZW50VGltZWxpbmUgYXJlIHByZXNlbnQsIHRoZW4gdGhlcmUgc2hhbGwgYmUgZXhhY3RseVxuICAgIC8vIG9uZSBtZWRpYSBzZWdtZW50XG4gICAgcmV0dXJuIFt7XG4gICAgICBudW1iZXI6IGF0dHJpYnV0ZXMuc3RhcnROdW1iZXIgfHwgMSxcbiAgICAgIGR1cmF0aW9uOiBhdHRyaWJ1dGVzLnNvdXJjZUR1cmF0aW9uLFxuICAgICAgdGltZTogMCxcbiAgICAgIHRpbWVsaW5lOiBhdHRyaWJ1dGVzLnBlcmlvZFN0YXJ0XG4gICAgfV07XG4gIH1cblxuICBpZiAoYXR0cmlidXRlcy5kdXJhdGlvbikge1xuICAgIHJldHVybiBwYXJzZUJ5RHVyYXRpb24oYXR0cmlidXRlcyk7XG4gIH1cblxuICByZXR1cm4gcGFyc2VCeVRpbWVsaW5lKGF0dHJpYnV0ZXMsIHNlZ21lbnRUaW1lbGluZSk7XG59O1xuLyoqXG4gKiBHZW5lcmF0ZXMgYSBsaXN0IG9mIHNlZ21lbnRzIHVzaW5nIGluZm9ybWF0aW9uIHByb3ZpZGVkIGJ5IHRoZSBTZWdtZW50VGVtcGxhdGUgZWxlbWVudFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBhdHRyaWJ1dGVzXG4gKiAgICAgICAgT2JqZWN0IGNvbnRhaW5pbmcgYWxsIGluaGVyaXRlZCBhdHRyaWJ1dGVzIGZyb20gcGFyZW50IGVsZW1lbnRzIHdpdGggYXR0cmlidXRlXG4gKiAgICAgICAgbmFtZXMgYXMga2V5c1xuICogQHBhcmFtIHtPYmplY3RbXXx1bmRlZmluZWR9IHNlZ21lbnRUaW1lbGluZVxuICogICAgICAgIExpc3Qgb2Ygb2JqZWN0cyByZXByZXNlbnRpbmcgdGhlIGF0dHJpYnV0ZXMgb2YgZWFjaCBTIGVsZW1lbnQgY29udGFpbmVkIHdpdGhpblxuICogICAgICAgIHRoZSBTZWdtZW50VGltZWxpbmUgZWxlbWVudFxuICogQHJldHVybiB7T2JqZWN0W119XG4gKiAgICAgICAgIExpc3Qgb2Ygc2VnbWVudCBvYmplY3RzXG4gKi9cblxuY29uc3Qgc2VnbWVudHNGcm9tVGVtcGxhdGUgPSAoYXR0cmlidXRlcywgc2VnbWVudFRpbWVsaW5lKSA9PiB7XG4gIGNvbnN0IHRlbXBsYXRlVmFsdWVzID0ge1xuICAgIFJlcHJlc2VudGF0aW9uSUQ6IGF0dHJpYnV0ZXMuaWQsXG4gICAgQmFuZHdpZHRoOiBhdHRyaWJ1dGVzLmJhbmR3aWR0aCB8fCAwXG4gIH07XG4gIGNvbnN0IHtcbiAgICBpbml0aWFsaXphdGlvbiA9IHtcbiAgICAgIHNvdXJjZVVSTDogJycsXG4gICAgICByYW5nZTogJydcbiAgICB9XG4gIH0gPSBhdHRyaWJ1dGVzO1xuICBjb25zdCBtYXBTZWdtZW50ID0gdXJsVHlwZVRvU2VnbWVudCh7XG4gICAgYmFzZVVybDogYXR0cmlidXRlcy5iYXNlVXJsLFxuICAgIHNvdXJjZTogY29uc3RydWN0VGVtcGxhdGVVcmwoaW5pdGlhbGl6YXRpb24uc291cmNlVVJMLCB0ZW1wbGF0ZVZhbHVlcyksXG4gICAgcmFuZ2U6IGluaXRpYWxpemF0aW9uLnJhbmdlXG4gIH0pO1xuICBjb25zdCBzZWdtZW50cyA9IHBhcnNlVGVtcGxhdGVJbmZvKGF0dHJpYnV0ZXMsIHNlZ21lbnRUaW1lbGluZSk7XG4gIHJldHVybiBzZWdtZW50cy5tYXAoc2VnbWVudCA9PiB7XG4gICAgdGVtcGxhdGVWYWx1ZXMuTnVtYmVyID0gc2VnbWVudC5udW1iZXI7XG4gICAgdGVtcGxhdGVWYWx1ZXMuVGltZSA9IHNlZ21lbnQudGltZTtcbiAgICBjb25zdCB1cmkgPSBjb25zdHJ1Y3RUZW1wbGF0ZVVybChhdHRyaWJ1dGVzLm1lZGlhIHx8ICcnLCB0ZW1wbGF0ZVZhbHVlcyk7IC8vIFNlZSBEQVNIIHNwZWMgc2VjdGlvbiA1LjMuOS4yLjJcbiAgICAvLyAtIGlmIHRpbWVzY2FsZSBpc24ndCBwcmVzZW50IG9uIGFueSBsZXZlbCwgZGVmYXVsdCB0byAxLlxuXG4gICAgY29uc3QgdGltZXNjYWxlID0gYXR0cmlidXRlcy50aW1lc2NhbGUgfHwgMTsgLy8gLSBpZiBwcmVzZW50YXRpb25UaW1lT2Zmc2V0IGlzbid0IHByZXNlbnQgb24gYW55IGxldmVsLCBkZWZhdWx0IHRvIDBcblxuICAgIGNvbnN0IHByZXNlbnRhdGlvblRpbWVPZmZzZXQgPSBhdHRyaWJ1dGVzLnByZXNlbnRhdGlvblRpbWVPZmZzZXQgfHwgMDtcbiAgICBjb25zdCBwcmVzZW50YXRpb25UaW1lID0gLy8gRXZlbiBpZiB0aGUgQHQgYXR0cmlidXRlIGlzIG5vdCBzcGVjaWZpZWQgZm9yIHRoZSBzZWdtZW50LCBzZWdtZW50LnRpbWUgaXNcbiAgICAvLyBjYWxjdWxhdGVkIGluIG1wZC1wYXJzZXIgcHJpb3IgdG8gdGhpcywgc28gaXQncyBhc3N1bWVkIHRvIGJlIGF2YWlsYWJsZS5cbiAgICBhdHRyaWJ1dGVzLnBlcmlvZFN0YXJ0ICsgKHNlZ21lbnQudGltZSAtIHByZXNlbnRhdGlvblRpbWVPZmZzZXQpIC8gdGltZXNjYWxlO1xuICAgIGNvbnN0IG1hcCA9IHtcbiAgICAgIHVyaSxcbiAgICAgIHRpbWVsaW5lOiBzZWdtZW50LnRpbWVsaW5lLFxuICAgICAgZHVyYXRpb246IHNlZ21lbnQuZHVyYXRpb24sXG4gICAgICByZXNvbHZlZFVyaTogcmVzb2x2ZVVybF9fZGVmYXVsdFsnZGVmYXVsdCddKGF0dHJpYnV0ZXMuYmFzZVVybCB8fCAnJywgdXJpKSxcbiAgICAgIG1hcDogbWFwU2VnbWVudCxcbiAgICAgIG51bWJlcjogc2VnbWVudC5udW1iZXIsXG4gICAgICBwcmVzZW50YXRpb25UaW1lXG4gICAgfTtcbiAgICByZXR1cm4gbWFwO1xuICB9KTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSA8U2VnbWVudFVybD4gKG9mIHR5cGUgVVJMVHlwZSBmcm9tIHRoZSBEQVNIIHNwZWMgNS4zLjkuMiBUYWJsZSAxNClcbiAqIHRvIGFuIG9iamVjdCB0aGF0IG1hdGNoZXMgdGhlIG91dHB1dCBvZiBhIHNlZ21lbnQgaW4gdmlkZW9qcy9tcGQtcGFyc2VyXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGF0dHJpYnV0ZXNcbiAqICAgT2JqZWN0IGNvbnRhaW5pbmcgYWxsIGluaGVyaXRlZCBhdHRyaWJ1dGVzIGZyb20gcGFyZW50IGVsZW1lbnRzIHdpdGggYXR0cmlidXRlXG4gKiAgIG5hbWVzIGFzIGtleXNcbiAqIEBwYXJhbSB7T2JqZWN0fSBzZWdtZW50VXJsXG4gKiAgIDxTZWdtZW50VVJMPiBub2RlIHRvIHRyYW5zbGF0ZSBpbnRvIGEgc2VnbWVudCBvYmplY3RcbiAqIEByZXR1cm4ge09iamVjdH0gdHJhbnNsYXRlZCBzZWdtZW50IG9iamVjdFxuICovXG5cbmNvbnN0IFNlZ21lbnRVUkxUb1NlZ21lbnRPYmplY3QgPSAoYXR0cmlidXRlcywgc2VnbWVudFVybCkgPT4ge1xuICBjb25zdCB7XG4gICAgYmFzZVVybCxcbiAgICBpbml0aWFsaXphdGlvbiA9IHt9XG4gIH0gPSBhdHRyaWJ1dGVzO1xuICBjb25zdCBpbml0U2VnbWVudCA9IHVybFR5cGVUb1NlZ21lbnQoe1xuICAgIGJhc2VVcmwsXG4gICAgc291cmNlOiBpbml0aWFsaXphdGlvbi5zb3VyY2VVUkwsXG4gICAgcmFuZ2U6IGluaXRpYWxpemF0aW9uLnJhbmdlXG4gIH0pO1xuICBjb25zdCBzZWdtZW50ID0gdXJsVHlwZVRvU2VnbWVudCh7XG4gICAgYmFzZVVybCxcbiAgICBzb3VyY2U6IHNlZ21lbnRVcmwubWVkaWEsXG4gICAgcmFuZ2U6IHNlZ21lbnRVcmwubWVkaWFSYW5nZVxuICB9KTtcbiAgc2VnbWVudC5tYXAgPSBpbml0U2VnbWVudDtcbiAgcmV0dXJuIHNlZ21lbnQ7XG59O1xuLyoqXG4gKiBHZW5lcmF0ZXMgYSBsaXN0IG9mIHNlZ21lbnRzIHVzaW5nIGluZm9ybWF0aW9uIHByb3ZpZGVkIGJ5IHRoZSBTZWdtZW50TGlzdCBlbGVtZW50XG4gKiBTZWdtZW50TGlzdCAoREFTSCBTUEVDIFNlY3Rpb24gNS4zLjkuMy4yKSBjb250YWlucyBhIHNldCBvZiA8U2VnbWVudFVSTD4gbm9kZXMuICBFYWNoXG4gKiBub2RlIHNob3VsZCBiZSB0cmFuc2xhdGVkIGludG8gc2VnbWVudC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gYXR0cmlidXRlc1xuICogICBPYmplY3QgY29udGFpbmluZyBhbGwgaW5oZXJpdGVkIGF0dHJpYnV0ZXMgZnJvbSBwYXJlbnQgZWxlbWVudHMgd2l0aCBhdHRyaWJ1dGVcbiAqICAgbmFtZXMgYXMga2V5c1xuICogQHBhcmFtIHtPYmplY3RbXXx1bmRlZmluZWR9IHNlZ21lbnRUaW1lbGluZVxuICogICAgICAgIExpc3Qgb2Ygb2JqZWN0cyByZXByZXNlbnRpbmcgdGhlIGF0dHJpYnV0ZXMgb2YgZWFjaCBTIGVsZW1lbnQgY29udGFpbmVkIHdpdGhpblxuICogICAgICAgIHRoZSBTZWdtZW50VGltZWxpbmUgZWxlbWVudFxuICogQHJldHVybiB7T2JqZWN0LjxBcnJheT59IGxpc3Qgb2Ygc2VnbWVudHNcbiAqL1xuXG5cbmNvbnN0IHNlZ21lbnRzRnJvbUxpc3QgPSAoYXR0cmlidXRlcywgc2VnbWVudFRpbWVsaW5lKSA9PiB7XG4gIGNvbnN0IHtcbiAgICBkdXJhdGlvbixcbiAgICBzZWdtZW50VXJscyA9IFtdLFxuICAgIHBlcmlvZFN0YXJ0XG4gIH0gPSBhdHRyaWJ1dGVzOyAvLyBQZXIgc3BlYyAoNS4zLjkuMi4xKSBubyB3YXkgdG8gZGV0ZXJtaW5lIHNlZ21lbnQgZHVyYXRpb24gT1JcbiAgLy8gaWYgYm90aCBTZWdtZW50VGltZWxpbmUgYW5kIEBkdXJhdGlvbiBhcmUgZGVmaW5lZCwgaXQgaXMgb3V0c2lkZSBvZiBzcGVjLlxuXG4gIGlmICghZHVyYXRpb24gJiYgIXNlZ21lbnRUaW1lbGluZSB8fCBkdXJhdGlvbiAmJiBzZWdtZW50VGltZWxpbmUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JzLlNFR01FTlRfVElNRV9VTlNQRUNJRklFRCk7XG4gIH1cblxuICBjb25zdCBzZWdtZW50VXJsTWFwID0gc2VnbWVudFVybHMubWFwKHNlZ21lbnRVcmxPYmplY3QgPT4gU2VnbWVudFVSTFRvU2VnbWVudE9iamVjdChhdHRyaWJ1dGVzLCBzZWdtZW50VXJsT2JqZWN0KSk7XG4gIGxldCBzZWdtZW50VGltZUluZm87XG5cbiAgaWYgKGR1cmF0aW9uKSB7XG4gICAgc2VnbWVudFRpbWVJbmZvID0gcGFyc2VCeUR1cmF0aW9uKGF0dHJpYnV0ZXMpO1xuICB9XG5cbiAgaWYgKHNlZ21lbnRUaW1lbGluZSkge1xuICAgIHNlZ21lbnRUaW1lSW5mbyA9IHBhcnNlQnlUaW1lbGluZShhdHRyaWJ1dGVzLCBzZWdtZW50VGltZWxpbmUpO1xuICB9XG5cbiAgY29uc3Qgc2VnbWVudHMgPSBzZWdtZW50VGltZUluZm8ubWFwKChzZWdtZW50VGltZSwgaW5kZXgpID0+IHtcbiAgICBpZiAoc2VnbWVudFVybE1hcFtpbmRleF0pIHtcbiAgICAgIGNvbnN0IHNlZ21lbnQgPSBzZWdtZW50VXJsTWFwW2luZGV4XTsgLy8gU2VlIERBU0ggc3BlYyBzZWN0aW9uIDUuMy45LjIuMlxuICAgICAgLy8gLSBpZiB0aW1lc2NhbGUgaXNuJ3QgcHJlc2VudCBvbiBhbnkgbGV2ZWwsIGRlZmF1bHQgdG8gMS5cblxuICAgICAgY29uc3QgdGltZXNjYWxlID0gYXR0cmlidXRlcy50aW1lc2NhbGUgfHwgMTsgLy8gLSBpZiBwcmVzZW50YXRpb25UaW1lT2Zmc2V0IGlzbid0IHByZXNlbnQgb24gYW55IGxldmVsLCBkZWZhdWx0IHRvIDBcblxuICAgICAgY29uc3QgcHJlc2VudGF0aW9uVGltZU9mZnNldCA9IGF0dHJpYnV0ZXMucHJlc2VudGF0aW9uVGltZU9mZnNldCB8fCAwO1xuICAgICAgc2VnbWVudC50aW1lbGluZSA9IHNlZ21lbnRUaW1lLnRpbWVsaW5lO1xuICAgICAgc2VnbWVudC5kdXJhdGlvbiA9IHNlZ21lbnRUaW1lLmR1cmF0aW9uO1xuICAgICAgc2VnbWVudC5udW1iZXIgPSBzZWdtZW50VGltZS5udW1iZXI7XG4gICAgICBzZWdtZW50LnByZXNlbnRhdGlvblRpbWUgPSBwZXJpb2RTdGFydCArIChzZWdtZW50VGltZS50aW1lIC0gcHJlc2VudGF0aW9uVGltZU9mZnNldCkgLyB0aW1lc2NhbGU7XG4gICAgICByZXR1cm4gc2VnbWVudDtcbiAgICB9IC8vIFNpbmNlIHdlJ3JlIG1hcHBpbmcgd2Ugc2hvdWxkIGdldCByaWQgb2YgYW55IGJsYW5rIHNlZ21lbnRzIChpbiBjYXNlXG4gICAgLy8gdGhlIGdpdmVuIFNlZ21lbnRUaW1lbGluZSBpcyBoYW5kbGluZyBmb3IgbW9yZSBlbGVtZW50cyB0aGFuIHdlIGhhdmVcbiAgICAvLyBTZWdtZW50VVJMcyBmb3IpLlxuXG4gIH0pLmZpbHRlcihzZWdtZW50ID0+IHNlZ21lbnQpO1xuICByZXR1cm4gc2VnbWVudHM7XG59O1xuXG5jb25zdCBnZW5lcmF0ZVNlZ21lbnRzID0gKHtcbiAgYXR0cmlidXRlcyxcbiAgc2VnbWVudEluZm9cbn0pID0+IHtcbiAgbGV0IHNlZ21lbnRBdHRyaWJ1dGVzO1xuICBsZXQgc2VnbWVudHNGbjtcblxuICBpZiAoc2VnbWVudEluZm8udGVtcGxhdGUpIHtcbiAgICBzZWdtZW50c0ZuID0gc2VnbWVudHNGcm9tVGVtcGxhdGU7XG4gICAgc2VnbWVudEF0dHJpYnV0ZXMgPSBtZXJnZShhdHRyaWJ1dGVzLCBzZWdtZW50SW5mby50ZW1wbGF0ZSk7XG4gIH0gZWxzZSBpZiAoc2VnbWVudEluZm8uYmFzZSkge1xuICAgIHNlZ21lbnRzRm4gPSBzZWdtZW50c0Zyb21CYXNlO1xuICAgIHNlZ21lbnRBdHRyaWJ1dGVzID0gbWVyZ2UoYXR0cmlidXRlcywgc2VnbWVudEluZm8uYmFzZSk7XG4gIH0gZWxzZSBpZiAoc2VnbWVudEluZm8ubGlzdCkge1xuICAgIHNlZ21lbnRzRm4gPSBzZWdtZW50c0Zyb21MaXN0O1xuICAgIHNlZ21lbnRBdHRyaWJ1dGVzID0gbWVyZ2UoYXR0cmlidXRlcywgc2VnbWVudEluZm8ubGlzdCk7XG4gIH1cblxuICBjb25zdCBzZWdtZW50c0luZm8gPSB7XG4gICAgYXR0cmlidXRlc1xuICB9O1xuXG4gIGlmICghc2VnbWVudHNGbikge1xuICAgIHJldHVybiBzZWdtZW50c0luZm87XG4gIH1cblxuICBjb25zdCBzZWdtZW50cyA9IHNlZ21lbnRzRm4oc2VnbWVudEF0dHJpYnV0ZXMsIHNlZ21lbnRJbmZvLnNlZ21lbnRUaW1lbGluZSk7IC8vIFRoZSBAZHVyYXRpb24gYXR0cmlidXRlIHdpbGwgYmUgdXNlZCB0byBkZXRlcm1pbiB0aGUgcGxheWxpc3QncyB0YXJnZXREdXJhdGlvbiB3aGljaFxuICAvLyBtdXN0IGJlIGluIHNlY29uZHMuIFNpbmNlIHdlJ3ZlIGdlbmVyYXRlZCB0aGUgc2VnbWVudCBsaXN0LCB3ZSBubyBsb25nZXIgbmVlZFxuICAvLyBAZHVyYXRpb24gdG8gYmUgaW4gQHRpbWVzY2FsZSB1bml0cywgc28gd2UgY2FuIGNvbnZlcnQgaXQgaGVyZS5cblxuICBpZiAoc2VnbWVudEF0dHJpYnV0ZXMuZHVyYXRpb24pIHtcbiAgICBjb25zdCB7XG4gICAgICBkdXJhdGlvbixcbiAgICAgIHRpbWVzY2FsZSA9IDFcbiAgICB9ID0gc2VnbWVudEF0dHJpYnV0ZXM7XG4gICAgc2VnbWVudEF0dHJpYnV0ZXMuZHVyYXRpb24gPSBkdXJhdGlvbiAvIHRpbWVzY2FsZTtcbiAgfSBlbHNlIGlmIChzZWdtZW50cy5sZW5ndGgpIHtcbiAgICAvLyBpZiB0aGVyZSBpcyBubyBAZHVyYXRpb24gYXR0cmlidXRlLCB1c2UgdGhlIGxhcmdlc3Qgc2VnbWVudCBkdXJhdGlvbiBhc1xuICAgIC8vIGFzIHRhcmdldCBkdXJhdGlvblxuICAgIHNlZ21lbnRBdHRyaWJ1dGVzLmR1cmF0aW9uID0gc2VnbWVudHMucmVkdWNlKChtYXgsIHNlZ21lbnQpID0+IHtcbiAgICAgIHJldHVybiBNYXRoLm1heChtYXgsIE1hdGguY2VpbChzZWdtZW50LmR1cmF0aW9uKSk7XG4gICAgfSwgMCk7XG4gIH0gZWxzZSB7XG4gICAgc2VnbWVudEF0dHJpYnV0ZXMuZHVyYXRpb24gPSAwO1xuICB9XG5cbiAgc2VnbWVudHNJbmZvLmF0dHJpYnV0ZXMgPSBzZWdtZW50QXR0cmlidXRlcztcbiAgc2VnbWVudHNJbmZvLnNlZ21lbnRzID0gc2VnbWVudHM7IC8vIFRoaXMgaXMgYSBzaWR4IGJveCB3aXRob3V0IGFjdHVhbCBzZWdtZW50IGluZm9ybWF0aW9uXG5cbiAgaWYgKHNlZ21lbnRJbmZvLmJhc2UgJiYgc2VnbWVudEF0dHJpYnV0ZXMuaW5kZXhSYW5nZSkge1xuICAgIHNlZ21lbnRzSW5mby5zaWR4ID0gc2VnbWVudHNbMF07XG4gICAgc2VnbWVudHNJbmZvLnNlZ21lbnRzID0gW107XG4gIH1cblxuICByZXR1cm4gc2VnbWVudHNJbmZvO1xufTtcbmNvbnN0IHRvUGxheWxpc3RzID0gcmVwcmVzZW50YXRpb25zID0+IHJlcHJlc2VudGF0aW9ucy5tYXAoZ2VuZXJhdGVTZWdtZW50cyk7XG5cbmNvbnN0IGZpbmRDaGlsZHJlbiA9IChlbGVtZW50LCBuYW1lKSA9PiBmcm9tKGVsZW1lbnQuY2hpbGROb2RlcykuZmlsdGVyKCh7XG4gIHRhZ05hbWVcbn0pID0+IHRhZ05hbWUgPT09IG5hbWUpO1xuY29uc3QgZ2V0Q29udGVudCA9IGVsZW1lbnQgPT4gZWxlbWVudC50ZXh0Q29udGVudC50cmltKCk7XG5cbi8qKlxuICogQ29udmVydHMgdGhlIHByb3ZpZGVkIHN0cmluZyB0aGF0IG1heSBjb250YWluIGEgZGl2aXNpb24gb3BlcmF0aW9uIHRvIGEgbnVtYmVyLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSAtIHRoZSBwcm92aWRlZCBzdHJpbmcgdmFsdWVcbiAqXG4gKiBAcmV0dXJuIHtudW1iZXJ9IHRoZSBwYXJzZWQgc3RyaW5nIHZhbHVlXG4gKi9cbmNvbnN0IHBhcnNlRGl2aXNpb25WYWx1ZSA9IHZhbHVlID0+IHtcbiAgcmV0dXJuIHBhcnNlRmxvYXQodmFsdWUuc3BsaXQoJy8nKS5yZWR1Y2UoKHByZXYsIGN1cnJlbnQpID0+IHByZXYgLyBjdXJyZW50KSk7XG59O1xuXG5jb25zdCBwYXJzZUR1cmF0aW9uID0gc3RyID0+IHtcbiAgY29uc3QgU0VDT05EU19JTl9ZRUFSID0gMzY1ICogMjQgKiA2MCAqIDYwO1xuICBjb25zdCBTRUNPTkRTX0lOX01PTlRIID0gMzAgKiAyNCAqIDYwICogNjA7XG4gIGNvbnN0IFNFQ09ORFNfSU5fREFZID0gMjQgKiA2MCAqIDYwO1xuICBjb25zdCBTRUNPTkRTX0lOX0hPVVIgPSA2MCAqIDYwO1xuICBjb25zdCBTRUNPTkRTX0lOX01JTiA9IDYwOyAvLyBQMTBZMTBNMTBEVDEwSDEwTTEwLjFTXG5cbiAgY29uc3QgZHVyYXRpb25SZWdleCA9IC9QKD86KFxcZCopWSk/KD86KFxcZCopTSk/KD86KFxcZCopRCk/KD86VCg/OihcXGQqKUgpPyg/OihcXGQqKU0pPyg/OihbXFxkLl0qKVMpPyk/LztcbiAgY29uc3QgbWF0Y2ggPSBkdXJhdGlvblJlZ2V4LmV4ZWMoc3RyKTtcblxuICBpZiAoIW1hdGNoKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICBjb25zdCBbeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmRdID0gbWF0Y2guc2xpY2UoMSk7XG4gIHJldHVybiBwYXJzZUZsb2F0KHllYXIgfHwgMCkgKiBTRUNPTkRTX0lOX1lFQVIgKyBwYXJzZUZsb2F0KG1vbnRoIHx8IDApICogU0VDT05EU19JTl9NT05USCArIHBhcnNlRmxvYXQoZGF5IHx8IDApICogU0VDT05EU19JTl9EQVkgKyBwYXJzZUZsb2F0KGhvdXIgfHwgMCkgKiBTRUNPTkRTX0lOX0hPVVIgKyBwYXJzZUZsb2F0KG1pbnV0ZSB8fCAwKSAqIFNFQ09ORFNfSU5fTUlOICsgcGFyc2VGbG9hdChzZWNvbmQgfHwgMCk7XG59O1xuY29uc3QgcGFyc2VEYXRlID0gc3RyID0+IHtcbiAgLy8gRGF0ZSBmb3JtYXQgd2l0aG91dCB0aW1lem9uZSBhY2NvcmRpbmcgdG8gSVNPIDg2MDFcbiAgLy8gWVlZLU1NLUREVGhoOm1tOnNzLnNzc3Nzc1xuICBjb25zdCBkYXRlUmVnZXggPSAvXlxcZCstXFxkKy1cXGQrVFxcZCs6XFxkKzpcXGQrKFxcLlxcZCspPyQvOyAvLyBJZiB0aGUgZGF0ZSBzdHJpbmcgZG9lcyBub3Qgc3BlY2lmaXkgYSB0aW1lem9uZSwgd2UgbXVzdCBzcGVjaWZpeSBVVEMuIFRoaXMgaXNcbiAgLy8gZXhwcmVzc2VkIGJ5IGVuZGluZyB3aXRoICdaJ1xuXG4gIGlmIChkYXRlUmVnZXgudGVzdChzdHIpKSB7XG4gICAgc3RyICs9ICdaJztcbiAgfVxuXG4gIHJldHVybiBEYXRlLnBhcnNlKHN0cik7XG59O1xuXG5jb25zdCBwYXJzZXJzID0ge1xuICAvKipcbiAgICogU3BlY2lmaWVzIHRoZSBkdXJhdGlvbiBvZiB0aGUgZW50aXJlIE1lZGlhIFByZXNlbnRhdGlvbi4gRm9ybWF0IGlzIGEgZHVyYXRpb24gc3RyaW5nXG4gICAqIGFzIHNwZWNpZmllZCBpbiBJU08gODYwMVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAgICogICAgICAgIHZhbHVlIG9mIGF0dHJpYnV0ZSBhcyBhIHN0cmluZ1xuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqICAgICAgICAgVGhlIGR1cmF0aW9uIGluIHNlY29uZHNcbiAgICovXG4gIG1lZGlhUHJlc2VudGF0aW9uRHVyYXRpb24odmFsdWUpIHtcbiAgICByZXR1cm4gcGFyc2VEdXJhdGlvbih2YWx1ZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNwZWNpZmllcyB0aGUgU2VnbWVudCBhdmFpbGFiaWxpdHkgc3RhcnQgdGltZSBmb3IgYWxsIFNlZ21lbnRzIHJlZmVycmVkIHRvIGluIHRoaXNcbiAgICogTVBELiBGb3IgYSBkeW5hbWljIG1hbmlmZXN0LCBpdCBzcGVjaWZpZXMgdGhlIGFuY2hvciBmb3IgdGhlIGVhcmxpZXN0IGF2YWlsYWJpbGl0eVxuICAgKiB0aW1lLiBGb3JtYXQgaXMgYSBkYXRlIHN0cmluZyBhcyBzcGVjaWZpZWQgaW4gSVNPIDg2MDFcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gICAqICAgICAgICB2YWx1ZSBvZiBhdHRyaWJ1dGUgYXMgYSBzdHJpbmdcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKiAgICAgICAgIFRoZSBkYXRlIGFzIHNlY29uZHMgZnJvbSB1bml4IGVwb2NoXG4gICAqL1xuICBhdmFpbGFiaWxpdHlTdGFydFRpbWUodmFsdWUpIHtcbiAgICByZXR1cm4gcGFyc2VEYXRlKHZhbHVlKSAvIDEwMDA7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNwZWNpZmllcyB0aGUgc21hbGxlc3QgcGVyaW9kIGJldHdlZW4gcG90ZW50aWFsIGNoYW5nZXMgdG8gdGhlIE1QRC4gRm9ybWF0IGlzIGFcbiAgICogZHVyYXRpb24gc3RyaW5nIGFzIHNwZWNpZmllZCBpbiBJU08gODYwMVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAgICogICAgICAgIHZhbHVlIG9mIGF0dHJpYnV0ZSBhcyBhIHN0cmluZ1xuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqICAgICAgICAgVGhlIGR1cmF0aW9uIGluIHNlY29uZHNcbiAgICovXG4gIG1pbmltdW1VcGRhdGVQZXJpb2QodmFsdWUpIHtcbiAgICByZXR1cm4gcGFyc2VEdXJhdGlvbih2YWx1ZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNwZWNpZmllcyB0aGUgc3VnZ2VzdGVkIHByZXNlbnRhdGlvbiBkZWxheS4gRm9ybWF0IGlzIGFcbiAgICogZHVyYXRpb24gc3RyaW5nIGFzIHNwZWNpZmllZCBpbiBJU08gODYwMVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAgICogICAgICAgIHZhbHVlIG9mIGF0dHJpYnV0ZSBhcyBhIHN0cmluZ1xuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqICAgICAgICAgVGhlIGR1cmF0aW9uIGluIHNlY29uZHNcbiAgICovXG4gIHN1Z2dlc3RlZFByZXNlbnRhdGlvbkRlbGF5KHZhbHVlKSB7XG4gICAgcmV0dXJuIHBhcnNlRHVyYXRpb24odmFsdWUpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBzcGVjaWZpY2VzIHRoZSB0eXBlIG9mIG1wZC4gQ2FuIGJlIGVpdGhlciBcInN0YXRpY1wiIG9yIFwiZHluYW1pY1wiXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICAgKiAgICAgICAgdmFsdWUgb2YgYXR0cmlidXRlIGFzIGEgc3RyaW5nXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICogICAgICAgICBUaGUgdHlwZSBhcyBhIHN0cmluZ1xuICAgKi9cbiAgdHlwZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfSxcblxuICAvKipcbiAgICogU3BlY2lmaWVzIHRoZSBkdXJhdGlvbiBvZiB0aGUgc21hbGxlc3QgdGltZSBzaGlmdGluZyBidWZmZXIgZm9yIGFueSBSZXByZXNlbnRhdGlvblxuICAgKiBpbiB0aGUgTVBELiBGb3JtYXQgaXMgYSBkdXJhdGlvbiBzdHJpbmcgYXMgc3BlY2lmaWVkIGluIElTTyA4NjAxXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICAgKiAgICAgICAgdmFsdWUgb2YgYXR0cmlidXRlIGFzIGEgc3RyaW5nXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICogICAgICAgICBUaGUgZHVyYXRpb24gaW4gc2Vjb25kc1xuICAgKi9cbiAgdGltZVNoaWZ0QnVmZmVyRGVwdGgodmFsdWUpIHtcbiAgICByZXR1cm4gcGFyc2VEdXJhdGlvbih2YWx1ZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNwZWNpZmllcyB0aGUgUGVyaW9kU3RhcnQgdGltZSBvZiB0aGUgUGVyaW9kIHJlbGF0aXZlIHRvIHRoZSBhdmFpbGFiaWxpdHlTdGFydHRpbWUuXG4gICAqIEZvcm1hdCBpcyBhIGR1cmF0aW9uIHN0cmluZyBhcyBzcGVjaWZpZWQgaW4gSVNPIDg2MDFcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gICAqICAgICAgICB2YWx1ZSBvZiBhdHRyaWJ1dGUgYXMgYSBzdHJpbmdcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKiAgICAgICAgIFRoZSBkdXJhdGlvbiBpbiBzZWNvbmRzXG4gICAqL1xuICBzdGFydCh2YWx1ZSkge1xuICAgIHJldHVybiBwYXJzZUR1cmF0aW9uKHZhbHVlKTtcbiAgfSxcblxuICAvKipcbiAgICogU3BlY2lmaWVzIHRoZSB3aWR0aCBvZiB0aGUgdmlzdWFsIHByZXNlbnRhdGlvblxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAgICogICAgICAgIHZhbHVlIG9mIGF0dHJpYnV0ZSBhcyBhIHN0cmluZ1xuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqICAgICAgICAgVGhlIHBhcnNlZCB3aWR0aFxuICAgKi9cbiAgd2lkdGgodmFsdWUpIHtcbiAgICByZXR1cm4gcGFyc2VJbnQodmFsdWUsIDEwKTtcbiAgfSxcblxuICAvKipcbiAgICogU3BlY2lmaWVzIHRoZSBoZWlnaHQgb2YgdGhlIHZpc3VhbCBwcmVzZW50YXRpb25cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gICAqICAgICAgICB2YWx1ZSBvZiBhdHRyaWJ1dGUgYXMgYSBzdHJpbmdcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKiAgICAgICAgIFRoZSBwYXJzZWQgaGVpZ2h0XG4gICAqL1xuICBoZWlnaHQodmFsdWUpIHtcbiAgICByZXR1cm4gcGFyc2VJbnQodmFsdWUsIDEwKTtcbiAgfSxcblxuICAvKipcbiAgICogU3BlY2lmaWVzIHRoZSBiaXRyYXRlIG9mIHRoZSByZXByZXNlbnRhdGlvblxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAgICogICAgICAgIHZhbHVlIG9mIGF0dHJpYnV0ZSBhcyBhIHN0cmluZ1xuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqICAgICAgICAgVGhlIHBhcnNlZCBiYW5kd2lkdGhcbiAgICovXG4gIGJhbmR3aWR0aCh2YWx1ZSkge1xuICAgIHJldHVybiBwYXJzZUludCh2YWx1ZSwgMTApO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTcGVjaWZpZXMgdGhlIGZyYW1lIHJhdGUgb2YgdGhlIHJlcHJlc2VudGF0aW9uXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICAgKiAgICAgICAgdmFsdWUgb2YgYXR0cmlidXRlIGFzIGEgc3RyaW5nXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICogICAgICAgICBUaGUgcGFyc2VkIGZyYW1lIHJhdGVcbiAgICovXG4gIGZyYW1lUmF0ZSh2YWx1ZSkge1xuICAgIHJldHVybiBwYXJzZURpdmlzaW9uVmFsdWUodmFsdWUpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTcGVjaWZpZXMgdGhlIG51bWJlciBvZiB0aGUgZmlyc3QgTWVkaWEgU2VnbWVudCBpbiB0aGlzIFJlcHJlc2VudGF0aW9uIGluIHRoZSBQZXJpb2RcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gICAqICAgICAgICB2YWx1ZSBvZiBhdHRyaWJ1dGUgYXMgYSBzdHJpbmdcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKiAgICAgICAgIFRoZSBwYXJzZWQgbnVtYmVyXG4gICAqL1xuICBzdGFydE51bWJlcih2YWx1ZSkge1xuICAgIHJldHVybiBwYXJzZUludCh2YWx1ZSwgMTApO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTcGVjaWZpZXMgdGhlIHRpbWVzY2FsZSBpbiB1bml0cyBwZXIgc2Vjb25kc1xuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAgICogICAgICAgIHZhbHVlIG9mIGF0dHJpYnV0ZSBhcyBhIHN0cmluZ1xuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqICAgICAgICAgVGhlIHBhcnNlZCB0aW1lc2NhbGVcbiAgICovXG4gIHRpbWVzY2FsZSh2YWx1ZSkge1xuICAgIHJldHVybiBwYXJzZUludCh2YWx1ZSwgMTApO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTcGVjaWZpZXMgdGhlIHByZXNlbnRhdGlvblRpbWVPZmZzZXQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICAgKiAgICAgICAgdmFsdWUgb2YgdGhlIGF0dHJpYnV0ZSBhcyBhIHN0cmluZ1xuICAgKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqICAgICAgICAgVGhlIHBhcnNlZCBwcmVzZW50YXRpb25UaW1lT2Zmc2V0XG4gICAqL1xuICBwcmVzZW50YXRpb25UaW1lT2Zmc2V0KHZhbHVlKSB7XG4gICAgcmV0dXJuIHBhcnNlSW50KHZhbHVlLCAxMCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNwZWNpZmllcyB0aGUgY29uc3RhbnQgYXBwcm94aW1hdGUgU2VnbWVudCBkdXJhdGlvblxuICAgKiBOT1RFOiBUaGUgPFBlcmlvZD4gZWxlbWVudCBhbHNvIGNvbnRhaW5zIGFuIEBkdXJhdGlvbiBhdHRyaWJ1dGUuIFRoaXMgZHVyYXRpb25cbiAgICogICAgICAgc3BlY2lmaWVzIHRoZSBkdXJhdGlvbiBvZiB0aGUgUGVyaW9kLiBUaGlzIGF0dHJpYnV0ZSBpcyBjdXJyZW50bHkgbm90XG4gICAqICAgICAgIHN1cHBvcnRlZCBieSB0aGUgcmVzdCBvZiB0aGUgcGFyc2VyLCBob3dldmVyIHdlIHN0aWxsIGNoZWNrIGZvciBpdCB0byBwcmV2ZW50XG4gICAqICAgICAgIGVycm9ycy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gICAqICAgICAgICB2YWx1ZSBvZiBhdHRyaWJ1dGUgYXMgYSBzdHJpbmdcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKiAgICAgICAgIFRoZSBwYXJzZWQgZHVyYXRpb25cbiAgICovXG4gIGR1cmF0aW9uKHZhbHVlKSB7XG4gICAgY29uc3QgcGFyc2VkVmFsdWUgPSBwYXJzZUludCh2YWx1ZSwgMTApO1xuXG4gICAgaWYgKGlzTmFOKHBhcnNlZFZhbHVlKSkge1xuICAgICAgcmV0dXJuIHBhcnNlRHVyYXRpb24odmFsdWUpO1xuICAgIH1cblxuICAgIHJldHVybiBwYXJzZWRWYWx1ZTtcbiAgfSxcblxuICAvKipcbiAgICogU3BlY2lmaWVzIHRoZSBTZWdtZW50IGR1cmF0aW9uLCBpbiB1bml0cyBvZiB0aGUgdmFsdWUgb2YgdGhlIEB0aW1lc2NhbGUuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICAgKiAgICAgICAgdmFsdWUgb2YgYXR0cmlidXRlIGFzIGEgc3RyaW5nXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICogICAgICAgICBUaGUgcGFyc2VkIGR1cmF0aW9uXG4gICAqL1xuICBkKHZhbHVlKSB7XG4gICAgcmV0dXJuIHBhcnNlSW50KHZhbHVlLCAxMCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNwZWNpZmllcyB0aGUgTVBEIHN0YXJ0IHRpbWUsIGluIEB0aW1lc2NhbGUgdW5pdHMsIHRoZSBmaXJzdCBTZWdtZW50IGluIHRoZSBzZXJpZXNcbiAgICogc3RhcnRzIHJlbGF0aXZlIHRvIHRoZSBiZWdpbm5pbmcgb2YgdGhlIFBlcmlvZFxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAgICogICAgICAgIHZhbHVlIG9mIGF0dHJpYnV0ZSBhcyBhIHN0cmluZ1xuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqICAgICAgICAgVGhlIHBhcnNlZCB0aW1lXG4gICAqL1xuICB0KHZhbHVlKSB7XG4gICAgcmV0dXJuIHBhcnNlSW50KHZhbHVlLCAxMCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNwZWNpZmllcyB0aGUgcmVwZWF0IGNvdW50IG9mIHRoZSBudW1iZXIgb2YgZm9sbG93aW5nIGNvbnRpZ3VvdXMgU2VnbWVudHMgd2l0aCB0aGVcbiAgICogc2FtZSBkdXJhdGlvbiBleHByZXNzZWQgYnkgdGhlIHZhbHVlIG9mIEBkXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICAgKiAgICAgICAgdmFsdWUgb2YgYXR0cmlidXRlIGFzIGEgc3RyaW5nXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICogICAgICAgICBUaGUgcGFyc2VkIG51bWJlclxuICAgKi9cbiAgcih2YWx1ZSkge1xuICAgIHJldHVybiBwYXJzZUludCh2YWx1ZSwgMTApO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTcGVjaWZpZXMgdGhlIHByZXNlbnRhdGlvblRpbWUuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICAgKiAgICAgICAgdmFsdWUgb2YgdGhlIGF0dHJpYnV0ZSBhcyBhIHN0cmluZ1xuICAgKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqICAgICAgICAgVGhlIHBhcnNlZCBwcmVzZW50YXRpb25UaW1lXG4gICAqL1xuICBwcmVzZW50YXRpb25UaW1lKHZhbHVlKSB7XG4gICAgcmV0dXJuIHBhcnNlSW50KHZhbHVlLCAxMCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIERlZmF1bHQgcGFyc2VyIGZvciBhbGwgb3RoZXIgYXR0cmlidXRlcy4gQWN0cyBhcyBhIG5vLW9wIGFuZCBqdXN0IHJldHVybnMgdGhlIHZhbHVlXG4gICAqIGFzIGEgc3RyaW5nXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICAgKiAgICAgICAgdmFsdWUgb2YgYXR0cmlidXRlIGFzIGEgc3RyaW5nXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICogICAgICAgICBVbnBhcnNlZCB2YWx1ZVxuICAgKi9cbiAgREVGQVVMVCh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG59O1xuLyoqXG4gKiBHZXRzIGFsbCB0aGUgYXR0cmlidXRlcyBhbmQgdmFsdWVzIG9mIHRoZSBwcm92aWRlZCBub2RlLCBwYXJzZXMgYXR0cmlidXRlcyB3aXRoIGtub3duXG4gKiB0eXBlcywgYW5kIHJldHVybnMgYW4gb2JqZWN0IHdpdGggYXR0cmlidXRlIG5hbWVzIG1hcHBlZCB0byB2YWx1ZXMuXG4gKlxuICogQHBhcmFtIHtOb2RlfSBlbFxuICogICAgICAgIFRoZSBub2RlIHRvIHBhcnNlIGF0dHJpYnV0ZXMgZnJvbVxuICogQHJldHVybiB7T2JqZWN0fVxuICogICAgICAgICBPYmplY3Qgd2l0aCBhbGwgYXR0cmlidXRlcyBvZiBlbCBwYXJzZWRcbiAqL1xuXG5jb25zdCBwYXJzZUF0dHJpYnV0ZXMgPSBlbCA9PiB7XG4gIGlmICghKGVsICYmIGVsLmF0dHJpYnV0ZXMpKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG5cbiAgcmV0dXJuIGZyb20oZWwuYXR0cmlidXRlcykucmVkdWNlKChhLCBlKSA9PiB7XG4gICAgY29uc3QgcGFyc2VGbiA9IHBhcnNlcnNbZS5uYW1lXSB8fCBwYXJzZXJzLkRFRkFVTFQ7XG4gICAgYVtlLm5hbWVdID0gcGFyc2VGbihlLnZhbHVlKTtcbiAgICByZXR1cm4gYTtcbiAgfSwge30pO1xufTtcblxuY29uc3Qga2V5U3lzdGVtc01hcCA9IHtcbiAgJ3Vybjp1dWlkOjEwNzdlZmVjLWMwYjItNGQwMi1hY2UzLTNjMWU1MmUyZmI0Yic6ICdvcmcudzMuY2xlYXJrZXknLFxuICAndXJuOnV1aWQ6ZWRlZjhiYTktNzlkNi00YWNlLWEzYzgtMjdkY2Q1MWQyMWVkJzogJ2NvbS53aWRldmluZS5hbHBoYScsXG4gICd1cm46dXVpZDo5YTA0ZjA3OS05ODQwLTQyODYtYWI5Mi1lNjViZTA4ODVmOTUnOiAnY29tLm1pY3Jvc29mdC5wbGF5cmVhZHknLFxuICAndXJuOnV1aWQ6ZjIzOWU3NjktZWZhMy00ODUwLTljMTYtYTkwM2M2OTMyZWZiJzogJ2NvbS5hZG9iZS5wcmltZXRpbWUnLFxuICAvLyBJU09fSUVDIDIzMDA5LTFfMjAyMiA1LjguNS4yLjIgVGhlIG1wNCBQcm90ZWN0aW9uIFNjaGVtZVxuICAndXJuOm1wZWc6ZGFzaDptcDRwcm90ZWN0aW9uOjIwMTEnOiAnbXA0cHJvdGVjdGlvbidcbn07XG4vKipcbiAqIEJ1aWxkcyBhIGxpc3Qgb2YgdXJscyB0aGF0IGlzIHRoZSBwcm9kdWN0IG9mIHRoZSByZWZlcmVuY2UgdXJscyBhbmQgQmFzZVVSTCB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0ge09iamVjdFtdfSByZWZlcmVuY2VzXG4gKiAgICAgICAgTGlzdCBvZiBvYmplY3RzIGNvbnRhaW5pbmcgdGhlIHJlZmVyZW5jZSBVUkwgYXMgd2VsbCBhcyBpdHMgYXR0cmlidXRlc1xuICogQHBhcmFtIHtOb2RlW119IGJhc2VVcmxFbGVtZW50c1xuICogICAgICAgIExpc3Qgb2YgQmFzZVVSTCBub2RlcyBmcm9tIHRoZSBtcGRcbiAqIEByZXR1cm4ge09iamVjdFtdfVxuICogICAgICAgICBMaXN0IG9mIG9iamVjdHMgd2l0aCByZXNvbHZlZCB1cmxzIGFuZCBhdHRyaWJ1dGVzXG4gKi9cblxuY29uc3QgYnVpbGRCYXNlVXJscyA9IChyZWZlcmVuY2VzLCBiYXNlVXJsRWxlbWVudHMpID0+IHtcbiAgaWYgKCFiYXNlVXJsRWxlbWVudHMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHJlZmVyZW5jZXM7XG4gIH1cblxuICByZXR1cm4gZmxhdHRlbihyZWZlcmVuY2VzLm1hcChmdW5jdGlvbiAocmVmZXJlbmNlKSB7XG4gICAgcmV0dXJuIGJhc2VVcmxFbGVtZW50cy5tYXAoZnVuY3Rpb24gKGJhc2VVcmxFbGVtZW50KSB7XG4gICAgICBjb25zdCBpbml0aWFsQmFzZVVybCA9IGdldENvbnRlbnQoYmFzZVVybEVsZW1lbnQpO1xuICAgICAgY29uc3QgcmVzb2x2ZWRCYXNlVXJsID0gcmVzb2x2ZVVybF9fZGVmYXVsdFsnZGVmYXVsdCddKHJlZmVyZW5jZS5iYXNlVXJsLCBpbml0aWFsQmFzZVVybCk7XG4gICAgICBjb25zdCBmaW5hbEJhc2VVcmwgPSBtZXJnZShwYXJzZUF0dHJpYnV0ZXMoYmFzZVVybEVsZW1lbnQpLCB7XG4gICAgICAgIGJhc2VVcmw6IHJlc29sdmVkQmFzZVVybFxuICAgICAgfSk7IC8vIElmIHRoZSBVUkwgaXMgcmVzb2x2ZWQsIHdlIHdhbnQgdG8gZ2V0IHRoZSBzZXJ2aWNlTG9jYXRpb24gZnJvbSB0aGUgcmVmZXJlbmNlXG4gICAgICAvLyBhc3N1bWluZyB0aGVyZSBpcyBubyBzZXJ2aWNlTG9jYXRpb24gb24gdGhlIGluaXRpYWxCYXNlVXJsXG5cbiAgICAgIGlmIChyZXNvbHZlZEJhc2VVcmwgIT09IGluaXRpYWxCYXNlVXJsICYmICFmaW5hbEJhc2VVcmwuc2VydmljZUxvY2F0aW9uICYmIHJlZmVyZW5jZS5zZXJ2aWNlTG9jYXRpb24pIHtcbiAgICAgICAgZmluYWxCYXNlVXJsLnNlcnZpY2VMb2NhdGlvbiA9IHJlZmVyZW5jZS5zZXJ2aWNlTG9jYXRpb247XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmaW5hbEJhc2VVcmw7XG4gICAgfSk7XG4gIH0pKTtcbn07XG4vKipcbiAqIENvbnRhaW5zIGFsbCBTZWdtZW50IGluZm9ybWF0aW9uIGZvciBpdHMgY29udGFpbmluZyBBZGFwdGF0aW9uU2V0XG4gKlxuICogQHR5cGVkZWYge09iamVjdH0gU2VnbWVudEluZm9ybWF0aW9uXG4gKiBAcHJvcGVydHkge09iamVjdHx1bmRlZmluZWR9IHRlbXBsYXRlXG4gKiAgICAgICAgICAgQ29udGFpbnMgdGhlIGF0dHJpYnV0ZXMgZm9yIHRoZSBTZWdtZW50VGVtcGxhdGUgbm9kZVxuICogQHByb3BlcnR5IHtPYmplY3RbXXx1bmRlZmluZWR9IHNlZ21lbnRUaW1lbGluZVxuICogICAgICAgICAgIENvbnRhaW5zIGEgbGlzdCBvZiBhdHJyaWJ1dGVzIGZvciBlYWNoIFMgbm9kZSB3aXRoaW4gdGhlIFNlZ21lbnRUaW1lbGluZSBub2RlXG4gKiBAcHJvcGVydHkge09iamVjdHx1bmRlZmluZWR9IGxpc3RcbiAqICAgICAgICAgICBDb250YWlucyB0aGUgYXR0cmlidXRlcyBmb3IgdGhlIFNlZ21lbnRMaXN0IG5vZGVcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fHVuZGVmaW5lZH0gYmFzZVxuICogICAgICAgICAgIENvbnRhaW5zIHRoZSBhdHRyaWJ1dGVzIGZvciB0aGUgU2VnbWVudEJhc2Ugbm9kZVxuICovXG5cbi8qKlxuICogUmV0dXJucyBhbGwgYXZhaWxhYmxlIFNlZ21lbnQgaW5mb3JtYXRpb24gY29udGFpbmVkIHdpdGhpbiB0aGUgQWRhcHRhdGlvblNldCBub2RlXG4gKlxuICogQHBhcmFtIHtOb2RlfSBhZGFwdGF0aW9uU2V0XG4gKiAgICAgICAgVGhlIEFkYXB0YXRpb25TZXQgbm9kZSB0byBnZXQgU2VnbWVudCBpbmZvcm1hdGlvbiBmcm9tXG4gKiBAcmV0dXJuIHtTZWdtZW50SW5mb3JtYXRpb259XG4gKiAgICAgICAgIFRoZSBTZWdtZW50IGluZm9ybWF0aW9uIGNvbnRhaW5lZCB3aXRoaW4gdGhlIHByb3ZpZGVkIEFkYXB0YXRpb25TZXRcbiAqL1xuXG5jb25zdCBnZXRTZWdtZW50SW5mb3JtYXRpb24gPSBhZGFwdGF0aW9uU2V0ID0+IHtcbiAgY29uc3Qgc2VnbWVudFRlbXBsYXRlID0gZmluZENoaWxkcmVuKGFkYXB0YXRpb25TZXQsICdTZWdtZW50VGVtcGxhdGUnKVswXTtcbiAgY29uc3Qgc2VnbWVudExpc3QgPSBmaW5kQ2hpbGRyZW4oYWRhcHRhdGlvblNldCwgJ1NlZ21lbnRMaXN0JylbMF07XG4gIGNvbnN0IHNlZ21lbnRVcmxzID0gc2VnbWVudExpc3QgJiYgZmluZENoaWxkcmVuKHNlZ21lbnRMaXN0LCAnU2VnbWVudFVSTCcpLm1hcChzID0+IG1lcmdlKHtcbiAgICB0YWc6ICdTZWdtZW50VVJMJ1xuICB9LCBwYXJzZUF0dHJpYnV0ZXMocykpKTtcbiAgY29uc3Qgc2VnbWVudEJhc2UgPSBmaW5kQ2hpbGRyZW4oYWRhcHRhdGlvblNldCwgJ1NlZ21lbnRCYXNlJylbMF07XG4gIGNvbnN0IHNlZ21lbnRUaW1lbGluZVBhcmVudE5vZGUgPSBzZWdtZW50TGlzdCB8fCBzZWdtZW50VGVtcGxhdGU7XG4gIGNvbnN0IHNlZ21lbnRUaW1lbGluZSA9IHNlZ21lbnRUaW1lbGluZVBhcmVudE5vZGUgJiYgZmluZENoaWxkcmVuKHNlZ21lbnRUaW1lbGluZVBhcmVudE5vZGUsICdTZWdtZW50VGltZWxpbmUnKVswXTtcbiAgY29uc3Qgc2VnbWVudEluaXRpYWxpemF0aW9uUGFyZW50Tm9kZSA9IHNlZ21lbnRMaXN0IHx8IHNlZ21lbnRCYXNlIHx8IHNlZ21lbnRUZW1wbGF0ZTtcbiAgY29uc3Qgc2VnbWVudEluaXRpYWxpemF0aW9uID0gc2VnbWVudEluaXRpYWxpemF0aW9uUGFyZW50Tm9kZSAmJiBmaW5kQ2hpbGRyZW4oc2VnbWVudEluaXRpYWxpemF0aW9uUGFyZW50Tm9kZSwgJ0luaXRpYWxpemF0aW9uJylbMF07IC8vIFNlZ21lbnRUZW1wbGF0ZSBpcyBoYW5kbGVkIHNsaWdodGx5IGRpZmZlcmVudGx5LCBzaW5jZSBpdCBjYW4gaGF2ZSBib3RoXG4gIC8vIEBpbml0aWFsaXphdGlvbiBhbmQgYW4gPEluaXRpYWxpemF0aW9uPiBub2RlLiAgQGluaXRpYWxpemF0aW9uIGNhbiBiZSB0ZW1wbGF0ZWQsXG4gIC8vIHdoaWxlIHRoZSBub2RlIGNhbiBoYXZlIGEgdXJsIGFuZCByYW5nZSBzcGVjaWZpZWQuICBJZiB0aGUgPFNlZ21lbnRUZW1wbGF0ZT4gaGFzXG4gIC8vIGJvdGggQGluaXRpYWxpemF0aW9uIGFuZCBhbiA8SW5pdGlhbGl6YXRpb24+IHN1YmVsZW1lbnQgd2Ugb3B0IHRvIG92ZXJyaWRlIHdpdGhcbiAgLy8gdGhlIG5vZGUsIGFzIHRoaXMgaW50ZXJhY3Rpb24gaXMgbm90IGRlZmluZWQgaW4gdGhlIHNwZWMuXG5cbiAgY29uc3QgdGVtcGxhdGUgPSBzZWdtZW50VGVtcGxhdGUgJiYgcGFyc2VBdHRyaWJ1dGVzKHNlZ21lbnRUZW1wbGF0ZSk7XG5cbiAgaWYgKHRlbXBsYXRlICYmIHNlZ21lbnRJbml0aWFsaXphdGlvbikge1xuICAgIHRlbXBsYXRlLmluaXRpYWxpemF0aW9uID0gc2VnbWVudEluaXRpYWxpemF0aW9uICYmIHBhcnNlQXR0cmlidXRlcyhzZWdtZW50SW5pdGlhbGl6YXRpb24pO1xuICB9IGVsc2UgaWYgKHRlbXBsYXRlICYmIHRlbXBsYXRlLmluaXRpYWxpemF0aW9uKSB7XG4gICAgLy8gSWYgaXQgaXMgQGluaXRpYWxpemF0aW9uIHdlIGNvbnZlcnQgaXQgdG8gYW4gb2JqZWN0IHNpbmNlIHRoaXMgaXMgdGhlIGZvcm1hdCB0aGF0XG4gICAgLy8gbGF0ZXIgZnVuY3Rpb25zIHdpbGwgcmVseSBvbiBmb3IgdGhlIGluaXRpYWxpemF0aW9uIHNlZ21lbnQuICBUaGlzIGlzIG9ubHkgdmFsaWRcbiAgICAvLyBmb3IgPFNlZ21lbnRUZW1wbGF0ZT5cbiAgICB0ZW1wbGF0ZS5pbml0aWFsaXphdGlvbiA9IHtcbiAgICAgIHNvdXJjZVVSTDogdGVtcGxhdGUuaW5pdGlhbGl6YXRpb25cbiAgICB9O1xuICB9XG5cbiAgY29uc3Qgc2VnbWVudEluZm8gPSB7XG4gICAgdGVtcGxhdGUsXG4gICAgc2VnbWVudFRpbWVsaW5lOiBzZWdtZW50VGltZWxpbmUgJiYgZmluZENoaWxkcmVuKHNlZ21lbnRUaW1lbGluZSwgJ1MnKS5tYXAocyA9PiBwYXJzZUF0dHJpYnV0ZXMocykpLFxuICAgIGxpc3Q6IHNlZ21lbnRMaXN0ICYmIG1lcmdlKHBhcnNlQXR0cmlidXRlcyhzZWdtZW50TGlzdCksIHtcbiAgICAgIHNlZ21lbnRVcmxzLFxuICAgICAgaW5pdGlhbGl6YXRpb246IHBhcnNlQXR0cmlidXRlcyhzZWdtZW50SW5pdGlhbGl6YXRpb24pXG4gICAgfSksXG4gICAgYmFzZTogc2VnbWVudEJhc2UgJiYgbWVyZ2UocGFyc2VBdHRyaWJ1dGVzKHNlZ21lbnRCYXNlKSwge1xuICAgICAgaW5pdGlhbGl6YXRpb246IHBhcnNlQXR0cmlidXRlcyhzZWdtZW50SW5pdGlhbGl6YXRpb24pXG4gICAgfSlcbiAgfTtcbiAgT2JqZWN0LmtleXMoc2VnbWVudEluZm8pLmZvckVhY2goa2V5ID0+IHtcbiAgICBpZiAoIXNlZ21lbnRJbmZvW2tleV0pIHtcbiAgICAgIGRlbGV0ZSBzZWdtZW50SW5mb1trZXldO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBzZWdtZW50SW5mbztcbn07XG4vKipcbiAqIENvbnRhaW5zIFNlZ21lbnQgaW5mb3JtYXRpb24gYW5kIGF0dHJpYnV0ZXMgbmVlZGVkIHRvIGNvbnN0cnVjdCBhIFBsYXlsaXN0IG9iamVjdFxuICogZnJvbSBhIFJlcHJlc2VudGF0aW9uXG4gKlxuICogQHR5cGVkZWYge09iamVjdH0gUmVwcmVzZW50YXRpb25JbmZvcm1hdGlvblxuICogQHByb3BlcnR5IHtTZWdtZW50SW5mb3JtYXRpb259IHNlZ21lbnRJbmZvXG4gKiAgICAgICAgICAgU2VnbWVudCBpbmZvcm1hdGlvbiBmb3IgdGhpcyBSZXByZXNlbnRhdGlvblxuICogQHByb3BlcnR5IHtPYmplY3R9IGF0dHJpYnV0ZXNcbiAqICAgICAgICAgICBJbmhlcml0ZWQgYXR0cmlidXRlcyBmb3IgdGhpcyBSZXByZXNlbnRhdGlvblxuICovXG5cbi8qKlxuICogTWFwcyBhIFJlcHJlc2VudGF0aW9uIG5vZGUgdG8gYW4gb2JqZWN0IGNvbnRhaW5pbmcgU2VnbWVudCBpbmZvcm1hdGlvbiBhbmQgYXR0cmlidXRlc1xuICpcbiAqIEBuYW1lIGluaGVyaXRCYXNlVXJsc0NhbGxiYWNrXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7Tm9kZX0gcmVwcmVzZW50YXRpb25cbiAqICAgICAgICBSZXByZXNlbnRhdGlvbiBub2RlIGZyb20gdGhlIG1wZFxuICogQHJldHVybiB7UmVwcmVzZW50YXRpb25JbmZvcm1hdGlvbn1cbiAqICAgICAgICAgUmVwcmVzZW50YXRpb24gaW5mb3JtYXRpb24gbmVlZGVkIHRvIGNvbnN0cnVjdCBhIFBsYXlsaXN0IG9iamVjdFxuICovXG5cbi8qKlxuICogUmV0dXJucyBhIGNhbGxiYWNrIGZvciBBcnJheS5wcm90b3R5cGUubWFwIGZvciBtYXBwaW5nIFJlcHJlc2VudGF0aW9uIG5vZGVzIHRvXG4gKiBTZWdtZW50IGluZm9ybWF0aW9uIGFuZCBhdHRyaWJ1dGVzIHVzaW5nIGluaGVyaXRlZCBCYXNlVVJMIG5vZGVzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBhZGFwdGF0aW9uU2V0QXR0cmlidXRlc1xuICogICAgICAgIENvbnRhaW5zIGF0dHJpYnV0ZXMgaW5oZXJpdGVkIGJ5IHRoZSBBZGFwdGF0aW9uU2V0XG4gKiBAcGFyYW0ge09iamVjdFtdfSBhZGFwdGF0aW9uU2V0QmFzZVVybHNcbiAqICAgICAgICBMaXN0IG9mIG9iamVjdHMgY29udGFpbmluZyByZXNvbHZlZCBiYXNlIFVSTHMgYW5kIGF0dHJpYnV0ZXNcbiAqICAgICAgICBpbmhlcml0ZWQgYnkgdGhlIEFkYXB0YXRpb25TZXRcbiAqIEBwYXJhbSB7U2VnbWVudEluZm9ybWF0aW9ufSBhZGFwdGF0aW9uU2V0U2VnbWVudEluZm9cbiAqICAgICAgICBDb250YWlucyBTZWdtZW50IGluZm9ybWF0aW9uIGZvciB0aGUgQWRhcHRhdGlvblNldFxuICogQHJldHVybiB7aW5oZXJpdEJhc2VVcmxzQ2FsbGJhY2t9XG4gKiAgICAgICAgIENhbGxiYWNrIG1hcCBmdW5jdGlvblxuICovXG5cbmNvbnN0IGluaGVyaXRCYXNlVXJscyA9IChhZGFwdGF0aW9uU2V0QXR0cmlidXRlcywgYWRhcHRhdGlvblNldEJhc2VVcmxzLCBhZGFwdGF0aW9uU2V0U2VnbWVudEluZm8pID0+IHJlcHJlc2VudGF0aW9uID0+IHtcbiAgY29uc3QgcmVwQmFzZVVybEVsZW1lbnRzID0gZmluZENoaWxkcmVuKHJlcHJlc2VudGF0aW9uLCAnQmFzZVVSTCcpO1xuICBjb25zdCByZXBCYXNlVXJscyA9IGJ1aWxkQmFzZVVybHMoYWRhcHRhdGlvblNldEJhc2VVcmxzLCByZXBCYXNlVXJsRWxlbWVudHMpO1xuICBjb25zdCBhdHRyaWJ1dGVzID0gbWVyZ2UoYWRhcHRhdGlvblNldEF0dHJpYnV0ZXMsIHBhcnNlQXR0cmlidXRlcyhyZXByZXNlbnRhdGlvbikpO1xuICBjb25zdCByZXByZXNlbnRhdGlvblNlZ21lbnRJbmZvID0gZ2V0U2VnbWVudEluZm9ybWF0aW9uKHJlcHJlc2VudGF0aW9uKTtcbiAgcmV0dXJuIHJlcEJhc2VVcmxzLm1hcChiYXNlVXJsID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgc2VnbWVudEluZm86IG1lcmdlKGFkYXB0YXRpb25TZXRTZWdtZW50SW5mbywgcmVwcmVzZW50YXRpb25TZWdtZW50SW5mbyksXG4gICAgICBhdHRyaWJ1dGVzOiBtZXJnZShhdHRyaWJ1dGVzLCBiYXNlVXJsKVxuICAgIH07XG4gIH0pO1xufTtcbi8qKlxuICogVHJhbmZvcm1zIGEgc2VyaWVzIG9mIGNvbnRlbnQgcHJvdGVjdGlvbiBub2RlcyB0b1xuICogYW4gb2JqZWN0IGNvbnRhaW5pbmcgcHNzaCBkYXRhIGJ5IGtleSBzeXN0ZW1cbiAqXG4gKiBAcGFyYW0ge05vZGVbXX0gY29udGVudFByb3RlY3Rpb25Ob2Rlc1xuICogICAgICAgIENvbnRlbnQgcHJvdGVjdGlvbiBub2Rlc1xuICogQHJldHVybiB7T2JqZWN0fVxuICogICAgICAgIE9iamVjdCBjb250YWluaW5nIHBzc2ggZGF0YSBieSBrZXkgc3lzdGVtXG4gKi9cblxuY29uc3QgZ2VuZXJhdGVLZXlTeXN0ZW1JbmZvcm1hdGlvbiA9IGNvbnRlbnRQcm90ZWN0aW9uTm9kZXMgPT4ge1xuICByZXR1cm4gY29udGVudFByb3RlY3Rpb25Ob2Rlcy5yZWR1Y2UoKGFjYywgbm9kZSkgPT4ge1xuICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBwYXJzZUF0dHJpYnV0ZXMobm9kZSk7IC8vIEFsdGhvdWdoIGl0IGNvdWxkIGJlIGFyZ3VlZCB0aGF0IGFjY29yZGluZyB0byB0aGUgVVVJRCBSRkMgc3BlYyB0aGUgVVVJRCBzdHJpbmcgKGEtZiBjaGFycykgc2hvdWxkIGJlIGdlbmVyYXRlZFxuICAgIC8vIGFzIGEgbG93ZXJjYXNlIHN0cmluZyBpdCBhbHNvIG1lbnRpb25zIGl0IHNob3VsZCBiZSB0cmVhdGVkIGFzIGNhc2UtaW5zZW5zaXRpdmUgb24gaW5wdXQuIFNpbmNlIHRoZSBrZXkgc3lzdGVtXG4gICAgLy8gVVVJRHMgaW4gdGhlIGtleVN5c3RlbXNNYXAgYXJlIGhhcmRjb2RlZCBhcyBsb3dlcmNhc2UgaW4gdGhlIGNvZGViYXNlIHRoZXJlIGlzbid0IGFueSByZWFzb24gbm90IHRvIGRvXG4gICAgLy8gLnRvTG93ZXJDYXNlKCkgb24gdGhlIGlucHV0IFVVSUQgc3RyaW5nIGZyb20gdGhlIG1hbmlmZXN0IChhdCBsZWFzdCBJIGNvdWxkIG5vdCB0aGluayBvZiBvbmUpLlxuXG4gICAgaWYgKGF0dHJpYnV0ZXMuc2NoZW1lSWRVcmkpIHtcbiAgICAgIGF0dHJpYnV0ZXMuc2NoZW1lSWRVcmkgPSBhdHRyaWJ1dGVzLnNjaGVtZUlkVXJpLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuXG4gICAgY29uc3Qga2V5U3lzdGVtID0ga2V5U3lzdGVtc01hcFthdHRyaWJ1dGVzLnNjaGVtZUlkVXJpXTtcblxuICAgIGlmIChrZXlTeXN0ZW0pIHtcbiAgICAgIGFjY1trZXlTeXN0ZW1dID0ge1xuICAgICAgICBhdHRyaWJ1dGVzXG4gICAgICB9O1xuICAgICAgY29uc3QgcHNzaE5vZGUgPSBmaW5kQ2hpbGRyZW4obm9kZSwgJ2NlbmM6cHNzaCcpWzBdO1xuXG4gICAgICBpZiAocHNzaE5vZGUpIHtcbiAgICAgICAgY29uc3QgcHNzaCA9IGdldENvbnRlbnQocHNzaE5vZGUpO1xuICAgICAgICBhY2Nba2V5U3lzdGVtXS5wc3NoID0gcHNzaCAmJiBkZWNvZGVCNjRUb1VpbnQ4QXJyYXlfX2RlZmF1bHRbJ2RlZmF1bHQnXShwc3NoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYWNjO1xuICB9LCB7fSk7XG59OyAvLyBkZWZpbmVkIGluIEFOU0lfU0NURSAyMTQtMSAyMDE2XG5cblxuY29uc3QgcGFyc2VDYXB0aW9uU2VydmljZU1ldGFkYXRhID0gc2VydmljZSA9PiB7XG4gIC8vIDYwOCBjYXB0aW9uc1xuICBpZiAoc2VydmljZS5zY2hlbWVJZFVyaSA9PT0gJ3VybjpzY3RlOmRhc2g6Y2M6Y2VhLTYwODoyMDE1Jykge1xuICAgIGNvbnN0IHZhbHVlcyA9IHR5cGVvZiBzZXJ2aWNlLnZhbHVlICE9PSAnc3RyaW5nJyA/IFtdIDogc2VydmljZS52YWx1ZS5zcGxpdCgnOycpO1xuICAgIHJldHVybiB2YWx1ZXMubWFwKHZhbHVlID0+IHtcbiAgICAgIGxldCBjaGFubmVsO1xuICAgICAgbGV0IGxhbmd1YWdlOyAvLyBkZWZhdWx0IGxhbmd1YWdlIHRvIHZhbHVlXG5cbiAgICAgIGxhbmd1YWdlID0gdmFsdWU7XG5cbiAgICAgIGlmICgvXkNDXFxkPS8udGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgW2NoYW5uZWwsIGxhbmd1YWdlXSA9IHZhbHVlLnNwbGl0KCc9Jyk7XG4gICAgICB9IGVsc2UgaWYgKC9eQ0NcXGQkLy50ZXN0KHZhbHVlKSkge1xuICAgICAgICBjaGFubmVsID0gdmFsdWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNoYW5uZWwsXG4gICAgICAgIGxhbmd1YWdlXG4gICAgICB9O1xuICAgIH0pO1xuICB9IGVsc2UgaWYgKHNlcnZpY2Uuc2NoZW1lSWRVcmkgPT09ICd1cm46c2N0ZTpkYXNoOmNjOmNlYS03MDg6MjAxNScpIHtcbiAgICBjb25zdCB2YWx1ZXMgPSB0eXBlb2Ygc2VydmljZS52YWx1ZSAhPT0gJ3N0cmluZycgPyBbXSA6IHNlcnZpY2UudmFsdWUuc3BsaXQoJzsnKTtcbiAgICByZXR1cm4gdmFsdWVzLm1hcCh2YWx1ZSA9PiB7XG4gICAgICBjb25zdCBmbGFncyA9IHtcbiAgICAgICAgLy8gc2VydmljZSBvciBjaGFubmVsIG51bWJlciAxLTYzXG4gICAgICAgICdjaGFubmVsJzogdW5kZWZpbmVkLFxuICAgICAgICAvLyBsYW5ndWFnZSBpcyBhIDNBTFBIQSBwZXIgSVNPIDYzOS4yL0JcbiAgICAgICAgLy8gZmllbGQgaXMgcmVxdWlyZWRcbiAgICAgICAgJ2xhbmd1YWdlJzogdW5kZWZpbmVkLFxuICAgICAgICAvLyBCSVQgMS8wIG9yID9cbiAgICAgICAgLy8gZGVmYXVsdCB2YWx1ZSBpcyAxLCBtZWFuaW5nIDE2OjkgYXNwZWN0IHJhdGlvLCAwIGlzIDQ6MywgPyBpcyB1bmtub3duXG4gICAgICAgICdhc3BlY3RSYXRpbyc6IDEsXG4gICAgICAgIC8vIEJJVCAxLzBcbiAgICAgICAgLy8gZWFzeSByZWFkZXIgZmxhZyBpbmRpY2F0ZWQgdGhlIHRleHQgaXMgdGFpbGVkIHRvIHRoZSBuZWVkcyBvZiBiZWdpbm5pbmcgcmVhZGVyc1xuICAgICAgICAvLyBkZWZhdWx0IDAsIG9yIG9mZlxuICAgICAgICAnZWFzeVJlYWRlcic6IDAsXG4gICAgICAgIC8vIEJJVCAxLzBcbiAgICAgICAgLy8gSWYgM2QgbWV0YWRhdGEgaXMgcHJlc2VudCAoQ0VBLTcwOC4xKSB0aGVuIDFcbiAgICAgICAgLy8gZGVmYXVsdCAwXG4gICAgICAgICczRCc6IDBcbiAgICAgIH07XG5cbiAgICAgIGlmICgvPS8udGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgY29uc3QgW2NoYW5uZWwsIG9wdHMgPSAnJ10gPSB2YWx1ZS5zcGxpdCgnPScpO1xuICAgICAgICBmbGFncy5jaGFubmVsID0gY2hhbm5lbDtcbiAgICAgICAgZmxhZ3MubGFuZ3VhZ2UgPSB2YWx1ZTtcbiAgICAgICAgb3B0cy5zcGxpdCgnLCcpLmZvckVhY2gob3B0ID0+IHtcbiAgICAgICAgICBjb25zdCBbbmFtZSwgdmFsXSA9IG9wdC5zcGxpdCgnOicpO1xuXG4gICAgICAgICAgaWYgKG5hbWUgPT09ICdsYW5nJykge1xuICAgICAgICAgICAgZmxhZ3MubGFuZ3VhZ2UgPSB2YWw7IC8vIGVyIGZvciBlYXN5UmVhZGVyeVxuICAgICAgICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gJ2VyJykge1xuICAgICAgICAgICAgZmxhZ3MuZWFzeVJlYWRlciA9IE51bWJlcih2YWwpOyAvLyB3YXIgZm9yIHdpZGUgYXNwZWN0IHJhdGlvXG4gICAgICAgICAgfSBlbHNlIGlmIChuYW1lID09PSAnd2FyJykge1xuICAgICAgICAgICAgZmxhZ3MuYXNwZWN0UmF0aW8gPSBOdW1iZXIodmFsKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKG5hbWUgPT09ICczRCcpIHtcbiAgICAgICAgICAgIGZsYWdzWyczRCddID0gTnVtYmVyKHZhbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZsYWdzLmxhbmd1YWdlID0gdmFsdWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChmbGFncy5jaGFubmVsKSB7XG4gICAgICAgIGZsYWdzLmNoYW5uZWwgPSAnU0VSVklDRScgKyBmbGFncy5jaGFubmVsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmxhZ3M7XG4gICAgfSk7XG4gIH1cbn07XG4vKipcbiAqIEEgbWFwIGNhbGxiYWNrIHRoYXQgd2lsbCBwYXJzZSBhbGwgZXZlbnQgc3RyZWFtIGRhdGEgZm9yIGEgY29sbGVjdGlvbiBvZiBwZXJpb2RzXG4gKiBEQVNIIElTT19JRUNfMjMwMDkgNS4xMC4yLjJcbiAqIGh0dHBzOi8vZGFzaGlmLWRvY3VtZW50cy5henVyZXdlYnNpdGVzLm5ldC9FdmVudHMvbWFzdGVyL2V2ZW50Lmh0bWwjbXBkLWV2ZW50LXRpbWluZ1xuICpcbiAqIEBwYXJhbSB7UGVyaW9kSW5mb3JtYXRpb259IHBlcmlvZCBvYmplY3QgY29udGFpbmluZyBuZWNlc3NhcnkgcGVyaW9kIGluZm9ybWF0aW9uXG4gKiBAcmV0dXJuIGEgY29sbGVjdGlvbiBvZiBwYXJzZWQgZXZlbnRzdHJlYW0gZXZlbnQgb2JqZWN0c1xuICovXG5cbmNvbnN0IHRvRXZlbnRTdHJlYW0gPSBwZXJpb2QgPT4ge1xuICAvLyBnZXQgYW5kIGZsYXR0ZW4gYWxsIEV2ZW50U3RyZWFtcyB0YWdzIGFuZCBwYXJzZSBhdHRyaWJ1dGVzIGFuZCBjaGlsZHJlblxuICByZXR1cm4gZmxhdHRlbihmaW5kQ2hpbGRyZW4ocGVyaW9kLm5vZGUsICdFdmVudFN0cmVhbScpLm1hcChldmVudFN0cmVhbSA9PiB7XG4gICAgY29uc3QgZXZlbnRTdHJlYW1BdHRyaWJ1dGVzID0gcGFyc2VBdHRyaWJ1dGVzKGV2ZW50U3RyZWFtKTtcbiAgICBjb25zdCBzY2hlbWVJZFVyaSA9IGV2ZW50U3RyZWFtQXR0cmlidXRlcy5zY2hlbWVJZFVyaTsgLy8gZmluZCBhbGwgRXZlbnRzIHBlciBFdmVudFN0cmVhbSB0YWcgYW5kIG1hcCB0byByZXR1cm4gb2JqZWN0c1xuXG4gICAgcmV0dXJuIGZpbmRDaGlsZHJlbihldmVudFN0cmVhbSwgJ0V2ZW50JykubWFwKGV2ZW50ID0+IHtcbiAgICAgIGNvbnN0IGV2ZW50QXR0cmlidXRlcyA9IHBhcnNlQXR0cmlidXRlcyhldmVudCk7XG4gICAgICBjb25zdCBwcmVzZW50YXRpb25UaW1lID0gZXZlbnRBdHRyaWJ1dGVzLnByZXNlbnRhdGlvblRpbWUgfHwgMDtcbiAgICAgIGNvbnN0IHRpbWVzY2FsZSA9IGV2ZW50U3RyZWFtQXR0cmlidXRlcy50aW1lc2NhbGUgfHwgMTtcbiAgICAgIGNvbnN0IGR1cmF0aW9uID0gZXZlbnRBdHRyaWJ1dGVzLmR1cmF0aW9uIHx8IDA7XG4gICAgICBjb25zdCBzdGFydCA9IHByZXNlbnRhdGlvblRpbWUgLyB0aW1lc2NhbGUgKyBwZXJpb2QuYXR0cmlidXRlcy5zdGFydDtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHNjaGVtZUlkVXJpLFxuICAgICAgICB2YWx1ZTogZXZlbnRTdHJlYW1BdHRyaWJ1dGVzLnZhbHVlLFxuICAgICAgICBpZDogZXZlbnRBdHRyaWJ1dGVzLmlkLFxuICAgICAgICBzdGFydCxcbiAgICAgICAgZW5kOiBzdGFydCArIGR1cmF0aW9uIC8gdGltZXNjYWxlLFxuICAgICAgICBtZXNzYWdlRGF0YTogZ2V0Q29udGVudChldmVudCkgfHwgZXZlbnRBdHRyaWJ1dGVzLm1lc3NhZ2VEYXRhLFxuICAgICAgICBjb250ZW50RW5jb2Rpbmc6IGV2ZW50U3RyZWFtQXR0cmlidXRlcy5jb250ZW50RW5jb2RpbmcsXG4gICAgICAgIHByZXNlbnRhdGlvblRpbWVPZmZzZXQ6IGV2ZW50U3RyZWFtQXR0cmlidXRlcy5wcmVzZW50YXRpb25UaW1lT2Zmc2V0IHx8IDBcbiAgICAgIH07XG4gICAgfSk7XG4gIH0pKTtcbn07XG4vKipcbiAqIE1hcHMgYW4gQWRhcHRhdGlvblNldCBub2RlIHRvIGEgbGlzdCBvZiBSZXByZXNlbnRhdGlvbiBpbmZvcm1hdGlvbiBvYmplY3RzXG4gKlxuICogQG5hbWUgdG9SZXByZXNlbnRhdGlvbnNDYWxsYmFja1xuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge05vZGV9IGFkYXB0YXRpb25TZXRcbiAqICAgICAgICBBZGFwdGF0aW9uU2V0IG5vZGUgZnJvbSB0aGUgbXBkXG4gKiBAcmV0dXJuIHtSZXByZXNlbnRhdGlvbkluZm9ybWF0aW9uW119XG4gKiAgICAgICAgIExpc3Qgb2Ygb2JqZWN0cyBjb250YWluaW5nIFJlcHJlc2VudGFpb24gaW5mb3JtYXRpb25cbiAqL1xuXG4vKipcbiAqIFJldHVybnMgYSBjYWxsYmFjayBmb3IgQXJyYXkucHJvdG90eXBlLm1hcCBmb3IgbWFwcGluZyBBZGFwdGF0aW9uU2V0IG5vZGVzIHRvIGEgbGlzdCBvZlxuICogUmVwcmVzZW50YXRpb24gaW5mb3JtYXRpb24gb2JqZWN0c1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwZXJpb2RBdHRyaWJ1dGVzXG4gKiAgICAgICAgQ29udGFpbnMgYXR0cmlidXRlcyBpbmhlcml0ZWQgYnkgdGhlIFBlcmlvZFxuICogQHBhcmFtIHtPYmplY3RbXX0gcGVyaW9kQmFzZVVybHNcbiAqICAgICAgICBDb250YWlucyBsaXN0IG9mIG9iamVjdHMgd2l0aCByZXNvbHZlZCBiYXNlIHVybHMgYW5kIGF0dHJpYnV0ZXNcbiAqICAgICAgICBpbmhlcml0ZWQgYnkgdGhlIFBlcmlvZFxuICogQHBhcmFtIHtzdHJpbmdbXX0gcGVyaW9kU2VnbWVudEluZm9cbiAqICAgICAgICBDb250YWlucyBTZWdtZW50IEluZm9ybWF0aW9uIGF0IHRoZSBwZXJpb2QgbGV2ZWxcbiAqIEByZXR1cm4ge3RvUmVwcmVzZW50YXRpb25zQ2FsbGJhY2t9XG4gKiAgICAgICAgIENhbGxiYWNrIG1hcCBmdW5jdGlvblxuICovXG5cbmNvbnN0IHRvUmVwcmVzZW50YXRpb25zID0gKHBlcmlvZEF0dHJpYnV0ZXMsIHBlcmlvZEJhc2VVcmxzLCBwZXJpb2RTZWdtZW50SW5mbykgPT4gYWRhcHRhdGlvblNldCA9PiB7XG4gIGNvbnN0IGFkYXB0YXRpb25TZXRBdHRyaWJ1dGVzID0gcGFyc2VBdHRyaWJ1dGVzKGFkYXB0YXRpb25TZXQpO1xuICBjb25zdCBhZGFwdGF0aW9uU2V0QmFzZVVybHMgPSBidWlsZEJhc2VVcmxzKHBlcmlvZEJhc2VVcmxzLCBmaW5kQ2hpbGRyZW4oYWRhcHRhdGlvblNldCwgJ0Jhc2VVUkwnKSk7XG4gIGNvbnN0IHJvbGUgPSBmaW5kQ2hpbGRyZW4oYWRhcHRhdGlvblNldCwgJ1JvbGUnKVswXTtcbiAgY29uc3Qgcm9sZUF0dHJpYnV0ZXMgPSB7XG4gICAgcm9sZTogcGFyc2VBdHRyaWJ1dGVzKHJvbGUpXG4gIH07XG4gIGxldCBhdHRycyA9IG1lcmdlKHBlcmlvZEF0dHJpYnV0ZXMsIGFkYXB0YXRpb25TZXRBdHRyaWJ1dGVzLCByb2xlQXR0cmlidXRlcyk7XG4gIGNvbnN0IGFjY2Vzc2liaWxpdHkgPSBmaW5kQ2hpbGRyZW4oYWRhcHRhdGlvblNldCwgJ0FjY2Vzc2liaWxpdHknKVswXTtcbiAgY29uc3QgY2FwdGlvblNlcnZpY2VzID0gcGFyc2VDYXB0aW9uU2VydmljZU1ldGFkYXRhKHBhcnNlQXR0cmlidXRlcyhhY2Nlc3NpYmlsaXR5KSk7XG5cbiAgaWYgKGNhcHRpb25TZXJ2aWNlcykge1xuICAgIGF0dHJzID0gbWVyZ2UoYXR0cnMsIHtcbiAgICAgIGNhcHRpb25TZXJ2aWNlc1xuICAgIH0pO1xuICB9XG5cbiAgY29uc3QgbGFiZWwgPSBmaW5kQ2hpbGRyZW4oYWRhcHRhdGlvblNldCwgJ0xhYmVsJylbMF07XG5cbiAgaWYgKGxhYmVsICYmIGxhYmVsLmNoaWxkTm9kZXMubGVuZ3RoKSB7XG4gICAgY29uc3QgbGFiZWxWYWwgPSBsYWJlbC5jaGlsZE5vZGVzWzBdLm5vZGVWYWx1ZS50cmltKCk7XG4gICAgYXR0cnMgPSBtZXJnZShhdHRycywge1xuICAgICAgbGFiZWw6IGxhYmVsVmFsXG4gICAgfSk7XG4gIH1cblxuICBjb25zdCBjb250ZW50UHJvdGVjdGlvbiA9IGdlbmVyYXRlS2V5U3lzdGVtSW5mb3JtYXRpb24oZmluZENoaWxkcmVuKGFkYXB0YXRpb25TZXQsICdDb250ZW50UHJvdGVjdGlvbicpKTtcblxuICBpZiAoT2JqZWN0LmtleXMoY29udGVudFByb3RlY3Rpb24pLmxlbmd0aCkge1xuICAgIGF0dHJzID0gbWVyZ2UoYXR0cnMsIHtcbiAgICAgIGNvbnRlbnRQcm90ZWN0aW9uXG4gICAgfSk7XG4gIH1cblxuICBjb25zdCBzZWdtZW50SW5mbyA9IGdldFNlZ21lbnRJbmZvcm1hdGlvbihhZGFwdGF0aW9uU2V0KTtcbiAgY29uc3QgcmVwcmVzZW50YXRpb25zID0gZmluZENoaWxkcmVuKGFkYXB0YXRpb25TZXQsICdSZXByZXNlbnRhdGlvbicpO1xuICBjb25zdCBhZGFwdGF0aW9uU2V0U2VnbWVudEluZm8gPSBtZXJnZShwZXJpb2RTZWdtZW50SW5mbywgc2VnbWVudEluZm8pO1xuICByZXR1cm4gZmxhdHRlbihyZXByZXNlbnRhdGlvbnMubWFwKGluaGVyaXRCYXNlVXJscyhhdHRycywgYWRhcHRhdGlvblNldEJhc2VVcmxzLCBhZGFwdGF0aW9uU2V0U2VnbWVudEluZm8pKSk7XG59O1xuLyoqXG4gKiBDb250YWlucyBhbGwgcGVyaW9kIGluZm9ybWF0aW9uIGZvciBtYXBwaW5nIG5vZGVzIG9udG8gYWRhcHRhdGlvbiBzZXRzLlxuICpcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFBlcmlvZEluZm9ybWF0aW9uXG4gKiBAcHJvcGVydHkge05vZGV9IHBlcmlvZC5ub2RlXG4gKiAgICAgICAgICAgUGVyaW9kIG5vZGUgZnJvbSB0aGUgbXBkXG4gKiBAcHJvcGVydHkge09iamVjdH0gcGVyaW9kLmF0dHJpYnV0ZXNcbiAqICAgICAgICAgICBQYXJzZWQgcGVyaW9kIGF0dHJpYnV0ZXMgZnJvbSBub2RlIHBsdXMgYW55IGFkZGVkXG4gKi9cblxuLyoqXG4gKiBNYXBzIGEgUGVyaW9kSW5mb3JtYXRpb24gb2JqZWN0IHRvIGEgbGlzdCBvZiBSZXByZXNlbnRhdGlvbiBpbmZvcm1hdGlvbiBvYmplY3RzIGZvciBhbGxcbiAqIEFkYXB0YXRpb25TZXQgbm9kZXMgY29udGFpbmVkIHdpdGhpbiB0aGUgUGVyaW9kLlxuICpcbiAqIEBuYW1lIHRvQWRhcHRhdGlvblNldHNDYWxsYmFja1xuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge1BlcmlvZEluZm9ybWF0aW9ufSBwZXJpb2RcbiAqICAgICAgICBQZXJpb2Qgb2JqZWN0IGNvbnRhaW5pbmcgbmVjZXNzYXJ5IHBlcmlvZCBpbmZvcm1hdGlvblxuICogQHBhcmFtIHtudW1iZXJ9IHBlcmlvZFN0YXJ0XG4gKiAgICAgICAgU3RhcnQgdGltZSBvZiB0aGUgUGVyaW9kIHdpdGhpbiB0aGUgbXBkXG4gKiBAcmV0dXJuIHtSZXByZXNlbnRhdGlvbkluZm9ybWF0aW9uW119XG4gKiAgICAgICAgIExpc3Qgb2Ygb2JqZWN0cyBjb250YWluaW5nIFJlcHJlc2VudGFpb24gaW5mb3JtYXRpb25cbiAqL1xuXG4vKipcbiAqIFJldHVybnMgYSBjYWxsYmFjayBmb3IgQXJyYXkucHJvdG90eXBlLm1hcCBmb3IgbWFwcGluZyBQZXJpb2Qgbm9kZXMgdG8gYSBsaXN0IG9mXG4gKiBSZXByZXNlbnRhdGlvbiBpbmZvcm1hdGlvbiBvYmplY3RzXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG1wZEF0dHJpYnV0ZXNcbiAqICAgICAgICBDb250YWlucyBhdHRyaWJ1dGVzIGluaGVyaXRlZCBieSB0aGUgbXBkXG4gICogQHBhcmFtIHtPYmplY3RbXX0gbXBkQmFzZVVybHNcbiAqICAgICAgICBDb250YWlucyBsaXN0IG9mIG9iamVjdHMgd2l0aCByZXNvbHZlZCBiYXNlIHVybHMgYW5kIGF0dHJpYnV0ZXNcbiAqICAgICAgICBpbmhlcml0ZWQgYnkgdGhlIG1wZFxuICogQHJldHVybiB7dG9BZGFwdGF0aW9uU2V0c0NhbGxiYWNrfVxuICogICAgICAgICBDYWxsYmFjayBtYXAgZnVuY3Rpb25cbiAqL1xuXG5jb25zdCB0b0FkYXB0YXRpb25TZXRzID0gKG1wZEF0dHJpYnV0ZXMsIG1wZEJhc2VVcmxzKSA9PiAocGVyaW9kLCBpbmRleCkgPT4ge1xuICBjb25zdCBwZXJpb2RCYXNlVXJscyA9IGJ1aWxkQmFzZVVybHMobXBkQmFzZVVybHMsIGZpbmRDaGlsZHJlbihwZXJpb2Qubm9kZSwgJ0Jhc2VVUkwnKSk7XG4gIGNvbnN0IHBlcmlvZEF0dHJpYnV0ZXMgPSBtZXJnZShtcGRBdHRyaWJ1dGVzLCB7XG4gICAgcGVyaW9kU3RhcnQ6IHBlcmlvZC5hdHRyaWJ1dGVzLnN0YXJ0XG4gIH0pO1xuXG4gIGlmICh0eXBlb2YgcGVyaW9kLmF0dHJpYnV0ZXMuZHVyYXRpb24gPT09ICdudW1iZXInKSB7XG4gICAgcGVyaW9kQXR0cmlidXRlcy5wZXJpb2REdXJhdGlvbiA9IHBlcmlvZC5hdHRyaWJ1dGVzLmR1cmF0aW9uO1xuICB9XG5cbiAgY29uc3QgYWRhcHRhdGlvblNldHMgPSBmaW5kQ2hpbGRyZW4ocGVyaW9kLm5vZGUsICdBZGFwdGF0aW9uU2V0Jyk7XG4gIGNvbnN0IHBlcmlvZFNlZ21lbnRJbmZvID0gZ2V0U2VnbWVudEluZm9ybWF0aW9uKHBlcmlvZC5ub2RlKTtcbiAgcmV0dXJuIGZsYXR0ZW4oYWRhcHRhdGlvblNldHMubWFwKHRvUmVwcmVzZW50YXRpb25zKHBlcmlvZEF0dHJpYnV0ZXMsIHBlcmlvZEJhc2VVcmxzLCBwZXJpb2RTZWdtZW50SW5mbykpKTtcbn07XG4vKipcbiAqIFRyYW5mb3JtcyBhbiBhcnJheSBvZiBjb250ZW50IHN0ZWVyaW5nIG5vZGVzIGludG8gYW4gb2JqZWN0XG4gKiBjb250YWluaW5nIENETiBjb250ZW50IHN0ZWVyaW5nIGluZm9ybWF0aW9uIGZyb20gdGhlIE1QRCBtYW5pZmVzdC5cbiAqXG4gKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiB0aGUgREFTSCBzcGVjIGZvciBDb250ZW50IFN0ZWVyaW5nIHBhcnNpbmcsIHNlZTpcbiAqIGh0dHBzOi8vZGFzaGlmLm9yZy9kb2NzL0RBU0gtSUYtQ1RTLTAwWFgtQ29udGVudC1TdGVlcmluZy1Db21tdW5pdHktUmV2aWV3LnBkZlxuICpcbiAqIEBwYXJhbSB7Tm9kZVtdfSBjb250ZW50U3RlZXJpbmdOb2Rlc1xuICogICAgICAgIENvbnRlbnQgc3RlZXJpbmcgbm9kZXNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGV2ZW50SGFuZGxlclxuICogICAgICAgIFRoZSBldmVudCBoYW5kbGVyIHBhc3NlZCBpbnRvIHRoZSBwYXJzZXIgb3B0aW9ucyB0byBoYW5kbGUgd2FybmluZ3NcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqICAgICAgICBPYmplY3QgY29udGFpbmluZyBjb250ZW50IHN0ZWVyaW5nIGRhdGFcbiAqL1xuXG5jb25zdCBnZW5lcmF0ZUNvbnRlbnRTdGVlcmluZ0luZm9ybWF0aW9uID0gKGNvbnRlbnRTdGVlcmluZ05vZGVzLCBldmVudEhhbmRsZXIpID0+IHtcbiAgLy8gSWYgdGhlcmUgYXJlIG1vcmUgdGhhbiBvbmUgQ29udGVudFN0ZWVyaW5nIHRhZ3MsIHRocm93IGFuIGVycm9yXG4gIGlmIChjb250ZW50U3RlZXJpbmdOb2Rlcy5sZW5ndGggPiAxKSB7XG4gICAgZXZlbnRIYW5kbGVyKHtcbiAgICAgIHR5cGU6ICd3YXJuJyxcbiAgICAgIG1lc3NhZ2U6ICdUaGUgTVBEIG1hbmlmZXN0IHNob3VsZCBjb250YWluIG5vIG1vcmUgdGhhbiBvbmUgQ29udGVudFN0ZWVyaW5nIHRhZydcbiAgICB9KTtcbiAgfSAvLyBSZXR1cm4gYSBudWxsIHZhbHVlIGlmIHRoZXJlIGFyZSBubyBDb250ZW50U3RlZXJpbmcgdGFnc1xuXG5cbiAgaWYgKCFjb250ZW50U3RlZXJpbmdOb2Rlcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGNvbnN0IGluZm9Gcm9tQ29udGVudFN0ZWVyaW5nVGFnID0gbWVyZ2Uoe1xuICAgIHNlcnZlclVSTDogZ2V0Q29udGVudChjb250ZW50U3RlZXJpbmdOb2Rlc1swXSlcbiAgfSwgcGFyc2VBdHRyaWJ1dGVzKGNvbnRlbnRTdGVlcmluZ05vZGVzWzBdKSk7IC8vIENvbnZlcnRzIGBxdWVyeUJlZm9yZVN0YXJ0YCB0byBhIGJvb2xlYW4sIGFzIHdlbGwgYXMgc2V0dGluZyB0aGUgZGVmYXVsdCB2YWx1ZVxuICAvLyB0byBgZmFsc2VgIGlmIGl0IGRvZXNuJ3QgZXhpc3RcblxuICBpbmZvRnJvbUNvbnRlbnRTdGVlcmluZ1RhZy5xdWVyeUJlZm9yZVN0YXJ0ID0gaW5mb0Zyb21Db250ZW50U3RlZXJpbmdUYWcucXVlcnlCZWZvcmVTdGFydCA9PT0gJ3RydWUnO1xuICByZXR1cm4gaW5mb0Zyb21Db250ZW50U3RlZXJpbmdUYWc7XG59O1xuLyoqXG4gKiBHZXRzIFBlcmlvZEBzdGFydCBwcm9wZXJ0eSBmb3IgYSBnaXZlbiBwZXJpb2QuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqICAgICAgICBPcHRpb25zIG9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMuYXR0cmlidXRlc1xuICogICAgICAgIFBlcmlvZCBhdHRyaWJ1dGVzXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMucHJpb3JQZXJpb2RBdHRyaWJ1dGVzXVxuICogICAgICAgIFByaW9yIHBlcmlvZCBhdHRyaWJ1dGVzIChpZiBwcmlvciBwZXJpb2QgaXMgYXZhaWxhYmxlKVxuICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMubXBkVHlwZVxuICogICAgICAgIFRoZSBNUERAdHlwZSB0aGVzZSBwZXJpb2RzIGNhbWUgZnJvbVxuICogQHJldHVybiB7bnVtYmVyfG51bGx9XG4gKiAgICAgICAgIFRoZSBwZXJpb2Qgc3RhcnQsIG9yIG51bGwgaWYgaXQncyBhbiBlYXJseSBhdmFpbGFibGUgcGVyaW9kIG9yIGVycm9yXG4gKi9cblxuY29uc3QgZ2V0UGVyaW9kU3RhcnQgPSAoe1xuICBhdHRyaWJ1dGVzLFxuICBwcmlvclBlcmlvZEF0dHJpYnV0ZXMsXG4gIG1wZFR5cGVcbn0pID0+IHtcbiAgLy8gU3VtbWFyeSBvZiBwZXJpb2Qgc3RhcnQgdGltZSBjYWxjdWxhdGlvbiBmcm9tIERBU0ggc3BlYyBzZWN0aW9uIDUuMy4yLjFcbiAgLy9cbiAgLy8gQSBwZXJpb2QncyBzdGFydCBpcyB0aGUgZmlyc3QgcGVyaW9kJ3Mgc3RhcnQgKyB0aW1lIGVsYXBzZWQgYWZ0ZXIgcGxheWluZyBhbGxcbiAgLy8gcHJpb3IgcGVyaW9kcyB0byB0aGlzIG9uZS4gUGVyaW9kcyBjb250aW51ZSBvbmUgYWZ0ZXIgdGhlIG90aGVyIGluIHRpbWUgKHdpdGhvdXRcbiAgLy8gZ2FwcykgdW50aWwgdGhlIGVuZCBvZiB0aGUgcHJlc2VudGF0aW9uLlxuICAvL1xuICAvLyBUaGUgdmFsdWUgb2YgUGVyaW9kQHN0YXJ0IHNob3VsZCBiZTpcbiAgLy8gMS4gaWYgUGVyaW9kQHN0YXJ0IGlzIHByZXNlbnQ6IHZhbHVlIG9mIFBlcmlvZEBzdGFydFxuICAvLyAyLiBpZiBwcmV2aW91cyBwZXJpb2QgZXhpc3RzIGFuZCBpdCBoYXMgQGR1cmF0aW9uOiBwcmV2aW91cyBQZXJpb2RAc3RhcnQgK1xuICAvLyAgICBwcmV2aW91cyBQZXJpb2RAZHVyYXRpb25cbiAgLy8gMy4gaWYgdGhpcyBpcyBmaXJzdCBwZXJpb2QgYW5kIE1QREB0eXBlIGlzICdzdGF0aWMnOiAwXG4gIC8vIDQuIGluIGFsbCBvdGhlciBjYXNlcywgY29uc2lkZXIgdGhlIHBlcmlvZCBhbiBcImVhcmx5IGF2YWlsYWJsZSBwZXJpb2RcIiAobm90ZTogbm90XG4gIC8vICAgIGN1cnJlbnRseSBzdXBwb3J0ZWQpXG4gIC8vICgxKVxuICBpZiAodHlwZW9mIGF0dHJpYnV0ZXMuc3RhcnQgPT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIGF0dHJpYnV0ZXMuc3RhcnQ7XG4gIH0gLy8gKDIpXG5cblxuICBpZiAocHJpb3JQZXJpb2RBdHRyaWJ1dGVzICYmIHR5cGVvZiBwcmlvclBlcmlvZEF0dHJpYnV0ZXMuc3RhcnQgPT09ICdudW1iZXInICYmIHR5cGVvZiBwcmlvclBlcmlvZEF0dHJpYnV0ZXMuZHVyYXRpb24gPT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIHByaW9yUGVyaW9kQXR0cmlidXRlcy5zdGFydCArIHByaW9yUGVyaW9kQXR0cmlidXRlcy5kdXJhdGlvbjtcbiAgfSAvLyAoMylcblxuXG4gIGlmICghcHJpb3JQZXJpb2RBdHRyaWJ1dGVzICYmIG1wZFR5cGUgPT09ICdzdGF0aWMnKSB7XG4gICAgcmV0dXJuIDA7XG4gIH0gLy8gKDQpXG4gIC8vIFRoZXJlIGlzIGN1cnJlbnRseSBubyBsb2dpYyBmb3IgY2FsY3VsYXRpbmcgdGhlIFBlcmlvZEBzdGFydCB2YWx1ZSBpZiB0aGVyZSBpc1xuICAvLyBubyBQZXJpb2RAc3RhcnQgb3IgcHJpb3IgUGVyaW9kQHN0YXJ0IGFuZCBQZXJpb2RAZHVyYXRpb24gYXZhaWxhYmxlLiBUaGlzIGlzIG5vdCBtYWRlXG4gIC8vIGV4cGxpY2l0IGJ5IHRoZSBEQVNIIGludGVyb3AgZ3VpZGVsaW5lcyBvciB0aGUgREFTSCBzcGVjLCBob3dldmVyLCBzaW5jZSB0aGVyZSdzXG4gIC8vIG5vdGhpbmcgYWJvdXQgYW55IG90aGVyIHJlc29sdXRpb24gc3RyYXRlZ2llcywgaXQncyBpbXBsaWVkLiBUaHVzLCB0aGlzIGNhc2Ugc2hvdWxkXG4gIC8vIGJlIGNvbnNpZGVyZWQgYW4gZWFybHkgYXZhaWxhYmxlIHBlcmlvZCwgb3IgZXJyb3IsIGFuZCBudWxsIHNob3VsZCBzdWZmaWNlIGZvciBib3RoXG4gIC8vIG9mIHRob3NlIGNhc2VzLlxuXG5cbiAgcmV0dXJuIG51bGw7XG59O1xuLyoqXG4gKiBUcmF2ZXJzZXMgdGhlIG1wZCB4bWwgdHJlZSB0byBnZW5lcmF0ZSBhIGxpc3Qgb2YgUmVwcmVzZW50YXRpb24gaW5mb3JtYXRpb24gb2JqZWN0c1xuICogdGhhdCBoYXZlIGluaGVyaXRlZCBhdHRyaWJ1dGVzIGZyb20gcGFyZW50IG5vZGVzXG4gKlxuICogQHBhcmFtIHtOb2RlfSBtcGRcbiAqICAgICAgICBUaGUgcm9vdCBub2RlIG9mIHRoZSBtcGRcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiAgICAgICAgQXZhaWxhYmxlIG9wdGlvbnMgZm9yIGluaGVyaXRBdHRyaWJ1dGVzXG4gKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5tYW5pZmVzdFVyaVxuICogICAgICAgIFRoZSB1cmkgc291cmNlIG9mIHRoZSBtcGRcbiAqIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLk5PV1xuICogICAgICAgIEN1cnJlbnQgdGltZSBwZXIgREFTSCBJT1AuICBEZWZhdWx0IGlzIGN1cnJlbnQgdGltZSBpbiBtcyBzaW5jZSBlcG9jaFxuICogQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMuY2xpZW50T2Zmc2V0XG4gKiAgICAgICAgQ2xpZW50IHRpbWUgZGlmZmVyZW5jZSBmcm9tIE5PVyAoaW4gbWlsbGlzZWNvbmRzKVxuICogQHJldHVybiB7UmVwcmVzZW50YXRpb25JbmZvcm1hdGlvbltdfVxuICogICAgICAgICBMaXN0IG9mIG9iamVjdHMgY29udGFpbmluZyBSZXByZXNlbnRhdGlvbiBpbmZvcm1hdGlvblxuICovXG5cbmNvbnN0IGluaGVyaXRBdHRyaWJ1dGVzID0gKG1wZCwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gIGNvbnN0IHtcbiAgICBtYW5pZmVzdFVyaSA9ICcnLFxuICAgIE5PVyA9IERhdGUubm93KCksXG4gICAgY2xpZW50T2Zmc2V0ID0gMCxcbiAgICAvLyBUT0RPOiBGb3Igbm93LCB3ZSBhcmUgZXhwZWN0aW5nIGFuIGV2ZW50SGFuZGxlciBjYWxsYmFjayBmdW5jdGlvblxuICAgIC8vIHRvIGJlIHBhc3NlZCBpbnRvIHRoZSBtcGQgcGFyc2VyIGFzIGFuIG9wdGlvbi5cbiAgICAvLyBJbiB0aGUgZnV0dXJlLCB3ZSBzaG91bGQgZW5hYmxlIHN0cmVhbSBwYXJzaW5nIGJ5IHVzaW5nIHRoZSBTdHJlYW0gY2xhc3MgZnJvbSB2aHMtdXRpbHMuXG4gICAgLy8gVGhpcyB3aWxsIHN1cHBvcnQgbmV3IGZlYXR1cmVzIGluY2x1ZGluZyBhIHN0YW5kYXJkaXplZCBldmVudCBoYW5kbGVyLlxuICAgIC8vIFNlZSB0aGUgbTN1OCBwYXJzZXIgZm9yIGV4YW1wbGVzIG9mIGhvdyBzdHJlYW0gcGFyc2luZyBpcyBjdXJyZW50bHkgdXNlZCBmb3IgSExTIHBhcnNpbmcuXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3ZpZGVvanMvdmhzLXV0aWxzL2Jsb2IvODhkNmUxMGM2MzFlNTdhNWFmMDJjNWE2MmJjNzM3NmNkNDU2YjRmNS9zcmMvc3RyZWFtLmpzI0w5XG4gICAgZXZlbnRIYW5kbGVyID0gZnVuY3Rpb24gKCkge31cbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IHBlcmlvZE5vZGVzID0gZmluZENoaWxkcmVuKG1wZCwgJ1BlcmlvZCcpO1xuXG4gIGlmICghcGVyaW9kTm9kZXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGVycm9ycy5JTlZBTElEX05VTUJFUl9PRl9QRVJJT0QpO1xuICB9XG5cbiAgY29uc3QgbG9jYXRpb25zID0gZmluZENoaWxkcmVuKG1wZCwgJ0xvY2F0aW9uJyk7XG4gIGNvbnN0IG1wZEF0dHJpYnV0ZXMgPSBwYXJzZUF0dHJpYnV0ZXMobXBkKTtcbiAgY29uc3QgbXBkQmFzZVVybHMgPSBidWlsZEJhc2VVcmxzKFt7XG4gICAgYmFzZVVybDogbWFuaWZlc3RVcmlcbiAgfV0sIGZpbmRDaGlsZHJlbihtcGQsICdCYXNlVVJMJykpO1xuICBjb25zdCBjb250ZW50U3RlZXJpbmdOb2RlcyA9IGZpbmRDaGlsZHJlbihtcGQsICdDb250ZW50U3RlZXJpbmcnKTsgLy8gU2VlIERBU0ggc3BlYyBzZWN0aW9uIDUuMy4xLjIsIFNlbWFudGljcyBvZiBNUEQgZWxlbWVudC4gRGVmYXVsdCB0eXBlIHRvICdzdGF0aWMnLlxuXG4gIG1wZEF0dHJpYnV0ZXMudHlwZSA9IG1wZEF0dHJpYnV0ZXMudHlwZSB8fCAnc3RhdGljJztcbiAgbXBkQXR0cmlidXRlcy5zb3VyY2VEdXJhdGlvbiA9IG1wZEF0dHJpYnV0ZXMubWVkaWFQcmVzZW50YXRpb25EdXJhdGlvbiB8fCAwO1xuICBtcGRBdHRyaWJ1dGVzLk5PVyA9IE5PVztcbiAgbXBkQXR0cmlidXRlcy5jbGllbnRPZmZzZXQgPSBjbGllbnRPZmZzZXQ7XG5cbiAgaWYgKGxvY2F0aW9ucy5sZW5ndGgpIHtcbiAgICBtcGRBdHRyaWJ1dGVzLmxvY2F0aW9ucyA9IGxvY2F0aW9ucy5tYXAoZ2V0Q29udGVudCk7XG4gIH1cblxuICBjb25zdCBwZXJpb2RzID0gW107IC8vIFNpbmNlIHRvQWRhcHRhdGlvblNldHMgYWN0cyBvbiBpbmRpdmlkdWFsIHBlcmlvZHMgcmlnaHQgbm93LCB0aGUgc2ltcGxlc3QgYXBwcm9hY2ggdG9cbiAgLy8gYWRkaW5nIHByb3BlcnRpZXMgdGhhdCByZXF1aXJlIGxvb2tpbmcgYXQgcHJpb3IgcGVyaW9kcyBpcyB0byBwYXJzZSBhdHRyaWJ1dGVzIGFuZCBhZGRcbiAgLy8gbWlzc2luZyBvbmVzIGJlZm9yZSB0b0FkYXB0YXRpb25TZXRzIGlzIGNhbGxlZC4gSWYgbW9yZSBzdWNoIHByb3BlcnRpZXMgYXJlIGFkZGVkLCBpdFxuICAvLyBtYXkgYmUgYmV0dGVyIHRvIHJlZmFjdG9yIHRvQWRhcHRhdGlvblNldHMuXG5cbiAgcGVyaW9kTm9kZXMuZm9yRWFjaCgobm9kZSwgaW5kZXgpID0+IHtcbiAgICBjb25zdCBhdHRyaWJ1dGVzID0gcGFyc2VBdHRyaWJ1dGVzKG5vZGUpOyAvLyBVc2UgdGhlIGxhc3QgbW9kaWZpZWQgcHJpb3IgcGVyaW9kLCBhcyBpdCBtYXkgY29udGFpbiBhZGRlZCBpbmZvcm1hdGlvbiBuZWNlc3NhcnlcbiAgICAvLyBmb3IgdGhpcyBwZXJpb2QuXG5cbiAgICBjb25zdCBwcmlvclBlcmlvZCA9IHBlcmlvZHNbaW5kZXggLSAxXTtcbiAgICBhdHRyaWJ1dGVzLnN0YXJ0ID0gZ2V0UGVyaW9kU3RhcnQoe1xuICAgICAgYXR0cmlidXRlcyxcbiAgICAgIHByaW9yUGVyaW9kQXR0cmlidXRlczogcHJpb3JQZXJpb2QgPyBwcmlvclBlcmlvZC5hdHRyaWJ1dGVzIDogbnVsbCxcbiAgICAgIG1wZFR5cGU6IG1wZEF0dHJpYnV0ZXMudHlwZVxuICAgIH0pO1xuICAgIHBlcmlvZHMucHVzaCh7XG4gICAgICBub2RlLFxuICAgICAgYXR0cmlidXRlc1xuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBsb2NhdGlvbnM6IG1wZEF0dHJpYnV0ZXMubG9jYXRpb25zLFxuICAgIGNvbnRlbnRTdGVlcmluZ0luZm86IGdlbmVyYXRlQ29udGVudFN0ZWVyaW5nSW5mb3JtYXRpb24oY29udGVudFN0ZWVyaW5nTm9kZXMsIGV2ZW50SGFuZGxlciksXG4gICAgLy8gVE9ETzogVGhlcmUgYXJlIG9jY3VyZW5jZXMgd2hlcmUgdGhpcyBgcmVwcmVzZW50YXRpb25JbmZvYCBhcnJheSBjb250YWlucyB1bmRlc2lyZWRcbiAgICAvLyBkdXBsaWNhdGVzLiBUaGlzIGdlbmVyYWxseSBvY2N1cnMgd2hlbiB0aGVyZSBhcmUgbXVsdGlwbGUgQmFzZVVSTCBub2RlcyB0aGF0IGFyZVxuICAgIC8vIGRpcmVjdCBjaGlsZHJlbiBvZiB0aGUgTVBEIG5vZGUuIFdoZW4gd2UgYXR0ZW1wdCB0byByZXNvbHZlIFVSTHMgZnJvbSBhIGNvbWJpbmF0aW9uIG9mIHRoZVxuICAgIC8vIHBhcmVudCBCYXNlVVJMIGFuZCBhIGNoaWxkIEJhc2VVUkwsIGFuZCB0aGUgdmFsdWUgZG9lcyBub3QgcmVzb2x2ZSxcbiAgICAvLyB3ZSBlbmQgdXAgcmV0dXJuaW5nIHRoZSBjaGlsZCBCYXNlVVJMIG11bHRpcGxlIHRpbWVzLlxuICAgIC8vIFdlIG5lZWQgdG8gZGV0ZXJtaW5lIGEgd2F5IHRvIHJlbW92ZSB0aGVzZSBkdXBsaWNhdGVzIGluIGEgc2FmZSB3YXkuXG4gICAgLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vdmlkZW9qcy9tcGQtcGFyc2VyL3B1bGwvMTcjZGlzY3Vzc2lvbl9yMTYyNzUwNTI3XG4gICAgcmVwcmVzZW50YXRpb25JbmZvOiBmbGF0dGVuKHBlcmlvZHMubWFwKHRvQWRhcHRhdGlvblNldHMobXBkQXR0cmlidXRlcywgbXBkQmFzZVVybHMpKSksXG4gICAgZXZlbnRTdHJlYW06IGZsYXR0ZW4ocGVyaW9kcy5tYXAodG9FdmVudFN0cmVhbSkpXG4gIH07XG59O1xuXG5jb25zdCBzdHJpbmdUb01wZFhtbCA9IG1hbmlmZXN0U3RyaW5nID0+IHtcbiAgaWYgKG1hbmlmZXN0U3RyaW5nID09PSAnJykge1xuICAgIHRocm93IG5ldyBFcnJvcihlcnJvcnMuREFTSF9FTVBUWV9NQU5JRkVTVCk7XG4gIH1cblxuICBjb25zdCBwYXJzZXIgPSBuZXcgeG1sZG9tLkRPTVBhcnNlcigpO1xuICBsZXQgeG1sO1xuICBsZXQgbXBkO1xuXG4gIHRyeSB7XG4gICAgeG1sID0gcGFyc2VyLnBhcnNlRnJvbVN0cmluZyhtYW5pZmVzdFN0cmluZywgJ2FwcGxpY2F0aW9uL3htbCcpO1xuICAgIG1wZCA9IHhtbCAmJiB4bWwuZG9jdW1lbnRFbGVtZW50LnRhZ05hbWUgPT09ICdNUEQnID8geG1sLmRvY3VtZW50RWxlbWVudCA6IG51bGw7XG4gIH0gY2F0Y2ggKGUpIHsvLyBpZSAxMSB0aHJvd3Mgb24gaW52YWxpZCB4bWxcbiAgfVxuXG4gIGlmICghbXBkIHx8IG1wZCAmJiBtcGQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3BhcnNlcmVycm9yJykubGVuZ3RoID4gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihlcnJvcnMuREFTSF9JTlZBTElEX1hNTCk7XG4gIH1cblxuICByZXR1cm4gbXBkO1xufTtcblxuLyoqXG4gKiBQYXJzZXMgdGhlIG1hbmlmZXN0IGZvciBhIFVUQ1RpbWluZyBub2RlLCByZXR1cm5pbmcgdGhlIG5vZGVzIGF0dHJpYnV0ZXMgaWYgZm91bmRcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbXBkXG4gKiAgICAgICAgWE1MIHN0cmluZyBvZiB0aGUgTVBEIG1hbmlmZXN0XG4gKiBAcmV0dXJuIHtPYmplY3R8bnVsbH1cbiAqICAgICAgICAgQXR0cmlidXRlcyBvZiBVVENUaW1pbmcgbm9kZSBzcGVjaWZpZWQgaW4gdGhlIG1hbmlmZXN0LiBOdWxsIGlmIG5vbmUgZm91bmRcbiAqL1xuXG5jb25zdCBwYXJzZVVUQ1RpbWluZ1NjaGVtZSA9IG1wZCA9PiB7XG4gIGNvbnN0IFVUQ1RpbWluZ05vZGUgPSBmaW5kQ2hpbGRyZW4obXBkLCAnVVRDVGltaW5nJylbMF07XG5cbiAgaWYgKCFVVENUaW1pbmdOb2RlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBjb25zdCBhdHRyaWJ1dGVzID0gcGFyc2VBdHRyaWJ1dGVzKFVUQ1RpbWluZ05vZGUpO1xuXG4gIHN3aXRjaCAoYXR0cmlidXRlcy5zY2hlbWVJZFVyaSkge1xuICAgIGNhc2UgJ3VybjptcGVnOmRhc2g6dXRjOmh0dHAtaGVhZDoyMDE0JzpcbiAgICBjYXNlICd1cm46bXBlZzpkYXNoOnV0YzpodHRwLWhlYWQ6MjAxMic6XG4gICAgICBhdHRyaWJ1dGVzLm1ldGhvZCA9ICdIRUFEJztcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAndXJuOm1wZWc6ZGFzaDp1dGM6aHR0cC14c2RhdGU6MjAxNCc6XG4gICAgY2FzZSAndXJuOm1wZWc6ZGFzaDp1dGM6aHR0cC1pc286MjAxNCc6XG4gICAgY2FzZSAndXJuOm1wZWc6ZGFzaDp1dGM6aHR0cC14c2RhdGU6MjAxMic6XG4gICAgY2FzZSAndXJuOm1wZWc6ZGFzaDp1dGM6aHR0cC1pc286MjAxMic6XG4gICAgICBhdHRyaWJ1dGVzLm1ldGhvZCA9ICdHRVQnO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICd1cm46bXBlZzpkYXNoOnV0YzpkaXJlY3Q6MjAxNCc6XG4gICAgY2FzZSAndXJuOm1wZWc6ZGFzaDp1dGM6ZGlyZWN0OjIwMTInOlxuICAgICAgYXR0cmlidXRlcy5tZXRob2QgPSAnRElSRUNUJztcbiAgICAgIGF0dHJpYnV0ZXMudmFsdWUgPSBEYXRlLnBhcnNlKGF0dHJpYnV0ZXMudmFsdWUpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICd1cm46bXBlZzpkYXNoOnV0YzpodHRwLW50cDoyMDE0JzpcbiAgICBjYXNlICd1cm46bXBlZzpkYXNoOnV0YzpudHA6MjAxNCc6XG4gICAgY2FzZSAndXJuOm1wZWc6ZGFzaDp1dGM6c250cDoyMDE0JzpcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9ycy5VTlNVUFBPUlRFRF9VVENfVElNSU5HX1NDSEVNRSk7XG4gIH1cblxuICByZXR1cm4gYXR0cmlidXRlcztcbn07XG5cbmNvbnN0IFZFUlNJT04gPSB2ZXJzaW9uO1xuLypcbiAqIEdpdmVuIGEgREFTSCBtYW5pZmVzdCBzdHJpbmcgYW5kIG9wdGlvbnMsIHBhcnNlcyB0aGUgREFTSCBtYW5pZmVzdCBpbnRvIGFuIG9iamVjdCBpbiB0aGVcbiAqIGZvcm0gb3V0cHV0ZWQgYnkgbTN1OC1wYXJzZXIgYW5kIGFjY2VwdGVkIGJ5IHZpZGVvanMvaHR0cC1zdHJlYW1pbmcuXG4gKlxuICogRm9yIGxpdmUgREFTSCBtYW5pZmVzdHMsIGlmIGBwcmV2aW91c01hbmlmZXN0YCBpcyBwcm92aWRlZCBpbiBvcHRpb25zLCB0aGVuIHRoZSBuZXdseVxuICogcGFyc2VkIERBU0ggbWFuaWZlc3Qgd2lsbCBoYXZlIGl0cyBtZWRpYSBzZXF1ZW5jZSBhbmQgZGlzY29udGludWl0eSBzZXF1ZW5jZSB2YWx1ZXNcbiAqIHVwZGF0ZWQgdG8gcmVmbGVjdCBpdHMgcG9zaXRpb24gcmVsYXRpdmUgdG8gdGhlIHByaW9yIG1hbmlmZXN0LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBtYW5pZmVzdFN0cmluZyAtIHRoZSBEQVNIIG1hbmlmZXN0IGFzIGEgc3RyaW5nXG4gKiBAcGFyYW0ge29wdGlvbnN9IFtvcHRpb25zXSAtIGFueSBvcHRpb25zXG4gKlxuICogQHJldHVybiB7T2JqZWN0fSB0aGUgbWFuaWZlc3Qgb2JqZWN0XG4gKi9cblxuY29uc3QgcGFyc2UgPSAobWFuaWZlc3RTdHJpbmcsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICBjb25zdCBwYXJzZWRNYW5pZmVzdEluZm8gPSBpbmhlcml0QXR0cmlidXRlcyhzdHJpbmdUb01wZFhtbChtYW5pZmVzdFN0cmluZyksIG9wdGlvbnMpO1xuICBjb25zdCBwbGF5bGlzdHMgPSB0b1BsYXlsaXN0cyhwYXJzZWRNYW5pZmVzdEluZm8ucmVwcmVzZW50YXRpb25JbmZvKTtcbiAgcmV0dXJuIHRvTTN1OCh7XG4gICAgZGFzaFBsYXlsaXN0czogcGxheWxpc3RzLFxuICAgIGxvY2F0aW9uczogcGFyc2VkTWFuaWZlc3RJbmZvLmxvY2F0aW9ucyxcbiAgICBjb250ZW50U3RlZXJpbmc6IHBhcnNlZE1hbmlmZXN0SW5mby5jb250ZW50U3RlZXJpbmdJbmZvLFxuICAgIHNpZHhNYXBwaW5nOiBvcHRpb25zLnNpZHhNYXBwaW5nLFxuICAgIHByZXZpb3VzTWFuaWZlc3Q6IG9wdGlvbnMucHJldmlvdXNNYW5pZmVzdCxcbiAgICBldmVudFN0cmVhbTogcGFyc2VkTWFuaWZlc3RJbmZvLmV2ZW50U3RyZWFtXG4gIH0pO1xufTtcbi8qKlxuICogUGFyc2VzIHRoZSBtYW5pZmVzdCBmb3IgYSBVVENUaW1pbmcgbm9kZSwgcmV0dXJuaW5nIHRoZSBub2RlcyBhdHRyaWJ1dGVzIGlmIGZvdW5kXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG1hbmlmZXN0U3RyaW5nXG4gKiAgICAgICAgWE1MIHN0cmluZyBvZiB0aGUgTVBEIG1hbmlmZXN0XG4gKiBAcmV0dXJuIHtPYmplY3R8bnVsbH1cbiAqICAgICAgICAgQXR0cmlidXRlcyBvZiBVVENUaW1pbmcgbm9kZSBzcGVjaWZpZWQgaW4gdGhlIG1hbmlmZXN0LiBOdWxsIGlmIG5vbmUgZm91bmRcbiAqL1xuXG5cbmNvbnN0IHBhcnNlVVRDVGltaW5nID0gbWFuaWZlc3RTdHJpbmcgPT4gcGFyc2VVVENUaW1pbmdTY2hlbWUoc3RyaW5nVG9NcGRYbWwobWFuaWZlc3RTdHJpbmcpKTtcblxuZXhwb3J0cy5WRVJTSU9OID0gVkVSU0lPTjtcbmV4cG9ydHMuYWRkU2lkeFNlZ21lbnRzVG9QbGF5bGlzdCA9IGFkZFNpZHhTZWdtZW50c1RvUGxheWxpc3QkMTtcbmV4cG9ydHMuZ2VuZXJhdGVTaWR4S2V5ID0gZ2VuZXJhdGVTaWR4S2V5O1xuZXhwb3J0cy5pbmhlcml0QXR0cmlidXRlcyA9IGluaGVyaXRBdHRyaWJ1dGVzO1xuZXhwb3J0cy5wYXJzZSA9IHBhcnNlO1xuZXhwb3J0cy5wYXJzZVVUQ1RpbWluZyA9IHBhcnNlVVRDVGltaW5nO1xuZXhwb3J0cy5zdHJpbmdUb01wZFhtbCA9IHN0cmluZ1RvTXBkWG1sO1xuZXhwb3J0cy50b00zdTggPSB0b00zdTg7XG5leHBvcnRzLnRvUGxheWxpc3RzID0gdG9QbGF5bGlzdHM7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mpd-parser/dist/mpd-parser.cjs.js\n");

/***/ })

};
;