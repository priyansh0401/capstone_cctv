"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/m3u8-parser";
exports.ids = ["vendor-chunks/m3u8-parser"];
exports.modules = {

/***/ "(ssr)/./node_modules/m3u8-parser/dist/m3u8-parser.cjs.js":
/*!**********************************************************!*\
  !*** ./node_modules/m3u8-parser/dist/m3u8-parser.cjs.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/*! @name m3u8-parser @version 7.2.0 @license Apache-2.0 */\n\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\nvar Stream = __webpack_require__(/*! @videojs/vhs-utils/cjs/stream.js */ \"(ssr)/./node_modules/@videojs/vhs-utils/cjs/stream.js\");\nvar _extends = __webpack_require__(/*! @babel/runtime/helpers/extends */ \"(ssr)/./node_modules/@babel/runtime/helpers/extends.js\");\nvar decodeB64ToUint8Array = __webpack_require__(/*! @videojs/vhs-utils/cjs/decode-b64-to-uint8-array.js */ \"(ssr)/./node_modules/@videojs/vhs-utils/cjs/decode-b64-to-uint8-array.js\");\n\nfunction _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }\n\nvar Stream__default = /*#__PURE__*/_interopDefaultLegacy(Stream);\nvar _extends__default = /*#__PURE__*/_interopDefaultLegacy(_extends);\nvar decodeB64ToUint8Array__default = /*#__PURE__*/_interopDefaultLegacy(decodeB64ToUint8Array);\n\n/**\n * @file m3u8/line-stream.js\n */\n/**\n * A stream that buffers string input and generates a `data` event for each\n * line.\n *\n * @class LineStream\n * @extends Stream\n */\n\nclass LineStream extends Stream__default[\"default\"] {\n  constructor() {\n    super();\n    this.buffer = '';\n  }\n  /**\n   * Add new data to be parsed.\n   *\n   * @param {string} data the text to process\n   */\n\n\n  push(data) {\n    let nextNewline;\n    this.buffer += data;\n    nextNewline = this.buffer.indexOf('\\n');\n\n    for (; nextNewline > -1; nextNewline = this.buffer.indexOf('\\n')) {\n      this.trigger('data', this.buffer.substring(0, nextNewline));\n      this.buffer = this.buffer.substring(nextNewline + 1);\n    }\n  }\n\n}\n\nconst TAB = String.fromCharCode(0x09);\n\nconst parseByterange = function (byterangeString) {\n  // optionally match and capture 0+ digits before `@`\n  // optionally match and capture 0+ digits after `@`\n  const match = /([0-9.]*)?@?([0-9.]*)?/.exec(byterangeString || '');\n  const result = {};\n\n  if (match[1]) {\n    result.length = parseInt(match[1], 10);\n  }\n\n  if (match[2]) {\n    result.offset = parseInt(match[2], 10);\n  }\n\n  return result;\n};\n/**\n * \"forgiving\" attribute list psuedo-grammar:\n * attributes -> keyvalue (',' keyvalue)*\n * keyvalue   -> key '=' value\n * key        -> [^=]*\n * value      -> '\"' [^\"]* '\"' | [^,]*\n */\n\n\nconst attributeSeparator = function () {\n  const key = '[^=]*';\n  const value = '\"[^\"]*\"|[^,]*';\n  const keyvalue = '(?:' + key + ')=(?:' + value + ')';\n  return new RegExp('(?:^|,)(' + keyvalue + ')');\n};\n/**\n * Parse attributes from a line given the separator\n *\n * @param {string} attributes the attribute line to parse\n */\n\n\nconst parseAttributes = function (attributes) {\n  const result = {};\n\n  if (!attributes) {\n    return result;\n  } // split the string using attributes as the separator\n\n\n  const attrs = attributes.split(attributeSeparator());\n  let i = attrs.length;\n  let attr;\n\n  while (i--) {\n    // filter out unmatched portions of the string\n    if (attrs[i] === '') {\n      continue;\n    } // split the key and value\n\n\n    attr = /([^=]*)=(.*)/.exec(attrs[i]).slice(1); // trim whitespace and remove optional quotes around the value\n\n    attr[0] = attr[0].replace(/^\\s+|\\s+$/g, '');\n    attr[1] = attr[1].replace(/^\\s+|\\s+$/g, '');\n    attr[1] = attr[1].replace(/^['\"](.*)['\"]$/g, '$1');\n    result[attr[0]] = attr[1];\n  }\n\n  return result;\n};\n/**\n * Converts a string into a resolution object\n *\n * @param {string} resolution a string such as 3840x2160\n *\n * @return {Object} An object representing the resolution\n *\n */\n\n\nconst parseResolution = resolution => {\n  const split = resolution.split('x');\n  const result = {};\n\n  if (split[0]) {\n    result.width = parseInt(split[0], 10);\n  }\n\n  if (split[1]) {\n    result.height = parseInt(split[1], 10);\n  }\n\n  return result;\n};\n/**\n * A line-level M3U8 parser event stream. It expects to receive input one\n * line at a time and performs a context-free parse of its contents. A stream\n * interpretation of a manifest can be useful if the manifest is expected to\n * be too large to fit comfortably into memory or the entirety of the input\n * is not immediately available. Otherwise, it's probably much easier to work\n * with a regular `Parser` object.\n *\n * Produces `data` events with an object that captures the parser's\n * interpretation of the input. That object has a property `tag` that is one\n * of `uri`, `comment`, or `tag`. URIs only have a single additional\n * property, `line`, which captures the entirety of the input without\n * interpretation. Comments similarly have a single additional property\n * `text` which is the input without the leading `#`.\n *\n * Tags always have a property `tagType` which is the lower-cased version of\n * the M3U8 directive without the `#EXT` or `#EXT-X-` prefix. For instance,\n * `#EXT-X-MEDIA-SEQUENCE` becomes `media-sequence` when parsed. Unrecognized\n * tags are given the tag type `unknown` and a single additional property\n * `data` with the remainder of the input.\n *\n * @class ParseStream\n * @extends Stream\n */\n\n\nclass ParseStream extends Stream__default[\"default\"] {\n  constructor() {\n    super();\n    this.customParsers = [];\n    this.tagMappers = [];\n  }\n  /**\n   * Parses an additional line of input.\n   *\n   * @param {string} line a single line of an M3U8 file to parse\n   */\n\n\n  push(line) {\n    let match;\n    let event; // strip whitespace\n\n    line = line.trim();\n\n    if (line.length === 0) {\n      // ignore empty lines\n      return;\n    } // URIs\n\n\n    if (line[0] !== '#') {\n      this.trigger('data', {\n        type: 'uri',\n        uri: line\n      });\n      return;\n    } // map tags\n\n\n    const newLines = this.tagMappers.reduce((acc, mapper) => {\n      const mappedLine = mapper(line); // skip if unchanged\n\n      if (mappedLine === line) {\n        return acc;\n      }\n\n      return acc.concat([mappedLine]);\n    }, [line]);\n    newLines.forEach(newLine => {\n      for (let i = 0; i < this.customParsers.length; i++) {\n        if (this.customParsers[i].call(this, newLine)) {\n          return;\n        }\n      } // Comments\n\n\n      if (newLine.indexOf('#EXT') !== 0) {\n        this.trigger('data', {\n          type: 'comment',\n          text: newLine.slice(1)\n        });\n        return;\n      } // strip off any carriage returns here so the regex matching\n      // doesn't have to account for them.\n\n\n      newLine = newLine.replace('\\r', ''); // Tags\n\n      match = /^#EXTM3U/.exec(newLine);\n\n      if (match) {\n        this.trigger('data', {\n          type: 'tag',\n          tagType: 'm3u'\n        });\n        return;\n      }\n\n      match = /^#EXTINF:([0-9\\.]*)?,?(.*)?$/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'inf'\n        };\n\n        if (match[1]) {\n          event.duration = parseFloat(match[1]);\n        }\n\n        if (match[2]) {\n          event.title = match[2];\n        }\n\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-TARGETDURATION:([0-9.]*)?/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'targetduration'\n        };\n\n        if (match[1]) {\n          event.duration = parseInt(match[1], 10);\n        }\n\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-VERSION:([0-9.]*)?/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'version'\n        };\n\n        if (match[1]) {\n          event.version = parseInt(match[1], 10);\n        }\n\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-MEDIA-SEQUENCE:(\\-?[0-9.]*)?/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'media-sequence'\n        };\n\n        if (match[1]) {\n          event.number = parseInt(match[1], 10);\n        }\n\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-DISCONTINUITY-SEQUENCE:(\\-?[0-9.]*)?/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'discontinuity-sequence'\n        };\n\n        if (match[1]) {\n          event.number = parseInt(match[1], 10);\n        }\n\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-PLAYLIST-TYPE:(.*)?$/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'playlist-type'\n        };\n\n        if (match[1]) {\n          event.playlistType = match[1];\n        }\n\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-BYTERANGE:(.*)?$/.exec(newLine);\n\n      if (match) {\n        event = _extends__default[\"default\"](parseByterange(match[1]), {\n          type: 'tag',\n          tagType: 'byterange'\n        });\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-ALLOW-CACHE:(YES|NO)?/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'allow-cache'\n        };\n\n        if (match[1]) {\n          event.allowed = !/NO/.test(match[1]);\n        }\n\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-MAP:(.*)$/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'map'\n        };\n\n        if (match[1]) {\n          const attributes = parseAttributes(match[1]);\n\n          if (attributes.URI) {\n            event.uri = attributes.URI;\n          }\n\n          if (attributes.BYTERANGE) {\n            event.byterange = parseByterange(attributes.BYTERANGE);\n          }\n        }\n\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-STREAM-INF:(.*)$/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'stream-inf'\n        };\n\n        if (match[1]) {\n          event.attributes = parseAttributes(match[1]);\n\n          if (event.attributes.RESOLUTION) {\n            event.attributes.RESOLUTION = parseResolution(event.attributes.RESOLUTION);\n          }\n\n          if (event.attributes.BANDWIDTH) {\n            event.attributes.BANDWIDTH = parseInt(event.attributes.BANDWIDTH, 10);\n          }\n\n          if (event.attributes['FRAME-RATE']) {\n            event.attributes['FRAME-RATE'] = parseFloat(event.attributes['FRAME-RATE']);\n          }\n\n          if (event.attributes['PROGRAM-ID']) {\n            event.attributes['PROGRAM-ID'] = parseInt(event.attributes['PROGRAM-ID'], 10);\n          }\n        }\n\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-MEDIA:(.*)$/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'media'\n        };\n\n        if (match[1]) {\n          event.attributes = parseAttributes(match[1]);\n        }\n\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-ENDLIST/.exec(newLine);\n\n      if (match) {\n        this.trigger('data', {\n          type: 'tag',\n          tagType: 'endlist'\n        });\n        return;\n      }\n\n      match = /^#EXT-X-DISCONTINUITY/.exec(newLine);\n\n      if (match) {\n        this.trigger('data', {\n          type: 'tag',\n          tagType: 'discontinuity'\n        });\n        return;\n      }\n\n      match = /^#EXT-X-PROGRAM-DATE-TIME:(.*)$/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'program-date-time'\n        };\n\n        if (match[1]) {\n          event.dateTimeString = match[1];\n          event.dateTimeObject = new Date(match[1]);\n        }\n\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-KEY:(.*)$/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'key'\n        };\n\n        if (match[1]) {\n          event.attributes = parseAttributes(match[1]); // parse the IV string into a Uint32Array\n\n          if (event.attributes.IV) {\n            if (event.attributes.IV.substring(0, 2).toLowerCase() === '0x') {\n              event.attributes.IV = event.attributes.IV.substring(2);\n            }\n\n            event.attributes.IV = event.attributes.IV.match(/.{8}/g);\n            event.attributes.IV[0] = parseInt(event.attributes.IV[0], 16);\n            event.attributes.IV[1] = parseInt(event.attributes.IV[1], 16);\n            event.attributes.IV[2] = parseInt(event.attributes.IV[2], 16);\n            event.attributes.IV[3] = parseInt(event.attributes.IV[3], 16);\n            event.attributes.IV = new Uint32Array(event.attributes.IV);\n          }\n        }\n\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-START:(.*)$/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'start'\n        };\n\n        if (match[1]) {\n          event.attributes = parseAttributes(match[1]);\n          event.attributes['TIME-OFFSET'] = parseFloat(event.attributes['TIME-OFFSET']);\n          event.attributes.PRECISE = /YES/.test(event.attributes.PRECISE);\n        }\n\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-CUE-OUT-CONT:(.*)?$/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'cue-out-cont'\n        };\n\n        if (match[1]) {\n          event.data = match[1];\n        } else {\n          event.data = '';\n        }\n\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-CUE-OUT:(.*)?$/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'cue-out'\n        };\n\n        if (match[1]) {\n          event.data = match[1];\n        } else {\n          event.data = '';\n        }\n\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-CUE-IN:?(.*)?$/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'cue-in'\n        };\n\n        if (match[1]) {\n          event.data = match[1];\n        } else {\n          event.data = '';\n        }\n\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-SKIP:(.*)$/.exec(newLine);\n\n      if (match && match[1]) {\n        event = {\n          type: 'tag',\n          tagType: 'skip'\n        };\n        event.attributes = parseAttributes(match[1]);\n\n        if (event.attributes.hasOwnProperty('SKIPPED-SEGMENTS')) {\n          event.attributes['SKIPPED-SEGMENTS'] = parseInt(event.attributes['SKIPPED-SEGMENTS'], 10);\n        }\n\n        if (event.attributes.hasOwnProperty('RECENTLY-REMOVED-DATERANGES')) {\n          event.attributes['RECENTLY-REMOVED-DATERANGES'] = event.attributes['RECENTLY-REMOVED-DATERANGES'].split(TAB);\n        }\n\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-PART:(.*)$/.exec(newLine);\n\n      if (match && match[1]) {\n        event = {\n          type: 'tag',\n          tagType: 'part'\n        };\n        event.attributes = parseAttributes(match[1]);\n        ['DURATION'].forEach(function (key) {\n          if (event.attributes.hasOwnProperty(key)) {\n            event.attributes[key] = parseFloat(event.attributes[key]);\n          }\n        });\n        ['INDEPENDENT', 'GAP'].forEach(function (key) {\n          if (event.attributes.hasOwnProperty(key)) {\n            event.attributes[key] = /YES/.test(event.attributes[key]);\n          }\n        });\n\n        if (event.attributes.hasOwnProperty('BYTERANGE')) {\n          event.attributes.byterange = parseByterange(event.attributes.BYTERANGE);\n        }\n\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-SERVER-CONTROL:(.*)$/.exec(newLine);\n\n      if (match && match[1]) {\n        event = {\n          type: 'tag',\n          tagType: 'server-control'\n        };\n        event.attributes = parseAttributes(match[1]);\n        ['CAN-SKIP-UNTIL', 'PART-HOLD-BACK', 'HOLD-BACK'].forEach(function (key) {\n          if (event.attributes.hasOwnProperty(key)) {\n            event.attributes[key] = parseFloat(event.attributes[key]);\n          }\n        });\n        ['CAN-SKIP-DATERANGES', 'CAN-BLOCK-RELOAD'].forEach(function (key) {\n          if (event.attributes.hasOwnProperty(key)) {\n            event.attributes[key] = /YES/.test(event.attributes[key]);\n          }\n        });\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-PART-INF:(.*)$/.exec(newLine);\n\n      if (match && match[1]) {\n        event = {\n          type: 'tag',\n          tagType: 'part-inf'\n        };\n        event.attributes = parseAttributes(match[1]);\n        ['PART-TARGET'].forEach(function (key) {\n          if (event.attributes.hasOwnProperty(key)) {\n            event.attributes[key] = parseFloat(event.attributes[key]);\n          }\n        });\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-PRELOAD-HINT:(.*)$/.exec(newLine);\n\n      if (match && match[1]) {\n        event = {\n          type: 'tag',\n          tagType: 'preload-hint'\n        };\n        event.attributes = parseAttributes(match[1]);\n        ['BYTERANGE-START', 'BYTERANGE-LENGTH'].forEach(function (key) {\n          if (event.attributes.hasOwnProperty(key)) {\n            event.attributes[key] = parseInt(event.attributes[key], 10);\n            const subkey = key === 'BYTERANGE-LENGTH' ? 'length' : 'offset';\n            event.attributes.byterange = event.attributes.byterange || {};\n            event.attributes.byterange[subkey] = event.attributes[key]; // only keep the parsed byterange object.\n\n            delete event.attributes[key];\n          }\n        });\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-RENDITION-REPORT:(.*)$/.exec(newLine);\n\n      if (match && match[1]) {\n        event = {\n          type: 'tag',\n          tagType: 'rendition-report'\n        };\n        event.attributes = parseAttributes(match[1]);\n        ['LAST-MSN', 'LAST-PART'].forEach(function (key) {\n          if (event.attributes.hasOwnProperty(key)) {\n            event.attributes[key] = parseInt(event.attributes[key], 10);\n          }\n        });\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-DATERANGE:(.*)$/.exec(newLine);\n\n      if (match && match[1]) {\n        event = {\n          type: 'tag',\n          tagType: 'daterange'\n        };\n        event.attributes = parseAttributes(match[1]);\n        ['ID', 'CLASS'].forEach(function (key) {\n          if (event.attributes.hasOwnProperty(key)) {\n            event.attributes[key] = String(event.attributes[key]);\n          }\n        });\n        ['START-DATE', 'END-DATE'].forEach(function (key) {\n          if (event.attributes.hasOwnProperty(key)) {\n            event.attributes[key] = new Date(event.attributes[key]);\n          }\n        });\n        ['DURATION', 'PLANNED-DURATION'].forEach(function (key) {\n          if (event.attributes.hasOwnProperty(key)) {\n            event.attributes[key] = parseFloat(event.attributes[key]);\n          }\n        });\n        ['END-ON-NEXT'].forEach(function (key) {\n          if (event.attributes.hasOwnProperty(key)) {\n            event.attributes[key] = /YES/i.test(event.attributes[key]);\n          }\n        });\n        ['SCTE35-CMD', ' SCTE35-OUT', 'SCTE35-IN'].forEach(function (key) {\n          if (event.attributes.hasOwnProperty(key)) {\n            event.attributes[key] = event.attributes[key].toString(16);\n          }\n        });\n        const clientAttributePattern = /^X-([A-Z]+-)+[A-Z]+$/;\n\n        for (const key in event.attributes) {\n          if (!clientAttributePattern.test(key)) {\n            continue;\n          }\n\n          const isHexaDecimal = /[0-9A-Fa-f]{6}/g.test(event.attributes[key]);\n          const isDecimalFloating = /^\\d+(\\.\\d+)?$/.test(event.attributes[key]);\n          event.attributes[key] = isHexaDecimal ? event.attributes[key].toString(16) : isDecimalFloating ? parseFloat(event.attributes[key]) : String(event.attributes[key]);\n        }\n\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-INDEPENDENT-SEGMENTS/.exec(newLine);\n\n      if (match) {\n        this.trigger('data', {\n          type: 'tag',\n          tagType: 'independent-segments'\n        });\n        return;\n      }\n\n      match = /^#EXT-X-I-FRAMES-ONLY/.exec(newLine);\n\n      if (match) {\n        this.trigger('data', {\n          type: 'tag',\n          tagType: 'i-frames-only'\n        });\n        return;\n      }\n\n      match = /^#EXT-X-CONTENT-STEERING:(.*)$/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'content-steering'\n        };\n        event.attributes = parseAttributes(match[1]);\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-I-FRAME-STREAM-INF:(.*)$/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'i-frame-playlist'\n        };\n        event.attributes = parseAttributes(match[1]);\n\n        if (event.attributes.URI) {\n          event.uri = event.attributes.URI;\n        }\n\n        if (event.attributes.BANDWIDTH) {\n          event.attributes.BANDWIDTH = parseInt(event.attributes.BANDWIDTH, 10);\n        }\n\n        if (event.attributes.RESOLUTION) {\n          event.attributes.RESOLUTION = parseResolution(event.attributes.RESOLUTION);\n        }\n\n        if (event.attributes['AVERAGE-BANDWIDTH']) {\n          event.attributes['AVERAGE-BANDWIDTH'] = parseInt(event.attributes['AVERAGE-BANDWIDTH'], 10);\n        }\n\n        if (event.attributes['FRAME-RATE']) {\n          event.attributes['FRAME-RATE'] = parseFloat(event.attributes['FRAME-RATE']);\n        }\n\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-DEFINE:(.*)$/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'define'\n        };\n        event.attributes = parseAttributes(match[1]);\n        this.trigger('data', event);\n        return;\n      } // unknown tag type\n\n\n      this.trigger('data', {\n        type: 'tag',\n        data: newLine.slice(4)\n      });\n    });\n  }\n  /**\n   * Add a parser for custom headers\n   *\n   * @param {Object}   options              a map of options for the added parser\n   * @param {RegExp}   options.expression   a regular expression to match the custom header\n   * @param {string}   options.customType   the custom type to register to the output\n   * @param {Function} [options.dataParser] function to parse the line into an object\n   * @param {boolean}  [options.segment]    should tag data be attached to the segment object\n   */\n\n\n  addParser({\n    expression,\n    customType,\n    dataParser,\n    segment\n  }) {\n    if (typeof dataParser !== 'function') {\n      dataParser = line => line;\n    }\n\n    this.customParsers.push(line => {\n      const match = expression.exec(line);\n\n      if (match) {\n        this.trigger('data', {\n          type: 'custom',\n          data: dataParser(line),\n          customType,\n          segment\n        });\n        return true;\n      }\n    });\n  }\n  /**\n   * Add a custom header mapper\n   *\n   * @param {Object}   options\n   * @param {RegExp}   options.expression   a regular expression to match the custom header\n   * @param {Function} options.map          function to translate tag into a different tag\n   */\n\n\n  addTagMapper({\n    expression,\n    map\n  }) {\n    const mapFn = line => {\n      if (expression.test(line)) {\n        return map(line);\n      }\n\n      return line;\n    };\n\n    this.tagMappers.push(mapFn);\n  }\n\n}\n\nconst camelCase = str => str.toLowerCase().replace(/-(\\w)/g, a => a[1].toUpperCase());\n\nconst camelCaseKeys = function (attributes) {\n  const result = {};\n  Object.keys(attributes).forEach(function (key) {\n    result[camelCase(key)] = attributes[key];\n  });\n  return result;\n}; // set SERVER-CONTROL hold back based upon targetDuration and partTargetDuration\n// we need this helper because defaults are based upon targetDuration and\n// partTargetDuration being set, but they may not be if SERVER-CONTROL appears before\n// target durations are set.\n\n\nconst setHoldBack = function (manifest) {\n  const {\n    serverControl,\n    targetDuration,\n    partTargetDuration\n  } = manifest;\n\n  if (!serverControl) {\n    return;\n  }\n\n  const tag = '#EXT-X-SERVER-CONTROL';\n  const hb = 'holdBack';\n  const phb = 'partHoldBack';\n  const minTargetDuration = targetDuration && targetDuration * 3;\n  const minPartDuration = partTargetDuration && partTargetDuration * 2;\n\n  if (targetDuration && !serverControl.hasOwnProperty(hb)) {\n    serverControl[hb] = minTargetDuration;\n    this.trigger('info', {\n      message: `${tag} defaulting HOLD-BACK to targetDuration * 3 (${minTargetDuration}).`\n    });\n  }\n\n  if (minTargetDuration && serverControl[hb] < minTargetDuration) {\n    this.trigger('warn', {\n      message: `${tag} clamping HOLD-BACK (${serverControl[hb]}) to targetDuration * 3 (${minTargetDuration})`\n    });\n    serverControl[hb] = minTargetDuration;\n  } // default no part hold back to part target duration * 3\n\n\n  if (partTargetDuration && !serverControl.hasOwnProperty(phb)) {\n    serverControl[phb] = partTargetDuration * 3;\n    this.trigger('info', {\n      message: `${tag} defaulting PART-HOLD-BACK to partTargetDuration * 3 (${serverControl[phb]}).`\n    });\n  } // if part hold back is too small default it to part target duration * 2\n\n\n  if (partTargetDuration && serverControl[phb] < minPartDuration) {\n    this.trigger('warn', {\n      message: `${tag} clamping PART-HOLD-BACK (${serverControl[phb]}) to partTargetDuration * 2 (${minPartDuration}).`\n    });\n    serverControl[phb] = minPartDuration;\n  }\n};\n/**\n * A parser for M3U8 files. The current interpretation of the input is\n * exposed as a property `manifest` on parser objects. It's just two lines to\n * create and parse a manifest once you have the contents available as a string:\n *\n * ```js\n * var parser = new m3u8.Parser();\n * parser.push(xhr.responseText);\n * ```\n *\n * New input can later be applied to update the manifest object by calling\n * `push` again.\n *\n * The parser attempts to create a usable manifest object even if the\n * underlying input is somewhat nonsensical. It emits `info` and `warning`\n * events during the parse if it encounters input that seems invalid or\n * requires some property of the manifest object to be defaulted.\n *\n * @class Parser\n * @param {Object} [opts] Options for the constructor, needed for substitutions\n * @param {string} [opts.uri] URL to check for query params\n * @param {Object} [opts.mainDefinitions] Definitions on main playlist that can be imported\n * @extends Stream\n */\n\n\nclass Parser extends Stream__default[\"default\"] {\n  constructor(opts = {}) {\n    super();\n    this.lineStream = new LineStream();\n    this.parseStream = new ParseStream();\n    this.lineStream.pipe(this.parseStream);\n    this.mainDefinitions = opts.mainDefinitions || {};\n    this.params = new URL(opts.uri, 'https://a.com').searchParams;\n    this.lastProgramDateTime = null;\n    /* eslint-disable consistent-this */\n\n    const self = this;\n    /* eslint-enable consistent-this */\n\n    const uris = [];\n    let currentUri = {}; // if specified, the active EXT-X-MAP definition\n\n    let currentMap; // if specified, the active decryption key\n\n    let key;\n    let hasParts = false;\n\n    const noop = function () {};\n\n    const defaultMediaGroups = {\n      'AUDIO': {},\n      'VIDEO': {},\n      'CLOSED-CAPTIONS': {},\n      'SUBTITLES': {}\n    }; // This is the Widevine UUID from DASH IF IOP. The same exact string is\n    // used in MPDs with Widevine encrypted streams.\n\n    const widevineUuid = 'urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed'; // group segments into numbered timelines delineated by discontinuities\n\n    let currentTimeline = 0; // the manifest is empty until the parse stream begins delivering data\n\n    this.manifest = {\n      allowCache: true,\n      discontinuityStarts: [],\n      dateRanges: [],\n      iFramePlaylists: [],\n      segments: []\n    }; // keep track of the last seen segment's byte range end, as segments are not required\n    // to provide the offset, in which case it defaults to the next byte after the\n    // previous segment\n\n    let lastByterangeEnd = 0; // keep track of the last seen part's byte range end.\n\n    let lastPartByterangeEnd = 0;\n    const dateRangeTags = {};\n    this.on('end', () => {\n      // only add preloadSegment if we don't yet have a uri for it.\n      // and we actually have parts/preloadHints\n      if (currentUri.uri || !currentUri.parts && !currentUri.preloadHints) {\n        return;\n      }\n\n      if (!currentUri.map && currentMap) {\n        currentUri.map = currentMap;\n      }\n\n      if (!currentUri.key && key) {\n        currentUri.key = key;\n      }\n\n      if (!currentUri.timeline && typeof currentTimeline === 'number') {\n        currentUri.timeline = currentTimeline;\n      }\n\n      this.manifest.preloadSegment = currentUri;\n    }); // update the manifest with the m3u8 entry from the parse stream\n\n    this.parseStream.on('data', function (entry) {\n      let mediaGroup;\n      let rendition; // Replace variables in uris and attributes as defined in #EXT-X-DEFINE tags\n\n      if (self.manifest.definitions) {\n        for (const def in self.manifest.definitions) {\n          if (entry.uri) {\n            entry.uri = entry.uri.replace(`{$${def}}`, self.manifest.definitions[def]);\n          }\n\n          if (entry.attributes) {\n            for (const attr in entry.attributes) {\n              if (typeof entry.attributes[attr] === 'string') {\n                entry.attributes[attr] = entry.attributes[attr].replace(`{$${def}}`, self.manifest.definitions[def]);\n              }\n            }\n          }\n        }\n      }\n\n      ({\n        tag() {\n          // switch based on the tag type\n          (({\n            version() {\n              if (entry.version) {\n                this.manifest.version = entry.version;\n              }\n            },\n\n            'allow-cache'() {\n              this.manifest.allowCache = entry.allowed;\n\n              if (!('allowed' in entry)) {\n                this.trigger('info', {\n                  message: 'defaulting allowCache to YES'\n                });\n                this.manifest.allowCache = true;\n              }\n            },\n\n            byterange() {\n              const byterange = {};\n\n              if ('length' in entry) {\n                currentUri.byterange = byterange;\n                byterange.length = entry.length;\n\n                if (!('offset' in entry)) {\n                  /*\n                   * From the latest spec (as of this writing):\n                   * https://tools.ietf.org/html/draft-pantos-http-live-streaming-23#section-4.3.2.2\n                   *\n                   * Same text since EXT-X-BYTERANGE's introduction in draft 7:\n                   * https://tools.ietf.org/html/draft-pantos-http-live-streaming-07#section-3.3.1)\n                   *\n                   * \"If o [offset] is not present, the sub-range begins at the next byte\n                   * following the sub-range of the previous media segment.\"\n                   */\n                  entry.offset = lastByterangeEnd;\n                }\n              }\n\n              if ('offset' in entry) {\n                currentUri.byterange = byterange;\n                byterange.offset = entry.offset;\n              }\n\n              lastByterangeEnd = byterange.offset + byterange.length;\n            },\n\n            endlist() {\n              this.manifest.endList = true;\n            },\n\n            inf() {\n              if (!('mediaSequence' in this.manifest)) {\n                this.manifest.mediaSequence = 0;\n                this.trigger('info', {\n                  message: 'defaulting media sequence to zero'\n                });\n              }\n\n              if (!('discontinuitySequence' in this.manifest)) {\n                this.manifest.discontinuitySequence = 0;\n                this.trigger('info', {\n                  message: 'defaulting discontinuity sequence to zero'\n                });\n              }\n\n              if (entry.title) {\n                currentUri.title = entry.title;\n              }\n\n              if (entry.duration > 0) {\n                currentUri.duration = entry.duration;\n              }\n\n              if (entry.duration === 0) {\n                currentUri.duration = 0.01;\n                this.trigger('info', {\n                  message: 'updating zero segment duration to a small value'\n                });\n              }\n\n              this.manifest.segments = uris;\n            },\n\n            key() {\n              if (!entry.attributes) {\n                this.trigger('warn', {\n                  message: 'ignoring key declaration without attribute list'\n                });\n                return;\n              } // clear the active encryption key\n\n\n              if (entry.attributes.METHOD === 'NONE') {\n                key = null;\n                return;\n              }\n\n              if (!entry.attributes.URI) {\n                this.trigger('warn', {\n                  message: 'ignoring key declaration without URI'\n                });\n                return;\n              }\n\n              if (entry.attributes.KEYFORMAT === 'com.apple.streamingkeydelivery') {\n                this.manifest.contentProtection = this.manifest.contentProtection || {}; // TODO: add full support for this.\n\n                this.manifest.contentProtection['com.apple.fps.1_0'] = {\n                  attributes: entry.attributes\n                };\n                return;\n              }\n\n              if (entry.attributes.KEYFORMAT === 'com.microsoft.playready') {\n                this.manifest.contentProtection = this.manifest.contentProtection || {}; // TODO: add full support for this.\n\n                this.manifest.contentProtection['com.microsoft.playready'] = {\n                  uri: entry.attributes.URI\n                };\n                return;\n              } // check if the content is encrypted for Widevine\n              // Widevine/HLS spec: https://storage.googleapis.com/wvdocs/Widevine_DRM_HLS.pdf\n\n\n              if (entry.attributes.KEYFORMAT === widevineUuid) {\n                const VALID_METHODS = ['SAMPLE-AES', 'SAMPLE-AES-CTR', 'SAMPLE-AES-CENC'];\n\n                if (VALID_METHODS.indexOf(entry.attributes.METHOD) === -1) {\n                  this.trigger('warn', {\n                    message: 'invalid key method provided for Widevine'\n                  });\n                  return;\n                }\n\n                if (entry.attributes.METHOD === 'SAMPLE-AES-CENC') {\n                  this.trigger('warn', {\n                    message: 'SAMPLE-AES-CENC is deprecated, please use SAMPLE-AES-CTR instead'\n                  });\n                }\n\n                if (entry.attributes.URI.substring(0, 23) !== 'data:text/plain;base64,') {\n                  this.trigger('warn', {\n                    message: 'invalid key URI provided for Widevine'\n                  });\n                  return;\n                }\n\n                if (!(entry.attributes.KEYID && entry.attributes.KEYID.substring(0, 2) === '0x')) {\n                  this.trigger('warn', {\n                    message: 'invalid key ID provided for Widevine'\n                  });\n                  return;\n                } // if Widevine key attributes are valid, store them as `contentProtection`\n                // on the manifest to emulate Widevine tag structure in a DASH mpd\n\n\n                this.manifest.contentProtection = this.manifest.contentProtection || {};\n                this.manifest.contentProtection['com.widevine.alpha'] = {\n                  attributes: {\n                    schemeIdUri: entry.attributes.KEYFORMAT,\n                    // remove '0x' from the key id string\n                    keyId: entry.attributes.KEYID.substring(2)\n                  },\n                  // decode the base64-encoded PSSH box\n                  pssh: decodeB64ToUint8Array__default[\"default\"](entry.attributes.URI.split(',')[1])\n                };\n                return;\n              }\n\n              if (!entry.attributes.METHOD) {\n                this.trigger('warn', {\n                  message: 'defaulting key method to AES-128'\n                });\n              } // setup an encryption key for upcoming segments\n\n\n              key = {\n                method: entry.attributes.METHOD || 'AES-128',\n                uri: entry.attributes.URI\n              };\n\n              if (typeof entry.attributes.IV !== 'undefined') {\n                key.iv = entry.attributes.IV;\n              }\n            },\n\n            'media-sequence'() {\n              if (!isFinite(entry.number)) {\n                this.trigger('warn', {\n                  message: 'ignoring invalid media sequence: ' + entry.number\n                });\n                return;\n              }\n\n              this.manifest.mediaSequence = entry.number;\n            },\n\n            'discontinuity-sequence'() {\n              if (!isFinite(entry.number)) {\n                this.trigger('warn', {\n                  message: 'ignoring invalid discontinuity sequence: ' + entry.number\n                });\n                return;\n              }\n\n              this.manifest.discontinuitySequence = entry.number;\n              currentTimeline = entry.number;\n            },\n\n            'playlist-type'() {\n              if (!/VOD|EVENT/.test(entry.playlistType)) {\n                this.trigger('warn', {\n                  message: 'ignoring unknown playlist type: ' + entry.playlist\n                });\n                return;\n              }\n\n              this.manifest.playlistType = entry.playlistType;\n            },\n\n            map() {\n              currentMap = {};\n\n              if (entry.uri) {\n                currentMap.uri = entry.uri;\n              }\n\n              if (entry.byterange) {\n                currentMap.byterange = entry.byterange;\n              }\n\n              if (key) {\n                currentMap.key = key;\n              }\n            },\n\n            'stream-inf'() {\n              this.manifest.playlists = uris;\n              this.manifest.mediaGroups = this.manifest.mediaGroups || defaultMediaGroups;\n\n              if (!entry.attributes) {\n                this.trigger('warn', {\n                  message: 'ignoring empty stream-inf attributes'\n                });\n                return;\n              }\n\n              if (!currentUri.attributes) {\n                currentUri.attributes = {};\n              }\n\n              _extends__default[\"default\"](currentUri.attributes, entry.attributes);\n            },\n\n            media() {\n              this.manifest.mediaGroups = this.manifest.mediaGroups || defaultMediaGroups;\n\n              if (!(entry.attributes && entry.attributes.TYPE && entry.attributes['GROUP-ID'] && entry.attributes.NAME)) {\n                this.trigger('warn', {\n                  message: 'ignoring incomplete or missing media group'\n                });\n                return;\n              } // find the media group, creating defaults as necessary\n\n\n              const mediaGroupType = this.manifest.mediaGroups[entry.attributes.TYPE];\n              mediaGroupType[entry.attributes['GROUP-ID']] = mediaGroupType[entry.attributes['GROUP-ID']] || {};\n              mediaGroup = mediaGroupType[entry.attributes['GROUP-ID']]; // collect the rendition metadata\n\n              rendition = {\n                default: /yes/i.test(entry.attributes.DEFAULT)\n              };\n\n              if (rendition.default) {\n                rendition.autoselect = true;\n              } else {\n                rendition.autoselect = /yes/i.test(entry.attributes.AUTOSELECT);\n              }\n\n              if (entry.attributes.LANGUAGE) {\n                rendition.language = entry.attributes.LANGUAGE;\n              }\n\n              if (entry.attributes.URI) {\n                rendition.uri = entry.attributes.URI;\n              }\n\n              if (entry.attributes['INSTREAM-ID']) {\n                rendition.instreamId = entry.attributes['INSTREAM-ID'];\n              }\n\n              if (entry.attributes.CHARACTERISTICS) {\n                rendition.characteristics = entry.attributes.CHARACTERISTICS;\n              }\n\n              if (entry.attributes.FORCED) {\n                rendition.forced = /yes/i.test(entry.attributes.FORCED);\n              } // insert the new rendition\n\n\n              mediaGroup[entry.attributes.NAME] = rendition;\n            },\n\n            discontinuity() {\n              currentTimeline += 1;\n              currentUri.discontinuity = true;\n              this.manifest.discontinuityStarts.push(uris.length);\n            },\n\n            'program-date-time'() {\n              if (typeof this.manifest.dateTimeString === 'undefined') {\n                // PROGRAM-DATE-TIME is a media-segment tag, but for backwards\n                // compatibility, we add the first occurence of the PROGRAM-DATE-TIME tag\n                // to the manifest object\n                // TODO: Consider removing this in future major version\n                this.manifest.dateTimeString = entry.dateTimeString;\n                this.manifest.dateTimeObject = entry.dateTimeObject;\n              }\n\n              currentUri.dateTimeString = entry.dateTimeString;\n              currentUri.dateTimeObject = entry.dateTimeObject;\n              const {\n                lastProgramDateTime\n              } = this;\n              this.lastProgramDateTime = new Date(entry.dateTimeString).getTime(); // We should extrapolate Program Date Time backward only during first program date time occurrence.\n              // Once we have at least one program date time point, we can always extrapolate it forward using lastProgramDateTime reference.\n\n              if (lastProgramDateTime === null) {\n                // Extrapolate Program Date Time backward\n                // Since it is first program date time occurrence we're assuming that\n                // all this.manifest.segments have no program date time info\n                this.manifest.segments.reduceRight((programDateTime, segment) => {\n                  segment.programDateTime = programDateTime - segment.duration * 1000;\n                  return segment.programDateTime;\n                }, this.lastProgramDateTime);\n              }\n            },\n\n            targetduration() {\n              if (!isFinite(entry.duration) || entry.duration < 0) {\n                this.trigger('warn', {\n                  message: 'ignoring invalid target duration: ' + entry.duration\n                });\n                return;\n              }\n\n              this.manifest.targetDuration = entry.duration;\n              setHoldBack.call(this, this.manifest);\n            },\n\n            start() {\n              if (!entry.attributes || isNaN(entry.attributes['TIME-OFFSET'])) {\n                this.trigger('warn', {\n                  message: 'ignoring start declaration without appropriate attribute list'\n                });\n                return;\n              }\n\n              this.manifest.start = {\n                timeOffset: entry.attributes['TIME-OFFSET'],\n                precise: entry.attributes.PRECISE\n              };\n            },\n\n            'cue-out'() {\n              currentUri.cueOut = entry.data;\n            },\n\n            'cue-out-cont'() {\n              currentUri.cueOutCont = entry.data;\n            },\n\n            'cue-in'() {\n              currentUri.cueIn = entry.data;\n            },\n\n            'skip'() {\n              this.manifest.skip = camelCaseKeys(entry.attributes);\n              this.warnOnMissingAttributes_('#EXT-X-SKIP', entry.attributes, ['SKIPPED-SEGMENTS']);\n            },\n\n            'part'() {\n              hasParts = true; // parts are always specifed before a segment\n\n              const segmentIndex = this.manifest.segments.length;\n              const part = camelCaseKeys(entry.attributes);\n              currentUri.parts = currentUri.parts || [];\n              currentUri.parts.push(part);\n\n              if (part.byterange) {\n                if (!part.byterange.hasOwnProperty('offset')) {\n                  part.byterange.offset = lastPartByterangeEnd;\n                }\n\n                lastPartByterangeEnd = part.byterange.offset + part.byterange.length;\n              }\n\n              const partIndex = currentUri.parts.length - 1;\n              this.warnOnMissingAttributes_(`#EXT-X-PART #${partIndex} for segment #${segmentIndex}`, entry.attributes, ['URI', 'DURATION']);\n\n              if (this.manifest.renditionReports) {\n                this.manifest.renditionReports.forEach((r, i) => {\n                  if (!r.hasOwnProperty('lastPart')) {\n                    this.trigger('warn', {\n                      message: `#EXT-X-RENDITION-REPORT #${i} lacks required attribute(s): LAST-PART`\n                    });\n                  }\n                });\n              }\n            },\n\n            'server-control'() {\n              const attrs = this.manifest.serverControl = camelCaseKeys(entry.attributes);\n\n              if (!attrs.hasOwnProperty('canBlockReload')) {\n                attrs.canBlockReload = false;\n                this.trigger('info', {\n                  message: '#EXT-X-SERVER-CONTROL defaulting CAN-BLOCK-RELOAD to false'\n                });\n              }\n\n              setHoldBack.call(this, this.manifest);\n\n              if (attrs.canSkipDateranges && !attrs.hasOwnProperty('canSkipUntil')) {\n                this.trigger('warn', {\n                  message: '#EXT-X-SERVER-CONTROL lacks required attribute CAN-SKIP-UNTIL which is required when CAN-SKIP-DATERANGES is set'\n                });\n              }\n            },\n\n            'preload-hint'() {\n              // parts are always specifed before a segment\n              const segmentIndex = this.manifest.segments.length;\n              const hint = camelCaseKeys(entry.attributes);\n              const isPart = hint.type && hint.type === 'PART';\n              currentUri.preloadHints = currentUri.preloadHints || [];\n              currentUri.preloadHints.push(hint);\n\n              if (hint.byterange) {\n                if (!hint.byterange.hasOwnProperty('offset')) {\n                  // use last part byterange end or zero if not a part.\n                  hint.byterange.offset = isPart ? lastPartByterangeEnd : 0;\n\n                  if (isPart) {\n                    lastPartByterangeEnd = hint.byterange.offset + hint.byterange.length;\n                  }\n                }\n              }\n\n              const index = currentUri.preloadHints.length - 1;\n              this.warnOnMissingAttributes_(`#EXT-X-PRELOAD-HINT #${index} for segment #${segmentIndex}`, entry.attributes, ['TYPE', 'URI']);\n\n              if (!hint.type) {\n                return;\n              } // search through all preload hints except for the current one for\n              // a duplicate type.\n\n\n              for (let i = 0; i < currentUri.preloadHints.length - 1; i++) {\n                const otherHint = currentUri.preloadHints[i];\n\n                if (!otherHint.type) {\n                  continue;\n                }\n\n                if (otherHint.type === hint.type) {\n                  this.trigger('warn', {\n                    message: `#EXT-X-PRELOAD-HINT #${index} for segment #${segmentIndex} has the same TYPE ${hint.type} as preload hint #${i}`\n                  });\n                }\n              }\n            },\n\n            'rendition-report'() {\n              const report = camelCaseKeys(entry.attributes);\n              this.manifest.renditionReports = this.manifest.renditionReports || [];\n              this.manifest.renditionReports.push(report);\n              const index = this.manifest.renditionReports.length - 1;\n              const required = ['LAST-MSN', 'URI'];\n\n              if (hasParts) {\n                required.push('LAST-PART');\n              }\n\n              this.warnOnMissingAttributes_(`#EXT-X-RENDITION-REPORT #${index}`, entry.attributes, required);\n            },\n\n            'part-inf'() {\n              this.manifest.partInf = camelCaseKeys(entry.attributes);\n              this.warnOnMissingAttributes_('#EXT-X-PART-INF', entry.attributes, ['PART-TARGET']);\n\n              if (this.manifest.partInf.partTarget) {\n                this.manifest.partTargetDuration = this.manifest.partInf.partTarget;\n              }\n\n              setHoldBack.call(this, this.manifest);\n            },\n\n            'daterange'() {\n              this.manifest.dateRanges.push(camelCaseKeys(entry.attributes));\n              const index = this.manifest.dateRanges.length - 1;\n              this.warnOnMissingAttributes_(`#EXT-X-DATERANGE #${index}`, entry.attributes, ['ID', 'START-DATE']);\n              const dateRange = this.manifest.dateRanges[index];\n\n              if (dateRange.endDate && dateRange.startDate && new Date(dateRange.endDate) < new Date(dateRange.startDate)) {\n                this.trigger('warn', {\n                  message: 'EXT-X-DATERANGE END-DATE must be equal to or later than the value of the START-DATE'\n                });\n              }\n\n              if (dateRange.duration && dateRange.duration < 0) {\n                this.trigger('warn', {\n                  message: 'EXT-X-DATERANGE DURATION must not be negative'\n                });\n              }\n\n              if (dateRange.plannedDuration && dateRange.plannedDuration < 0) {\n                this.trigger('warn', {\n                  message: 'EXT-X-DATERANGE PLANNED-DURATION must not be negative'\n                });\n              }\n\n              const endOnNextYes = !!dateRange.endOnNext;\n\n              if (endOnNextYes && !dateRange.class) {\n                this.trigger('warn', {\n                  message: 'EXT-X-DATERANGE with an END-ON-NEXT=YES attribute must have a CLASS attribute'\n                });\n              }\n\n              if (endOnNextYes && (dateRange.duration || dateRange.endDate)) {\n                this.trigger('warn', {\n                  message: 'EXT-X-DATERANGE with an END-ON-NEXT=YES attribute must not contain DURATION or END-DATE attributes'\n                });\n              }\n\n              if (dateRange.duration && dateRange.endDate) {\n                const startDate = dateRange.startDate;\n                const newDateInSeconds = startDate.getTime() + dateRange.duration * 1000;\n                this.manifest.dateRanges[index].endDate = new Date(newDateInSeconds);\n              }\n\n              if (!dateRangeTags[dateRange.id]) {\n                dateRangeTags[dateRange.id] = dateRange;\n              } else {\n                for (const attribute in dateRangeTags[dateRange.id]) {\n                  if (!!dateRange[attribute] && JSON.stringify(dateRangeTags[dateRange.id][attribute]) !== JSON.stringify(dateRange[attribute])) {\n                    this.trigger('warn', {\n                      message: 'EXT-X-DATERANGE tags with the same ID in a playlist must have the same attributes values'\n                    });\n                    break;\n                  }\n                } // if tags with the same ID do not have conflicting attributes, merge them\n\n\n                const dateRangeWithSameId = this.manifest.dateRanges.findIndex(dateRangeToFind => dateRangeToFind.id === dateRange.id);\n                this.manifest.dateRanges[dateRangeWithSameId] = _extends__default[\"default\"](this.manifest.dateRanges[dateRangeWithSameId], dateRange);\n                dateRangeTags[dateRange.id] = _extends__default[\"default\"](dateRangeTags[dateRange.id], dateRange); // after merging, delete the duplicate dateRange that was added last\n\n                this.manifest.dateRanges.pop();\n              }\n            },\n\n            'independent-segments'() {\n              this.manifest.independentSegments = true;\n            },\n\n            'i-frames-only'() {\n              this.manifest.iFramesOnly = true;\n              this.requiredCompatibilityversion(this.manifest.version, 4);\n            },\n\n            'content-steering'() {\n              this.manifest.contentSteering = camelCaseKeys(entry.attributes);\n              this.warnOnMissingAttributes_('#EXT-X-CONTENT-STEERING', entry.attributes, ['SERVER-URI']);\n            },\n\n            /** @this {Parser} */\n            define() {\n              this.manifest.definitions = this.manifest.definitions || {};\n\n              const addDef = (n, v) => {\n                if (n in this.manifest.definitions) {\n                  // An EXT-X-DEFINE tag MUST NOT specify the same Variable Name as any other\n                  // EXT-X-DEFINE tag in the same Playlist.  Parsers that encounter duplicate\n                  // Variable Name declarations MUST fail to parse the Playlist.\n                  this.trigger('error', {\n                    message: `EXT-X-DEFINE: Duplicate name ${n}`\n                  });\n                  return;\n                }\n\n                this.manifest.definitions[n] = v;\n              };\n\n              if ('QUERYPARAM' in entry.attributes) {\n                if ('NAME' in entry.attributes || 'IMPORT' in entry.attributes) {\n                  // An EXT-X-DEFINE tag MUST contain either a NAME, an IMPORT, or a\n                  // QUERYPARAM attribute, but only one of the three.  Otherwise, the\n                  // client MUST fail to parse the Playlist.\n                  this.trigger('error', {\n                    message: 'EXT-X-DEFINE: Invalid attributes'\n                  });\n                  return;\n                }\n\n                const val = this.params.get(entry.attributes.QUERYPARAM);\n\n                if (!val) {\n                  // If the QUERYPARAM attribute value does not match any query parameter in\n                  // the URI or the matching parameter has no associated value, the parser\n                  // MUST fail to parse the Playlist.  If more than one parameter matches,\n                  // any of the associated values MAY be used.\n                  this.trigger('error', {\n                    message: `EXT-X-DEFINE: No query param ${entry.attributes.QUERYPARAM}`\n                  });\n                  return;\n                }\n\n                addDef(entry.attributes.QUERYPARAM, decodeURIComponent(val));\n                return;\n              }\n\n              if ('NAME' in entry.attributes) {\n                if ('IMPORT' in entry.attributes) {\n                  // An EXT-X-DEFINE tag MUST contain either a NAME, an IMPORT, or a\n                  // QUERYPARAM attribute, but only one of the three.  Otherwise, the\n                  // client MUST fail to parse the Playlist.\n                  this.trigger('error', {\n                    message: 'EXT-X-DEFINE: Invalid attributes'\n                  });\n                  return;\n                }\n\n                if (!('VALUE' in entry.attributes) || typeof entry.attributes.VALUE !== 'string') {\n                  // This attribute is REQUIRED if the EXT-X-DEFINE tag has a NAME attribute.\n                  // The quoted-string MAY be empty.\n                  this.trigger('error', {\n                    message: `EXT-X-DEFINE: No value for ${entry.attributes.NAME}`\n                  });\n                  return;\n                }\n\n                addDef(entry.attributes.NAME, entry.attributes.VALUE);\n                return;\n              }\n\n              if ('IMPORT' in entry.attributes) {\n                if (!this.mainDefinitions[entry.attributes.IMPORT]) {\n                  // Covers two conditions, as mainDefinitions will always be empty on main\n                  //\n                  // EXT-X-DEFINE tags containing the IMPORT attribute MUST NOT occur in\n                  // Multivariant Playlists; they are only allowed in Media Playlists.\n                  //\n                  // If the IMPORT attribute value does not match any Variable Name in the\n                  // Multivariant Playlist, or if the Media Playlist loaded from a\n                  // Multivariant Playlist, the parser MUST fail the Playlist.\n                  this.trigger('error', {\n                    message: `EXT-X-DEFINE: No value ${entry.attributes.IMPORT} to import, or IMPORT used on main playlist`\n                  });\n                  return;\n                }\n\n                addDef(entry.attributes.IMPORT, this.mainDefinitions[entry.attributes.IMPORT]);\n                return;\n              } // An EXT-X-DEFINE tag MUST contain either a NAME, an IMPORT, or a QUERYPARAM\n              // attribute, but only one of the three.  Otherwise, the client MUST fail to\n              // parse the Playlist.\n\n\n              this.trigger('error', {\n                message: 'EXT-X-DEFINE: No attribute'\n              });\n            },\n\n            'i-frame-playlist'() {\n              this.manifest.iFramePlaylists.push({\n                attributes: entry.attributes,\n                uri: entry.uri,\n                timeline: currentTimeline\n              });\n              this.warnOnMissingAttributes_('#EXT-X-I-FRAME-STREAM-INF', entry.attributes, ['BANDWIDTH', 'URI']);\n            }\n\n          })[entry.tagType] || noop).call(self);\n        },\n\n        uri() {\n          currentUri.uri = entry.uri;\n          uris.push(currentUri); // if no explicit duration was declared, use the target duration\n\n          if (this.manifest.targetDuration && !('duration' in currentUri)) {\n            this.trigger('warn', {\n              message: 'defaulting segment duration to the target duration'\n            });\n            currentUri.duration = this.manifest.targetDuration;\n          } // annotate with encryption information, if necessary\n\n\n          if (key) {\n            currentUri.key = key;\n          }\n\n          currentUri.timeline = currentTimeline; // annotate with initialization segment information, if necessary\n\n          if (currentMap) {\n            currentUri.map = currentMap;\n          } // reset the last byterange end as it needs to be 0 between parts\n\n\n          lastPartByterangeEnd = 0; // Once we have at least one program date time we can always extrapolate it forward\n\n          if (this.lastProgramDateTime !== null) {\n            currentUri.programDateTime = this.lastProgramDateTime;\n            this.lastProgramDateTime += currentUri.duration * 1000;\n          } // prepare for the next URI\n\n\n          currentUri = {};\n        },\n\n        comment() {// comments are not important for playback\n        },\n\n        custom() {\n          // if this is segment-level data attach the output to the segment\n          if (entry.segment) {\n            currentUri.custom = currentUri.custom || {};\n            currentUri.custom[entry.customType] = entry.data; // if this is manifest-level data attach to the top level manifest object\n          } else {\n            this.manifest.custom = this.manifest.custom || {};\n            this.manifest.custom[entry.customType] = entry.data;\n          }\n        }\n\n      })[entry.type].call(self);\n    });\n  }\n\n  requiredCompatibilityversion(currentVersion, targetVersion) {\n    if (currentVersion < targetVersion || !currentVersion) {\n      this.trigger('warn', {\n        message: `manifest must be at least version ${targetVersion}`\n      });\n    }\n  }\n\n  warnOnMissingAttributes_(identifier, attributes, required) {\n    const missing = [];\n    required.forEach(function (key) {\n      if (!attributes.hasOwnProperty(key)) {\n        missing.push(key);\n      }\n    });\n\n    if (missing.length) {\n      this.trigger('warn', {\n        message: `${identifier} lacks required attribute(s): ${missing.join(', ')}`\n      });\n    }\n  }\n  /**\n   * Parse the input string and update the manifest object.\n   *\n   * @param {string} chunk a potentially incomplete portion of the manifest\n   */\n\n\n  push(chunk) {\n    this.lineStream.push(chunk);\n  }\n  /**\n   * Flush any remaining input. This can be handy if the last line of an M3U8\n   * manifest did not contain a trailing newline but the file has been\n   * completely received.\n   */\n\n\n  end() {\n    // flush any buffered input\n    this.lineStream.push('\\n');\n\n    if (this.manifest.dateRanges.length && this.lastProgramDateTime === null) {\n      this.trigger('warn', {\n        message: 'A playlist with EXT-X-DATERANGE tag must contain atleast one EXT-X-PROGRAM-DATE-TIME tag'\n      });\n    }\n\n    this.lastProgramDateTime = null;\n    this.trigger('end');\n  }\n  /**\n   * Add an additional parser for non-standard tags\n   *\n   * @param {Object}   options              a map of options for the added parser\n   * @param {RegExp}   options.expression   a regular expression to match the custom header\n   * @param {string}   options.customType   the custom type to register to the output\n   * @param {Function} [options.dataParser] function to parse the line into an object\n   * @param {boolean}  [options.segment]    should tag data be attached to the segment object\n   */\n\n\n  addParser(options) {\n    this.parseStream.addParser(options);\n  }\n  /**\n   * Add a custom header mapper\n   *\n   * @param {Object}   options\n   * @param {RegExp}   options.expression   a regular expression to match the custom header\n   * @param {Function} options.map          function to translate tag into a different tag\n   */\n\n\n  addTagMapper(options) {\n    this.parseStream.addTagMapper(options);\n  }\n\n}\n\nexports.LineStream = LineStream;\nexports.ParseStream = ParseStream;\nexports.Parser = Parser;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbTN1OC1wYXJzZXIvZGlzdC9tM3U4LXBhcnNlci5janMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDYTs7QUFFYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7O0FBRTdELGFBQWEsbUJBQU8sQ0FBQywrRkFBa0M7QUFDdkQsZUFBZSxtQkFBTyxDQUFDLDhGQUFnQztBQUN2RCw0QkFBNEIsbUJBQU8sQ0FBQyxxSUFBcUQ7O0FBRXpGLHFDQUFxQyw0REFBNEQ7O0FBRWpHO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxXQUFXLGtCQUFrQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07OztBQUdOLG1EQUFtRDs7QUFFbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjs7O0FBR0E7QUFDQTtBQUNBLGVBQWU7O0FBRWY7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxNQUFNOzs7QUFHTjtBQUNBLHVDQUF1Qzs7QUFFdkM7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esc0JBQXNCLCtCQUErQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQSxRQUFROzs7QUFHUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFFBQVE7QUFDUjs7O0FBR0EsMkNBQTJDOztBQUUzQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0RBQXdEOztBQUV4RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrREFBK0QsRUFBRTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFOztBQUV4RTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNkNBQTZDLEVBQUU7QUFDL0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7O0FBR1I7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsVUFBVTtBQUN2QixhQUFhLFVBQVU7QUFDdkIsYUFBYSxVQUFVO0FBQ3ZCLGFBQWEsVUFBVTtBQUN2QixhQUFhLFVBQVU7QUFDdkI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFVBQVU7QUFDdkIsYUFBYSxVQUFVO0FBQ3ZCLGFBQWEsVUFBVTtBQUN2Qjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FB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QUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsVUFBVTtBQUN2QixhQUFhLFVBQVU7QUFDdkIsYUFBYSxVQUFVO0FBQ3ZCLGFBQWEsVUFBVTtBQUN2QixhQUFhLFVBQVU7QUFDdkI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsVUFBVTtBQUN2QixhQUFhLFVBQVU7QUFDdkIsYUFBYSxVQUFVO0FBQ3ZCOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsa0JBQWtCO0FBQ2xCLG1CQUFtQjtBQUNuQixjQUFjIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktdjAtcHJvamVjdC8uL25vZGVfbW9kdWxlcy9tM3U4LXBhcnNlci9kaXN0L20zdTgtcGFyc2VyLmNqcy5qcz9kOTZiIl0sInNvdXJjZXNDb250ZW50IjpbIi8qISBAbmFtZSBtM3U4LXBhcnNlciBAdmVyc2lvbiA3LjIuMCBAbGljZW5zZSBBcGFjaGUtMi4wICovXG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBTdHJlYW0gPSByZXF1aXJlKCdAdmlkZW9qcy92aHMtdXRpbHMvY2pzL3N0cmVhbS5qcycpO1xudmFyIF9leHRlbmRzID0gcmVxdWlyZSgnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9leHRlbmRzJyk7XG52YXIgZGVjb2RlQjY0VG9VaW50OEFycmF5ID0gcmVxdWlyZSgnQHZpZGVvanMvdmhzLXV0aWxzL2Nqcy9kZWNvZGUtYjY0LXRvLXVpbnQ4LWFycmF5LmpzJyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wRGVmYXVsdExlZ2FjeSAoZSkgeyByZXR1cm4gZSAmJiB0eXBlb2YgZSA9PT0gJ29iamVjdCcgJiYgJ2RlZmF1bHQnIGluIGUgPyBlIDogeyAnZGVmYXVsdCc6IGUgfTsgfVxuXG52YXIgU3RyZWFtX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19pbnRlcm9wRGVmYXVsdExlZ2FjeShTdHJlYW0pO1xudmFyIF9leHRlbmRzX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19pbnRlcm9wRGVmYXVsdExlZ2FjeShfZXh0ZW5kcyk7XG52YXIgZGVjb2RlQjY0VG9VaW50OEFycmF5X19kZWZhdWx0ID0gLyojX19QVVJFX18qL19pbnRlcm9wRGVmYXVsdExlZ2FjeShkZWNvZGVCNjRUb1VpbnQ4QXJyYXkpO1xuXG4vKipcbiAqIEBmaWxlIG0zdTgvbGluZS1zdHJlYW0uanNcbiAqL1xuLyoqXG4gKiBBIHN0cmVhbSB0aGF0IGJ1ZmZlcnMgc3RyaW5nIGlucHV0IGFuZCBnZW5lcmF0ZXMgYSBgZGF0YWAgZXZlbnQgZm9yIGVhY2hcbiAqIGxpbmUuXG4gKlxuICogQGNsYXNzIExpbmVTdHJlYW1cbiAqIEBleHRlbmRzIFN0cmVhbVxuICovXG5cbmNsYXNzIExpbmVTdHJlYW0gZXh0ZW5kcyBTdHJlYW1fX2RlZmF1bHRbXCJkZWZhdWx0XCJdIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmJ1ZmZlciA9ICcnO1xuICB9XG4gIC8qKlxuICAgKiBBZGQgbmV3IGRhdGEgdG8gYmUgcGFyc2VkLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZGF0YSB0aGUgdGV4dCB0byBwcm9jZXNzXG4gICAqL1xuXG5cbiAgcHVzaChkYXRhKSB7XG4gICAgbGV0IG5leHROZXdsaW5lO1xuICAgIHRoaXMuYnVmZmVyICs9IGRhdGE7XG4gICAgbmV4dE5ld2xpbmUgPSB0aGlzLmJ1ZmZlci5pbmRleE9mKCdcXG4nKTtcblxuICAgIGZvciAoOyBuZXh0TmV3bGluZSA+IC0xOyBuZXh0TmV3bGluZSA9IHRoaXMuYnVmZmVyLmluZGV4T2YoJ1xcbicpKSB7XG4gICAgICB0aGlzLnRyaWdnZXIoJ2RhdGEnLCB0aGlzLmJ1ZmZlci5zdWJzdHJpbmcoMCwgbmV4dE5ld2xpbmUpKTtcbiAgICAgIHRoaXMuYnVmZmVyID0gdGhpcy5idWZmZXIuc3Vic3RyaW5nKG5leHROZXdsaW5lICsgMSk7XG4gICAgfVxuICB9XG5cbn1cblxuY29uc3QgVEFCID0gU3RyaW5nLmZyb21DaGFyQ29kZSgweDA5KTtcblxuY29uc3QgcGFyc2VCeXRlcmFuZ2UgPSBmdW5jdGlvbiAoYnl0ZXJhbmdlU3RyaW5nKSB7XG4gIC8vIG9wdGlvbmFsbHkgbWF0Y2ggYW5kIGNhcHR1cmUgMCsgZGlnaXRzIGJlZm9yZSBgQGBcbiAgLy8gb3B0aW9uYWxseSBtYXRjaCBhbmQgY2FwdHVyZSAwKyBkaWdpdHMgYWZ0ZXIgYEBgXG4gIGNvbnN0IG1hdGNoID0gLyhbMC05Ll0qKT9APyhbMC05Ll0qKT8vLmV4ZWMoYnl0ZXJhbmdlU3RyaW5nIHx8ICcnKTtcbiAgY29uc3QgcmVzdWx0ID0ge307XG5cbiAgaWYgKG1hdGNoWzFdKSB7XG4gICAgcmVzdWx0Lmxlbmd0aCA9IHBhcnNlSW50KG1hdGNoWzFdLCAxMCk7XG4gIH1cblxuICBpZiAobWF0Y2hbMl0pIHtcbiAgICByZXN1bHQub2Zmc2V0ID0gcGFyc2VJbnQobWF0Y2hbMl0sIDEwKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuLyoqXG4gKiBcImZvcmdpdmluZ1wiIGF0dHJpYnV0ZSBsaXN0IHBzdWVkby1ncmFtbWFyOlxuICogYXR0cmlidXRlcyAtPiBrZXl2YWx1ZSAoJywnIGtleXZhbHVlKSpcbiAqIGtleXZhbHVlICAgLT4ga2V5ICc9JyB2YWx1ZVxuICoga2V5ICAgICAgICAtPiBbXj1dKlxuICogdmFsdWUgICAgICAtPiAnXCInIFteXCJdKiAnXCInIHwgW14sXSpcbiAqL1xuXG5cbmNvbnN0IGF0dHJpYnV0ZVNlcGFyYXRvciA9IGZ1bmN0aW9uICgpIHtcbiAgY29uc3Qga2V5ID0gJ1tePV0qJztcbiAgY29uc3QgdmFsdWUgPSAnXCJbXlwiXSpcInxbXixdKic7XG4gIGNvbnN0IGtleXZhbHVlID0gJyg/OicgKyBrZXkgKyAnKT0oPzonICsgdmFsdWUgKyAnKSc7XG4gIHJldHVybiBuZXcgUmVnRXhwKCcoPzpefCwpKCcgKyBrZXl2YWx1ZSArICcpJyk7XG59O1xuLyoqXG4gKiBQYXJzZSBhdHRyaWJ1dGVzIGZyb20gYSBsaW5lIGdpdmVuIHRoZSBzZXBhcmF0b3JcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYXR0cmlidXRlcyB0aGUgYXR0cmlidXRlIGxpbmUgdG8gcGFyc2VcbiAqL1xuXG5cbmNvbnN0IHBhcnNlQXR0cmlidXRlcyA9IGZ1bmN0aW9uIChhdHRyaWJ1dGVzKSB7XG4gIGNvbnN0IHJlc3VsdCA9IHt9O1xuXG4gIGlmICghYXR0cmlidXRlcykge1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH0gLy8gc3BsaXQgdGhlIHN0cmluZyB1c2luZyBhdHRyaWJ1dGVzIGFzIHRoZSBzZXBhcmF0b3JcblxuXG4gIGNvbnN0IGF0dHJzID0gYXR0cmlidXRlcy5zcGxpdChhdHRyaWJ1dGVTZXBhcmF0b3IoKSk7XG4gIGxldCBpID0gYXR0cnMubGVuZ3RoO1xuICBsZXQgYXR0cjtcblxuICB3aGlsZSAoaS0tKSB7XG4gICAgLy8gZmlsdGVyIG91dCB1bm1hdGNoZWQgcG9ydGlvbnMgb2YgdGhlIHN0cmluZ1xuICAgIGlmIChhdHRyc1tpXSA9PT0gJycpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH0gLy8gc3BsaXQgdGhlIGtleSBhbmQgdmFsdWVcblxuXG4gICAgYXR0ciA9IC8oW149XSopPSguKikvLmV4ZWMoYXR0cnNbaV0pLnNsaWNlKDEpOyAvLyB0cmltIHdoaXRlc3BhY2UgYW5kIHJlbW92ZSBvcHRpb25hbCBxdW90ZXMgYXJvdW5kIHRoZSB2YWx1ZVxuXG4gICAgYXR0clswXSA9IGF0dHJbMF0ucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpO1xuICAgIGF0dHJbMV0gPSBhdHRyWzFdLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKTtcbiAgICBhdHRyWzFdID0gYXR0clsxXS5yZXBsYWNlKC9eWydcIl0oLiopWydcIl0kL2csICckMScpO1xuICAgIHJlc3VsdFthdHRyWzBdXSA9IGF0dHJbMV07XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufTtcbi8qKlxuICogQ29udmVydHMgYSBzdHJpbmcgaW50byBhIHJlc29sdXRpb24gb2JqZWN0XG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHJlc29sdXRpb24gYSBzdHJpbmcgc3VjaCBhcyAzODQweDIxNjBcbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9IEFuIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIHJlc29sdXRpb25cbiAqXG4gKi9cblxuXG5jb25zdCBwYXJzZVJlc29sdXRpb24gPSByZXNvbHV0aW9uID0+IHtcbiAgY29uc3Qgc3BsaXQgPSByZXNvbHV0aW9uLnNwbGl0KCd4Jyk7XG4gIGNvbnN0IHJlc3VsdCA9IHt9O1xuXG4gIGlmIChzcGxpdFswXSkge1xuICAgIHJlc3VsdC53aWR0aCA9IHBhcnNlSW50KHNwbGl0WzBdLCAxMCk7XG4gIH1cblxuICBpZiAoc3BsaXRbMV0pIHtcbiAgICByZXN1bHQuaGVpZ2h0ID0gcGFyc2VJbnQoc3BsaXRbMV0sIDEwKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuLyoqXG4gKiBBIGxpbmUtbGV2ZWwgTTNVOCBwYXJzZXIgZXZlbnQgc3RyZWFtLiBJdCBleHBlY3RzIHRvIHJlY2VpdmUgaW5wdXQgb25lXG4gKiBsaW5lIGF0IGEgdGltZSBhbmQgcGVyZm9ybXMgYSBjb250ZXh0LWZyZWUgcGFyc2Ugb2YgaXRzIGNvbnRlbnRzLiBBIHN0cmVhbVxuICogaW50ZXJwcmV0YXRpb24gb2YgYSBtYW5pZmVzdCBjYW4gYmUgdXNlZnVsIGlmIHRoZSBtYW5pZmVzdCBpcyBleHBlY3RlZCB0b1xuICogYmUgdG9vIGxhcmdlIHRvIGZpdCBjb21mb3J0YWJseSBpbnRvIG1lbW9yeSBvciB0aGUgZW50aXJldHkgb2YgdGhlIGlucHV0XG4gKiBpcyBub3QgaW1tZWRpYXRlbHkgYXZhaWxhYmxlLiBPdGhlcndpc2UsIGl0J3MgcHJvYmFibHkgbXVjaCBlYXNpZXIgdG8gd29ya1xuICogd2l0aCBhIHJlZ3VsYXIgYFBhcnNlcmAgb2JqZWN0LlxuICpcbiAqIFByb2R1Y2VzIGBkYXRhYCBldmVudHMgd2l0aCBhbiBvYmplY3QgdGhhdCBjYXB0dXJlcyB0aGUgcGFyc2VyJ3NcbiAqIGludGVycHJldGF0aW9uIG9mIHRoZSBpbnB1dC4gVGhhdCBvYmplY3QgaGFzIGEgcHJvcGVydHkgYHRhZ2AgdGhhdCBpcyBvbmVcbiAqIG9mIGB1cmlgLCBgY29tbWVudGAsIG9yIGB0YWdgLiBVUklzIG9ubHkgaGF2ZSBhIHNpbmdsZSBhZGRpdGlvbmFsXG4gKiBwcm9wZXJ0eSwgYGxpbmVgLCB3aGljaCBjYXB0dXJlcyB0aGUgZW50aXJldHkgb2YgdGhlIGlucHV0IHdpdGhvdXRcbiAqIGludGVycHJldGF0aW9uLiBDb21tZW50cyBzaW1pbGFybHkgaGF2ZSBhIHNpbmdsZSBhZGRpdGlvbmFsIHByb3BlcnR5XG4gKiBgdGV4dGAgd2hpY2ggaXMgdGhlIGlucHV0IHdpdGhvdXQgdGhlIGxlYWRpbmcgYCNgLlxuICpcbiAqIFRhZ3MgYWx3YXlzIGhhdmUgYSBwcm9wZXJ0eSBgdGFnVHlwZWAgd2hpY2ggaXMgdGhlIGxvd2VyLWNhc2VkIHZlcnNpb24gb2ZcbiAqIHRoZSBNM1U4IGRpcmVjdGl2ZSB3aXRob3V0IHRoZSBgI0VYVGAgb3IgYCNFWFQtWC1gIHByZWZpeC4gRm9yIGluc3RhbmNlLFxuICogYCNFWFQtWC1NRURJQS1TRVFVRU5DRWAgYmVjb21lcyBgbWVkaWEtc2VxdWVuY2VgIHdoZW4gcGFyc2VkLiBVbnJlY29nbml6ZWRcbiAqIHRhZ3MgYXJlIGdpdmVuIHRoZSB0YWcgdHlwZSBgdW5rbm93bmAgYW5kIGEgc2luZ2xlIGFkZGl0aW9uYWwgcHJvcGVydHlcbiAqIGBkYXRhYCB3aXRoIHRoZSByZW1haW5kZXIgb2YgdGhlIGlucHV0LlxuICpcbiAqIEBjbGFzcyBQYXJzZVN0cmVhbVxuICogQGV4dGVuZHMgU3RyZWFtXG4gKi9cblxuXG5jbGFzcyBQYXJzZVN0cmVhbSBleHRlbmRzIFN0cmVhbV9fZGVmYXVsdFtcImRlZmF1bHRcIl0ge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuY3VzdG9tUGFyc2VycyA9IFtdO1xuICAgIHRoaXMudGFnTWFwcGVycyA9IFtdO1xuICB9XG4gIC8qKlxuICAgKiBQYXJzZXMgYW4gYWRkaXRpb25hbCBsaW5lIG9mIGlucHV0LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbGluZSBhIHNpbmdsZSBsaW5lIG9mIGFuIE0zVTggZmlsZSB0byBwYXJzZVxuICAgKi9cblxuXG4gIHB1c2gobGluZSkge1xuICAgIGxldCBtYXRjaDtcbiAgICBsZXQgZXZlbnQ7IC8vIHN0cmlwIHdoaXRlc3BhY2VcblxuICAgIGxpbmUgPSBsaW5lLnRyaW0oKTtcblxuICAgIGlmIChsaW5lLmxlbmd0aCA9PT0gMCkge1xuICAgICAgLy8gaWdub3JlIGVtcHR5IGxpbmVzXG4gICAgICByZXR1cm47XG4gICAgfSAvLyBVUklzXG5cblxuICAgIGlmIChsaW5lWzBdICE9PSAnIycpIHtcbiAgICAgIHRoaXMudHJpZ2dlcignZGF0YScsIHtcbiAgICAgICAgdHlwZTogJ3VyaScsXG4gICAgICAgIHVyaTogbGluZVxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBtYXAgdGFnc1xuXG5cbiAgICBjb25zdCBuZXdMaW5lcyA9IHRoaXMudGFnTWFwcGVycy5yZWR1Y2UoKGFjYywgbWFwcGVyKSA9PiB7XG4gICAgICBjb25zdCBtYXBwZWRMaW5lID0gbWFwcGVyKGxpbmUpOyAvLyBza2lwIGlmIHVuY2hhbmdlZFxuXG4gICAgICBpZiAobWFwcGVkTGluZSA9PT0gbGluZSkge1xuICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYWNjLmNvbmNhdChbbWFwcGVkTGluZV0pO1xuICAgIH0sIFtsaW5lXSk7XG4gICAgbmV3TGluZXMuZm9yRWFjaChuZXdMaW5lID0+IHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jdXN0b21QYXJzZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICh0aGlzLmN1c3RvbVBhcnNlcnNbaV0uY2FsbCh0aGlzLCBuZXdMaW5lKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfSAvLyBDb21tZW50c1xuXG5cbiAgICAgIGlmIChuZXdMaW5lLmluZGV4T2YoJyNFWFQnKSAhPT0gMCkge1xuICAgICAgICB0aGlzLnRyaWdnZXIoJ2RhdGEnLCB7XG4gICAgICAgICAgdHlwZTogJ2NvbW1lbnQnLFxuICAgICAgICAgIHRleHQ6IG5ld0xpbmUuc2xpY2UoMSlcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gc3RyaXAgb2ZmIGFueSBjYXJyaWFnZSByZXR1cm5zIGhlcmUgc28gdGhlIHJlZ2V4IG1hdGNoaW5nXG4gICAgICAvLyBkb2Vzbid0IGhhdmUgdG8gYWNjb3VudCBmb3IgdGhlbS5cblxuXG4gICAgICBuZXdMaW5lID0gbmV3TGluZS5yZXBsYWNlKCdcXHInLCAnJyk7IC8vIFRhZ3NcblxuICAgICAgbWF0Y2ggPSAvXiNFWFRNM1UvLmV4ZWMobmV3TGluZSk7XG5cbiAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICB0aGlzLnRyaWdnZXIoJ2RhdGEnLCB7XG4gICAgICAgICAgdHlwZTogJ3RhZycsXG4gICAgICAgICAgdGFnVHlwZTogJ20zdSdcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgbWF0Y2ggPSAvXiNFWFRJTkY6KFswLTlcXC5dKik/LD8oLiopPyQvLmV4ZWMobmV3TGluZSk7XG5cbiAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICBldmVudCA9IHtcbiAgICAgICAgICB0eXBlOiAndGFnJyxcbiAgICAgICAgICB0YWdUeXBlOiAnaW5mJ1xuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChtYXRjaFsxXSkge1xuICAgICAgICAgIGV2ZW50LmR1cmF0aW9uID0gcGFyc2VGbG9hdChtYXRjaFsxXSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWF0Y2hbMl0pIHtcbiAgICAgICAgICBldmVudC50aXRsZSA9IG1hdGNoWzJdO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy50cmlnZ2VyKCdkYXRhJywgZXZlbnQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIG1hdGNoID0gL14jRVhULVgtVEFSR0VURFVSQVRJT046KFswLTkuXSopPy8uZXhlYyhuZXdMaW5lKTtcblxuICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgIGV2ZW50ID0ge1xuICAgICAgICAgIHR5cGU6ICd0YWcnLFxuICAgICAgICAgIHRhZ1R5cGU6ICd0YXJnZXRkdXJhdGlvbidcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAobWF0Y2hbMV0pIHtcbiAgICAgICAgICBldmVudC5kdXJhdGlvbiA9IHBhcnNlSW50KG1hdGNoWzFdLCAxMCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnRyaWdnZXIoJ2RhdGEnLCBldmVudCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgbWF0Y2ggPSAvXiNFWFQtWC1WRVJTSU9OOihbMC05Ll0qKT8vLmV4ZWMobmV3TGluZSk7XG5cbiAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICBldmVudCA9IHtcbiAgICAgICAgICB0eXBlOiAndGFnJyxcbiAgICAgICAgICB0YWdUeXBlOiAndmVyc2lvbidcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAobWF0Y2hbMV0pIHtcbiAgICAgICAgICBldmVudC52ZXJzaW9uID0gcGFyc2VJbnQobWF0Y2hbMV0sIDEwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudHJpZ2dlcignZGF0YScsIGV2ZW50KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBtYXRjaCA9IC9eI0VYVC1YLU1FRElBLVNFUVVFTkNFOihcXC0/WzAtOS5dKik/Ly5leGVjKG5ld0xpbmUpO1xuXG4gICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgZXZlbnQgPSB7XG4gICAgICAgICAgdHlwZTogJ3RhZycsXG4gICAgICAgICAgdGFnVHlwZTogJ21lZGlhLXNlcXVlbmNlJ1xuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChtYXRjaFsxXSkge1xuICAgICAgICAgIGV2ZW50Lm51bWJlciA9IHBhcnNlSW50KG1hdGNoWzFdLCAxMCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnRyaWdnZXIoJ2RhdGEnLCBldmVudCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgbWF0Y2ggPSAvXiNFWFQtWC1ESVNDT05USU5VSVRZLVNFUVVFTkNFOihcXC0/WzAtOS5dKik/Ly5leGVjKG5ld0xpbmUpO1xuXG4gICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgZXZlbnQgPSB7XG4gICAgICAgICAgdHlwZTogJ3RhZycsXG4gICAgICAgICAgdGFnVHlwZTogJ2Rpc2NvbnRpbnVpdHktc2VxdWVuY2UnXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKG1hdGNoWzFdKSB7XG4gICAgICAgICAgZXZlbnQubnVtYmVyID0gcGFyc2VJbnQobWF0Y2hbMV0sIDEwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudHJpZ2dlcignZGF0YScsIGV2ZW50KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBtYXRjaCA9IC9eI0VYVC1YLVBMQVlMSVNULVRZUEU6KC4qKT8kLy5leGVjKG5ld0xpbmUpO1xuXG4gICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgZXZlbnQgPSB7XG4gICAgICAgICAgdHlwZTogJ3RhZycsXG4gICAgICAgICAgdGFnVHlwZTogJ3BsYXlsaXN0LXR5cGUnXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKG1hdGNoWzFdKSB7XG4gICAgICAgICAgZXZlbnQucGxheWxpc3RUeXBlID0gbWF0Y2hbMV07XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnRyaWdnZXIoJ2RhdGEnLCBldmVudCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgbWF0Y2ggPSAvXiNFWFQtWC1CWVRFUkFOR0U6KC4qKT8kLy5leGVjKG5ld0xpbmUpO1xuXG4gICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgZXZlbnQgPSBfZXh0ZW5kc19fZGVmYXVsdFtcImRlZmF1bHRcIl0ocGFyc2VCeXRlcmFuZ2UobWF0Y2hbMV0pLCB7XG4gICAgICAgICAgdHlwZTogJ3RhZycsXG4gICAgICAgICAgdGFnVHlwZTogJ2J5dGVyYW5nZSdcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudHJpZ2dlcignZGF0YScsIGV2ZW50KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBtYXRjaCA9IC9eI0VYVC1YLUFMTE9XLUNBQ0hFOihZRVN8Tk8pPy8uZXhlYyhuZXdMaW5lKTtcblxuICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgIGV2ZW50ID0ge1xuICAgICAgICAgIHR5cGU6ICd0YWcnLFxuICAgICAgICAgIHRhZ1R5cGU6ICdhbGxvdy1jYWNoZSdcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAobWF0Y2hbMV0pIHtcbiAgICAgICAgICBldmVudC5hbGxvd2VkID0gIS9OTy8udGVzdChtYXRjaFsxXSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnRyaWdnZXIoJ2RhdGEnLCBldmVudCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgbWF0Y2ggPSAvXiNFWFQtWC1NQVA6KC4qKSQvLmV4ZWMobmV3TGluZSk7XG5cbiAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICBldmVudCA9IHtcbiAgICAgICAgICB0eXBlOiAndGFnJyxcbiAgICAgICAgICB0YWdUeXBlOiAnbWFwJ1xuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChtYXRjaFsxXSkge1xuICAgICAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBwYXJzZUF0dHJpYnV0ZXMobWF0Y2hbMV0pO1xuXG4gICAgICAgICAgaWYgKGF0dHJpYnV0ZXMuVVJJKSB7XG4gICAgICAgICAgICBldmVudC51cmkgPSBhdHRyaWJ1dGVzLlVSSTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoYXR0cmlidXRlcy5CWVRFUkFOR0UpIHtcbiAgICAgICAgICAgIGV2ZW50LmJ5dGVyYW5nZSA9IHBhcnNlQnl0ZXJhbmdlKGF0dHJpYnV0ZXMuQllURVJBTkdFKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnRyaWdnZXIoJ2RhdGEnLCBldmVudCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgbWF0Y2ggPSAvXiNFWFQtWC1TVFJFQU0tSU5GOiguKikkLy5leGVjKG5ld0xpbmUpO1xuXG4gICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgZXZlbnQgPSB7XG4gICAgICAgICAgdHlwZTogJ3RhZycsXG4gICAgICAgICAgdGFnVHlwZTogJ3N0cmVhbS1pbmYnXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKG1hdGNoWzFdKSB7XG4gICAgICAgICAgZXZlbnQuYXR0cmlidXRlcyA9IHBhcnNlQXR0cmlidXRlcyhtYXRjaFsxXSk7XG5cbiAgICAgICAgICBpZiAoZXZlbnQuYXR0cmlidXRlcy5SRVNPTFVUSU9OKSB7XG4gICAgICAgICAgICBldmVudC5hdHRyaWJ1dGVzLlJFU09MVVRJT04gPSBwYXJzZVJlc29sdXRpb24oZXZlbnQuYXR0cmlidXRlcy5SRVNPTFVUSU9OKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoZXZlbnQuYXR0cmlidXRlcy5CQU5EV0lEVEgpIHtcbiAgICAgICAgICAgIGV2ZW50LmF0dHJpYnV0ZXMuQkFORFdJRFRIID0gcGFyc2VJbnQoZXZlbnQuYXR0cmlidXRlcy5CQU5EV0lEVEgsIDEwKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoZXZlbnQuYXR0cmlidXRlc1snRlJBTUUtUkFURSddKSB7XG4gICAgICAgICAgICBldmVudC5hdHRyaWJ1dGVzWydGUkFNRS1SQVRFJ10gPSBwYXJzZUZsb2F0KGV2ZW50LmF0dHJpYnV0ZXNbJ0ZSQU1FLVJBVEUnXSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGV2ZW50LmF0dHJpYnV0ZXNbJ1BST0dSQU0tSUQnXSkge1xuICAgICAgICAgICAgZXZlbnQuYXR0cmlidXRlc1snUFJPR1JBTS1JRCddID0gcGFyc2VJbnQoZXZlbnQuYXR0cmlidXRlc1snUFJPR1JBTS1JRCddLCAxMCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy50cmlnZ2VyKCdkYXRhJywgZXZlbnQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIG1hdGNoID0gL14jRVhULVgtTUVESUE6KC4qKSQvLmV4ZWMobmV3TGluZSk7XG5cbiAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICBldmVudCA9IHtcbiAgICAgICAgICB0eXBlOiAndGFnJyxcbiAgICAgICAgICB0YWdUeXBlOiAnbWVkaWEnXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKG1hdGNoWzFdKSB7XG4gICAgICAgICAgZXZlbnQuYXR0cmlidXRlcyA9IHBhcnNlQXR0cmlidXRlcyhtYXRjaFsxXSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnRyaWdnZXIoJ2RhdGEnLCBldmVudCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgbWF0Y2ggPSAvXiNFWFQtWC1FTkRMSVNULy5leGVjKG5ld0xpbmUpO1xuXG4gICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgdGhpcy50cmlnZ2VyKCdkYXRhJywge1xuICAgICAgICAgIHR5cGU6ICd0YWcnLFxuICAgICAgICAgIHRhZ1R5cGU6ICdlbmRsaXN0J1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBtYXRjaCA9IC9eI0VYVC1YLURJU0NPTlRJTlVJVFkvLmV4ZWMobmV3TGluZSk7XG5cbiAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICB0aGlzLnRyaWdnZXIoJ2RhdGEnLCB7XG4gICAgICAgICAgdHlwZTogJ3RhZycsXG4gICAgICAgICAgdGFnVHlwZTogJ2Rpc2NvbnRpbnVpdHknXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIG1hdGNoID0gL14jRVhULVgtUFJPR1JBTS1EQVRFLVRJTUU6KC4qKSQvLmV4ZWMobmV3TGluZSk7XG5cbiAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICBldmVudCA9IHtcbiAgICAgICAgICB0eXBlOiAndGFnJyxcbiAgICAgICAgICB0YWdUeXBlOiAncHJvZ3JhbS1kYXRlLXRpbWUnXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKG1hdGNoWzFdKSB7XG4gICAgICAgICAgZXZlbnQuZGF0ZVRpbWVTdHJpbmcgPSBtYXRjaFsxXTtcbiAgICAgICAgICBldmVudC5kYXRlVGltZU9iamVjdCA9IG5ldyBEYXRlKG1hdGNoWzFdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudHJpZ2dlcignZGF0YScsIGV2ZW50KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBtYXRjaCA9IC9eI0VYVC1YLUtFWTooLiopJC8uZXhlYyhuZXdMaW5lKTtcblxuICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgIGV2ZW50ID0ge1xuICAgICAgICAgIHR5cGU6ICd0YWcnLFxuICAgICAgICAgIHRhZ1R5cGU6ICdrZXknXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKG1hdGNoWzFdKSB7XG4gICAgICAgICAgZXZlbnQuYXR0cmlidXRlcyA9IHBhcnNlQXR0cmlidXRlcyhtYXRjaFsxXSk7IC8vIHBhcnNlIHRoZSBJViBzdHJpbmcgaW50byBhIFVpbnQzMkFycmF5XG5cbiAgICAgICAgICBpZiAoZXZlbnQuYXR0cmlidXRlcy5JVikge1xuICAgICAgICAgICAgaWYgKGV2ZW50LmF0dHJpYnV0ZXMuSVYuc3Vic3RyaW5nKDAsIDIpLnRvTG93ZXJDYXNlKCkgPT09ICcweCcpIHtcbiAgICAgICAgICAgICAgZXZlbnQuYXR0cmlidXRlcy5JViA9IGV2ZW50LmF0dHJpYnV0ZXMuSVYuc3Vic3RyaW5nKDIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBldmVudC5hdHRyaWJ1dGVzLklWID0gZXZlbnQuYXR0cmlidXRlcy5JVi5tYXRjaCgvLns4fS9nKTtcbiAgICAgICAgICAgIGV2ZW50LmF0dHJpYnV0ZXMuSVZbMF0gPSBwYXJzZUludChldmVudC5hdHRyaWJ1dGVzLklWWzBdLCAxNik7XG4gICAgICAgICAgICBldmVudC5hdHRyaWJ1dGVzLklWWzFdID0gcGFyc2VJbnQoZXZlbnQuYXR0cmlidXRlcy5JVlsxXSwgMTYpO1xuICAgICAgICAgICAgZXZlbnQuYXR0cmlidXRlcy5JVlsyXSA9IHBhcnNlSW50KGV2ZW50LmF0dHJpYnV0ZXMuSVZbMl0sIDE2KTtcbiAgICAgICAgICAgIGV2ZW50LmF0dHJpYnV0ZXMuSVZbM10gPSBwYXJzZUludChldmVudC5hdHRyaWJ1dGVzLklWWzNdLCAxNik7XG4gICAgICAgICAgICBldmVudC5hdHRyaWJ1dGVzLklWID0gbmV3IFVpbnQzMkFycmF5KGV2ZW50LmF0dHJpYnV0ZXMuSVYpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudHJpZ2dlcignZGF0YScsIGV2ZW50KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBtYXRjaCA9IC9eI0VYVC1YLVNUQVJUOiguKikkLy5leGVjKG5ld0xpbmUpO1xuXG4gICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgZXZlbnQgPSB7XG4gICAgICAgICAgdHlwZTogJ3RhZycsXG4gICAgICAgICAgdGFnVHlwZTogJ3N0YXJ0J1xuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChtYXRjaFsxXSkge1xuICAgICAgICAgIGV2ZW50LmF0dHJpYnV0ZXMgPSBwYXJzZUF0dHJpYnV0ZXMobWF0Y2hbMV0pO1xuICAgICAgICAgIGV2ZW50LmF0dHJpYnV0ZXNbJ1RJTUUtT0ZGU0VUJ10gPSBwYXJzZUZsb2F0KGV2ZW50LmF0dHJpYnV0ZXNbJ1RJTUUtT0ZGU0VUJ10pO1xuICAgICAgICAgIGV2ZW50LmF0dHJpYnV0ZXMuUFJFQ0lTRSA9IC9ZRVMvLnRlc3QoZXZlbnQuYXR0cmlidXRlcy5QUkVDSVNFKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudHJpZ2dlcignZGF0YScsIGV2ZW50KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBtYXRjaCA9IC9eI0VYVC1YLUNVRS1PVVQtQ09OVDooLiopPyQvLmV4ZWMobmV3TGluZSk7XG5cbiAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICBldmVudCA9IHtcbiAgICAgICAgICB0eXBlOiAndGFnJyxcbiAgICAgICAgICB0YWdUeXBlOiAnY3VlLW91dC1jb250J1xuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChtYXRjaFsxXSkge1xuICAgICAgICAgIGV2ZW50LmRhdGEgPSBtYXRjaFsxXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBldmVudC5kYXRhID0gJyc7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnRyaWdnZXIoJ2RhdGEnLCBldmVudCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgbWF0Y2ggPSAvXiNFWFQtWC1DVUUtT1VUOiguKik/JC8uZXhlYyhuZXdMaW5lKTtcblxuICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgIGV2ZW50ID0ge1xuICAgICAgICAgIHR5cGU6ICd0YWcnLFxuICAgICAgICAgIHRhZ1R5cGU6ICdjdWUtb3V0J1xuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChtYXRjaFsxXSkge1xuICAgICAgICAgIGV2ZW50LmRhdGEgPSBtYXRjaFsxXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBldmVudC5kYXRhID0gJyc7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnRyaWdnZXIoJ2RhdGEnLCBldmVudCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgbWF0Y2ggPSAvXiNFWFQtWC1DVUUtSU46PyguKik/JC8uZXhlYyhuZXdMaW5lKTtcblxuICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgIGV2ZW50ID0ge1xuICAgICAgICAgIHR5cGU6ICd0YWcnLFxuICAgICAgICAgIHRhZ1R5cGU6ICdjdWUtaW4nXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKG1hdGNoWzFdKSB7XG4gICAgICAgICAgZXZlbnQuZGF0YSA9IG1hdGNoWzFdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGV2ZW50LmRhdGEgPSAnJztcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudHJpZ2dlcignZGF0YScsIGV2ZW50KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBtYXRjaCA9IC9eI0VYVC1YLVNLSVA6KC4qKSQvLmV4ZWMobmV3TGluZSk7XG5cbiAgICAgIGlmIChtYXRjaCAmJiBtYXRjaFsxXSkge1xuICAgICAgICBldmVudCA9IHtcbiAgICAgICAgICB0eXBlOiAndGFnJyxcbiAgICAgICAgICB0YWdUeXBlOiAnc2tpcCdcbiAgICAgICAgfTtcbiAgICAgICAgZXZlbnQuYXR0cmlidXRlcyA9IHBhcnNlQXR0cmlidXRlcyhtYXRjaFsxXSk7XG5cbiAgICAgICAgaWYgKGV2ZW50LmF0dHJpYnV0ZXMuaGFzT3duUHJvcGVydHkoJ1NLSVBQRUQtU0VHTUVOVFMnKSkge1xuICAgICAgICAgIGV2ZW50LmF0dHJpYnV0ZXNbJ1NLSVBQRUQtU0VHTUVOVFMnXSA9IHBhcnNlSW50KGV2ZW50LmF0dHJpYnV0ZXNbJ1NLSVBQRUQtU0VHTUVOVFMnXSwgMTApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGV2ZW50LmF0dHJpYnV0ZXMuaGFzT3duUHJvcGVydHkoJ1JFQ0VOVExZLVJFTU9WRUQtREFURVJBTkdFUycpKSB7XG4gICAgICAgICAgZXZlbnQuYXR0cmlidXRlc1snUkVDRU5UTFktUkVNT1ZFRC1EQVRFUkFOR0VTJ10gPSBldmVudC5hdHRyaWJ1dGVzWydSRUNFTlRMWS1SRU1PVkVELURBVEVSQU5HRVMnXS5zcGxpdChUQUIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy50cmlnZ2VyKCdkYXRhJywgZXZlbnQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIG1hdGNoID0gL14jRVhULVgtUEFSVDooLiopJC8uZXhlYyhuZXdMaW5lKTtcblxuICAgICAgaWYgKG1hdGNoICYmIG1hdGNoWzFdKSB7XG4gICAgICAgIGV2ZW50ID0ge1xuICAgICAgICAgIHR5cGU6ICd0YWcnLFxuICAgICAgICAgIHRhZ1R5cGU6ICdwYXJ0J1xuICAgICAgICB9O1xuICAgICAgICBldmVudC5hdHRyaWJ1dGVzID0gcGFyc2VBdHRyaWJ1dGVzKG1hdGNoWzFdKTtcbiAgICAgICAgWydEVVJBVElPTiddLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgIGlmIChldmVudC5hdHRyaWJ1dGVzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgIGV2ZW50LmF0dHJpYnV0ZXNba2V5XSA9IHBhcnNlRmxvYXQoZXZlbnQuYXR0cmlidXRlc1trZXldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBbJ0lOREVQRU5ERU5UJywgJ0dBUCddLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgIGlmIChldmVudC5hdHRyaWJ1dGVzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgIGV2ZW50LmF0dHJpYnV0ZXNba2V5XSA9IC9ZRVMvLnRlc3QoZXZlbnQuYXR0cmlidXRlc1trZXldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChldmVudC5hdHRyaWJ1dGVzLmhhc093blByb3BlcnR5KCdCWVRFUkFOR0UnKSkge1xuICAgICAgICAgIGV2ZW50LmF0dHJpYnV0ZXMuYnl0ZXJhbmdlID0gcGFyc2VCeXRlcmFuZ2UoZXZlbnQuYXR0cmlidXRlcy5CWVRFUkFOR0UpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy50cmlnZ2VyKCdkYXRhJywgZXZlbnQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIG1hdGNoID0gL14jRVhULVgtU0VSVkVSLUNPTlRST0w6KC4qKSQvLmV4ZWMobmV3TGluZSk7XG5cbiAgICAgIGlmIChtYXRjaCAmJiBtYXRjaFsxXSkge1xuICAgICAgICBldmVudCA9IHtcbiAgICAgICAgICB0eXBlOiAndGFnJyxcbiAgICAgICAgICB0YWdUeXBlOiAnc2VydmVyLWNvbnRyb2wnXG4gICAgICAgIH07XG4gICAgICAgIGV2ZW50LmF0dHJpYnV0ZXMgPSBwYXJzZUF0dHJpYnV0ZXMobWF0Y2hbMV0pO1xuICAgICAgICBbJ0NBTi1TS0lQLVVOVElMJywgJ1BBUlQtSE9MRC1CQUNLJywgJ0hPTEQtQkFDSyddLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgIGlmIChldmVudC5hdHRyaWJ1dGVzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgIGV2ZW50LmF0dHJpYnV0ZXNba2V5XSA9IHBhcnNlRmxvYXQoZXZlbnQuYXR0cmlidXRlc1trZXldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBbJ0NBTi1TS0lQLURBVEVSQU5HRVMnLCAnQ0FOLUJMT0NLLVJFTE9BRCddLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgIGlmIChldmVudC5hdHRyaWJ1dGVzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgIGV2ZW50LmF0dHJpYnV0ZXNba2V5XSA9IC9ZRVMvLnRlc3QoZXZlbnQuYXR0cmlidXRlc1trZXldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnRyaWdnZXIoJ2RhdGEnLCBldmVudCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgbWF0Y2ggPSAvXiNFWFQtWC1QQVJULUlORjooLiopJC8uZXhlYyhuZXdMaW5lKTtcblxuICAgICAgaWYgKG1hdGNoICYmIG1hdGNoWzFdKSB7XG4gICAgICAgIGV2ZW50ID0ge1xuICAgICAgICAgIHR5cGU6ICd0YWcnLFxuICAgICAgICAgIHRhZ1R5cGU6ICdwYXJ0LWluZidcbiAgICAgICAgfTtcbiAgICAgICAgZXZlbnQuYXR0cmlidXRlcyA9IHBhcnNlQXR0cmlidXRlcyhtYXRjaFsxXSk7XG4gICAgICAgIFsnUEFSVC1UQVJHRVQnXS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICBpZiAoZXZlbnQuYXR0cmlidXRlcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICBldmVudC5hdHRyaWJ1dGVzW2tleV0gPSBwYXJzZUZsb2F0KGV2ZW50LmF0dHJpYnV0ZXNba2V5XSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy50cmlnZ2VyKCdkYXRhJywgZXZlbnQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIG1hdGNoID0gL14jRVhULVgtUFJFTE9BRC1ISU5UOiguKikkLy5leGVjKG5ld0xpbmUpO1xuXG4gICAgICBpZiAobWF0Y2ggJiYgbWF0Y2hbMV0pIHtcbiAgICAgICAgZXZlbnQgPSB7XG4gICAgICAgICAgdHlwZTogJ3RhZycsXG4gICAgICAgICAgdGFnVHlwZTogJ3ByZWxvYWQtaGludCdcbiAgICAgICAgfTtcbiAgICAgICAgZXZlbnQuYXR0cmlidXRlcyA9IHBhcnNlQXR0cmlidXRlcyhtYXRjaFsxXSk7XG4gICAgICAgIFsnQllURVJBTkdFLVNUQVJUJywgJ0JZVEVSQU5HRS1MRU5HVEgnXS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICBpZiAoZXZlbnQuYXR0cmlidXRlcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICBldmVudC5hdHRyaWJ1dGVzW2tleV0gPSBwYXJzZUludChldmVudC5hdHRyaWJ1dGVzW2tleV0sIDEwKTtcbiAgICAgICAgICAgIGNvbnN0IHN1YmtleSA9IGtleSA9PT0gJ0JZVEVSQU5HRS1MRU5HVEgnID8gJ2xlbmd0aCcgOiAnb2Zmc2V0JztcbiAgICAgICAgICAgIGV2ZW50LmF0dHJpYnV0ZXMuYnl0ZXJhbmdlID0gZXZlbnQuYXR0cmlidXRlcy5ieXRlcmFuZ2UgfHwge307XG4gICAgICAgICAgICBldmVudC5hdHRyaWJ1dGVzLmJ5dGVyYW5nZVtzdWJrZXldID0gZXZlbnQuYXR0cmlidXRlc1trZXldOyAvLyBvbmx5IGtlZXAgdGhlIHBhcnNlZCBieXRlcmFuZ2Ugb2JqZWN0LlxuXG4gICAgICAgICAgICBkZWxldGUgZXZlbnQuYXR0cmlidXRlc1trZXldO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudHJpZ2dlcignZGF0YScsIGV2ZW50KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBtYXRjaCA9IC9eI0VYVC1YLVJFTkRJVElPTi1SRVBPUlQ6KC4qKSQvLmV4ZWMobmV3TGluZSk7XG5cbiAgICAgIGlmIChtYXRjaCAmJiBtYXRjaFsxXSkge1xuICAgICAgICBldmVudCA9IHtcbiAgICAgICAgICB0eXBlOiAndGFnJyxcbiAgICAgICAgICB0YWdUeXBlOiAncmVuZGl0aW9uLXJlcG9ydCdcbiAgICAgICAgfTtcbiAgICAgICAgZXZlbnQuYXR0cmlidXRlcyA9IHBhcnNlQXR0cmlidXRlcyhtYXRjaFsxXSk7XG4gICAgICAgIFsnTEFTVC1NU04nLCAnTEFTVC1QQVJUJ10uZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgaWYgKGV2ZW50LmF0dHJpYnV0ZXMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgZXZlbnQuYXR0cmlidXRlc1trZXldID0gcGFyc2VJbnQoZXZlbnQuYXR0cmlidXRlc1trZXldLCAxMCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy50cmlnZ2VyKCdkYXRhJywgZXZlbnQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIG1hdGNoID0gL14jRVhULVgtREFURVJBTkdFOiguKikkLy5leGVjKG5ld0xpbmUpO1xuXG4gICAgICBpZiAobWF0Y2ggJiYgbWF0Y2hbMV0pIHtcbiAgICAgICAgZXZlbnQgPSB7XG4gICAgICAgICAgdHlwZTogJ3RhZycsXG4gICAgICAgICAgdGFnVHlwZTogJ2RhdGVyYW5nZSdcbiAgICAgICAgfTtcbiAgICAgICAgZXZlbnQuYXR0cmlidXRlcyA9IHBhcnNlQXR0cmlidXRlcyhtYXRjaFsxXSk7XG4gICAgICAgIFsnSUQnLCAnQ0xBU1MnXS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICBpZiAoZXZlbnQuYXR0cmlidXRlcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICBldmVudC5hdHRyaWJ1dGVzW2tleV0gPSBTdHJpbmcoZXZlbnQuYXR0cmlidXRlc1trZXldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBbJ1NUQVJULURBVEUnLCAnRU5ELURBVEUnXS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICBpZiAoZXZlbnQuYXR0cmlidXRlcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICBldmVudC5hdHRyaWJ1dGVzW2tleV0gPSBuZXcgRGF0ZShldmVudC5hdHRyaWJ1dGVzW2tleV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIFsnRFVSQVRJT04nLCAnUExBTk5FRC1EVVJBVElPTiddLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgIGlmIChldmVudC5hdHRyaWJ1dGVzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgIGV2ZW50LmF0dHJpYnV0ZXNba2V5XSA9IHBhcnNlRmxvYXQoZXZlbnQuYXR0cmlidXRlc1trZXldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBbJ0VORC1PTi1ORVhUJ10uZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgaWYgKGV2ZW50LmF0dHJpYnV0ZXMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgZXZlbnQuYXR0cmlidXRlc1trZXldID0gL1lFUy9pLnRlc3QoZXZlbnQuYXR0cmlidXRlc1trZXldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBbJ1NDVEUzNS1DTUQnLCAnIFNDVEUzNS1PVVQnLCAnU0NURTM1LUlOJ10uZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgaWYgKGV2ZW50LmF0dHJpYnV0ZXMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgZXZlbnQuYXR0cmlidXRlc1trZXldID0gZXZlbnQuYXR0cmlidXRlc1trZXldLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBjbGllbnRBdHRyaWJ1dGVQYXR0ZXJuID0gL15YLShbQS1aXSstKStbQS1aXSskLztcblxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBldmVudC5hdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgaWYgKCFjbGllbnRBdHRyaWJ1dGVQYXR0ZXJuLnRlc3Qoa2V5KSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgaXNIZXhhRGVjaW1hbCA9IC9bMC05QS1GYS1mXXs2fS9nLnRlc3QoZXZlbnQuYXR0cmlidXRlc1trZXldKTtcbiAgICAgICAgICBjb25zdCBpc0RlY2ltYWxGbG9hdGluZyA9IC9eXFxkKyhcXC5cXGQrKT8kLy50ZXN0KGV2ZW50LmF0dHJpYnV0ZXNba2V5XSk7XG4gICAgICAgICAgZXZlbnQuYXR0cmlidXRlc1trZXldID0gaXNIZXhhRGVjaW1hbCA/IGV2ZW50LmF0dHJpYnV0ZXNba2V5XS50b1N0cmluZygxNikgOiBpc0RlY2ltYWxGbG9hdGluZyA/IHBhcnNlRmxvYXQoZXZlbnQuYXR0cmlidXRlc1trZXldKSA6IFN0cmluZyhldmVudC5hdHRyaWJ1dGVzW2tleV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy50cmlnZ2VyKCdkYXRhJywgZXZlbnQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIG1hdGNoID0gL14jRVhULVgtSU5ERVBFTkRFTlQtU0VHTUVOVFMvLmV4ZWMobmV3TGluZSk7XG5cbiAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICB0aGlzLnRyaWdnZXIoJ2RhdGEnLCB7XG4gICAgICAgICAgdHlwZTogJ3RhZycsXG4gICAgICAgICAgdGFnVHlwZTogJ2luZGVwZW5kZW50LXNlZ21lbnRzJ1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBtYXRjaCA9IC9eI0VYVC1YLUktRlJBTUVTLU9OTFkvLmV4ZWMobmV3TGluZSk7XG5cbiAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICB0aGlzLnRyaWdnZXIoJ2RhdGEnLCB7XG4gICAgICAgICAgdHlwZTogJ3RhZycsXG4gICAgICAgICAgdGFnVHlwZTogJ2ktZnJhbWVzLW9ubHknXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIG1hdGNoID0gL14jRVhULVgtQ09OVEVOVC1TVEVFUklORzooLiopJC8uZXhlYyhuZXdMaW5lKTtcblxuICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgIGV2ZW50ID0ge1xuICAgICAgICAgIHR5cGU6ICd0YWcnLFxuICAgICAgICAgIHRhZ1R5cGU6ICdjb250ZW50LXN0ZWVyaW5nJ1xuICAgICAgICB9O1xuICAgICAgICBldmVudC5hdHRyaWJ1dGVzID0gcGFyc2VBdHRyaWJ1dGVzKG1hdGNoWzFdKTtcbiAgICAgICAgdGhpcy50cmlnZ2VyKCdkYXRhJywgZXZlbnQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIG1hdGNoID0gL14jRVhULVgtSS1GUkFNRS1TVFJFQU0tSU5GOiguKikkLy5leGVjKG5ld0xpbmUpO1xuXG4gICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgZXZlbnQgPSB7XG4gICAgICAgICAgdHlwZTogJ3RhZycsXG4gICAgICAgICAgdGFnVHlwZTogJ2ktZnJhbWUtcGxheWxpc3QnXG4gICAgICAgIH07XG4gICAgICAgIGV2ZW50LmF0dHJpYnV0ZXMgPSBwYXJzZUF0dHJpYnV0ZXMobWF0Y2hbMV0pO1xuXG4gICAgICAgIGlmIChldmVudC5hdHRyaWJ1dGVzLlVSSSkge1xuICAgICAgICAgIGV2ZW50LnVyaSA9IGV2ZW50LmF0dHJpYnV0ZXMuVVJJO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGV2ZW50LmF0dHJpYnV0ZXMuQkFORFdJRFRIKSB7XG4gICAgICAgICAgZXZlbnQuYXR0cmlidXRlcy5CQU5EV0lEVEggPSBwYXJzZUludChldmVudC5hdHRyaWJ1dGVzLkJBTkRXSURUSCwgMTApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGV2ZW50LmF0dHJpYnV0ZXMuUkVTT0xVVElPTikge1xuICAgICAgICAgIGV2ZW50LmF0dHJpYnV0ZXMuUkVTT0xVVElPTiA9IHBhcnNlUmVzb2x1dGlvbihldmVudC5hdHRyaWJ1dGVzLlJFU09MVVRJT04pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGV2ZW50LmF0dHJpYnV0ZXNbJ0FWRVJBR0UtQkFORFdJRFRIJ10pIHtcbiAgICAgICAgICBldmVudC5hdHRyaWJ1dGVzWydBVkVSQUdFLUJBTkRXSURUSCddID0gcGFyc2VJbnQoZXZlbnQuYXR0cmlidXRlc1snQVZFUkFHRS1CQU5EV0lEVEgnXSwgMTApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGV2ZW50LmF0dHJpYnV0ZXNbJ0ZSQU1FLVJBVEUnXSkge1xuICAgICAgICAgIGV2ZW50LmF0dHJpYnV0ZXNbJ0ZSQU1FLVJBVEUnXSA9IHBhcnNlRmxvYXQoZXZlbnQuYXR0cmlidXRlc1snRlJBTUUtUkFURSddKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudHJpZ2dlcignZGF0YScsIGV2ZW50KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBtYXRjaCA9IC9eI0VYVC1YLURFRklORTooLiopJC8uZXhlYyhuZXdMaW5lKTtcblxuICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgIGV2ZW50ID0ge1xuICAgICAgICAgIHR5cGU6ICd0YWcnLFxuICAgICAgICAgIHRhZ1R5cGU6ICdkZWZpbmUnXG4gICAgICAgIH07XG4gICAgICAgIGV2ZW50LmF0dHJpYnV0ZXMgPSBwYXJzZUF0dHJpYnV0ZXMobWF0Y2hbMV0pO1xuICAgICAgICB0aGlzLnRyaWdnZXIoJ2RhdGEnLCBldmVudCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gdW5rbm93biB0YWcgdHlwZVxuXG5cbiAgICAgIHRoaXMudHJpZ2dlcignZGF0YScsIHtcbiAgICAgICAgdHlwZTogJ3RhZycsXG4gICAgICAgIGRhdGE6IG5ld0xpbmUuc2xpY2UoNClcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBBZGQgYSBwYXJzZXIgZm9yIGN1c3RvbSBoZWFkZXJzXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSAgIG9wdGlvbnMgICAgICAgICAgICAgIGEgbWFwIG9mIG9wdGlvbnMgZm9yIHRoZSBhZGRlZCBwYXJzZXJcbiAgICogQHBhcmFtIHtSZWdFeHB9ICAgb3B0aW9ucy5leHByZXNzaW9uICAgYSByZWd1bGFyIGV4cHJlc3Npb24gdG8gbWF0Y2ggdGhlIGN1c3RvbSBoZWFkZXJcbiAgICogQHBhcmFtIHtzdHJpbmd9ICAgb3B0aW9ucy5jdXN0b21UeXBlICAgdGhlIGN1c3RvbSB0eXBlIHRvIHJlZ2lzdGVyIHRvIHRoZSBvdXRwdXRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuZGF0YVBhcnNlcl0gZnVuY3Rpb24gdG8gcGFyc2UgdGhlIGxpbmUgaW50byBhbiBvYmplY3RcbiAgICogQHBhcmFtIHtib29sZWFufSAgW29wdGlvbnMuc2VnbWVudF0gICAgc2hvdWxkIHRhZyBkYXRhIGJlIGF0dGFjaGVkIHRvIHRoZSBzZWdtZW50IG9iamVjdFxuICAgKi9cblxuXG4gIGFkZFBhcnNlcih7XG4gICAgZXhwcmVzc2lvbixcbiAgICBjdXN0b21UeXBlLFxuICAgIGRhdGFQYXJzZXIsXG4gICAgc2VnbWVudFxuICB9KSB7XG4gICAgaWYgKHR5cGVvZiBkYXRhUGFyc2VyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBkYXRhUGFyc2VyID0gbGluZSA9PiBsaW5lO1xuICAgIH1cblxuICAgIHRoaXMuY3VzdG9tUGFyc2Vycy5wdXNoKGxpbmUgPT4ge1xuICAgICAgY29uc3QgbWF0Y2ggPSBleHByZXNzaW9uLmV4ZWMobGluZSk7XG5cbiAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICB0aGlzLnRyaWdnZXIoJ2RhdGEnLCB7XG4gICAgICAgICAgdHlwZTogJ2N1c3RvbScsXG4gICAgICAgICAgZGF0YTogZGF0YVBhcnNlcihsaW5lKSxcbiAgICAgICAgICBjdXN0b21UeXBlLFxuICAgICAgICAgIHNlZ21lbnRcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBBZGQgYSBjdXN0b20gaGVhZGVyIG1hcHBlclxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gICBvcHRpb25zXG4gICAqIEBwYXJhbSB7UmVnRXhwfSAgIG9wdGlvbnMuZXhwcmVzc2lvbiAgIGEgcmVndWxhciBleHByZXNzaW9uIHRvIG1hdGNoIHRoZSBjdXN0b20gaGVhZGVyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IG9wdGlvbnMubWFwICAgICAgICAgIGZ1bmN0aW9uIHRvIHRyYW5zbGF0ZSB0YWcgaW50byBhIGRpZmZlcmVudCB0YWdcbiAgICovXG5cblxuICBhZGRUYWdNYXBwZXIoe1xuICAgIGV4cHJlc3Npb24sXG4gICAgbWFwXG4gIH0pIHtcbiAgICBjb25zdCBtYXBGbiA9IGxpbmUgPT4ge1xuICAgICAgaWYgKGV4cHJlc3Npb24udGVzdChsaW5lKSkge1xuICAgICAgICByZXR1cm4gbWFwKGxpbmUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbGluZTtcbiAgICB9O1xuXG4gICAgdGhpcy50YWdNYXBwZXJzLnB1c2gobWFwRm4pO1xuICB9XG5cbn1cblxuY29uc3QgY2FtZWxDYXNlID0gc3RyID0+IHN0ci50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoLy0oXFx3KS9nLCBhID0+IGFbMV0udG9VcHBlckNhc2UoKSk7XG5cbmNvbnN0IGNhbWVsQ2FzZUtleXMgPSBmdW5jdGlvbiAoYXR0cmlidXRlcykge1xuICBjb25zdCByZXN1bHQgPSB7fTtcbiAgT2JqZWN0LmtleXMoYXR0cmlidXRlcykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmVzdWx0W2NhbWVsQ2FzZShrZXkpXSA9IGF0dHJpYnV0ZXNba2V5XTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59OyAvLyBzZXQgU0VSVkVSLUNPTlRST0wgaG9sZCBiYWNrIGJhc2VkIHVwb24gdGFyZ2V0RHVyYXRpb24gYW5kIHBhcnRUYXJnZXREdXJhdGlvblxuLy8gd2UgbmVlZCB0aGlzIGhlbHBlciBiZWNhdXNlIGRlZmF1bHRzIGFyZSBiYXNlZCB1cG9uIHRhcmdldER1cmF0aW9uIGFuZFxuLy8gcGFydFRhcmdldER1cmF0aW9uIGJlaW5nIHNldCwgYnV0IHRoZXkgbWF5IG5vdCBiZSBpZiBTRVJWRVItQ09OVFJPTCBhcHBlYXJzIGJlZm9yZVxuLy8gdGFyZ2V0IGR1cmF0aW9ucyBhcmUgc2V0LlxuXG5cbmNvbnN0IHNldEhvbGRCYWNrID0gZnVuY3Rpb24gKG1hbmlmZXN0KSB7XG4gIGNvbnN0IHtcbiAgICBzZXJ2ZXJDb250cm9sLFxuICAgIHRhcmdldER1cmF0aW9uLFxuICAgIHBhcnRUYXJnZXREdXJhdGlvblxuICB9ID0gbWFuaWZlc3Q7XG5cbiAgaWYgKCFzZXJ2ZXJDb250cm9sKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3QgdGFnID0gJyNFWFQtWC1TRVJWRVItQ09OVFJPTCc7XG4gIGNvbnN0IGhiID0gJ2hvbGRCYWNrJztcbiAgY29uc3QgcGhiID0gJ3BhcnRIb2xkQmFjayc7XG4gIGNvbnN0IG1pblRhcmdldER1cmF0aW9uID0gdGFyZ2V0RHVyYXRpb24gJiYgdGFyZ2V0RHVyYXRpb24gKiAzO1xuICBjb25zdCBtaW5QYXJ0RHVyYXRpb24gPSBwYXJ0VGFyZ2V0RHVyYXRpb24gJiYgcGFydFRhcmdldER1cmF0aW9uICogMjtcblxuICBpZiAodGFyZ2V0RHVyYXRpb24gJiYgIXNlcnZlckNvbnRyb2wuaGFzT3duUHJvcGVydHkoaGIpKSB7XG4gICAgc2VydmVyQ29udHJvbFtoYl0gPSBtaW5UYXJnZXREdXJhdGlvbjtcbiAgICB0aGlzLnRyaWdnZXIoJ2luZm8nLCB7XG4gICAgICBtZXNzYWdlOiBgJHt0YWd9IGRlZmF1bHRpbmcgSE9MRC1CQUNLIHRvIHRhcmdldER1cmF0aW9uICogMyAoJHttaW5UYXJnZXREdXJhdGlvbn0pLmBcbiAgICB9KTtcbiAgfVxuXG4gIGlmIChtaW5UYXJnZXREdXJhdGlvbiAmJiBzZXJ2ZXJDb250cm9sW2hiXSA8IG1pblRhcmdldER1cmF0aW9uKSB7XG4gICAgdGhpcy50cmlnZ2VyKCd3YXJuJywge1xuICAgICAgbWVzc2FnZTogYCR7dGFnfSBjbGFtcGluZyBIT0xELUJBQ0sgKCR7c2VydmVyQ29udHJvbFtoYl19KSB0byB0YXJnZXREdXJhdGlvbiAqIDMgKCR7bWluVGFyZ2V0RHVyYXRpb259KWBcbiAgICB9KTtcbiAgICBzZXJ2ZXJDb250cm9sW2hiXSA9IG1pblRhcmdldER1cmF0aW9uO1xuICB9IC8vIGRlZmF1bHQgbm8gcGFydCBob2xkIGJhY2sgdG8gcGFydCB0YXJnZXQgZHVyYXRpb24gKiAzXG5cblxuICBpZiAocGFydFRhcmdldER1cmF0aW9uICYmICFzZXJ2ZXJDb250cm9sLmhhc093blByb3BlcnR5KHBoYikpIHtcbiAgICBzZXJ2ZXJDb250cm9sW3BoYl0gPSBwYXJ0VGFyZ2V0RHVyYXRpb24gKiAzO1xuICAgIHRoaXMudHJpZ2dlcignaW5mbycsIHtcbiAgICAgIG1lc3NhZ2U6IGAke3RhZ30gZGVmYXVsdGluZyBQQVJULUhPTEQtQkFDSyB0byBwYXJ0VGFyZ2V0RHVyYXRpb24gKiAzICgke3NlcnZlckNvbnRyb2xbcGhiXX0pLmBcbiAgICB9KTtcbiAgfSAvLyBpZiBwYXJ0IGhvbGQgYmFjayBpcyB0b28gc21hbGwgZGVmYXVsdCBpdCB0byBwYXJ0IHRhcmdldCBkdXJhdGlvbiAqIDJcblxuXG4gIGlmIChwYXJ0VGFyZ2V0RHVyYXRpb24gJiYgc2VydmVyQ29udHJvbFtwaGJdIDwgbWluUGFydER1cmF0aW9uKSB7XG4gICAgdGhpcy50cmlnZ2VyKCd3YXJuJywge1xuICAgICAgbWVzc2FnZTogYCR7dGFnfSBjbGFtcGluZyBQQVJULUhPTEQtQkFDSyAoJHtzZXJ2ZXJDb250cm9sW3BoYl19KSB0byBwYXJ0VGFyZ2V0RHVyYXRpb24gKiAyICgke21pblBhcnREdXJhdGlvbn0pLmBcbiAgICB9KTtcbiAgICBzZXJ2ZXJDb250cm9sW3BoYl0gPSBtaW5QYXJ0RHVyYXRpb247XG4gIH1cbn07XG4vKipcbiAqIEEgcGFyc2VyIGZvciBNM1U4IGZpbGVzLiBUaGUgY3VycmVudCBpbnRlcnByZXRhdGlvbiBvZiB0aGUgaW5wdXQgaXNcbiAqIGV4cG9zZWQgYXMgYSBwcm9wZXJ0eSBgbWFuaWZlc3RgIG9uIHBhcnNlciBvYmplY3RzLiBJdCdzIGp1c3QgdHdvIGxpbmVzIHRvXG4gKiBjcmVhdGUgYW5kIHBhcnNlIGEgbWFuaWZlc3Qgb25jZSB5b3UgaGF2ZSB0aGUgY29udGVudHMgYXZhaWxhYmxlIGFzIGEgc3RyaW5nOlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgcGFyc2VyID0gbmV3IG0zdTguUGFyc2VyKCk7XG4gKiBwYXJzZXIucHVzaCh4aHIucmVzcG9uc2VUZXh0KTtcbiAqIGBgYFxuICpcbiAqIE5ldyBpbnB1dCBjYW4gbGF0ZXIgYmUgYXBwbGllZCB0byB1cGRhdGUgdGhlIG1hbmlmZXN0IG9iamVjdCBieSBjYWxsaW5nXG4gKiBgcHVzaGAgYWdhaW4uXG4gKlxuICogVGhlIHBhcnNlciBhdHRlbXB0cyB0byBjcmVhdGUgYSB1c2FibGUgbWFuaWZlc3Qgb2JqZWN0IGV2ZW4gaWYgdGhlXG4gKiB1bmRlcmx5aW5nIGlucHV0IGlzIHNvbWV3aGF0IG5vbnNlbnNpY2FsLiBJdCBlbWl0cyBgaW5mb2AgYW5kIGB3YXJuaW5nYFxuICogZXZlbnRzIGR1cmluZyB0aGUgcGFyc2UgaWYgaXQgZW5jb3VudGVycyBpbnB1dCB0aGF0IHNlZW1zIGludmFsaWQgb3JcbiAqIHJlcXVpcmVzIHNvbWUgcHJvcGVydHkgb2YgdGhlIG1hbmlmZXN0IG9iamVjdCB0byBiZSBkZWZhdWx0ZWQuXG4gKlxuICogQGNsYXNzIFBhcnNlclxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRzXSBPcHRpb25zIGZvciB0aGUgY29uc3RydWN0b3IsIG5lZWRlZCBmb3Igc3Vic3RpdHV0aW9uc1xuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLnVyaV0gVVJMIHRvIGNoZWNrIGZvciBxdWVyeSBwYXJhbXNcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0cy5tYWluRGVmaW5pdGlvbnNdIERlZmluaXRpb25zIG9uIG1haW4gcGxheWxpc3QgdGhhdCBjYW4gYmUgaW1wb3J0ZWRcbiAqIEBleHRlbmRzIFN0cmVhbVxuICovXG5cblxuY2xhc3MgUGFyc2VyIGV4dGVuZHMgU3RyZWFtX19kZWZhdWx0W1wiZGVmYXVsdFwiXSB7XG4gIGNvbnN0cnVjdG9yKG9wdHMgPSB7fSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5saW5lU3RyZWFtID0gbmV3IExpbmVTdHJlYW0oKTtcbiAgICB0aGlzLnBhcnNlU3RyZWFtID0gbmV3IFBhcnNlU3RyZWFtKCk7XG4gICAgdGhpcy5saW5lU3RyZWFtLnBpcGUodGhpcy5wYXJzZVN0cmVhbSk7XG4gICAgdGhpcy5tYWluRGVmaW5pdGlvbnMgPSBvcHRzLm1haW5EZWZpbml0aW9ucyB8fCB7fTtcbiAgICB0aGlzLnBhcmFtcyA9IG5ldyBVUkwob3B0cy51cmksICdodHRwczovL2EuY29tJykuc2VhcmNoUGFyYW1zO1xuICAgIHRoaXMubGFzdFByb2dyYW1EYXRlVGltZSA9IG51bGw7XG4gICAgLyogZXNsaW50LWRpc2FibGUgY29uc2lzdGVudC10aGlzICovXG5cbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAvKiBlc2xpbnQtZW5hYmxlIGNvbnNpc3RlbnQtdGhpcyAqL1xuXG4gICAgY29uc3QgdXJpcyA9IFtdO1xuICAgIGxldCBjdXJyZW50VXJpID0ge307IC8vIGlmIHNwZWNpZmllZCwgdGhlIGFjdGl2ZSBFWFQtWC1NQVAgZGVmaW5pdGlvblxuXG4gICAgbGV0IGN1cnJlbnRNYXA7IC8vIGlmIHNwZWNpZmllZCwgdGhlIGFjdGl2ZSBkZWNyeXB0aW9uIGtleVxuXG4gICAgbGV0IGtleTtcbiAgICBsZXQgaGFzUGFydHMgPSBmYWxzZTtcblxuICAgIGNvbnN0IG5vb3AgPSBmdW5jdGlvbiAoKSB7fTtcblxuICAgIGNvbnN0IGRlZmF1bHRNZWRpYUdyb3VwcyA9IHtcbiAgICAgICdBVURJTyc6IHt9LFxuICAgICAgJ1ZJREVPJzoge30sXG4gICAgICAnQ0xPU0VELUNBUFRJT05TJzoge30sXG4gICAgICAnU1VCVElUTEVTJzoge31cbiAgICB9OyAvLyBUaGlzIGlzIHRoZSBXaWRldmluZSBVVUlEIGZyb20gREFTSCBJRiBJT1AuIFRoZSBzYW1lIGV4YWN0IHN0cmluZyBpc1xuICAgIC8vIHVzZWQgaW4gTVBEcyB3aXRoIFdpZGV2aW5lIGVuY3J5cHRlZCBzdHJlYW1zLlxuXG4gICAgY29uc3Qgd2lkZXZpbmVVdWlkID0gJ3Vybjp1dWlkOmVkZWY4YmE5LTc5ZDYtNGFjZS1hM2M4LTI3ZGNkNTFkMjFlZCc7IC8vIGdyb3VwIHNlZ21lbnRzIGludG8gbnVtYmVyZWQgdGltZWxpbmVzIGRlbGluZWF0ZWQgYnkgZGlzY29udGludWl0aWVzXG5cbiAgICBsZXQgY3VycmVudFRpbWVsaW5lID0gMDsgLy8gdGhlIG1hbmlmZXN0IGlzIGVtcHR5IHVudGlsIHRoZSBwYXJzZSBzdHJlYW0gYmVnaW5zIGRlbGl2ZXJpbmcgZGF0YVxuXG4gICAgdGhpcy5tYW5pZmVzdCA9IHtcbiAgICAgIGFsbG93Q2FjaGU6IHRydWUsXG4gICAgICBkaXNjb250aW51aXR5U3RhcnRzOiBbXSxcbiAgICAgIGRhdGVSYW5nZXM6IFtdLFxuICAgICAgaUZyYW1lUGxheWxpc3RzOiBbXSxcbiAgICAgIHNlZ21lbnRzOiBbXVxuICAgIH07IC8vIGtlZXAgdHJhY2sgb2YgdGhlIGxhc3Qgc2VlbiBzZWdtZW50J3MgYnl0ZSByYW5nZSBlbmQsIGFzIHNlZ21lbnRzIGFyZSBub3QgcmVxdWlyZWRcbiAgICAvLyB0byBwcm92aWRlIHRoZSBvZmZzZXQsIGluIHdoaWNoIGNhc2UgaXQgZGVmYXVsdHMgdG8gdGhlIG5leHQgYnl0ZSBhZnRlciB0aGVcbiAgICAvLyBwcmV2aW91cyBzZWdtZW50XG5cbiAgICBsZXQgbGFzdEJ5dGVyYW5nZUVuZCA9IDA7IC8vIGtlZXAgdHJhY2sgb2YgdGhlIGxhc3Qgc2VlbiBwYXJ0J3MgYnl0ZSByYW5nZSBlbmQuXG5cbiAgICBsZXQgbGFzdFBhcnRCeXRlcmFuZ2VFbmQgPSAwO1xuICAgIGNvbnN0IGRhdGVSYW5nZVRhZ3MgPSB7fTtcbiAgICB0aGlzLm9uKCdlbmQnLCAoKSA9PiB7XG4gICAgICAvLyBvbmx5IGFkZCBwcmVsb2FkU2VnbWVudCBpZiB3ZSBkb24ndCB5ZXQgaGF2ZSBhIHVyaSBmb3IgaXQuXG4gICAgICAvLyBhbmQgd2UgYWN0dWFsbHkgaGF2ZSBwYXJ0cy9wcmVsb2FkSGludHNcbiAgICAgIGlmIChjdXJyZW50VXJpLnVyaSB8fCAhY3VycmVudFVyaS5wYXJ0cyAmJiAhY3VycmVudFVyaS5wcmVsb2FkSGludHMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWN1cnJlbnRVcmkubWFwICYmIGN1cnJlbnRNYXApIHtcbiAgICAgICAgY3VycmVudFVyaS5tYXAgPSBjdXJyZW50TWFwO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWN1cnJlbnRVcmkua2V5ICYmIGtleSkge1xuICAgICAgICBjdXJyZW50VXJpLmtleSA9IGtleTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFjdXJyZW50VXJpLnRpbWVsaW5lICYmIHR5cGVvZiBjdXJyZW50VGltZWxpbmUgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGN1cnJlbnRVcmkudGltZWxpbmUgPSBjdXJyZW50VGltZWxpbmU7XG4gICAgICB9XG5cbiAgICAgIHRoaXMubWFuaWZlc3QucHJlbG9hZFNlZ21lbnQgPSBjdXJyZW50VXJpO1xuICAgIH0pOyAvLyB1cGRhdGUgdGhlIG1hbmlmZXN0IHdpdGggdGhlIG0zdTggZW50cnkgZnJvbSB0aGUgcGFyc2Ugc3RyZWFtXG5cbiAgICB0aGlzLnBhcnNlU3RyZWFtLm9uKCdkYXRhJywgZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgICBsZXQgbWVkaWFHcm91cDtcbiAgICAgIGxldCByZW5kaXRpb247IC8vIFJlcGxhY2UgdmFyaWFibGVzIGluIHVyaXMgYW5kIGF0dHJpYnV0ZXMgYXMgZGVmaW5lZCBpbiAjRVhULVgtREVGSU5FIHRhZ3NcblxuICAgICAgaWYgKHNlbGYubWFuaWZlc3QuZGVmaW5pdGlvbnMpIHtcbiAgICAgICAgZm9yIChjb25zdCBkZWYgaW4gc2VsZi5tYW5pZmVzdC5kZWZpbml0aW9ucykge1xuICAgICAgICAgIGlmIChlbnRyeS51cmkpIHtcbiAgICAgICAgICAgIGVudHJ5LnVyaSA9IGVudHJ5LnVyaS5yZXBsYWNlKGB7JCR7ZGVmfX1gLCBzZWxmLm1hbmlmZXN0LmRlZmluaXRpb25zW2RlZl0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChlbnRyeS5hdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGF0dHIgaW4gZW50cnkuYXR0cmlidXRlcykge1xuICAgICAgICAgICAgICBpZiAodHlwZW9mIGVudHJ5LmF0dHJpYnV0ZXNbYXR0cl0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgZW50cnkuYXR0cmlidXRlc1thdHRyXSA9IGVudHJ5LmF0dHJpYnV0ZXNbYXR0cl0ucmVwbGFjZShgeyQke2RlZn19YCwgc2VsZi5tYW5pZmVzdC5kZWZpbml0aW9uc1tkZWZdKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAoe1xuICAgICAgICB0YWcoKSB7XG4gICAgICAgICAgLy8gc3dpdGNoIGJhc2VkIG9uIHRoZSB0YWcgdHlwZVxuICAgICAgICAgICgoe1xuICAgICAgICAgICAgdmVyc2lvbigpIHtcbiAgICAgICAgICAgICAgaWYgKGVudHJ5LnZlcnNpb24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1hbmlmZXN0LnZlcnNpb24gPSBlbnRyeS52ZXJzaW9uO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAnYWxsb3ctY2FjaGUnKCkge1xuICAgICAgICAgICAgICB0aGlzLm1hbmlmZXN0LmFsbG93Q2FjaGUgPSBlbnRyeS5hbGxvd2VkO1xuXG4gICAgICAgICAgICAgIGlmICghKCdhbGxvd2VkJyBpbiBlbnRyeSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXIoJ2luZm8nLCB7XG4gICAgICAgICAgICAgICAgICBtZXNzYWdlOiAnZGVmYXVsdGluZyBhbGxvd0NhY2hlIHRvIFlFUydcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLm1hbmlmZXN0LmFsbG93Q2FjaGUgPSB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBieXRlcmFuZ2UoKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGJ5dGVyYW5nZSA9IHt9O1xuXG4gICAgICAgICAgICAgIGlmICgnbGVuZ3RoJyBpbiBlbnRyeSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRVcmkuYnl0ZXJhbmdlID0gYnl0ZXJhbmdlO1xuICAgICAgICAgICAgICAgIGJ5dGVyYW5nZS5sZW5ndGggPSBlbnRyeS5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICBpZiAoISgnb2Zmc2V0JyBpbiBlbnRyeSkpIHtcbiAgICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICAgKiBGcm9tIHRoZSBsYXRlc3Qgc3BlYyAoYXMgb2YgdGhpcyB3cml0aW5nKTpcbiAgICAgICAgICAgICAgICAgICAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9kcmFmdC1wYW50b3MtaHR0cC1saXZlLXN0cmVhbWluZy0yMyNzZWN0aW9uLTQuMy4yLjJcbiAgICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICAgKiBTYW1lIHRleHQgc2luY2UgRVhULVgtQllURVJBTkdFJ3MgaW50cm9kdWN0aW9uIGluIGRyYWZ0IDc6XG4gICAgICAgICAgICAgICAgICAgKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvZHJhZnQtcGFudG9zLWh0dHAtbGl2ZS1zdHJlYW1pbmctMDcjc2VjdGlvbi0zLjMuMSlcbiAgICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICAgKiBcIklmIG8gW29mZnNldF0gaXMgbm90IHByZXNlbnQsIHRoZSBzdWItcmFuZ2UgYmVnaW5zIGF0IHRoZSBuZXh0IGJ5dGVcbiAgICAgICAgICAgICAgICAgICAqIGZvbGxvd2luZyB0aGUgc3ViLXJhbmdlIG9mIHRoZSBwcmV2aW91cyBtZWRpYSBzZWdtZW50LlwiXG4gICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgIGVudHJ5Lm9mZnNldCA9IGxhc3RCeXRlcmFuZ2VFbmQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKCdvZmZzZXQnIGluIGVudHJ5KSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFVyaS5ieXRlcmFuZ2UgPSBieXRlcmFuZ2U7XG4gICAgICAgICAgICAgICAgYnl0ZXJhbmdlLm9mZnNldCA9IGVudHJ5Lm9mZnNldDtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGxhc3RCeXRlcmFuZ2VFbmQgPSBieXRlcmFuZ2Uub2Zmc2V0ICsgYnl0ZXJhbmdlLmxlbmd0aDtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGVuZGxpc3QoKSB7XG4gICAgICAgICAgICAgIHRoaXMubWFuaWZlc3QuZW5kTGlzdCA9IHRydWU7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBpbmYoKSB7XG4gICAgICAgICAgICAgIGlmICghKCdtZWRpYVNlcXVlbmNlJyBpbiB0aGlzLm1hbmlmZXN0KSkge1xuICAgICAgICAgICAgICAgIHRoaXMubWFuaWZlc3QubWVkaWFTZXF1ZW5jZSA9IDA7XG4gICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCdpbmZvJywge1xuICAgICAgICAgICAgICAgICAgbWVzc2FnZTogJ2RlZmF1bHRpbmcgbWVkaWEgc2VxdWVuY2UgdG8gemVybydcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmICghKCdkaXNjb250aW51aXR5U2VxdWVuY2UnIGluIHRoaXMubWFuaWZlc3QpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tYW5pZmVzdC5kaXNjb250aW51aXR5U2VxdWVuY2UgPSAwO1xuICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlcignaW5mbycsIHtcbiAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdkZWZhdWx0aW5nIGRpc2NvbnRpbnVpdHkgc2VxdWVuY2UgdG8gemVybydcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChlbnRyeS50aXRsZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRVcmkudGl0bGUgPSBlbnRyeS50aXRsZTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChlbnRyeS5kdXJhdGlvbiA+IDApIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50VXJpLmR1cmF0aW9uID0gZW50cnkuZHVyYXRpb247XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoZW50cnkuZHVyYXRpb24gPT09IDApIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50VXJpLmR1cmF0aW9uID0gMC4wMTtcbiAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXIoJ2luZm8nLCB7XG4gICAgICAgICAgICAgICAgICBtZXNzYWdlOiAndXBkYXRpbmcgemVybyBzZWdtZW50IGR1cmF0aW9uIHRvIGEgc21hbGwgdmFsdWUnXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB0aGlzLm1hbmlmZXN0LnNlZ21lbnRzID0gdXJpcztcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGtleSgpIHtcbiAgICAgICAgICAgICAgaWYgKCFlbnRyeS5hdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCd3YXJuJywge1xuICAgICAgICAgICAgICAgICAgbWVzc2FnZTogJ2lnbm9yaW5nIGtleSBkZWNsYXJhdGlvbiB3aXRob3V0IGF0dHJpYnV0ZSBsaXN0J1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfSAvLyBjbGVhciB0aGUgYWN0aXZlIGVuY3J5cHRpb24ga2V5XG5cblxuICAgICAgICAgICAgICBpZiAoZW50cnkuYXR0cmlidXRlcy5NRVRIT0QgPT09ICdOT05FJykge1xuICAgICAgICAgICAgICAgIGtleSA9IG51bGw7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKCFlbnRyeS5hdHRyaWJ1dGVzLlVSSSkge1xuICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlcignd2FybicsIHtcbiAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdpZ25vcmluZyBrZXkgZGVjbGFyYXRpb24gd2l0aG91dCBVUkknXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKGVudHJ5LmF0dHJpYnV0ZXMuS0VZRk9STUFUID09PSAnY29tLmFwcGxlLnN0cmVhbWluZ2tleWRlbGl2ZXJ5Jykge1xuICAgICAgICAgICAgICAgIHRoaXMubWFuaWZlc3QuY29udGVudFByb3RlY3Rpb24gPSB0aGlzLm1hbmlmZXN0LmNvbnRlbnRQcm90ZWN0aW9uIHx8IHt9OyAvLyBUT0RPOiBhZGQgZnVsbCBzdXBwb3J0IGZvciB0aGlzLlxuXG4gICAgICAgICAgICAgICAgdGhpcy5tYW5pZmVzdC5jb250ZW50UHJvdGVjdGlvblsnY29tLmFwcGxlLmZwcy4xXzAnXSA9IHtcbiAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IGVudHJ5LmF0dHJpYnV0ZXNcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChlbnRyeS5hdHRyaWJ1dGVzLktFWUZPUk1BVCA9PT0gJ2NvbS5taWNyb3NvZnQucGxheXJlYWR5Jykge1xuICAgICAgICAgICAgICAgIHRoaXMubWFuaWZlc3QuY29udGVudFByb3RlY3Rpb24gPSB0aGlzLm1hbmlmZXN0LmNvbnRlbnRQcm90ZWN0aW9uIHx8IHt9OyAvLyBUT0RPOiBhZGQgZnVsbCBzdXBwb3J0IGZvciB0aGlzLlxuXG4gICAgICAgICAgICAgICAgdGhpcy5tYW5pZmVzdC5jb250ZW50UHJvdGVjdGlvblsnY29tLm1pY3Jvc29mdC5wbGF5cmVhZHknXSA9IHtcbiAgICAgICAgICAgICAgICAgIHVyaTogZW50cnkuYXR0cmlidXRlcy5VUklcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfSAvLyBjaGVjayBpZiB0aGUgY29udGVudCBpcyBlbmNyeXB0ZWQgZm9yIFdpZGV2aW5lXG4gICAgICAgICAgICAgIC8vIFdpZGV2aW5lL0hMUyBzcGVjOiBodHRwczovL3N0b3JhZ2UuZ29vZ2xlYXBpcy5jb20vd3Zkb2NzL1dpZGV2aW5lX0RSTV9ITFMucGRmXG5cblxuICAgICAgICAgICAgICBpZiAoZW50cnkuYXR0cmlidXRlcy5LRVlGT1JNQVQgPT09IHdpZGV2aW5lVXVpZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IFZBTElEX01FVEhPRFMgPSBbJ1NBTVBMRS1BRVMnLCAnU0FNUExFLUFFUy1DVFInLCAnU0FNUExFLUFFUy1DRU5DJ107XG5cbiAgICAgICAgICAgICAgICBpZiAoVkFMSURfTUVUSE9EUy5pbmRleE9mKGVudHJ5LmF0dHJpYnV0ZXMuTUVUSE9EKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlcignd2FybicsIHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogJ2ludmFsaWQga2V5IG1ldGhvZCBwcm92aWRlZCBmb3IgV2lkZXZpbmUnXG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoZW50cnkuYXR0cmlidXRlcy5NRVRIT0QgPT09ICdTQU1QTEUtQUVTLUNFTkMnKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXIoJ3dhcm4nLCB7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdTQU1QTEUtQUVTLUNFTkMgaXMgZGVwcmVjYXRlZCwgcGxlYXNlIHVzZSBTQU1QTEUtQUVTLUNUUiBpbnN0ZWFkJ1xuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGVudHJ5LmF0dHJpYnV0ZXMuVVJJLnN1YnN0cmluZygwLCAyMykgIT09ICdkYXRhOnRleHQvcGxhaW47YmFzZTY0LCcpIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlcignd2FybicsIHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogJ2ludmFsaWQga2V5IFVSSSBwcm92aWRlZCBmb3IgV2lkZXZpbmUnXG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIShlbnRyeS5hdHRyaWJ1dGVzLktFWUlEICYmIGVudHJ5LmF0dHJpYnV0ZXMuS0VZSUQuc3Vic3RyaW5nKDAsIDIpID09PSAnMHgnKSkge1xuICAgICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCd3YXJuJywge1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiAnaW52YWxpZCBrZXkgSUQgcHJvdmlkZWQgZm9yIFdpZGV2aW5lJ1xuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfSAvLyBpZiBXaWRldmluZSBrZXkgYXR0cmlidXRlcyBhcmUgdmFsaWQsIHN0b3JlIHRoZW0gYXMgYGNvbnRlbnRQcm90ZWN0aW9uYFxuICAgICAgICAgICAgICAgIC8vIG9uIHRoZSBtYW5pZmVzdCB0byBlbXVsYXRlIFdpZGV2aW5lIHRhZyBzdHJ1Y3R1cmUgaW4gYSBEQVNIIG1wZFxuXG5cbiAgICAgICAgICAgICAgICB0aGlzLm1hbmlmZXN0LmNvbnRlbnRQcm90ZWN0aW9uID0gdGhpcy5tYW5pZmVzdC5jb250ZW50UHJvdGVjdGlvbiB8fCB7fTtcbiAgICAgICAgICAgICAgICB0aGlzLm1hbmlmZXN0LmNvbnRlbnRQcm90ZWN0aW9uWydjb20ud2lkZXZpbmUuYWxwaGEnXSA9IHtcbiAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgc2NoZW1lSWRVcmk6IGVudHJ5LmF0dHJpYnV0ZXMuS0VZRk9STUFULFxuICAgICAgICAgICAgICAgICAgICAvLyByZW1vdmUgJzB4JyBmcm9tIHRoZSBrZXkgaWQgc3RyaW5nXG4gICAgICAgICAgICAgICAgICAgIGtleUlkOiBlbnRyeS5hdHRyaWJ1dGVzLktFWUlELnN1YnN0cmluZygyKVxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIC8vIGRlY29kZSB0aGUgYmFzZTY0LWVuY29kZWQgUFNTSCBib3hcbiAgICAgICAgICAgICAgICAgIHBzc2g6IGRlY29kZUI2NFRvVWludDhBcnJheV9fZGVmYXVsdFtcImRlZmF1bHRcIl0oZW50cnkuYXR0cmlidXRlcy5VUkkuc3BsaXQoJywnKVsxXSlcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmICghZW50cnkuYXR0cmlidXRlcy5NRVRIT0QpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXIoJ3dhcm4nLCB7XG4gICAgICAgICAgICAgICAgICBtZXNzYWdlOiAnZGVmYXVsdGluZyBrZXkgbWV0aG9kIHRvIEFFUy0xMjgnXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH0gLy8gc2V0dXAgYW4gZW5jcnlwdGlvbiBrZXkgZm9yIHVwY29taW5nIHNlZ21lbnRzXG5cblxuICAgICAgICAgICAgICBrZXkgPSB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiBlbnRyeS5hdHRyaWJ1dGVzLk1FVEhPRCB8fCAnQUVTLTEyOCcsXG4gICAgICAgICAgICAgICAgdXJpOiBlbnRyeS5hdHRyaWJ1dGVzLlVSSVxuICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgZW50cnkuYXR0cmlidXRlcy5JViAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBrZXkuaXYgPSBlbnRyeS5hdHRyaWJ1dGVzLklWO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAnbWVkaWEtc2VxdWVuY2UnKCkge1xuICAgICAgICAgICAgICBpZiAoIWlzRmluaXRlKGVudHJ5Lm51bWJlcikpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXIoJ3dhcm4nLCB7XG4gICAgICAgICAgICAgICAgICBtZXNzYWdlOiAnaWdub3JpbmcgaW52YWxpZCBtZWRpYSBzZXF1ZW5jZTogJyArIGVudHJ5Lm51bWJlclxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHRoaXMubWFuaWZlc3QubWVkaWFTZXF1ZW5jZSA9IGVudHJ5Lm51bWJlcjtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICdkaXNjb250aW51aXR5LXNlcXVlbmNlJygpIHtcbiAgICAgICAgICAgICAgaWYgKCFpc0Zpbml0ZShlbnRyeS5udW1iZXIpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCd3YXJuJywge1xuICAgICAgICAgICAgICAgICAgbWVzc2FnZTogJ2lnbm9yaW5nIGludmFsaWQgZGlzY29udGludWl0eSBzZXF1ZW5jZTogJyArIGVudHJ5Lm51bWJlclxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHRoaXMubWFuaWZlc3QuZGlzY29udGludWl0eVNlcXVlbmNlID0gZW50cnkubnVtYmVyO1xuICAgICAgICAgICAgICBjdXJyZW50VGltZWxpbmUgPSBlbnRyeS5udW1iZXI7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAncGxheWxpc3QtdHlwZScoKSB7XG4gICAgICAgICAgICAgIGlmICghL1ZPRHxFVkVOVC8udGVzdChlbnRyeS5wbGF5bGlzdFR5cGUpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCd3YXJuJywge1xuICAgICAgICAgICAgICAgICAgbWVzc2FnZTogJ2lnbm9yaW5nIHVua25vd24gcGxheWxpc3QgdHlwZTogJyArIGVudHJ5LnBsYXlsaXN0XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdGhpcy5tYW5pZmVzdC5wbGF5bGlzdFR5cGUgPSBlbnRyeS5wbGF5bGlzdFR5cGU7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBtYXAoKSB7XG4gICAgICAgICAgICAgIGN1cnJlbnRNYXAgPSB7fTtcblxuICAgICAgICAgICAgICBpZiAoZW50cnkudXJpKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudE1hcC51cmkgPSBlbnRyeS51cmk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoZW50cnkuYnl0ZXJhbmdlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudE1hcC5ieXRlcmFuZ2UgPSBlbnRyeS5ieXRlcmFuZ2U7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgY3VycmVudE1hcC5rZXkgPSBrZXk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICdzdHJlYW0taW5mJygpIHtcbiAgICAgICAgICAgICAgdGhpcy5tYW5pZmVzdC5wbGF5bGlzdHMgPSB1cmlzO1xuICAgICAgICAgICAgICB0aGlzLm1hbmlmZXN0Lm1lZGlhR3JvdXBzID0gdGhpcy5tYW5pZmVzdC5tZWRpYUdyb3VwcyB8fCBkZWZhdWx0TWVkaWFHcm91cHM7XG5cbiAgICAgICAgICAgICAgaWYgKCFlbnRyeS5hdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCd3YXJuJywge1xuICAgICAgICAgICAgICAgICAgbWVzc2FnZTogJ2lnbm9yaW5nIGVtcHR5IHN0cmVhbS1pbmYgYXR0cmlidXRlcydcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoIWN1cnJlbnRVcmkuYXR0cmlidXRlcykge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRVcmkuYXR0cmlidXRlcyA9IHt9O1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgX2V4dGVuZHNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKGN1cnJlbnRVcmkuYXR0cmlidXRlcywgZW50cnkuYXR0cmlidXRlcyk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBtZWRpYSgpIHtcbiAgICAgICAgICAgICAgdGhpcy5tYW5pZmVzdC5tZWRpYUdyb3VwcyA9IHRoaXMubWFuaWZlc3QubWVkaWFHcm91cHMgfHwgZGVmYXVsdE1lZGlhR3JvdXBzO1xuXG4gICAgICAgICAgICAgIGlmICghKGVudHJ5LmF0dHJpYnV0ZXMgJiYgZW50cnkuYXR0cmlidXRlcy5UWVBFICYmIGVudHJ5LmF0dHJpYnV0ZXNbJ0dST1VQLUlEJ10gJiYgZW50cnkuYXR0cmlidXRlcy5OQU1FKSkge1xuICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlcignd2FybicsIHtcbiAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdpZ25vcmluZyBpbmNvbXBsZXRlIG9yIG1pc3NpbmcgbWVkaWEgZ3JvdXAnXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9IC8vIGZpbmQgdGhlIG1lZGlhIGdyb3VwLCBjcmVhdGluZyBkZWZhdWx0cyBhcyBuZWNlc3NhcnlcblxuXG4gICAgICAgICAgICAgIGNvbnN0IG1lZGlhR3JvdXBUeXBlID0gdGhpcy5tYW5pZmVzdC5tZWRpYUdyb3Vwc1tlbnRyeS5hdHRyaWJ1dGVzLlRZUEVdO1xuICAgICAgICAgICAgICBtZWRpYUdyb3VwVHlwZVtlbnRyeS5hdHRyaWJ1dGVzWydHUk9VUC1JRCddXSA9IG1lZGlhR3JvdXBUeXBlW2VudHJ5LmF0dHJpYnV0ZXNbJ0dST1VQLUlEJ11dIHx8IHt9O1xuICAgICAgICAgICAgICBtZWRpYUdyb3VwID0gbWVkaWFHcm91cFR5cGVbZW50cnkuYXR0cmlidXRlc1snR1JPVVAtSUQnXV07IC8vIGNvbGxlY3QgdGhlIHJlbmRpdGlvbiBtZXRhZGF0YVxuXG4gICAgICAgICAgICAgIHJlbmRpdGlvbiA9IHtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiAveWVzL2kudGVzdChlbnRyeS5hdHRyaWJ1dGVzLkRFRkFVTFQpXG4gICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgaWYgKHJlbmRpdGlvbi5kZWZhdWx0KSB7XG4gICAgICAgICAgICAgICAgcmVuZGl0aW9uLmF1dG9zZWxlY3QgPSB0cnVlO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlbmRpdGlvbi5hdXRvc2VsZWN0ID0gL3llcy9pLnRlc3QoZW50cnkuYXR0cmlidXRlcy5BVVRPU0VMRUNUKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChlbnRyeS5hdHRyaWJ1dGVzLkxBTkdVQUdFKSB7XG4gICAgICAgICAgICAgICAgcmVuZGl0aW9uLmxhbmd1YWdlID0gZW50cnkuYXR0cmlidXRlcy5MQU5HVUFHRTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChlbnRyeS5hdHRyaWJ1dGVzLlVSSSkge1xuICAgICAgICAgICAgICAgIHJlbmRpdGlvbi51cmkgPSBlbnRyeS5hdHRyaWJ1dGVzLlVSSTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChlbnRyeS5hdHRyaWJ1dGVzWydJTlNUUkVBTS1JRCddKSB7XG4gICAgICAgICAgICAgICAgcmVuZGl0aW9uLmluc3RyZWFtSWQgPSBlbnRyeS5hdHRyaWJ1dGVzWydJTlNUUkVBTS1JRCddO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKGVudHJ5LmF0dHJpYnV0ZXMuQ0hBUkFDVEVSSVNUSUNTKSB7XG4gICAgICAgICAgICAgICAgcmVuZGl0aW9uLmNoYXJhY3RlcmlzdGljcyA9IGVudHJ5LmF0dHJpYnV0ZXMuQ0hBUkFDVEVSSVNUSUNTO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKGVudHJ5LmF0dHJpYnV0ZXMuRk9SQ0VEKSB7XG4gICAgICAgICAgICAgICAgcmVuZGl0aW9uLmZvcmNlZCA9IC95ZXMvaS50ZXN0KGVudHJ5LmF0dHJpYnV0ZXMuRk9SQ0VEKTtcbiAgICAgICAgICAgICAgfSAvLyBpbnNlcnQgdGhlIG5ldyByZW5kaXRpb25cblxuXG4gICAgICAgICAgICAgIG1lZGlhR3JvdXBbZW50cnkuYXR0cmlidXRlcy5OQU1FXSA9IHJlbmRpdGlvbjtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGRpc2NvbnRpbnVpdHkoKSB7XG4gICAgICAgICAgICAgIGN1cnJlbnRUaW1lbGluZSArPSAxO1xuICAgICAgICAgICAgICBjdXJyZW50VXJpLmRpc2NvbnRpbnVpdHkgPSB0cnVlO1xuICAgICAgICAgICAgICB0aGlzLm1hbmlmZXN0LmRpc2NvbnRpbnVpdHlTdGFydHMucHVzaCh1cmlzLmxlbmd0aCk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAncHJvZ3JhbS1kYXRlLXRpbWUnKCkge1xuICAgICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMubWFuaWZlc3QuZGF0ZVRpbWVTdHJpbmcgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgLy8gUFJPR1JBTS1EQVRFLVRJTUUgaXMgYSBtZWRpYS1zZWdtZW50IHRhZywgYnV0IGZvciBiYWNrd2FyZHNcbiAgICAgICAgICAgICAgICAvLyBjb21wYXRpYmlsaXR5LCB3ZSBhZGQgdGhlIGZpcnN0IG9jY3VyZW5jZSBvZiB0aGUgUFJPR1JBTS1EQVRFLVRJTUUgdGFnXG4gICAgICAgICAgICAgICAgLy8gdG8gdGhlIG1hbmlmZXN0IG9iamVjdFxuICAgICAgICAgICAgICAgIC8vIFRPRE86IENvbnNpZGVyIHJlbW92aW5nIHRoaXMgaW4gZnV0dXJlIG1ham9yIHZlcnNpb25cbiAgICAgICAgICAgICAgICB0aGlzLm1hbmlmZXN0LmRhdGVUaW1lU3RyaW5nID0gZW50cnkuZGF0ZVRpbWVTdHJpbmc7XG4gICAgICAgICAgICAgICAgdGhpcy5tYW5pZmVzdC5kYXRlVGltZU9iamVjdCA9IGVudHJ5LmRhdGVUaW1lT2JqZWN0O1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgY3VycmVudFVyaS5kYXRlVGltZVN0cmluZyA9IGVudHJ5LmRhdGVUaW1lU3RyaW5nO1xuICAgICAgICAgICAgICBjdXJyZW50VXJpLmRhdGVUaW1lT2JqZWN0ID0gZW50cnkuZGF0ZVRpbWVPYmplY3Q7XG4gICAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAgICBsYXN0UHJvZ3JhbURhdGVUaW1lXG4gICAgICAgICAgICAgIH0gPSB0aGlzO1xuICAgICAgICAgICAgICB0aGlzLmxhc3RQcm9ncmFtRGF0ZVRpbWUgPSBuZXcgRGF0ZShlbnRyeS5kYXRlVGltZVN0cmluZykuZ2V0VGltZSgpOyAvLyBXZSBzaG91bGQgZXh0cmFwb2xhdGUgUHJvZ3JhbSBEYXRlIFRpbWUgYmFja3dhcmQgb25seSBkdXJpbmcgZmlyc3QgcHJvZ3JhbSBkYXRlIHRpbWUgb2NjdXJyZW5jZS5cbiAgICAgICAgICAgICAgLy8gT25jZSB3ZSBoYXZlIGF0IGxlYXN0IG9uZSBwcm9ncmFtIGRhdGUgdGltZSBwb2ludCwgd2UgY2FuIGFsd2F5cyBleHRyYXBvbGF0ZSBpdCBmb3J3YXJkIHVzaW5nIGxhc3RQcm9ncmFtRGF0ZVRpbWUgcmVmZXJlbmNlLlxuXG4gICAgICAgICAgICAgIGlmIChsYXN0UHJvZ3JhbURhdGVUaW1lID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgLy8gRXh0cmFwb2xhdGUgUHJvZ3JhbSBEYXRlIFRpbWUgYmFja3dhcmRcbiAgICAgICAgICAgICAgICAvLyBTaW5jZSBpdCBpcyBmaXJzdCBwcm9ncmFtIGRhdGUgdGltZSBvY2N1cnJlbmNlIHdlJ3JlIGFzc3VtaW5nIHRoYXRcbiAgICAgICAgICAgICAgICAvLyBhbGwgdGhpcy5tYW5pZmVzdC5zZWdtZW50cyBoYXZlIG5vIHByb2dyYW0gZGF0ZSB0aW1lIGluZm9cbiAgICAgICAgICAgICAgICB0aGlzLm1hbmlmZXN0LnNlZ21lbnRzLnJlZHVjZVJpZ2h0KChwcm9ncmFtRGF0ZVRpbWUsIHNlZ21lbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgIHNlZ21lbnQucHJvZ3JhbURhdGVUaW1lID0gcHJvZ3JhbURhdGVUaW1lIC0gc2VnbWVudC5kdXJhdGlvbiAqIDEwMDA7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gc2VnbWVudC5wcm9ncmFtRGF0ZVRpbWU7XG4gICAgICAgICAgICAgICAgfSwgdGhpcy5sYXN0UHJvZ3JhbURhdGVUaW1lKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgdGFyZ2V0ZHVyYXRpb24oKSB7XG4gICAgICAgICAgICAgIGlmICghaXNGaW5pdGUoZW50cnkuZHVyYXRpb24pIHx8IGVudHJ5LmR1cmF0aW9uIDwgMCkge1xuICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlcignd2FybicsIHtcbiAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdpZ25vcmluZyBpbnZhbGlkIHRhcmdldCBkdXJhdGlvbjogJyArIGVudHJ5LmR1cmF0aW9uXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdGhpcy5tYW5pZmVzdC50YXJnZXREdXJhdGlvbiA9IGVudHJ5LmR1cmF0aW9uO1xuICAgICAgICAgICAgICBzZXRIb2xkQmFjay5jYWxsKHRoaXMsIHRoaXMubWFuaWZlc3QpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgc3RhcnQoKSB7XG4gICAgICAgICAgICAgIGlmICghZW50cnkuYXR0cmlidXRlcyB8fCBpc05hTihlbnRyeS5hdHRyaWJ1dGVzWydUSU1FLU9GRlNFVCddKSkge1xuICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlcignd2FybicsIHtcbiAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdpZ25vcmluZyBzdGFydCBkZWNsYXJhdGlvbiB3aXRob3V0IGFwcHJvcHJpYXRlIGF0dHJpYnV0ZSBsaXN0J1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHRoaXMubWFuaWZlc3Quc3RhcnQgPSB7XG4gICAgICAgICAgICAgICAgdGltZU9mZnNldDogZW50cnkuYXR0cmlidXRlc1snVElNRS1PRkZTRVQnXSxcbiAgICAgICAgICAgICAgICBwcmVjaXNlOiBlbnRyeS5hdHRyaWJ1dGVzLlBSRUNJU0VcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICdjdWUtb3V0JygpIHtcbiAgICAgICAgICAgICAgY3VycmVudFVyaS5jdWVPdXQgPSBlbnRyeS5kYXRhO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgJ2N1ZS1vdXQtY29udCcoKSB7XG4gICAgICAgICAgICAgIGN1cnJlbnRVcmkuY3VlT3V0Q29udCA9IGVudHJ5LmRhdGE7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAnY3VlLWluJygpIHtcbiAgICAgICAgICAgICAgY3VycmVudFVyaS5jdWVJbiA9IGVudHJ5LmRhdGE7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAnc2tpcCcoKSB7XG4gICAgICAgICAgICAgIHRoaXMubWFuaWZlc3Quc2tpcCA9IGNhbWVsQ2FzZUtleXMoZW50cnkuYXR0cmlidXRlcyk7XG4gICAgICAgICAgICAgIHRoaXMud2Fybk9uTWlzc2luZ0F0dHJpYnV0ZXNfKCcjRVhULVgtU0tJUCcsIGVudHJ5LmF0dHJpYnV0ZXMsIFsnU0tJUFBFRC1TRUdNRU5UUyddKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICdwYXJ0JygpIHtcbiAgICAgICAgICAgICAgaGFzUGFydHMgPSB0cnVlOyAvLyBwYXJ0cyBhcmUgYWx3YXlzIHNwZWNpZmVkIGJlZm9yZSBhIHNlZ21lbnRcblxuICAgICAgICAgICAgICBjb25zdCBzZWdtZW50SW5kZXggPSB0aGlzLm1hbmlmZXN0LnNlZ21lbnRzLmxlbmd0aDtcbiAgICAgICAgICAgICAgY29uc3QgcGFydCA9IGNhbWVsQ2FzZUtleXMoZW50cnkuYXR0cmlidXRlcyk7XG4gICAgICAgICAgICAgIGN1cnJlbnRVcmkucGFydHMgPSBjdXJyZW50VXJpLnBhcnRzIHx8IFtdO1xuICAgICAgICAgICAgICBjdXJyZW50VXJpLnBhcnRzLnB1c2gocGFydCk7XG5cbiAgICAgICAgICAgICAgaWYgKHBhcnQuYnl0ZXJhbmdlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFwYXJ0LmJ5dGVyYW5nZS5oYXNPd25Qcm9wZXJ0eSgnb2Zmc2V0JykpIHtcbiAgICAgICAgICAgICAgICAgIHBhcnQuYnl0ZXJhbmdlLm9mZnNldCA9IGxhc3RQYXJ0Qnl0ZXJhbmdlRW5kO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGxhc3RQYXJ0Qnl0ZXJhbmdlRW5kID0gcGFydC5ieXRlcmFuZ2Uub2Zmc2V0ICsgcGFydC5ieXRlcmFuZ2UubGVuZ3RoO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgY29uc3QgcGFydEluZGV4ID0gY3VycmVudFVyaS5wYXJ0cy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICB0aGlzLndhcm5Pbk1pc3NpbmdBdHRyaWJ1dGVzXyhgI0VYVC1YLVBBUlQgIyR7cGFydEluZGV4fSBmb3Igc2VnbWVudCAjJHtzZWdtZW50SW5kZXh9YCwgZW50cnkuYXR0cmlidXRlcywgWydVUkknLCAnRFVSQVRJT04nXSk7XG5cbiAgICAgICAgICAgICAgaWYgKHRoaXMubWFuaWZlc3QucmVuZGl0aW9uUmVwb3J0cykge1xuICAgICAgICAgICAgICAgIHRoaXMubWFuaWZlc3QucmVuZGl0aW9uUmVwb3J0cy5mb3JFYWNoKChyLCBpKSA9PiB7XG4gICAgICAgICAgICAgICAgICBpZiAoIXIuaGFzT3duUHJvcGVydHkoJ2xhc3RQYXJ0JykpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCd3YXJuJywge1xuICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGAjRVhULVgtUkVORElUSU9OLVJFUE9SVCAjJHtpfSBsYWNrcyByZXF1aXJlZCBhdHRyaWJ1dGUocyk6IExBU1QtUEFSVGBcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICdzZXJ2ZXItY29udHJvbCcoKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGF0dHJzID0gdGhpcy5tYW5pZmVzdC5zZXJ2ZXJDb250cm9sID0gY2FtZWxDYXNlS2V5cyhlbnRyeS5hdHRyaWJ1dGVzKTtcblxuICAgICAgICAgICAgICBpZiAoIWF0dHJzLmhhc093blByb3BlcnR5KCdjYW5CbG9ja1JlbG9hZCcpKSB7XG4gICAgICAgICAgICAgICAgYXR0cnMuY2FuQmxvY2tSZWxvYWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXIoJ2luZm8nLCB7XG4gICAgICAgICAgICAgICAgICBtZXNzYWdlOiAnI0VYVC1YLVNFUlZFUi1DT05UUk9MIGRlZmF1bHRpbmcgQ0FOLUJMT0NLLVJFTE9BRCB0byBmYWxzZSdcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHNldEhvbGRCYWNrLmNhbGwodGhpcywgdGhpcy5tYW5pZmVzdCk7XG5cbiAgICAgICAgICAgICAgaWYgKGF0dHJzLmNhblNraXBEYXRlcmFuZ2VzICYmICFhdHRycy5oYXNPd25Qcm9wZXJ0eSgnY2FuU2tpcFVudGlsJykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXIoJ3dhcm4nLCB7XG4gICAgICAgICAgICAgICAgICBtZXNzYWdlOiAnI0VYVC1YLVNFUlZFUi1DT05UUk9MIGxhY2tzIHJlcXVpcmVkIGF0dHJpYnV0ZSBDQU4tU0tJUC1VTlRJTCB3aGljaCBpcyByZXF1aXJlZCB3aGVuIENBTi1TS0lQLURBVEVSQU5HRVMgaXMgc2V0J1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAncHJlbG9hZC1oaW50JygpIHtcbiAgICAgICAgICAgICAgLy8gcGFydHMgYXJlIGFsd2F5cyBzcGVjaWZlZCBiZWZvcmUgYSBzZWdtZW50XG4gICAgICAgICAgICAgIGNvbnN0IHNlZ21lbnRJbmRleCA9IHRoaXMubWFuaWZlc3Quc2VnbWVudHMubGVuZ3RoO1xuICAgICAgICAgICAgICBjb25zdCBoaW50ID0gY2FtZWxDYXNlS2V5cyhlbnRyeS5hdHRyaWJ1dGVzKTtcbiAgICAgICAgICAgICAgY29uc3QgaXNQYXJ0ID0gaGludC50eXBlICYmIGhpbnQudHlwZSA9PT0gJ1BBUlQnO1xuICAgICAgICAgICAgICBjdXJyZW50VXJpLnByZWxvYWRIaW50cyA9IGN1cnJlbnRVcmkucHJlbG9hZEhpbnRzIHx8IFtdO1xuICAgICAgICAgICAgICBjdXJyZW50VXJpLnByZWxvYWRIaW50cy5wdXNoKGhpbnQpO1xuXG4gICAgICAgICAgICAgIGlmIChoaW50LmJ5dGVyYW5nZSkge1xuICAgICAgICAgICAgICAgIGlmICghaGludC5ieXRlcmFuZ2UuaGFzT3duUHJvcGVydHkoJ29mZnNldCcpKSB7XG4gICAgICAgICAgICAgICAgICAvLyB1c2UgbGFzdCBwYXJ0IGJ5dGVyYW5nZSBlbmQgb3IgemVybyBpZiBub3QgYSBwYXJ0LlxuICAgICAgICAgICAgICAgICAgaGludC5ieXRlcmFuZ2Uub2Zmc2V0ID0gaXNQYXJ0ID8gbGFzdFBhcnRCeXRlcmFuZ2VFbmQgOiAwO1xuXG4gICAgICAgICAgICAgICAgICBpZiAoaXNQYXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RQYXJ0Qnl0ZXJhbmdlRW5kID0gaGludC5ieXRlcmFuZ2Uub2Zmc2V0ICsgaGludC5ieXRlcmFuZ2UubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gY3VycmVudFVyaS5wcmVsb2FkSGludHMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgdGhpcy53YXJuT25NaXNzaW5nQXR0cmlidXRlc18oYCNFWFQtWC1QUkVMT0FELUhJTlQgIyR7aW5kZXh9IGZvciBzZWdtZW50ICMke3NlZ21lbnRJbmRleH1gLCBlbnRyeS5hdHRyaWJ1dGVzLCBbJ1RZUEUnLCAnVVJJJ10pO1xuXG4gICAgICAgICAgICAgIGlmICghaGludC50eXBlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9IC8vIHNlYXJjaCB0aHJvdWdoIGFsbCBwcmVsb2FkIGhpbnRzIGV4Y2VwdCBmb3IgdGhlIGN1cnJlbnQgb25lIGZvclxuICAgICAgICAgICAgICAvLyBhIGR1cGxpY2F0ZSB0eXBlLlxuXG5cbiAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjdXJyZW50VXJpLnByZWxvYWRIaW50cy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvdGhlckhpbnQgPSBjdXJyZW50VXJpLnByZWxvYWRIaW50c1tpXTtcblxuICAgICAgICAgICAgICAgIGlmICghb3RoZXJIaW50LnR5cGUpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChvdGhlckhpbnQudHlwZSA9PT0gaGludC50eXBlKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXIoJ3dhcm4nLCB7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGAjRVhULVgtUFJFTE9BRC1ISU5UICMke2luZGV4fSBmb3Igc2VnbWVudCAjJHtzZWdtZW50SW5kZXh9IGhhcyB0aGUgc2FtZSBUWVBFICR7aGludC50eXBlfSBhcyBwcmVsb2FkIGhpbnQgIyR7aX1gXG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICdyZW5kaXRpb24tcmVwb3J0JygpIHtcbiAgICAgICAgICAgICAgY29uc3QgcmVwb3J0ID0gY2FtZWxDYXNlS2V5cyhlbnRyeS5hdHRyaWJ1dGVzKTtcbiAgICAgICAgICAgICAgdGhpcy5tYW5pZmVzdC5yZW5kaXRpb25SZXBvcnRzID0gdGhpcy5tYW5pZmVzdC5yZW5kaXRpb25SZXBvcnRzIHx8IFtdO1xuICAgICAgICAgICAgICB0aGlzLm1hbmlmZXN0LnJlbmRpdGlvblJlcG9ydHMucHVzaChyZXBvcnQpO1xuICAgICAgICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMubWFuaWZlc3QucmVuZGl0aW9uUmVwb3J0cy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICBjb25zdCByZXF1aXJlZCA9IFsnTEFTVC1NU04nLCAnVVJJJ107XG5cbiAgICAgICAgICAgICAgaWYgKGhhc1BhcnRzKSB7XG4gICAgICAgICAgICAgICAgcmVxdWlyZWQucHVzaCgnTEFTVC1QQVJUJyk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB0aGlzLndhcm5Pbk1pc3NpbmdBdHRyaWJ1dGVzXyhgI0VYVC1YLVJFTkRJVElPTi1SRVBPUlQgIyR7aW5kZXh9YCwgZW50cnkuYXR0cmlidXRlcywgcmVxdWlyZWQpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgJ3BhcnQtaW5mJygpIHtcbiAgICAgICAgICAgICAgdGhpcy5tYW5pZmVzdC5wYXJ0SW5mID0gY2FtZWxDYXNlS2V5cyhlbnRyeS5hdHRyaWJ1dGVzKTtcbiAgICAgICAgICAgICAgdGhpcy53YXJuT25NaXNzaW5nQXR0cmlidXRlc18oJyNFWFQtWC1QQVJULUlORicsIGVudHJ5LmF0dHJpYnV0ZXMsIFsnUEFSVC1UQVJHRVQnXSk7XG5cbiAgICAgICAgICAgICAgaWYgKHRoaXMubWFuaWZlc3QucGFydEluZi5wYXJ0VGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tYW5pZmVzdC5wYXJ0VGFyZ2V0RHVyYXRpb24gPSB0aGlzLm1hbmlmZXN0LnBhcnRJbmYucGFydFRhcmdldDtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHNldEhvbGRCYWNrLmNhbGwodGhpcywgdGhpcy5tYW5pZmVzdCk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAnZGF0ZXJhbmdlJygpIHtcbiAgICAgICAgICAgICAgdGhpcy5tYW5pZmVzdC5kYXRlUmFuZ2VzLnB1c2goY2FtZWxDYXNlS2V5cyhlbnRyeS5hdHRyaWJ1dGVzKSk7XG4gICAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5tYW5pZmVzdC5kYXRlUmFuZ2VzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgIHRoaXMud2Fybk9uTWlzc2luZ0F0dHJpYnV0ZXNfKGAjRVhULVgtREFURVJBTkdFICMke2luZGV4fWAsIGVudHJ5LmF0dHJpYnV0ZXMsIFsnSUQnLCAnU1RBUlQtREFURSddKTtcbiAgICAgICAgICAgICAgY29uc3QgZGF0ZVJhbmdlID0gdGhpcy5tYW5pZmVzdC5kYXRlUmFuZ2VzW2luZGV4XTtcblxuICAgICAgICAgICAgICBpZiAoZGF0ZVJhbmdlLmVuZERhdGUgJiYgZGF0ZVJhbmdlLnN0YXJ0RGF0ZSAmJiBuZXcgRGF0ZShkYXRlUmFuZ2UuZW5kRGF0ZSkgPCBuZXcgRGF0ZShkYXRlUmFuZ2Uuc3RhcnREYXRlKSkge1xuICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlcignd2FybicsIHtcbiAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdFWFQtWC1EQVRFUkFOR0UgRU5ELURBVEUgbXVzdCBiZSBlcXVhbCB0byBvciBsYXRlciB0aGFuIHRoZSB2YWx1ZSBvZiB0aGUgU1RBUlQtREFURSdcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChkYXRlUmFuZ2UuZHVyYXRpb24gJiYgZGF0ZVJhbmdlLmR1cmF0aW9uIDwgMCkge1xuICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlcignd2FybicsIHtcbiAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdFWFQtWC1EQVRFUkFOR0UgRFVSQVRJT04gbXVzdCBub3QgYmUgbmVnYXRpdmUnXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoZGF0ZVJhbmdlLnBsYW5uZWREdXJhdGlvbiAmJiBkYXRlUmFuZ2UucGxhbm5lZER1cmF0aW9uIDwgMCkge1xuICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlcignd2FybicsIHtcbiAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdFWFQtWC1EQVRFUkFOR0UgUExBTk5FRC1EVVJBVElPTiBtdXN0IG5vdCBiZSBuZWdhdGl2ZSdcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGNvbnN0IGVuZE9uTmV4dFllcyA9ICEhZGF0ZVJhbmdlLmVuZE9uTmV4dDtcblxuICAgICAgICAgICAgICBpZiAoZW5kT25OZXh0WWVzICYmICFkYXRlUmFuZ2UuY2xhc3MpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXIoJ3dhcm4nLCB7XG4gICAgICAgICAgICAgICAgICBtZXNzYWdlOiAnRVhULVgtREFURVJBTkdFIHdpdGggYW4gRU5ELU9OLU5FWFQ9WUVTIGF0dHJpYnV0ZSBtdXN0IGhhdmUgYSBDTEFTUyBhdHRyaWJ1dGUnXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoZW5kT25OZXh0WWVzICYmIChkYXRlUmFuZ2UuZHVyYXRpb24gfHwgZGF0ZVJhbmdlLmVuZERhdGUpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCd3YXJuJywge1xuICAgICAgICAgICAgICAgICAgbWVzc2FnZTogJ0VYVC1YLURBVEVSQU5HRSB3aXRoIGFuIEVORC1PTi1ORVhUPVlFUyBhdHRyaWJ1dGUgbXVzdCBub3QgY29udGFpbiBEVVJBVElPTiBvciBFTkQtREFURSBhdHRyaWJ1dGVzJ1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKGRhdGVSYW5nZS5kdXJhdGlvbiAmJiBkYXRlUmFuZ2UuZW5kRGF0ZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXJ0RGF0ZSA9IGRhdGVSYW5nZS5zdGFydERhdGU7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3RGF0ZUluU2Vjb25kcyA9IHN0YXJ0RGF0ZS5nZXRUaW1lKCkgKyBkYXRlUmFuZ2UuZHVyYXRpb24gKiAxMDAwO1xuICAgICAgICAgICAgICAgIHRoaXMubWFuaWZlc3QuZGF0ZVJhbmdlc1tpbmRleF0uZW5kRGF0ZSA9IG5ldyBEYXRlKG5ld0RhdGVJblNlY29uZHMpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKCFkYXRlUmFuZ2VUYWdzW2RhdGVSYW5nZS5pZF0pIHtcbiAgICAgICAgICAgICAgICBkYXRlUmFuZ2VUYWdzW2RhdGVSYW5nZS5pZF0gPSBkYXRlUmFuZ2U7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBhdHRyaWJ1dGUgaW4gZGF0ZVJhbmdlVGFnc1tkYXRlUmFuZ2UuaWRdKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoISFkYXRlUmFuZ2VbYXR0cmlidXRlXSAmJiBKU09OLnN0cmluZ2lmeShkYXRlUmFuZ2VUYWdzW2RhdGVSYW5nZS5pZF1bYXR0cmlidXRlXSkgIT09IEpTT04uc3RyaW5naWZ5KGRhdGVSYW5nZVthdHRyaWJ1dGVdKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXIoJ3dhcm4nLCB7XG4gICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogJ0VYVC1YLURBVEVSQU5HRSB0YWdzIHdpdGggdGhlIHNhbWUgSUQgaW4gYSBwbGF5bGlzdCBtdXN0IGhhdmUgdGhlIHNhbWUgYXR0cmlidXRlcyB2YWx1ZXMnXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IC8vIGlmIHRhZ3Mgd2l0aCB0aGUgc2FtZSBJRCBkbyBub3QgaGF2ZSBjb25mbGljdGluZyBhdHRyaWJ1dGVzLCBtZXJnZSB0aGVtXG5cblxuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGVSYW5nZVdpdGhTYW1lSWQgPSB0aGlzLm1hbmlmZXN0LmRhdGVSYW5nZXMuZmluZEluZGV4KGRhdGVSYW5nZVRvRmluZCA9PiBkYXRlUmFuZ2VUb0ZpbmQuaWQgPT09IGRhdGVSYW5nZS5pZCk7XG4gICAgICAgICAgICAgICAgdGhpcy5tYW5pZmVzdC5kYXRlUmFuZ2VzW2RhdGVSYW5nZVdpdGhTYW1lSWRdID0gX2V4dGVuZHNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKHRoaXMubWFuaWZlc3QuZGF0ZVJhbmdlc1tkYXRlUmFuZ2VXaXRoU2FtZUlkXSwgZGF0ZVJhbmdlKTtcbiAgICAgICAgICAgICAgICBkYXRlUmFuZ2VUYWdzW2RhdGVSYW5nZS5pZF0gPSBfZXh0ZW5kc19fZGVmYXVsdFtcImRlZmF1bHRcIl0oZGF0ZVJhbmdlVGFnc1tkYXRlUmFuZ2UuaWRdLCBkYXRlUmFuZ2UpOyAvLyBhZnRlciBtZXJnaW5nLCBkZWxldGUgdGhlIGR1cGxpY2F0ZSBkYXRlUmFuZ2UgdGhhdCB3YXMgYWRkZWQgbGFzdFxuXG4gICAgICAgICAgICAgICAgdGhpcy5tYW5pZmVzdC5kYXRlUmFuZ2VzLnBvcCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAnaW5kZXBlbmRlbnQtc2VnbWVudHMnKCkge1xuICAgICAgICAgICAgICB0aGlzLm1hbmlmZXN0LmluZGVwZW5kZW50U2VnbWVudHMgPSB0cnVlO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgJ2ktZnJhbWVzLW9ubHknKCkge1xuICAgICAgICAgICAgICB0aGlzLm1hbmlmZXN0LmlGcmFtZXNPbmx5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgdGhpcy5yZXF1aXJlZENvbXBhdGliaWxpdHl2ZXJzaW9uKHRoaXMubWFuaWZlc3QudmVyc2lvbiwgNCk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAnY29udGVudC1zdGVlcmluZycoKSB7XG4gICAgICAgICAgICAgIHRoaXMubWFuaWZlc3QuY29udGVudFN0ZWVyaW5nID0gY2FtZWxDYXNlS2V5cyhlbnRyeS5hdHRyaWJ1dGVzKTtcbiAgICAgICAgICAgICAgdGhpcy53YXJuT25NaXNzaW5nQXR0cmlidXRlc18oJyNFWFQtWC1DT05URU5ULVNURUVSSU5HJywgZW50cnkuYXR0cmlidXRlcywgWydTRVJWRVItVVJJJ10pO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLyoqIEB0aGlzIHtQYXJzZXJ9ICovXG4gICAgICAgICAgICBkZWZpbmUoKSB7XG4gICAgICAgICAgICAgIHRoaXMubWFuaWZlc3QuZGVmaW5pdGlvbnMgPSB0aGlzLm1hbmlmZXN0LmRlZmluaXRpb25zIHx8IHt9O1xuXG4gICAgICAgICAgICAgIGNvbnN0IGFkZERlZiA9IChuLCB2KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKG4gaW4gdGhpcy5tYW5pZmVzdC5kZWZpbml0aW9ucykge1xuICAgICAgICAgICAgICAgICAgLy8gQW4gRVhULVgtREVGSU5FIHRhZyBNVVNUIE5PVCBzcGVjaWZ5IHRoZSBzYW1lIFZhcmlhYmxlIE5hbWUgYXMgYW55IG90aGVyXG4gICAgICAgICAgICAgICAgICAvLyBFWFQtWC1ERUZJTkUgdGFnIGluIHRoZSBzYW1lIFBsYXlsaXN0LiAgUGFyc2VycyB0aGF0IGVuY291bnRlciBkdXBsaWNhdGVcbiAgICAgICAgICAgICAgICAgIC8vIFZhcmlhYmxlIE5hbWUgZGVjbGFyYXRpb25zIE1VU1QgZmFpbCB0byBwYXJzZSB0aGUgUGxheWxpc3QuXG4gICAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXIoJ2Vycm9yJywge1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBgRVhULVgtREVGSU5FOiBEdXBsaWNhdGUgbmFtZSAke259YFxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5tYW5pZmVzdC5kZWZpbml0aW9uc1tuXSA9IHY7XG4gICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgaWYgKCdRVUVSWVBBUkFNJyBpbiBlbnRyeS5hdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKCdOQU1FJyBpbiBlbnRyeS5hdHRyaWJ1dGVzIHx8ICdJTVBPUlQnIGluIGVudHJ5LmF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgICAgICAgIC8vIEFuIEVYVC1YLURFRklORSB0YWcgTVVTVCBjb250YWluIGVpdGhlciBhIE5BTUUsIGFuIElNUE9SVCwgb3IgYVxuICAgICAgICAgICAgICAgICAgLy8gUVVFUllQQVJBTSBhdHRyaWJ1dGUsIGJ1dCBvbmx5IG9uZSBvZiB0aGUgdGhyZWUuICBPdGhlcndpc2UsIHRoZVxuICAgICAgICAgICAgICAgICAgLy8gY2xpZW50IE1VU1QgZmFpbCB0byBwYXJzZSB0aGUgUGxheWxpc3QuXG4gICAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXIoJ2Vycm9yJywge1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiAnRVhULVgtREVGSU5FOiBJbnZhbGlkIGF0dHJpYnV0ZXMnXG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb25zdCB2YWwgPSB0aGlzLnBhcmFtcy5nZXQoZW50cnkuYXR0cmlidXRlcy5RVUVSWVBBUkFNKTtcblxuICAgICAgICAgICAgICAgIGlmICghdmFsKSB7XG4gICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgUVVFUllQQVJBTSBhdHRyaWJ1dGUgdmFsdWUgZG9lcyBub3QgbWF0Y2ggYW55IHF1ZXJ5IHBhcmFtZXRlciBpblxuICAgICAgICAgICAgICAgICAgLy8gdGhlIFVSSSBvciB0aGUgbWF0Y2hpbmcgcGFyYW1ldGVyIGhhcyBubyBhc3NvY2lhdGVkIHZhbHVlLCB0aGUgcGFyc2VyXG4gICAgICAgICAgICAgICAgICAvLyBNVVNUIGZhaWwgdG8gcGFyc2UgdGhlIFBsYXlsaXN0LiAgSWYgbW9yZSB0aGFuIG9uZSBwYXJhbWV0ZXIgbWF0Y2hlcyxcbiAgICAgICAgICAgICAgICAgIC8vIGFueSBvZiB0aGUgYXNzb2NpYXRlZCB2YWx1ZXMgTUFZIGJlIHVzZWQuXG4gICAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXIoJ2Vycm9yJywge1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBgRVhULVgtREVGSU5FOiBObyBxdWVyeSBwYXJhbSAke2VudHJ5LmF0dHJpYnV0ZXMuUVVFUllQQVJBTX1gXG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBhZGREZWYoZW50cnkuYXR0cmlidXRlcy5RVUVSWVBBUkFNLCBkZWNvZGVVUklDb21wb25lbnQodmFsKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKCdOQU1FJyBpbiBlbnRyeS5hdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKCdJTVBPUlQnIGluIGVudHJ5LmF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgICAgICAgIC8vIEFuIEVYVC1YLURFRklORSB0YWcgTVVTVCBjb250YWluIGVpdGhlciBhIE5BTUUsIGFuIElNUE9SVCwgb3IgYVxuICAgICAgICAgICAgICAgICAgLy8gUVVFUllQQVJBTSBhdHRyaWJ1dGUsIGJ1dCBvbmx5IG9uZSBvZiB0aGUgdGhyZWUuICBPdGhlcndpc2UsIHRoZVxuICAgICAgICAgICAgICAgICAgLy8gY2xpZW50IE1VU1QgZmFpbCB0byBwYXJzZSB0aGUgUGxheWxpc3QuXG4gICAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXIoJ2Vycm9yJywge1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiAnRVhULVgtREVGSU5FOiBJbnZhbGlkIGF0dHJpYnV0ZXMnXG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoISgnVkFMVUUnIGluIGVudHJ5LmF0dHJpYnV0ZXMpIHx8IHR5cGVvZiBlbnRyeS5hdHRyaWJ1dGVzLlZBTFVFICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgLy8gVGhpcyBhdHRyaWJ1dGUgaXMgUkVRVUlSRUQgaWYgdGhlIEVYVC1YLURFRklORSB0YWcgaGFzIGEgTkFNRSBhdHRyaWJ1dGUuXG4gICAgICAgICAgICAgICAgICAvLyBUaGUgcXVvdGVkLXN0cmluZyBNQVkgYmUgZW1wdHkuXG4gICAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXIoJ2Vycm9yJywge1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBgRVhULVgtREVGSU5FOiBObyB2YWx1ZSBmb3IgJHtlbnRyeS5hdHRyaWJ1dGVzLk5BTUV9YFxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYWRkRGVmKGVudHJ5LmF0dHJpYnV0ZXMuTkFNRSwgZW50cnkuYXR0cmlidXRlcy5WQUxVRSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKCdJTVBPUlQnIGluIGVudHJ5LmF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMubWFpbkRlZmluaXRpb25zW2VudHJ5LmF0dHJpYnV0ZXMuSU1QT1JUXSkge1xuICAgICAgICAgICAgICAgICAgLy8gQ292ZXJzIHR3byBjb25kaXRpb25zLCBhcyBtYWluRGVmaW5pdGlvbnMgd2lsbCBhbHdheXMgYmUgZW1wdHkgb24gbWFpblxuICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgIC8vIEVYVC1YLURFRklORSB0YWdzIGNvbnRhaW5pbmcgdGhlIElNUE9SVCBhdHRyaWJ1dGUgTVVTVCBOT1Qgb2NjdXIgaW5cbiAgICAgICAgICAgICAgICAgIC8vIE11bHRpdmFyaWFudCBQbGF5bGlzdHM7IHRoZXkgYXJlIG9ubHkgYWxsb3dlZCBpbiBNZWRpYSBQbGF5bGlzdHMuXG4gICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIElNUE9SVCBhdHRyaWJ1dGUgdmFsdWUgZG9lcyBub3QgbWF0Y2ggYW55IFZhcmlhYmxlIE5hbWUgaW4gdGhlXG4gICAgICAgICAgICAgICAgICAvLyBNdWx0aXZhcmlhbnQgUGxheWxpc3QsIG9yIGlmIHRoZSBNZWRpYSBQbGF5bGlzdCBsb2FkZWQgZnJvbSBhXG4gICAgICAgICAgICAgICAgICAvLyBNdWx0aXZhcmlhbnQgUGxheWxpc3QsIHRoZSBwYXJzZXIgTVVTVCBmYWlsIHRoZSBQbGF5bGlzdC5cbiAgICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlcignZXJyb3InLCB7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGBFWFQtWC1ERUZJTkU6IE5vIHZhbHVlICR7ZW50cnkuYXR0cmlidXRlcy5JTVBPUlR9IHRvIGltcG9ydCwgb3IgSU1QT1JUIHVzZWQgb24gbWFpbiBwbGF5bGlzdGBcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGFkZERlZihlbnRyeS5hdHRyaWJ1dGVzLklNUE9SVCwgdGhpcy5tYWluRGVmaW5pdGlvbnNbZW50cnkuYXR0cmlidXRlcy5JTVBPUlRdKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH0gLy8gQW4gRVhULVgtREVGSU5FIHRhZyBNVVNUIGNvbnRhaW4gZWl0aGVyIGEgTkFNRSwgYW4gSU1QT1JULCBvciBhIFFVRVJZUEFSQU1cbiAgICAgICAgICAgICAgLy8gYXR0cmlidXRlLCBidXQgb25seSBvbmUgb2YgdGhlIHRocmVlLiAgT3RoZXJ3aXNlLCB0aGUgY2xpZW50IE1VU1QgZmFpbCB0b1xuICAgICAgICAgICAgICAvLyBwYXJzZSB0aGUgUGxheWxpc3QuXG5cblxuICAgICAgICAgICAgICB0aGlzLnRyaWdnZXIoJ2Vycm9yJywge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdFWFQtWC1ERUZJTkU6IE5vIGF0dHJpYnV0ZSdcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAnaS1mcmFtZS1wbGF5bGlzdCcoKSB7XG4gICAgICAgICAgICAgIHRoaXMubWFuaWZlc3QuaUZyYW1lUGxheWxpc3RzLnB1c2goe1xuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IGVudHJ5LmF0dHJpYnV0ZXMsXG4gICAgICAgICAgICAgICAgdXJpOiBlbnRyeS51cmksXG4gICAgICAgICAgICAgICAgdGltZWxpbmU6IGN1cnJlbnRUaW1lbGluZVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgdGhpcy53YXJuT25NaXNzaW5nQXR0cmlidXRlc18oJyNFWFQtWC1JLUZSQU1FLVNUUkVBTS1JTkYnLCBlbnRyeS5hdHRyaWJ1dGVzLCBbJ0JBTkRXSURUSCcsICdVUkknXSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9KVtlbnRyeS50YWdUeXBlXSB8fCBub29wKS5jYWxsKHNlbGYpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHVyaSgpIHtcbiAgICAgICAgICBjdXJyZW50VXJpLnVyaSA9IGVudHJ5LnVyaTtcbiAgICAgICAgICB1cmlzLnB1c2goY3VycmVudFVyaSk7IC8vIGlmIG5vIGV4cGxpY2l0IGR1cmF0aW9uIHdhcyBkZWNsYXJlZCwgdXNlIHRoZSB0YXJnZXQgZHVyYXRpb25cblxuICAgICAgICAgIGlmICh0aGlzLm1hbmlmZXN0LnRhcmdldER1cmF0aW9uICYmICEoJ2R1cmF0aW9uJyBpbiBjdXJyZW50VXJpKSkge1xuICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCd3YXJuJywge1xuICAgICAgICAgICAgICBtZXNzYWdlOiAnZGVmYXVsdGluZyBzZWdtZW50IGR1cmF0aW9uIHRvIHRoZSB0YXJnZXQgZHVyYXRpb24nXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGN1cnJlbnRVcmkuZHVyYXRpb24gPSB0aGlzLm1hbmlmZXN0LnRhcmdldER1cmF0aW9uO1xuICAgICAgICAgIH0gLy8gYW5ub3RhdGUgd2l0aCBlbmNyeXB0aW9uIGluZm9ybWF0aW9uLCBpZiBuZWNlc3NhcnlcblxuXG4gICAgICAgICAgaWYgKGtleSkge1xuICAgICAgICAgICAgY3VycmVudFVyaS5rZXkgPSBrZXk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY3VycmVudFVyaS50aW1lbGluZSA9IGN1cnJlbnRUaW1lbGluZTsgLy8gYW5ub3RhdGUgd2l0aCBpbml0aWFsaXphdGlvbiBzZWdtZW50IGluZm9ybWF0aW9uLCBpZiBuZWNlc3NhcnlcblxuICAgICAgICAgIGlmIChjdXJyZW50TWFwKSB7XG4gICAgICAgICAgICBjdXJyZW50VXJpLm1hcCA9IGN1cnJlbnRNYXA7XG4gICAgICAgICAgfSAvLyByZXNldCB0aGUgbGFzdCBieXRlcmFuZ2UgZW5kIGFzIGl0IG5lZWRzIHRvIGJlIDAgYmV0d2VlbiBwYXJ0c1xuXG5cbiAgICAgICAgICBsYXN0UGFydEJ5dGVyYW5nZUVuZCA9IDA7IC8vIE9uY2Ugd2UgaGF2ZSBhdCBsZWFzdCBvbmUgcHJvZ3JhbSBkYXRlIHRpbWUgd2UgY2FuIGFsd2F5cyBleHRyYXBvbGF0ZSBpdCBmb3J3YXJkXG5cbiAgICAgICAgICBpZiAodGhpcy5sYXN0UHJvZ3JhbURhdGVUaW1lICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjdXJyZW50VXJpLnByb2dyYW1EYXRlVGltZSA9IHRoaXMubGFzdFByb2dyYW1EYXRlVGltZTtcbiAgICAgICAgICAgIHRoaXMubGFzdFByb2dyYW1EYXRlVGltZSArPSBjdXJyZW50VXJpLmR1cmF0aW9uICogMTAwMDtcbiAgICAgICAgICB9IC8vIHByZXBhcmUgZm9yIHRoZSBuZXh0IFVSSVxuXG5cbiAgICAgICAgICBjdXJyZW50VXJpID0ge307XG4gICAgICAgIH0sXG5cbiAgICAgICAgY29tbWVudCgpIHsvLyBjb21tZW50cyBhcmUgbm90IGltcG9ydGFudCBmb3IgcGxheWJhY2tcbiAgICAgICAgfSxcblxuICAgICAgICBjdXN0b20oKSB7XG4gICAgICAgICAgLy8gaWYgdGhpcyBpcyBzZWdtZW50LWxldmVsIGRhdGEgYXR0YWNoIHRoZSBvdXRwdXQgdG8gdGhlIHNlZ21lbnRcbiAgICAgICAgICBpZiAoZW50cnkuc2VnbWVudCkge1xuICAgICAgICAgICAgY3VycmVudFVyaS5jdXN0b20gPSBjdXJyZW50VXJpLmN1c3RvbSB8fCB7fTtcbiAgICAgICAgICAgIGN1cnJlbnRVcmkuY3VzdG9tW2VudHJ5LmN1c3RvbVR5cGVdID0gZW50cnkuZGF0YTsgLy8gaWYgdGhpcyBpcyBtYW5pZmVzdC1sZXZlbCBkYXRhIGF0dGFjaCB0byB0aGUgdG9wIGxldmVsIG1hbmlmZXN0IG9iamVjdFxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm1hbmlmZXN0LmN1c3RvbSA9IHRoaXMubWFuaWZlc3QuY3VzdG9tIHx8IHt9O1xuICAgICAgICAgICAgdGhpcy5tYW5pZmVzdC5jdXN0b21bZW50cnkuY3VzdG9tVHlwZV0gPSBlbnRyeS5kYXRhO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICB9KVtlbnRyeS50eXBlXS5jYWxsKHNlbGYpO1xuICAgIH0pO1xuICB9XG5cbiAgcmVxdWlyZWRDb21wYXRpYmlsaXR5dmVyc2lvbihjdXJyZW50VmVyc2lvbiwgdGFyZ2V0VmVyc2lvbikge1xuICAgIGlmIChjdXJyZW50VmVyc2lvbiA8IHRhcmdldFZlcnNpb24gfHwgIWN1cnJlbnRWZXJzaW9uKSB7XG4gICAgICB0aGlzLnRyaWdnZXIoJ3dhcm4nLCB7XG4gICAgICAgIG1lc3NhZ2U6IGBtYW5pZmVzdCBtdXN0IGJlIGF0IGxlYXN0IHZlcnNpb24gJHt0YXJnZXRWZXJzaW9ufWBcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHdhcm5Pbk1pc3NpbmdBdHRyaWJ1dGVzXyhpZGVudGlmaWVyLCBhdHRyaWJ1dGVzLCByZXF1aXJlZCkge1xuICAgIGNvbnN0IG1pc3NpbmcgPSBbXTtcbiAgICByZXF1aXJlZC5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIGlmICghYXR0cmlidXRlcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgIG1pc3NpbmcucHVzaChrZXkpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKG1pc3NpbmcubGVuZ3RoKSB7XG4gICAgICB0aGlzLnRyaWdnZXIoJ3dhcm4nLCB7XG4gICAgICAgIG1lc3NhZ2U6IGAke2lkZW50aWZpZXJ9IGxhY2tzIHJlcXVpcmVkIGF0dHJpYnV0ZShzKTogJHttaXNzaW5nLmpvaW4oJywgJyl9YFxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBQYXJzZSB0aGUgaW5wdXQgc3RyaW5nIGFuZCB1cGRhdGUgdGhlIG1hbmlmZXN0IG9iamVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNodW5rIGEgcG90ZW50aWFsbHkgaW5jb21wbGV0ZSBwb3J0aW9uIG9mIHRoZSBtYW5pZmVzdFxuICAgKi9cblxuXG4gIHB1c2goY2h1bmspIHtcbiAgICB0aGlzLmxpbmVTdHJlYW0ucHVzaChjaHVuayk7XG4gIH1cbiAgLyoqXG4gICAqIEZsdXNoIGFueSByZW1haW5pbmcgaW5wdXQuIFRoaXMgY2FuIGJlIGhhbmR5IGlmIHRoZSBsYXN0IGxpbmUgb2YgYW4gTTNVOFxuICAgKiBtYW5pZmVzdCBkaWQgbm90IGNvbnRhaW4gYSB0cmFpbGluZyBuZXdsaW5lIGJ1dCB0aGUgZmlsZSBoYXMgYmVlblxuICAgKiBjb21wbGV0ZWx5IHJlY2VpdmVkLlxuICAgKi9cblxuXG4gIGVuZCgpIHtcbiAgICAvLyBmbHVzaCBhbnkgYnVmZmVyZWQgaW5wdXRcbiAgICB0aGlzLmxpbmVTdHJlYW0ucHVzaCgnXFxuJyk7XG5cbiAgICBpZiAodGhpcy5tYW5pZmVzdC5kYXRlUmFuZ2VzLmxlbmd0aCAmJiB0aGlzLmxhc3RQcm9ncmFtRGF0ZVRpbWUgPT09IG51bGwpIHtcbiAgICAgIHRoaXMudHJpZ2dlcignd2FybicsIHtcbiAgICAgICAgbWVzc2FnZTogJ0EgcGxheWxpc3Qgd2l0aCBFWFQtWC1EQVRFUkFOR0UgdGFnIG11c3QgY29udGFpbiBhdGxlYXN0IG9uZSBFWFQtWC1QUk9HUkFNLURBVEUtVElNRSB0YWcnXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB0aGlzLmxhc3RQcm9ncmFtRGF0ZVRpbWUgPSBudWxsO1xuICAgIHRoaXMudHJpZ2dlcignZW5kJyk7XG4gIH1cbiAgLyoqXG4gICAqIEFkZCBhbiBhZGRpdGlvbmFsIHBhcnNlciBmb3Igbm9uLXN0YW5kYXJkIHRhZ3NcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9ICAgb3B0aW9ucyAgICAgICAgICAgICAgYSBtYXAgb2Ygb3B0aW9ucyBmb3IgdGhlIGFkZGVkIHBhcnNlclxuICAgKiBAcGFyYW0ge1JlZ0V4cH0gICBvcHRpb25zLmV4cHJlc3Npb24gICBhIHJlZ3VsYXIgZXhwcmVzc2lvbiB0byBtYXRjaCB0aGUgY3VzdG9tIGhlYWRlclxuICAgKiBAcGFyYW0ge3N0cmluZ30gICBvcHRpb25zLmN1c3RvbVR5cGUgICB0aGUgY3VzdG9tIHR5cGUgdG8gcmVnaXN0ZXIgdG8gdGhlIG91dHB1dFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5kYXRhUGFyc2VyXSBmdW5jdGlvbiB0byBwYXJzZSB0aGUgbGluZSBpbnRvIGFuIG9iamVjdFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59ICBbb3B0aW9ucy5zZWdtZW50XSAgICBzaG91bGQgdGFnIGRhdGEgYmUgYXR0YWNoZWQgdG8gdGhlIHNlZ21lbnQgb2JqZWN0XG4gICAqL1xuXG5cbiAgYWRkUGFyc2VyKG9wdGlvbnMpIHtcbiAgICB0aGlzLnBhcnNlU3RyZWFtLmFkZFBhcnNlcihvcHRpb25zKTtcbiAgfVxuICAvKipcbiAgICogQWRkIGEgY3VzdG9tIGhlYWRlciBtYXBwZXJcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9ICAgb3B0aW9uc1xuICAgKiBAcGFyYW0ge1JlZ0V4cH0gICBvcHRpb25zLmV4cHJlc3Npb24gICBhIHJlZ3VsYXIgZXhwcmVzc2lvbiB0byBtYXRjaCB0aGUgY3VzdG9tIGhlYWRlclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcHRpb25zLm1hcCAgICAgICAgICBmdW5jdGlvbiB0byB0cmFuc2xhdGUgdGFnIGludG8gYSBkaWZmZXJlbnQgdGFnXG4gICAqL1xuXG5cbiAgYWRkVGFnTWFwcGVyKG9wdGlvbnMpIHtcbiAgICB0aGlzLnBhcnNlU3RyZWFtLmFkZFRhZ01hcHBlcihvcHRpb25zKTtcbiAgfVxuXG59XG5cbmV4cG9ydHMuTGluZVN0cmVhbSA9IExpbmVTdHJlYW07XG5leHBvcnRzLlBhcnNlU3RyZWFtID0gUGFyc2VTdHJlYW07XG5leHBvcnRzLlBhcnNlciA9IFBhcnNlcjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/m3u8-parser/dist/m3u8-parser.cjs.js\n");

/***/ })

};
;