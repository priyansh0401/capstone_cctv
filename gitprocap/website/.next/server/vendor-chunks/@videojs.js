"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@videojs";
exports.ids = ["vendor-chunks/@videojs"];
exports.modules = {

/***/ "(ssr)/./node_modules/@videojs/vhs-utils/cjs/byte-helpers.js":
/*!*************************************************************!*\
  !*** ./node_modules/@videojs/vhs-utils/cjs/byte-helpers.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nvar _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ \"(ssr)/./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.reverseBytes = exports.sliceBytes = exports.bytesMatch = exports.concatTypedArrays = exports.stringToBytes = exports.bytesToString = exports.numberToBytes = exports.bytesToNumber = exports.IS_LITTLE_ENDIAN = exports.IS_BIG_ENDIAN = exports.ENDIANNESS = exports.toBinaryString = exports.toHexString = exports.toUint8 = exports.isTypedArray = exports.isArrayBufferView = exports.padStart = exports.countBytes = exports.countBits = void 0;\n\nvar _window = _interopRequireDefault(__webpack_require__(/*! global/window */ \"(ssr)/./node_modules/global/window.js\"));\n\n// const log2 = Math.log2 ? Math.log2 : (x) => (Math.log(x) / Math.log(2));\nvar repeat = function repeat(str, len) {\n  var acc = '';\n\n  while (len--) {\n    acc += str;\n  }\n\n  return acc;\n}; // count the number of bits it would take to represent a number\n// we used to do this with log2 but BigInt does not support builtin math\n// Math.ceil(log2(x));\n\n\nvar countBits = function countBits(x) {\n  return x.toString(2).length;\n}; // count the number of whole bytes it would take to represent a number\n\n\nexports.countBits = countBits;\n\nvar countBytes = function countBytes(x) {\n  return Math.ceil(countBits(x) / 8);\n};\n\nexports.countBytes = countBytes;\n\nvar padStart = function padStart(b, len, str) {\n  if (str === void 0) {\n    str = ' ';\n  }\n\n  return (repeat(str, len) + b.toString()).slice(-len);\n};\n\nexports.padStart = padStart;\n\nvar isArrayBufferView = function isArrayBufferView(obj) {\n  if (ArrayBuffer.isView === 'function') {\n    return ArrayBuffer.isView(obj);\n  }\n\n  return obj && obj.buffer instanceof ArrayBuffer;\n};\n\nexports.isArrayBufferView = isArrayBufferView;\n\nvar isTypedArray = function isTypedArray(obj) {\n  return isArrayBufferView(obj);\n};\n\nexports.isTypedArray = isTypedArray;\n\nvar toUint8 = function toUint8(bytes) {\n  if (bytes instanceof Uint8Array) {\n    return bytes;\n  }\n\n  if (!Array.isArray(bytes) && !isTypedArray(bytes) && !(bytes instanceof ArrayBuffer)) {\n    // any non-number or NaN leads to empty uint8array\n    // eslint-disable-next-line\n    if (typeof bytes !== 'number' || typeof bytes === 'number' && bytes !== bytes) {\n      bytes = 0;\n    } else {\n      bytes = [bytes];\n    }\n  }\n\n  return new Uint8Array(bytes && bytes.buffer || bytes, bytes && bytes.byteOffset || 0, bytes && bytes.byteLength || 0);\n};\n\nexports.toUint8 = toUint8;\n\nvar toHexString = function toHexString(bytes) {\n  bytes = toUint8(bytes);\n  var str = '';\n\n  for (var i = 0; i < bytes.length; i++) {\n    str += padStart(bytes[i].toString(16), 2, '0');\n  }\n\n  return str;\n};\n\nexports.toHexString = toHexString;\n\nvar toBinaryString = function toBinaryString(bytes) {\n  bytes = toUint8(bytes);\n  var str = '';\n\n  for (var i = 0; i < bytes.length; i++) {\n    str += padStart(bytes[i].toString(2), 8, '0');\n  }\n\n  return str;\n};\n\nexports.toBinaryString = toBinaryString;\nvar BigInt = _window.default.BigInt || Number;\nvar BYTE_TABLE = [BigInt('0x1'), BigInt('0x100'), BigInt('0x10000'), BigInt('0x1000000'), BigInt('0x100000000'), BigInt('0x10000000000'), BigInt('0x1000000000000'), BigInt('0x100000000000000'), BigInt('0x10000000000000000')];\n\nvar ENDIANNESS = function () {\n  var a = new Uint16Array([0xFFCC]);\n  var b = new Uint8Array(a.buffer, a.byteOffset, a.byteLength);\n\n  if (b[0] === 0xFF) {\n    return 'big';\n  }\n\n  if (b[0] === 0xCC) {\n    return 'little';\n  }\n\n  return 'unknown';\n}();\n\nexports.ENDIANNESS = ENDIANNESS;\nvar IS_BIG_ENDIAN = ENDIANNESS === 'big';\nexports.IS_BIG_ENDIAN = IS_BIG_ENDIAN;\nvar IS_LITTLE_ENDIAN = ENDIANNESS === 'little';\nexports.IS_LITTLE_ENDIAN = IS_LITTLE_ENDIAN;\n\nvar bytesToNumber = function bytesToNumber(bytes, _temp) {\n  var _ref = _temp === void 0 ? {} : _temp,\n      _ref$signed = _ref.signed,\n      signed = _ref$signed === void 0 ? false : _ref$signed,\n      _ref$le = _ref.le,\n      le = _ref$le === void 0 ? false : _ref$le;\n\n  bytes = toUint8(bytes);\n  var fn = le ? 'reduce' : 'reduceRight';\n  var obj = bytes[fn] ? bytes[fn] : Array.prototype[fn];\n  var number = obj.call(bytes, function (total, byte, i) {\n    var exponent = le ? i : Math.abs(i + 1 - bytes.length);\n    return total + BigInt(byte) * BYTE_TABLE[exponent];\n  }, BigInt(0));\n\n  if (signed) {\n    var max = BYTE_TABLE[bytes.length] / BigInt(2) - BigInt(1);\n    number = BigInt(number);\n\n    if (number > max) {\n      number -= max;\n      number -= max;\n      number -= BigInt(2);\n    }\n  }\n\n  return Number(number);\n};\n\nexports.bytesToNumber = bytesToNumber;\n\nvar numberToBytes = function numberToBytes(number, _temp2) {\n  var _ref2 = _temp2 === void 0 ? {} : _temp2,\n      _ref2$le = _ref2.le,\n      le = _ref2$le === void 0 ? false : _ref2$le;\n\n  // eslint-disable-next-line\n  if (typeof number !== 'bigint' && typeof number !== 'number' || typeof number === 'number' && number !== number) {\n    number = 0;\n  }\n\n  number = BigInt(number);\n  var byteCount = countBytes(number);\n  var bytes = new Uint8Array(new ArrayBuffer(byteCount));\n\n  for (var i = 0; i < byteCount; i++) {\n    var byteIndex = le ? i : Math.abs(i + 1 - bytes.length);\n    bytes[byteIndex] = Number(number / BYTE_TABLE[i] & BigInt(0xFF));\n\n    if (number < 0) {\n      bytes[byteIndex] = Math.abs(~bytes[byteIndex]);\n      bytes[byteIndex] -= i === 0 ? 1 : 2;\n    }\n  }\n\n  return bytes;\n};\n\nexports.numberToBytes = numberToBytes;\n\nvar bytesToString = function bytesToString(bytes) {\n  if (!bytes) {\n    return '';\n  } // TODO: should toUint8 handle cases where we only have 8 bytes\n  // but report more since this is a Uint16+ Array?\n\n\n  bytes = Array.prototype.slice.call(bytes);\n  var string = String.fromCharCode.apply(null, toUint8(bytes));\n\n  try {\n    return decodeURIComponent(escape(string));\n  } catch (e) {// if decodeURIComponent/escape fails, we are dealing with partial\n    // or full non string data. Just return the potentially garbled string.\n  }\n\n  return string;\n};\n\nexports.bytesToString = bytesToString;\n\nvar stringToBytes = function stringToBytes(string, stringIsBytes) {\n  if (typeof string !== 'string' && string && typeof string.toString === 'function') {\n    string = string.toString();\n  }\n\n  if (typeof string !== 'string') {\n    return new Uint8Array();\n  } // If the string already is bytes, we don't have to do this\n  // otherwise we do this so that we split multi length characters\n  // into individual bytes\n\n\n  if (!stringIsBytes) {\n    string = unescape(encodeURIComponent(string));\n  }\n\n  var view = new Uint8Array(string.length);\n\n  for (var i = 0; i < string.length; i++) {\n    view[i] = string.charCodeAt(i);\n  }\n\n  return view;\n};\n\nexports.stringToBytes = stringToBytes;\n\nvar concatTypedArrays = function concatTypedArrays() {\n  for (var _len = arguments.length, buffers = new Array(_len), _key = 0; _key < _len; _key++) {\n    buffers[_key] = arguments[_key];\n  }\n\n  buffers = buffers.filter(function (b) {\n    return b && (b.byteLength || b.length) && typeof b !== 'string';\n  });\n\n  if (buffers.length <= 1) {\n    // for 0 length we will return empty uint8\n    // for 1 length we return the first uint8\n    return toUint8(buffers[0]);\n  }\n\n  var totalLen = buffers.reduce(function (total, buf, i) {\n    return total + (buf.byteLength || buf.length);\n  }, 0);\n  var tempBuffer = new Uint8Array(totalLen);\n  var offset = 0;\n  buffers.forEach(function (buf) {\n    buf = toUint8(buf);\n    tempBuffer.set(buf, offset);\n    offset += buf.byteLength;\n  });\n  return tempBuffer;\n};\n/**\n * Check if the bytes \"b\" are contained within bytes \"a\".\n *\n * @param {Uint8Array|Array} a\n *        Bytes to check in\n *\n * @param {Uint8Array|Array} b\n *        Bytes to check for\n *\n * @param {Object} options\n *        options\n *\n * @param {Array|Uint8Array} [offset=0]\n *        offset to use when looking at bytes in a\n *\n * @param {Array|Uint8Array} [mask=[]]\n *        mask to use on bytes before comparison.\n *\n * @return {boolean}\n *         If all bytes in b are inside of a, taking into account\n *         bit masks.\n */\n\n\nexports.concatTypedArrays = concatTypedArrays;\n\nvar bytesMatch = function bytesMatch(a, b, _temp3) {\n  var _ref3 = _temp3 === void 0 ? {} : _temp3,\n      _ref3$offset = _ref3.offset,\n      offset = _ref3$offset === void 0 ? 0 : _ref3$offset,\n      _ref3$mask = _ref3.mask,\n      mask = _ref3$mask === void 0 ? [] : _ref3$mask;\n\n  a = toUint8(a);\n  b = toUint8(b); // ie 11 does not support uint8 every\n\n  var fn = b.every ? b.every : Array.prototype.every;\n  return b.length && a.length - offset >= b.length && // ie 11 doesn't support every on uin8\n  fn.call(b, function (bByte, i) {\n    var aByte = mask[i] ? mask[i] & a[offset + i] : a[offset + i];\n    return bByte === aByte;\n  });\n};\n\nexports.bytesMatch = bytesMatch;\n\nvar sliceBytes = function sliceBytes(src, start, end) {\n  if (Uint8Array.prototype.slice) {\n    return Uint8Array.prototype.slice.call(src, start, end);\n  }\n\n  return new Uint8Array(Array.prototype.slice.call(src, start, end));\n};\n\nexports.sliceBytes = sliceBytes;\n\nvar reverseBytes = function reverseBytes(src) {\n  if (src.reverse) {\n    return src.reverse();\n  }\n\n  return Array.prototype.reverse.call(src);\n};\n\nexports.reverseBytes = reverseBytes;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHZpZGVvanMvdmhzLXV0aWxzL2Nqcy9ieXRlLWhlbHBlcnMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsNkJBQTZCLG1CQUFPLENBQUMsMEhBQThDOztBQUVuRiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRixvQkFBb0IsR0FBRyxrQkFBa0IsR0FBRyxrQkFBa0IsR0FBRyx5QkFBeUIsR0FBRyxxQkFBcUIsR0FBRyxxQkFBcUIsR0FBRyxxQkFBcUIsR0FBRyxxQkFBcUIsR0FBRyx3QkFBd0IsR0FBRyxxQkFBcUIsR0FBRyxrQkFBa0IsR0FBRyxzQkFBc0IsR0FBRyxtQkFBbUIsR0FBRyxlQUFlLEdBQUcsb0JBQW9CLEdBQUcseUJBQXlCLEdBQUcsZ0JBQWdCLEdBQUcsa0JBQWtCLEdBQUcsaUJBQWlCOztBQUVsYixxQ0FBcUMsbUJBQU8sQ0FBQyw0REFBZTs7QUFFNUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0gsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCOztBQUVsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGdCQUFnQjs7QUFFaEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx5QkFBeUI7O0FBRXpCO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0I7O0FBRXBCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsZUFBZTs7QUFFZjtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBOztBQUVBO0FBQ0E7O0FBRUEsbUJBQW1COztBQUVuQjtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBOztBQUVBO0FBQ0E7O0FBRUEsc0JBQXNCO0FBQ3RCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVELGtCQUFrQjtBQUNsQjtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLHdCQUF3Qjs7QUFFeEI7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEscUJBQXFCOztBQUVyQjtBQUNBLHFDQUFxQztBQUNyQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsZUFBZTtBQUNqQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxxQkFBcUI7O0FBRXJCO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSSxXQUFXO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHFCQUFxQjs7QUFFckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsa0JBQWtCLG1CQUFtQjtBQUNyQztBQUNBOztBQUVBO0FBQ0E7O0FBRUEscUJBQXFCOztBQUVyQjtBQUNBLHlFQUF5RSxhQUFhO0FBQ3RGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxrQkFBa0I7QUFDN0I7QUFDQTtBQUNBLFdBQVcsa0JBQWtCO0FBQzdCO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBLFdBQVcsa0JBQWtCO0FBQzdCO0FBQ0E7QUFDQSxXQUFXLGtCQUFrQjtBQUM3QjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7O0FBR0EseUJBQXlCOztBQUV6QjtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjs7QUFFbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQSxrQkFBa0I7O0FBRWxCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsa0JBQWtCOztBQUVsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG9CQUFvQiIsInNvdXJjZXMiOlsid2VicGFjazovL215LXYwLXByb2plY3QvLi9ub2RlX21vZHVsZXMvQHZpZGVvanMvdmhzLXV0aWxzL2Nqcy9ieXRlLWhlbHBlcnMuanM/NmNkNiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLnJldmVyc2VCeXRlcyA9IGV4cG9ydHMuc2xpY2VCeXRlcyA9IGV4cG9ydHMuYnl0ZXNNYXRjaCA9IGV4cG9ydHMuY29uY2F0VHlwZWRBcnJheXMgPSBleHBvcnRzLnN0cmluZ1RvQnl0ZXMgPSBleHBvcnRzLmJ5dGVzVG9TdHJpbmcgPSBleHBvcnRzLm51bWJlclRvQnl0ZXMgPSBleHBvcnRzLmJ5dGVzVG9OdW1iZXIgPSBleHBvcnRzLklTX0xJVFRMRV9FTkRJQU4gPSBleHBvcnRzLklTX0JJR19FTkRJQU4gPSBleHBvcnRzLkVORElBTk5FU1MgPSBleHBvcnRzLnRvQmluYXJ5U3RyaW5nID0gZXhwb3J0cy50b0hleFN0cmluZyA9IGV4cG9ydHMudG9VaW50OCA9IGV4cG9ydHMuaXNUeXBlZEFycmF5ID0gZXhwb3J0cy5pc0FycmF5QnVmZmVyVmlldyA9IGV4cG9ydHMucGFkU3RhcnQgPSBleHBvcnRzLmNvdW50Qnl0ZXMgPSBleHBvcnRzLmNvdW50Qml0cyA9IHZvaWQgMDtcblxudmFyIF93aW5kb3cgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJnbG9iYWwvd2luZG93XCIpKTtcblxuLy8gY29uc3QgbG9nMiA9IE1hdGgubG9nMiA/IE1hdGgubG9nMiA6ICh4KSA9PiAoTWF0aC5sb2coeCkgLyBNYXRoLmxvZygyKSk7XG52YXIgcmVwZWF0ID0gZnVuY3Rpb24gcmVwZWF0KHN0ciwgbGVuKSB7XG4gIHZhciBhY2MgPSAnJztcblxuICB3aGlsZSAobGVuLS0pIHtcbiAgICBhY2MgKz0gc3RyO1xuICB9XG5cbiAgcmV0dXJuIGFjYztcbn07IC8vIGNvdW50IHRoZSBudW1iZXIgb2YgYml0cyBpdCB3b3VsZCB0YWtlIHRvIHJlcHJlc2VudCBhIG51bWJlclxuLy8gd2UgdXNlZCB0byBkbyB0aGlzIHdpdGggbG9nMiBidXQgQmlnSW50IGRvZXMgbm90IHN1cHBvcnQgYnVpbHRpbiBtYXRoXG4vLyBNYXRoLmNlaWwobG9nMih4KSk7XG5cblxudmFyIGNvdW50Qml0cyA9IGZ1bmN0aW9uIGNvdW50Qml0cyh4KSB7XG4gIHJldHVybiB4LnRvU3RyaW5nKDIpLmxlbmd0aDtcbn07IC8vIGNvdW50IHRoZSBudW1iZXIgb2Ygd2hvbGUgYnl0ZXMgaXQgd291bGQgdGFrZSB0byByZXByZXNlbnQgYSBudW1iZXJcblxuXG5leHBvcnRzLmNvdW50Qml0cyA9IGNvdW50Qml0cztcblxudmFyIGNvdW50Qnl0ZXMgPSBmdW5jdGlvbiBjb3VudEJ5dGVzKHgpIHtcbiAgcmV0dXJuIE1hdGguY2VpbChjb3VudEJpdHMoeCkgLyA4KTtcbn07XG5cbmV4cG9ydHMuY291bnRCeXRlcyA9IGNvdW50Qnl0ZXM7XG5cbnZhciBwYWRTdGFydCA9IGZ1bmN0aW9uIHBhZFN0YXJ0KGIsIGxlbiwgc3RyKSB7XG4gIGlmIChzdHIgPT09IHZvaWQgMCkge1xuICAgIHN0ciA9ICcgJztcbiAgfVxuXG4gIHJldHVybiAocmVwZWF0KHN0ciwgbGVuKSArIGIudG9TdHJpbmcoKSkuc2xpY2UoLWxlbik7XG59O1xuXG5leHBvcnRzLnBhZFN0YXJ0ID0gcGFkU3RhcnQ7XG5cbnZhciBpc0FycmF5QnVmZmVyVmlldyA9IGZ1bmN0aW9uIGlzQXJyYXlCdWZmZXJWaWV3KG9iaikge1xuICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIEFycmF5QnVmZmVyLmlzVmlldyhvYmopO1xuICB9XG5cbiAgcmV0dXJuIG9iaiAmJiBvYmouYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXI7XG59O1xuXG5leHBvcnRzLmlzQXJyYXlCdWZmZXJWaWV3ID0gaXNBcnJheUJ1ZmZlclZpZXc7XG5cbnZhciBpc1R5cGVkQXJyYXkgPSBmdW5jdGlvbiBpc1R5cGVkQXJyYXkob2JqKSB7XG4gIHJldHVybiBpc0FycmF5QnVmZmVyVmlldyhvYmopO1xufTtcblxuZXhwb3J0cy5pc1R5cGVkQXJyYXkgPSBpc1R5cGVkQXJyYXk7XG5cbnZhciB0b1VpbnQ4ID0gZnVuY3Rpb24gdG9VaW50OChieXRlcykge1xuICBpZiAoYnl0ZXMgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgcmV0dXJuIGJ5dGVzO1xuICB9XG5cbiAgaWYgKCFBcnJheS5pc0FycmF5KGJ5dGVzKSAmJiAhaXNUeXBlZEFycmF5KGJ5dGVzKSAmJiAhKGJ5dGVzIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpKSB7XG4gICAgLy8gYW55IG5vbi1udW1iZXIgb3IgTmFOIGxlYWRzIHRvIGVtcHR5IHVpbnQ4YXJyYXlcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICBpZiAodHlwZW9mIGJ5dGVzICE9PSAnbnVtYmVyJyB8fCB0eXBlb2YgYnl0ZXMgPT09ICdudW1iZXInICYmIGJ5dGVzICE9PSBieXRlcykge1xuICAgICAgYnl0ZXMgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICBieXRlcyA9IFtieXRlc107XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGJ5dGVzICYmIGJ5dGVzLmJ1ZmZlciB8fCBieXRlcywgYnl0ZXMgJiYgYnl0ZXMuYnl0ZU9mZnNldCB8fCAwLCBieXRlcyAmJiBieXRlcy5ieXRlTGVuZ3RoIHx8IDApO1xufTtcblxuZXhwb3J0cy50b1VpbnQ4ID0gdG9VaW50ODtcblxudmFyIHRvSGV4U3RyaW5nID0gZnVuY3Rpb24gdG9IZXhTdHJpbmcoYnl0ZXMpIHtcbiAgYnl0ZXMgPSB0b1VpbnQ4KGJ5dGVzKTtcbiAgdmFyIHN0ciA9ICcnO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICBzdHIgKz0gcGFkU3RhcnQoYnl0ZXNbaV0udG9TdHJpbmcoMTYpLCAyLCAnMCcpO1xuICB9XG5cbiAgcmV0dXJuIHN0cjtcbn07XG5cbmV4cG9ydHMudG9IZXhTdHJpbmcgPSB0b0hleFN0cmluZztcblxudmFyIHRvQmluYXJ5U3RyaW5nID0gZnVuY3Rpb24gdG9CaW5hcnlTdHJpbmcoYnl0ZXMpIHtcbiAgYnl0ZXMgPSB0b1VpbnQ4KGJ5dGVzKTtcbiAgdmFyIHN0ciA9ICcnO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICBzdHIgKz0gcGFkU3RhcnQoYnl0ZXNbaV0udG9TdHJpbmcoMiksIDgsICcwJyk7XG4gIH1cblxuICByZXR1cm4gc3RyO1xufTtcblxuZXhwb3J0cy50b0JpbmFyeVN0cmluZyA9IHRvQmluYXJ5U3RyaW5nO1xudmFyIEJpZ0ludCA9IF93aW5kb3cuZGVmYXVsdC5CaWdJbnQgfHwgTnVtYmVyO1xudmFyIEJZVEVfVEFCTEUgPSBbQmlnSW50KCcweDEnKSwgQmlnSW50KCcweDEwMCcpLCBCaWdJbnQoJzB4MTAwMDAnKSwgQmlnSW50KCcweDEwMDAwMDAnKSwgQmlnSW50KCcweDEwMDAwMDAwMCcpLCBCaWdJbnQoJzB4MTAwMDAwMDAwMDAnKSwgQmlnSW50KCcweDEwMDAwMDAwMDAwMDAnKSwgQmlnSW50KCcweDEwMDAwMDAwMDAwMDAwMCcpLCBCaWdJbnQoJzB4MTAwMDAwMDAwMDAwMDAwMDAnKV07XG5cbnZhciBFTkRJQU5ORVNTID0gZnVuY3Rpb24gKCkge1xuICB2YXIgYSA9IG5ldyBVaW50MTZBcnJheShbMHhGRkNDXSk7XG4gIHZhciBiID0gbmV3IFVpbnQ4QXJyYXkoYS5idWZmZXIsIGEuYnl0ZU9mZnNldCwgYS5ieXRlTGVuZ3RoKTtcblxuICBpZiAoYlswXSA9PT0gMHhGRikge1xuICAgIHJldHVybiAnYmlnJztcbiAgfVxuXG4gIGlmIChiWzBdID09PSAweENDKSB7XG4gICAgcmV0dXJuICdsaXR0bGUnO1xuICB9XG5cbiAgcmV0dXJuICd1bmtub3duJztcbn0oKTtcblxuZXhwb3J0cy5FTkRJQU5ORVNTID0gRU5ESUFOTkVTUztcbnZhciBJU19CSUdfRU5ESUFOID0gRU5ESUFOTkVTUyA9PT0gJ2JpZyc7XG5leHBvcnRzLklTX0JJR19FTkRJQU4gPSBJU19CSUdfRU5ESUFOO1xudmFyIElTX0xJVFRMRV9FTkRJQU4gPSBFTkRJQU5ORVNTID09PSAnbGl0dGxlJztcbmV4cG9ydHMuSVNfTElUVExFX0VORElBTiA9IElTX0xJVFRMRV9FTkRJQU47XG5cbnZhciBieXRlc1RvTnVtYmVyID0gZnVuY3Rpb24gYnl0ZXNUb051bWJlcihieXRlcywgX3RlbXApIHtcbiAgdmFyIF9yZWYgPSBfdGVtcCA9PT0gdm9pZCAwID8ge30gOiBfdGVtcCxcbiAgICAgIF9yZWYkc2lnbmVkID0gX3JlZi5zaWduZWQsXG4gICAgICBzaWduZWQgPSBfcmVmJHNpZ25lZCA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcmVmJHNpZ25lZCxcbiAgICAgIF9yZWYkbGUgPSBfcmVmLmxlLFxuICAgICAgbGUgPSBfcmVmJGxlID09PSB2b2lkIDAgPyBmYWxzZSA6IF9yZWYkbGU7XG5cbiAgYnl0ZXMgPSB0b1VpbnQ4KGJ5dGVzKTtcbiAgdmFyIGZuID0gbGUgPyAncmVkdWNlJyA6ICdyZWR1Y2VSaWdodCc7XG4gIHZhciBvYmogPSBieXRlc1tmbl0gPyBieXRlc1tmbl0gOiBBcnJheS5wcm90b3R5cGVbZm5dO1xuICB2YXIgbnVtYmVyID0gb2JqLmNhbGwoYnl0ZXMsIGZ1bmN0aW9uICh0b3RhbCwgYnl0ZSwgaSkge1xuICAgIHZhciBleHBvbmVudCA9IGxlID8gaSA6IE1hdGguYWJzKGkgKyAxIC0gYnl0ZXMubGVuZ3RoKTtcbiAgICByZXR1cm4gdG90YWwgKyBCaWdJbnQoYnl0ZSkgKiBCWVRFX1RBQkxFW2V4cG9uZW50XTtcbiAgfSwgQmlnSW50KDApKTtcblxuICBpZiAoc2lnbmVkKSB7XG4gICAgdmFyIG1heCA9IEJZVEVfVEFCTEVbYnl0ZXMubGVuZ3RoXSAvIEJpZ0ludCgyKSAtIEJpZ0ludCgxKTtcbiAgICBudW1iZXIgPSBCaWdJbnQobnVtYmVyKTtcblxuICAgIGlmIChudW1iZXIgPiBtYXgpIHtcbiAgICAgIG51bWJlciAtPSBtYXg7XG4gICAgICBudW1iZXIgLT0gbWF4O1xuICAgICAgbnVtYmVyIC09IEJpZ0ludCgyKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gTnVtYmVyKG51bWJlcik7XG59O1xuXG5leHBvcnRzLmJ5dGVzVG9OdW1iZXIgPSBieXRlc1RvTnVtYmVyO1xuXG52YXIgbnVtYmVyVG9CeXRlcyA9IGZ1bmN0aW9uIG51bWJlclRvQnl0ZXMobnVtYmVyLCBfdGVtcDIpIHtcbiAgdmFyIF9yZWYyID0gX3RlbXAyID09PSB2b2lkIDAgPyB7fSA6IF90ZW1wMixcbiAgICAgIF9yZWYyJGxlID0gX3JlZjIubGUsXG4gICAgICBsZSA9IF9yZWYyJGxlID09PSB2b2lkIDAgPyBmYWxzZSA6IF9yZWYyJGxlO1xuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICBpZiAodHlwZW9mIG51bWJlciAhPT0gJ2JpZ2ludCcgJiYgdHlwZW9mIG51bWJlciAhPT0gJ251bWJlcicgfHwgdHlwZW9mIG51bWJlciA9PT0gJ251bWJlcicgJiYgbnVtYmVyICE9PSBudW1iZXIpIHtcbiAgICBudW1iZXIgPSAwO1xuICB9XG5cbiAgbnVtYmVyID0gQmlnSW50KG51bWJlcik7XG4gIHZhciBieXRlQ291bnQgPSBjb3VudEJ5dGVzKG51bWJlcik7XG4gIHZhciBieXRlcyA9IG5ldyBVaW50OEFycmF5KG5ldyBBcnJheUJ1ZmZlcihieXRlQ291bnQpKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVDb3VudDsgaSsrKSB7XG4gICAgdmFyIGJ5dGVJbmRleCA9IGxlID8gaSA6IE1hdGguYWJzKGkgKyAxIC0gYnl0ZXMubGVuZ3RoKTtcbiAgICBieXRlc1tieXRlSW5kZXhdID0gTnVtYmVyKG51bWJlciAvIEJZVEVfVEFCTEVbaV0gJiBCaWdJbnQoMHhGRikpO1xuXG4gICAgaWYgKG51bWJlciA8IDApIHtcbiAgICAgIGJ5dGVzW2J5dGVJbmRleF0gPSBNYXRoLmFicyh+Ynl0ZXNbYnl0ZUluZGV4XSk7XG4gICAgICBieXRlc1tieXRlSW5kZXhdIC09IGkgPT09IDAgPyAxIDogMjtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnl0ZXM7XG59O1xuXG5leHBvcnRzLm51bWJlclRvQnl0ZXMgPSBudW1iZXJUb0J5dGVzO1xuXG52YXIgYnl0ZXNUb1N0cmluZyA9IGZ1bmN0aW9uIGJ5dGVzVG9TdHJpbmcoYnl0ZXMpIHtcbiAgaWYgKCFieXRlcykge1xuICAgIHJldHVybiAnJztcbiAgfSAvLyBUT0RPOiBzaG91bGQgdG9VaW50OCBoYW5kbGUgY2FzZXMgd2hlcmUgd2Ugb25seSBoYXZlIDggYnl0ZXNcbiAgLy8gYnV0IHJlcG9ydCBtb3JlIHNpbmNlIHRoaXMgaXMgYSBVaW50MTYrIEFycmF5P1xuXG5cbiAgYnl0ZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChieXRlcyk7XG4gIHZhciBzdHJpbmcgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIHRvVWludDgoYnl0ZXMpKTtcblxuICB0cnkge1xuICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoZXNjYXBlKHN0cmluZykpO1xuICB9IGNhdGNoIChlKSB7Ly8gaWYgZGVjb2RlVVJJQ29tcG9uZW50L2VzY2FwZSBmYWlscywgd2UgYXJlIGRlYWxpbmcgd2l0aCBwYXJ0aWFsXG4gICAgLy8gb3IgZnVsbCBub24gc3RyaW5nIGRhdGEuIEp1c3QgcmV0dXJuIHRoZSBwb3RlbnRpYWxseSBnYXJibGVkIHN0cmluZy5cbiAgfVxuXG4gIHJldHVybiBzdHJpbmc7XG59O1xuXG5leHBvcnRzLmJ5dGVzVG9TdHJpbmcgPSBieXRlc1RvU3RyaW5nO1xuXG52YXIgc3RyaW5nVG9CeXRlcyA9IGZ1bmN0aW9uIHN0cmluZ1RvQnl0ZXMoc3RyaW5nLCBzdHJpbmdJc0J5dGVzKSB7XG4gIGlmICh0eXBlb2Ygc3RyaW5nICE9PSAnc3RyaW5nJyAmJiBzdHJpbmcgJiYgdHlwZW9mIHN0cmluZy50b1N0cmluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHN0cmluZyA9IHN0cmluZy50b1N0cmluZygpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBzdHJpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KCk7XG4gIH0gLy8gSWYgdGhlIHN0cmluZyBhbHJlYWR5IGlzIGJ5dGVzLCB3ZSBkb24ndCBoYXZlIHRvIGRvIHRoaXNcbiAgLy8gb3RoZXJ3aXNlIHdlIGRvIHRoaXMgc28gdGhhdCB3ZSBzcGxpdCBtdWx0aSBsZW5ndGggY2hhcmFjdGVyc1xuICAvLyBpbnRvIGluZGl2aWR1YWwgYnl0ZXNcblxuXG4gIGlmICghc3RyaW5nSXNCeXRlcykge1xuICAgIHN0cmluZyA9IHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmcpKTtcbiAgfVxuXG4gIHZhciB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkoc3RyaW5nLmxlbmd0aCk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHJpbmcubGVuZ3RoOyBpKyspIHtcbiAgICB2aWV3W2ldID0gc3RyaW5nLmNoYXJDb2RlQXQoaSk7XG4gIH1cblxuICByZXR1cm4gdmlldztcbn07XG5cbmV4cG9ydHMuc3RyaW5nVG9CeXRlcyA9IHN0cmluZ1RvQnl0ZXM7XG5cbnZhciBjb25jYXRUeXBlZEFycmF5cyA9IGZ1bmN0aW9uIGNvbmNhdFR5cGVkQXJyYXlzKCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYnVmZmVycyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBidWZmZXJzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgYnVmZmVycyA9IGJ1ZmZlcnMuZmlsdGVyKGZ1bmN0aW9uIChiKSB7XG4gICAgcmV0dXJuIGIgJiYgKGIuYnl0ZUxlbmd0aCB8fCBiLmxlbmd0aCkgJiYgdHlwZW9mIGIgIT09ICdzdHJpbmcnO1xuICB9KTtcblxuICBpZiAoYnVmZmVycy5sZW5ndGggPD0gMSkge1xuICAgIC8vIGZvciAwIGxlbmd0aCB3ZSB3aWxsIHJldHVybiBlbXB0eSB1aW50OFxuICAgIC8vIGZvciAxIGxlbmd0aCB3ZSByZXR1cm4gdGhlIGZpcnN0IHVpbnQ4XG4gICAgcmV0dXJuIHRvVWludDgoYnVmZmVyc1swXSk7XG4gIH1cblxuICB2YXIgdG90YWxMZW4gPSBidWZmZXJzLnJlZHVjZShmdW5jdGlvbiAodG90YWwsIGJ1ZiwgaSkge1xuICAgIHJldHVybiB0b3RhbCArIChidWYuYnl0ZUxlbmd0aCB8fCBidWYubGVuZ3RoKTtcbiAgfSwgMCk7XG4gIHZhciB0ZW1wQnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkodG90YWxMZW4pO1xuICB2YXIgb2Zmc2V0ID0gMDtcbiAgYnVmZmVycy5mb3JFYWNoKGZ1bmN0aW9uIChidWYpIHtcbiAgICBidWYgPSB0b1VpbnQ4KGJ1Zik7XG4gICAgdGVtcEJ1ZmZlci5zZXQoYnVmLCBvZmZzZXQpO1xuICAgIG9mZnNldCArPSBidWYuYnl0ZUxlbmd0aDtcbiAgfSk7XG4gIHJldHVybiB0ZW1wQnVmZmVyO1xufTtcbi8qKlxuICogQ2hlY2sgaWYgdGhlIGJ5dGVzIFwiYlwiIGFyZSBjb250YWluZWQgd2l0aGluIGJ5dGVzIFwiYVwiLlxuICpcbiAqIEBwYXJhbSB7VWludDhBcnJheXxBcnJheX0gYVxuICogICAgICAgIEJ5dGVzIHRvIGNoZWNrIGluXG4gKlxuICogQHBhcmFtIHtVaW50OEFycmF5fEFycmF5fSBiXG4gKiAgICAgICAgQnl0ZXMgdG8gY2hlY2sgZm9yXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqICAgICAgICBvcHRpb25zXG4gKlxuICogQHBhcmFtIHtBcnJheXxVaW50OEFycmF5fSBbb2Zmc2V0PTBdXG4gKiAgICAgICAgb2Zmc2V0IHRvIHVzZSB3aGVuIGxvb2tpbmcgYXQgYnl0ZXMgaW4gYVxuICpcbiAqIEBwYXJhbSB7QXJyYXl8VWludDhBcnJheX0gW21hc2s9W11dXG4gKiAgICAgICAgbWFzayB0byB1c2Ugb24gYnl0ZXMgYmVmb3JlIGNvbXBhcmlzb24uXG4gKlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqICAgICAgICAgSWYgYWxsIGJ5dGVzIGluIGIgYXJlIGluc2lkZSBvZiBhLCB0YWtpbmcgaW50byBhY2NvdW50XG4gKiAgICAgICAgIGJpdCBtYXNrcy5cbiAqL1xuXG5cbmV4cG9ydHMuY29uY2F0VHlwZWRBcnJheXMgPSBjb25jYXRUeXBlZEFycmF5cztcblxudmFyIGJ5dGVzTWF0Y2ggPSBmdW5jdGlvbiBieXRlc01hdGNoKGEsIGIsIF90ZW1wMykge1xuICB2YXIgX3JlZjMgPSBfdGVtcDMgPT09IHZvaWQgMCA/IHt9IDogX3RlbXAzLFxuICAgICAgX3JlZjMkb2Zmc2V0ID0gX3JlZjMub2Zmc2V0LFxuICAgICAgb2Zmc2V0ID0gX3JlZjMkb2Zmc2V0ID09PSB2b2lkIDAgPyAwIDogX3JlZjMkb2Zmc2V0LFxuICAgICAgX3JlZjMkbWFzayA9IF9yZWYzLm1hc2ssXG4gICAgICBtYXNrID0gX3JlZjMkbWFzayA9PT0gdm9pZCAwID8gW10gOiBfcmVmMyRtYXNrO1xuXG4gIGEgPSB0b1VpbnQ4KGEpO1xuICBiID0gdG9VaW50OChiKTsgLy8gaWUgMTEgZG9lcyBub3Qgc3VwcG9ydCB1aW50OCBldmVyeVxuXG4gIHZhciBmbiA9IGIuZXZlcnkgPyBiLmV2ZXJ5IDogQXJyYXkucHJvdG90eXBlLmV2ZXJ5O1xuICByZXR1cm4gYi5sZW5ndGggJiYgYS5sZW5ndGggLSBvZmZzZXQgPj0gYi5sZW5ndGggJiYgLy8gaWUgMTEgZG9lc24ndCBzdXBwb3J0IGV2ZXJ5IG9uIHVpbjhcbiAgZm4uY2FsbChiLCBmdW5jdGlvbiAoYkJ5dGUsIGkpIHtcbiAgICB2YXIgYUJ5dGUgPSBtYXNrW2ldID8gbWFza1tpXSAmIGFbb2Zmc2V0ICsgaV0gOiBhW29mZnNldCArIGldO1xuICAgIHJldHVybiBiQnl0ZSA9PT0gYUJ5dGU7XG4gIH0pO1xufTtcblxuZXhwb3J0cy5ieXRlc01hdGNoID0gYnl0ZXNNYXRjaDtcblxudmFyIHNsaWNlQnl0ZXMgPSBmdW5jdGlvbiBzbGljZUJ5dGVzKHNyYywgc3RhcnQsIGVuZCkge1xuICBpZiAoVWludDhBcnJheS5wcm90b3R5cGUuc2xpY2UpIHtcbiAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChzcmMsIHN0YXJ0LCBlbmQpO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBVaW50OEFycmF5KEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHNyYywgc3RhcnQsIGVuZCkpO1xufTtcblxuZXhwb3J0cy5zbGljZUJ5dGVzID0gc2xpY2VCeXRlcztcblxudmFyIHJldmVyc2VCeXRlcyA9IGZ1bmN0aW9uIHJldmVyc2VCeXRlcyhzcmMpIHtcbiAgaWYgKHNyYy5yZXZlcnNlKSB7XG4gICAgcmV0dXJuIHNyYy5yZXZlcnNlKCk7XG4gIH1cblxuICByZXR1cm4gQXJyYXkucHJvdG90eXBlLnJldmVyc2UuY2FsbChzcmMpO1xufTtcblxuZXhwb3J0cy5yZXZlcnNlQnl0ZXMgPSByZXZlcnNlQnl0ZXM7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@videojs/vhs-utils/cjs/byte-helpers.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@videojs/vhs-utils/cjs/codec-helpers.js":
/*!**************************************************************!*\
  !*** ./node_modules/@videojs/vhs-utils/cjs/codec-helpers.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.getHvcCodec = exports.getAvcCodec = exports.getAv1Codec = void 0;\n\nvar _byteHelpers = __webpack_require__(/*! ./byte-helpers.js */ \"(ssr)/./node_modules/@videojs/vhs-utils/cjs/byte-helpers.js\");\n\n// https://aomediacodec.github.io/av1-isobmff/#av1codecconfigurationbox-syntax\n// https://developer.mozilla.org/en-US/docs/Web/Media/Formats/codecs_parameter#AV1\nvar getAv1Codec = function getAv1Codec(bytes) {\n  var codec = '';\n  var profile = bytes[1] >>> 3;\n  var level = bytes[1] & 0x1F;\n  var tier = bytes[2] >>> 7;\n  var highBitDepth = (bytes[2] & 0x40) >> 6;\n  var twelveBit = (bytes[2] & 0x20) >> 5;\n  var monochrome = (bytes[2] & 0x10) >> 4;\n  var chromaSubsamplingX = (bytes[2] & 0x08) >> 3;\n  var chromaSubsamplingY = (bytes[2] & 0x04) >> 2;\n  var chromaSamplePosition = bytes[2] & 0x03;\n  codec += profile + \".\" + (0, _byteHelpers.padStart)(level, 2, '0');\n\n  if (tier === 0) {\n    codec += 'M';\n  } else if (tier === 1) {\n    codec += 'H';\n  }\n\n  var bitDepth;\n\n  if (profile === 2 && highBitDepth) {\n    bitDepth = twelveBit ? 12 : 10;\n  } else {\n    bitDepth = highBitDepth ? 10 : 8;\n  }\n\n  codec += \".\" + (0, _byteHelpers.padStart)(bitDepth, 2, '0'); // TODO: can we parse color range??\n\n  codec += \".\" + monochrome;\n  codec += \".\" + chromaSubsamplingX + chromaSubsamplingY + chromaSamplePosition;\n  return codec;\n};\n\nexports.getAv1Codec = getAv1Codec;\n\nvar getAvcCodec = function getAvcCodec(bytes) {\n  var profileId = (0, _byteHelpers.toHexString)(bytes[1]);\n  var constraintFlags = (0, _byteHelpers.toHexString)(bytes[2] & 0xFC);\n  var levelId = (0, _byteHelpers.toHexString)(bytes[3]);\n  return \"\" + profileId + constraintFlags + levelId;\n};\n\nexports.getAvcCodec = getAvcCodec;\n\nvar getHvcCodec = function getHvcCodec(bytes) {\n  var codec = '';\n  var profileSpace = bytes[1] >> 6;\n  var profileId = bytes[1] & 0x1F;\n  var tierFlag = (bytes[1] & 0x20) >> 5;\n  var profileCompat = bytes.subarray(2, 6);\n  var constraintIds = bytes.subarray(6, 12);\n  var levelId = bytes[12];\n\n  if (profileSpace === 1) {\n    codec += 'A';\n  } else if (profileSpace === 2) {\n    codec += 'B';\n  } else if (profileSpace === 3) {\n    codec += 'C';\n  }\n\n  codec += profileId + \".\"; // ffmpeg does this in big endian\n\n  var profileCompatVal = parseInt((0, _byteHelpers.toBinaryString)(profileCompat).split('').reverse().join(''), 2); // apple does this in little endian...\n\n  if (profileCompatVal > 255) {\n    profileCompatVal = parseInt((0, _byteHelpers.toBinaryString)(profileCompat), 2);\n  }\n\n  codec += profileCompatVal.toString(16) + \".\";\n\n  if (tierFlag === 0) {\n    codec += 'L';\n  } else {\n    codec += 'H';\n  }\n\n  codec += levelId;\n  var constraints = '';\n\n  for (var i = 0; i < constraintIds.length; i++) {\n    var v = constraintIds[i];\n\n    if (v) {\n      if (constraints) {\n        constraints += '.';\n      }\n\n      constraints += v.toString(16);\n    }\n  }\n\n  if (constraints) {\n    codec += \".\" + constraints;\n  }\n\n  return codec;\n};\n\nexports.getHvcCodec = getHvcCodec;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHZpZGVvanMvdmhzLXV0aWxzL2Nqcy9jb2RlYy1oZWxwZXJzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGLG1CQUFtQixHQUFHLG1CQUFtQixHQUFHLG1CQUFtQjs7QUFFL0QsbUJBQW1CLG1CQUFPLENBQUMsc0ZBQW1COztBQUU5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUEsK0RBQStEOztBQUUvRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUI7O0FBRW5CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUI7O0FBRW5CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBLDRCQUE0Qjs7QUFFNUIsb0hBQW9IOztBQUVwSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsa0JBQWtCLDBCQUEwQjtBQUM1Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsbUJBQW1CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktdjAtcHJvamVjdC8uL25vZGVfbW9kdWxlcy9AdmlkZW9qcy92aHMtdXRpbHMvY2pzL2NvZGVjLWhlbHBlcnMuanM/YjI1NiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZ2V0SHZjQ29kZWMgPSBleHBvcnRzLmdldEF2Y0NvZGVjID0gZXhwb3J0cy5nZXRBdjFDb2RlYyA9IHZvaWQgMDtcblxudmFyIF9ieXRlSGVscGVycyA9IHJlcXVpcmUoXCIuL2J5dGUtaGVscGVycy5qc1wiKTtcblxuLy8gaHR0cHM6Ly9hb21lZGlhY29kZWMuZ2l0aHViLmlvL2F2MS1pc29ibWZmLyNhdjFjb2RlY2NvbmZpZ3VyYXRpb25ib3gtc3ludGF4XG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9NZWRpYS9Gb3JtYXRzL2NvZGVjc19wYXJhbWV0ZXIjQVYxXG52YXIgZ2V0QXYxQ29kZWMgPSBmdW5jdGlvbiBnZXRBdjFDb2RlYyhieXRlcykge1xuICB2YXIgY29kZWMgPSAnJztcbiAgdmFyIHByb2ZpbGUgPSBieXRlc1sxXSA+Pj4gMztcbiAgdmFyIGxldmVsID0gYnl0ZXNbMV0gJiAweDFGO1xuICB2YXIgdGllciA9IGJ5dGVzWzJdID4+PiA3O1xuICB2YXIgaGlnaEJpdERlcHRoID0gKGJ5dGVzWzJdICYgMHg0MCkgPj4gNjtcbiAgdmFyIHR3ZWx2ZUJpdCA9IChieXRlc1syXSAmIDB4MjApID4+IDU7XG4gIHZhciBtb25vY2hyb21lID0gKGJ5dGVzWzJdICYgMHgxMCkgPj4gNDtcbiAgdmFyIGNocm9tYVN1YnNhbXBsaW5nWCA9IChieXRlc1syXSAmIDB4MDgpID4+IDM7XG4gIHZhciBjaHJvbWFTdWJzYW1wbGluZ1kgPSAoYnl0ZXNbMl0gJiAweDA0KSA+PiAyO1xuICB2YXIgY2hyb21hU2FtcGxlUG9zaXRpb24gPSBieXRlc1syXSAmIDB4MDM7XG4gIGNvZGVjICs9IHByb2ZpbGUgKyBcIi5cIiArICgwLCBfYnl0ZUhlbHBlcnMucGFkU3RhcnQpKGxldmVsLCAyLCAnMCcpO1xuXG4gIGlmICh0aWVyID09PSAwKSB7XG4gICAgY29kZWMgKz0gJ00nO1xuICB9IGVsc2UgaWYgKHRpZXIgPT09IDEpIHtcbiAgICBjb2RlYyArPSAnSCc7XG4gIH1cblxuICB2YXIgYml0RGVwdGg7XG5cbiAgaWYgKHByb2ZpbGUgPT09IDIgJiYgaGlnaEJpdERlcHRoKSB7XG4gICAgYml0RGVwdGggPSB0d2VsdmVCaXQgPyAxMiA6IDEwO1xuICB9IGVsc2Uge1xuICAgIGJpdERlcHRoID0gaGlnaEJpdERlcHRoID8gMTAgOiA4O1xuICB9XG5cbiAgY29kZWMgKz0gXCIuXCIgKyAoMCwgX2J5dGVIZWxwZXJzLnBhZFN0YXJ0KShiaXREZXB0aCwgMiwgJzAnKTsgLy8gVE9ETzogY2FuIHdlIHBhcnNlIGNvbG9yIHJhbmdlPz9cblxuICBjb2RlYyArPSBcIi5cIiArIG1vbm9jaHJvbWU7XG4gIGNvZGVjICs9IFwiLlwiICsgY2hyb21hU3Vic2FtcGxpbmdYICsgY2hyb21hU3Vic2FtcGxpbmdZICsgY2hyb21hU2FtcGxlUG9zaXRpb247XG4gIHJldHVybiBjb2RlYztcbn07XG5cbmV4cG9ydHMuZ2V0QXYxQ29kZWMgPSBnZXRBdjFDb2RlYztcblxudmFyIGdldEF2Y0NvZGVjID0gZnVuY3Rpb24gZ2V0QXZjQ29kZWMoYnl0ZXMpIHtcbiAgdmFyIHByb2ZpbGVJZCA9ICgwLCBfYnl0ZUhlbHBlcnMudG9IZXhTdHJpbmcpKGJ5dGVzWzFdKTtcbiAgdmFyIGNvbnN0cmFpbnRGbGFncyA9ICgwLCBfYnl0ZUhlbHBlcnMudG9IZXhTdHJpbmcpKGJ5dGVzWzJdICYgMHhGQyk7XG4gIHZhciBsZXZlbElkID0gKDAsIF9ieXRlSGVscGVycy50b0hleFN0cmluZykoYnl0ZXNbM10pO1xuICByZXR1cm4gXCJcIiArIHByb2ZpbGVJZCArIGNvbnN0cmFpbnRGbGFncyArIGxldmVsSWQ7XG59O1xuXG5leHBvcnRzLmdldEF2Y0NvZGVjID0gZ2V0QXZjQ29kZWM7XG5cbnZhciBnZXRIdmNDb2RlYyA9IGZ1bmN0aW9uIGdldEh2Y0NvZGVjKGJ5dGVzKSB7XG4gIHZhciBjb2RlYyA9ICcnO1xuICB2YXIgcHJvZmlsZVNwYWNlID0gYnl0ZXNbMV0gPj4gNjtcbiAgdmFyIHByb2ZpbGVJZCA9IGJ5dGVzWzFdICYgMHgxRjtcbiAgdmFyIHRpZXJGbGFnID0gKGJ5dGVzWzFdICYgMHgyMCkgPj4gNTtcbiAgdmFyIHByb2ZpbGVDb21wYXQgPSBieXRlcy5zdWJhcnJheSgyLCA2KTtcbiAgdmFyIGNvbnN0cmFpbnRJZHMgPSBieXRlcy5zdWJhcnJheSg2LCAxMik7XG4gIHZhciBsZXZlbElkID0gYnl0ZXNbMTJdO1xuXG4gIGlmIChwcm9maWxlU3BhY2UgPT09IDEpIHtcbiAgICBjb2RlYyArPSAnQSc7XG4gIH0gZWxzZSBpZiAocHJvZmlsZVNwYWNlID09PSAyKSB7XG4gICAgY29kZWMgKz0gJ0InO1xuICB9IGVsc2UgaWYgKHByb2ZpbGVTcGFjZSA9PT0gMykge1xuICAgIGNvZGVjICs9ICdDJztcbiAgfVxuXG4gIGNvZGVjICs9IHByb2ZpbGVJZCArIFwiLlwiOyAvLyBmZm1wZWcgZG9lcyB0aGlzIGluIGJpZyBlbmRpYW5cblxuICB2YXIgcHJvZmlsZUNvbXBhdFZhbCA9IHBhcnNlSW50KCgwLCBfYnl0ZUhlbHBlcnMudG9CaW5hcnlTdHJpbmcpKHByb2ZpbGVDb21wYXQpLnNwbGl0KCcnKS5yZXZlcnNlKCkuam9pbignJyksIDIpOyAvLyBhcHBsZSBkb2VzIHRoaXMgaW4gbGl0dGxlIGVuZGlhbi4uLlxuXG4gIGlmIChwcm9maWxlQ29tcGF0VmFsID4gMjU1KSB7XG4gICAgcHJvZmlsZUNvbXBhdFZhbCA9IHBhcnNlSW50KCgwLCBfYnl0ZUhlbHBlcnMudG9CaW5hcnlTdHJpbmcpKHByb2ZpbGVDb21wYXQpLCAyKTtcbiAgfVxuXG4gIGNvZGVjICs9IHByb2ZpbGVDb21wYXRWYWwudG9TdHJpbmcoMTYpICsgXCIuXCI7XG5cbiAgaWYgKHRpZXJGbGFnID09PSAwKSB7XG4gICAgY29kZWMgKz0gJ0wnO1xuICB9IGVsc2Uge1xuICAgIGNvZGVjICs9ICdIJztcbiAgfVxuXG4gIGNvZGVjICs9IGxldmVsSWQ7XG4gIHZhciBjb25zdHJhaW50cyA9ICcnO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY29uc3RyYWludElkcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciB2ID0gY29uc3RyYWludElkc1tpXTtcblxuICAgIGlmICh2KSB7XG4gICAgICBpZiAoY29uc3RyYWludHMpIHtcbiAgICAgICAgY29uc3RyYWludHMgKz0gJy4nO1xuICAgICAgfVxuXG4gICAgICBjb25zdHJhaW50cyArPSB2LnRvU3RyaW5nKDE2KTtcbiAgICB9XG4gIH1cblxuICBpZiAoY29uc3RyYWludHMpIHtcbiAgICBjb2RlYyArPSBcIi5cIiArIGNvbnN0cmFpbnRzO1xuICB9XG5cbiAgcmV0dXJuIGNvZGVjO1xufTtcblxuZXhwb3J0cy5nZXRIdmNDb2RlYyA9IGdldEh2Y0NvZGVjOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@videojs/vhs-utils/cjs/codec-helpers.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@videojs/vhs-utils/cjs/codecs.js":
/*!*******************************************************!*\
  !*** ./node_modules/@videojs/vhs-utils/cjs/codecs.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nvar _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ \"(ssr)/./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.DEFAULT_VIDEO_CODEC = exports.DEFAULT_AUDIO_CODEC = exports.muxerSupportsCodec = exports.browserSupportsCodec = exports.getMimeForCodec = exports.isTextCodec = exports.isAudioCodec = exports.isVideoCodec = exports.codecsFromDefault = exports.parseCodecs = exports.mapLegacyAvcCodecs = exports.translateLegacyCodecs = exports.translateLegacyCodec = void 0;\n\nvar _window = _interopRequireDefault(__webpack_require__(/*! global/window */ \"(ssr)/./node_modules/global/window.js\"));\n\nvar regexs = {\n  // to determine mime types\n  mp4: /^(av0?1|avc0?[1234]|vp0?9|flac|opus|mp3|mp4a|mp4v|stpp.ttml.im1t)/,\n  webm: /^(vp0?[89]|av0?1|opus|vorbis)/,\n  ogg: /^(vp0?[89]|theora|flac|opus|vorbis)/,\n  // to determine if a codec is audio or video\n  video: /^(av0?1|avc0?[1234]|vp0?[89]|hvc1|hev1|theora|mp4v)/,\n  audio: /^(mp4a|flac|vorbis|opus|ac-[34]|ec-3|alac|mp3|speex|aac)/,\n  text: /^(stpp.ttml.im1t)/,\n  // mux.js support regex\n  muxerVideo: /^(avc0?1)/,\n  muxerAudio: /^(mp4a)/,\n  // match nothing as muxer does not support text right now.\n  // there cannot never be a character before the start of a string\n  // so this matches nothing.\n  muxerText: /a^/\n};\nvar mediaTypes = ['video', 'audio', 'text'];\nvar upperMediaTypes = ['Video', 'Audio', 'Text'];\n/**\n * Replace the old apple-style `avc1.<dd>.<dd>` codec string with the standard\n * `avc1.<hhhhhh>`\n *\n * @param {string} codec\n *        Codec string to translate\n * @return {string}\n *         The translated codec string\n */\n\nvar translateLegacyCodec = function translateLegacyCodec(codec) {\n  if (!codec) {\n    return codec;\n  }\n\n  return codec.replace(/avc1\\.(\\d+)\\.(\\d+)/i, function (orig, profile, avcLevel) {\n    var profileHex = ('00' + Number(profile).toString(16)).slice(-2);\n    var avcLevelHex = ('00' + Number(avcLevel).toString(16)).slice(-2);\n    return 'avc1.' + profileHex + '00' + avcLevelHex;\n  });\n};\n/**\n * Replace the old apple-style `avc1.<dd>.<dd>` codec strings with the standard\n * `avc1.<hhhhhh>`\n *\n * @param {string[]} codecs\n *        An array of codec strings to translate\n * @return {string[]}\n *         The translated array of codec strings\n */\n\n\nexports.translateLegacyCodec = translateLegacyCodec;\n\nvar translateLegacyCodecs = function translateLegacyCodecs(codecs) {\n  return codecs.map(translateLegacyCodec);\n};\n/**\n * Replace codecs in the codec string with the old apple-style `avc1.<dd>.<dd>` to the\n * standard `avc1.<hhhhhh>`.\n *\n * @param {string} codecString\n *        The codec string\n * @return {string}\n *         The codec string with old apple-style codecs replaced\n *\n * @private\n */\n\n\nexports.translateLegacyCodecs = translateLegacyCodecs;\n\nvar mapLegacyAvcCodecs = function mapLegacyAvcCodecs(codecString) {\n  return codecString.replace(/avc1\\.(\\d+)\\.(\\d+)/i, function (match) {\n    return translateLegacyCodecs([match])[0];\n  });\n};\n/**\n * @typedef {Object} ParsedCodecInfo\n * @property {number} codecCount\n *           Number of codecs parsed\n * @property {string} [videoCodec]\n *           Parsed video codec (if found)\n * @property {string} [videoObjectTypeIndicator]\n *           Video object type indicator (if found)\n * @property {string|null} audioProfile\n *           Audio profile\n */\n\n/**\n * Parses a codec string to retrieve the number of codecs specified, the video codec and\n * object type indicator, and the audio profile.\n *\n * @param {string} [codecString]\n *        The codec string to parse\n * @return {ParsedCodecInfo}\n *         Parsed codec info\n */\n\n\nexports.mapLegacyAvcCodecs = mapLegacyAvcCodecs;\n\nvar parseCodecs = function parseCodecs(codecString) {\n  if (codecString === void 0) {\n    codecString = '';\n  }\n\n  var codecs = codecString.split(',');\n  var result = [];\n  codecs.forEach(function (codec) {\n    codec = codec.trim();\n    var codecType;\n    mediaTypes.forEach(function (name) {\n      var match = regexs[name].exec(codec.toLowerCase());\n\n      if (!match || match.length <= 1) {\n        return;\n      }\n\n      codecType = name; // maintain codec case\n\n      var type = codec.substring(0, match[1].length);\n      var details = codec.replace(type, '');\n      result.push({\n        type: type,\n        details: details,\n        mediaType: name\n      });\n    });\n\n    if (!codecType) {\n      result.push({\n        type: codec,\n        details: '',\n        mediaType: 'unknown'\n      });\n    }\n  });\n  return result;\n};\n/**\n * Returns a ParsedCodecInfo object for the default alternate audio playlist if there is\n * a default alternate audio playlist for the provided audio group.\n *\n * @param {Object} master\n *        The master playlist\n * @param {string} audioGroupId\n *        ID of the audio group for which to find the default codec info\n * @return {ParsedCodecInfo}\n *         Parsed codec info\n */\n\n\nexports.parseCodecs = parseCodecs;\n\nvar codecsFromDefault = function codecsFromDefault(master, audioGroupId) {\n  if (!master.mediaGroups.AUDIO || !audioGroupId) {\n    return null;\n  }\n\n  var audioGroup = master.mediaGroups.AUDIO[audioGroupId];\n\n  if (!audioGroup) {\n    return null;\n  }\n\n  for (var name in audioGroup) {\n    var audioType = audioGroup[name];\n\n    if (audioType.default && audioType.playlists) {\n      // codec should be the same for all playlists within the audio type\n      return parseCodecs(audioType.playlists[0].attributes.CODECS);\n    }\n  }\n\n  return null;\n};\n\nexports.codecsFromDefault = codecsFromDefault;\n\nvar isVideoCodec = function isVideoCodec(codec) {\n  if (codec === void 0) {\n    codec = '';\n  }\n\n  return regexs.video.test(codec.trim().toLowerCase());\n};\n\nexports.isVideoCodec = isVideoCodec;\n\nvar isAudioCodec = function isAudioCodec(codec) {\n  if (codec === void 0) {\n    codec = '';\n  }\n\n  return regexs.audio.test(codec.trim().toLowerCase());\n};\n\nexports.isAudioCodec = isAudioCodec;\n\nvar isTextCodec = function isTextCodec(codec) {\n  if (codec === void 0) {\n    codec = '';\n  }\n\n  return regexs.text.test(codec.trim().toLowerCase());\n};\n\nexports.isTextCodec = isTextCodec;\n\nvar getMimeForCodec = function getMimeForCodec(codecString) {\n  if (!codecString || typeof codecString !== 'string') {\n    return;\n  }\n\n  var codecs = codecString.toLowerCase().split(',').map(function (c) {\n    return translateLegacyCodec(c.trim());\n  }); // default to video type\n\n  var type = 'video'; // only change to audio type if the only codec we have is\n  // audio\n\n  if (codecs.length === 1 && isAudioCodec(codecs[0])) {\n    type = 'audio';\n  } else if (codecs.length === 1 && isTextCodec(codecs[0])) {\n    // text uses application/<container> for now\n    type = 'application';\n  } // default the container to mp4\n\n\n  var container = 'mp4'; // every codec must be able to go into the container\n  // for that container to be the correct one\n\n  if (codecs.every(function (c) {\n    return regexs.mp4.test(c);\n  })) {\n    container = 'mp4';\n  } else if (codecs.every(function (c) {\n    return regexs.webm.test(c);\n  })) {\n    container = 'webm';\n  } else if (codecs.every(function (c) {\n    return regexs.ogg.test(c);\n  })) {\n    container = 'ogg';\n  }\n\n  return type + \"/\" + container + \";codecs=\\\"\" + codecString + \"\\\"\";\n};\n/**\n * Tests whether the codec is supported by MediaSource. Optionally also tests ManagedMediaSource.\n *\n * @param {string} codecString\n *        Codec to test\n * @param {boolean} [withMMS]\n *        Whether to check if ManagedMediaSource supports it\n * @return {boolean}\n *          Codec is supported\n */\n\n\nexports.getMimeForCodec = getMimeForCodec;\n\nvar browserSupportsCodec = function browserSupportsCodec(codecString, withMMS) {\n  if (codecString === void 0) {\n    codecString = '';\n  }\n\n  if (withMMS === void 0) {\n    withMMS = false;\n  }\n\n  return _window.default.MediaSource && _window.default.MediaSource.isTypeSupported && _window.default.MediaSource.isTypeSupported(getMimeForCodec(codecString)) || withMMS && _window.default.ManagedMediaSource && _window.default.ManagedMediaSource.isTypeSupported && _window.default.ManagedMediaSource.isTypeSupported(getMimeForCodec(codecString)) || false;\n};\n\nexports.browserSupportsCodec = browserSupportsCodec;\n\nvar muxerSupportsCodec = function muxerSupportsCodec(codecString) {\n  if (codecString === void 0) {\n    codecString = '';\n  }\n\n  return codecString.toLowerCase().split(',').every(function (codec) {\n    codec = codec.trim(); // any match is supported.\n\n    for (var i = 0; i < upperMediaTypes.length; i++) {\n      var type = upperMediaTypes[i];\n\n      if (regexs[\"muxer\" + type].test(codec)) {\n        return true;\n      }\n    }\n\n    return false;\n  });\n};\n\nexports.muxerSupportsCodec = muxerSupportsCodec;\nvar DEFAULT_AUDIO_CODEC = 'mp4a.40.2';\nexports.DEFAULT_AUDIO_CODEC = DEFAULT_AUDIO_CODEC;\nvar DEFAULT_VIDEO_CODEC = 'avc1.4d400d';\nexports.DEFAULT_VIDEO_CODEC = DEFAULT_VIDEO_CODEC;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHZpZGVvanMvdmhzLXV0aWxzL2Nqcy9jb2RlY3MuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsNkJBQTZCLG1CQUFPLENBQUMsMEhBQThDOztBQUVuRiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRiwyQkFBMkIsR0FBRywyQkFBMkIsR0FBRywwQkFBMEIsR0FBRyw0QkFBNEIsR0FBRyx1QkFBdUIsR0FBRyxtQkFBbUIsR0FBRyxvQkFBb0IsR0FBRyxvQkFBb0IsR0FBRyx5QkFBeUIsR0FBRyxtQkFBbUIsR0FBRywwQkFBMEIsR0FBRyw2QkFBNkIsR0FBRyw0QkFBNEI7O0FBRWpXLHFDQUFxQyxtQkFBTyxDQUFDLDREQUFlOztBQUU1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQjtBQUNBLFlBQVk7QUFDWjtBQUNBOzs7QUFHQSw0QkFBNEI7O0FBRTVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSw2QkFBNkI7O0FBRTdCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsUUFBUTtBQUN0QjtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBLGNBQWMsYUFBYTtBQUMzQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7OztBQUdBLDBCQUEwQjs7QUFFMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHdCQUF3Qjs7QUFFeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7O0FBR0EsbUJBQW1COztBQUVuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEseUJBQXlCOztBQUV6QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG9CQUFvQjs7QUFFcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxvQkFBb0I7O0FBRXBCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsbUJBQW1COztBQUVuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRyxHQUFHOztBQUVOLHNCQUFzQjtBQUN0Qjs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSix5QkFBeUI7QUFDekI7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLElBQUk7QUFDSjtBQUNBLEdBQUc7QUFDSDtBQUNBLElBQUk7QUFDSjtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBLFlBQVk7QUFDWjtBQUNBOzs7QUFHQSx1QkFBdUI7O0FBRXZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDRCQUE0Qjs7QUFFNUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQkFBMEI7O0FBRTFCLG9CQUFvQiw0QkFBNEI7QUFDaEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7O0FBRUEsMEJBQTBCO0FBQzFCO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0EsMkJBQTJCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktdjAtcHJvamVjdC8uL25vZGVfbW9kdWxlcy9AdmlkZW9qcy92aHMtdXRpbHMvY2pzL2NvZGVjcy5qcz9lYzk4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuREVGQVVMVF9WSURFT19DT0RFQyA9IGV4cG9ydHMuREVGQVVMVF9BVURJT19DT0RFQyA9IGV4cG9ydHMubXV4ZXJTdXBwb3J0c0NvZGVjID0gZXhwb3J0cy5icm93c2VyU3VwcG9ydHNDb2RlYyA9IGV4cG9ydHMuZ2V0TWltZUZvckNvZGVjID0gZXhwb3J0cy5pc1RleHRDb2RlYyA9IGV4cG9ydHMuaXNBdWRpb0NvZGVjID0gZXhwb3J0cy5pc1ZpZGVvQ29kZWMgPSBleHBvcnRzLmNvZGVjc0Zyb21EZWZhdWx0ID0gZXhwb3J0cy5wYXJzZUNvZGVjcyA9IGV4cG9ydHMubWFwTGVnYWN5QXZjQ29kZWNzID0gZXhwb3J0cy50cmFuc2xhdGVMZWdhY3lDb2RlY3MgPSBleHBvcnRzLnRyYW5zbGF0ZUxlZ2FjeUNvZGVjID0gdm9pZCAwO1xuXG52YXIgX3dpbmRvdyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcImdsb2JhbC93aW5kb3dcIikpO1xuXG52YXIgcmVnZXhzID0ge1xuICAvLyB0byBkZXRlcm1pbmUgbWltZSB0eXBlc1xuICBtcDQ6IC9eKGF2MD8xfGF2YzA/WzEyMzRdfHZwMD85fGZsYWN8b3B1c3xtcDN8bXA0YXxtcDR2fHN0cHAudHRtbC5pbTF0KS8sXG4gIHdlYm06IC9eKHZwMD9bODldfGF2MD8xfG9wdXN8dm9yYmlzKS8sXG4gIG9nZzogL14odnAwP1s4OV18dGhlb3JhfGZsYWN8b3B1c3x2b3JiaXMpLyxcbiAgLy8gdG8gZGV0ZXJtaW5lIGlmIGEgY29kZWMgaXMgYXVkaW8gb3IgdmlkZW9cbiAgdmlkZW86IC9eKGF2MD8xfGF2YzA/WzEyMzRdfHZwMD9bODldfGh2YzF8aGV2MXx0aGVvcmF8bXA0dikvLFxuICBhdWRpbzogL14obXA0YXxmbGFjfHZvcmJpc3xvcHVzfGFjLVszNF18ZWMtM3xhbGFjfG1wM3xzcGVleHxhYWMpLyxcbiAgdGV4dDogL14oc3RwcC50dG1sLmltMXQpLyxcbiAgLy8gbXV4LmpzIHN1cHBvcnQgcmVnZXhcbiAgbXV4ZXJWaWRlbzogL14oYXZjMD8xKS8sXG4gIG11eGVyQXVkaW86IC9eKG1wNGEpLyxcbiAgLy8gbWF0Y2ggbm90aGluZyBhcyBtdXhlciBkb2VzIG5vdCBzdXBwb3J0IHRleHQgcmlnaHQgbm93LlxuICAvLyB0aGVyZSBjYW5ub3QgbmV2ZXIgYmUgYSBjaGFyYWN0ZXIgYmVmb3JlIHRoZSBzdGFydCBvZiBhIHN0cmluZ1xuICAvLyBzbyB0aGlzIG1hdGNoZXMgbm90aGluZy5cbiAgbXV4ZXJUZXh0OiAvYV4vXG59O1xudmFyIG1lZGlhVHlwZXMgPSBbJ3ZpZGVvJywgJ2F1ZGlvJywgJ3RleHQnXTtcbnZhciB1cHBlck1lZGlhVHlwZXMgPSBbJ1ZpZGVvJywgJ0F1ZGlvJywgJ1RleHQnXTtcbi8qKlxuICogUmVwbGFjZSB0aGUgb2xkIGFwcGxlLXN0eWxlIGBhdmMxLjxkZD4uPGRkPmAgY29kZWMgc3RyaW5nIHdpdGggdGhlIHN0YW5kYXJkXG4gKiBgYXZjMS48aGhoaGhoPmBcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gY29kZWNcbiAqICAgICAgICBDb2RlYyBzdHJpbmcgdG8gdHJhbnNsYXRlXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKiAgICAgICAgIFRoZSB0cmFuc2xhdGVkIGNvZGVjIHN0cmluZ1xuICovXG5cbnZhciB0cmFuc2xhdGVMZWdhY3lDb2RlYyA9IGZ1bmN0aW9uIHRyYW5zbGF0ZUxlZ2FjeUNvZGVjKGNvZGVjKSB7XG4gIGlmICghY29kZWMpIHtcbiAgICByZXR1cm4gY29kZWM7XG4gIH1cblxuICByZXR1cm4gY29kZWMucmVwbGFjZSgvYXZjMVxcLihcXGQrKVxcLihcXGQrKS9pLCBmdW5jdGlvbiAob3JpZywgcHJvZmlsZSwgYXZjTGV2ZWwpIHtcbiAgICB2YXIgcHJvZmlsZUhleCA9ICgnMDAnICsgTnVtYmVyKHByb2ZpbGUpLnRvU3RyaW5nKDE2KSkuc2xpY2UoLTIpO1xuICAgIHZhciBhdmNMZXZlbEhleCA9ICgnMDAnICsgTnVtYmVyKGF2Y0xldmVsKS50b1N0cmluZygxNikpLnNsaWNlKC0yKTtcbiAgICByZXR1cm4gJ2F2YzEuJyArIHByb2ZpbGVIZXggKyAnMDAnICsgYXZjTGV2ZWxIZXg7XG4gIH0pO1xufTtcbi8qKlxuICogUmVwbGFjZSB0aGUgb2xkIGFwcGxlLXN0eWxlIGBhdmMxLjxkZD4uPGRkPmAgY29kZWMgc3RyaW5ncyB3aXRoIHRoZSBzdGFuZGFyZFxuICogYGF2YzEuPGhoaGhoaD5gXG4gKlxuICogQHBhcmFtIHtzdHJpbmdbXX0gY29kZWNzXG4gKiAgICAgICAgQW4gYXJyYXkgb2YgY29kZWMgc3RyaW5ncyB0byB0cmFuc2xhdGVcbiAqIEByZXR1cm4ge3N0cmluZ1tdfVxuICogICAgICAgICBUaGUgdHJhbnNsYXRlZCBhcnJheSBvZiBjb2RlYyBzdHJpbmdzXG4gKi9cblxuXG5leHBvcnRzLnRyYW5zbGF0ZUxlZ2FjeUNvZGVjID0gdHJhbnNsYXRlTGVnYWN5Q29kZWM7XG5cbnZhciB0cmFuc2xhdGVMZWdhY3lDb2RlY3MgPSBmdW5jdGlvbiB0cmFuc2xhdGVMZWdhY3lDb2RlY3MoY29kZWNzKSB7XG4gIHJldHVybiBjb2RlY3MubWFwKHRyYW5zbGF0ZUxlZ2FjeUNvZGVjKTtcbn07XG4vKipcbiAqIFJlcGxhY2UgY29kZWNzIGluIHRoZSBjb2RlYyBzdHJpbmcgd2l0aCB0aGUgb2xkIGFwcGxlLXN0eWxlIGBhdmMxLjxkZD4uPGRkPmAgdG8gdGhlXG4gKiBzdGFuZGFyZCBgYXZjMS48aGhoaGhoPmAuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGNvZGVjU3RyaW5nXG4gKiAgICAgICAgVGhlIGNvZGVjIHN0cmluZ1xuICogQHJldHVybiB7c3RyaW5nfVxuICogICAgICAgICBUaGUgY29kZWMgc3RyaW5nIHdpdGggb2xkIGFwcGxlLXN0eWxlIGNvZGVjcyByZXBsYWNlZFxuICpcbiAqIEBwcml2YXRlXG4gKi9cblxuXG5leHBvcnRzLnRyYW5zbGF0ZUxlZ2FjeUNvZGVjcyA9IHRyYW5zbGF0ZUxlZ2FjeUNvZGVjcztcblxudmFyIG1hcExlZ2FjeUF2Y0NvZGVjcyA9IGZ1bmN0aW9uIG1hcExlZ2FjeUF2Y0NvZGVjcyhjb2RlY1N0cmluZykge1xuICByZXR1cm4gY29kZWNTdHJpbmcucmVwbGFjZSgvYXZjMVxcLihcXGQrKVxcLihcXGQrKS9pLCBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICByZXR1cm4gdHJhbnNsYXRlTGVnYWN5Q29kZWNzKFttYXRjaF0pWzBdO1xuICB9KTtcbn07XG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFBhcnNlZENvZGVjSW5mb1xuICogQHByb3BlcnR5IHtudW1iZXJ9IGNvZGVjQ291bnRcbiAqICAgICAgICAgICBOdW1iZXIgb2YgY29kZWNzIHBhcnNlZFxuICogQHByb3BlcnR5IHtzdHJpbmd9IFt2aWRlb0NvZGVjXVxuICogICAgICAgICAgIFBhcnNlZCB2aWRlbyBjb2RlYyAoaWYgZm91bmQpXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW3ZpZGVvT2JqZWN0VHlwZUluZGljYXRvcl1cbiAqICAgICAgICAgICBWaWRlbyBvYmplY3QgdHlwZSBpbmRpY2F0b3IgKGlmIGZvdW5kKVxuICogQHByb3BlcnR5IHtzdHJpbmd8bnVsbH0gYXVkaW9Qcm9maWxlXG4gKiAgICAgICAgICAgQXVkaW8gcHJvZmlsZVxuICovXG5cbi8qKlxuICogUGFyc2VzIGEgY29kZWMgc3RyaW5nIHRvIHJldHJpZXZlIHRoZSBudW1iZXIgb2YgY29kZWNzIHNwZWNpZmllZCwgdGhlIHZpZGVvIGNvZGVjIGFuZFxuICogb2JqZWN0IHR5cGUgaW5kaWNhdG9yLCBhbmQgdGhlIGF1ZGlvIHByb2ZpbGUuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IFtjb2RlY1N0cmluZ11cbiAqICAgICAgICBUaGUgY29kZWMgc3RyaW5nIHRvIHBhcnNlXG4gKiBAcmV0dXJuIHtQYXJzZWRDb2RlY0luZm99XG4gKiAgICAgICAgIFBhcnNlZCBjb2RlYyBpbmZvXG4gKi9cblxuXG5leHBvcnRzLm1hcExlZ2FjeUF2Y0NvZGVjcyA9IG1hcExlZ2FjeUF2Y0NvZGVjcztcblxudmFyIHBhcnNlQ29kZWNzID0gZnVuY3Rpb24gcGFyc2VDb2RlY3MoY29kZWNTdHJpbmcpIHtcbiAgaWYgKGNvZGVjU3RyaW5nID09PSB2b2lkIDApIHtcbiAgICBjb2RlY1N0cmluZyA9ICcnO1xuICB9XG5cbiAgdmFyIGNvZGVjcyA9IGNvZGVjU3RyaW5nLnNwbGl0KCcsJyk7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgY29kZWNzLmZvckVhY2goZnVuY3Rpb24gKGNvZGVjKSB7XG4gICAgY29kZWMgPSBjb2RlYy50cmltKCk7XG4gICAgdmFyIGNvZGVjVHlwZTtcbiAgICBtZWRpYVR5cGVzLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIHZhciBtYXRjaCA9IHJlZ2V4c1tuYW1lXS5leGVjKGNvZGVjLnRvTG93ZXJDYXNlKCkpO1xuXG4gICAgICBpZiAoIW1hdGNoIHx8IG1hdGNoLmxlbmd0aCA8PSAxKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29kZWNUeXBlID0gbmFtZTsgLy8gbWFpbnRhaW4gY29kZWMgY2FzZVxuXG4gICAgICB2YXIgdHlwZSA9IGNvZGVjLnN1YnN0cmluZygwLCBtYXRjaFsxXS5sZW5ndGgpO1xuICAgICAgdmFyIGRldGFpbHMgPSBjb2RlYy5yZXBsYWNlKHR5cGUsICcnKTtcbiAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgZGV0YWlsczogZGV0YWlscyxcbiAgICAgICAgbWVkaWFUeXBlOiBuYW1lXG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGlmICghY29kZWNUeXBlKSB7XG4gICAgICByZXN1bHQucHVzaCh7XG4gICAgICAgIHR5cGU6IGNvZGVjLFxuICAgICAgICBkZXRhaWxzOiAnJyxcbiAgICAgICAgbWVkaWFUeXBlOiAndW5rbm93bidcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuLyoqXG4gKiBSZXR1cm5zIGEgUGFyc2VkQ29kZWNJbmZvIG9iamVjdCBmb3IgdGhlIGRlZmF1bHQgYWx0ZXJuYXRlIGF1ZGlvIHBsYXlsaXN0IGlmIHRoZXJlIGlzXG4gKiBhIGRlZmF1bHQgYWx0ZXJuYXRlIGF1ZGlvIHBsYXlsaXN0IGZvciB0aGUgcHJvdmlkZWQgYXVkaW8gZ3JvdXAuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG1hc3RlclxuICogICAgICAgIFRoZSBtYXN0ZXIgcGxheWxpc3RcbiAqIEBwYXJhbSB7c3RyaW5nfSBhdWRpb0dyb3VwSWRcbiAqICAgICAgICBJRCBvZiB0aGUgYXVkaW8gZ3JvdXAgZm9yIHdoaWNoIHRvIGZpbmQgdGhlIGRlZmF1bHQgY29kZWMgaW5mb1xuICogQHJldHVybiB7UGFyc2VkQ29kZWNJbmZvfVxuICogICAgICAgICBQYXJzZWQgY29kZWMgaW5mb1xuICovXG5cblxuZXhwb3J0cy5wYXJzZUNvZGVjcyA9IHBhcnNlQ29kZWNzO1xuXG52YXIgY29kZWNzRnJvbURlZmF1bHQgPSBmdW5jdGlvbiBjb2RlY3NGcm9tRGVmYXVsdChtYXN0ZXIsIGF1ZGlvR3JvdXBJZCkge1xuICBpZiAoIW1hc3Rlci5tZWRpYUdyb3Vwcy5BVURJTyB8fCAhYXVkaW9Hcm91cElkKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgYXVkaW9Hcm91cCA9IG1hc3Rlci5tZWRpYUdyb3Vwcy5BVURJT1thdWRpb0dyb3VwSWRdO1xuXG4gIGlmICghYXVkaW9Hcm91cCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZm9yICh2YXIgbmFtZSBpbiBhdWRpb0dyb3VwKSB7XG4gICAgdmFyIGF1ZGlvVHlwZSA9IGF1ZGlvR3JvdXBbbmFtZV07XG5cbiAgICBpZiAoYXVkaW9UeXBlLmRlZmF1bHQgJiYgYXVkaW9UeXBlLnBsYXlsaXN0cykge1xuICAgICAgLy8gY29kZWMgc2hvdWxkIGJlIHRoZSBzYW1lIGZvciBhbGwgcGxheWxpc3RzIHdpdGhpbiB0aGUgYXVkaW8gdHlwZVxuICAgICAgcmV0dXJuIHBhcnNlQ29kZWNzKGF1ZGlvVHlwZS5wbGF5bGlzdHNbMF0uYXR0cmlidXRlcy5DT0RFQ1MpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufTtcblxuZXhwb3J0cy5jb2RlY3NGcm9tRGVmYXVsdCA9IGNvZGVjc0Zyb21EZWZhdWx0O1xuXG52YXIgaXNWaWRlb0NvZGVjID0gZnVuY3Rpb24gaXNWaWRlb0NvZGVjKGNvZGVjKSB7XG4gIGlmIChjb2RlYyA9PT0gdm9pZCAwKSB7XG4gICAgY29kZWMgPSAnJztcbiAgfVxuXG4gIHJldHVybiByZWdleHMudmlkZW8udGVzdChjb2RlYy50cmltKCkudG9Mb3dlckNhc2UoKSk7XG59O1xuXG5leHBvcnRzLmlzVmlkZW9Db2RlYyA9IGlzVmlkZW9Db2RlYztcblxudmFyIGlzQXVkaW9Db2RlYyA9IGZ1bmN0aW9uIGlzQXVkaW9Db2RlYyhjb2RlYykge1xuICBpZiAoY29kZWMgPT09IHZvaWQgMCkge1xuICAgIGNvZGVjID0gJyc7XG4gIH1cblxuICByZXR1cm4gcmVnZXhzLmF1ZGlvLnRlc3QoY29kZWMudHJpbSgpLnRvTG93ZXJDYXNlKCkpO1xufTtcblxuZXhwb3J0cy5pc0F1ZGlvQ29kZWMgPSBpc0F1ZGlvQ29kZWM7XG5cbnZhciBpc1RleHRDb2RlYyA9IGZ1bmN0aW9uIGlzVGV4dENvZGVjKGNvZGVjKSB7XG4gIGlmIChjb2RlYyA9PT0gdm9pZCAwKSB7XG4gICAgY29kZWMgPSAnJztcbiAgfVxuXG4gIHJldHVybiByZWdleHMudGV4dC50ZXN0KGNvZGVjLnRyaW0oKS50b0xvd2VyQ2FzZSgpKTtcbn07XG5cbmV4cG9ydHMuaXNUZXh0Q29kZWMgPSBpc1RleHRDb2RlYztcblxudmFyIGdldE1pbWVGb3JDb2RlYyA9IGZ1bmN0aW9uIGdldE1pbWVGb3JDb2RlYyhjb2RlY1N0cmluZykge1xuICBpZiAoIWNvZGVjU3RyaW5nIHx8IHR5cGVvZiBjb2RlY1N0cmluZyAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgY29kZWNzID0gY29kZWNTdHJpbmcudG9Mb3dlckNhc2UoKS5zcGxpdCgnLCcpLm1hcChmdW5jdGlvbiAoYykge1xuICAgIHJldHVybiB0cmFuc2xhdGVMZWdhY3lDb2RlYyhjLnRyaW0oKSk7XG4gIH0pOyAvLyBkZWZhdWx0IHRvIHZpZGVvIHR5cGVcblxuICB2YXIgdHlwZSA9ICd2aWRlbyc7IC8vIG9ubHkgY2hhbmdlIHRvIGF1ZGlvIHR5cGUgaWYgdGhlIG9ubHkgY29kZWMgd2UgaGF2ZSBpc1xuICAvLyBhdWRpb1xuXG4gIGlmIChjb2RlY3MubGVuZ3RoID09PSAxICYmIGlzQXVkaW9Db2RlYyhjb2RlY3NbMF0pKSB7XG4gICAgdHlwZSA9ICdhdWRpbyc7XG4gIH0gZWxzZSBpZiAoY29kZWNzLmxlbmd0aCA9PT0gMSAmJiBpc1RleHRDb2RlYyhjb2RlY3NbMF0pKSB7XG4gICAgLy8gdGV4dCB1c2VzIGFwcGxpY2F0aW9uLzxjb250YWluZXI+IGZvciBub3dcbiAgICB0eXBlID0gJ2FwcGxpY2F0aW9uJztcbiAgfSAvLyBkZWZhdWx0IHRoZSBjb250YWluZXIgdG8gbXA0XG5cblxuICB2YXIgY29udGFpbmVyID0gJ21wNCc7IC8vIGV2ZXJ5IGNvZGVjIG11c3QgYmUgYWJsZSB0byBnbyBpbnRvIHRoZSBjb250YWluZXJcbiAgLy8gZm9yIHRoYXQgY29udGFpbmVyIHRvIGJlIHRoZSBjb3JyZWN0IG9uZVxuXG4gIGlmIChjb2RlY3MuZXZlcnkoZnVuY3Rpb24gKGMpIHtcbiAgICByZXR1cm4gcmVnZXhzLm1wNC50ZXN0KGMpO1xuICB9KSkge1xuICAgIGNvbnRhaW5lciA9ICdtcDQnO1xuICB9IGVsc2UgaWYgKGNvZGVjcy5ldmVyeShmdW5jdGlvbiAoYykge1xuICAgIHJldHVybiByZWdleHMud2VibS50ZXN0KGMpO1xuICB9KSkge1xuICAgIGNvbnRhaW5lciA9ICd3ZWJtJztcbiAgfSBlbHNlIGlmIChjb2RlY3MuZXZlcnkoZnVuY3Rpb24gKGMpIHtcbiAgICByZXR1cm4gcmVnZXhzLm9nZy50ZXN0KGMpO1xuICB9KSkge1xuICAgIGNvbnRhaW5lciA9ICdvZ2cnO1xuICB9XG5cbiAgcmV0dXJuIHR5cGUgKyBcIi9cIiArIGNvbnRhaW5lciArIFwiO2NvZGVjcz1cXFwiXCIgKyBjb2RlY1N0cmluZyArIFwiXFxcIlwiO1xufTtcbi8qKlxuICogVGVzdHMgd2hldGhlciB0aGUgY29kZWMgaXMgc3VwcG9ydGVkIGJ5IE1lZGlhU291cmNlLiBPcHRpb25hbGx5IGFsc28gdGVzdHMgTWFuYWdlZE1lZGlhU291cmNlLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb2RlY1N0cmluZ1xuICogICAgICAgIENvZGVjIHRvIHRlc3RcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3dpdGhNTVNdXG4gKiAgICAgICAgV2hldGhlciB0byBjaGVjayBpZiBNYW5hZ2VkTWVkaWFTb3VyY2Ugc3VwcG9ydHMgaXRcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKiAgICAgICAgICBDb2RlYyBpcyBzdXBwb3J0ZWRcbiAqL1xuXG5cbmV4cG9ydHMuZ2V0TWltZUZvckNvZGVjID0gZ2V0TWltZUZvckNvZGVjO1xuXG52YXIgYnJvd3NlclN1cHBvcnRzQ29kZWMgPSBmdW5jdGlvbiBicm93c2VyU3VwcG9ydHNDb2RlYyhjb2RlY1N0cmluZywgd2l0aE1NUykge1xuICBpZiAoY29kZWNTdHJpbmcgPT09IHZvaWQgMCkge1xuICAgIGNvZGVjU3RyaW5nID0gJyc7XG4gIH1cblxuICBpZiAod2l0aE1NUyA9PT0gdm9pZCAwKSB7XG4gICAgd2l0aE1NUyA9IGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIF93aW5kb3cuZGVmYXVsdC5NZWRpYVNvdXJjZSAmJiBfd2luZG93LmRlZmF1bHQuTWVkaWFTb3VyY2UuaXNUeXBlU3VwcG9ydGVkICYmIF93aW5kb3cuZGVmYXVsdC5NZWRpYVNvdXJjZS5pc1R5cGVTdXBwb3J0ZWQoZ2V0TWltZUZvckNvZGVjKGNvZGVjU3RyaW5nKSkgfHwgd2l0aE1NUyAmJiBfd2luZG93LmRlZmF1bHQuTWFuYWdlZE1lZGlhU291cmNlICYmIF93aW5kb3cuZGVmYXVsdC5NYW5hZ2VkTWVkaWFTb3VyY2UuaXNUeXBlU3VwcG9ydGVkICYmIF93aW5kb3cuZGVmYXVsdC5NYW5hZ2VkTWVkaWFTb3VyY2UuaXNUeXBlU3VwcG9ydGVkKGdldE1pbWVGb3JDb2RlYyhjb2RlY1N0cmluZykpIHx8IGZhbHNlO1xufTtcblxuZXhwb3J0cy5icm93c2VyU3VwcG9ydHNDb2RlYyA9IGJyb3dzZXJTdXBwb3J0c0NvZGVjO1xuXG52YXIgbXV4ZXJTdXBwb3J0c0NvZGVjID0gZnVuY3Rpb24gbXV4ZXJTdXBwb3J0c0NvZGVjKGNvZGVjU3RyaW5nKSB7XG4gIGlmIChjb2RlY1N0cmluZyA9PT0gdm9pZCAwKSB7XG4gICAgY29kZWNTdHJpbmcgPSAnJztcbiAgfVxuXG4gIHJldHVybiBjb2RlY1N0cmluZy50b0xvd2VyQ2FzZSgpLnNwbGl0KCcsJykuZXZlcnkoZnVuY3Rpb24gKGNvZGVjKSB7XG4gICAgY29kZWMgPSBjb2RlYy50cmltKCk7IC8vIGFueSBtYXRjaCBpcyBzdXBwb3J0ZWQuXG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHVwcGVyTWVkaWFUeXBlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHR5cGUgPSB1cHBlck1lZGlhVHlwZXNbaV07XG5cbiAgICAgIGlmIChyZWdleHNbXCJtdXhlclwiICsgdHlwZV0udGVzdChjb2RlYykpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9KTtcbn07XG5cbmV4cG9ydHMubXV4ZXJTdXBwb3J0c0NvZGVjID0gbXV4ZXJTdXBwb3J0c0NvZGVjO1xudmFyIERFRkFVTFRfQVVESU9fQ09ERUMgPSAnbXA0YS40MC4yJztcbmV4cG9ydHMuREVGQVVMVF9BVURJT19DT0RFQyA9IERFRkFVTFRfQVVESU9fQ09ERUM7XG52YXIgREVGQVVMVF9WSURFT19DT0RFQyA9ICdhdmMxLjRkNDAwZCc7XG5leHBvcnRzLkRFRkFVTFRfVklERU9fQ09ERUMgPSBERUZBVUxUX1ZJREVPX0NPREVDOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@videojs/vhs-utils/cjs/codecs.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@videojs/vhs-utils/cjs/containers.js":
/*!***********************************************************!*\
  !*** ./node_modules/@videojs/vhs-utils/cjs/containers.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.isLikelyFmp4MediaSegment = exports.detectContainerForBytes = exports.isLikely = void 0;\n\nvar _byteHelpers = __webpack_require__(/*! ./byte-helpers.js */ \"(ssr)/./node_modules/@videojs/vhs-utils/cjs/byte-helpers.js\");\n\nvar _mp4Helpers = __webpack_require__(/*! ./mp4-helpers.js */ \"(ssr)/./node_modules/@videojs/vhs-utils/cjs/mp4-helpers.js\");\n\nvar _ebmlHelpers = __webpack_require__(/*! ./ebml-helpers.js */ \"(ssr)/./node_modules/@videojs/vhs-utils/cjs/ebml-helpers.js\");\n\nvar _id3Helpers = __webpack_require__(/*! ./id3-helpers.js */ \"(ssr)/./node_modules/@videojs/vhs-utils/cjs/id3-helpers.js\");\n\nvar _nalHelpers = __webpack_require__(/*! ./nal-helpers.js */ \"(ssr)/./node_modules/@videojs/vhs-utils/cjs/nal-helpers.js\");\n\nvar CONSTANTS = {\n  // \"webm\" string literal in hex\n  'webm': (0, _byteHelpers.toUint8)([0x77, 0x65, 0x62, 0x6d]),\n  // \"matroska\" string literal in hex\n  'matroska': (0, _byteHelpers.toUint8)([0x6d, 0x61, 0x74, 0x72, 0x6f, 0x73, 0x6b, 0x61]),\n  // \"fLaC\" string literal in hex\n  'flac': (0, _byteHelpers.toUint8)([0x66, 0x4c, 0x61, 0x43]),\n  // \"OggS\" string literal in hex\n  'ogg': (0, _byteHelpers.toUint8)([0x4f, 0x67, 0x67, 0x53]),\n  // ac-3 sync byte, also works for ec-3 as that is simply a codec\n  // of ac-3\n  'ac3': (0, _byteHelpers.toUint8)([0x0b, 0x77]),\n  // \"RIFF\" string literal in hex used for wav and avi\n  'riff': (0, _byteHelpers.toUint8)([0x52, 0x49, 0x46, 0x46]),\n  // \"AVI\" string literal in hex\n  'avi': (0, _byteHelpers.toUint8)([0x41, 0x56, 0x49]),\n  // \"WAVE\" string literal in hex\n  'wav': (0, _byteHelpers.toUint8)([0x57, 0x41, 0x56, 0x45]),\n  // \"ftyp3g\" string literal in hex\n  '3gp': (0, _byteHelpers.toUint8)([0x66, 0x74, 0x79, 0x70, 0x33, 0x67]),\n  // \"ftyp\" string literal in hex\n  'mp4': (0, _byteHelpers.toUint8)([0x66, 0x74, 0x79, 0x70]),\n  // \"styp\" string literal in hex\n  'fmp4': (0, _byteHelpers.toUint8)([0x73, 0x74, 0x79, 0x70]),\n  // \"ftypqt\" string literal in hex\n  'mov': (0, _byteHelpers.toUint8)([0x66, 0x74, 0x79, 0x70, 0x71, 0x74]),\n  // moov string literal in hex\n  'moov': (0, _byteHelpers.toUint8)([0x6D, 0x6F, 0x6F, 0x76]),\n  // moof string literal in hex\n  'moof': (0, _byteHelpers.toUint8)([0x6D, 0x6F, 0x6F, 0x66])\n};\nvar _isLikely = {\n  aac: function aac(bytes) {\n    var offset = (0, _id3Helpers.getId3Offset)(bytes);\n    return (0, _byteHelpers.bytesMatch)(bytes, [0xFF, 0x10], {\n      offset: offset,\n      mask: [0xFF, 0x16]\n    });\n  },\n  mp3: function mp3(bytes) {\n    var offset = (0, _id3Helpers.getId3Offset)(bytes);\n    return (0, _byteHelpers.bytesMatch)(bytes, [0xFF, 0x02], {\n      offset: offset,\n      mask: [0xFF, 0x06]\n    });\n  },\n  webm: function webm(bytes) {\n    var docType = (0, _ebmlHelpers.findEbml)(bytes, [_ebmlHelpers.EBML_TAGS.EBML, _ebmlHelpers.EBML_TAGS.DocType])[0]; // check if DocType EBML tag is webm\n\n    return (0, _byteHelpers.bytesMatch)(docType, CONSTANTS.webm);\n  },\n  mkv: function mkv(bytes) {\n    var docType = (0, _ebmlHelpers.findEbml)(bytes, [_ebmlHelpers.EBML_TAGS.EBML, _ebmlHelpers.EBML_TAGS.DocType])[0]; // check if DocType EBML tag is matroska\n\n    return (0, _byteHelpers.bytesMatch)(docType, CONSTANTS.matroska);\n  },\n  mp4: function mp4(bytes) {\n    // if this file is another base media file format, it is not mp4\n    if (_isLikely['3gp'](bytes) || _isLikely.mov(bytes)) {\n      return false;\n    } // if this file starts with a ftyp or styp box its mp4\n\n\n    if ((0, _byteHelpers.bytesMatch)(bytes, CONSTANTS.mp4, {\n      offset: 4\n    }) || (0, _byteHelpers.bytesMatch)(bytes, CONSTANTS.fmp4, {\n      offset: 4\n    })) {\n      return true;\n    } // if this file starts with a moof/moov box its mp4\n\n\n    if ((0, _byteHelpers.bytesMatch)(bytes, CONSTANTS.moof, {\n      offset: 4\n    }) || (0, _byteHelpers.bytesMatch)(bytes, CONSTANTS.moov, {\n      offset: 4\n    })) {\n      return true;\n    }\n  },\n  mov: function mov(bytes) {\n    return (0, _byteHelpers.bytesMatch)(bytes, CONSTANTS.mov, {\n      offset: 4\n    });\n  },\n  '3gp': function gp(bytes) {\n    return (0, _byteHelpers.bytesMatch)(bytes, CONSTANTS['3gp'], {\n      offset: 4\n    });\n  },\n  ac3: function ac3(bytes) {\n    var offset = (0, _id3Helpers.getId3Offset)(bytes);\n    return (0, _byteHelpers.bytesMatch)(bytes, CONSTANTS.ac3, {\n      offset: offset\n    });\n  },\n  ts: function ts(bytes) {\n    if (bytes.length < 189 && bytes.length >= 1) {\n      return bytes[0] === 0x47;\n    }\n\n    var i = 0; // check the first 376 bytes for two matching sync bytes\n\n    while (i + 188 < bytes.length && i < 188) {\n      if (bytes[i] === 0x47 && bytes[i + 188] === 0x47) {\n        return true;\n      }\n\n      i += 1;\n    }\n\n    return false;\n  },\n  flac: function flac(bytes) {\n    var offset = (0, _id3Helpers.getId3Offset)(bytes);\n    return (0, _byteHelpers.bytesMatch)(bytes, CONSTANTS.flac, {\n      offset: offset\n    });\n  },\n  ogg: function ogg(bytes) {\n    return (0, _byteHelpers.bytesMatch)(bytes, CONSTANTS.ogg);\n  },\n  avi: function avi(bytes) {\n    return (0, _byteHelpers.bytesMatch)(bytes, CONSTANTS.riff) && (0, _byteHelpers.bytesMatch)(bytes, CONSTANTS.avi, {\n      offset: 8\n    });\n  },\n  wav: function wav(bytes) {\n    return (0, _byteHelpers.bytesMatch)(bytes, CONSTANTS.riff) && (0, _byteHelpers.bytesMatch)(bytes, CONSTANTS.wav, {\n      offset: 8\n    });\n  },\n  'h264': function h264(bytes) {\n    // find seq_parameter_set_rbsp\n    return (0, _nalHelpers.findH264Nal)(bytes, 7, 3).length;\n  },\n  'h265': function h265(bytes) {\n    // find video_parameter_set_rbsp or seq_parameter_set_rbsp\n    return (0, _nalHelpers.findH265Nal)(bytes, [32, 33], 3).length;\n  }\n}; // get all the isLikely functions\n// but make sure 'ts' is above h264 and h265\n// but below everything else as it is the least specific\n\nvar isLikelyTypes = Object.keys(_isLikely) // remove ts, h264, h265\n.filter(function (t) {\n  return t !== 'ts' && t !== 'h264' && t !== 'h265';\n}) // add it back to the bottom\n.concat(['ts', 'h264', 'h265']); // make sure we are dealing with uint8 data.\n\nisLikelyTypes.forEach(function (type) {\n  var isLikelyFn = _isLikely[type];\n\n  _isLikely[type] = function (bytes) {\n    return isLikelyFn((0, _byteHelpers.toUint8)(bytes));\n  };\n}); // export after wrapping\n\nvar isLikely = _isLikely; // A useful list of file signatures can be found here\n// https://en.wikipedia.org/wiki/List_of_file_signatures\n\nexports.isLikely = isLikely;\n\nvar detectContainerForBytes = function detectContainerForBytes(bytes) {\n  bytes = (0, _byteHelpers.toUint8)(bytes);\n\n  for (var i = 0; i < isLikelyTypes.length; i++) {\n    var type = isLikelyTypes[i];\n\n    if (isLikely[type](bytes)) {\n      return type;\n    }\n  }\n\n  return '';\n}; // fmp4 is not a container\n\n\nexports.detectContainerForBytes = detectContainerForBytes;\n\nvar isLikelyFmp4MediaSegment = function isLikelyFmp4MediaSegment(bytes) {\n  return (0, _mp4Helpers.findBox)(bytes, ['moof']).length > 0;\n};\n\nexports.isLikelyFmp4MediaSegment = isLikelyFmp4MediaSegment;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHZpZGVvanMvdmhzLXV0aWxzL2Nqcy9jb250YWluZXJzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGLGdDQUFnQyxHQUFHLCtCQUErQixHQUFHLGdCQUFnQjs7QUFFckYsbUJBQW1CLG1CQUFPLENBQUMsc0ZBQW1COztBQUU5QyxrQkFBa0IsbUJBQU8sQ0FBQyxvRkFBa0I7O0FBRTVDLG1CQUFtQixtQkFBTyxDQUFDLHNGQUFtQjs7QUFFOUMsa0JBQWtCLG1CQUFPLENBQUMsb0ZBQWtCOztBQUU1QyxrQkFBa0IsbUJBQU8sQ0FBQyxvRkFBa0I7O0FBRTVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBLHVIQUF1SDs7QUFFdkg7QUFDQSxHQUFHO0FBQ0g7QUFDQSx1SEFBdUg7O0FBRXZIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWU7O0FBRWY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELGlDQUFpQzs7QUFFakM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEdBQUc7O0FBRUosMEJBQTBCO0FBQzFCOztBQUVBLGdCQUFnQjs7QUFFaEI7QUFDQTs7QUFFQSxrQkFBa0IsMEJBQTBCO0FBQzVDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7O0FBR0gsK0JBQStCOztBQUUvQjtBQUNBO0FBQ0E7O0FBRUEsZ0NBQWdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktdjAtcHJvamVjdC8uL25vZGVfbW9kdWxlcy9AdmlkZW9qcy92aHMtdXRpbHMvY2pzL2NvbnRhaW5lcnMuanM/ZWVlMiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuaXNMaWtlbHlGbXA0TWVkaWFTZWdtZW50ID0gZXhwb3J0cy5kZXRlY3RDb250YWluZXJGb3JCeXRlcyA9IGV4cG9ydHMuaXNMaWtlbHkgPSB2b2lkIDA7XG5cbnZhciBfYnl0ZUhlbHBlcnMgPSByZXF1aXJlKFwiLi9ieXRlLWhlbHBlcnMuanNcIik7XG5cbnZhciBfbXA0SGVscGVycyA9IHJlcXVpcmUoXCIuL21wNC1oZWxwZXJzLmpzXCIpO1xuXG52YXIgX2VibWxIZWxwZXJzID0gcmVxdWlyZShcIi4vZWJtbC1oZWxwZXJzLmpzXCIpO1xuXG52YXIgX2lkM0hlbHBlcnMgPSByZXF1aXJlKFwiLi9pZDMtaGVscGVycy5qc1wiKTtcblxudmFyIF9uYWxIZWxwZXJzID0gcmVxdWlyZShcIi4vbmFsLWhlbHBlcnMuanNcIik7XG5cbnZhciBDT05TVEFOVFMgPSB7XG4gIC8vIFwid2VibVwiIHN0cmluZyBsaXRlcmFsIGluIGhleFxuICAnd2VibSc6ICgwLCBfYnl0ZUhlbHBlcnMudG9VaW50OCkoWzB4NzcsIDB4NjUsIDB4NjIsIDB4NmRdKSxcbiAgLy8gXCJtYXRyb3NrYVwiIHN0cmluZyBsaXRlcmFsIGluIGhleFxuICAnbWF0cm9za2EnOiAoMCwgX2J5dGVIZWxwZXJzLnRvVWludDgpKFsweDZkLCAweDYxLCAweDc0LCAweDcyLCAweDZmLCAweDczLCAweDZiLCAweDYxXSksXG4gIC8vIFwiZkxhQ1wiIHN0cmluZyBsaXRlcmFsIGluIGhleFxuICAnZmxhYyc6ICgwLCBfYnl0ZUhlbHBlcnMudG9VaW50OCkoWzB4NjYsIDB4NGMsIDB4NjEsIDB4NDNdKSxcbiAgLy8gXCJPZ2dTXCIgc3RyaW5nIGxpdGVyYWwgaW4gaGV4XG4gICdvZ2cnOiAoMCwgX2J5dGVIZWxwZXJzLnRvVWludDgpKFsweDRmLCAweDY3LCAweDY3LCAweDUzXSksXG4gIC8vIGFjLTMgc3luYyBieXRlLCBhbHNvIHdvcmtzIGZvciBlYy0zIGFzIHRoYXQgaXMgc2ltcGx5IGEgY29kZWNcbiAgLy8gb2YgYWMtM1xuICAnYWMzJzogKDAsIF9ieXRlSGVscGVycy50b1VpbnQ4KShbMHgwYiwgMHg3N10pLFxuICAvLyBcIlJJRkZcIiBzdHJpbmcgbGl0ZXJhbCBpbiBoZXggdXNlZCBmb3Igd2F2IGFuZCBhdmlcbiAgJ3JpZmYnOiAoMCwgX2J5dGVIZWxwZXJzLnRvVWludDgpKFsweDUyLCAweDQ5LCAweDQ2LCAweDQ2XSksXG4gIC8vIFwiQVZJXCIgc3RyaW5nIGxpdGVyYWwgaW4gaGV4XG4gICdhdmknOiAoMCwgX2J5dGVIZWxwZXJzLnRvVWludDgpKFsweDQxLCAweDU2LCAweDQ5XSksXG4gIC8vIFwiV0FWRVwiIHN0cmluZyBsaXRlcmFsIGluIGhleFxuICAnd2F2JzogKDAsIF9ieXRlSGVscGVycy50b1VpbnQ4KShbMHg1NywgMHg0MSwgMHg1NiwgMHg0NV0pLFxuICAvLyBcImZ0eXAzZ1wiIHN0cmluZyBsaXRlcmFsIGluIGhleFxuICAnM2dwJzogKDAsIF9ieXRlSGVscGVycy50b1VpbnQ4KShbMHg2NiwgMHg3NCwgMHg3OSwgMHg3MCwgMHgzMywgMHg2N10pLFxuICAvLyBcImZ0eXBcIiBzdHJpbmcgbGl0ZXJhbCBpbiBoZXhcbiAgJ21wNCc6ICgwLCBfYnl0ZUhlbHBlcnMudG9VaW50OCkoWzB4NjYsIDB4NzQsIDB4NzksIDB4NzBdKSxcbiAgLy8gXCJzdHlwXCIgc3RyaW5nIGxpdGVyYWwgaW4gaGV4XG4gICdmbXA0JzogKDAsIF9ieXRlSGVscGVycy50b1VpbnQ4KShbMHg3MywgMHg3NCwgMHg3OSwgMHg3MF0pLFxuICAvLyBcImZ0eXBxdFwiIHN0cmluZyBsaXRlcmFsIGluIGhleFxuICAnbW92JzogKDAsIF9ieXRlSGVscGVycy50b1VpbnQ4KShbMHg2NiwgMHg3NCwgMHg3OSwgMHg3MCwgMHg3MSwgMHg3NF0pLFxuICAvLyBtb292IHN0cmluZyBsaXRlcmFsIGluIGhleFxuICAnbW9vdic6ICgwLCBfYnl0ZUhlbHBlcnMudG9VaW50OCkoWzB4NkQsIDB4NkYsIDB4NkYsIDB4NzZdKSxcbiAgLy8gbW9vZiBzdHJpbmcgbGl0ZXJhbCBpbiBoZXhcbiAgJ21vb2YnOiAoMCwgX2J5dGVIZWxwZXJzLnRvVWludDgpKFsweDZELCAweDZGLCAweDZGLCAweDY2XSlcbn07XG52YXIgX2lzTGlrZWx5ID0ge1xuICBhYWM6IGZ1bmN0aW9uIGFhYyhieXRlcykge1xuICAgIHZhciBvZmZzZXQgPSAoMCwgX2lkM0hlbHBlcnMuZ2V0SWQzT2Zmc2V0KShieXRlcyk7XG4gICAgcmV0dXJuICgwLCBfYnl0ZUhlbHBlcnMuYnl0ZXNNYXRjaCkoYnl0ZXMsIFsweEZGLCAweDEwXSwge1xuICAgICAgb2Zmc2V0OiBvZmZzZXQsXG4gICAgICBtYXNrOiBbMHhGRiwgMHgxNl1cbiAgICB9KTtcbiAgfSxcbiAgbXAzOiBmdW5jdGlvbiBtcDMoYnl0ZXMpIHtcbiAgICB2YXIgb2Zmc2V0ID0gKDAsIF9pZDNIZWxwZXJzLmdldElkM09mZnNldCkoYnl0ZXMpO1xuICAgIHJldHVybiAoMCwgX2J5dGVIZWxwZXJzLmJ5dGVzTWF0Y2gpKGJ5dGVzLCBbMHhGRiwgMHgwMl0sIHtcbiAgICAgIG9mZnNldDogb2Zmc2V0LFxuICAgICAgbWFzazogWzB4RkYsIDB4MDZdXG4gICAgfSk7XG4gIH0sXG4gIHdlYm06IGZ1bmN0aW9uIHdlYm0oYnl0ZXMpIHtcbiAgICB2YXIgZG9jVHlwZSA9ICgwLCBfZWJtbEhlbHBlcnMuZmluZEVibWwpKGJ5dGVzLCBbX2VibWxIZWxwZXJzLkVCTUxfVEFHUy5FQk1MLCBfZWJtbEhlbHBlcnMuRUJNTF9UQUdTLkRvY1R5cGVdKVswXTsgLy8gY2hlY2sgaWYgRG9jVHlwZSBFQk1MIHRhZyBpcyB3ZWJtXG5cbiAgICByZXR1cm4gKDAsIF9ieXRlSGVscGVycy5ieXRlc01hdGNoKShkb2NUeXBlLCBDT05TVEFOVFMud2VibSk7XG4gIH0sXG4gIG1rdjogZnVuY3Rpb24gbWt2KGJ5dGVzKSB7XG4gICAgdmFyIGRvY1R5cGUgPSAoMCwgX2VibWxIZWxwZXJzLmZpbmRFYm1sKShieXRlcywgW19lYm1sSGVscGVycy5FQk1MX1RBR1MuRUJNTCwgX2VibWxIZWxwZXJzLkVCTUxfVEFHUy5Eb2NUeXBlXSlbMF07IC8vIGNoZWNrIGlmIERvY1R5cGUgRUJNTCB0YWcgaXMgbWF0cm9za2FcblxuICAgIHJldHVybiAoMCwgX2J5dGVIZWxwZXJzLmJ5dGVzTWF0Y2gpKGRvY1R5cGUsIENPTlNUQU5UUy5tYXRyb3NrYSk7XG4gIH0sXG4gIG1wNDogZnVuY3Rpb24gbXA0KGJ5dGVzKSB7XG4gICAgLy8gaWYgdGhpcyBmaWxlIGlzIGFub3RoZXIgYmFzZSBtZWRpYSBmaWxlIGZvcm1hdCwgaXQgaXMgbm90IG1wNFxuICAgIGlmIChfaXNMaWtlbHlbJzNncCddKGJ5dGVzKSB8fCBfaXNMaWtlbHkubW92KGJ5dGVzKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gLy8gaWYgdGhpcyBmaWxlIHN0YXJ0cyB3aXRoIGEgZnR5cCBvciBzdHlwIGJveCBpdHMgbXA0XG5cblxuICAgIGlmICgoMCwgX2J5dGVIZWxwZXJzLmJ5dGVzTWF0Y2gpKGJ5dGVzLCBDT05TVEFOVFMubXA0LCB7XG4gICAgICBvZmZzZXQ6IDRcbiAgICB9KSB8fCAoMCwgX2J5dGVIZWxwZXJzLmJ5dGVzTWF0Y2gpKGJ5dGVzLCBDT05TVEFOVFMuZm1wNCwge1xuICAgICAgb2Zmc2V0OiA0XG4gICAgfSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gLy8gaWYgdGhpcyBmaWxlIHN0YXJ0cyB3aXRoIGEgbW9vZi9tb292IGJveCBpdHMgbXA0XG5cblxuICAgIGlmICgoMCwgX2J5dGVIZWxwZXJzLmJ5dGVzTWF0Y2gpKGJ5dGVzLCBDT05TVEFOVFMubW9vZiwge1xuICAgICAgb2Zmc2V0OiA0XG4gICAgfSkgfHwgKDAsIF9ieXRlSGVscGVycy5ieXRlc01hdGNoKShieXRlcywgQ09OU1RBTlRTLm1vb3YsIHtcbiAgICAgIG9mZnNldDogNFxuICAgIH0pKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0sXG4gIG1vdjogZnVuY3Rpb24gbW92KGJ5dGVzKSB7XG4gICAgcmV0dXJuICgwLCBfYnl0ZUhlbHBlcnMuYnl0ZXNNYXRjaCkoYnl0ZXMsIENPTlNUQU5UUy5tb3YsIHtcbiAgICAgIG9mZnNldDogNFxuICAgIH0pO1xuICB9LFxuICAnM2dwJzogZnVuY3Rpb24gZ3AoYnl0ZXMpIHtcbiAgICByZXR1cm4gKDAsIF9ieXRlSGVscGVycy5ieXRlc01hdGNoKShieXRlcywgQ09OU1RBTlRTWyczZ3AnXSwge1xuICAgICAgb2Zmc2V0OiA0XG4gICAgfSk7XG4gIH0sXG4gIGFjMzogZnVuY3Rpb24gYWMzKGJ5dGVzKSB7XG4gICAgdmFyIG9mZnNldCA9ICgwLCBfaWQzSGVscGVycy5nZXRJZDNPZmZzZXQpKGJ5dGVzKTtcbiAgICByZXR1cm4gKDAsIF9ieXRlSGVscGVycy5ieXRlc01hdGNoKShieXRlcywgQ09OU1RBTlRTLmFjMywge1xuICAgICAgb2Zmc2V0OiBvZmZzZXRcbiAgICB9KTtcbiAgfSxcbiAgdHM6IGZ1bmN0aW9uIHRzKGJ5dGVzKSB7XG4gICAgaWYgKGJ5dGVzLmxlbmd0aCA8IDE4OSAmJiBieXRlcy5sZW5ndGggPj0gMSkge1xuICAgICAgcmV0dXJuIGJ5dGVzWzBdID09PSAweDQ3O1xuICAgIH1cblxuICAgIHZhciBpID0gMDsgLy8gY2hlY2sgdGhlIGZpcnN0IDM3NiBieXRlcyBmb3IgdHdvIG1hdGNoaW5nIHN5bmMgYnl0ZXNcblxuICAgIHdoaWxlIChpICsgMTg4IDwgYnl0ZXMubGVuZ3RoICYmIGkgPCAxODgpIHtcbiAgICAgIGlmIChieXRlc1tpXSA9PT0gMHg0NyAmJiBieXRlc1tpICsgMTg4XSA9PT0gMHg0Nykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaSArPSAxO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcbiAgZmxhYzogZnVuY3Rpb24gZmxhYyhieXRlcykge1xuICAgIHZhciBvZmZzZXQgPSAoMCwgX2lkM0hlbHBlcnMuZ2V0SWQzT2Zmc2V0KShieXRlcyk7XG4gICAgcmV0dXJuICgwLCBfYnl0ZUhlbHBlcnMuYnl0ZXNNYXRjaCkoYnl0ZXMsIENPTlNUQU5UUy5mbGFjLCB7XG4gICAgICBvZmZzZXQ6IG9mZnNldFxuICAgIH0pO1xuICB9LFxuICBvZ2c6IGZ1bmN0aW9uIG9nZyhieXRlcykge1xuICAgIHJldHVybiAoMCwgX2J5dGVIZWxwZXJzLmJ5dGVzTWF0Y2gpKGJ5dGVzLCBDT05TVEFOVFMub2dnKTtcbiAgfSxcbiAgYXZpOiBmdW5jdGlvbiBhdmkoYnl0ZXMpIHtcbiAgICByZXR1cm4gKDAsIF9ieXRlSGVscGVycy5ieXRlc01hdGNoKShieXRlcywgQ09OU1RBTlRTLnJpZmYpICYmICgwLCBfYnl0ZUhlbHBlcnMuYnl0ZXNNYXRjaCkoYnl0ZXMsIENPTlNUQU5UUy5hdmksIHtcbiAgICAgIG9mZnNldDogOFxuICAgIH0pO1xuICB9LFxuICB3YXY6IGZ1bmN0aW9uIHdhdihieXRlcykge1xuICAgIHJldHVybiAoMCwgX2J5dGVIZWxwZXJzLmJ5dGVzTWF0Y2gpKGJ5dGVzLCBDT05TVEFOVFMucmlmZikgJiYgKDAsIF9ieXRlSGVscGVycy5ieXRlc01hdGNoKShieXRlcywgQ09OU1RBTlRTLndhdiwge1xuICAgICAgb2Zmc2V0OiA4XG4gICAgfSk7XG4gIH0sXG4gICdoMjY0JzogZnVuY3Rpb24gaDI2NChieXRlcykge1xuICAgIC8vIGZpbmQgc2VxX3BhcmFtZXRlcl9zZXRfcmJzcFxuICAgIHJldHVybiAoMCwgX25hbEhlbHBlcnMuZmluZEgyNjROYWwpKGJ5dGVzLCA3LCAzKS5sZW5ndGg7XG4gIH0sXG4gICdoMjY1JzogZnVuY3Rpb24gaDI2NShieXRlcykge1xuICAgIC8vIGZpbmQgdmlkZW9fcGFyYW1ldGVyX3NldF9yYnNwIG9yIHNlcV9wYXJhbWV0ZXJfc2V0X3Jic3BcbiAgICByZXR1cm4gKDAsIF9uYWxIZWxwZXJzLmZpbmRIMjY1TmFsKShieXRlcywgWzMyLCAzM10sIDMpLmxlbmd0aDtcbiAgfVxufTsgLy8gZ2V0IGFsbCB0aGUgaXNMaWtlbHkgZnVuY3Rpb25zXG4vLyBidXQgbWFrZSBzdXJlICd0cycgaXMgYWJvdmUgaDI2NCBhbmQgaDI2NVxuLy8gYnV0IGJlbG93IGV2ZXJ5dGhpbmcgZWxzZSBhcyBpdCBpcyB0aGUgbGVhc3Qgc3BlY2lmaWNcblxudmFyIGlzTGlrZWx5VHlwZXMgPSBPYmplY3Qua2V5cyhfaXNMaWtlbHkpIC8vIHJlbW92ZSB0cywgaDI2NCwgaDI2NVxuLmZpbHRlcihmdW5jdGlvbiAodCkge1xuICByZXR1cm4gdCAhPT0gJ3RzJyAmJiB0ICE9PSAnaDI2NCcgJiYgdCAhPT0gJ2gyNjUnO1xufSkgLy8gYWRkIGl0IGJhY2sgdG8gdGhlIGJvdHRvbVxuLmNvbmNhdChbJ3RzJywgJ2gyNjQnLCAnaDI2NSddKTsgLy8gbWFrZSBzdXJlIHdlIGFyZSBkZWFsaW5nIHdpdGggdWludDggZGF0YS5cblxuaXNMaWtlbHlUeXBlcy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gIHZhciBpc0xpa2VseUZuID0gX2lzTGlrZWx5W3R5cGVdO1xuXG4gIF9pc0xpa2VseVt0eXBlXSA9IGZ1bmN0aW9uIChieXRlcykge1xuICAgIHJldHVybiBpc0xpa2VseUZuKCgwLCBfYnl0ZUhlbHBlcnMudG9VaW50OCkoYnl0ZXMpKTtcbiAgfTtcbn0pOyAvLyBleHBvcnQgYWZ0ZXIgd3JhcHBpbmdcblxudmFyIGlzTGlrZWx5ID0gX2lzTGlrZWx5OyAvLyBBIHVzZWZ1bCBsaXN0IG9mIGZpbGUgc2lnbmF0dXJlcyBjYW4gYmUgZm91bmQgaGVyZVxuLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGlzdF9vZl9maWxlX3NpZ25hdHVyZXNcblxuZXhwb3J0cy5pc0xpa2VseSA9IGlzTGlrZWx5O1xuXG52YXIgZGV0ZWN0Q29udGFpbmVyRm9yQnl0ZXMgPSBmdW5jdGlvbiBkZXRlY3RDb250YWluZXJGb3JCeXRlcyhieXRlcykge1xuICBieXRlcyA9ICgwLCBfYnl0ZUhlbHBlcnMudG9VaW50OCkoYnl0ZXMpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgaXNMaWtlbHlUeXBlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciB0eXBlID0gaXNMaWtlbHlUeXBlc1tpXTtcblxuICAgIGlmIChpc0xpa2VseVt0eXBlXShieXRlcykpIHtcbiAgICAgIHJldHVybiB0eXBlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAnJztcbn07IC8vIGZtcDQgaXMgbm90IGEgY29udGFpbmVyXG5cblxuZXhwb3J0cy5kZXRlY3RDb250YWluZXJGb3JCeXRlcyA9IGRldGVjdENvbnRhaW5lckZvckJ5dGVzO1xuXG52YXIgaXNMaWtlbHlGbXA0TWVkaWFTZWdtZW50ID0gZnVuY3Rpb24gaXNMaWtlbHlGbXA0TWVkaWFTZWdtZW50KGJ5dGVzKSB7XG4gIHJldHVybiAoMCwgX21wNEhlbHBlcnMuZmluZEJveCkoYnl0ZXMsIFsnbW9vZiddKS5sZW5ndGggPiAwO1xufTtcblxuZXhwb3J0cy5pc0xpa2VseUZtcDRNZWRpYVNlZ21lbnQgPSBpc0xpa2VseUZtcDRNZWRpYVNlZ21lbnQ7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@videojs/vhs-utils/cjs/containers.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@videojs/vhs-utils/cjs/decode-b64-to-uint8-array.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@videojs/vhs-utils/cjs/decode-b64-to-uint8-array.js ***!
  \**************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("\n\nvar _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ \"(ssr)/./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = decodeB64ToUint8Array;\n\nvar _window = _interopRequireDefault(__webpack_require__(/*! global/window */ \"(ssr)/./node_modules/global/window.js\"));\n\nvar atob = function atob(s) {\n  return _window.default.atob ? _window.default.atob(s) : Buffer.from(s, 'base64').toString('binary');\n};\n\nfunction decodeB64ToUint8Array(b64Text) {\n  var decodedString = atob(b64Text);\n  var array = new Uint8Array(decodedString.length);\n\n  for (var i = 0; i < decodedString.length; i++) {\n    array[i] = decodedString.charCodeAt(i);\n  }\n\n  return array;\n}\n\nmodule.exports = exports.default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHZpZGVvanMvdmhzLXV0aWxzL2Nqcy9kZWNvZGUtYjY0LXRvLXVpbnQ4LWFycmF5LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDZCQUE2QixtQkFBTyxDQUFDLDBIQUE4Qzs7QUFFbkYsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0JBQWU7O0FBRWYscUNBQXFDLG1CQUFPLENBQUMsNERBQWU7O0FBRTVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLDBCQUEwQjtBQUM1QztBQUNBOztBQUVBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS12MC1wcm9qZWN0Ly4vbm9kZV9tb2R1bGVzL0B2aWRlb2pzL3Zocy11dGlscy9janMvZGVjb2RlLWI2NC10by11aW50OC1hcnJheS5qcz9hOTU1Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlY29kZUI2NFRvVWludDhBcnJheTtcblxudmFyIF93aW5kb3cgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJnbG9iYWwvd2luZG93XCIpKTtcblxudmFyIGF0b2IgPSBmdW5jdGlvbiBhdG9iKHMpIHtcbiAgcmV0dXJuIF93aW5kb3cuZGVmYXVsdC5hdG9iID8gX3dpbmRvdy5kZWZhdWx0LmF0b2IocykgOiBCdWZmZXIuZnJvbShzLCAnYmFzZTY0JykudG9TdHJpbmcoJ2JpbmFyeScpO1xufTtcblxuZnVuY3Rpb24gZGVjb2RlQjY0VG9VaW50OEFycmF5KGI2NFRleHQpIHtcbiAgdmFyIGRlY29kZWRTdHJpbmcgPSBhdG9iKGI2NFRleHQpO1xuICB2YXIgYXJyYXkgPSBuZXcgVWludDhBcnJheShkZWNvZGVkU3RyaW5nLmxlbmd0aCk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBkZWNvZGVkU3RyaW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgYXJyYXlbaV0gPSBkZWNvZGVkU3RyaW5nLmNoYXJDb2RlQXQoaSk7XG4gIH1cblxuICByZXR1cm4gYXJyYXk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@videojs/vhs-utils/cjs/decode-b64-to-uint8-array.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@videojs/vhs-utils/cjs/ebml-helpers.js":
/*!*************************************************************!*\
  !*** ./node_modules/@videojs/vhs-utils/cjs/ebml-helpers.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.parseData = exports.parseTracks = exports.decodeBlock = exports.findEbml = exports.EBML_TAGS = void 0;\n\nvar _byteHelpers = __webpack_require__(/*! ./byte-helpers */ \"(ssr)/./node_modules/@videojs/vhs-utils/cjs/byte-helpers.js\");\n\nvar _codecHelpers = __webpack_require__(/*! ./codec-helpers.js */ \"(ssr)/./node_modules/@videojs/vhs-utils/cjs/codec-helpers.js\");\n\n// relevant specs for this parser:\n// https://matroska-org.github.io/libebml/specs.html\n// https://www.matroska.org/technical/elements.html\n// https://www.webmproject.org/docs/container/\nvar EBML_TAGS = {\n  EBML: (0, _byteHelpers.toUint8)([0x1A, 0x45, 0xDF, 0xA3]),\n  DocType: (0, _byteHelpers.toUint8)([0x42, 0x82]),\n  Segment: (0, _byteHelpers.toUint8)([0x18, 0x53, 0x80, 0x67]),\n  SegmentInfo: (0, _byteHelpers.toUint8)([0x15, 0x49, 0xA9, 0x66]),\n  Tracks: (0, _byteHelpers.toUint8)([0x16, 0x54, 0xAE, 0x6B]),\n  Track: (0, _byteHelpers.toUint8)([0xAE]),\n  TrackNumber: (0, _byteHelpers.toUint8)([0xd7]),\n  DefaultDuration: (0, _byteHelpers.toUint8)([0x23, 0xe3, 0x83]),\n  TrackEntry: (0, _byteHelpers.toUint8)([0xAE]),\n  TrackType: (0, _byteHelpers.toUint8)([0x83]),\n  FlagDefault: (0, _byteHelpers.toUint8)([0x88]),\n  CodecID: (0, _byteHelpers.toUint8)([0x86]),\n  CodecPrivate: (0, _byteHelpers.toUint8)([0x63, 0xA2]),\n  VideoTrack: (0, _byteHelpers.toUint8)([0xe0]),\n  AudioTrack: (0, _byteHelpers.toUint8)([0xe1]),\n  // Not used yet, but will be used for live webm/mkv\n  // see https://www.matroska.org/technical/basics.html#block-structure\n  // see https://www.matroska.org/technical/basics.html#simpleblock-structure\n  Cluster: (0, _byteHelpers.toUint8)([0x1F, 0x43, 0xB6, 0x75]),\n  Timestamp: (0, _byteHelpers.toUint8)([0xE7]),\n  TimestampScale: (0, _byteHelpers.toUint8)([0x2A, 0xD7, 0xB1]),\n  BlockGroup: (0, _byteHelpers.toUint8)([0xA0]),\n  BlockDuration: (0, _byteHelpers.toUint8)([0x9B]),\n  Block: (0, _byteHelpers.toUint8)([0xA1]),\n  SimpleBlock: (0, _byteHelpers.toUint8)([0xA3])\n};\n/**\n * This is a simple table to determine the length\n * of things in ebml. The length is one based (starts at 1,\n * rather than zero) and for every zero bit before a one bit\n * we add one to length. We also need this table because in some\n * case we have to xor all the length bits from another value.\n */\n\nexports.EBML_TAGS = EBML_TAGS;\nvar LENGTH_TABLE = [128, 64, 32, 16, 8, 4, 2, 1];\n\nvar getLength = function getLength(byte) {\n  var len = 1;\n\n  for (var i = 0; i < LENGTH_TABLE.length; i++) {\n    if (byte & LENGTH_TABLE[i]) {\n      break;\n    }\n\n    len++;\n  }\n\n  return len;\n}; // length in ebml is stored in the first 4 to 8 bits\n// of the first byte. 4 for the id length and 8 for the\n// data size length. Length is measured by converting the number to binary\n// then 1 + the number of zeros before a 1 is encountered starting\n// from the left.\n\n\nvar getvint = function getvint(bytes, offset, removeLength, signed) {\n  if (removeLength === void 0) {\n    removeLength = true;\n  }\n\n  if (signed === void 0) {\n    signed = false;\n  }\n\n  var length = getLength(bytes[offset]);\n  var valueBytes = bytes.subarray(offset, offset + length); // NOTE that we do **not** subarray here because we need to copy these bytes\n  // as they will be modified below to remove the dataSizeLen bits and we do not\n  // want to modify the original data. normally we could just call slice on\n  // uint8array but ie 11 does not support that...\n\n  if (removeLength) {\n    valueBytes = Array.prototype.slice.call(bytes, offset, offset + length);\n    valueBytes[0] ^= LENGTH_TABLE[length - 1];\n  }\n\n  return {\n    length: length,\n    value: (0, _byteHelpers.bytesToNumber)(valueBytes, {\n      signed: signed\n    }),\n    bytes: valueBytes\n  };\n};\n\nvar normalizePath = function normalizePath(path) {\n  if (typeof path === 'string') {\n    return path.match(/.{1,2}/g).map(function (p) {\n      return normalizePath(p);\n    });\n  }\n\n  if (typeof path === 'number') {\n    return (0, _byteHelpers.numberToBytes)(path);\n  }\n\n  return path;\n};\n\nvar normalizePaths = function normalizePaths(paths) {\n  if (!Array.isArray(paths)) {\n    return [normalizePath(paths)];\n  }\n\n  return paths.map(function (p) {\n    return normalizePath(p);\n  });\n};\n\nvar getInfinityDataSize = function getInfinityDataSize(id, bytes, offset) {\n  if (offset >= bytes.length) {\n    return bytes.length;\n  }\n\n  var innerid = getvint(bytes, offset, false);\n\n  if ((0, _byteHelpers.bytesMatch)(id.bytes, innerid.bytes)) {\n    return offset;\n  }\n\n  var dataHeader = getvint(bytes, offset + innerid.length);\n  return getInfinityDataSize(id, bytes, offset + dataHeader.length + dataHeader.value + innerid.length);\n};\n/**\n * Notes on the EBLM format.\n *\n * EBLM uses \"vints\" tags. Every vint tag contains\n * two parts\n *\n * 1. The length from the first byte. You get this by\n *    converting the byte to binary and counting the zeros\n *    before a 1. Then you add 1 to that. Examples\n *    00011111 = length 4 because there are 3 zeros before a 1.\n *    00100000 = length 3 because there are 2 zeros before a 1.\n *    00000011 = length 7 because there are 6 zeros before a 1.\n *\n * 2. The bits used for length are removed from the first byte\n *    Then all the bytes are merged into a value. NOTE: this\n *    is not the case for id ebml tags as there id includes\n *    length bits.\n *\n */\n\n\nvar findEbml = function findEbml(bytes, paths) {\n  paths = normalizePaths(paths);\n  bytes = (0, _byteHelpers.toUint8)(bytes);\n  var results = [];\n\n  if (!paths.length) {\n    return results;\n  }\n\n  var i = 0;\n\n  while (i < bytes.length) {\n    var id = getvint(bytes, i, false);\n    var dataHeader = getvint(bytes, i + id.length);\n    var dataStart = i + id.length + dataHeader.length; // dataSize is unknown or this is a live stream\n\n    if (dataHeader.value === 0x7f) {\n      dataHeader.value = getInfinityDataSize(id, bytes, dataStart);\n\n      if (dataHeader.value !== bytes.length) {\n        dataHeader.value -= dataStart;\n      }\n    }\n\n    var dataEnd = dataStart + dataHeader.value > bytes.length ? bytes.length : dataStart + dataHeader.value;\n    var data = bytes.subarray(dataStart, dataEnd);\n\n    if ((0, _byteHelpers.bytesMatch)(paths[0], id.bytes)) {\n      if (paths.length === 1) {\n        // this is the end of the paths and we've found the tag we were\n        // looking for\n        results.push(data);\n      } else {\n        // recursively search for the next tag inside of the data\n        // of this one\n        results = results.concat(findEbml(data, paths.slice(1)));\n      }\n    }\n\n    var totalLength = id.length + dataHeader.length + data.length; // move past this tag entirely, we are not looking for it\n\n    i += totalLength;\n  }\n\n  return results;\n}; // see https://www.matroska.org/technical/basics.html#block-structure\n\n\nexports.findEbml = findEbml;\n\nvar decodeBlock = function decodeBlock(block, type, timestampScale, clusterTimestamp) {\n  var duration;\n\n  if (type === 'group') {\n    duration = findEbml(block, [EBML_TAGS.BlockDuration])[0];\n\n    if (duration) {\n      duration = (0, _byteHelpers.bytesToNumber)(duration);\n      duration = 1 / timestampScale * duration * timestampScale / 1000;\n    }\n\n    block = findEbml(block, [EBML_TAGS.Block])[0];\n    type = 'block'; // treat data as a block after this point\n  }\n\n  var dv = new DataView(block.buffer, block.byteOffset, block.byteLength);\n  var trackNumber = getvint(block, 0);\n  var timestamp = dv.getInt16(trackNumber.length, false);\n  var flags = block[trackNumber.length + 2];\n  var data = block.subarray(trackNumber.length + 3); // pts/dts in seconds\n\n  var ptsdts = 1 / timestampScale * (clusterTimestamp + timestamp) * timestampScale / 1000; // return the frame\n\n  var parsed = {\n    duration: duration,\n    trackNumber: trackNumber.value,\n    keyframe: type === 'simple' && flags >> 7 === 1,\n    invisible: (flags & 0x08) >> 3 === 1,\n    lacing: (flags & 0x06) >> 1,\n    discardable: type === 'simple' && (flags & 0x01) === 1,\n    frames: [],\n    pts: ptsdts,\n    dts: ptsdts,\n    timestamp: timestamp\n  };\n\n  if (!parsed.lacing) {\n    parsed.frames.push(data);\n    return parsed;\n  }\n\n  var numberOfFrames = data[0] + 1;\n  var frameSizes = [];\n  var offset = 1; // Fixed\n\n  if (parsed.lacing === 2) {\n    var sizeOfFrame = (data.length - offset) / numberOfFrames;\n\n    for (var i = 0; i < numberOfFrames; i++) {\n      frameSizes.push(sizeOfFrame);\n    }\n  } // xiph\n\n\n  if (parsed.lacing === 1) {\n    for (var _i = 0; _i < numberOfFrames - 1; _i++) {\n      var size = 0;\n\n      do {\n        size += data[offset];\n        offset++;\n      } while (data[offset - 1] === 0xFF);\n\n      frameSizes.push(size);\n    }\n  } // ebml\n\n\n  if (parsed.lacing === 3) {\n    // first vint is unsinged\n    // after that vints are singed and\n    // based on a compounding size\n    var _size = 0;\n\n    for (var _i2 = 0; _i2 < numberOfFrames - 1; _i2++) {\n      var vint = _i2 === 0 ? getvint(data, offset) : getvint(data, offset, true, true);\n      _size += vint.value;\n      frameSizes.push(_size);\n      offset += vint.length;\n    }\n  }\n\n  frameSizes.forEach(function (size) {\n    parsed.frames.push(data.subarray(offset, offset + size));\n    offset += size;\n  });\n  return parsed;\n}; // VP9 Codec Feature Metadata (CodecPrivate)\n// https://www.webmproject.org/docs/container/\n\n\nexports.decodeBlock = decodeBlock;\n\nvar parseVp9Private = function parseVp9Private(bytes) {\n  var i = 0;\n  var params = {};\n\n  while (i < bytes.length) {\n    var id = bytes[i] & 0x7f;\n    var len = bytes[i + 1];\n    var val = void 0;\n\n    if (len === 1) {\n      val = bytes[i + 2];\n    } else {\n      val = bytes.subarray(i + 2, i + 2 + len);\n    }\n\n    if (id === 1) {\n      params.profile = val;\n    } else if (id === 2) {\n      params.level = val;\n    } else if (id === 3) {\n      params.bitDepth = val;\n    } else if (id === 4) {\n      params.chromaSubsampling = val;\n    } else {\n      params[id] = val;\n    }\n\n    i += 2 + len;\n  }\n\n  return params;\n};\n\nvar parseTracks = function parseTracks(bytes) {\n  bytes = (0, _byteHelpers.toUint8)(bytes);\n  var decodedTracks = [];\n  var tracks = findEbml(bytes, [EBML_TAGS.Segment, EBML_TAGS.Tracks, EBML_TAGS.Track]);\n\n  if (!tracks.length) {\n    tracks = findEbml(bytes, [EBML_TAGS.Tracks, EBML_TAGS.Track]);\n  }\n\n  if (!tracks.length) {\n    tracks = findEbml(bytes, [EBML_TAGS.Track]);\n  }\n\n  if (!tracks.length) {\n    return decodedTracks;\n  }\n\n  tracks.forEach(function (track) {\n    var trackType = findEbml(track, EBML_TAGS.TrackType)[0];\n\n    if (!trackType || !trackType.length) {\n      return;\n    } // 1 is video, 2 is audio, 17 is subtitle\n    // other values are unimportant in this context\n\n\n    if (trackType[0] === 1) {\n      trackType = 'video';\n    } else if (trackType[0] === 2) {\n      trackType = 'audio';\n    } else if (trackType[0] === 17) {\n      trackType = 'subtitle';\n    } else {\n      return;\n    } // todo parse language\n\n\n    var decodedTrack = {\n      rawCodec: (0, _byteHelpers.bytesToString)(findEbml(track, [EBML_TAGS.CodecID])[0]),\n      type: trackType,\n      codecPrivate: findEbml(track, [EBML_TAGS.CodecPrivate])[0],\n      number: (0, _byteHelpers.bytesToNumber)(findEbml(track, [EBML_TAGS.TrackNumber])[0]),\n      defaultDuration: (0, _byteHelpers.bytesToNumber)(findEbml(track, [EBML_TAGS.DefaultDuration])[0]),\n      default: findEbml(track, [EBML_TAGS.FlagDefault])[0],\n      rawData: track\n    };\n    var codec = '';\n\n    if (/V_MPEG4\\/ISO\\/AVC/.test(decodedTrack.rawCodec)) {\n      codec = \"avc1.\" + (0, _codecHelpers.getAvcCodec)(decodedTrack.codecPrivate);\n    } else if (/V_MPEGH\\/ISO\\/HEVC/.test(decodedTrack.rawCodec)) {\n      codec = \"hev1.\" + (0, _codecHelpers.getHvcCodec)(decodedTrack.codecPrivate);\n    } else if (/V_MPEG4\\/ISO\\/ASP/.test(decodedTrack.rawCodec)) {\n      if (decodedTrack.codecPrivate) {\n        codec = 'mp4v.20.' + decodedTrack.codecPrivate[4].toString();\n      } else {\n        codec = 'mp4v.20.9';\n      }\n    } else if (/^V_THEORA/.test(decodedTrack.rawCodec)) {\n      codec = 'theora';\n    } else if (/^V_VP8/.test(decodedTrack.rawCodec)) {\n      codec = 'vp8';\n    } else if (/^V_VP9/.test(decodedTrack.rawCodec)) {\n      if (decodedTrack.codecPrivate) {\n        var _parseVp9Private = parseVp9Private(decodedTrack.codecPrivate),\n            profile = _parseVp9Private.profile,\n            level = _parseVp9Private.level,\n            bitDepth = _parseVp9Private.bitDepth,\n            chromaSubsampling = _parseVp9Private.chromaSubsampling;\n\n        codec = 'vp09.';\n        codec += (0, _byteHelpers.padStart)(profile, 2, '0') + \".\";\n        codec += (0, _byteHelpers.padStart)(level, 2, '0') + \".\";\n        codec += (0, _byteHelpers.padStart)(bitDepth, 2, '0') + \".\";\n        codec += \"\" + (0, _byteHelpers.padStart)(chromaSubsampling, 2, '0'); // Video -> Colour -> Ebml name\n\n        var matrixCoefficients = findEbml(track, [0xE0, [0x55, 0xB0], [0x55, 0xB1]])[0] || [];\n        var videoFullRangeFlag = findEbml(track, [0xE0, [0x55, 0xB0], [0x55, 0xB9]])[0] || [];\n        var transferCharacteristics = findEbml(track, [0xE0, [0x55, 0xB0], [0x55, 0xBA]])[0] || [];\n        var colourPrimaries = findEbml(track, [0xE0, [0x55, 0xB0], [0x55, 0xBB]])[0] || []; // if we find any optional codec parameter specify them all.\n\n        if (matrixCoefficients.length || videoFullRangeFlag.length || transferCharacteristics.length || colourPrimaries.length) {\n          codec += \".\" + (0, _byteHelpers.padStart)(colourPrimaries[0], 2, '0');\n          codec += \".\" + (0, _byteHelpers.padStart)(transferCharacteristics[0], 2, '0');\n          codec += \".\" + (0, _byteHelpers.padStart)(matrixCoefficients[0], 2, '0');\n          codec += \".\" + (0, _byteHelpers.padStart)(videoFullRangeFlag[0], 2, '0');\n        }\n      } else {\n        codec = 'vp9';\n      }\n    } else if (/^V_AV1/.test(decodedTrack.rawCodec)) {\n      codec = \"av01.\" + (0, _codecHelpers.getAv1Codec)(decodedTrack.codecPrivate);\n    } else if (/A_ALAC/.test(decodedTrack.rawCodec)) {\n      codec = 'alac';\n    } else if (/A_MPEG\\/L2/.test(decodedTrack.rawCodec)) {\n      codec = 'mp2';\n    } else if (/A_MPEG\\/L3/.test(decodedTrack.rawCodec)) {\n      codec = 'mp3';\n    } else if (/^A_AAC/.test(decodedTrack.rawCodec)) {\n      if (decodedTrack.codecPrivate) {\n        codec = 'mp4a.40.' + (decodedTrack.codecPrivate[0] >>> 3).toString();\n      } else {\n        codec = 'mp4a.40.2';\n      }\n    } else if (/^A_AC3/.test(decodedTrack.rawCodec)) {\n      codec = 'ac-3';\n    } else if (/^A_PCM/.test(decodedTrack.rawCodec)) {\n      codec = 'pcm';\n    } else if (/^A_MS\\/ACM/.test(decodedTrack.rawCodec)) {\n      codec = 'speex';\n    } else if (/^A_EAC3/.test(decodedTrack.rawCodec)) {\n      codec = 'ec-3';\n    } else if (/^A_VORBIS/.test(decodedTrack.rawCodec)) {\n      codec = 'vorbis';\n    } else if (/^A_FLAC/.test(decodedTrack.rawCodec)) {\n      codec = 'flac';\n    } else if (/^A_OPUS/.test(decodedTrack.rawCodec)) {\n      codec = 'opus';\n    }\n\n    decodedTrack.codec = codec;\n    decodedTracks.push(decodedTrack);\n  });\n  return decodedTracks.sort(function (a, b) {\n    return a.number - b.number;\n  });\n};\n\nexports.parseTracks = parseTracks;\n\nvar parseData = function parseData(data, tracks) {\n  var allBlocks = [];\n  var segment = findEbml(data, [EBML_TAGS.Segment])[0];\n  var timestampScale = findEbml(segment, [EBML_TAGS.SegmentInfo, EBML_TAGS.TimestampScale])[0]; // in nanoseconds, defaults to 1ms\n\n  if (timestampScale && timestampScale.length) {\n    timestampScale = (0, _byteHelpers.bytesToNumber)(timestampScale);\n  } else {\n    timestampScale = 1000000;\n  }\n\n  var clusters = findEbml(segment, [EBML_TAGS.Cluster]);\n\n  if (!tracks) {\n    tracks = parseTracks(segment);\n  }\n\n  clusters.forEach(function (cluster, ci) {\n    var simpleBlocks = findEbml(cluster, [EBML_TAGS.SimpleBlock]).map(function (b) {\n      return {\n        type: 'simple',\n        data: b\n      };\n    });\n    var blockGroups = findEbml(cluster, [EBML_TAGS.BlockGroup]).map(function (b) {\n      return {\n        type: 'group',\n        data: b\n      };\n    });\n    var timestamp = findEbml(cluster, [EBML_TAGS.Timestamp])[0] || 0;\n\n    if (timestamp && timestamp.length) {\n      timestamp = (0, _byteHelpers.bytesToNumber)(timestamp);\n    } // get all blocks then sort them into the correct order\n\n\n    var blocks = simpleBlocks.concat(blockGroups).sort(function (a, b) {\n      return a.data.byteOffset - b.data.byteOffset;\n    });\n    blocks.forEach(function (block, bi) {\n      var decoded = decodeBlock(block.data, block.type, timestampScale, timestamp);\n      allBlocks.push(decoded);\n    });\n  });\n  return {\n    tracks: tracks,\n    blocks: allBlocks\n  };\n};\n\nexports.parseData = parseData;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHZpZGVvanMvdmhzLXV0aWxzL2Nqcy9lYm1sLWhlbHBlcnMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsaUJBQWlCLEdBQUcsbUJBQW1CLEdBQUcsbUJBQW1CLEdBQUcsZ0JBQWdCLEdBQUcsaUJBQWlCOztBQUVwRyxtQkFBbUIsbUJBQU8sQ0FBQyxtRkFBZ0I7O0FBRTNDLG9CQUFvQixtQkFBTyxDQUFDLHdGQUFvQjs7QUFFaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUI7QUFDakI7O0FBRUE7QUFDQTs7QUFFQSxrQkFBa0IseUJBQXlCO0FBQzNDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseUJBQXlCLElBQUk7QUFDN0I7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7O0FBRXZEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUVBQW1FOztBQUVuRTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7O0FBR0gsZ0JBQWdCOztBQUVoQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0I7QUFDcEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7O0FBRXJELDRGQUE0Rjs7QUFFNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0I7O0FBRWxCO0FBQ0E7O0FBRUEsb0JBQW9CLG9CQUFvQjtBQUN4QztBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQSxxQkFBcUIseUJBQXlCO0FBQzlDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7O0FBRVI7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLDBCQUEwQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIOzs7QUFHQSxtQkFBbUI7O0FBRW5CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047OztBQUdBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkU7O0FBRTdFO0FBQ0E7QUFDQTtBQUNBLDRGQUE0Rjs7QUFFNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBLG1CQUFtQjs7QUFFbkI7QUFDQTtBQUNBO0FBQ0EsZ0dBQWdHOztBQUVoRztBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS12MC1wcm9qZWN0Ly4vbm9kZV9tb2R1bGVzL0B2aWRlb2pzL3Zocy11dGlscy9janMvZWJtbC1oZWxwZXJzLmpzP2ExZTkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLnBhcnNlRGF0YSA9IGV4cG9ydHMucGFyc2VUcmFja3MgPSBleHBvcnRzLmRlY29kZUJsb2NrID0gZXhwb3J0cy5maW5kRWJtbCA9IGV4cG9ydHMuRUJNTF9UQUdTID0gdm9pZCAwO1xuXG52YXIgX2J5dGVIZWxwZXJzID0gcmVxdWlyZShcIi4vYnl0ZS1oZWxwZXJzXCIpO1xuXG52YXIgX2NvZGVjSGVscGVycyA9IHJlcXVpcmUoXCIuL2NvZGVjLWhlbHBlcnMuanNcIik7XG5cbi8vIHJlbGV2YW50IHNwZWNzIGZvciB0aGlzIHBhcnNlcjpcbi8vIGh0dHBzOi8vbWF0cm9za2Etb3JnLmdpdGh1Yi5pby9saWJlYm1sL3NwZWNzLmh0bWxcbi8vIGh0dHBzOi8vd3d3Lm1hdHJvc2thLm9yZy90ZWNobmljYWwvZWxlbWVudHMuaHRtbFxuLy8gaHR0cHM6Ly93d3cud2VibXByb2plY3Qub3JnL2RvY3MvY29udGFpbmVyL1xudmFyIEVCTUxfVEFHUyA9IHtcbiAgRUJNTDogKDAsIF9ieXRlSGVscGVycy50b1VpbnQ4KShbMHgxQSwgMHg0NSwgMHhERiwgMHhBM10pLFxuICBEb2NUeXBlOiAoMCwgX2J5dGVIZWxwZXJzLnRvVWludDgpKFsweDQyLCAweDgyXSksXG4gIFNlZ21lbnQ6ICgwLCBfYnl0ZUhlbHBlcnMudG9VaW50OCkoWzB4MTgsIDB4NTMsIDB4ODAsIDB4NjddKSxcbiAgU2VnbWVudEluZm86ICgwLCBfYnl0ZUhlbHBlcnMudG9VaW50OCkoWzB4MTUsIDB4NDksIDB4QTksIDB4NjZdKSxcbiAgVHJhY2tzOiAoMCwgX2J5dGVIZWxwZXJzLnRvVWludDgpKFsweDE2LCAweDU0LCAweEFFLCAweDZCXSksXG4gIFRyYWNrOiAoMCwgX2J5dGVIZWxwZXJzLnRvVWludDgpKFsweEFFXSksXG4gIFRyYWNrTnVtYmVyOiAoMCwgX2J5dGVIZWxwZXJzLnRvVWludDgpKFsweGQ3XSksXG4gIERlZmF1bHREdXJhdGlvbjogKDAsIF9ieXRlSGVscGVycy50b1VpbnQ4KShbMHgyMywgMHhlMywgMHg4M10pLFxuICBUcmFja0VudHJ5OiAoMCwgX2J5dGVIZWxwZXJzLnRvVWludDgpKFsweEFFXSksXG4gIFRyYWNrVHlwZTogKDAsIF9ieXRlSGVscGVycy50b1VpbnQ4KShbMHg4M10pLFxuICBGbGFnRGVmYXVsdDogKDAsIF9ieXRlSGVscGVycy50b1VpbnQ4KShbMHg4OF0pLFxuICBDb2RlY0lEOiAoMCwgX2J5dGVIZWxwZXJzLnRvVWludDgpKFsweDg2XSksXG4gIENvZGVjUHJpdmF0ZTogKDAsIF9ieXRlSGVscGVycy50b1VpbnQ4KShbMHg2MywgMHhBMl0pLFxuICBWaWRlb1RyYWNrOiAoMCwgX2J5dGVIZWxwZXJzLnRvVWludDgpKFsweGUwXSksXG4gIEF1ZGlvVHJhY2s6ICgwLCBfYnl0ZUhlbHBlcnMudG9VaW50OCkoWzB4ZTFdKSxcbiAgLy8gTm90IHVzZWQgeWV0LCBidXQgd2lsbCBiZSB1c2VkIGZvciBsaXZlIHdlYm0vbWt2XG4gIC8vIHNlZSBodHRwczovL3d3dy5tYXRyb3NrYS5vcmcvdGVjaG5pY2FsL2Jhc2ljcy5odG1sI2Jsb2NrLXN0cnVjdHVyZVxuICAvLyBzZWUgaHR0cHM6Ly93d3cubWF0cm9za2Eub3JnL3RlY2huaWNhbC9iYXNpY3MuaHRtbCNzaW1wbGVibG9jay1zdHJ1Y3R1cmVcbiAgQ2x1c3RlcjogKDAsIF9ieXRlSGVscGVycy50b1VpbnQ4KShbMHgxRiwgMHg0MywgMHhCNiwgMHg3NV0pLFxuICBUaW1lc3RhbXA6ICgwLCBfYnl0ZUhlbHBlcnMudG9VaW50OCkoWzB4RTddKSxcbiAgVGltZXN0YW1wU2NhbGU6ICgwLCBfYnl0ZUhlbHBlcnMudG9VaW50OCkoWzB4MkEsIDB4RDcsIDB4QjFdKSxcbiAgQmxvY2tHcm91cDogKDAsIF9ieXRlSGVscGVycy50b1VpbnQ4KShbMHhBMF0pLFxuICBCbG9ja0R1cmF0aW9uOiAoMCwgX2J5dGVIZWxwZXJzLnRvVWludDgpKFsweDlCXSksXG4gIEJsb2NrOiAoMCwgX2J5dGVIZWxwZXJzLnRvVWludDgpKFsweEExXSksXG4gIFNpbXBsZUJsb2NrOiAoMCwgX2J5dGVIZWxwZXJzLnRvVWludDgpKFsweEEzXSlcbn07XG4vKipcbiAqIFRoaXMgaXMgYSBzaW1wbGUgdGFibGUgdG8gZGV0ZXJtaW5lIHRoZSBsZW5ndGhcbiAqIG9mIHRoaW5ncyBpbiBlYm1sLiBUaGUgbGVuZ3RoIGlzIG9uZSBiYXNlZCAoc3RhcnRzIGF0IDEsXG4gKiByYXRoZXIgdGhhbiB6ZXJvKSBhbmQgZm9yIGV2ZXJ5IHplcm8gYml0IGJlZm9yZSBhIG9uZSBiaXRcbiAqIHdlIGFkZCBvbmUgdG8gbGVuZ3RoLiBXZSBhbHNvIG5lZWQgdGhpcyB0YWJsZSBiZWNhdXNlIGluIHNvbWVcbiAqIGNhc2Ugd2UgaGF2ZSB0byB4b3IgYWxsIHRoZSBsZW5ndGggYml0cyBmcm9tIGFub3RoZXIgdmFsdWUuXG4gKi9cblxuZXhwb3J0cy5FQk1MX1RBR1MgPSBFQk1MX1RBR1M7XG52YXIgTEVOR1RIX1RBQkxFID0gWzEyOCwgNjQsIDMyLCAxNiwgOCwgNCwgMiwgMV07XG5cbnZhciBnZXRMZW5ndGggPSBmdW5jdGlvbiBnZXRMZW5ndGgoYnl0ZSkge1xuICB2YXIgbGVuID0gMTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IExFTkdUSF9UQUJMRS5sZW5ndGg7IGkrKykge1xuICAgIGlmIChieXRlICYgTEVOR1RIX1RBQkxFW2ldKSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBsZW4rKztcbiAgfVxuXG4gIHJldHVybiBsZW47XG59OyAvLyBsZW5ndGggaW4gZWJtbCBpcyBzdG9yZWQgaW4gdGhlIGZpcnN0IDQgdG8gOCBiaXRzXG4vLyBvZiB0aGUgZmlyc3QgYnl0ZS4gNCBmb3IgdGhlIGlkIGxlbmd0aCBhbmQgOCBmb3IgdGhlXG4vLyBkYXRhIHNpemUgbGVuZ3RoLiBMZW5ndGggaXMgbWVhc3VyZWQgYnkgY29udmVydGluZyB0aGUgbnVtYmVyIHRvIGJpbmFyeVxuLy8gdGhlbiAxICsgdGhlIG51bWJlciBvZiB6ZXJvcyBiZWZvcmUgYSAxIGlzIGVuY291bnRlcmVkIHN0YXJ0aW5nXG4vLyBmcm9tIHRoZSBsZWZ0LlxuXG5cbnZhciBnZXR2aW50ID0gZnVuY3Rpb24gZ2V0dmludChieXRlcywgb2Zmc2V0LCByZW1vdmVMZW5ndGgsIHNpZ25lZCkge1xuICBpZiAocmVtb3ZlTGVuZ3RoID09PSB2b2lkIDApIHtcbiAgICByZW1vdmVMZW5ndGggPSB0cnVlO1xuICB9XG5cbiAgaWYgKHNpZ25lZCA9PT0gdm9pZCAwKSB7XG4gICAgc2lnbmVkID0gZmFsc2U7XG4gIH1cblxuICB2YXIgbGVuZ3RoID0gZ2V0TGVuZ3RoKGJ5dGVzW29mZnNldF0pO1xuICB2YXIgdmFsdWVCeXRlcyA9IGJ5dGVzLnN1YmFycmF5KG9mZnNldCwgb2Zmc2V0ICsgbGVuZ3RoKTsgLy8gTk9URSB0aGF0IHdlIGRvICoqbm90Kiogc3ViYXJyYXkgaGVyZSBiZWNhdXNlIHdlIG5lZWQgdG8gY29weSB0aGVzZSBieXRlc1xuICAvLyBhcyB0aGV5IHdpbGwgYmUgbW9kaWZpZWQgYmVsb3cgdG8gcmVtb3ZlIHRoZSBkYXRhU2l6ZUxlbiBiaXRzIGFuZCB3ZSBkbyBub3RcbiAgLy8gd2FudCB0byBtb2RpZnkgdGhlIG9yaWdpbmFsIGRhdGEuIG5vcm1hbGx5IHdlIGNvdWxkIGp1c3QgY2FsbCBzbGljZSBvblxuICAvLyB1aW50OGFycmF5IGJ1dCBpZSAxMSBkb2VzIG5vdCBzdXBwb3J0IHRoYXQuLi5cblxuICBpZiAocmVtb3ZlTGVuZ3RoKSB7XG4gICAgdmFsdWVCeXRlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGJ5dGVzLCBvZmZzZXQsIG9mZnNldCArIGxlbmd0aCk7XG4gICAgdmFsdWVCeXRlc1swXSBePSBMRU5HVEhfVEFCTEVbbGVuZ3RoIC0gMV07XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGxlbmd0aDogbGVuZ3RoLFxuICAgIHZhbHVlOiAoMCwgX2J5dGVIZWxwZXJzLmJ5dGVzVG9OdW1iZXIpKHZhbHVlQnl0ZXMsIHtcbiAgICAgIHNpZ25lZDogc2lnbmVkXG4gICAgfSksXG4gICAgYnl0ZXM6IHZhbHVlQnl0ZXNcbiAgfTtcbn07XG5cbnZhciBub3JtYWxpemVQYXRoID0gZnVuY3Rpb24gbm9ybWFsaXplUGF0aChwYXRoKSB7XG4gIGlmICh0eXBlb2YgcGF0aCA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gcGF0aC5tYXRjaCgvLnsxLDJ9L2cpLm1hcChmdW5jdGlvbiAocCkge1xuICAgICAgcmV0dXJuIG5vcm1hbGl6ZVBhdGgocCk7XG4gICAgfSk7XG4gIH1cblxuICBpZiAodHlwZW9mIHBhdGggPT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuICgwLCBfYnl0ZUhlbHBlcnMubnVtYmVyVG9CeXRlcykocGF0aCk7XG4gIH1cblxuICByZXR1cm4gcGF0aDtcbn07XG5cbnZhciBub3JtYWxpemVQYXRocyA9IGZ1bmN0aW9uIG5vcm1hbGl6ZVBhdGhzKHBhdGhzKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShwYXRocykpIHtcbiAgICByZXR1cm4gW25vcm1hbGl6ZVBhdGgocGF0aHMpXTtcbiAgfVxuXG4gIHJldHVybiBwYXRocy5tYXAoZnVuY3Rpb24gKHApIHtcbiAgICByZXR1cm4gbm9ybWFsaXplUGF0aChwKTtcbiAgfSk7XG59O1xuXG52YXIgZ2V0SW5maW5pdHlEYXRhU2l6ZSA9IGZ1bmN0aW9uIGdldEluZmluaXR5RGF0YVNpemUoaWQsIGJ5dGVzLCBvZmZzZXQpIHtcbiAgaWYgKG9mZnNldCA+PSBieXRlcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gYnl0ZXMubGVuZ3RoO1xuICB9XG5cbiAgdmFyIGlubmVyaWQgPSBnZXR2aW50KGJ5dGVzLCBvZmZzZXQsIGZhbHNlKTtcblxuICBpZiAoKDAsIF9ieXRlSGVscGVycy5ieXRlc01hdGNoKShpZC5ieXRlcywgaW5uZXJpZC5ieXRlcykpIHtcbiAgICByZXR1cm4gb2Zmc2V0O1xuICB9XG5cbiAgdmFyIGRhdGFIZWFkZXIgPSBnZXR2aW50KGJ5dGVzLCBvZmZzZXQgKyBpbm5lcmlkLmxlbmd0aCk7XG4gIHJldHVybiBnZXRJbmZpbml0eURhdGFTaXplKGlkLCBieXRlcywgb2Zmc2V0ICsgZGF0YUhlYWRlci5sZW5ndGggKyBkYXRhSGVhZGVyLnZhbHVlICsgaW5uZXJpZC5sZW5ndGgpO1xufTtcbi8qKlxuICogTm90ZXMgb24gdGhlIEVCTE0gZm9ybWF0LlxuICpcbiAqIEVCTE0gdXNlcyBcInZpbnRzXCIgdGFncy4gRXZlcnkgdmludCB0YWcgY29udGFpbnNcbiAqIHR3byBwYXJ0c1xuICpcbiAqIDEuIFRoZSBsZW5ndGggZnJvbSB0aGUgZmlyc3QgYnl0ZS4gWW91IGdldCB0aGlzIGJ5XG4gKiAgICBjb252ZXJ0aW5nIHRoZSBieXRlIHRvIGJpbmFyeSBhbmQgY291bnRpbmcgdGhlIHplcm9zXG4gKiAgICBiZWZvcmUgYSAxLiBUaGVuIHlvdSBhZGQgMSB0byB0aGF0LiBFeGFtcGxlc1xuICogICAgMDAwMTExMTEgPSBsZW5ndGggNCBiZWNhdXNlIHRoZXJlIGFyZSAzIHplcm9zIGJlZm9yZSBhIDEuXG4gKiAgICAwMDEwMDAwMCA9IGxlbmd0aCAzIGJlY2F1c2UgdGhlcmUgYXJlIDIgemVyb3MgYmVmb3JlIGEgMS5cbiAqICAgIDAwMDAwMDExID0gbGVuZ3RoIDcgYmVjYXVzZSB0aGVyZSBhcmUgNiB6ZXJvcyBiZWZvcmUgYSAxLlxuICpcbiAqIDIuIFRoZSBiaXRzIHVzZWQgZm9yIGxlbmd0aCBhcmUgcmVtb3ZlZCBmcm9tIHRoZSBmaXJzdCBieXRlXG4gKiAgICBUaGVuIGFsbCB0aGUgYnl0ZXMgYXJlIG1lcmdlZCBpbnRvIGEgdmFsdWUuIE5PVEU6IHRoaXNcbiAqICAgIGlzIG5vdCB0aGUgY2FzZSBmb3IgaWQgZWJtbCB0YWdzIGFzIHRoZXJlIGlkIGluY2x1ZGVzXG4gKiAgICBsZW5ndGggYml0cy5cbiAqXG4gKi9cblxuXG52YXIgZmluZEVibWwgPSBmdW5jdGlvbiBmaW5kRWJtbChieXRlcywgcGF0aHMpIHtcbiAgcGF0aHMgPSBub3JtYWxpemVQYXRocyhwYXRocyk7XG4gIGJ5dGVzID0gKDAsIF9ieXRlSGVscGVycy50b1VpbnQ4KShieXRlcyk7XG4gIHZhciByZXN1bHRzID0gW107XG5cbiAgaWYgKCFwYXRocy5sZW5ndGgpIHtcbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfVxuXG4gIHZhciBpID0gMDtcblxuICB3aGlsZSAoaSA8IGJ5dGVzLmxlbmd0aCkge1xuICAgIHZhciBpZCA9IGdldHZpbnQoYnl0ZXMsIGksIGZhbHNlKTtcbiAgICB2YXIgZGF0YUhlYWRlciA9IGdldHZpbnQoYnl0ZXMsIGkgKyBpZC5sZW5ndGgpO1xuICAgIHZhciBkYXRhU3RhcnQgPSBpICsgaWQubGVuZ3RoICsgZGF0YUhlYWRlci5sZW5ndGg7IC8vIGRhdGFTaXplIGlzIHVua25vd24gb3IgdGhpcyBpcyBhIGxpdmUgc3RyZWFtXG5cbiAgICBpZiAoZGF0YUhlYWRlci52YWx1ZSA9PT0gMHg3Zikge1xuICAgICAgZGF0YUhlYWRlci52YWx1ZSA9IGdldEluZmluaXR5RGF0YVNpemUoaWQsIGJ5dGVzLCBkYXRhU3RhcnQpO1xuXG4gICAgICBpZiAoZGF0YUhlYWRlci52YWx1ZSAhPT0gYnl0ZXMubGVuZ3RoKSB7XG4gICAgICAgIGRhdGFIZWFkZXIudmFsdWUgLT0gZGF0YVN0YXJ0O1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBkYXRhRW5kID0gZGF0YVN0YXJ0ICsgZGF0YUhlYWRlci52YWx1ZSA+IGJ5dGVzLmxlbmd0aCA/IGJ5dGVzLmxlbmd0aCA6IGRhdGFTdGFydCArIGRhdGFIZWFkZXIudmFsdWU7XG4gICAgdmFyIGRhdGEgPSBieXRlcy5zdWJhcnJheShkYXRhU3RhcnQsIGRhdGFFbmQpO1xuXG4gICAgaWYgKCgwLCBfYnl0ZUhlbHBlcnMuYnl0ZXNNYXRjaCkocGF0aHNbMF0sIGlkLmJ5dGVzKSkge1xuICAgICAgaWYgKHBhdGhzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAvLyB0aGlzIGlzIHRoZSBlbmQgb2YgdGhlIHBhdGhzIGFuZCB3ZSd2ZSBmb3VuZCB0aGUgdGFnIHdlIHdlcmVcbiAgICAgICAgLy8gbG9va2luZyBmb3JcbiAgICAgICAgcmVzdWx0cy5wdXNoKGRhdGEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gcmVjdXJzaXZlbHkgc2VhcmNoIGZvciB0aGUgbmV4dCB0YWcgaW5zaWRlIG9mIHRoZSBkYXRhXG4gICAgICAgIC8vIG9mIHRoaXMgb25lXG4gICAgICAgIHJlc3VsdHMgPSByZXN1bHRzLmNvbmNhdChmaW5kRWJtbChkYXRhLCBwYXRocy5zbGljZSgxKSkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciB0b3RhbExlbmd0aCA9IGlkLmxlbmd0aCArIGRhdGFIZWFkZXIubGVuZ3RoICsgZGF0YS5sZW5ndGg7IC8vIG1vdmUgcGFzdCB0aGlzIHRhZyBlbnRpcmVseSwgd2UgYXJlIG5vdCBsb29raW5nIGZvciBpdFxuXG4gICAgaSArPSB0b3RhbExlbmd0aDtcbiAgfVxuXG4gIHJldHVybiByZXN1bHRzO1xufTsgLy8gc2VlIGh0dHBzOi8vd3d3Lm1hdHJvc2thLm9yZy90ZWNobmljYWwvYmFzaWNzLmh0bWwjYmxvY2stc3RydWN0dXJlXG5cblxuZXhwb3J0cy5maW5kRWJtbCA9IGZpbmRFYm1sO1xuXG52YXIgZGVjb2RlQmxvY2sgPSBmdW5jdGlvbiBkZWNvZGVCbG9jayhibG9jaywgdHlwZSwgdGltZXN0YW1wU2NhbGUsIGNsdXN0ZXJUaW1lc3RhbXApIHtcbiAgdmFyIGR1cmF0aW9uO1xuXG4gIGlmICh0eXBlID09PSAnZ3JvdXAnKSB7XG4gICAgZHVyYXRpb24gPSBmaW5kRWJtbChibG9jaywgW0VCTUxfVEFHUy5CbG9ja0R1cmF0aW9uXSlbMF07XG5cbiAgICBpZiAoZHVyYXRpb24pIHtcbiAgICAgIGR1cmF0aW9uID0gKDAsIF9ieXRlSGVscGVycy5ieXRlc1RvTnVtYmVyKShkdXJhdGlvbik7XG4gICAgICBkdXJhdGlvbiA9IDEgLyB0aW1lc3RhbXBTY2FsZSAqIGR1cmF0aW9uICogdGltZXN0YW1wU2NhbGUgLyAxMDAwO1xuICAgIH1cblxuICAgIGJsb2NrID0gZmluZEVibWwoYmxvY2ssIFtFQk1MX1RBR1MuQmxvY2tdKVswXTtcbiAgICB0eXBlID0gJ2Jsb2NrJzsgLy8gdHJlYXQgZGF0YSBhcyBhIGJsb2NrIGFmdGVyIHRoaXMgcG9pbnRcbiAgfVxuXG4gIHZhciBkdiA9IG5ldyBEYXRhVmlldyhibG9jay5idWZmZXIsIGJsb2NrLmJ5dGVPZmZzZXQsIGJsb2NrLmJ5dGVMZW5ndGgpO1xuICB2YXIgdHJhY2tOdW1iZXIgPSBnZXR2aW50KGJsb2NrLCAwKTtcbiAgdmFyIHRpbWVzdGFtcCA9IGR2LmdldEludDE2KHRyYWNrTnVtYmVyLmxlbmd0aCwgZmFsc2UpO1xuICB2YXIgZmxhZ3MgPSBibG9ja1t0cmFja051bWJlci5sZW5ndGggKyAyXTtcbiAgdmFyIGRhdGEgPSBibG9jay5zdWJhcnJheSh0cmFja051bWJlci5sZW5ndGggKyAzKTsgLy8gcHRzL2R0cyBpbiBzZWNvbmRzXG5cbiAgdmFyIHB0c2R0cyA9IDEgLyB0aW1lc3RhbXBTY2FsZSAqIChjbHVzdGVyVGltZXN0YW1wICsgdGltZXN0YW1wKSAqIHRpbWVzdGFtcFNjYWxlIC8gMTAwMDsgLy8gcmV0dXJuIHRoZSBmcmFtZVxuXG4gIHZhciBwYXJzZWQgPSB7XG4gICAgZHVyYXRpb246IGR1cmF0aW9uLFxuICAgIHRyYWNrTnVtYmVyOiB0cmFja051bWJlci52YWx1ZSxcbiAgICBrZXlmcmFtZTogdHlwZSA9PT0gJ3NpbXBsZScgJiYgZmxhZ3MgPj4gNyA9PT0gMSxcbiAgICBpbnZpc2libGU6IChmbGFncyAmIDB4MDgpID4+IDMgPT09IDEsXG4gICAgbGFjaW5nOiAoZmxhZ3MgJiAweDA2KSA+PiAxLFxuICAgIGRpc2NhcmRhYmxlOiB0eXBlID09PSAnc2ltcGxlJyAmJiAoZmxhZ3MgJiAweDAxKSA9PT0gMSxcbiAgICBmcmFtZXM6IFtdLFxuICAgIHB0czogcHRzZHRzLFxuICAgIGR0czogcHRzZHRzLFxuICAgIHRpbWVzdGFtcDogdGltZXN0YW1wXG4gIH07XG5cbiAgaWYgKCFwYXJzZWQubGFjaW5nKSB7XG4gICAgcGFyc2VkLmZyYW1lcy5wdXNoKGRhdGEpO1xuICAgIHJldHVybiBwYXJzZWQ7XG4gIH1cblxuICB2YXIgbnVtYmVyT2ZGcmFtZXMgPSBkYXRhWzBdICsgMTtcbiAgdmFyIGZyYW1lU2l6ZXMgPSBbXTtcbiAgdmFyIG9mZnNldCA9IDE7IC8vIEZpeGVkXG5cbiAgaWYgKHBhcnNlZC5sYWNpbmcgPT09IDIpIHtcbiAgICB2YXIgc2l6ZU9mRnJhbWUgPSAoZGF0YS5sZW5ndGggLSBvZmZzZXQpIC8gbnVtYmVyT2ZGcmFtZXM7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bWJlck9mRnJhbWVzOyBpKyspIHtcbiAgICAgIGZyYW1lU2l6ZXMucHVzaChzaXplT2ZGcmFtZSk7XG4gICAgfVxuICB9IC8vIHhpcGhcblxuXG4gIGlmIChwYXJzZWQubGFjaW5nID09PSAxKSB7XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IG51bWJlck9mRnJhbWVzIC0gMTsgX2krKykge1xuICAgICAgdmFyIHNpemUgPSAwO1xuXG4gICAgICBkbyB7XG4gICAgICAgIHNpemUgKz0gZGF0YVtvZmZzZXRdO1xuICAgICAgICBvZmZzZXQrKztcbiAgICAgIH0gd2hpbGUgKGRhdGFbb2Zmc2V0IC0gMV0gPT09IDB4RkYpO1xuXG4gICAgICBmcmFtZVNpemVzLnB1c2goc2l6ZSk7XG4gICAgfVxuICB9IC8vIGVibWxcblxuXG4gIGlmIChwYXJzZWQubGFjaW5nID09PSAzKSB7XG4gICAgLy8gZmlyc3QgdmludCBpcyB1bnNpbmdlZFxuICAgIC8vIGFmdGVyIHRoYXQgdmludHMgYXJlIHNpbmdlZCBhbmRcbiAgICAvLyBiYXNlZCBvbiBhIGNvbXBvdW5kaW5nIHNpemVcbiAgICB2YXIgX3NpemUgPSAwO1xuXG4gICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgbnVtYmVyT2ZGcmFtZXMgLSAxOyBfaTIrKykge1xuICAgICAgdmFyIHZpbnQgPSBfaTIgPT09IDAgPyBnZXR2aW50KGRhdGEsIG9mZnNldCkgOiBnZXR2aW50KGRhdGEsIG9mZnNldCwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICBfc2l6ZSArPSB2aW50LnZhbHVlO1xuICAgICAgZnJhbWVTaXplcy5wdXNoKF9zaXplKTtcbiAgICAgIG9mZnNldCArPSB2aW50Lmxlbmd0aDtcbiAgICB9XG4gIH1cblxuICBmcmFtZVNpemVzLmZvckVhY2goZnVuY3Rpb24gKHNpemUpIHtcbiAgICBwYXJzZWQuZnJhbWVzLnB1c2goZGF0YS5zdWJhcnJheShvZmZzZXQsIG9mZnNldCArIHNpemUpKTtcbiAgICBvZmZzZXQgKz0gc2l6ZTtcbiAgfSk7XG4gIHJldHVybiBwYXJzZWQ7XG59OyAvLyBWUDkgQ29kZWMgRmVhdHVyZSBNZXRhZGF0YSAoQ29kZWNQcml2YXRlKVxuLy8gaHR0cHM6Ly93d3cud2VibXByb2plY3Qub3JnL2RvY3MvY29udGFpbmVyL1xuXG5cbmV4cG9ydHMuZGVjb2RlQmxvY2sgPSBkZWNvZGVCbG9jaztcblxudmFyIHBhcnNlVnA5UHJpdmF0ZSA9IGZ1bmN0aW9uIHBhcnNlVnA5UHJpdmF0ZShieXRlcykge1xuICB2YXIgaSA9IDA7XG4gIHZhciBwYXJhbXMgPSB7fTtcblxuICB3aGlsZSAoaSA8IGJ5dGVzLmxlbmd0aCkge1xuICAgIHZhciBpZCA9IGJ5dGVzW2ldICYgMHg3ZjtcbiAgICB2YXIgbGVuID0gYnl0ZXNbaSArIDFdO1xuICAgIHZhciB2YWwgPSB2b2lkIDA7XG5cbiAgICBpZiAobGVuID09PSAxKSB7XG4gICAgICB2YWwgPSBieXRlc1tpICsgMl07XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbCA9IGJ5dGVzLnN1YmFycmF5KGkgKyAyLCBpICsgMiArIGxlbik7XG4gICAgfVxuXG4gICAgaWYgKGlkID09PSAxKSB7XG4gICAgICBwYXJhbXMucHJvZmlsZSA9IHZhbDtcbiAgICB9IGVsc2UgaWYgKGlkID09PSAyKSB7XG4gICAgICBwYXJhbXMubGV2ZWwgPSB2YWw7XG4gICAgfSBlbHNlIGlmIChpZCA9PT0gMykge1xuICAgICAgcGFyYW1zLmJpdERlcHRoID0gdmFsO1xuICAgIH0gZWxzZSBpZiAoaWQgPT09IDQpIHtcbiAgICAgIHBhcmFtcy5jaHJvbWFTdWJzYW1wbGluZyA9IHZhbDtcbiAgICB9IGVsc2Uge1xuICAgICAgcGFyYW1zW2lkXSA9IHZhbDtcbiAgICB9XG5cbiAgICBpICs9IDIgKyBsZW47XG4gIH1cblxuICByZXR1cm4gcGFyYW1zO1xufTtcblxudmFyIHBhcnNlVHJhY2tzID0gZnVuY3Rpb24gcGFyc2VUcmFja3MoYnl0ZXMpIHtcbiAgYnl0ZXMgPSAoMCwgX2J5dGVIZWxwZXJzLnRvVWludDgpKGJ5dGVzKTtcbiAgdmFyIGRlY29kZWRUcmFja3MgPSBbXTtcbiAgdmFyIHRyYWNrcyA9IGZpbmRFYm1sKGJ5dGVzLCBbRUJNTF9UQUdTLlNlZ21lbnQsIEVCTUxfVEFHUy5UcmFja3MsIEVCTUxfVEFHUy5UcmFja10pO1xuXG4gIGlmICghdHJhY2tzLmxlbmd0aCkge1xuICAgIHRyYWNrcyA9IGZpbmRFYm1sKGJ5dGVzLCBbRUJNTF9UQUdTLlRyYWNrcywgRUJNTF9UQUdTLlRyYWNrXSk7XG4gIH1cblxuICBpZiAoIXRyYWNrcy5sZW5ndGgpIHtcbiAgICB0cmFja3MgPSBmaW5kRWJtbChieXRlcywgW0VCTUxfVEFHUy5UcmFja10pO1xuICB9XG5cbiAgaWYgKCF0cmFja3MubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGRlY29kZWRUcmFja3M7XG4gIH1cblxuICB0cmFja3MuZm9yRWFjaChmdW5jdGlvbiAodHJhY2spIHtcbiAgICB2YXIgdHJhY2tUeXBlID0gZmluZEVibWwodHJhY2ssIEVCTUxfVEFHUy5UcmFja1R5cGUpWzBdO1xuXG4gICAgaWYgKCF0cmFja1R5cGUgfHwgIXRyYWNrVHlwZS5sZW5ndGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIDEgaXMgdmlkZW8sIDIgaXMgYXVkaW8sIDE3IGlzIHN1YnRpdGxlXG4gICAgLy8gb3RoZXIgdmFsdWVzIGFyZSB1bmltcG9ydGFudCBpbiB0aGlzIGNvbnRleHRcblxuXG4gICAgaWYgKHRyYWNrVHlwZVswXSA9PT0gMSkge1xuICAgICAgdHJhY2tUeXBlID0gJ3ZpZGVvJztcbiAgICB9IGVsc2UgaWYgKHRyYWNrVHlwZVswXSA9PT0gMikge1xuICAgICAgdHJhY2tUeXBlID0gJ2F1ZGlvJztcbiAgICB9IGVsc2UgaWYgKHRyYWNrVHlwZVswXSA9PT0gMTcpIHtcbiAgICAgIHRyYWNrVHlwZSA9ICdzdWJ0aXRsZSc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIHRvZG8gcGFyc2UgbGFuZ3VhZ2VcblxuXG4gICAgdmFyIGRlY29kZWRUcmFjayA9IHtcbiAgICAgIHJhd0NvZGVjOiAoMCwgX2J5dGVIZWxwZXJzLmJ5dGVzVG9TdHJpbmcpKGZpbmRFYm1sKHRyYWNrLCBbRUJNTF9UQUdTLkNvZGVjSURdKVswXSksXG4gICAgICB0eXBlOiB0cmFja1R5cGUsXG4gICAgICBjb2RlY1ByaXZhdGU6IGZpbmRFYm1sKHRyYWNrLCBbRUJNTF9UQUdTLkNvZGVjUHJpdmF0ZV0pWzBdLFxuICAgICAgbnVtYmVyOiAoMCwgX2J5dGVIZWxwZXJzLmJ5dGVzVG9OdW1iZXIpKGZpbmRFYm1sKHRyYWNrLCBbRUJNTF9UQUdTLlRyYWNrTnVtYmVyXSlbMF0pLFxuICAgICAgZGVmYXVsdER1cmF0aW9uOiAoMCwgX2J5dGVIZWxwZXJzLmJ5dGVzVG9OdW1iZXIpKGZpbmRFYm1sKHRyYWNrLCBbRUJNTF9UQUdTLkRlZmF1bHREdXJhdGlvbl0pWzBdKSxcbiAgICAgIGRlZmF1bHQ6IGZpbmRFYm1sKHRyYWNrLCBbRUJNTF9UQUdTLkZsYWdEZWZhdWx0XSlbMF0sXG4gICAgICByYXdEYXRhOiB0cmFja1xuICAgIH07XG4gICAgdmFyIGNvZGVjID0gJyc7XG5cbiAgICBpZiAoL1ZfTVBFRzRcXC9JU09cXC9BVkMvLnRlc3QoZGVjb2RlZFRyYWNrLnJhd0NvZGVjKSkge1xuICAgICAgY29kZWMgPSBcImF2YzEuXCIgKyAoMCwgX2NvZGVjSGVscGVycy5nZXRBdmNDb2RlYykoZGVjb2RlZFRyYWNrLmNvZGVjUHJpdmF0ZSk7XG4gICAgfSBlbHNlIGlmICgvVl9NUEVHSFxcL0lTT1xcL0hFVkMvLnRlc3QoZGVjb2RlZFRyYWNrLnJhd0NvZGVjKSkge1xuICAgICAgY29kZWMgPSBcImhldjEuXCIgKyAoMCwgX2NvZGVjSGVscGVycy5nZXRIdmNDb2RlYykoZGVjb2RlZFRyYWNrLmNvZGVjUHJpdmF0ZSk7XG4gICAgfSBlbHNlIGlmICgvVl9NUEVHNFxcL0lTT1xcL0FTUC8udGVzdChkZWNvZGVkVHJhY2sucmF3Q29kZWMpKSB7XG4gICAgICBpZiAoZGVjb2RlZFRyYWNrLmNvZGVjUHJpdmF0ZSkge1xuICAgICAgICBjb2RlYyA9ICdtcDR2LjIwLicgKyBkZWNvZGVkVHJhY2suY29kZWNQcml2YXRlWzRdLnRvU3RyaW5nKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb2RlYyA9ICdtcDR2LjIwLjknO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoL15WX1RIRU9SQS8udGVzdChkZWNvZGVkVHJhY2sucmF3Q29kZWMpKSB7XG4gICAgICBjb2RlYyA9ICd0aGVvcmEnO1xuICAgIH0gZWxzZSBpZiAoL15WX1ZQOC8udGVzdChkZWNvZGVkVHJhY2sucmF3Q29kZWMpKSB7XG4gICAgICBjb2RlYyA9ICd2cDgnO1xuICAgIH0gZWxzZSBpZiAoL15WX1ZQOS8udGVzdChkZWNvZGVkVHJhY2sucmF3Q29kZWMpKSB7XG4gICAgICBpZiAoZGVjb2RlZFRyYWNrLmNvZGVjUHJpdmF0ZSkge1xuICAgICAgICB2YXIgX3BhcnNlVnA5UHJpdmF0ZSA9IHBhcnNlVnA5UHJpdmF0ZShkZWNvZGVkVHJhY2suY29kZWNQcml2YXRlKSxcbiAgICAgICAgICAgIHByb2ZpbGUgPSBfcGFyc2VWcDlQcml2YXRlLnByb2ZpbGUsXG4gICAgICAgICAgICBsZXZlbCA9IF9wYXJzZVZwOVByaXZhdGUubGV2ZWwsXG4gICAgICAgICAgICBiaXREZXB0aCA9IF9wYXJzZVZwOVByaXZhdGUuYml0RGVwdGgsXG4gICAgICAgICAgICBjaHJvbWFTdWJzYW1wbGluZyA9IF9wYXJzZVZwOVByaXZhdGUuY2hyb21hU3Vic2FtcGxpbmc7XG5cbiAgICAgICAgY29kZWMgPSAndnAwOS4nO1xuICAgICAgICBjb2RlYyArPSAoMCwgX2J5dGVIZWxwZXJzLnBhZFN0YXJ0KShwcm9maWxlLCAyLCAnMCcpICsgXCIuXCI7XG4gICAgICAgIGNvZGVjICs9ICgwLCBfYnl0ZUhlbHBlcnMucGFkU3RhcnQpKGxldmVsLCAyLCAnMCcpICsgXCIuXCI7XG4gICAgICAgIGNvZGVjICs9ICgwLCBfYnl0ZUhlbHBlcnMucGFkU3RhcnQpKGJpdERlcHRoLCAyLCAnMCcpICsgXCIuXCI7XG4gICAgICAgIGNvZGVjICs9IFwiXCIgKyAoMCwgX2J5dGVIZWxwZXJzLnBhZFN0YXJ0KShjaHJvbWFTdWJzYW1wbGluZywgMiwgJzAnKTsgLy8gVmlkZW8gLT4gQ29sb3VyIC0+IEVibWwgbmFtZVxuXG4gICAgICAgIHZhciBtYXRyaXhDb2VmZmljaWVudHMgPSBmaW5kRWJtbCh0cmFjaywgWzB4RTAsIFsweDU1LCAweEIwXSwgWzB4NTUsIDB4QjFdXSlbMF0gfHwgW107XG4gICAgICAgIHZhciB2aWRlb0Z1bGxSYW5nZUZsYWcgPSBmaW5kRWJtbCh0cmFjaywgWzB4RTAsIFsweDU1LCAweEIwXSwgWzB4NTUsIDB4QjldXSlbMF0gfHwgW107XG4gICAgICAgIHZhciB0cmFuc2ZlckNoYXJhY3RlcmlzdGljcyA9IGZpbmRFYm1sKHRyYWNrLCBbMHhFMCwgWzB4NTUsIDB4QjBdLCBbMHg1NSwgMHhCQV1dKVswXSB8fCBbXTtcbiAgICAgICAgdmFyIGNvbG91clByaW1hcmllcyA9IGZpbmRFYm1sKHRyYWNrLCBbMHhFMCwgWzB4NTUsIDB4QjBdLCBbMHg1NSwgMHhCQl1dKVswXSB8fCBbXTsgLy8gaWYgd2UgZmluZCBhbnkgb3B0aW9uYWwgY29kZWMgcGFyYW1ldGVyIHNwZWNpZnkgdGhlbSBhbGwuXG5cbiAgICAgICAgaWYgKG1hdHJpeENvZWZmaWNpZW50cy5sZW5ndGggfHwgdmlkZW9GdWxsUmFuZ2VGbGFnLmxlbmd0aCB8fCB0cmFuc2ZlckNoYXJhY3RlcmlzdGljcy5sZW5ndGggfHwgY29sb3VyUHJpbWFyaWVzLmxlbmd0aCkge1xuICAgICAgICAgIGNvZGVjICs9IFwiLlwiICsgKDAsIF9ieXRlSGVscGVycy5wYWRTdGFydCkoY29sb3VyUHJpbWFyaWVzWzBdLCAyLCAnMCcpO1xuICAgICAgICAgIGNvZGVjICs9IFwiLlwiICsgKDAsIF9ieXRlSGVscGVycy5wYWRTdGFydCkodHJhbnNmZXJDaGFyYWN0ZXJpc3RpY3NbMF0sIDIsICcwJyk7XG4gICAgICAgICAgY29kZWMgKz0gXCIuXCIgKyAoMCwgX2J5dGVIZWxwZXJzLnBhZFN0YXJ0KShtYXRyaXhDb2VmZmljaWVudHNbMF0sIDIsICcwJyk7XG4gICAgICAgICAgY29kZWMgKz0gXCIuXCIgKyAoMCwgX2J5dGVIZWxwZXJzLnBhZFN0YXJ0KSh2aWRlb0Z1bGxSYW5nZUZsYWdbMF0sIDIsICcwJyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvZGVjID0gJ3ZwOSc7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICgvXlZfQVYxLy50ZXN0KGRlY29kZWRUcmFjay5yYXdDb2RlYykpIHtcbiAgICAgIGNvZGVjID0gXCJhdjAxLlwiICsgKDAsIF9jb2RlY0hlbHBlcnMuZ2V0QXYxQ29kZWMpKGRlY29kZWRUcmFjay5jb2RlY1ByaXZhdGUpO1xuICAgIH0gZWxzZSBpZiAoL0FfQUxBQy8udGVzdChkZWNvZGVkVHJhY2sucmF3Q29kZWMpKSB7XG4gICAgICBjb2RlYyA9ICdhbGFjJztcbiAgICB9IGVsc2UgaWYgKC9BX01QRUdcXC9MMi8udGVzdChkZWNvZGVkVHJhY2sucmF3Q29kZWMpKSB7XG4gICAgICBjb2RlYyA9ICdtcDInO1xuICAgIH0gZWxzZSBpZiAoL0FfTVBFR1xcL0wzLy50ZXN0KGRlY29kZWRUcmFjay5yYXdDb2RlYykpIHtcbiAgICAgIGNvZGVjID0gJ21wMyc7XG4gICAgfSBlbHNlIGlmICgvXkFfQUFDLy50ZXN0KGRlY29kZWRUcmFjay5yYXdDb2RlYykpIHtcbiAgICAgIGlmIChkZWNvZGVkVHJhY2suY29kZWNQcml2YXRlKSB7XG4gICAgICAgIGNvZGVjID0gJ21wNGEuNDAuJyArIChkZWNvZGVkVHJhY2suY29kZWNQcml2YXRlWzBdID4+PiAzKS50b1N0cmluZygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29kZWMgPSAnbXA0YS40MC4yJztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKC9eQV9BQzMvLnRlc3QoZGVjb2RlZFRyYWNrLnJhd0NvZGVjKSkge1xuICAgICAgY29kZWMgPSAnYWMtMyc7XG4gICAgfSBlbHNlIGlmICgvXkFfUENNLy50ZXN0KGRlY29kZWRUcmFjay5yYXdDb2RlYykpIHtcbiAgICAgIGNvZGVjID0gJ3BjbSc7XG4gICAgfSBlbHNlIGlmICgvXkFfTVNcXC9BQ00vLnRlc3QoZGVjb2RlZFRyYWNrLnJhd0NvZGVjKSkge1xuICAgICAgY29kZWMgPSAnc3BlZXgnO1xuICAgIH0gZWxzZSBpZiAoL15BX0VBQzMvLnRlc3QoZGVjb2RlZFRyYWNrLnJhd0NvZGVjKSkge1xuICAgICAgY29kZWMgPSAnZWMtMyc7XG4gICAgfSBlbHNlIGlmICgvXkFfVk9SQklTLy50ZXN0KGRlY29kZWRUcmFjay5yYXdDb2RlYykpIHtcbiAgICAgIGNvZGVjID0gJ3ZvcmJpcyc7XG4gICAgfSBlbHNlIGlmICgvXkFfRkxBQy8udGVzdChkZWNvZGVkVHJhY2sucmF3Q29kZWMpKSB7XG4gICAgICBjb2RlYyA9ICdmbGFjJztcbiAgICB9IGVsc2UgaWYgKC9eQV9PUFVTLy50ZXN0KGRlY29kZWRUcmFjay5yYXdDb2RlYykpIHtcbiAgICAgIGNvZGVjID0gJ29wdXMnO1xuICAgIH1cblxuICAgIGRlY29kZWRUcmFjay5jb2RlYyA9IGNvZGVjO1xuICAgIGRlY29kZWRUcmFja3MucHVzaChkZWNvZGVkVHJhY2spO1xuICB9KTtcbiAgcmV0dXJuIGRlY29kZWRUcmFja3Muc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBhLm51bWJlciAtIGIubnVtYmVyO1xuICB9KTtcbn07XG5cbmV4cG9ydHMucGFyc2VUcmFja3MgPSBwYXJzZVRyYWNrcztcblxudmFyIHBhcnNlRGF0YSA9IGZ1bmN0aW9uIHBhcnNlRGF0YShkYXRhLCB0cmFja3MpIHtcbiAgdmFyIGFsbEJsb2NrcyA9IFtdO1xuICB2YXIgc2VnbWVudCA9IGZpbmRFYm1sKGRhdGEsIFtFQk1MX1RBR1MuU2VnbWVudF0pWzBdO1xuICB2YXIgdGltZXN0YW1wU2NhbGUgPSBmaW5kRWJtbChzZWdtZW50LCBbRUJNTF9UQUdTLlNlZ21lbnRJbmZvLCBFQk1MX1RBR1MuVGltZXN0YW1wU2NhbGVdKVswXTsgLy8gaW4gbmFub3NlY29uZHMsIGRlZmF1bHRzIHRvIDFtc1xuXG4gIGlmICh0aW1lc3RhbXBTY2FsZSAmJiB0aW1lc3RhbXBTY2FsZS5sZW5ndGgpIHtcbiAgICB0aW1lc3RhbXBTY2FsZSA9ICgwLCBfYnl0ZUhlbHBlcnMuYnl0ZXNUb051bWJlcikodGltZXN0YW1wU2NhbGUpO1xuICB9IGVsc2Uge1xuICAgIHRpbWVzdGFtcFNjYWxlID0gMTAwMDAwMDtcbiAgfVxuXG4gIHZhciBjbHVzdGVycyA9IGZpbmRFYm1sKHNlZ21lbnQsIFtFQk1MX1RBR1MuQ2x1c3Rlcl0pO1xuXG4gIGlmICghdHJhY2tzKSB7XG4gICAgdHJhY2tzID0gcGFyc2VUcmFja3Moc2VnbWVudCk7XG4gIH1cblxuICBjbHVzdGVycy5mb3JFYWNoKGZ1bmN0aW9uIChjbHVzdGVyLCBjaSkge1xuICAgIHZhciBzaW1wbGVCbG9ja3MgPSBmaW5kRWJtbChjbHVzdGVyLCBbRUJNTF9UQUdTLlNpbXBsZUJsb2NrXSkubWFwKGZ1bmN0aW9uIChiKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAnc2ltcGxlJyxcbiAgICAgICAgZGF0YTogYlxuICAgICAgfTtcbiAgICB9KTtcbiAgICB2YXIgYmxvY2tHcm91cHMgPSBmaW5kRWJtbChjbHVzdGVyLCBbRUJNTF9UQUdTLkJsb2NrR3JvdXBdKS5tYXAoZnVuY3Rpb24gKGIpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdncm91cCcsXG4gICAgICAgIGRhdGE6IGJcbiAgICAgIH07XG4gICAgfSk7XG4gICAgdmFyIHRpbWVzdGFtcCA9IGZpbmRFYm1sKGNsdXN0ZXIsIFtFQk1MX1RBR1MuVGltZXN0YW1wXSlbMF0gfHwgMDtcblxuICAgIGlmICh0aW1lc3RhbXAgJiYgdGltZXN0YW1wLmxlbmd0aCkge1xuICAgICAgdGltZXN0YW1wID0gKDAsIF9ieXRlSGVscGVycy5ieXRlc1RvTnVtYmVyKSh0aW1lc3RhbXApO1xuICAgIH0gLy8gZ2V0IGFsbCBibG9ja3MgdGhlbiBzb3J0IHRoZW0gaW50byB0aGUgY29ycmVjdCBvcmRlclxuXG5cbiAgICB2YXIgYmxvY2tzID0gc2ltcGxlQmxvY2tzLmNvbmNhdChibG9ja0dyb3Vwcykuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgcmV0dXJuIGEuZGF0YS5ieXRlT2Zmc2V0IC0gYi5kYXRhLmJ5dGVPZmZzZXQ7XG4gICAgfSk7XG4gICAgYmxvY2tzLmZvckVhY2goZnVuY3Rpb24gKGJsb2NrLCBiaSkge1xuICAgICAgdmFyIGRlY29kZWQgPSBkZWNvZGVCbG9jayhibG9jay5kYXRhLCBibG9jay50eXBlLCB0aW1lc3RhbXBTY2FsZSwgdGltZXN0YW1wKTtcbiAgICAgIGFsbEJsb2Nrcy5wdXNoKGRlY29kZWQpO1xuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuIHtcbiAgICB0cmFja3M6IHRyYWNrcyxcbiAgICBibG9ja3M6IGFsbEJsb2Nrc1xuICB9O1xufTtcblxuZXhwb3J0cy5wYXJzZURhdGEgPSBwYXJzZURhdGE7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@videojs/vhs-utils/cjs/ebml-helpers.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@videojs/vhs-utils/cjs/id3-helpers.js":
/*!************************************************************!*\
  !*** ./node_modules/@videojs/vhs-utils/cjs/id3-helpers.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.getId3Offset = exports.getId3Size = void 0;\n\nvar _byteHelpers = __webpack_require__(/*! ./byte-helpers.js */ \"(ssr)/./node_modules/@videojs/vhs-utils/cjs/byte-helpers.js\");\n\nvar ID3 = (0, _byteHelpers.toUint8)([0x49, 0x44, 0x33]);\n\nvar getId3Size = function getId3Size(bytes, offset) {\n  if (offset === void 0) {\n    offset = 0;\n  }\n\n  bytes = (0, _byteHelpers.toUint8)(bytes);\n  var flags = bytes[offset + 5];\n  var returnSize = bytes[offset + 6] << 21 | bytes[offset + 7] << 14 | bytes[offset + 8] << 7 | bytes[offset + 9];\n  var footerPresent = (flags & 16) >> 4;\n\n  if (footerPresent) {\n    return returnSize + 20;\n  }\n\n  return returnSize + 10;\n};\n\nexports.getId3Size = getId3Size;\n\nvar getId3Offset = function getId3Offset(bytes, offset) {\n  if (offset === void 0) {\n    offset = 0;\n  }\n\n  bytes = (0, _byteHelpers.toUint8)(bytes);\n\n  if (bytes.length - offset < 10 || !(0, _byteHelpers.bytesMatch)(bytes, ID3, {\n    offset: offset\n  })) {\n    return offset;\n  }\n\n  offset += getId3Size(bytes, offset); // recursive check for id3 tags as some files\n  // have multiple ID3 tag sections even though\n  // they should not.\n\n  return getId3Offset(bytes, offset);\n};\n\nexports.getId3Offset = getId3Offset;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHZpZGVvanMvdmhzLXV0aWxzL2Nqcy9pZDMtaGVscGVycy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRixvQkFBb0IsR0FBRyxrQkFBa0I7O0FBRXpDLG1CQUFtQixtQkFBTyxDQUFDLHNGQUFtQjs7QUFFOUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsa0JBQWtCOztBQUVsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUEsdUNBQXVDO0FBQ3ZDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxvQkFBb0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS12MC1wcm9qZWN0Ly4vbm9kZV9tb2R1bGVzL0B2aWRlb2pzL3Zocy11dGlscy9janMvaWQzLWhlbHBlcnMuanM/YTE2YSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZ2V0SWQzT2Zmc2V0ID0gZXhwb3J0cy5nZXRJZDNTaXplID0gdm9pZCAwO1xuXG52YXIgX2J5dGVIZWxwZXJzID0gcmVxdWlyZShcIi4vYnl0ZS1oZWxwZXJzLmpzXCIpO1xuXG52YXIgSUQzID0gKDAsIF9ieXRlSGVscGVycy50b1VpbnQ4KShbMHg0OSwgMHg0NCwgMHgzM10pO1xuXG52YXIgZ2V0SWQzU2l6ZSA9IGZ1bmN0aW9uIGdldElkM1NpemUoYnl0ZXMsIG9mZnNldCkge1xuICBpZiAob2Zmc2V0ID09PSB2b2lkIDApIHtcbiAgICBvZmZzZXQgPSAwO1xuICB9XG5cbiAgYnl0ZXMgPSAoMCwgX2J5dGVIZWxwZXJzLnRvVWludDgpKGJ5dGVzKTtcbiAgdmFyIGZsYWdzID0gYnl0ZXNbb2Zmc2V0ICsgNV07XG4gIHZhciByZXR1cm5TaXplID0gYnl0ZXNbb2Zmc2V0ICsgNl0gPDwgMjEgfCBieXRlc1tvZmZzZXQgKyA3XSA8PCAxNCB8IGJ5dGVzW29mZnNldCArIDhdIDw8IDcgfCBieXRlc1tvZmZzZXQgKyA5XTtcbiAgdmFyIGZvb3RlclByZXNlbnQgPSAoZmxhZ3MgJiAxNikgPj4gNDtcblxuICBpZiAoZm9vdGVyUHJlc2VudCkge1xuICAgIHJldHVybiByZXR1cm5TaXplICsgMjA7XG4gIH1cblxuICByZXR1cm4gcmV0dXJuU2l6ZSArIDEwO1xufTtcblxuZXhwb3J0cy5nZXRJZDNTaXplID0gZ2V0SWQzU2l6ZTtcblxudmFyIGdldElkM09mZnNldCA9IGZ1bmN0aW9uIGdldElkM09mZnNldChieXRlcywgb2Zmc2V0KSB7XG4gIGlmIChvZmZzZXQgPT09IHZvaWQgMCkge1xuICAgIG9mZnNldCA9IDA7XG4gIH1cblxuICBieXRlcyA9ICgwLCBfYnl0ZUhlbHBlcnMudG9VaW50OCkoYnl0ZXMpO1xuXG4gIGlmIChieXRlcy5sZW5ndGggLSBvZmZzZXQgPCAxMCB8fCAhKDAsIF9ieXRlSGVscGVycy5ieXRlc01hdGNoKShieXRlcywgSUQzLCB7XG4gICAgb2Zmc2V0OiBvZmZzZXRcbiAgfSkpIHtcbiAgICByZXR1cm4gb2Zmc2V0O1xuICB9XG5cbiAgb2Zmc2V0ICs9IGdldElkM1NpemUoYnl0ZXMsIG9mZnNldCk7IC8vIHJlY3Vyc2l2ZSBjaGVjayBmb3IgaWQzIHRhZ3MgYXMgc29tZSBmaWxlc1xuICAvLyBoYXZlIG11bHRpcGxlIElEMyB0YWcgc2VjdGlvbnMgZXZlbiB0aG91Z2hcbiAgLy8gdGhleSBzaG91bGQgbm90LlxuXG4gIHJldHVybiBnZXRJZDNPZmZzZXQoYnl0ZXMsIG9mZnNldCk7XG59O1xuXG5leHBvcnRzLmdldElkM09mZnNldCA9IGdldElkM09mZnNldDsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@videojs/vhs-utils/cjs/id3-helpers.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@videojs/vhs-utils/cjs/media-groups.js":
/*!*************************************************************!*\
  !*** ./node_modules/@videojs/vhs-utils/cjs/media-groups.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.forEachMediaGroup = void 0;\n\n/**\n * Loops through all supported media groups in master and calls the provided\n * callback for each group\n *\n * @param {Object} master\n *        The parsed master manifest object\n * @param {string[]} groups\n *        The media groups to call the callback for\n * @param {Function} callback\n *        Callback to call for each media group\n */\nvar forEachMediaGroup = function forEachMediaGroup(master, groups, callback) {\n  groups.forEach(function (mediaType) {\n    for (var groupKey in master.mediaGroups[mediaType]) {\n      for (var labelKey in master.mediaGroups[mediaType][groupKey]) {\n        var mediaProperties = master.mediaGroups[mediaType][groupKey][labelKey];\n        callback(mediaProperties, mediaType, groupKey, labelKey);\n      }\n    }\n  });\n};\n\nexports.forEachMediaGroup = forEachMediaGroup;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHZpZGVvanMvdmhzLXV0aWxzL2Nqcy9tZWRpYS1ncm91cHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YseUJBQXlCOztBQUV6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBLFdBQVcsVUFBVTtBQUNyQjtBQUNBLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQSx5QkFBeUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS12MC1wcm9qZWN0Ly4vbm9kZV9tb2R1bGVzL0B2aWRlb2pzL3Zocy11dGlscy9janMvbWVkaWEtZ3JvdXBzLmpzPzM0NGIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmZvckVhY2hNZWRpYUdyb3VwID0gdm9pZCAwO1xuXG4vKipcbiAqIExvb3BzIHRocm91Z2ggYWxsIHN1cHBvcnRlZCBtZWRpYSBncm91cHMgaW4gbWFzdGVyIGFuZCBjYWxscyB0aGUgcHJvdmlkZWRcbiAqIGNhbGxiYWNrIGZvciBlYWNoIGdyb3VwXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG1hc3RlclxuICogICAgICAgIFRoZSBwYXJzZWQgbWFzdGVyIG1hbmlmZXN0IG9iamVjdFxuICogQHBhcmFtIHtzdHJpbmdbXX0gZ3JvdXBzXG4gKiAgICAgICAgVGhlIG1lZGlhIGdyb3VwcyB0byBjYWxsIHRoZSBjYWxsYmFjayBmb3JcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKiAgICAgICAgQ2FsbGJhY2sgdG8gY2FsbCBmb3IgZWFjaCBtZWRpYSBncm91cFxuICovXG52YXIgZm9yRWFjaE1lZGlhR3JvdXAgPSBmdW5jdGlvbiBmb3JFYWNoTWVkaWFHcm91cChtYXN0ZXIsIGdyb3VwcywgY2FsbGJhY2spIHtcbiAgZ3JvdXBzLmZvckVhY2goZnVuY3Rpb24gKG1lZGlhVHlwZSkge1xuICAgIGZvciAodmFyIGdyb3VwS2V5IGluIG1hc3Rlci5tZWRpYUdyb3Vwc1ttZWRpYVR5cGVdKSB7XG4gICAgICBmb3IgKHZhciBsYWJlbEtleSBpbiBtYXN0ZXIubWVkaWFHcm91cHNbbWVkaWFUeXBlXVtncm91cEtleV0pIHtcbiAgICAgICAgdmFyIG1lZGlhUHJvcGVydGllcyA9IG1hc3Rlci5tZWRpYUdyb3Vwc1ttZWRpYVR5cGVdW2dyb3VwS2V5XVtsYWJlbEtleV07XG4gICAgICAgIGNhbGxiYWNrKG1lZGlhUHJvcGVydGllcywgbWVkaWFUeXBlLCBncm91cEtleSwgbGFiZWxLZXkpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59O1xuXG5leHBvcnRzLmZvckVhY2hNZWRpYUdyb3VwID0gZm9yRWFjaE1lZGlhR3JvdXA7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@videojs/vhs-utils/cjs/media-groups.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@videojs/vhs-utils/cjs/media-types.js":
/*!************************************************************!*\
  !*** ./node_modules/@videojs/vhs-utils/cjs/media-types.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.simpleTypeFromSourceType = void 0;\nvar MPEGURL_REGEX = /^(audio|video|application)\\/(x-|vnd\\.apple\\.)?mpegurl/i;\nvar DASH_REGEX = /^application\\/dash\\+xml/i;\n/**\n * Returns a string that describes the type of source based on a video source object's\n * media type.\n *\n * @see {@link https://dev.w3.org/html5/pf-summary/video.html#dom-source-type|Source Type}\n *\n * @param {string} type\n *        Video source object media type\n * @return {('hls'|'dash'|'vhs-json'|null)}\n *         VHS source type string\n */\n\nvar simpleTypeFromSourceType = function simpleTypeFromSourceType(type) {\n  if (MPEGURL_REGEX.test(type)) {\n    return 'hls';\n  }\n\n  if (DASH_REGEX.test(type)) {\n    return 'dash';\n  } // Denotes the special case of a manifest object passed to http-streaming instead of a\n  // source URL.\n  //\n  // See https://en.wikipedia.org/wiki/Media_type for details on specifying media types.\n  //\n  // In this case, vnd stands for vendor, video.js for the organization, VHS for this\n  // project, and the +json suffix identifies the structure of the media type.\n\n\n  if (type === 'application/vnd.videojs.vhs+json') {\n    return 'vhs-json';\n  }\n\n  return null;\n};\n\nexports.simpleTypeFromSourceType = simpleTypeFromSourceType;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHZpZGVvanMvdmhzLXV0aWxzL2Nqcy9tZWRpYS10eXBlcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRixnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGdDQUFnQyIsInNvdXJjZXMiOlsid2VicGFjazovL215LXYwLXByb2plY3QvLi9ub2RlX21vZHVsZXMvQHZpZGVvanMvdmhzLXV0aWxzL2Nqcy9tZWRpYS10eXBlcy5qcz8yNjA4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5zaW1wbGVUeXBlRnJvbVNvdXJjZVR5cGUgPSB2b2lkIDA7XG52YXIgTVBFR1VSTF9SRUdFWCA9IC9eKGF1ZGlvfHZpZGVvfGFwcGxpY2F0aW9uKVxcLyh4LXx2bmRcXC5hcHBsZVxcLik/bXBlZ3VybC9pO1xudmFyIERBU0hfUkVHRVggPSAvXmFwcGxpY2F0aW9uXFwvZGFzaFxcK3htbC9pO1xuLyoqXG4gKiBSZXR1cm5zIGEgc3RyaW5nIHRoYXQgZGVzY3JpYmVzIHRoZSB0eXBlIG9mIHNvdXJjZSBiYXNlZCBvbiBhIHZpZGVvIHNvdXJjZSBvYmplY3Qnc1xuICogbWVkaWEgdHlwZS5cbiAqXG4gKiBAc2VlIHtAbGluayBodHRwczovL2Rldi53My5vcmcvaHRtbDUvcGYtc3VtbWFyeS92aWRlby5odG1sI2RvbS1zb3VyY2UtdHlwZXxTb3VyY2UgVHlwZX1cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICogICAgICAgIFZpZGVvIHNvdXJjZSBvYmplY3QgbWVkaWEgdHlwZVxuICogQHJldHVybiB7KCdobHMnfCdkYXNoJ3wndmhzLWpzb24nfG51bGwpfVxuICogICAgICAgICBWSFMgc291cmNlIHR5cGUgc3RyaW5nXG4gKi9cblxudmFyIHNpbXBsZVR5cGVGcm9tU291cmNlVHlwZSA9IGZ1bmN0aW9uIHNpbXBsZVR5cGVGcm9tU291cmNlVHlwZSh0eXBlKSB7XG4gIGlmIChNUEVHVVJMX1JFR0VYLnRlc3QodHlwZSkpIHtcbiAgICByZXR1cm4gJ2hscyc7XG4gIH1cblxuICBpZiAoREFTSF9SRUdFWC50ZXN0KHR5cGUpKSB7XG4gICAgcmV0dXJuICdkYXNoJztcbiAgfSAvLyBEZW5vdGVzIHRoZSBzcGVjaWFsIGNhc2Ugb2YgYSBtYW5pZmVzdCBvYmplY3QgcGFzc2VkIHRvIGh0dHAtc3RyZWFtaW5nIGluc3RlYWQgb2YgYVxuICAvLyBzb3VyY2UgVVJMLlxuICAvL1xuICAvLyBTZWUgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTWVkaWFfdHlwZSBmb3IgZGV0YWlscyBvbiBzcGVjaWZ5aW5nIG1lZGlhIHR5cGVzLlxuICAvL1xuICAvLyBJbiB0aGlzIGNhc2UsIHZuZCBzdGFuZHMgZm9yIHZlbmRvciwgdmlkZW8uanMgZm9yIHRoZSBvcmdhbml6YXRpb24sIFZIUyBmb3IgdGhpc1xuICAvLyBwcm9qZWN0LCBhbmQgdGhlICtqc29uIHN1ZmZpeCBpZGVudGlmaWVzIHRoZSBzdHJ1Y3R1cmUgb2YgdGhlIG1lZGlhIHR5cGUuXG5cblxuICBpZiAodHlwZSA9PT0gJ2FwcGxpY2F0aW9uL3ZuZC52aWRlb2pzLnZocytqc29uJykge1xuICAgIHJldHVybiAndmhzLWpzb24nO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59O1xuXG5leHBvcnRzLnNpbXBsZVR5cGVGcm9tU291cmNlVHlwZSA9IHNpbXBsZVR5cGVGcm9tU291cmNlVHlwZTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@videojs/vhs-utils/cjs/media-types.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@videojs/vhs-utils/cjs/mp4-helpers.js":
/*!************************************************************!*\
  !*** ./node_modules/@videojs/vhs-utils/cjs/mp4-helpers.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.parseMediaInfo = exports.parseTracks = exports.addSampleDescription = exports.buildFrameTable = exports.findNamedBox = exports.findBox = exports.parseDescriptors = void 0;\n\nvar _byteHelpers = __webpack_require__(/*! ./byte-helpers.js */ \"(ssr)/./node_modules/@videojs/vhs-utils/cjs/byte-helpers.js\");\n\nvar _codecHelpers = __webpack_require__(/*! ./codec-helpers.js */ \"(ssr)/./node_modules/@videojs/vhs-utils/cjs/codec-helpers.js\");\n\nvar _opusHelpers = __webpack_require__(/*! ./opus-helpers.js */ \"(ssr)/./node_modules/@videojs/vhs-utils/cjs/opus-helpers.js\");\n\nvar normalizePath = function normalizePath(path) {\n  if (typeof path === 'string') {\n    return (0, _byteHelpers.stringToBytes)(path);\n  }\n\n  if (typeof path === 'number') {\n    return path;\n  }\n\n  return path;\n};\n\nvar normalizePaths = function normalizePaths(paths) {\n  if (!Array.isArray(paths)) {\n    return [normalizePath(paths)];\n  }\n\n  return paths.map(function (p) {\n    return normalizePath(p);\n  });\n};\n\nvar DESCRIPTORS;\n\nvar parseDescriptors = function parseDescriptors(bytes) {\n  bytes = (0, _byteHelpers.toUint8)(bytes);\n  var results = [];\n  var i = 0;\n\n  while (bytes.length > i) {\n    var tag = bytes[i];\n    var size = 0;\n    var headerSize = 0; // tag\n\n    headerSize++;\n    var byte = bytes[headerSize]; // first byte\n\n    headerSize++;\n\n    while (byte & 0x80) {\n      size = (byte & 0x7F) << 7;\n      byte = bytes[headerSize];\n      headerSize++;\n    }\n\n    size += byte & 0x7F;\n\n    for (var z = 0; z < DESCRIPTORS.length; z++) {\n      var _DESCRIPTORS$z = DESCRIPTORS[z],\n          id = _DESCRIPTORS$z.id,\n          parser = _DESCRIPTORS$z.parser;\n\n      if (tag === id) {\n        results.push(parser(bytes.subarray(headerSize, headerSize + size)));\n        break;\n      }\n    }\n\n    i += size + headerSize;\n  }\n\n  return results;\n};\n\nexports.parseDescriptors = parseDescriptors;\nDESCRIPTORS = [{\n  id: 0x03,\n  parser: function parser(bytes) {\n    var desc = {\n      tag: 0x03,\n      id: bytes[0] << 8 | bytes[1],\n      flags: bytes[2],\n      size: 3,\n      dependsOnEsId: 0,\n      ocrEsId: 0,\n      descriptors: [],\n      url: ''\n    }; // depends on es id\n\n    if (desc.flags & 0x80) {\n      desc.dependsOnEsId = bytes[desc.size] << 8 | bytes[desc.size + 1];\n      desc.size += 2;\n    } // url\n\n\n    if (desc.flags & 0x40) {\n      var len = bytes[desc.size];\n      desc.url = (0, _byteHelpers.bytesToString)(bytes.subarray(desc.size + 1, desc.size + 1 + len));\n      desc.size += len;\n    } // ocr es id\n\n\n    if (desc.flags & 0x20) {\n      desc.ocrEsId = bytes[desc.size] << 8 | bytes[desc.size + 1];\n      desc.size += 2;\n    }\n\n    desc.descriptors = parseDescriptors(bytes.subarray(desc.size)) || [];\n    return desc;\n  }\n}, {\n  id: 0x04,\n  parser: function parser(bytes) {\n    // DecoderConfigDescriptor\n    var desc = {\n      tag: 0x04,\n      oti: bytes[0],\n      streamType: bytes[1],\n      bufferSize: bytes[2] << 16 | bytes[3] << 8 | bytes[4],\n      maxBitrate: bytes[5] << 24 | bytes[6] << 16 | bytes[7] << 8 | bytes[8],\n      avgBitrate: bytes[9] << 24 | bytes[10] << 16 | bytes[11] << 8 | bytes[12],\n      descriptors: parseDescriptors(bytes.subarray(13))\n    };\n    return desc;\n  }\n}, {\n  id: 0x05,\n  parser: function parser(bytes) {\n    // DecoderSpecificInfo\n    return {\n      tag: 0x05,\n      bytes: bytes\n    };\n  }\n}, {\n  id: 0x06,\n  parser: function parser(bytes) {\n    // SLConfigDescriptor\n    return {\n      tag: 0x06,\n      bytes: bytes\n    };\n  }\n}];\n/**\n * find any number of boxes by name given a path to it in an iso bmff\n * such as mp4.\n *\n * @param {TypedArray} bytes\n *        bytes for the iso bmff to search for boxes in\n *\n * @param {Uint8Array[]|string[]|string|Uint8Array} name\n *        An array of paths or a single path representing the name\n *        of boxes to search through in bytes. Paths may be\n *        uint8 (character codes) or strings.\n *\n * @param {boolean} [complete=false]\n *        Should we search only for complete boxes on the final path.\n *        This is very useful when you do not want to get back partial boxes\n *        in the case of streaming files.\n *\n * @return {Uint8Array[]}\n *         An array of the end paths that we found.\n */\n\nvar findBox = function findBox(bytes, paths, complete) {\n  if (complete === void 0) {\n    complete = false;\n  }\n\n  paths = normalizePaths(paths);\n  bytes = (0, _byteHelpers.toUint8)(bytes);\n  var results = [];\n\n  if (!paths.length) {\n    // short-circuit the search for empty paths\n    return results;\n  }\n\n  var i = 0;\n\n  while (i < bytes.length) {\n    var size = (bytes[i] << 24 | bytes[i + 1] << 16 | bytes[i + 2] << 8 | bytes[i + 3]) >>> 0;\n    var type = bytes.subarray(i + 4, i + 8); // invalid box format.\n\n    if (size === 0) {\n      break;\n    }\n\n    var end = i + size;\n\n    if (end > bytes.length) {\n      // this box is bigger than the number of bytes we have\n      // and complete is set, we cannot find any more boxes.\n      if (complete) {\n        break;\n      }\n\n      end = bytes.length;\n    }\n\n    var data = bytes.subarray(i + 8, end);\n\n    if ((0, _byteHelpers.bytesMatch)(type, paths[0])) {\n      if (paths.length === 1) {\n        // this is the end of the path and we've found the box we were\n        // looking for\n        results.push(data);\n      } else {\n        // recursively search for the next box along the path\n        results.push.apply(results, findBox(data, paths.slice(1), complete));\n      }\n    }\n\n    i = end;\n  } // we've finished searching all of bytes\n\n\n  return results;\n};\n/**\n * Search for a single matching box by name in an iso bmff format like\n * mp4. This function is useful for finding codec boxes which\n * can be placed arbitrarily in sample descriptions depending\n * on the version of the file or file type.\n *\n * @param {TypedArray} bytes\n *        bytes for the iso bmff to search for boxes in\n *\n * @param {string|Uint8Array} name\n *        The name of the box to find.\n *\n * @return {Uint8Array[]}\n *         a subarray of bytes representing the name boxed we found.\n */\n\n\nexports.findBox = findBox;\n\nvar findNamedBox = function findNamedBox(bytes, name) {\n  name = normalizePath(name);\n\n  if (!name.length) {\n    // short-circuit the search for empty paths\n    return bytes.subarray(bytes.length);\n  }\n\n  var i = 0;\n\n  while (i < bytes.length) {\n    if ((0, _byteHelpers.bytesMatch)(bytes.subarray(i, i + name.length), name)) {\n      var size = (bytes[i - 4] << 24 | bytes[i - 3] << 16 | bytes[i - 2] << 8 | bytes[i - 1]) >>> 0;\n      var end = size > 1 ? i + size : bytes.byteLength;\n      return bytes.subarray(i + 4, end);\n    }\n\n    i++;\n  } // we've finished searching all of bytes\n\n\n  return bytes.subarray(bytes.length);\n};\n\nexports.findNamedBox = findNamedBox;\n\nvar parseSamples = function parseSamples(data, entrySize, parseEntry) {\n  if (entrySize === void 0) {\n    entrySize = 4;\n  }\n\n  if (parseEntry === void 0) {\n    parseEntry = function parseEntry(d) {\n      return (0, _byteHelpers.bytesToNumber)(d);\n    };\n  }\n\n  var entries = [];\n\n  if (!data || !data.length) {\n    return entries;\n  }\n\n  var entryCount = (0, _byteHelpers.bytesToNumber)(data.subarray(4, 8));\n\n  for (var i = 8; entryCount; i += entrySize, entryCount--) {\n    entries.push(parseEntry(data.subarray(i, i + entrySize)));\n  }\n\n  return entries;\n};\n\nvar buildFrameTable = function buildFrameTable(stbl, timescale) {\n  var keySamples = parseSamples(findBox(stbl, ['stss'])[0]);\n  var chunkOffsets = parseSamples(findBox(stbl, ['stco'])[0]);\n  var timeToSamples = parseSamples(findBox(stbl, ['stts'])[0], 8, function (entry) {\n    return {\n      sampleCount: (0, _byteHelpers.bytesToNumber)(entry.subarray(0, 4)),\n      sampleDelta: (0, _byteHelpers.bytesToNumber)(entry.subarray(4, 8))\n    };\n  });\n  var samplesToChunks = parseSamples(findBox(stbl, ['stsc'])[0], 12, function (entry) {\n    return {\n      firstChunk: (0, _byteHelpers.bytesToNumber)(entry.subarray(0, 4)),\n      samplesPerChunk: (0, _byteHelpers.bytesToNumber)(entry.subarray(4, 8)),\n      sampleDescriptionIndex: (0, _byteHelpers.bytesToNumber)(entry.subarray(8, 12))\n    };\n  });\n  var stsz = findBox(stbl, ['stsz'])[0]; // stsz starts with a 4 byte sampleSize which we don't need\n\n  var sampleSizes = parseSamples(stsz && stsz.length && stsz.subarray(4) || null);\n  var frames = [];\n\n  for (var chunkIndex = 0; chunkIndex < chunkOffsets.length; chunkIndex++) {\n    var samplesInChunk = void 0;\n\n    for (var i = 0; i < samplesToChunks.length; i++) {\n      var sampleToChunk = samplesToChunks[i];\n      var isThisOne = chunkIndex + 1 >= sampleToChunk.firstChunk && (i + 1 >= samplesToChunks.length || chunkIndex + 1 < samplesToChunks[i + 1].firstChunk);\n\n      if (isThisOne) {\n        samplesInChunk = sampleToChunk.samplesPerChunk;\n        break;\n      }\n    }\n\n    var chunkOffset = chunkOffsets[chunkIndex];\n\n    for (var _i = 0; _i < samplesInChunk; _i++) {\n      var frameEnd = sampleSizes[frames.length]; // if we don't have key samples every frame is a keyframe\n\n      var keyframe = !keySamples.length;\n\n      if (keySamples.length && keySamples.indexOf(frames.length + 1) !== -1) {\n        keyframe = true;\n      }\n\n      var frame = {\n        keyframe: keyframe,\n        start: chunkOffset,\n        end: chunkOffset + frameEnd\n      };\n\n      for (var k = 0; k < timeToSamples.length; k++) {\n        var _timeToSamples$k = timeToSamples[k],\n            sampleCount = _timeToSamples$k.sampleCount,\n            sampleDelta = _timeToSamples$k.sampleDelta;\n\n        if (frames.length <= sampleCount) {\n          // ms to ns\n          var lastTimestamp = frames.length ? frames[frames.length - 1].timestamp : 0;\n          frame.timestamp = lastTimestamp + sampleDelta / timescale * 1000;\n          frame.duration = sampleDelta;\n          break;\n        }\n      }\n\n      frames.push(frame);\n      chunkOffset += frameEnd;\n    }\n  }\n\n  return frames;\n};\n\nexports.buildFrameTable = buildFrameTable;\n\nvar addSampleDescription = function addSampleDescription(track, bytes) {\n  var codec = (0, _byteHelpers.bytesToString)(bytes.subarray(0, 4));\n\n  if (track.type === 'video') {\n    track.info = track.info || {};\n    track.info.width = bytes[28] << 8 | bytes[29];\n    track.info.height = bytes[30] << 8 | bytes[31];\n  } else if (track.type === 'audio') {\n    track.info = track.info || {};\n    track.info.channels = bytes[20] << 8 | bytes[21];\n    track.info.bitDepth = bytes[22] << 8 | bytes[23];\n    track.info.sampleRate = bytes[28] << 8 | bytes[29];\n  }\n\n  if (codec === 'avc1') {\n    var avcC = findNamedBox(bytes, 'avcC'); // AVCDecoderConfigurationRecord\n\n    codec += \".\" + (0, _codecHelpers.getAvcCodec)(avcC);\n    track.info.avcC = avcC; // TODO: do we need to parse all this?\n\n    /* {\n      configurationVersion: avcC[0],\n      profile: avcC[1],\n      profileCompatibility: avcC[2],\n      level: avcC[3],\n      lengthSizeMinusOne: avcC[4] & 0x3\n    };\n     let spsNalUnitCount = avcC[5] & 0x1F;\n    const spsNalUnits = track.info.avc.spsNalUnits = [];\n     // past spsNalUnitCount\n    let offset = 6;\n     while (spsNalUnitCount--) {\n      const nalLen = avcC[offset] << 8 | avcC[offset + 1];\n       spsNalUnits.push(avcC.subarray(offset + 2, offset + 2 + nalLen));\n       offset += nalLen + 2;\n    }\n    let ppsNalUnitCount = avcC[offset];\n    const ppsNalUnits = track.info.avc.ppsNalUnits = [];\n     // past ppsNalUnitCount\n    offset += 1;\n     while (ppsNalUnitCount--) {\n      const nalLen = avcC[offset] << 8 | avcC[offset + 1];\n       ppsNalUnits.push(avcC.subarray(offset + 2, offset + 2 + nalLen));\n       offset += nalLen + 2;\n    }*/\n    // HEVCDecoderConfigurationRecord\n  } else if (codec === 'hvc1' || codec === 'hev1') {\n    codec += \".\" + (0, _codecHelpers.getHvcCodec)(findNamedBox(bytes, 'hvcC'));\n  } else if (codec === 'mp4a' || codec === 'mp4v') {\n    var esds = findNamedBox(bytes, 'esds');\n    var esDescriptor = parseDescriptors(esds.subarray(4))[0];\n    var decoderConfig = esDescriptor && esDescriptor.descriptors.filter(function (_ref) {\n      var tag = _ref.tag;\n      return tag === 0x04;\n    })[0];\n\n    if (decoderConfig) {\n      // most codecs do not have a further '.'\n      // such as 0xa5 for ac-3 and 0xa6 for e-ac-3\n      codec += '.' + (0, _byteHelpers.toHexString)(decoderConfig.oti);\n\n      if (decoderConfig.oti === 0x40) {\n        codec += '.' + (decoderConfig.descriptors[0].bytes[0] >> 3).toString();\n      } else if (decoderConfig.oti === 0x20) {\n        codec += '.' + decoderConfig.descriptors[0].bytes[4].toString();\n      } else if (decoderConfig.oti === 0xdd) {\n        codec = 'vorbis';\n      }\n    } else if (track.type === 'audio') {\n      codec += '.40.2';\n    } else {\n      codec += '.20.9';\n    }\n  } else if (codec === 'av01') {\n    // AV1DecoderConfigurationRecord\n    codec += \".\" + (0, _codecHelpers.getAv1Codec)(findNamedBox(bytes, 'av1C'));\n  } else if (codec === 'vp09') {\n    // VPCodecConfigurationRecord\n    var vpcC = findNamedBox(bytes, 'vpcC'); // https://www.webmproject.org/vp9/mp4/\n\n    var profile = vpcC[0];\n    var level = vpcC[1];\n    var bitDepth = vpcC[2] >> 4;\n    var chromaSubsampling = (vpcC[2] & 0x0F) >> 1;\n    var videoFullRangeFlag = (vpcC[2] & 0x0F) >> 3;\n    var colourPrimaries = vpcC[3];\n    var transferCharacteristics = vpcC[4];\n    var matrixCoefficients = vpcC[5];\n    codec += \".\" + (0, _byteHelpers.padStart)(profile, 2, '0');\n    codec += \".\" + (0, _byteHelpers.padStart)(level, 2, '0');\n    codec += \".\" + (0, _byteHelpers.padStart)(bitDepth, 2, '0');\n    codec += \".\" + (0, _byteHelpers.padStart)(chromaSubsampling, 2, '0');\n    codec += \".\" + (0, _byteHelpers.padStart)(colourPrimaries, 2, '0');\n    codec += \".\" + (0, _byteHelpers.padStart)(transferCharacteristics, 2, '0');\n    codec += \".\" + (0, _byteHelpers.padStart)(matrixCoefficients, 2, '0');\n    codec += \".\" + (0, _byteHelpers.padStart)(videoFullRangeFlag, 2, '0');\n  } else if (codec === 'theo') {\n    codec = 'theora';\n  } else if (codec === 'spex') {\n    codec = 'speex';\n  } else if (codec === '.mp3') {\n    codec = 'mp4a.40.34';\n  } else if (codec === 'msVo') {\n    codec = 'vorbis';\n  } else if (codec === 'Opus') {\n    codec = 'opus';\n    var dOps = findNamedBox(bytes, 'dOps');\n    track.info.opus = (0, _opusHelpers.parseOpusHead)(dOps); // TODO: should this go into the webm code??\n    // Firefox requires a codecDelay for opus playback\n    // see https://bugzilla.mozilla.org/show_bug.cgi?id=1276238\n\n    track.info.codecDelay = 6500000;\n  } else {\n    codec = codec.toLowerCase();\n  }\n  /* eslint-enable */\n  // flac, ac-3, ec-3, opus\n\n\n  track.codec = codec;\n};\n\nexports.addSampleDescription = addSampleDescription;\n\nvar parseTracks = function parseTracks(bytes, frameTable) {\n  if (frameTable === void 0) {\n    frameTable = true;\n  }\n\n  bytes = (0, _byteHelpers.toUint8)(bytes);\n  var traks = findBox(bytes, ['moov', 'trak'], true);\n  var tracks = [];\n  traks.forEach(function (trak) {\n    var track = {\n      bytes: trak\n    };\n    var mdia = findBox(trak, ['mdia'])[0];\n    var hdlr = findBox(mdia, ['hdlr'])[0];\n    var trakType = (0, _byteHelpers.bytesToString)(hdlr.subarray(8, 12));\n\n    if (trakType === 'soun') {\n      track.type = 'audio';\n    } else if (trakType === 'vide') {\n      track.type = 'video';\n    } else {\n      track.type = trakType;\n    }\n\n    var tkhd = findBox(trak, ['tkhd'])[0];\n\n    if (tkhd) {\n      var view = new DataView(tkhd.buffer, tkhd.byteOffset, tkhd.byteLength);\n      var tkhdVersion = view.getUint8(0);\n      track.number = tkhdVersion === 0 ? view.getUint32(12) : view.getUint32(20);\n    }\n\n    var mdhd = findBox(mdia, ['mdhd'])[0];\n\n    if (mdhd) {\n      // mdhd is a FullBox, meaning it will have its own version as the first byte\n      var version = mdhd[0];\n      var index = version === 0 ? 12 : 20;\n      track.timescale = (mdhd[index] << 24 | mdhd[index + 1] << 16 | mdhd[index + 2] << 8 | mdhd[index + 3]) >>> 0;\n    }\n\n    var stbl = findBox(mdia, ['minf', 'stbl'])[0];\n    var stsd = findBox(stbl, ['stsd'])[0];\n    var descriptionCount = (0, _byteHelpers.bytesToNumber)(stsd.subarray(4, 8));\n    var offset = 8; // add codec and codec info\n\n    while (descriptionCount--) {\n      var len = (0, _byteHelpers.bytesToNumber)(stsd.subarray(offset, offset + 4));\n      var sampleDescriptor = stsd.subarray(offset + 4, offset + 4 + len);\n      addSampleDescription(track, sampleDescriptor);\n      offset += 4 + len;\n    }\n\n    if (frameTable) {\n      track.frameTable = buildFrameTable(stbl, track.timescale);\n    } // codec has no sub parameters\n\n\n    tracks.push(track);\n  });\n  return tracks;\n};\n\nexports.parseTracks = parseTracks;\n\nvar parseMediaInfo = function parseMediaInfo(bytes) {\n  var mvhd = findBox(bytes, ['moov', 'mvhd'], true)[0];\n\n  if (!mvhd || !mvhd.length) {\n    return;\n  }\n\n  var info = {}; // ms to ns\n  // mvhd v1 has 8 byte duration and other fields too\n\n  if (mvhd[0] === 1) {\n    info.timestampScale = (0, _byteHelpers.bytesToNumber)(mvhd.subarray(20, 24));\n    info.duration = (0, _byteHelpers.bytesToNumber)(mvhd.subarray(24, 32));\n  } else {\n    info.timestampScale = (0, _byteHelpers.bytesToNumber)(mvhd.subarray(12, 16));\n    info.duration = (0, _byteHelpers.bytesToNumber)(mvhd.subarray(16, 20));\n  }\n\n  info.bytes = mvhd;\n  return info;\n};\n\nexports.parseMediaInfo = parseMediaInfo;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHZpZGVvanMvdmhzLXV0aWxzL2Nqcy9tcDQtaGVscGVycy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRixzQkFBc0IsR0FBRyxtQkFBbUIsR0FBRyw0QkFBNEIsR0FBRyx1QkFBdUIsR0FBRyxvQkFBb0IsR0FBRyxlQUFlLEdBQUcsd0JBQXdCOztBQUV6SyxtQkFBbUIsbUJBQU8sQ0FBQyxzRkFBbUI7O0FBRTlDLG9CQUFvQixtQkFBTyxDQUFDLHdGQUFvQjs7QUFFaEQsbUJBQW1CLG1CQUFPLENBQUMsc0ZBQW1COztBQUU5QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qjs7QUFFeEI7QUFDQSxrQ0FBa0M7O0FBRWxDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsb0JBQW9CLHdCQUF3QjtBQUM1QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFlBQVk7QUFDdkI7QUFDQTtBQUNBLFdBQVcseUNBQXlDO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSw2Q0FBNkM7O0FBRTdDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsWUFBWTtBQUN2QjtBQUNBO0FBQ0EsV0FBVyxtQkFBbUI7QUFDOUI7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOzs7QUFHQSxlQUFlOztBQUVmO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTs7QUFFQSxvQkFBb0I7O0FBRXBCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLGtCQUFrQixZQUFZO0FBQzlCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCx5Q0FBeUM7O0FBRXpDO0FBQ0E7O0FBRUEsMkJBQTJCLGtDQUFrQztBQUM3RDs7QUFFQSxvQkFBb0IsNEJBQTRCO0FBQ2hEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxxQkFBcUIscUJBQXFCO0FBQzFDLGlEQUFpRDs7QUFFakQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLDBCQUEwQjtBQUNoRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHVCQUF1Qjs7QUFFdkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNENBQTRDOztBQUU1QztBQUNBLDRCQUE0Qjs7QUFFNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSw0Q0FBNEM7O0FBRTVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0Q7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQSw0QkFBNEI7O0FBRTVCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7O0FBRXBCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQSxtQkFBbUI7O0FBRW5CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGlCQUFpQjtBQUNqQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS12MC1wcm9qZWN0Ly4vbm9kZV9tb2R1bGVzL0B2aWRlb2pzL3Zocy11dGlscy9janMvbXA0LWhlbHBlcnMuanM/MGI5OCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMucGFyc2VNZWRpYUluZm8gPSBleHBvcnRzLnBhcnNlVHJhY2tzID0gZXhwb3J0cy5hZGRTYW1wbGVEZXNjcmlwdGlvbiA9IGV4cG9ydHMuYnVpbGRGcmFtZVRhYmxlID0gZXhwb3J0cy5maW5kTmFtZWRCb3ggPSBleHBvcnRzLmZpbmRCb3ggPSBleHBvcnRzLnBhcnNlRGVzY3JpcHRvcnMgPSB2b2lkIDA7XG5cbnZhciBfYnl0ZUhlbHBlcnMgPSByZXF1aXJlKFwiLi9ieXRlLWhlbHBlcnMuanNcIik7XG5cbnZhciBfY29kZWNIZWxwZXJzID0gcmVxdWlyZShcIi4vY29kZWMtaGVscGVycy5qc1wiKTtcblxudmFyIF9vcHVzSGVscGVycyA9IHJlcXVpcmUoXCIuL29wdXMtaGVscGVycy5qc1wiKTtcblxudmFyIG5vcm1hbGl6ZVBhdGggPSBmdW5jdGlvbiBub3JtYWxpemVQYXRoKHBhdGgpIHtcbiAgaWYgKHR5cGVvZiBwYXRoID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiAoMCwgX2J5dGVIZWxwZXJzLnN0cmluZ1RvQnl0ZXMpKHBhdGgpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBwYXRoID09PSAnbnVtYmVyJykge1xuICAgIHJldHVybiBwYXRoO1xuICB9XG5cbiAgcmV0dXJuIHBhdGg7XG59O1xuXG52YXIgbm9ybWFsaXplUGF0aHMgPSBmdW5jdGlvbiBub3JtYWxpemVQYXRocyhwYXRocykge1xuICBpZiAoIUFycmF5LmlzQXJyYXkocGF0aHMpKSB7XG4gICAgcmV0dXJuIFtub3JtYWxpemVQYXRoKHBhdGhzKV07XG4gIH1cblxuICByZXR1cm4gcGF0aHMubWFwKGZ1bmN0aW9uIChwKSB7XG4gICAgcmV0dXJuIG5vcm1hbGl6ZVBhdGgocCk7XG4gIH0pO1xufTtcblxudmFyIERFU0NSSVBUT1JTO1xuXG52YXIgcGFyc2VEZXNjcmlwdG9ycyA9IGZ1bmN0aW9uIHBhcnNlRGVzY3JpcHRvcnMoYnl0ZXMpIHtcbiAgYnl0ZXMgPSAoMCwgX2J5dGVIZWxwZXJzLnRvVWludDgpKGJ5dGVzKTtcbiAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgdmFyIGkgPSAwO1xuXG4gIHdoaWxlIChieXRlcy5sZW5ndGggPiBpKSB7XG4gICAgdmFyIHRhZyA9IGJ5dGVzW2ldO1xuICAgIHZhciBzaXplID0gMDtcbiAgICB2YXIgaGVhZGVyU2l6ZSA9IDA7IC8vIHRhZ1xuXG4gICAgaGVhZGVyU2l6ZSsrO1xuICAgIHZhciBieXRlID0gYnl0ZXNbaGVhZGVyU2l6ZV07IC8vIGZpcnN0IGJ5dGVcblxuICAgIGhlYWRlclNpemUrKztcblxuICAgIHdoaWxlIChieXRlICYgMHg4MCkge1xuICAgICAgc2l6ZSA9IChieXRlICYgMHg3RikgPDwgNztcbiAgICAgIGJ5dGUgPSBieXRlc1toZWFkZXJTaXplXTtcbiAgICAgIGhlYWRlclNpemUrKztcbiAgICB9XG5cbiAgICBzaXplICs9IGJ5dGUgJiAweDdGO1xuXG4gICAgZm9yICh2YXIgeiA9IDA7IHogPCBERVNDUklQVE9SUy5sZW5ndGg7IHorKykge1xuICAgICAgdmFyIF9ERVNDUklQVE9SUyR6ID0gREVTQ1JJUFRPUlNbel0sXG4gICAgICAgICAgaWQgPSBfREVTQ1JJUFRPUlMkei5pZCxcbiAgICAgICAgICBwYXJzZXIgPSBfREVTQ1JJUFRPUlMkei5wYXJzZXI7XG5cbiAgICAgIGlmICh0YWcgPT09IGlkKSB7XG4gICAgICAgIHJlc3VsdHMucHVzaChwYXJzZXIoYnl0ZXMuc3ViYXJyYXkoaGVhZGVyU2l6ZSwgaGVhZGVyU2l6ZSArIHNpemUpKSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGkgKz0gc2l6ZSArIGhlYWRlclNpemU7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0cztcbn07XG5cbmV4cG9ydHMucGFyc2VEZXNjcmlwdG9ycyA9IHBhcnNlRGVzY3JpcHRvcnM7XG5ERVNDUklQVE9SUyA9IFt7XG4gIGlkOiAweDAzLFxuICBwYXJzZXI6IGZ1bmN0aW9uIHBhcnNlcihieXRlcykge1xuICAgIHZhciBkZXNjID0ge1xuICAgICAgdGFnOiAweDAzLFxuICAgICAgaWQ6IGJ5dGVzWzBdIDw8IDggfCBieXRlc1sxXSxcbiAgICAgIGZsYWdzOiBieXRlc1syXSxcbiAgICAgIHNpemU6IDMsXG4gICAgICBkZXBlbmRzT25Fc0lkOiAwLFxuICAgICAgb2NyRXNJZDogMCxcbiAgICAgIGRlc2NyaXB0b3JzOiBbXSxcbiAgICAgIHVybDogJydcbiAgICB9OyAvLyBkZXBlbmRzIG9uIGVzIGlkXG5cbiAgICBpZiAoZGVzYy5mbGFncyAmIDB4ODApIHtcbiAgICAgIGRlc2MuZGVwZW5kc09uRXNJZCA9IGJ5dGVzW2Rlc2Muc2l6ZV0gPDwgOCB8IGJ5dGVzW2Rlc2Muc2l6ZSArIDFdO1xuICAgICAgZGVzYy5zaXplICs9IDI7XG4gICAgfSAvLyB1cmxcblxuXG4gICAgaWYgKGRlc2MuZmxhZ3MgJiAweDQwKSB7XG4gICAgICB2YXIgbGVuID0gYnl0ZXNbZGVzYy5zaXplXTtcbiAgICAgIGRlc2MudXJsID0gKDAsIF9ieXRlSGVscGVycy5ieXRlc1RvU3RyaW5nKShieXRlcy5zdWJhcnJheShkZXNjLnNpemUgKyAxLCBkZXNjLnNpemUgKyAxICsgbGVuKSk7XG4gICAgICBkZXNjLnNpemUgKz0gbGVuO1xuICAgIH0gLy8gb2NyIGVzIGlkXG5cblxuICAgIGlmIChkZXNjLmZsYWdzICYgMHgyMCkge1xuICAgICAgZGVzYy5vY3JFc0lkID0gYnl0ZXNbZGVzYy5zaXplXSA8PCA4IHwgYnl0ZXNbZGVzYy5zaXplICsgMV07XG4gICAgICBkZXNjLnNpemUgKz0gMjtcbiAgICB9XG5cbiAgICBkZXNjLmRlc2NyaXB0b3JzID0gcGFyc2VEZXNjcmlwdG9ycyhieXRlcy5zdWJhcnJheShkZXNjLnNpemUpKSB8fCBbXTtcbiAgICByZXR1cm4gZGVzYztcbiAgfVxufSwge1xuICBpZDogMHgwNCxcbiAgcGFyc2VyOiBmdW5jdGlvbiBwYXJzZXIoYnl0ZXMpIHtcbiAgICAvLyBEZWNvZGVyQ29uZmlnRGVzY3JpcHRvclxuICAgIHZhciBkZXNjID0ge1xuICAgICAgdGFnOiAweDA0LFxuICAgICAgb3RpOiBieXRlc1swXSxcbiAgICAgIHN0cmVhbVR5cGU6IGJ5dGVzWzFdLFxuICAgICAgYnVmZmVyU2l6ZTogYnl0ZXNbMl0gPDwgMTYgfCBieXRlc1szXSA8PCA4IHwgYnl0ZXNbNF0sXG4gICAgICBtYXhCaXRyYXRlOiBieXRlc1s1XSA8PCAyNCB8IGJ5dGVzWzZdIDw8IDE2IHwgYnl0ZXNbN10gPDwgOCB8IGJ5dGVzWzhdLFxuICAgICAgYXZnQml0cmF0ZTogYnl0ZXNbOV0gPDwgMjQgfCBieXRlc1sxMF0gPDwgMTYgfCBieXRlc1sxMV0gPDwgOCB8IGJ5dGVzWzEyXSxcbiAgICAgIGRlc2NyaXB0b3JzOiBwYXJzZURlc2NyaXB0b3JzKGJ5dGVzLnN1YmFycmF5KDEzKSlcbiAgICB9O1xuICAgIHJldHVybiBkZXNjO1xuICB9XG59LCB7XG4gIGlkOiAweDA1LFxuICBwYXJzZXI6IGZ1bmN0aW9uIHBhcnNlcihieXRlcykge1xuICAgIC8vIERlY29kZXJTcGVjaWZpY0luZm9cbiAgICByZXR1cm4ge1xuICAgICAgdGFnOiAweDA1LFxuICAgICAgYnl0ZXM6IGJ5dGVzXG4gICAgfTtcbiAgfVxufSwge1xuICBpZDogMHgwNixcbiAgcGFyc2VyOiBmdW5jdGlvbiBwYXJzZXIoYnl0ZXMpIHtcbiAgICAvLyBTTENvbmZpZ0Rlc2NyaXB0b3JcbiAgICByZXR1cm4ge1xuICAgICAgdGFnOiAweDA2LFxuICAgICAgYnl0ZXM6IGJ5dGVzXG4gICAgfTtcbiAgfVxufV07XG4vKipcbiAqIGZpbmQgYW55IG51bWJlciBvZiBib3hlcyBieSBuYW1lIGdpdmVuIGEgcGF0aCB0byBpdCBpbiBhbiBpc28gYm1mZlxuICogc3VjaCBhcyBtcDQuXG4gKlxuICogQHBhcmFtIHtUeXBlZEFycmF5fSBieXRlc1xuICogICAgICAgIGJ5dGVzIGZvciB0aGUgaXNvIGJtZmYgdG8gc2VhcmNoIGZvciBib3hlcyBpblxuICpcbiAqIEBwYXJhbSB7VWludDhBcnJheVtdfHN0cmluZ1tdfHN0cmluZ3xVaW50OEFycmF5fSBuYW1lXG4gKiAgICAgICAgQW4gYXJyYXkgb2YgcGF0aHMgb3IgYSBzaW5nbGUgcGF0aCByZXByZXNlbnRpbmcgdGhlIG5hbWVcbiAqICAgICAgICBvZiBib3hlcyB0byBzZWFyY2ggdGhyb3VnaCBpbiBieXRlcy4gUGF0aHMgbWF5IGJlXG4gKiAgICAgICAgdWludDggKGNoYXJhY3RlciBjb2Rlcykgb3Igc3RyaW5ncy5cbiAqXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtjb21wbGV0ZT1mYWxzZV1cbiAqICAgICAgICBTaG91bGQgd2Ugc2VhcmNoIG9ubHkgZm9yIGNvbXBsZXRlIGJveGVzIG9uIHRoZSBmaW5hbCBwYXRoLlxuICogICAgICAgIFRoaXMgaXMgdmVyeSB1c2VmdWwgd2hlbiB5b3UgZG8gbm90IHdhbnQgdG8gZ2V0IGJhY2sgcGFydGlhbCBib3hlc1xuICogICAgICAgIGluIHRoZSBjYXNlIG9mIHN0cmVhbWluZyBmaWxlcy5cbiAqXG4gKiBAcmV0dXJuIHtVaW50OEFycmF5W119XG4gKiAgICAgICAgIEFuIGFycmF5IG9mIHRoZSBlbmQgcGF0aHMgdGhhdCB3ZSBmb3VuZC5cbiAqL1xuXG52YXIgZmluZEJveCA9IGZ1bmN0aW9uIGZpbmRCb3goYnl0ZXMsIHBhdGhzLCBjb21wbGV0ZSkge1xuICBpZiAoY29tcGxldGUgPT09IHZvaWQgMCkge1xuICAgIGNvbXBsZXRlID0gZmFsc2U7XG4gIH1cblxuICBwYXRocyA9IG5vcm1hbGl6ZVBhdGhzKHBhdGhzKTtcbiAgYnl0ZXMgPSAoMCwgX2J5dGVIZWxwZXJzLnRvVWludDgpKGJ5dGVzKTtcbiAgdmFyIHJlc3VsdHMgPSBbXTtcblxuICBpZiAoIXBhdGhzLmxlbmd0aCkge1xuICAgIC8vIHNob3J0LWNpcmN1aXQgdGhlIHNlYXJjaCBmb3IgZW1wdHkgcGF0aHNcbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfVxuXG4gIHZhciBpID0gMDtcblxuICB3aGlsZSAoaSA8IGJ5dGVzLmxlbmd0aCkge1xuICAgIHZhciBzaXplID0gKGJ5dGVzW2ldIDw8IDI0IHwgYnl0ZXNbaSArIDFdIDw8IDE2IHwgYnl0ZXNbaSArIDJdIDw8IDggfCBieXRlc1tpICsgM10pID4+PiAwO1xuICAgIHZhciB0eXBlID0gYnl0ZXMuc3ViYXJyYXkoaSArIDQsIGkgKyA4KTsgLy8gaW52YWxpZCBib3ggZm9ybWF0LlxuXG4gICAgaWYgKHNpemUgPT09IDApIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHZhciBlbmQgPSBpICsgc2l6ZTtcblxuICAgIGlmIChlbmQgPiBieXRlcy5sZW5ndGgpIHtcbiAgICAgIC8vIHRoaXMgYm94IGlzIGJpZ2dlciB0aGFuIHRoZSBudW1iZXIgb2YgYnl0ZXMgd2UgaGF2ZVxuICAgICAgLy8gYW5kIGNvbXBsZXRlIGlzIHNldCwgd2UgY2Fubm90IGZpbmQgYW55IG1vcmUgYm94ZXMuXG4gICAgICBpZiAoY29tcGxldGUpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGVuZCA9IGJ5dGVzLmxlbmd0aDtcbiAgICB9XG5cbiAgICB2YXIgZGF0YSA9IGJ5dGVzLnN1YmFycmF5KGkgKyA4LCBlbmQpO1xuXG4gICAgaWYgKCgwLCBfYnl0ZUhlbHBlcnMuYnl0ZXNNYXRjaCkodHlwZSwgcGF0aHNbMF0pKSB7XG4gICAgICBpZiAocGF0aHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIC8vIHRoaXMgaXMgdGhlIGVuZCBvZiB0aGUgcGF0aCBhbmQgd2UndmUgZm91bmQgdGhlIGJveCB3ZSB3ZXJlXG4gICAgICAgIC8vIGxvb2tpbmcgZm9yXG4gICAgICAgIHJlc3VsdHMucHVzaChkYXRhKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHJlY3Vyc2l2ZWx5IHNlYXJjaCBmb3IgdGhlIG5leHQgYm94IGFsb25nIHRoZSBwYXRoXG4gICAgICAgIHJlc3VsdHMucHVzaC5hcHBseShyZXN1bHRzLCBmaW5kQm94KGRhdGEsIHBhdGhzLnNsaWNlKDEpLCBjb21wbGV0ZSkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGkgPSBlbmQ7XG4gIH0gLy8gd2UndmUgZmluaXNoZWQgc2VhcmNoaW5nIGFsbCBvZiBieXRlc1xuXG5cbiAgcmV0dXJuIHJlc3VsdHM7XG59O1xuLyoqXG4gKiBTZWFyY2ggZm9yIGEgc2luZ2xlIG1hdGNoaW5nIGJveCBieSBuYW1lIGluIGFuIGlzbyBibWZmIGZvcm1hdCBsaWtlXG4gKiBtcDQuIFRoaXMgZnVuY3Rpb24gaXMgdXNlZnVsIGZvciBmaW5kaW5nIGNvZGVjIGJveGVzIHdoaWNoXG4gKiBjYW4gYmUgcGxhY2VkIGFyYml0cmFyaWx5IGluIHNhbXBsZSBkZXNjcmlwdGlvbnMgZGVwZW5kaW5nXG4gKiBvbiB0aGUgdmVyc2lvbiBvZiB0aGUgZmlsZSBvciBmaWxlIHR5cGUuXG4gKlxuICogQHBhcmFtIHtUeXBlZEFycmF5fSBieXRlc1xuICogICAgICAgIGJ5dGVzIGZvciB0aGUgaXNvIGJtZmYgdG8gc2VhcmNoIGZvciBib3hlcyBpblxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfFVpbnQ4QXJyYXl9IG5hbWVcbiAqICAgICAgICBUaGUgbmFtZSBvZiB0aGUgYm94IHRvIGZpbmQuXG4gKlxuICogQHJldHVybiB7VWludDhBcnJheVtdfVxuICogICAgICAgICBhIHN1YmFycmF5IG9mIGJ5dGVzIHJlcHJlc2VudGluZyB0aGUgbmFtZSBib3hlZCB3ZSBmb3VuZC5cbiAqL1xuXG5cbmV4cG9ydHMuZmluZEJveCA9IGZpbmRCb3g7XG5cbnZhciBmaW5kTmFtZWRCb3ggPSBmdW5jdGlvbiBmaW5kTmFtZWRCb3goYnl0ZXMsIG5hbWUpIHtcbiAgbmFtZSA9IG5vcm1hbGl6ZVBhdGgobmFtZSk7XG5cbiAgaWYgKCFuYW1lLmxlbmd0aCkge1xuICAgIC8vIHNob3J0LWNpcmN1aXQgdGhlIHNlYXJjaCBmb3IgZW1wdHkgcGF0aHNcbiAgICByZXR1cm4gYnl0ZXMuc3ViYXJyYXkoYnl0ZXMubGVuZ3RoKTtcbiAgfVxuXG4gIHZhciBpID0gMDtcblxuICB3aGlsZSAoaSA8IGJ5dGVzLmxlbmd0aCkge1xuICAgIGlmICgoMCwgX2J5dGVIZWxwZXJzLmJ5dGVzTWF0Y2gpKGJ5dGVzLnN1YmFycmF5KGksIGkgKyBuYW1lLmxlbmd0aCksIG5hbWUpKSB7XG4gICAgICB2YXIgc2l6ZSA9IChieXRlc1tpIC0gNF0gPDwgMjQgfCBieXRlc1tpIC0gM10gPDwgMTYgfCBieXRlc1tpIC0gMl0gPDwgOCB8IGJ5dGVzW2kgLSAxXSkgPj4+IDA7XG4gICAgICB2YXIgZW5kID0gc2l6ZSA+IDEgPyBpICsgc2l6ZSA6IGJ5dGVzLmJ5dGVMZW5ndGg7XG4gICAgICByZXR1cm4gYnl0ZXMuc3ViYXJyYXkoaSArIDQsIGVuZCk7XG4gICAgfVxuXG4gICAgaSsrO1xuICB9IC8vIHdlJ3ZlIGZpbmlzaGVkIHNlYXJjaGluZyBhbGwgb2YgYnl0ZXNcblxuXG4gIHJldHVybiBieXRlcy5zdWJhcnJheShieXRlcy5sZW5ndGgpO1xufTtcblxuZXhwb3J0cy5maW5kTmFtZWRCb3ggPSBmaW5kTmFtZWRCb3g7XG5cbnZhciBwYXJzZVNhbXBsZXMgPSBmdW5jdGlvbiBwYXJzZVNhbXBsZXMoZGF0YSwgZW50cnlTaXplLCBwYXJzZUVudHJ5KSB7XG4gIGlmIChlbnRyeVNpemUgPT09IHZvaWQgMCkge1xuICAgIGVudHJ5U2l6ZSA9IDQ7XG4gIH1cblxuICBpZiAocGFyc2VFbnRyeSA9PT0gdm9pZCAwKSB7XG4gICAgcGFyc2VFbnRyeSA9IGZ1bmN0aW9uIHBhcnNlRW50cnkoZCkge1xuICAgICAgcmV0dXJuICgwLCBfYnl0ZUhlbHBlcnMuYnl0ZXNUb051bWJlcikoZCk7XG4gICAgfTtcbiAgfVxuXG4gIHZhciBlbnRyaWVzID0gW107XG5cbiAgaWYgKCFkYXRhIHx8ICFkYXRhLmxlbmd0aCkge1xuICAgIHJldHVybiBlbnRyaWVzO1xuICB9XG5cbiAgdmFyIGVudHJ5Q291bnQgPSAoMCwgX2J5dGVIZWxwZXJzLmJ5dGVzVG9OdW1iZXIpKGRhdGEuc3ViYXJyYXkoNCwgOCkpO1xuXG4gIGZvciAodmFyIGkgPSA4OyBlbnRyeUNvdW50OyBpICs9IGVudHJ5U2l6ZSwgZW50cnlDb3VudC0tKSB7XG4gICAgZW50cmllcy5wdXNoKHBhcnNlRW50cnkoZGF0YS5zdWJhcnJheShpLCBpICsgZW50cnlTaXplKSkpO1xuICB9XG5cbiAgcmV0dXJuIGVudHJpZXM7XG59O1xuXG52YXIgYnVpbGRGcmFtZVRhYmxlID0gZnVuY3Rpb24gYnVpbGRGcmFtZVRhYmxlKHN0YmwsIHRpbWVzY2FsZSkge1xuICB2YXIga2V5U2FtcGxlcyA9IHBhcnNlU2FtcGxlcyhmaW5kQm94KHN0YmwsIFsnc3RzcyddKVswXSk7XG4gIHZhciBjaHVua09mZnNldHMgPSBwYXJzZVNhbXBsZXMoZmluZEJveChzdGJsLCBbJ3N0Y28nXSlbMF0pO1xuICB2YXIgdGltZVRvU2FtcGxlcyA9IHBhcnNlU2FtcGxlcyhmaW5kQm94KHN0YmwsIFsnc3R0cyddKVswXSwgOCwgZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNhbXBsZUNvdW50OiAoMCwgX2J5dGVIZWxwZXJzLmJ5dGVzVG9OdW1iZXIpKGVudHJ5LnN1YmFycmF5KDAsIDQpKSxcbiAgICAgIHNhbXBsZURlbHRhOiAoMCwgX2J5dGVIZWxwZXJzLmJ5dGVzVG9OdW1iZXIpKGVudHJ5LnN1YmFycmF5KDQsIDgpKVxuICAgIH07XG4gIH0pO1xuICB2YXIgc2FtcGxlc1RvQ2h1bmtzID0gcGFyc2VTYW1wbGVzKGZpbmRCb3goc3RibCwgWydzdHNjJ10pWzBdLCAxMiwgZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGZpcnN0Q2h1bms6ICgwLCBfYnl0ZUhlbHBlcnMuYnl0ZXNUb051bWJlcikoZW50cnkuc3ViYXJyYXkoMCwgNCkpLFxuICAgICAgc2FtcGxlc1BlckNodW5rOiAoMCwgX2J5dGVIZWxwZXJzLmJ5dGVzVG9OdW1iZXIpKGVudHJ5LnN1YmFycmF5KDQsIDgpKSxcbiAgICAgIHNhbXBsZURlc2NyaXB0aW9uSW5kZXg6ICgwLCBfYnl0ZUhlbHBlcnMuYnl0ZXNUb051bWJlcikoZW50cnkuc3ViYXJyYXkoOCwgMTIpKVxuICAgIH07XG4gIH0pO1xuICB2YXIgc3RzeiA9IGZpbmRCb3goc3RibCwgWydzdHN6J10pWzBdOyAvLyBzdHN6IHN0YXJ0cyB3aXRoIGEgNCBieXRlIHNhbXBsZVNpemUgd2hpY2ggd2UgZG9uJ3QgbmVlZFxuXG4gIHZhciBzYW1wbGVTaXplcyA9IHBhcnNlU2FtcGxlcyhzdHN6ICYmIHN0c3oubGVuZ3RoICYmIHN0c3ouc3ViYXJyYXkoNCkgfHwgbnVsbCk7XG4gIHZhciBmcmFtZXMgPSBbXTtcblxuICBmb3IgKHZhciBjaHVua0luZGV4ID0gMDsgY2h1bmtJbmRleCA8IGNodW5rT2Zmc2V0cy5sZW5ndGg7IGNodW5rSW5kZXgrKykge1xuICAgIHZhciBzYW1wbGVzSW5DaHVuayA9IHZvaWQgMDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2FtcGxlc1RvQ2h1bmtzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc2FtcGxlVG9DaHVuayA9IHNhbXBsZXNUb0NodW5rc1tpXTtcbiAgICAgIHZhciBpc1RoaXNPbmUgPSBjaHVua0luZGV4ICsgMSA+PSBzYW1wbGVUb0NodW5rLmZpcnN0Q2h1bmsgJiYgKGkgKyAxID49IHNhbXBsZXNUb0NodW5rcy5sZW5ndGggfHwgY2h1bmtJbmRleCArIDEgPCBzYW1wbGVzVG9DaHVua3NbaSArIDFdLmZpcnN0Q2h1bmspO1xuXG4gICAgICBpZiAoaXNUaGlzT25lKSB7XG4gICAgICAgIHNhbXBsZXNJbkNodW5rID0gc2FtcGxlVG9DaHVuay5zYW1wbGVzUGVyQ2h1bms7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBjaHVua09mZnNldCA9IGNodW5rT2Zmc2V0c1tjaHVua0luZGV4XTtcblxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBzYW1wbGVzSW5DaHVuazsgX2krKykge1xuICAgICAgdmFyIGZyYW1lRW5kID0gc2FtcGxlU2l6ZXNbZnJhbWVzLmxlbmd0aF07IC8vIGlmIHdlIGRvbid0IGhhdmUga2V5IHNhbXBsZXMgZXZlcnkgZnJhbWUgaXMgYSBrZXlmcmFtZVxuXG4gICAgICB2YXIga2V5ZnJhbWUgPSAha2V5U2FtcGxlcy5sZW5ndGg7XG5cbiAgICAgIGlmIChrZXlTYW1wbGVzLmxlbmd0aCAmJiBrZXlTYW1wbGVzLmluZGV4T2YoZnJhbWVzLmxlbmd0aCArIDEpICE9PSAtMSkge1xuICAgICAgICBrZXlmcmFtZSA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBmcmFtZSA9IHtcbiAgICAgICAga2V5ZnJhbWU6IGtleWZyYW1lLFxuICAgICAgICBzdGFydDogY2h1bmtPZmZzZXQsXG4gICAgICAgIGVuZDogY2h1bmtPZmZzZXQgKyBmcmFtZUVuZFxuICAgICAgfTtcblxuICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCB0aW1lVG9TYW1wbGVzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgIHZhciBfdGltZVRvU2FtcGxlcyRrID0gdGltZVRvU2FtcGxlc1trXSxcbiAgICAgICAgICAgIHNhbXBsZUNvdW50ID0gX3RpbWVUb1NhbXBsZXMkay5zYW1wbGVDb3VudCxcbiAgICAgICAgICAgIHNhbXBsZURlbHRhID0gX3RpbWVUb1NhbXBsZXMkay5zYW1wbGVEZWx0YTtcblxuICAgICAgICBpZiAoZnJhbWVzLmxlbmd0aCA8PSBzYW1wbGVDb3VudCkge1xuICAgICAgICAgIC8vIG1zIHRvIG5zXG4gICAgICAgICAgdmFyIGxhc3RUaW1lc3RhbXAgPSBmcmFtZXMubGVuZ3RoID8gZnJhbWVzW2ZyYW1lcy5sZW5ndGggLSAxXS50aW1lc3RhbXAgOiAwO1xuICAgICAgICAgIGZyYW1lLnRpbWVzdGFtcCA9IGxhc3RUaW1lc3RhbXAgKyBzYW1wbGVEZWx0YSAvIHRpbWVzY2FsZSAqIDEwMDA7XG4gICAgICAgICAgZnJhbWUuZHVyYXRpb24gPSBzYW1wbGVEZWx0YTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmcmFtZXMucHVzaChmcmFtZSk7XG4gICAgICBjaHVua09mZnNldCArPSBmcmFtZUVuZDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZnJhbWVzO1xufTtcblxuZXhwb3J0cy5idWlsZEZyYW1lVGFibGUgPSBidWlsZEZyYW1lVGFibGU7XG5cbnZhciBhZGRTYW1wbGVEZXNjcmlwdGlvbiA9IGZ1bmN0aW9uIGFkZFNhbXBsZURlc2NyaXB0aW9uKHRyYWNrLCBieXRlcykge1xuICB2YXIgY29kZWMgPSAoMCwgX2J5dGVIZWxwZXJzLmJ5dGVzVG9TdHJpbmcpKGJ5dGVzLnN1YmFycmF5KDAsIDQpKTtcblxuICBpZiAodHJhY2sudHlwZSA9PT0gJ3ZpZGVvJykge1xuICAgIHRyYWNrLmluZm8gPSB0cmFjay5pbmZvIHx8IHt9O1xuICAgIHRyYWNrLmluZm8ud2lkdGggPSBieXRlc1syOF0gPDwgOCB8IGJ5dGVzWzI5XTtcbiAgICB0cmFjay5pbmZvLmhlaWdodCA9IGJ5dGVzWzMwXSA8PCA4IHwgYnl0ZXNbMzFdO1xuICB9IGVsc2UgaWYgKHRyYWNrLnR5cGUgPT09ICdhdWRpbycpIHtcbiAgICB0cmFjay5pbmZvID0gdHJhY2suaW5mbyB8fCB7fTtcbiAgICB0cmFjay5pbmZvLmNoYW5uZWxzID0gYnl0ZXNbMjBdIDw8IDggfCBieXRlc1syMV07XG4gICAgdHJhY2suaW5mby5iaXREZXB0aCA9IGJ5dGVzWzIyXSA8PCA4IHwgYnl0ZXNbMjNdO1xuICAgIHRyYWNrLmluZm8uc2FtcGxlUmF0ZSA9IGJ5dGVzWzI4XSA8PCA4IHwgYnl0ZXNbMjldO1xuICB9XG5cbiAgaWYgKGNvZGVjID09PSAnYXZjMScpIHtcbiAgICB2YXIgYXZjQyA9IGZpbmROYW1lZEJveChieXRlcywgJ2F2Y0MnKTsgLy8gQVZDRGVjb2RlckNvbmZpZ3VyYXRpb25SZWNvcmRcblxuICAgIGNvZGVjICs9IFwiLlwiICsgKDAsIF9jb2RlY0hlbHBlcnMuZ2V0QXZjQ29kZWMpKGF2Y0MpO1xuICAgIHRyYWNrLmluZm8uYXZjQyA9IGF2Y0M7IC8vIFRPRE86IGRvIHdlIG5lZWQgdG8gcGFyc2UgYWxsIHRoaXM/XG5cbiAgICAvKiB7XG4gICAgICBjb25maWd1cmF0aW9uVmVyc2lvbjogYXZjQ1swXSxcbiAgICAgIHByb2ZpbGU6IGF2Y0NbMV0sXG4gICAgICBwcm9maWxlQ29tcGF0aWJpbGl0eTogYXZjQ1syXSxcbiAgICAgIGxldmVsOiBhdmNDWzNdLFxuICAgICAgbGVuZ3RoU2l6ZU1pbnVzT25lOiBhdmNDWzRdICYgMHgzXG4gICAgfTtcbiAgICAgbGV0IHNwc05hbFVuaXRDb3VudCA9IGF2Y0NbNV0gJiAweDFGO1xuICAgIGNvbnN0IHNwc05hbFVuaXRzID0gdHJhY2suaW5mby5hdmMuc3BzTmFsVW5pdHMgPSBbXTtcbiAgICAgLy8gcGFzdCBzcHNOYWxVbml0Q291bnRcbiAgICBsZXQgb2Zmc2V0ID0gNjtcbiAgICAgd2hpbGUgKHNwc05hbFVuaXRDb3VudC0tKSB7XG4gICAgICBjb25zdCBuYWxMZW4gPSBhdmNDW29mZnNldF0gPDwgOCB8IGF2Y0Nbb2Zmc2V0ICsgMV07XG4gICAgICAgc3BzTmFsVW5pdHMucHVzaChhdmNDLnN1YmFycmF5KG9mZnNldCArIDIsIG9mZnNldCArIDIgKyBuYWxMZW4pKTtcbiAgICAgICBvZmZzZXQgKz0gbmFsTGVuICsgMjtcbiAgICB9XG4gICAgbGV0IHBwc05hbFVuaXRDb3VudCA9IGF2Y0Nbb2Zmc2V0XTtcbiAgICBjb25zdCBwcHNOYWxVbml0cyA9IHRyYWNrLmluZm8uYXZjLnBwc05hbFVuaXRzID0gW107XG4gICAgIC8vIHBhc3QgcHBzTmFsVW5pdENvdW50XG4gICAgb2Zmc2V0ICs9IDE7XG4gICAgIHdoaWxlIChwcHNOYWxVbml0Q291bnQtLSkge1xuICAgICAgY29uc3QgbmFsTGVuID0gYXZjQ1tvZmZzZXRdIDw8IDggfCBhdmNDW29mZnNldCArIDFdO1xuICAgICAgIHBwc05hbFVuaXRzLnB1c2goYXZjQy5zdWJhcnJheShvZmZzZXQgKyAyLCBvZmZzZXQgKyAyICsgbmFsTGVuKSk7XG4gICAgICAgb2Zmc2V0ICs9IG5hbExlbiArIDI7XG4gICAgfSovXG4gICAgLy8gSEVWQ0RlY29kZXJDb25maWd1cmF0aW9uUmVjb3JkXG4gIH0gZWxzZSBpZiAoY29kZWMgPT09ICdodmMxJyB8fCBjb2RlYyA9PT0gJ2hldjEnKSB7XG4gICAgY29kZWMgKz0gXCIuXCIgKyAoMCwgX2NvZGVjSGVscGVycy5nZXRIdmNDb2RlYykoZmluZE5hbWVkQm94KGJ5dGVzLCAnaHZjQycpKTtcbiAgfSBlbHNlIGlmIChjb2RlYyA9PT0gJ21wNGEnIHx8IGNvZGVjID09PSAnbXA0dicpIHtcbiAgICB2YXIgZXNkcyA9IGZpbmROYW1lZEJveChieXRlcywgJ2VzZHMnKTtcbiAgICB2YXIgZXNEZXNjcmlwdG9yID0gcGFyc2VEZXNjcmlwdG9ycyhlc2RzLnN1YmFycmF5KDQpKVswXTtcbiAgICB2YXIgZGVjb2RlckNvbmZpZyA9IGVzRGVzY3JpcHRvciAmJiBlc0Rlc2NyaXB0b3IuZGVzY3JpcHRvcnMuZmlsdGVyKGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgICB2YXIgdGFnID0gX3JlZi50YWc7XG4gICAgICByZXR1cm4gdGFnID09PSAweDA0O1xuICAgIH0pWzBdO1xuXG4gICAgaWYgKGRlY29kZXJDb25maWcpIHtcbiAgICAgIC8vIG1vc3QgY29kZWNzIGRvIG5vdCBoYXZlIGEgZnVydGhlciAnLidcbiAgICAgIC8vIHN1Y2ggYXMgMHhhNSBmb3IgYWMtMyBhbmQgMHhhNiBmb3IgZS1hYy0zXG4gICAgICBjb2RlYyArPSAnLicgKyAoMCwgX2J5dGVIZWxwZXJzLnRvSGV4U3RyaW5nKShkZWNvZGVyQ29uZmlnLm90aSk7XG5cbiAgICAgIGlmIChkZWNvZGVyQ29uZmlnLm90aSA9PT0gMHg0MCkge1xuICAgICAgICBjb2RlYyArPSAnLicgKyAoZGVjb2RlckNvbmZpZy5kZXNjcmlwdG9yc1swXS5ieXRlc1swXSA+PiAzKS50b1N0cmluZygpO1xuICAgICAgfSBlbHNlIGlmIChkZWNvZGVyQ29uZmlnLm90aSA9PT0gMHgyMCkge1xuICAgICAgICBjb2RlYyArPSAnLicgKyBkZWNvZGVyQ29uZmlnLmRlc2NyaXB0b3JzWzBdLmJ5dGVzWzRdLnRvU3RyaW5nKCk7XG4gICAgICB9IGVsc2UgaWYgKGRlY29kZXJDb25maWcub3RpID09PSAweGRkKSB7XG4gICAgICAgIGNvZGVjID0gJ3ZvcmJpcyc7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0cmFjay50eXBlID09PSAnYXVkaW8nKSB7XG4gICAgICBjb2RlYyArPSAnLjQwLjInO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb2RlYyArPSAnLjIwLjknO1xuICAgIH1cbiAgfSBlbHNlIGlmIChjb2RlYyA9PT0gJ2F2MDEnKSB7XG4gICAgLy8gQVYxRGVjb2RlckNvbmZpZ3VyYXRpb25SZWNvcmRcbiAgICBjb2RlYyArPSBcIi5cIiArICgwLCBfY29kZWNIZWxwZXJzLmdldEF2MUNvZGVjKShmaW5kTmFtZWRCb3goYnl0ZXMsICdhdjFDJykpO1xuICB9IGVsc2UgaWYgKGNvZGVjID09PSAndnAwOScpIHtcbiAgICAvLyBWUENvZGVjQ29uZmlndXJhdGlvblJlY29yZFxuICAgIHZhciB2cGNDID0gZmluZE5hbWVkQm94KGJ5dGVzLCAndnBjQycpOyAvLyBodHRwczovL3d3dy53ZWJtcHJvamVjdC5vcmcvdnA5L21wNC9cblxuICAgIHZhciBwcm9maWxlID0gdnBjQ1swXTtcbiAgICB2YXIgbGV2ZWwgPSB2cGNDWzFdO1xuICAgIHZhciBiaXREZXB0aCA9IHZwY0NbMl0gPj4gNDtcbiAgICB2YXIgY2hyb21hU3Vic2FtcGxpbmcgPSAodnBjQ1syXSAmIDB4MEYpID4+IDE7XG4gICAgdmFyIHZpZGVvRnVsbFJhbmdlRmxhZyA9ICh2cGNDWzJdICYgMHgwRikgPj4gMztcbiAgICB2YXIgY29sb3VyUHJpbWFyaWVzID0gdnBjQ1szXTtcbiAgICB2YXIgdHJhbnNmZXJDaGFyYWN0ZXJpc3RpY3MgPSB2cGNDWzRdO1xuICAgIHZhciBtYXRyaXhDb2VmZmljaWVudHMgPSB2cGNDWzVdO1xuICAgIGNvZGVjICs9IFwiLlwiICsgKDAsIF9ieXRlSGVscGVycy5wYWRTdGFydCkocHJvZmlsZSwgMiwgJzAnKTtcbiAgICBjb2RlYyArPSBcIi5cIiArICgwLCBfYnl0ZUhlbHBlcnMucGFkU3RhcnQpKGxldmVsLCAyLCAnMCcpO1xuICAgIGNvZGVjICs9IFwiLlwiICsgKDAsIF9ieXRlSGVscGVycy5wYWRTdGFydCkoYml0RGVwdGgsIDIsICcwJyk7XG4gICAgY29kZWMgKz0gXCIuXCIgKyAoMCwgX2J5dGVIZWxwZXJzLnBhZFN0YXJ0KShjaHJvbWFTdWJzYW1wbGluZywgMiwgJzAnKTtcbiAgICBjb2RlYyArPSBcIi5cIiArICgwLCBfYnl0ZUhlbHBlcnMucGFkU3RhcnQpKGNvbG91clByaW1hcmllcywgMiwgJzAnKTtcbiAgICBjb2RlYyArPSBcIi5cIiArICgwLCBfYnl0ZUhlbHBlcnMucGFkU3RhcnQpKHRyYW5zZmVyQ2hhcmFjdGVyaXN0aWNzLCAyLCAnMCcpO1xuICAgIGNvZGVjICs9IFwiLlwiICsgKDAsIF9ieXRlSGVscGVycy5wYWRTdGFydCkobWF0cml4Q29lZmZpY2llbnRzLCAyLCAnMCcpO1xuICAgIGNvZGVjICs9IFwiLlwiICsgKDAsIF9ieXRlSGVscGVycy5wYWRTdGFydCkodmlkZW9GdWxsUmFuZ2VGbGFnLCAyLCAnMCcpO1xuICB9IGVsc2UgaWYgKGNvZGVjID09PSAndGhlbycpIHtcbiAgICBjb2RlYyA9ICd0aGVvcmEnO1xuICB9IGVsc2UgaWYgKGNvZGVjID09PSAnc3BleCcpIHtcbiAgICBjb2RlYyA9ICdzcGVleCc7XG4gIH0gZWxzZSBpZiAoY29kZWMgPT09ICcubXAzJykge1xuICAgIGNvZGVjID0gJ21wNGEuNDAuMzQnO1xuICB9IGVsc2UgaWYgKGNvZGVjID09PSAnbXNWbycpIHtcbiAgICBjb2RlYyA9ICd2b3JiaXMnO1xuICB9IGVsc2UgaWYgKGNvZGVjID09PSAnT3B1cycpIHtcbiAgICBjb2RlYyA9ICdvcHVzJztcbiAgICB2YXIgZE9wcyA9IGZpbmROYW1lZEJveChieXRlcywgJ2RPcHMnKTtcbiAgICB0cmFjay5pbmZvLm9wdXMgPSAoMCwgX29wdXNIZWxwZXJzLnBhcnNlT3B1c0hlYWQpKGRPcHMpOyAvLyBUT0RPOiBzaG91bGQgdGhpcyBnbyBpbnRvIHRoZSB3ZWJtIGNvZGU/P1xuICAgIC8vIEZpcmVmb3ggcmVxdWlyZXMgYSBjb2RlY0RlbGF5IGZvciBvcHVzIHBsYXliYWNrXG4gICAgLy8gc2VlIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTEyNzYyMzhcblxuICAgIHRyYWNrLmluZm8uY29kZWNEZWxheSA9IDY1MDAwMDA7XG4gIH0gZWxzZSB7XG4gICAgY29kZWMgPSBjb2RlYy50b0xvd2VyQ2FzZSgpO1xuICB9XG4gIC8qIGVzbGludC1lbmFibGUgKi9cbiAgLy8gZmxhYywgYWMtMywgZWMtMywgb3B1c1xuXG5cbiAgdHJhY2suY29kZWMgPSBjb2RlYztcbn07XG5cbmV4cG9ydHMuYWRkU2FtcGxlRGVzY3JpcHRpb24gPSBhZGRTYW1wbGVEZXNjcmlwdGlvbjtcblxudmFyIHBhcnNlVHJhY2tzID0gZnVuY3Rpb24gcGFyc2VUcmFja3MoYnl0ZXMsIGZyYW1lVGFibGUpIHtcbiAgaWYgKGZyYW1lVGFibGUgPT09IHZvaWQgMCkge1xuICAgIGZyYW1lVGFibGUgPSB0cnVlO1xuICB9XG5cbiAgYnl0ZXMgPSAoMCwgX2J5dGVIZWxwZXJzLnRvVWludDgpKGJ5dGVzKTtcbiAgdmFyIHRyYWtzID0gZmluZEJveChieXRlcywgWydtb292JywgJ3RyYWsnXSwgdHJ1ZSk7XG4gIHZhciB0cmFja3MgPSBbXTtcbiAgdHJha3MuZm9yRWFjaChmdW5jdGlvbiAodHJhaykge1xuICAgIHZhciB0cmFjayA9IHtcbiAgICAgIGJ5dGVzOiB0cmFrXG4gICAgfTtcbiAgICB2YXIgbWRpYSA9IGZpbmRCb3godHJhaywgWydtZGlhJ10pWzBdO1xuICAgIHZhciBoZGxyID0gZmluZEJveChtZGlhLCBbJ2hkbHInXSlbMF07XG4gICAgdmFyIHRyYWtUeXBlID0gKDAsIF9ieXRlSGVscGVycy5ieXRlc1RvU3RyaW5nKShoZGxyLnN1YmFycmF5KDgsIDEyKSk7XG5cbiAgICBpZiAodHJha1R5cGUgPT09ICdzb3VuJykge1xuICAgICAgdHJhY2sudHlwZSA9ICdhdWRpbyc7XG4gICAgfSBlbHNlIGlmICh0cmFrVHlwZSA9PT0gJ3ZpZGUnKSB7XG4gICAgICB0cmFjay50eXBlID0gJ3ZpZGVvJztcbiAgICB9IGVsc2Uge1xuICAgICAgdHJhY2sudHlwZSA9IHRyYWtUeXBlO1xuICAgIH1cblxuICAgIHZhciB0a2hkID0gZmluZEJveCh0cmFrLCBbJ3RraGQnXSlbMF07XG5cbiAgICBpZiAodGtoZCkge1xuICAgICAgdmFyIHZpZXcgPSBuZXcgRGF0YVZpZXcodGtoZC5idWZmZXIsIHRraGQuYnl0ZU9mZnNldCwgdGtoZC5ieXRlTGVuZ3RoKTtcbiAgICAgIHZhciB0a2hkVmVyc2lvbiA9IHZpZXcuZ2V0VWludDgoMCk7XG4gICAgICB0cmFjay5udW1iZXIgPSB0a2hkVmVyc2lvbiA9PT0gMCA/IHZpZXcuZ2V0VWludDMyKDEyKSA6IHZpZXcuZ2V0VWludDMyKDIwKTtcbiAgICB9XG5cbiAgICB2YXIgbWRoZCA9IGZpbmRCb3gobWRpYSwgWydtZGhkJ10pWzBdO1xuXG4gICAgaWYgKG1kaGQpIHtcbiAgICAgIC8vIG1kaGQgaXMgYSBGdWxsQm94LCBtZWFuaW5nIGl0IHdpbGwgaGF2ZSBpdHMgb3duIHZlcnNpb24gYXMgdGhlIGZpcnN0IGJ5dGVcbiAgICAgIHZhciB2ZXJzaW9uID0gbWRoZFswXTtcbiAgICAgIHZhciBpbmRleCA9IHZlcnNpb24gPT09IDAgPyAxMiA6IDIwO1xuICAgICAgdHJhY2sudGltZXNjYWxlID0gKG1kaGRbaW5kZXhdIDw8IDI0IHwgbWRoZFtpbmRleCArIDFdIDw8IDE2IHwgbWRoZFtpbmRleCArIDJdIDw8IDggfCBtZGhkW2luZGV4ICsgM10pID4+PiAwO1xuICAgIH1cblxuICAgIHZhciBzdGJsID0gZmluZEJveChtZGlhLCBbJ21pbmYnLCAnc3RibCddKVswXTtcbiAgICB2YXIgc3RzZCA9IGZpbmRCb3goc3RibCwgWydzdHNkJ10pWzBdO1xuICAgIHZhciBkZXNjcmlwdGlvbkNvdW50ID0gKDAsIF9ieXRlSGVscGVycy5ieXRlc1RvTnVtYmVyKShzdHNkLnN1YmFycmF5KDQsIDgpKTtcbiAgICB2YXIgb2Zmc2V0ID0gODsgLy8gYWRkIGNvZGVjIGFuZCBjb2RlYyBpbmZvXG5cbiAgICB3aGlsZSAoZGVzY3JpcHRpb25Db3VudC0tKSB7XG4gICAgICB2YXIgbGVuID0gKDAsIF9ieXRlSGVscGVycy5ieXRlc1RvTnVtYmVyKShzdHNkLnN1YmFycmF5KG9mZnNldCwgb2Zmc2V0ICsgNCkpO1xuICAgICAgdmFyIHNhbXBsZURlc2NyaXB0b3IgPSBzdHNkLnN1YmFycmF5KG9mZnNldCArIDQsIG9mZnNldCArIDQgKyBsZW4pO1xuICAgICAgYWRkU2FtcGxlRGVzY3JpcHRpb24odHJhY2ssIHNhbXBsZURlc2NyaXB0b3IpO1xuICAgICAgb2Zmc2V0ICs9IDQgKyBsZW47XG4gICAgfVxuXG4gICAgaWYgKGZyYW1lVGFibGUpIHtcbiAgICAgIHRyYWNrLmZyYW1lVGFibGUgPSBidWlsZEZyYW1lVGFibGUoc3RibCwgdHJhY2sudGltZXNjYWxlKTtcbiAgICB9IC8vIGNvZGVjIGhhcyBubyBzdWIgcGFyYW1ldGVyc1xuXG5cbiAgICB0cmFja3MucHVzaCh0cmFjayk7XG4gIH0pO1xuICByZXR1cm4gdHJhY2tzO1xufTtcblxuZXhwb3J0cy5wYXJzZVRyYWNrcyA9IHBhcnNlVHJhY2tzO1xuXG52YXIgcGFyc2VNZWRpYUluZm8gPSBmdW5jdGlvbiBwYXJzZU1lZGlhSW5mbyhieXRlcykge1xuICB2YXIgbXZoZCA9IGZpbmRCb3goYnl0ZXMsIFsnbW9vdicsICdtdmhkJ10sIHRydWUpWzBdO1xuXG4gIGlmICghbXZoZCB8fCAhbXZoZC5sZW5ndGgpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgaW5mbyA9IHt9OyAvLyBtcyB0byBuc1xuICAvLyBtdmhkIHYxIGhhcyA4IGJ5dGUgZHVyYXRpb24gYW5kIG90aGVyIGZpZWxkcyB0b29cblxuICBpZiAobXZoZFswXSA9PT0gMSkge1xuICAgIGluZm8udGltZXN0YW1wU2NhbGUgPSAoMCwgX2J5dGVIZWxwZXJzLmJ5dGVzVG9OdW1iZXIpKG12aGQuc3ViYXJyYXkoMjAsIDI0KSk7XG4gICAgaW5mby5kdXJhdGlvbiA9ICgwLCBfYnl0ZUhlbHBlcnMuYnl0ZXNUb051bWJlcikobXZoZC5zdWJhcnJheSgyNCwgMzIpKTtcbiAgfSBlbHNlIHtcbiAgICBpbmZvLnRpbWVzdGFtcFNjYWxlID0gKDAsIF9ieXRlSGVscGVycy5ieXRlc1RvTnVtYmVyKShtdmhkLnN1YmFycmF5KDEyLCAxNikpO1xuICAgIGluZm8uZHVyYXRpb24gPSAoMCwgX2J5dGVIZWxwZXJzLmJ5dGVzVG9OdW1iZXIpKG12aGQuc3ViYXJyYXkoMTYsIDIwKSk7XG4gIH1cblxuICBpbmZvLmJ5dGVzID0gbXZoZDtcbiAgcmV0dXJuIGluZm87XG59O1xuXG5leHBvcnRzLnBhcnNlTWVkaWFJbmZvID0gcGFyc2VNZWRpYUluZm87Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@videojs/vhs-utils/cjs/mp4-helpers.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@videojs/vhs-utils/cjs/nal-helpers.js":
/*!************************************************************!*\
  !*** ./node_modules/@videojs/vhs-utils/cjs/nal-helpers.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.findH265Nal = exports.findH264Nal = exports.findNal = exports.discardEmulationPreventionBytes = exports.EMULATION_PREVENTION = exports.NAL_TYPE_TWO = exports.NAL_TYPE_ONE = void 0;\n\nvar _byteHelpers = __webpack_require__(/*! ./byte-helpers.js */ \"(ssr)/./node_modules/@videojs/vhs-utils/cjs/byte-helpers.js\");\n\nvar NAL_TYPE_ONE = (0, _byteHelpers.toUint8)([0x00, 0x00, 0x00, 0x01]);\nexports.NAL_TYPE_ONE = NAL_TYPE_ONE;\nvar NAL_TYPE_TWO = (0, _byteHelpers.toUint8)([0x00, 0x00, 0x01]);\nexports.NAL_TYPE_TWO = NAL_TYPE_TWO;\nvar EMULATION_PREVENTION = (0, _byteHelpers.toUint8)([0x00, 0x00, 0x03]);\n/**\n * Expunge any \"Emulation Prevention\" bytes from a \"Raw Byte\n * Sequence Payload\"\n *\n * @param data {Uint8Array} the bytes of a RBSP from a NAL\n * unit\n * @return {Uint8Array} the RBSP without any Emulation\n * Prevention Bytes\n */\n\nexports.EMULATION_PREVENTION = EMULATION_PREVENTION;\n\nvar discardEmulationPreventionBytes = function discardEmulationPreventionBytes(bytes) {\n  var positions = [];\n  var i = 1; // Find all `Emulation Prevention Bytes`\n\n  while (i < bytes.length - 2) {\n    if ((0, _byteHelpers.bytesMatch)(bytes.subarray(i, i + 3), EMULATION_PREVENTION)) {\n      positions.push(i + 2);\n      i++;\n    }\n\n    i++;\n  } // If no Emulation Prevention Bytes were found just return the original\n  // array\n\n\n  if (positions.length === 0) {\n    return bytes;\n  } // Create a new array to hold the NAL unit data\n\n\n  var newLength = bytes.length - positions.length;\n  var newData = new Uint8Array(newLength);\n  var sourceIndex = 0;\n\n  for (i = 0; i < newLength; sourceIndex++, i++) {\n    if (sourceIndex === positions[0]) {\n      // Skip this byte\n      sourceIndex++; // Remove this position index\n\n      positions.shift();\n    }\n\n    newData[i] = bytes[sourceIndex];\n  }\n\n  return newData;\n};\n\nexports.discardEmulationPreventionBytes = discardEmulationPreventionBytes;\n\nvar findNal = function findNal(bytes, dataType, types, nalLimit) {\n  if (nalLimit === void 0) {\n    nalLimit = Infinity;\n  }\n\n  bytes = (0, _byteHelpers.toUint8)(bytes);\n  types = [].concat(types);\n  var i = 0;\n  var nalStart;\n  var nalsFound = 0; // keep searching until:\n  // we reach the end of bytes\n  // we reach the maximum number of nals they want to seach\n  // NOTE: that we disregard nalLimit when we have found the start\n  // of the nal we want so that we can find the end of the nal we want.\n\n  while (i < bytes.length && (nalsFound < nalLimit || nalStart)) {\n    var nalOffset = void 0;\n\n    if ((0, _byteHelpers.bytesMatch)(bytes.subarray(i), NAL_TYPE_ONE)) {\n      nalOffset = 4;\n    } else if ((0, _byteHelpers.bytesMatch)(bytes.subarray(i), NAL_TYPE_TWO)) {\n      nalOffset = 3;\n    } // we are unsynced,\n    // find the next nal unit\n\n\n    if (!nalOffset) {\n      i++;\n      continue;\n    }\n\n    nalsFound++;\n\n    if (nalStart) {\n      return discardEmulationPreventionBytes(bytes.subarray(nalStart, i));\n    }\n\n    var nalType = void 0;\n\n    if (dataType === 'h264') {\n      nalType = bytes[i + nalOffset] & 0x1f;\n    } else if (dataType === 'h265') {\n      nalType = bytes[i + nalOffset] >> 1 & 0x3f;\n    }\n\n    if (types.indexOf(nalType) !== -1) {\n      nalStart = i + nalOffset;\n    } // nal header is 1 length for h264, and 2 for h265\n\n\n    i += nalOffset + (dataType === 'h264' ? 1 : 2);\n  }\n\n  return bytes.subarray(0, 0);\n};\n\nexports.findNal = findNal;\n\nvar findH264Nal = function findH264Nal(bytes, type, nalLimit) {\n  return findNal(bytes, 'h264', type, nalLimit);\n};\n\nexports.findH264Nal = findH264Nal;\n\nvar findH265Nal = function findH265Nal(bytes, type, nalLimit) {\n  return findNal(bytes, 'h265', type, nalLimit);\n};\n\nexports.findH265Nal = findH265Nal;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHZpZGVvanMvdmhzLXV0aWxzL2Nqcy9uYWwtaGVscGVycy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRixtQkFBbUIsR0FBRyxtQkFBbUIsR0FBRyxlQUFlLEdBQUcsdUNBQXVDLEdBQUcsNEJBQTRCLEdBQUcsb0JBQW9CLEdBQUcsb0JBQW9COztBQUVsTCxtQkFBbUIsbUJBQU8sQ0FBQyxzRkFBbUI7O0FBRTlDO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsWUFBWTtBQUM1QjtBQUNBLFlBQVksWUFBWTtBQUN4QjtBQUNBOztBQUVBLDRCQUE0Qjs7QUFFNUI7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjs7O0FBR0E7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTs7QUFFQSxjQUFjLGVBQWU7QUFDN0I7QUFDQTtBQUNBLHFCQUFxQjs7QUFFckI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsdUNBQXVDOztBQUV2QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxlQUFlOztBQUVmO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUI7O0FBRW5CO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS12MC1wcm9qZWN0Ly4vbm9kZV9tb2R1bGVzL0B2aWRlb2pzL3Zocy11dGlscy9janMvbmFsLWhlbHBlcnMuanM/NjNhNSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZmluZEgyNjVOYWwgPSBleHBvcnRzLmZpbmRIMjY0TmFsID0gZXhwb3J0cy5maW5kTmFsID0gZXhwb3J0cy5kaXNjYXJkRW11bGF0aW9uUHJldmVudGlvbkJ5dGVzID0gZXhwb3J0cy5FTVVMQVRJT05fUFJFVkVOVElPTiA9IGV4cG9ydHMuTkFMX1RZUEVfVFdPID0gZXhwb3J0cy5OQUxfVFlQRV9PTkUgPSB2b2lkIDA7XG5cbnZhciBfYnl0ZUhlbHBlcnMgPSByZXF1aXJlKFwiLi9ieXRlLWhlbHBlcnMuanNcIik7XG5cbnZhciBOQUxfVFlQRV9PTkUgPSAoMCwgX2J5dGVIZWxwZXJzLnRvVWludDgpKFsweDAwLCAweDAwLCAweDAwLCAweDAxXSk7XG5leHBvcnRzLk5BTF9UWVBFX09ORSA9IE5BTF9UWVBFX09ORTtcbnZhciBOQUxfVFlQRV9UV08gPSAoMCwgX2J5dGVIZWxwZXJzLnRvVWludDgpKFsweDAwLCAweDAwLCAweDAxXSk7XG5leHBvcnRzLk5BTF9UWVBFX1RXTyA9IE5BTF9UWVBFX1RXTztcbnZhciBFTVVMQVRJT05fUFJFVkVOVElPTiA9ICgwLCBfYnl0ZUhlbHBlcnMudG9VaW50OCkoWzB4MDAsIDB4MDAsIDB4MDNdKTtcbi8qKlxuICogRXhwdW5nZSBhbnkgXCJFbXVsYXRpb24gUHJldmVudGlvblwiIGJ5dGVzIGZyb20gYSBcIlJhdyBCeXRlXG4gKiBTZXF1ZW5jZSBQYXlsb2FkXCJcbiAqXG4gKiBAcGFyYW0gZGF0YSB7VWludDhBcnJheX0gdGhlIGJ5dGVzIG9mIGEgUkJTUCBmcm9tIGEgTkFMXG4gKiB1bml0XG4gKiBAcmV0dXJuIHtVaW50OEFycmF5fSB0aGUgUkJTUCB3aXRob3V0IGFueSBFbXVsYXRpb25cbiAqIFByZXZlbnRpb24gQnl0ZXNcbiAqL1xuXG5leHBvcnRzLkVNVUxBVElPTl9QUkVWRU5USU9OID0gRU1VTEFUSU9OX1BSRVZFTlRJT047XG5cbnZhciBkaXNjYXJkRW11bGF0aW9uUHJldmVudGlvbkJ5dGVzID0gZnVuY3Rpb24gZGlzY2FyZEVtdWxhdGlvblByZXZlbnRpb25CeXRlcyhieXRlcykge1xuICB2YXIgcG9zaXRpb25zID0gW107XG4gIHZhciBpID0gMTsgLy8gRmluZCBhbGwgYEVtdWxhdGlvbiBQcmV2ZW50aW9uIEJ5dGVzYFxuXG4gIHdoaWxlIChpIDwgYnl0ZXMubGVuZ3RoIC0gMikge1xuICAgIGlmICgoMCwgX2J5dGVIZWxwZXJzLmJ5dGVzTWF0Y2gpKGJ5dGVzLnN1YmFycmF5KGksIGkgKyAzKSwgRU1VTEFUSU9OX1BSRVZFTlRJT04pKSB7XG4gICAgICBwb3NpdGlvbnMucHVzaChpICsgMik7XG4gICAgICBpKys7XG4gICAgfVxuXG4gICAgaSsrO1xuICB9IC8vIElmIG5vIEVtdWxhdGlvbiBQcmV2ZW50aW9uIEJ5dGVzIHdlcmUgZm91bmQganVzdCByZXR1cm4gdGhlIG9yaWdpbmFsXG4gIC8vIGFycmF5XG5cblxuICBpZiAocG9zaXRpb25zLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBieXRlcztcbiAgfSAvLyBDcmVhdGUgYSBuZXcgYXJyYXkgdG8gaG9sZCB0aGUgTkFMIHVuaXQgZGF0YVxuXG5cbiAgdmFyIG5ld0xlbmd0aCA9IGJ5dGVzLmxlbmd0aCAtIHBvc2l0aW9ucy5sZW5ndGg7XG4gIHZhciBuZXdEYXRhID0gbmV3IFVpbnQ4QXJyYXkobmV3TGVuZ3RoKTtcbiAgdmFyIHNvdXJjZUluZGV4ID0gMDtcblxuICBmb3IgKGkgPSAwOyBpIDwgbmV3TGVuZ3RoOyBzb3VyY2VJbmRleCsrLCBpKyspIHtcbiAgICBpZiAoc291cmNlSW5kZXggPT09IHBvc2l0aW9uc1swXSkge1xuICAgICAgLy8gU2tpcCB0aGlzIGJ5dGVcbiAgICAgIHNvdXJjZUluZGV4Kys7IC8vIFJlbW92ZSB0aGlzIHBvc2l0aW9uIGluZGV4XG5cbiAgICAgIHBvc2l0aW9ucy5zaGlmdCgpO1xuICAgIH1cblxuICAgIG5ld0RhdGFbaV0gPSBieXRlc1tzb3VyY2VJbmRleF07XG4gIH1cblxuICByZXR1cm4gbmV3RGF0YTtcbn07XG5cbmV4cG9ydHMuZGlzY2FyZEVtdWxhdGlvblByZXZlbnRpb25CeXRlcyA9IGRpc2NhcmRFbXVsYXRpb25QcmV2ZW50aW9uQnl0ZXM7XG5cbnZhciBmaW5kTmFsID0gZnVuY3Rpb24gZmluZE5hbChieXRlcywgZGF0YVR5cGUsIHR5cGVzLCBuYWxMaW1pdCkge1xuICBpZiAobmFsTGltaXQgPT09IHZvaWQgMCkge1xuICAgIG5hbExpbWl0ID0gSW5maW5pdHk7XG4gIH1cblxuICBieXRlcyA9ICgwLCBfYnl0ZUhlbHBlcnMudG9VaW50OCkoYnl0ZXMpO1xuICB0eXBlcyA9IFtdLmNvbmNhdCh0eXBlcyk7XG4gIHZhciBpID0gMDtcbiAgdmFyIG5hbFN0YXJ0O1xuICB2YXIgbmFsc0ZvdW5kID0gMDsgLy8ga2VlcCBzZWFyY2hpbmcgdW50aWw6XG4gIC8vIHdlIHJlYWNoIHRoZSBlbmQgb2YgYnl0ZXNcbiAgLy8gd2UgcmVhY2ggdGhlIG1heGltdW0gbnVtYmVyIG9mIG5hbHMgdGhleSB3YW50IHRvIHNlYWNoXG4gIC8vIE5PVEU6IHRoYXQgd2UgZGlzcmVnYXJkIG5hbExpbWl0IHdoZW4gd2UgaGF2ZSBmb3VuZCB0aGUgc3RhcnRcbiAgLy8gb2YgdGhlIG5hbCB3ZSB3YW50IHNvIHRoYXQgd2UgY2FuIGZpbmQgdGhlIGVuZCBvZiB0aGUgbmFsIHdlIHdhbnQuXG5cbiAgd2hpbGUgKGkgPCBieXRlcy5sZW5ndGggJiYgKG5hbHNGb3VuZCA8IG5hbExpbWl0IHx8IG5hbFN0YXJ0KSkge1xuICAgIHZhciBuYWxPZmZzZXQgPSB2b2lkIDA7XG5cbiAgICBpZiAoKDAsIF9ieXRlSGVscGVycy5ieXRlc01hdGNoKShieXRlcy5zdWJhcnJheShpKSwgTkFMX1RZUEVfT05FKSkge1xuICAgICAgbmFsT2Zmc2V0ID0gNDtcbiAgICB9IGVsc2UgaWYgKCgwLCBfYnl0ZUhlbHBlcnMuYnl0ZXNNYXRjaCkoYnl0ZXMuc3ViYXJyYXkoaSksIE5BTF9UWVBFX1RXTykpIHtcbiAgICAgIG5hbE9mZnNldCA9IDM7XG4gICAgfSAvLyB3ZSBhcmUgdW5zeW5jZWQsXG4gICAgLy8gZmluZCB0aGUgbmV4dCBuYWwgdW5pdFxuXG5cbiAgICBpZiAoIW5hbE9mZnNldCkge1xuICAgICAgaSsrO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgbmFsc0ZvdW5kKys7XG5cbiAgICBpZiAobmFsU3RhcnQpIHtcbiAgICAgIHJldHVybiBkaXNjYXJkRW11bGF0aW9uUHJldmVudGlvbkJ5dGVzKGJ5dGVzLnN1YmFycmF5KG5hbFN0YXJ0LCBpKSk7XG4gICAgfVxuXG4gICAgdmFyIG5hbFR5cGUgPSB2b2lkIDA7XG5cbiAgICBpZiAoZGF0YVR5cGUgPT09ICdoMjY0Jykge1xuICAgICAgbmFsVHlwZSA9IGJ5dGVzW2kgKyBuYWxPZmZzZXRdICYgMHgxZjtcbiAgICB9IGVsc2UgaWYgKGRhdGFUeXBlID09PSAnaDI2NScpIHtcbiAgICAgIG5hbFR5cGUgPSBieXRlc1tpICsgbmFsT2Zmc2V0XSA+PiAxICYgMHgzZjtcbiAgICB9XG5cbiAgICBpZiAodHlwZXMuaW5kZXhPZihuYWxUeXBlKSAhPT0gLTEpIHtcbiAgICAgIG5hbFN0YXJ0ID0gaSArIG5hbE9mZnNldDtcbiAgICB9IC8vIG5hbCBoZWFkZXIgaXMgMSBsZW5ndGggZm9yIGgyNjQsIGFuZCAyIGZvciBoMjY1XG5cblxuICAgIGkgKz0gbmFsT2Zmc2V0ICsgKGRhdGFUeXBlID09PSAnaDI2NCcgPyAxIDogMik7XG4gIH1cblxuICByZXR1cm4gYnl0ZXMuc3ViYXJyYXkoMCwgMCk7XG59O1xuXG5leHBvcnRzLmZpbmROYWwgPSBmaW5kTmFsO1xuXG52YXIgZmluZEgyNjROYWwgPSBmdW5jdGlvbiBmaW5kSDI2NE5hbChieXRlcywgdHlwZSwgbmFsTGltaXQpIHtcbiAgcmV0dXJuIGZpbmROYWwoYnl0ZXMsICdoMjY0JywgdHlwZSwgbmFsTGltaXQpO1xufTtcblxuZXhwb3J0cy5maW5kSDI2NE5hbCA9IGZpbmRIMjY0TmFsO1xuXG52YXIgZmluZEgyNjVOYWwgPSBmdW5jdGlvbiBmaW5kSDI2NU5hbChieXRlcywgdHlwZSwgbmFsTGltaXQpIHtcbiAgcmV0dXJuIGZpbmROYWwoYnl0ZXMsICdoMjY1JywgdHlwZSwgbmFsTGltaXQpO1xufTtcblxuZXhwb3J0cy5maW5kSDI2NU5hbCA9IGZpbmRIMjY1TmFsOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@videojs/vhs-utils/cjs/nal-helpers.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@videojs/vhs-utils/cjs/opus-helpers.js":
/*!*************************************************************!*\
  !*** ./node_modules/@videojs/vhs-utils/cjs/opus-helpers.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.setOpusHead = exports.parseOpusHead = exports.OPUS_HEAD = void 0;\nvar OPUS_HEAD = new Uint8Array([// O, p, u, s\n0x4f, 0x70, 0x75, 0x73, // H, e, a, d\n0x48, 0x65, 0x61, 0x64]); // https://wiki.xiph.org/OggOpus\n// https://vfrmaniac.fushizen.eu/contents/opus_in_isobmff.html\n// https://opus-codec.org/docs/opusfile_api-0.7/structOpusHead.html\n\nexports.OPUS_HEAD = OPUS_HEAD;\n\nvar parseOpusHead = function parseOpusHead(bytes) {\n  var view = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);\n  var version = view.getUint8(0); // version 0, from mp4, does not use littleEndian.\n\n  var littleEndian = version !== 0;\n  var config = {\n    version: version,\n    channels: view.getUint8(1),\n    preSkip: view.getUint16(2, littleEndian),\n    sampleRate: view.getUint32(4, littleEndian),\n    outputGain: view.getUint16(8, littleEndian),\n    channelMappingFamily: view.getUint8(10)\n  };\n\n  if (config.channelMappingFamily > 0 && bytes.length > 10) {\n    config.streamCount = view.getUint8(11);\n    config.twoChannelStreamCount = view.getUint8(12);\n    config.channelMapping = [];\n\n    for (var c = 0; c < config.channels; c++) {\n      config.channelMapping.push(view.getUint8(13 + c));\n    }\n  }\n\n  return config;\n};\n\nexports.parseOpusHead = parseOpusHead;\n\nvar setOpusHead = function setOpusHead(config) {\n  var size = config.channelMappingFamily <= 0 ? 11 : 12 + config.channels;\n  var view = new DataView(new ArrayBuffer(size));\n  var littleEndian = config.version !== 0;\n  view.setUint8(0, config.version);\n  view.setUint8(1, config.channels);\n  view.setUint16(2, config.preSkip, littleEndian);\n  view.setUint32(4, config.sampleRate, littleEndian);\n  view.setUint16(8, config.outputGain, littleEndian);\n  view.setUint8(10, config.channelMappingFamily);\n\n  if (config.channelMappingFamily > 0) {\n    view.setUint8(11, config.streamCount);\n    config.channelMapping.foreach(function (cm, i) {\n      view.setUint8(12 + i, cm);\n    });\n  }\n\n  return new Uint8Array(view.buffer);\n};\n\nexports.setOpusHead = setOpusHead;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHZpZGVvanMvdmhzLXV0aWxzL2Nqcy9vcHVzLWhlbHBlcnMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsbUJBQW1CLEdBQUcscUJBQXFCLEdBQUcsaUJBQWlCO0FBQy9EO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTs7QUFFQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQSxrQ0FBa0M7O0FBRWxDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IscUJBQXFCO0FBQ3pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHFCQUFxQjs7QUFFckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQSxtQkFBbUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS12MC1wcm9qZWN0Ly4vbm9kZV9tb2R1bGVzL0B2aWRlb2pzL3Zocy11dGlscy9janMvb3B1cy1oZWxwZXJzLmpzPzQxOTMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLnNldE9wdXNIZWFkID0gZXhwb3J0cy5wYXJzZU9wdXNIZWFkID0gZXhwb3J0cy5PUFVTX0hFQUQgPSB2b2lkIDA7XG52YXIgT1BVU19IRUFEID0gbmV3IFVpbnQ4QXJyYXkoWy8vIE8sIHAsIHUsIHNcbjB4NGYsIDB4NzAsIDB4NzUsIDB4NzMsIC8vIEgsIGUsIGEsIGRcbjB4NDgsIDB4NjUsIDB4NjEsIDB4NjRdKTsgLy8gaHR0cHM6Ly93aWtpLnhpcGgub3JnL09nZ09wdXNcbi8vIGh0dHBzOi8vdmZybWFuaWFjLmZ1c2hpemVuLmV1L2NvbnRlbnRzL29wdXNfaW5faXNvYm1mZi5odG1sXG4vLyBodHRwczovL29wdXMtY29kZWMub3JnL2RvY3Mvb3B1c2ZpbGVfYXBpLTAuNy9zdHJ1Y3RPcHVzSGVhZC5odG1sXG5cbmV4cG9ydHMuT1BVU19IRUFEID0gT1BVU19IRUFEO1xuXG52YXIgcGFyc2VPcHVzSGVhZCA9IGZ1bmN0aW9uIHBhcnNlT3B1c0hlYWQoYnl0ZXMpIHtcbiAgdmFyIHZpZXcgPSBuZXcgRGF0YVZpZXcoYnl0ZXMuYnVmZmVyLCBieXRlcy5ieXRlT2Zmc2V0LCBieXRlcy5ieXRlTGVuZ3RoKTtcbiAgdmFyIHZlcnNpb24gPSB2aWV3LmdldFVpbnQ4KDApOyAvLyB2ZXJzaW9uIDAsIGZyb20gbXA0LCBkb2VzIG5vdCB1c2UgbGl0dGxlRW5kaWFuLlxuXG4gIHZhciBsaXR0bGVFbmRpYW4gPSB2ZXJzaW9uICE9PSAwO1xuICB2YXIgY29uZmlnID0ge1xuICAgIHZlcnNpb246IHZlcnNpb24sXG4gICAgY2hhbm5lbHM6IHZpZXcuZ2V0VWludDgoMSksXG4gICAgcHJlU2tpcDogdmlldy5nZXRVaW50MTYoMiwgbGl0dGxlRW5kaWFuKSxcbiAgICBzYW1wbGVSYXRlOiB2aWV3LmdldFVpbnQzMig0LCBsaXR0bGVFbmRpYW4pLFxuICAgIG91dHB1dEdhaW46IHZpZXcuZ2V0VWludDE2KDgsIGxpdHRsZUVuZGlhbiksXG4gICAgY2hhbm5lbE1hcHBpbmdGYW1pbHk6IHZpZXcuZ2V0VWludDgoMTApXG4gIH07XG5cbiAgaWYgKGNvbmZpZy5jaGFubmVsTWFwcGluZ0ZhbWlseSA+IDAgJiYgYnl0ZXMubGVuZ3RoID4gMTApIHtcbiAgICBjb25maWcuc3RyZWFtQ291bnQgPSB2aWV3LmdldFVpbnQ4KDExKTtcbiAgICBjb25maWcudHdvQ2hhbm5lbFN0cmVhbUNvdW50ID0gdmlldy5nZXRVaW50OCgxMik7XG4gICAgY29uZmlnLmNoYW5uZWxNYXBwaW5nID0gW107XG5cbiAgICBmb3IgKHZhciBjID0gMDsgYyA8IGNvbmZpZy5jaGFubmVsczsgYysrKSB7XG4gICAgICBjb25maWcuY2hhbm5lbE1hcHBpbmcucHVzaCh2aWV3LmdldFVpbnQ4KDEzICsgYykpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb25maWc7XG59O1xuXG5leHBvcnRzLnBhcnNlT3B1c0hlYWQgPSBwYXJzZU9wdXNIZWFkO1xuXG52YXIgc2V0T3B1c0hlYWQgPSBmdW5jdGlvbiBzZXRPcHVzSGVhZChjb25maWcpIHtcbiAgdmFyIHNpemUgPSBjb25maWcuY2hhbm5lbE1hcHBpbmdGYW1pbHkgPD0gMCA/IDExIDogMTIgKyBjb25maWcuY2hhbm5lbHM7XG4gIHZhciB2aWV3ID0gbmV3IERhdGFWaWV3KG5ldyBBcnJheUJ1ZmZlcihzaXplKSk7XG4gIHZhciBsaXR0bGVFbmRpYW4gPSBjb25maWcudmVyc2lvbiAhPT0gMDtcbiAgdmlldy5zZXRVaW50OCgwLCBjb25maWcudmVyc2lvbik7XG4gIHZpZXcuc2V0VWludDgoMSwgY29uZmlnLmNoYW5uZWxzKTtcbiAgdmlldy5zZXRVaW50MTYoMiwgY29uZmlnLnByZVNraXAsIGxpdHRsZUVuZGlhbik7XG4gIHZpZXcuc2V0VWludDMyKDQsIGNvbmZpZy5zYW1wbGVSYXRlLCBsaXR0bGVFbmRpYW4pO1xuICB2aWV3LnNldFVpbnQxNig4LCBjb25maWcub3V0cHV0R2FpbiwgbGl0dGxlRW5kaWFuKTtcbiAgdmlldy5zZXRVaW50OCgxMCwgY29uZmlnLmNoYW5uZWxNYXBwaW5nRmFtaWx5KTtcblxuICBpZiAoY29uZmlnLmNoYW5uZWxNYXBwaW5nRmFtaWx5ID4gMCkge1xuICAgIHZpZXcuc2V0VWludDgoMTEsIGNvbmZpZy5zdHJlYW1Db3VudCk7XG4gICAgY29uZmlnLmNoYW5uZWxNYXBwaW5nLmZvcmVhY2goZnVuY3Rpb24gKGNtLCBpKSB7XG4gICAgICB2aWV3LnNldFVpbnQ4KDEyICsgaSwgY20pO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHZpZXcuYnVmZmVyKTtcbn07XG5cbmV4cG9ydHMuc2V0T3B1c0hlYWQgPSBzZXRPcHVzSGVhZDsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@videojs/vhs-utils/cjs/opus-helpers.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@videojs/vhs-utils/cjs/resolve-url.js":
/*!************************************************************!*\
  !*** ./node_modules/@videojs/vhs-utils/cjs/resolve-url.js ***!
  \************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("\n\nvar _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ \"(ssr)/./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n\nvar _window = _interopRequireDefault(__webpack_require__(/*! global/window */ \"(ssr)/./node_modules/global/window.js\"));\n\nvar DEFAULT_LOCATION = 'https://example.com';\n\nvar resolveUrl = function resolveUrl(baseUrl, relativeUrl) {\n  // return early if we don't need to resolve\n  if (/^[a-z]+:/i.test(relativeUrl)) {\n    return relativeUrl;\n  } // if baseUrl is a data URI, ignore it and resolve everything relative to window.location\n\n\n  if (/^data:/.test(baseUrl)) {\n    baseUrl = _window.default.location && _window.default.location.href || '';\n  }\n\n  var protocolLess = /^\\/\\//.test(baseUrl); // remove location if window.location isn't available (i.e. we're in node)\n  // and if baseUrl isn't an absolute url\n\n  var removeLocation = !_window.default.location && !/\\/\\//i.test(baseUrl); // if the base URL is relative then combine with the current location\n\n  baseUrl = new _window.default.URL(baseUrl, _window.default.location || DEFAULT_LOCATION);\n  var newUrl = new URL(relativeUrl, baseUrl); // if we're a protocol-less url, remove the protocol\n  // and if we're location-less, remove the location\n  // otherwise, return the url unmodified\n\n  if (removeLocation) {\n    return newUrl.href.slice(DEFAULT_LOCATION.length);\n  } else if (protocolLess) {\n    return newUrl.href.slice(newUrl.protocol.length);\n  }\n\n  return newUrl.href;\n};\n\nvar _default = resolveUrl;\nexports[\"default\"] = _default;\nmodule.exports = exports.default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHZpZGVvanMvdmhzLXV0aWxzL2Nqcy9yZXNvbHZlLXVybC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw2QkFBNkIsbUJBQU8sQ0FBQywwSEFBOEM7O0FBRW5GLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGLGtCQUFlOztBQUVmLHFDQUFxQyxtQkFBTyxDQUFDLDREQUFlOztBQUU1RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTs7QUFFQSw0Q0FBNEM7QUFDNUM7O0FBRUEsNEVBQTRFOztBQUU1RTtBQUNBLDhDQUE4QztBQUM5QztBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWU7QUFDZiIsInNvdXJjZXMiOlsid2VicGFjazovL215LXYwLXByb2plY3QvLi9ub2RlX21vZHVsZXMvQHZpZGVvanMvdmhzLXV0aWxzL2Nqcy9yZXNvbHZlLXVybC5qcz8yMGM5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxudmFyIF93aW5kb3cgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJnbG9iYWwvd2luZG93XCIpKTtcblxudmFyIERFRkFVTFRfTE9DQVRJT04gPSAnaHR0cHM6Ly9leGFtcGxlLmNvbSc7XG5cbnZhciByZXNvbHZlVXJsID0gZnVuY3Rpb24gcmVzb2x2ZVVybChiYXNlVXJsLCByZWxhdGl2ZVVybCkge1xuICAvLyByZXR1cm4gZWFybHkgaWYgd2UgZG9uJ3QgbmVlZCB0byByZXNvbHZlXG4gIGlmICgvXlthLXpdKzovaS50ZXN0KHJlbGF0aXZlVXJsKSkge1xuICAgIHJldHVybiByZWxhdGl2ZVVybDtcbiAgfSAvLyBpZiBiYXNlVXJsIGlzIGEgZGF0YSBVUkksIGlnbm9yZSBpdCBhbmQgcmVzb2x2ZSBldmVyeXRoaW5nIHJlbGF0aXZlIHRvIHdpbmRvdy5sb2NhdGlvblxuXG5cbiAgaWYgKC9eZGF0YTovLnRlc3QoYmFzZVVybCkpIHtcbiAgICBiYXNlVXJsID0gX3dpbmRvdy5kZWZhdWx0LmxvY2F0aW9uICYmIF93aW5kb3cuZGVmYXVsdC5sb2NhdGlvbi5ocmVmIHx8ICcnO1xuICB9XG5cbiAgdmFyIHByb3RvY29sTGVzcyA9IC9eXFwvXFwvLy50ZXN0KGJhc2VVcmwpOyAvLyByZW1vdmUgbG9jYXRpb24gaWYgd2luZG93LmxvY2F0aW9uIGlzbid0IGF2YWlsYWJsZSAoaS5lLiB3ZSdyZSBpbiBub2RlKVxuICAvLyBhbmQgaWYgYmFzZVVybCBpc24ndCBhbiBhYnNvbHV0ZSB1cmxcblxuICB2YXIgcmVtb3ZlTG9jYXRpb24gPSAhX3dpbmRvdy5kZWZhdWx0LmxvY2F0aW9uICYmICEvXFwvXFwvL2kudGVzdChiYXNlVXJsKTsgLy8gaWYgdGhlIGJhc2UgVVJMIGlzIHJlbGF0aXZlIHRoZW4gY29tYmluZSB3aXRoIHRoZSBjdXJyZW50IGxvY2F0aW9uXG5cbiAgYmFzZVVybCA9IG5ldyBfd2luZG93LmRlZmF1bHQuVVJMKGJhc2VVcmwsIF93aW5kb3cuZGVmYXVsdC5sb2NhdGlvbiB8fCBERUZBVUxUX0xPQ0FUSU9OKTtcbiAgdmFyIG5ld1VybCA9IG5ldyBVUkwocmVsYXRpdmVVcmwsIGJhc2VVcmwpOyAvLyBpZiB3ZSdyZSBhIHByb3RvY29sLWxlc3MgdXJsLCByZW1vdmUgdGhlIHByb3RvY29sXG4gIC8vIGFuZCBpZiB3ZSdyZSBsb2NhdGlvbi1sZXNzLCByZW1vdmUgdGhlIGxvY2F0aW9uXG4gIC8vIG90aGVyd2lzZSwgcmV0dXJuIHRoZSB1cmwgdW5tb2RpZmllZFxuXG4gIGlmIChyZW1vdmVMb2NhdGlvbikge1xuICAgIHJldHVybiBuZXdVcmwuaHJlZi5zbGljZShERUZBVUxUX0xPQ0FUSU9OLmxlbmd0aCk7XG4gIH0gZWxzZSBpZiAocHJvdG9jb2xMZXNzKSB7XG4gICAgcmV0dXJuIG5ld1VybC5ocmVmLnNsaWNlKG5ld1VybC5wcm90b2NvbC5sZW5ndGgpO1xuICB9XG5cbiAgcmV0dXJuIG5ld1VybC5ocmVmO1xufTtcblxudmFyIF9kZWZhdWx0ID0gcmVzb2x2ZVVybDtcbmV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@videojs/vhs-utils/cjs/resolve-url.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@videojs/vhs-utils/cjs/stream.js":
/*!*******************************************************!*\
  !*** ./node_modules/@videojs/vhs-utils/cjs/stream.js ***!
  \*******************************************************/
/***/ ((module, exports) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n\n/**\n * @file stream.js\n */\n\n/**\n * A lightweight readable stream implemention that handles event dispatching.\n *\n * @class Stream\n */\nvar Stream = /*#__PURE__*/function () {\n  function Stream() {\n    this.listeners = {};\n  }\n  /**\n   * Add a listener for a specified event type.\n   *\n   * @param {string} type the event name\n   * @param {Function} listener the callback to be invoked when an event of\n   * the specified type occurs\n   */\n\n\n  var _proto = Stream.prototype;\n\n  _proto.on = function on(type, listener) {\n    if (!this.listeners[type]) {\n      this.listeners[type] = [];\n    }\n\n    this.listeners[type].push(listener);\n  }\n  /**\n   * Remove a listener for a specified event type.\n   *\n   * @param {string} type the event name\n   * @param {Function} listener  a function previously registered for this\n   * type of event through `on`\n   * @return {boolean} if we could turn it off or not\n   */\n  ;\n\n  _proto.off = function off(type, listener) {\n    if (!this.listeners[type]) {\n      return false;\n    }\n\n    var index = this.listeners[type].indexOf(listener); // TODO: which is better?\n    // In Video.js we slice listener functions\n    // on trigger so that it does not mess up the order\n    // while we loop through.\n    //\n    // Here we slice on off so that the loop in trigger\n    // can continue using it's old reference to loop without\n    // messing up the order.\n\n    this.listeners[type] = this.listeners[type].slice(0);\n    this.listeners[type].splice(index, 1);\n    return index > -1;\n  }\n  /**\n   * Trigger an event of the specified type on this stream. Any additional\n   * arguments to this function are passed as parameters to event listeners.\n   *\n   * @param {string} type the event name\n   */\n  ;\n\n  _proto.trigger = function trigger(type) {\n    var callbacks = this.listeners[type];\n\n    if (!callbacks) {\n      return;\n    } // Slicing the arguments on every invocation of this method\n    // can add a significant amount of overhead. Avoid the\n    // intermediate object creation for the common case of a\n    // single callback argument\n\n\n    if (arguments.length === 2) {\n      var length = callbacks.length;\n\n      for (var i = 0; i < length; ++i) {\n        callbacks[i].call(this, arguments[1]);\n      }\n    } else {\n      var args = Array.prototype.slice.call(arguments, 1);\n      var _length = callbacks.length;\n\n      for (var _i = 0; _i < _length; ++_i) {\n        callbacks[_i].apply(this, args);\n      }\n    }\n  }\n  /**\n   * Destroys the stream and cleans up.\n   */\n  ;\n\n  _proto.dispose = function dispose() {\n    this.listeners = {};\n  }\n  /**\n   * Forwards all `data` events on this stream to the destination stream. The\n   * destination stream should provide a method `push` to receive the data\n   * events as they arrive.\n   *\n   * @param {Stream} destination the stream that will receive all `data` events\n   * @see http://nodejs.org/api/stream.html#stream_readable_pipe_destination_options\n   */\n  ;\n\n  _proto.pipe = function pipe(destination) {\n    this.on('data', function (data) {\n      destination.push(data);\n    });\n  };\n\n  return Stream;\n}();\n\nexports[\"default\"] = Stream;\nmodule.exports = exports.default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHZpZGVvanMvdmhzLXV0aWxzL2Nqcy9zdHJlYW0uanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0JBQWU7O0FBRWY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFVBQVU7QUFDdkI7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFVBQVU7QUFDdkI7QUFDQSxjQUFjLFNBQVM7QUFDdkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3REFBd0Q7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUEsc0JBQXNCLFlBQVk7QUFDbEM7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBLHVCQUF1QixjQUFjO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRCxrQkFBZTtBQUNmIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktdjAtcHJvamVjdC8uL25vZGVfbW9kdWxlcy9AdmlkZW9qcy92aHMtdXRpbHMvY2pzL3N0cmVhbS5qcz9hNGVhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG4vKipcbiAqIEBmaWxlIHN0cmVhbS5qc1xuICovXG5cbi8qKlxuICogQSBsaWdodHdlaWdodCByZWFkYWJsZSBzdHJlYW0gaW1wbGVtZW50aW9uIHRoYXQgaGFuZGxlcyBldmVudCBkaXNwYXRjaGluZy5cbiAqXG4gKiBAY2xhc3MgU3RyZWFtXG4gKi9cbnZhciBTdHJlYW0gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBTdHJlYW0oKSB7XG4gICAgdGhpcy5saXN0ZW5lcnMgPSB7fTtcbiAgfVxuICAvKipcbiAgICogQWRkIGEgbGlzdGVuZXIgZm9yIGEgc3BlY2lmaWVkIGV2ZW50IHR5cGUuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIHRoZSBldmVudCBuYW1lXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGxpc3RlbmVyIHRoZSBjYWxsYmFjayB0byBiZSBpbnZva2VkIHdoZW4gYW4gZXZlbnQgb2ZcbiAgICogdGhlIHNwZWNpZmllZCB0eXBlIG9jY3Vyc1xuICAgKi9cblxuXG4gIHZhciBfcHJvdG8gPSBTdHJlYW0ucHJvdG90eXBlO1xuXG4gIF9wcm90by5vbiA9IGZ1bmN0aW9uIG9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgaWYgKCF0aGlzLmxpc3RlbmVyc1t0eXBlXSkge1xuICAgICAgdGhpcy5saXN0ZW5lcnNbdHlwZV0gPSBbXTtcbiAgICB9XG5cbiAgICB0aGlzLmxpc3RlbmVyc1t0eXBlXS5wdXNoKGxpc3RlbmVyKTtcbiAgfVxuICAvKipcbiAgICogUmVtb3ZlIGEgbGlzdGVuZXIgZm9yIGEgc3BlY2lmaWVkIGV2ZW50IHR5cGUuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIHRoZSBldmVudCBuYW1lXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGxpc3RlbmVyICBhIGZ1bmN0aW9uIHByZXZpb3VzbHkgcmVnaXN0ZXJlZCBmb3IgdGhpc1xuICAgKiB0eXBlIG9mIGV2ZW50IHRocm91Z2ggYG9uYFxuICAgKiBAcmV0dXJuIHtib29sZWFufSBpZiB3ZSBjb3VsZCB0dXJuIGl0IG9mZiBvciBub3RcbiAgICovXG4gIDtcblxuICBfcHJvdG8ub2ZmID0gZnVuY3Rpb24gb2ZmKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgaWYgKCF0aGlzLmxpc3RlbmVyc1t0eXBlXSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBpbmRleCA9IHRoaXMubGlzdGVuZXJzW3R5cGVdLmluZGV4T2YobGlzdGVuZXIpOyAvLyBUT0RPOiB3aGljaCBpcyBiZXR0ZXI/XG4gICAgLy8gSW4gVmlkZW8uanMgd2Ugc2xpY2UgbGlzdGVuZXIgZnVuY3Rpb25zXG4gICAgLy8gb24gdHJpZ2dlciBzbyB0aGF0IGl0IGRvZXMgbm90IG1lc3MgdXAgdGhlIG9yZGVyXG4gICAgLy8gd2hpbGUgd2UgbG9vcCB0aHJvdWdoLlxuICAgIC8vXG4gICAgLy8gSGVyZSB3ZSBzbGljZSBvbiBvZmYgc28gdGhhdCB0aGUgbG9vcCBpbiB0cmlnZ2VyXG4gICAgLy8gY2FuIGNvbnRpbnVlIHVzaW5nIGl0J3Mgb2xkIHJlZmVyZW5jZSB0byBsb29wIHdpdGhvdXRcbiAgICAvLyBtZXNzaW5nIHVwIHRoZSBvcmRlci5cblxuICAgIHRoaXMubGlzdGVuZXJzW3R5cGVdID0gdGhpcy5saXN0ZW5lcnNbdHlwZV0uc2xpY2UoMCk7XG4gICAgdGhpcy5saXN0ZW5lcnNbdHlwZV0uc3BsaWNlKGluZGV4LCAxKTtcbiAgICByZXR1cm4gaW5kZXggPiAtMTtcbiAgfVxuICAvKipcbiAgICogVHJpZ2dlciBhbiBldmVudCBvZiB0aGUgc3BlY2lmaWVkIHR5cGUgb24gdGhpcyBzdHJlYW0uIEFueSBhZGRpdGlvbmFsXG4gICAqIGFyZ3VtZW50cyB0byB0aGlzIGZ1bmN0aW9uIGFyZSBwYXNzZWQgYXMgcGFyYW1ldGVycyB0byBldmVudCBsaXN0ZW5lcnMuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIHRoZSBldmVudCBuYW1lXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnRyaWdnZXIgPSBmdW5jdGlvbiB0cmlnZ2VyKHR5cGUpIHtcbiAgICB2YXIgY2FsbGJhY2tzID0gdGhpcy5saXN0ZW5lcnNbdHlwZV07XG5cbiAgICBpZiAoIWNhbGxiYWNrcykge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gU2xpY2luZyB0aGUgYXJndW1lbnRzIG9uIGV2ZXJ5IGludm9jYXRpb24gb2YgdGhpcyBtZXRob2RcbiAgICAvLyBjYW4gYWRkIGEgc2lnbmlmaWNhbnQgYW1vdW50IG9mIG92ZXJoZWFkLiBBdm9pZCB0aGVcbiAgICAvLyBpbnRlcm1lZGlhdGUgb2JqZWN0IGNyZWF0aW9uIGZvciB0aGUgY29tbW9uIGNhc2Ugb2YgYVxuICAgIC8vIHNpbmdsZSBjYWxsYmFjayBhcmd1bWVudFxuXG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgdmFyIGxlbmd0aCA9IGNhbGxiYWNrcy5sZW5ndGg7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY2FsbGJhY2tzW2ldLmNhbGwodGhpcywgYXJndW1lbnRzWzFdKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgdmFyIF9sZW5ndGggPSBjYWxsYmFja3MubGVuZ3RoO1xuXG4gICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgX2xlbmd0aDsgKytfaSkge1xuICAgICAgICBjYWxsYmFja3NbX2ldLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogRGVzdHJveXMgdGhlIHN0cmVhbSBhbmQgY2xlYW5zIHVwLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5kaXNwb3NlID0gZnVuY3Rpb24gZGlzcG9zZSgpIHtcbiAgICB0aGlzLmxpc3RlbmVycyA9IHt9O1xuICB9XG4gIC8qKlxuICAgKiBGb3J3YXJkcyBhbGwgYGRhdGFgIGV2ZW50cyBvbiB0aGlzIHN0cmVhbSB0byB0aGUgZGVzdGluYXRpb24gc3RyZWFtLiBUaGVcbiAgICogZGVzdGluYXRpb24gc3RyZWFtIHNob3VsZCBwcm92aWRlIGEgbWV0aG9kIGBwdXNoYCB0byByZWNlaXZlIHRoZSBkYXRhXG4gICAqIGV2ZW50cyBhcyB0aGV5IGFycml2ZS5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJlYW19IGRlc3RpbmF0aW9uIHRoZSBzdHJlYW0gdGhhdCB3aWxsIHJlY2VpdmUgYWxsIGBkYXRhYCBldmVudHNcbiAgICogQHNlZSBodHRwOi8vbm9kZWpzLm9yZy9hcGkvc3RyZWFtLmh0bWwjc3RyZWFtX3JlYWRhYmxlX3BpcGVfZGVzdGluYXRpb25fb3B0aW9uc1xuICAgKi9cbiAgO1xuXG4gIF9wcm90by5waXBlID0gZnVuY3Rpb24gcGlwZShkZXN0aW5hdGlvbikge1xuICAgIHRoaXMub24oJ2RhdGEnLCBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgZGVzdGluYXRpb24ucHVzaChkYXRhKTtcbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4gU3RyZWFtO1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBTdHJlYW07XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@videojs/vhs-utils/cjs/stream.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@videojs/xhr/lib/http-handler.js":
/*!*******************************************************!*\
  !*** ./node_modules/@videojs/xhr/lib/http-handler.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nvar window = __webpack_require__(/*! global/window */ \"(ssr)/./node_modules/global/window.js\");\n\nvar httpResponseHandler = function httpResponseHandler(callback, decodeResponseBody) {\n  if (decodeResponseBody === void 0) {\n    decodeResponseBody = false;\n  }\n\n  return function (err, response, responseBody) {\n    // if the XHR failed, return that error\n    if (err) {\n      callback(err);\n      return;\n    } // if the HTTP status code is 4xx or 5xx, the request also failed\n\n\n    if (response.statusCode >= 400 && response.statusCode <= 599) {\n      var cause = responseBody;\n\n      if (decodeResponseBody) {\n        if (window.TextDecoder) {\n          var charset = getCharset(response.headers && response.headers['content-type']);\n\n          try {\n            cause = new TextDecoder(charset).decode(responseBody);\n          } catch (e) {}\n        } else {\n          cause = String.fromCharCode.apply(null, new Uint8Array(responseBody));\n        }\n      }\n\n      callback({\n        cause: cause\n      });\n      return;\n    } // otherwise, request succeeded\n\n\n    callback(null, responseBody);\n  };\n};\n\nfunction getCharset(contentTypeHeader) {\n  if (contentTypeHeader === void 0) {\n    contentTypeHeader = '';\n  }\n\n  return contentTypeHeader.toLowerCase().split(';').reduce(function (charset, contentType) {\n    var _contentType$split = contentType.split('='),\n        type = _contentType$split[0],\n        value = _contentType$split[1];\n\n    if (type.trim() === 'charset') {\n      return value.trim();\n    }\n\n    return charset;\n  }, 'utf-8');\n}\n\nmodule.exports = httpResponseHandler;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHZpZGVvanMveGhyL2xpYi9odHRwLWhhbmRsZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsYUFBYSxtQkFBTyxDQUFDLDREQUFlOztBQUVwQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWixVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS12MC1wcm9qZWN0Ly4vbm9kZV9tb2R1bGVzL0B2aWRlb2pzL3hoci9saWIvaHR0cC1oYW5kbGVyLmpzPzdkYjgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciB3aW5kb3cgPSByZXF1aXJlKCdnbG9iYWwvd2luZG93Jyk7XG5cbnZhciBodHRwUmVzcG9uc2VIYW5kbGVyID0gZnVuY3Rpb24gaHR0cFJlc3BvbnNlSGFuZGxlcihjYWxsYmFjaywgZGVjb2RlUmVzcG9uc2VCb2R5KSB7XG4gIGlmIChkZWNvZGVSZXNwb25zZUJvZHkgPT09IHZvaWQgMCkge1xuICAgIGRlY29kZVJlc3BvbnNlQm9keSA9IGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChlcnIsIHJlc3BvbnNlLCByZXNwb25zZUJvZHkpIHtcbiAgICAvLyBpZiB0aGUgWEhSIGZhaWxlZCwgcmV0dXJuIHRoYXQgZXJyb3JcbiAgICBpZiAoZXJyKSB7XG4gICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gaWYgdGhlIEhUVFAgc3RhdHVzIGNvZGUgaXMgNHh4IG9yIDV4eCwgdGhlIHJlcXVlc3QgYWxzbyBmYWlsZWRcblxuXG4gICAgaWYgKHJlc3BvbnNlLnN0YXR1c0NvZGUgPj0gNDAwICYmIHJlc3BvbnNlLnN0YXR1c0NvZGUgPD0gNTk5KSB7XG4gICAgICB2YXIgY2F1c2UgPSByZXNwb25zZUJvZHk7XG5cbiAgICAgIGlmIChkZWNvZGVSZXNwb25zZUJvZHkpIHtcbiAgICAgICAgaWYgKHdpbmRvdy5UZXh0RGVjb2Rlcikge1xuICAgICAgICAgIHZhciBjaGFyc2V0ID0gZ2V0Q2hhcnNldChyZXNwb25zZS5oZWFkZXJzICYmIHJlc3BvbnNlLmhlYWRlcnNbJ2NvbnRlbnQtdHlwZSddKTtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjYXVzZSA9IG5ldyBUZXh0RGVjb2RlcihjaGFyc2V0KS5kZWNvZGUocmVzcG9uc2VCb2R5KTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNhdXNlID0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBuZXcgVWludDhBcnJheShyZXNwb25zZUJvZHkpKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjYWxsYmFjayh7XG4gICAgICAgIGNhdXNlOiBjYXVzZVxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBvdGhlcndpc2UsIHJlcXVlc3Qgc3VjY2VlZGVkXG5cblxuICAgIGNhbGxiYWNrKG51bGwsIHJlc3BvbnNlQm9keSk7XG4gIH07XG59O1xuXG5mdW5jdGlvbiBnZXRDaGFyc2V0KGNvbnRlbnRUeXBlSGVhZGVyKSB7XG4gIGlmIChjb250ZW50VHlwZUhlYWRlciA9PT0gdm9pZCAwKSB7XG4gICAgY29udGVudFR5cGVIZWFkZXIgPSAnJztcbiAgfVxuXG4gIHJldHVybiBjb250ZW50VHlwZUhlYWRlci50b0xvd2VyQ2FzZSgpLnNwbGl0KCc7JykucmVkdWNlKGZ1bmN0aW9uIChjaGFyc2V0LCBjb250ZW50VHlwZSkge1xuICAgIHZhciBfY29udGVudFR5cGUkc3BsaXQgPSBjb250ZW50VHlwZS5zcGxpdCgnPScpLFxuICAgICAgICB0eXBlID0gX2NvbnRlbnRUeXBlJHNwbGl0WzBdLFxuICAgICAgICB2YWx1ZSA9IF9jb250ZW50VHlwZSRzcGxpdFsxXTtcblxuICAgIGlmICh0eXBlLnRyaW0oKSA9PT0gJ2NoYXJzZXQnKSB7XG4gICAgICByZXR1cm4gdmFsdWUudHJpbSgpO1xuICAgIH1cblxuICAgIHJldHVybiBjaGFyc2V0O1xuICB9LCAndXRmLTgnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBodHRwUmVzcG9uc2VIYW5kbGVyOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@videojs/xhr/lib/http-handler.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@videojs/xhr/lib/index.js":
/*!************************************************!*\
  !*** ./node_modules/@videojs/xhr/lib/index.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nvar window = __webpack_require__(/*! global/window */ \"(ssr)/./node_modules/global/window.js\");\n\nvar _extends = __webpack_require__(/*! @babel/runtime/helpers/extends */ \"(ssr)/./node_modules/@babel/runtime/helpers/extends.js\");\n\nvar isFunction = __webpack_require__(/*! is-function */ \"(ssr)/./node_modules/is-function/index.js\");\n\nvar InterceptorsStorage = __webpack_require__(/*! ./interceptors.js */ \"(ssr)/./node_modules/@videojs/xhr/lib/interceptors.js\");\n\nvar RetryManager = __webpack_require__(/*! ./retry.js */ \"(ssr)/./node_modules/@videojs/xhr/lib/retry.js\");\n\ncreateXHR.httpHandler = __webpack_require__(/*! ./http-handler.js */ \"(ssr)/./node_modules/@videojs/xhr/lib/http-handler.js\");\ncreateXHR.requestInterceptorsStorage = new InterceptorsStorage();\ncreateXHR.responseInterceptorsStorage = new InterceptorsStorage();\ncreateXHR.retryManager = new RetryManager();\n/**\n * @license\n * slighly modified parse-headers 2.0.2 <https://github.com/kesla/parse-headers/>\n * Copyright (c) 2014 David Bjrklund\n * Available under the MIT license\n * <https://github.com/kesla/parse-headers/blob/master/LICENCE>\n */\n\nvar parseHeaders = function parseHeaders(headers) {\n  var result = {};\n\n  if (!headers) {\n    return result;\n  }\n\n  headers.trim().split('\\n').forEach(function (row) {\n    var index = row.indexOf(':');\n    var key = row.slice(0, index).trim().toLowerCase();\n    var value = row.slice(index + 1).trim();\n\n    if (typeof result[key] === 'undefined') {\n      result[key] = value;\n    } else if (Array.isArray(result[key])) {\n      result[key].push(value);\n    } else {\n      result[key] = [result[key], value];\n    }\n  });\n  return result;\n};\n\nmodule.exports = createXHR; // Allow use of default import syntax in TypeScript\n\nmodule.exports[\"default\"] = createXHR;\ncreateXHR.XMLHttpRequest = window.XMLHttpRequest || noop;\ncreateXHR.XDomainRequest = \"withCredentials\" in new createXHR.XMLHttpRequest() ? createXHR.XMLHttpRequest : window.XDomainRequest;\nforEachArray([\"get\", \"put\", \"post\", \"patch\", \"head\", \"delete\"], function (method) {\n  createXHR[method === \"delete\" ? \"del\" : method] = function (uri, options, callback) {\n    options = initParams(uri, options, callback);\n    options.method = method.toUpperCase();\n    return _createXHR(options);\n  };\n});\n\nfunction forEachArray(array, iterator) {\n  for (var i = 0; i < array.length; i++) {\n    iterator(array[i]);\n  }\n}\n\nfunction isEmpty(obj) {\n  for (var i in obj) {\n    if (obj.hasOwnProperty(i)) return false;\n  }\n\n  return true;\n}\n\nfunction initParams(uri, options, callback) {\n  var params = uri;\n\n  if (isFunction(options)) {\n    callback = options;\n\n    if (typeof uri === \"string\") {\n      params = {\n        uri: uri\n      };\n    }\n  } else {\n    params = _extends({}, options, {\n      uri: uri\n    });\n  }\n\n  params.callback = callback;\n  return params;\n}\n\nfunction createXHR(uri, options, callback) {\n  options = initParams(uri, options, callback);\n  return _createXHR(options);\n}\n\nfunction _createXHR(options) {\n  if (typeof options.callback === \"undefined\") {\n    throw new Error(\"callback argument missing\");\n  } // call all registered request interceptors for a given request type:\n\n\n  if (options.requestType && createXHR.requestInterceptorsStorage.getIsEnabled()) {\n    var requestInterceptorPayload = {\n      uri: options.uri || options.url,\n      headers: options.headers || {},\n      body: options.body,\n      metadata: options.metadata || {},\n      retry: options.retry,\n      timeout: options.timeout\n    };\n    var updatedPayload = createXHR.requestInterceptorsStorage.execute(options.requestType, requestInterceptorPayload);\n    options.uri = updatedPayload.uri;\n    options.headers = updatedPayload.headers;\n    options.body = updatedPayload.body;\n    options.metadata = updatedPayload.metadata;\n    options.retry = updatedPayload.retry;\n    options.timeout = updatedPayload.timeout;\n  }\n\n  var called = false;\n\n  var callback = function cbOnce(err, response, body) {\n    if (!called) {\n      called = true;\n      options.callback(err, response, body);\n    }\n  };\n\n  function readystatechange() {\n    // do not call load 2 times when response interceptors are enabled\n    // why do we even need this 2nd load?\n    if (xhr.readyState === 4 && !createXHR.responseInterceptorsStorage.getIsEnabled()) {\n      setTimeout(loadFunc, 0);\n    }\n  }\n\n  function getBody() {\n    // Chrome with requestType=blob throws errors arround when even testing access to responseText\n    var body = undefined;\n\n    if (xhr.response) {\n      body = xhr.response;\n    } else {\n      body = xhr.responseText || getXml(xhr);\n    }\n\n    if (isJson) {\n      try {\n        body = JSON.parse(body);\n      } catch (e) {}\n    }\n\n    return body;\n  }\n\n  function errorFunc(evt) {\n    clearTimeout(timeoutTimer);\n    clearTimeout(options.retryTimeout);\n\n    if (!(evt instanceof Error)) {\n      evt = new Error(\"\" + (evt || \"Unknown XMLHttpRequest Error\"));\n    }\n\n    evt.statusCode = 0; // we would like to retry on error:\n\n    if (!aborted && createXHR.retryManager.getIsEnabled() && options.retry && options.retry.shouldRetry()) {\n      options.retryTimeout = setTimeout(function () {\n        options.retry.moveToNextAttempt(); // we want to re-use the same options and the same xhr object:\n\n        options.xhr = xhr;\n\n        _createXHR(options);\n      }, options.retry.getCurrentFuzzedDelay());\n      return;\n    } // call all registered response interceptors for a given request type:\n\n\n    if (options.requestType && createXHR.responseInterceptorsStorage.getIsEnabled()) {\n      var responseInterceptorPayload = {\n        headers: failureResponse.headers || {},\n        body: failureResponse.body,\n        responseUrl: xhr.responseURL,\n        responseType: xhr.responseType\n      };\n\n      var _updatedPayload = createXHR.responseInterceptorsStorage.execute(options.requestType, responseInterceptorPayload);\n\n      failureResponse.body = _updatedPayload.body;\n      failureResponse.headers = _updatedPayload.headers;\n    }\n\n    return callback(evt, failureResponse);\n  } // will load the data & process the response in a special response object\n\n\n  function loadFunc() {\n    if (aborted) return;\n    var status;\n    clearTimeout(timeoutTimer);\n    clearTimeout(options.retryTimeout);\n\n    if (options.useXDR && xhr.status === undefined) {\n      //IE8 CORS GET successful response doesn't have a status field, but body is fine\n      status = 200;\n    } else {\n      status = xhr.status === 1223 ? 204 : xhr.status;\n    }\n\n    var response = failureResponse;\n    var err = null;\n\n    if (status !== 0) {\n      response = {\n        body: getBody(),\n        statusCode: status,\n        method: method,\n        headers: {},\n        url: uri,\n        rawRequest: xhr\n      };\n\n      if (xhr.getAllResponseHeaders) {\n        //remember xhr can in fact be XDR for CORS in IE\n        response.headers = parseHeaders(xhr.getAllResponseHeaders());\n      }\n    } else {\n      err = new Error(\"Internal XMLHttpRequest Error\");\n    } // call all registered response interceptors for a given request type:\n\n\n    if (options.requestType && createXHR.responseInterceptorsStorage.getIsEnabled()) {\n      var responseInterceptorPayload = {\n        headers: response.headers || {},\n        body: response.body,\n        responseUrl: xhr.responseURL,\n        responseType: xhr.responseType\n      };\n\n      var _updatedPayload2 = createXHR.responseInterceptorsStorage.execute(options.requestType, responseInterceptorPayload);\n\n      response.body = _updatedPayload2.body;\n      response.headers = _updatedPayload2.headers;\n    }\n\n    return callback(err, response, response.body);\n  }\n\n  var xhr = options.xhr || null;\n\n  if (!xhr) {\n    if (options.cors || options.useXDR) {\n      xhr = new createXHR.XDomainRequest();\n    } else {\n      xhr = new createXHR.XMLHttpRequest();\n    }\n  }\n\n  var key;\n  var aborted;\n  var uri = xhr.url = options.uri || options.url;\n  var method = xhr.method = options.method || \"GET\";\n  var body = options.body || options.data;\n  var headers = xhr.headers = options.headers || {};\n  var sync = !!options.sync;\n  var isJson = false;\n  var timeoutTimer;\n  var failureResponse = {\n    body: undefined,\n    headers: {},\n    statusCode: 0,\n    method: method,\n    url: uri,\n    rawRequest: xhr\n  };\n\n  if (\"json\" in options && options.json !== false) {\n    isJson = true;\n    headers[\"accept\"] || headers[\"Accept\"] || (headers[\"Accept\"] = \"application/json\"); //Don't override existing accept header declared by user\n\n    if (method !== \"GET\" && method !== \"HEAD\") {\n      headers[\"content-type\"] || headers[\"Content-Type\"] || (headers[\"Content-Type\"] = \"application/json\"); //Don't override existing accept header declared by user\n\n      body = JSON.stringify(options.json === true ? body : options.json);\n    }\n  }\n\n  xhr.onreadystatechange = readystatechange;\n  xhr.onload = loadFunc;\n  xhr.onerror = errorFunc; // IE9 must have onprogress be set to a unique function.\n\n  xhr.onprogress = function () {// IE must die\n  };\n\n  xhr.onabort = function () {\n    aborted = true;\n    clearTimeout(options.retryTimeout);\n  };\n\n  xhr.ontimeout = errorFunc;\n  xhr.open(method, uri, !sync, options.username, options.password); //has to be after open\n\n  if (!sync) {\n    xhr.withCredentials = !!options.withCredentials;\n  } // Cannot set timeout with sync request\n  // not setting timeout on the xhr object, because of old webkits etc. not handling that correctly\n  // both npm's request and jquery 1.x use this kind of timeout, so this is being consistent\n\n\n  if (!sync && options.timeout > 0) {\n    timeoutTimer = setTimeout(function () {\n      if (aborted) return;\n      aborted = true; //IE9 may still call readystatechange\n\n      xhr.abort(\"timeout\");\n      var e = new Error(\"XMLHttpRequest timeout\");\n      e.code = \"ETIMEDOUT\";\n      errorFunc(e);\n    }, options.timeout);\n  }\n\n  if (xhr.setRequestHeader) {\n    for (key in headers) {\n      if (headers.hasOwnProperty(key)) {\n        xhr.setRequestHeader(key, headers[key]);\n      }\n    }\n  } else if (options.headers && !isEmpty(options.headers)) {\n    throw new Error(\"Headers cannot be set on an XDomainRequest object\");\n  }\n\n  if (\"responseType\" in options) {\n    xhr.responseType = options.responseType;\n  }\n\n  if (\"beforeSend\" in options && typeof options.beforeSend === \"function\") {\n    options.beforeSend(xhr);\n  } // Microsoft Edge browser sends \"undefined\" when send is called with undefined value.\n  // XMLHttpRequest spec says to pass null as body to indicate no body\n  // See https://github.com/naugtur/xhr/issues/100.\n\n\n  xhr.send(body || null);\n  return xhr;\n}\n\nfunction getXml(xhr) {\n  // xhr.responseXML will throw Exception \"InvalidStateError\" or \"DOMException\"\n  // See https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/responseXML.\n  try {\n    if (xhr.responseType === \"document\") {\n      return xhr.responseXML;\n    }\n\n    var firefoxBugTakenEffect = xhr.responseXML && xhr.responseXML.documentElement.nodeName === \"parsererror\";\n\n    if (xhr.responseType === \"\" && !firefoxBugTakenEffect) {\n      return xhr.responseXML;\n    }\n  } catch (e) {}\n\n  return null;\n}\n\nfunction noop() {}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHZpZGVvanMveGhyL2xpYi9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixhQUFhLG1CQUFPLENBQUMsNERBQWU7O0FBRXBDLGVBQWUsbUJBQU8sQ0FBQyw4RkFBZ0M7O0FBRXZELGlCQUFpQixtQkFBTyxDQUFDLDhEQUFhOztBQUV0QywwQkFBMEIsbUJBQU8sQ0FBQyxnRkFBbUI7O0FBRXJELG1CQUFtQixtQkFBTyxDQUFDLGtFQUFZOztBQUV2Qyx3QkFBd0IsbUJBQU8sQ0FBQyxnRkFBbUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUEsNEJBQTRCOztBQUU1Qix5QkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLHdCQUF3QjtBQUN4QjtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0I7O0FBRXhCO0FBQ0E7QUFDQSwyQ0FBMkM7O0FBRTNDOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsTUFBTTs7O0FBR047QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3RkFBd0Y7O0FBRXhGO0FBQ0EsNEdBQTRHOztBQUU1RztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJCQUEyQjs7QUFFM0IsZ0NBQWdDO0FBQ2hDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0VBQW9FOztBQUVwRTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjs7QUFFdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL215LXYwLXByb2plY3QvLi9ub2RlX21vZHVsZXMvQHZpZGVvanMveGhyL2xpYi9pbmRleC5qcz82YjYwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG52YXIgd2luZG93ID0gcmVxdWlyZShcImdsb2JhbC93aW5kb3dcIik7XG5cbnZhciBfZXh0ZW5kcyA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2V4dGVuZHNcIik7XG5cbnZhciBpc0Z1bmN0aW9uID0gcmVxdWlyZSgnaXMtZnVuY3Rpb24nKTtcblxudmFyIEludGVyY2VwdG9yc1N0b3JhZ2UgPSByZXF1aXJlKCcuL2ludGVyY2VwdG9ycy5qcycpO1xuXG52YXIgUmV0cnlNYW5hZ2VyID0gcmVxdWlyZShcIi4vcmV0cnkuanNcIik7XG5cbmNyZWF0ZVhIUi5odHRwSGFuZGxlciA9IHJlcXVpcmUoJy4vaHR0cC1oYW5kbGVyLmpzJyk7XG5jcmVhdGVYSFIucmVxdWVzdEludGVyY2VwdG9yc1N0b3JhZ2UgPSBuZXcgSW50ZXJjZXB0b3JzU3RvcmFnZSgpO1xuY3JlYXRlWEhSLnJlc3BvbnNlSW50ZXJjZXB0b3JzU3RvcmFnZSA9IG5ldyBJbnRlcmNlcHRvcnNTdG9yYWdlKCk7XG5jcmVhdGVYSFIucmV0cnlNYW5hZ2VyID0gbmV3IFJldHJ5TWFuYWdlcigpO1xuLyoqXG4gKiBAbGljZW5zZVxuICogc2xpZ2hseSBtb2RpZmllZCBwYXJzZS1oZWFkZXJzIDIuMC4yIDxodHRwczovL2dpdGh1Yi5jb20va2VzbGEvcGFyc2UtaGVhZGVycy8+XG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQgRGF2aWQgQmrDtnJrbHVuZFxuICogQXZhaWxhYmxlIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICogPGh0dHBzOi8vZ2l0aHViLmNvbS9rZXNsYS9wYXJzZS1oZWFkZXJzL2Jsb2IvbWFzdGVyL0xJQ0VOQ0U+XG4gKi9cblxudmFyIHBhcnNlSGVhZGVycyA9IGZ1bmN0aW9uIHBhcnNlSGVhZGVycyhoZWFkZXJzKSB7XG4gIHZhciByZXN1bHQgPSB7fTtcblxuICBpZiAoIWhlYWRlcnMpIHtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgaGVhZGVycy50cmltKCkuc3BsaXQoJ1xcbicpLmZvckVhY2goZnVuY3Rpb24gKHJvdykge1xuICAgIHZhciBpbmRleCA9IHJvdy5pbmRleE9mKCc6Jyk7XG4gICAgdmFyIGtleSA9IHJvdy5zbGljZSgwLCBpbmRleCkudHJpbSgpLnRvTG93ZXJDYXNlKCk7XG4gICAgdmFyIHZhbHVlID0gcm93LnNsaWNlKGluZGV4ICsgMSkudHJpbSgpO1xuXG4gICAgaWYgKHR5cGVvZiByZXN1bHRba2V5XSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJlc3VsdFtrZXldID0gdmFsdWU7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHJlc3VsdFtrZXldKSkge1xuICAgICAgcmVzdWx0W2tleV0ucHVzaCh2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdFtrZXldID0gW3Jlc3VsdFtrZXldLCB2YWx1ZV07XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlWEhSOyAvLyBBbGxvdyB1c2Ugb2YgZGVmYXVsdCBpbXBvcnQgc3ludGF4IGluIFR5cGVTY3JpcHRcblxubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IGNyZWF0ZVhIUjtcbmNyZWF0ZVhIUi5YTUxIdHRwUmVxdWVzdCA9IHdpbmRvdy5YTUxIdHRwUmVxdWVzdCB8fCBub29wO1xuY3JlYXRlWEhSLlhEb21haW5SZXF1ZXN0ID0gXCJ3aXRoQ3JlZGVudGlhbHNcIiBpbiBuZXcgY3JlYXRlWEhSLlhNTEh0dHBSZXF1ZXN0KCkgPyBjcmVhdGVYSFIuWE1MSHR0cFJlcXVlc3QgOiB3aW5kb3cuWERvbWFpblJlcXVlc3Q7XG5mb3JFYWNoQXJyYXkoW1wiZ2V0XCIsIFwicHV0XCIsIFwicG9zdFwiLCBcInBhdGNoXCIsIFwiaGVhZFwiLCBcImRlbGV0ZVwiXSwgZnVuY3Rpb24gKG1ldGhvZCkge1xuICBjcmVhdGVYSFJbbWV0aG9kID09PSBcImRlbGV0ZVwiID8gXCJkZWxcIiA6IG1ldGhvZF0gPSBmdW5jdGlvbiAodXJpLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICAgIG9wdGlvbnMgPSBpbml0UGFyYW1zKHVyaSwgb3B0aW9ucywgY2FsbGJhY2spO1xuICAgIG9wdGlvbnMubWV0aG9kID0gbWV0aG9kLnRvVXBwZXJDYXNlKCk7XG4gICAgcmV0dXJuIF9jcmVhdGVYSFIob3B0aW9ucyk7XG4gIH07XG59KTtcblxuZnVuY3Rpb24gZm9yRWFjaEFycmF5KGFycmF5LCBpdGVyYXRvcikge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgaXRlcmF0b3IoYXJyYXlbaV0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzRW1wdHkob2JqKSB7XG4gIGZvciAodmFyIGkgaW4gb2JqKSB7XG4gICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShpKSkgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGluaXRQYXJhbXModXJpLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICB2YXIgcGFyYW1zID0gdXJpO1xuXG4gIGlmIChpc0Z1bmN0aW9uKG9wdGlvbnMpKSB7XG4gICAgY2FsbGJhY2sgPSBvcHRpb25zO1xuXG4gICAgaWYgKHR5cGVvZiB1cmkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHBhcmFtcyA9IHtcbiAgICAgICAgdXJpOiB1cmlcbiAgICAgIH07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHBhcmFtcyA9IF9leHRlbmRzKHt9LCBvcHRpb25zLCB7XG4gICAgICB1cmk6IHVyaVxuICAgIH0pO1xuICB9XG5cbiAgcGFyYW1zLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gIHJldHVybiBwYXJhbXM7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVhIUih1cmksIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIG9wdGlvbnMgPSBpbml0UGFyYW1zKHVyaSwgb3B0aW9ucywgY2FsbGJhY2spO1xuICByZXR1cm4gX2NyZWF0ZVhIUihvcHRpb25zKTtcbn1cblxuZnVuY3Rpb24gX2NyZWF0ZVhIUihvcHRpb25zKSB7XG4gIGlmICh0eXBlb2Ygb3B0aW9ucy5jYWxsYmFjayA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHRocm93IG5ldyBFcnJvcihcImNhbGxiYWNrIGFyZ3VtZW50IG1pc3NpbmdcIik7XG4gIH0gLy8gY2FsbCBhbGwgcmVnaXN0ZXJlZCByZXF1ZXN0IGludGVyY2VwdG9ycyBmb3IgYSBnaXZlbiByZXF1ZXN0IHR5cGU6XG5cblxuICBpZiAob3B0aW9ucy5yZXF1ZXN0VHlwZSAmJiBjcmVhdGVYSFIucmVxdWVzdEludGVyY2VwdG9yc1N0b3JhZ2UuZ2V0SXNFbmFibGVkKCkpIHtcbiAgICB2YXIgcmVxdWVzdEludGVyY2VwdG9yUGF5bG9hZCA9IHtcbiAgICAgIHVyaTogb3B0aW9ucy51cmkgfHwgb3B0aW9ucy51cmwsXG4gICAgICBoZWFkZXJzOiBvcHRpb25zLmhlYWRlcnMgfHwge30sXG4gICAgICBib2R5OiBvcHRpb25zLmJvZHksXG4gICAgICBtZXRhZGF0YTogb3B0aW9ucy5tZXRhZGF0YSB8fCB7fSxcbiAgICAgIHJldHJ5OiBvcHRpb25zLnJldHJ5LFxuICAgICAgdGltZW91dDogb3B0aW9ucy50aW1lb3V0XG4gICAgfTtcbiAgICB2YXIgdXBkYXRlZFBheWxvYWQgPSBjcmVhdGVYSFIucmVxdWVzdEludGVyY2VwdG9yc1N0b3JhZ2UuZXhlY3V0ZShvcHRpb25zLnJlcXVlc3RUeXBlLCByZXF1ZXN0SW50ZXJjZXB0b3JQYXlsb2FkKTtcbiAgICBvcHRpb25zLnVyaSA9IHVwZGF0ZWRQYXlsb2FkLnVyaTtcbiAgICBvcHRpb25zLmhlYWRlcnMgPSB1cGRhdGVkUGF5bG9hZC5oZWFkZXJzO1xuICAgIG9wdGlvbnMuYm9keSA9IHVwZGF0ZWRQYXlsb2FkLmJvZHk7XG4gICAgb3B0aW9ucy5tZXRhZGF0YSA9IHVwZGF0ZWRQYXlsb2FkLm1ldGFkYXRhO1xuICAgIG9wdGlvbnMucmV0cnkgPSB1cGRhdGVkUGF5bG9hZC5yZXRyeTtcbiAgICBvcHRpb25zLnRpbWVvdXQgPSB1cGRhdGVkUGF5bG9hZC50aW1lb3V0O1xuICB9XG5cbiAgdmFyIGNhbGxlZCA9IGZhbHNlO1xuXG4gIHZhciBjYWxsYmFjayA9IGZ1bmN0aW9uIGNiT25jZShlcnIsIHJlc3BvbnNlLCBib2R5KSB7XG4gICAgaWYgKCFjYWxsZWQpIHtcbiAgICAgIGNhbGxlZCA9IHRydWU7XG4gICAgICBvcHRpb25zLmNhbGxiYWNrKGVyciwgcmVzcG9uc2UsIGJvZHkpO1xuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiByZWFkeXN0YXRlY2hhbmdlKCkge1xuICAgIC8vIGRvIG5vdCBjYWxsIGxvYWQgMiB0aW1lcyB3aGVuIHJlc3BvbnNlIGludGVyY2VwdG9ycyBhcmUgZW5hYmxlZFxuICAgIC8vIHdoeSBkbyB3ZSBldmVuIG5lZWQgdGhpcyAybmQgbG9hZD9cbiAgICBpZiAoeGhyLnJlYWR5U3RhdGUgPT09IDQgJiYgIWNyZWF0ZVhIUi5yZXNwb25zZUludGVyY2VwdG9yc1N0b3JhZ2UuZ2V0SXNFbmFibGVkKCkpIHtcbiAgICAgIHNldFRpbWVvdXQobG9hZEZ1bmMsIDApO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEJvZHkoKSB7XG4gICAgLy8gQ2hyb21lIHdpdGggcmVxdWVzdFR5cGU9YmxvYiB0aHJvd3MgZXJyb3JzIGFycm91bmQgd2hlbiBldmVuIHRlc3RpbmcgYWNjZXNzIHRvIHJlc3BvbnNlVGV4dFxuICAgIHZhciBib2R5ID0gdW5kZWZpbmVkO1xuXG4gICAgaWYgKHhoci5yZXNwb25zZSkge1xuICAgICAgYm9keSA9IHhoci5yZXNwb25zZTtcbiAgICB9IGVsc2Uge1xuICAgICAgYm9keSA9IHhoci5yZXNwb25zZVRleHQgfHwgZ2V0WG1sKHhocik7XG4gICAgfVxuXG4gICAgaWYgKGlzSnNvbikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgYm9keSA9IEpTT04ucGFyc2UoYm9keSk7XG4gICAgICB9IGNhdGNoIChlKSB7fVxuICAgIH1cblxuICAgIHJldHVybiBib2R5O1xuICB9XG5cbiAgZnVuY3Rpb24gZXJyb3JGdW5jKGV2dCkge1xuICAgIGNsZWFyVGltZW91dCh0aW1lb3V0VGltZXIpO1xuICAgIGNsZWFyVGltZW91dChvcHRpb25zLnJldHJ5VGltZW91dCk7XG5cbiAgICBpZiAoIShldnQgaW5zdGFuY2VvZiBFcnJvcikpIHtcbiAgICAgIGV2dCA9IG5ldyBFcnJvcihcIlwiICsgKGV2dCB8fCBcIlVua25vd24gWE1MSHR0cFJlcXVlc3QgRXJyb3JcIikpO1xuICAgIH1cblxuICAgIGV2dC5zdGF0dXNDb2RlID0gMDsgLy8gd2Ugd291bGQgbGlrZSB0byByZXRyeSBvbiBlcnJvcjpcblxuICAgIGlmICghYWJvcnRlZCAmJiBjcmVhdGVYSFIucmV0cnlNYW5hZ2VyLmdldElzRW5hYmxlZCgpICYmIG9wdGlvbnMucmV0cnkgJiYgb3B0aW9ucy5yZXRyeS5zaG91bGRSZXRyeSgpKSB7XG4gICAgICBvcHRpb25zLnJldHJ5VGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBvcHRpb25zLnJldHJ5Lm1vdmVUb05leHRBdHRlbXB0KCk7IC8vIHdlIHdhbnQgdG8gcmUtdXNlIHRoZSBzYW1lIG9wdGlvbnMgYW5kIHRoZSBzYW1lIHhociBvYmplY3Q6XG5cbiAgICAgICAgb3B0aW9ucy54aHIgPSB4aHI7XG5cbiAgICAgICAgX2NyZWF0ZVhIUihvcHRpb25zKTtcbiAgICAgIH0sIG9wdGlvbnMucmV0cnkuZ2V0Q3VycmVudEZ1enplZERlbGF5KCkpO1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gY2FsbCBhbGwgcmVnaXN0ZXJlZCByZXNwb25zZSBpbnRlcmNlcHRvcnMgZm9yIGEgZ2l2ZW4gcmVxdWVzdCB0eXBlOlxuXG5cbiAgICBpZiAob3B0aW9ucy5yZXF1ZXN0VHlwZSAmJiBjcmVhdGVYSFIucmVzcG9uc2VJbnRlcmNlcHRvcnNTdG9yYWdlLmdldElzRW5hYmxlZCgpKSB7XG4gICAgICB2YXIgcmVzcG9uc2VJbnRlcmNlcHRvclBheWxvYWQgPSB7XG4gICAgICAgIGhlYWRlcnM6IGZhaWx1cmVSZXNwb25zZS5oZWFkZXJzIHx8IHt9LFxuICAgICAgICBib2R5OiBmYWlsdXJlUmVzcG9uc2UuYm9keSxcbiAgICAgICAgcmVzcG9uc2VVcmw6IHhoci5yZXNwb25zZVVSTCxcbiAgICAgICAgcmVzcG9uc2VUeXBlOiB4aHIucmVzcG9uc2VUeXBlXG4gICAgICB9O1xuXG4gICAgICB2YXIgX3VwZGF0ZWRQYXlsb2FkID0gY3JlYXRlWEhSLnJlc3BvbnNlSW50ZXJjZXB0b3JzU3RvcmFnZS5leGVjdXRlKG9wdGlvbnMucmVxdWVzdFR5cGUsIHJlc3BvbnNlSW50ZXJjZXB0b3JQYXlsb2FkKTtcblxuICAgICAgZmFpbHVyZVJlc3BvbnNlLmJvZHkgPSBfdXBkYXRlZFBheWxvYWQuYm9keTtcbiAgICAgIGZhaWx1cmVSZXNwb25zZS5oZWFkZXJzID0gX3VwZGF0ZWRQYXlsb2FkLmhlYWRlcnM7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNhbGxiYWNrKGV2dCwgZmFpbHVyZVJlc3BvbnNlKTtcbiAgfSAvLyB3aWxsIGxvYWQgdGhlIGRhdGEgJiBwcm9jZXNzIHRoZSByZXNwb25zZSBpbiBhIHNwZWNpYWwgcmVzcG9uc2Ugb2JqZWN0XG5cblxuICBmdW5jdGlvbiBsb2FkRnVuYygpIHtcbiAgICBpZiAoYWJvcnRlZCkgcmV0dXJuO1xuICAgIHZhciBzdGF0dXM7XG4gICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRUaW1lcik7XG4gICAgY2xlYXJUaW1lb3V0KG9wdGlvbnMucmV0cnlUaW1lb3V0KTtcblxuICAgIGlmIChvcHRpb25zLnVzZVhEUiAmJiB4aHIuc3RhdHVzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vSUU4IENPUlMgR0VUIHN1Y2Nlc3NmdWwgcmVzcG9uc2UgZG9lc24ndCBoYXZlIGEgc3RhdHVzIGZpZWxkLCBidXQgYm9keSBpcyBmaW5lXG4gICAgICBzdGF0dXMgPSAyMDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXR1cyA9IHhoci5zdGF0dXMgPT09IDEyMjMgPyAyMDQgOiB4aHIuc3RhdHVzO1xuICAgIH1cblxuICAgIHZhciByZXNwb25zZSA9IGZhaWx1cmVSZXNwb25zZTtcbiAgICB2YXIgZXJyID0gbnVsbDtcblxuICAgIGlmIChzdGF0dXMgIT09IDApIHtcbiAgICAgIHJlc3BvbnNlID0ge1xuICAgICAgICBib2R5OiBnZXRCb2R5KCksXG4gICAgICAgIHN0YXR1c0NvZGU6IHN0YXR1cyxcbiAgICAgICAgbWV0aG9kOiBtZXRob2QsXG4gICAgICAgIGhlYWRlcnM6IHt9LFxuICAgICAgICB1cmw6IHVyaSxcbiAgICAgICAgcmF3UmVxdWVzdDogeGhyXG4gICAgICB9O1xuXG4gICAgICBpZiAoeGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycykge1xuICAgICAgICAvL3JlbWVtYmVyIHhociBjYW4gaW4gZmFjdCBiZSBYRFIgZm9yIENPUlMgaW4gSUVcbiAgICAgICAgcmVzcG9uc2UuaGVhZGVycyA9IHBhcnNlSGVhZGVycyh4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBlcnIgPSBuZXcgRXJyb3IoXCJJbnRlcm5hbCBYTUxIdHRwUmVxdWVzdCBFcnJvclwiKTtcbiAgICB9IC8vIGNhbGwgYWxsIHJlZ2lzdGVyZWQgcmVzcG9uc2UgaW50ZXJjZXB0b3JzIGZvciBhIGdpdmVuIHJlcXVlc3QgdHlwZTpcblxuXG4gICAgaWYgKG9wdGlvbnMucmVxdWVzdFR5cGUgJiYgY3JlYXRlWEhSLnJlc3BvbnNlSW50ZXJjZXB0b3JzU3RvcmFnZS5nZXRJc0VuYWJsZWQoKSkge1xuICAgICAgdmFyIHJlc3BvbnNlSW50ZXJjZXB0b3JQYXlsb2FkID0ge1xuICAgICAgICBoZWFkZXJzOiByZXNwb25zZS5oZWFkZXJzIHx8IHt9LFxuICAgICAgICBib2R5OiByZXNwb25zZS5ib2R5LFxuICAgICAgICByZXNwb25zZVVybDogeGhyLnJlc3BvbnNlVVJMLFxuICAgICAgICByZXNwb25zZVR5cGU6IHhoci5yZXNwb25zZVR5cGVcbiAgICAgIH07XG5cbiAgICAgIHZhciBfdXBkYXRlZFBheWxvYWQyID0gY3JlYXRlWEhSLnJlc3BvbnNlSW50ZXJjZXB0b3JzU3RvcmFnZS5leGVjdXRlKG9wdGlvbnMucmVxdWVzdFR5cGUsIHJlc3BvbnNlSW50ZXJjZXB0b3JQYXlsb2FkKTtcblxuICAgICAgcmVzcG9uc2UuYm9keSA9IF91cGRhdGVkUGF5bG9hZDIuYm9keTtcbiAgICAgIHJlc3BvbnNlLmhlYWRlcnMgPSBfdXBkYXRlZFBheWxvYWQyLmhlYWRlcnM7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNhbGxiYWNrKGVyciwgcmVzcG9uc2UsIHJlc3BvbnNlLmJvZHkpO1xuICB9XG5cbiAgdmFyIHhociA9IG9wdGlvbnMueGhyIHx8IG51bGw7XG5cbiAgaWYgKCF4aHIpIHtcbiAgICBpZiAob3B0aW9ucy5jb3JzIHx8IG9wdGlvbnMudXNlWERSKSB7XG4gICAgICB4aHIgPSBuZXcgY3JlYXRlWEhSLlhEb21haW5SZXF1ZXN0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHhociA9IG5ldyBjcmVhdGVYSFIuWE1MSHR0cFJlcXVlc3QoKTtcbiAgICB9XG4gIH1cblxuICB2YXIga2V5O1xuICB2YXIgYWJvcnRlZDtcbiAgdmFyIHVyaSA9IHhoci51cmwgPSBvcHRpb25zLnVyaSB8fCBvcHRpb25zLnVybDtcbiAgdmFyIG1ldGhvZCA9IHhoci5tZXRob2QgPSBvcHRpb25zLm1ldGhvZCB8fCBcIkdFVFwiO1xuICB2YXIgYm9keSA9IG9wdGlvbnMuYm9keSB8fCBvcHRpb25zLmRhdGE7XG4gIHZhciBoZWFkZXJzID0geGhyLmhlYWRlcnMgPSBvcHRpb25zLmhlYWRlcnMgfHwge307XG4gIHZhciBzeW5jID0gISFvcHRpb25zLnN5bmM7XG4gIHZhciBpc0pzb24gPSBmYWxzZTtcbiAgdmFyIHRpbWVvdXRUaW1lcjtcbiAgdmFyIGZhaWx1cmVSZXNwb25zZSA9IHtcbiAgICBib2R5OiB1bmRlZmluZWQsXG4gICAgaGVhZGVyczoge30sXG4gICAgc3RhdHVzQ29kZTogMCxcbiAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICB1cmw6IHVyaSxcbiAgICByYXdSZXF1ZXN0OiB4aHJcbiAgfTtcblxuICBpZiAoXCJqc29uXCIgaW4gb3B0aW9ucyAmJiBvcHRpb25zLmpzb24gIT09IGZhbHNlKSB7XG4gICAgaXNKc29uID0gdHJ1ZTtcbiAgICBoZWFkZXJzW1wiYWNjZXB0XCJdIHx8IGhlYWRlcnNbXCJBY2NlcHRcIl0gfHwgKGhlYWRlcnNbXCJBY2NlcHRcIl0gPSBcImFwcGxpY2F0aW9uL2pzb25cIik7IC8vRG9uJ3Qgb3ZlcnJpZGUgZXhpc3RpbmcgYWNjZXB0IGhlYWRlciBkZWNsYXJlZCBieSB1c2VyXG5cbiAgICBpZiAobWV0aG9kICE9PSBcIkdFVFwiICYmIG1ldGhvZCAhPT0gXCJIRUFEXCIpIHtcbiAgICAgIGhlYWRlcnNbXCJjb250ZW50LXR5cGVcIl0gfHwgaGVhZGVyc1tcIkNvbnRlbnQtVHlwZVwiXSB8fCAoaGVhZGVyc1tcIkNvbnRlbnQtVHlwZVwiXSA9IFwiYXBwbGljYXRpb24vanNvblwiKTsgLy9Eb24ndCBvdmVycmlkZSBleGlzdGluZyBhY2NlcHQgaGVhZGVyIGRlY2xhcmVkIGJ5IHVzZXJcblxuICAgICAgYm9keSA9IEpTT04uc3RyaW5naWZ5KG9wdGlvbnMuanNvbiA9PT0gdHJ1ZSA/IGJvZHkgOiBvcHRpb25zLmpzb24pO1xuICAgIH1cbiAgfVxuXG4gIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSByZWFkeXN0YXRlY2hhbmdlO1xuICB4aHIub25sb2FkID0gbG9hZEZ1bmM7XG4gIHhoci5vbmVycm9yID0gZXJyb3JGdW5jOyAvLyBJRTkgbXVzdCBoYXZlIG9ucHJvZ3Jlc3MgYmUgc2V0IHRvIGEgdW5pcXVlIGZ1bmN0aW9uLlxuXG4gIHhoci5vbnByb2dyZXNzID0gZnVuY3Rpb24gKCkgey8vIElFIG11c3QgZGllXG4gIH07XG5cbiAgeGhyLm9uYWJvcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgYWJvcnRlZCA9IHRydWU7XG4gICAgY2xlYXJUaW1lb3V0KG9wdGlvbnMucmV0cnlUaW1lb3V0KTtcbiAgfTtcblxuICB4aHIub250aW1lb3V0ID0gZXJyb3JGdW5jO1xuICB4aHIub3BlbihtZXRob2QsIHVyaSwgIXN5bmMsIG9wdGlvbnMudXNlcm5hbWUsIG9wdGlvbnMucGFzc3dvcmQpOyAvL2hhcyB0byBiZSBhZnRlciBvcGVuXG5cbiAgaWYgKCFzeW5jKSB7XG4gICAgeGhyLndpdGhDcmVkZW50aWFscyA9ICEhb3B0aW9ucy53aXRoQ3JlZGVudGlhbHM7XG4gIH0gLy8gQ2Fubm90IHNldCB0aW1lb3V0IHdpdGggc3luYyByZXF1ZXN0XG4gIC8vIG5vdCBzZXR0aW5nIHRpbWVvdXQgb24gdGhlIHhociBvYmplY3QsIGJlY2F1c2Ugb2Ygb2xkIHdlYmtpdHMgZXRjLiBub3QgaGFuZGxpbmcgdGhhdCBjb3JyZWN0bHlcbiAgLy8gYm90aCBucG0ncyByZXF1ZXN0IGFuZCBqcXVlcnkgMS54IHVzZSB0aGlzIGtpbmQgb2YgdGltZW91dCwgc28gdGhpcyBpcyBiZWluZyBjb25zaXN0ZW50XG5cblxuICBpZiAoIXN5bmMgJiYgb3B0aW9ucy50aW1lb3V0ID4gMCkge1xuICAgIHRpbWVvdXRUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGFib3J0ZWQpIHJldHVybjtcbiAgICAgIGFib3J0ZWQgPSB0cnVlOyAvL0lFOSBtYXkgc3RpbGwgY2FsbCByZWFkeXN0YXRlY2hhbmdlXG5cbiAgICAgIHhoci5hYm9ydChcInRpbWVvdXRcIik7XG4gICAgICB2YXIgZSA9IG5ldyBFcnJvcihcIlhNTEh0dHBSZXF1ZXN0IHRpbWVvdXRcIik7XG4gICAgICBlLmNvZGUgPSBcIkVUSU1FRE9VVFwiO1xuICAgICAgZXJyb3JGdW5jKGUpO1xuICAgIH0sIG9wdGlvbnMudGltZW91dCk7XG4gIH1cblxuICBpZiAoeGhyLnNldFJlcXVlc3RIZWFkZXIpIHtcbiAgICBmb3IgKGtleSBpbiBoZWFkZXJzKSB7XG4gICAgICBpZiAoaGVhZGVycy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKGtleSwgaGVhZGVyc1trZXldKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAob3B0aW9ucy5oZWFkZXJzICYmICFpc0VtcHR5KG9wdGlvbnMuaGVhZGVycykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJIZWFkZXJzIGNhbm5vdCBiZSBzZXQgb24gYW4gWERvbWFpblJlcXVlc3Qgb2JqZWN0XCIpO1xuICB9XG5cbiAgaWYgKFwicmVzcG9uc2VUeXBlXCIgaW4gb3B0aW9ucykge1xuICAgIHhoci5yZXNwb25zZVR5cGUgPSBvcHRpb25zLnJlc3BvbnNlVHlwZTtcbiAgfVxuXG4gIGlmIChcImJlZm9yZVNlbmRcIiBpbiBvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zLmJlZm9yZVNlbmQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIG9wdGlvbnMuYmVmb3JlU2VuZCh4aHIpO1xuICB9IC8vIE1pY3Jvc29mdCBFZGdlIGJyb3dzZXIgc2VuZHMgXCJ1bmRlZmluZWRcIiB3aGVuIHNlbmQgaXMgY2FsbGVkIHdpdGggdW5kZWZpbmVkIHZhbHVlLlxuICAvLyBYTUxIdHRwUmVxdWVzdCBzcGVjIHNheXMgdG8gcGFzcyBudWxsIGFzIGJvZHkgdG8gaW5kaWNhdGUgbm8gYm9keVxuICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL25hdWd0dXIveGhyL2lzc3Vlcy8xMDAuXG5cblxuICB4aHIuc2VuZChib2R5IHx8IG51bGwpO1xuICByZXR1cm4geGhyO1xufVxuXG5mdW5jdGlvbiBnZXRYbWwoeGhyKSB7XG4gIC8vIHhoci5yZXNwb25zZVhNTCB3aWxsIHRocm93IEV4Y2VwdGlvbiBcIkludmFsaWRTdGF0ZUVycm9yXCIgb3IgXCJET01FeGNlcHRpb25cIlxuICAvLyBTZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1hNTEh0dHBSZXF1ZXN0L3Jlc3BvbnNlWE1MLlxuICB0cnkge1xuICAgIGlmICh4aHIucmVzcG9uc2VUeXBlID09PSBcImRvY3VtZW50XCIpIHtcbiAgICAgIHJldHVybiB4aHIucmVzcG9uc2VYTUw7XG4gICAgfVxuXG4gICAgdmFyIGZpcmVmb3hCdWdUYWtlbkVmZmVjdCA9IHhoci5yZXNwb25zZVhNTCAmJiB4aHIucmVzcG9uc2VYTUwuZG9jdW1lbnRFbGVtZW50Lm5vZGVOYW1lID09PSBcInBhcnNlcmVycm9yXCI7XG5cbiAgICBpZiAoeGhyLnJlc3BvbnNlVHlwZSA9PT0gXCJcIiAmJiAhZmlyZWZveEJ1Z1Rha2VuRWZmZWN0KSB7XG4gICAgICByZXR1cm4geGhyLnJlc3BvbnNlWE1MO1xuICAgIH1cbiAgfSBjYXRjaCAoZSkge31cblxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gbm9vcCgpIHt9Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@videojs/xhr/lib/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@videojs/xhr/lib/interceptors.js":
/*!*******************************************************!*\
  !*** ./node_modules/@videojs/xhr/lib/interceptors.js ***!
  \*******************************************************/
/***/ ((module) => {

eval("\n\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nvar InterceptorsStorage = /*#__PURE__*/function () {\n  function InterceptorsStorage() {\n    this.typeToInterceptorsMap_ = new Map();\n    this.enabled_ = false;\n  }\n\n  var _proto = InterceptorsStorage.prototype;\n\n  _proto.getIsEnabled = function getIsEnabled() {\n    return this.enabled_;\n  };\n\n  _proto.enable = function enable() {\n    this.enabled_ = true;\n  };\n\n  _proto.disable = function disable() {\n    this.enabled_ = false;\n  };\n\n  _proto.reset = function reset() {\n    this.typeToInterceptorsMap_ = new Map();\n    this.enabled_ = false;\n  };\n\n  _proto.addInterceptor = function addInterceptor(type, interceptor) {\n    if (!this.typeToInterceptorsMap_.has(type)) {\n      this.typeToInterceptorsMap_.set(type, new Set());\n    }\n\n    var interceptorsSet = this.typeToInterceptorsMap_.get(type);\n\n    if (interceptorsSet.has(interceptor)) {\n      // already have this interceptor\n      return false;\n    }\n\n    interceptorsSet.add(interceptor);\n    return true;\n  };\n\n  _proto.removeInterceptor = function removeInterceptor(type, interceptor) {\n    var interceptorsSet = this.typeToInterceptorsMap_.get(type);\n\n    if (interceptorsSet && interceptorsSet.has(interceptor)) {\n      interceptorsSet.delete(interceptor);\n      return true;\n    }\n\n    return false;\n  };\n\n  _proto.clearInterceptorsByType = function clearInterceptorsByType(type) {\n    var interceptorsSet = this.typeToInterceptorsMap_.get(type);\n\n    if (!interceptorsSet) {\n      return false;\n    }\n\n    this.typeToInterceptorsMap_.delete(type);\n    this.typeToInterceptorsMap_.set(type, new Set());\n    return true;\n  };\n\n  _proto.clear = function clear() {\n    if (!this.typeToInterceptorsMap_.size) {\n      return false;\n    }\n\n    this.typeToInterceptorsMap_ = new Map();\n    return true;\n  };\n\n  _proto.getForType = function getForType(type) {\n    return this.typeToInterceptorsMap_.get(type) || new Set();\n  };\n\n  _proto.execute = function execute(type, payload) {\n    var interceptors = this.getForType(type);\n\n    for (var _iterator = _createForOfIteratorHelperLoose(interceptors), _step; !(_step = _iterator()).done;) {\n      var interceptor = _step.value;\n\n      try {\n        payload = interceptor(payload);\n      } catch (e) {//ignore\n      }\n    }\n\n    return payload;\n  };\n\n  return InterceptorsStorage;\n}();\n\nmodule.exports = InterceptorsStorage;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHZpZGVvanMveGhyL2xpYi9pbnRlcmNlcHRvcnMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOERBQThELGlGQUFpRixnREFBZ0Qsd0hBQXdILGdCQUFnQixXQUFXLHFCQUFxQiw0QkFBNEIsY0FBYyxTQUFTLG1DQUFtQzs7QUFFN2Isa0RBQWtELGdCQUFnQixnRUFBZ0Usd0RBQXdELDZEQUE2RCxzREFBc0Q7O0FBRTdTLHVDQUF1Qyx1REFBdUQsdUNBQXVDLFNBQVMsT0FBTyxvQkFBb0I7O0FBRXpLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsK0VBQStFLDRCQUE0QjtBQUMzRzs7QUFFQTtBQUNBO0FBQ0EsUUFBUSxXQUFXO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS12MC1wcm9qZWN0Ly4vbm9kZV9tb2R1bGVzL0B2aWRlb2pzL3hoci9saWIvaW50ZXJjZXB0b3JzLmpzP2M4N2IiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyTG9vc2UobywgYWxsb3dBcnJheUxpa2UpIHsgdmFyIGl0ID0gdHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl0gfHwgb1tcIkBAaXRlcmF0b3JcIl07IGlmIChpdCkgcmV0dXJuIChpdCA9IGl0LmNhbGwobykpLm5leHQuYmluZChpdCk7IGlmIChBcnJheS5pc0FycmF5KG8pIHx8IChpdCA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvKSkgfHwgYWxsb3dBcnJheUxpa2UgJiYgbyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHsgaWYgKGl0KSBvID0gaXQ7IHZhciBpID0gMDsgcmV0dXJuIGZ1bmN0aW9uICgpIHsgaWYgKGkgPj0gby5sZW5ndGgpIHJldHVybiB7IGRvbmU6IHRydWUgfTsgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiBvW2krK10gfTsgfTsgfSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH1cblxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB9XG5cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfVxuXG52YXIgSW50ZXJjZXB0b3JzU3RvcmFnZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEludGVyY2VwdG9yc1N0b3JhZ2UoKSB7XG4gICAgdGhpcy50eXBlVG9JbnRlcmNlcHRvcnNNYXBfID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuZW5hYmxlZF8gPSBmYWxzZTtcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBJbnRlcmNlcHRvcnNTdG9yYWdlLnByb3RvdHlwZTtcblxuICBfcHJvdG8uZ2V0SXNFbmFibGVkID0gZnVuY3Rpb24gZ2V0SXNFbmFibGVkKCkge1xuICAgIHJldHVybiB0aGlzLmVuYWJsZWRfO1xuICB9O1xuXG4gIF9wcm90by5lbmFibGUgPSBmdW5jdGlvbiBlbmFibGUoKSB7XG4gICAgdGhpcy5lbmFibGVkXyA9IHRydWU7XG4gIH07XG5cbiAgX3Byb3RvLmRpc2FibGUgPSBmdW5jdGlvbiBkaXNhYmxlKCkge1xuICAgIHRoaXMuZW5hYmxlZF8gPSBmYWxzZTtcbiAgfTtcblxuICBfcHJvdG8ucmVzZXQgPSBmdW5jdGlvbiByZXNldCgpIHtcbiAgICB0aGlzLnR5cGVUb0ludGVyY2VwdG9yc01hcF8gPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5lbmFibGVkXyA9IGZhbHNlO1xuICB9O1xuXG4gIF9wcm90by5hZGRJbnRlcmNlcHRvciA9IGZ1bmN0aW9uIGFkZEludGVyY2VwdG9yKHR5cGUsIGludGVyY2VwdG9yKSB7XG4gICAgaWYgKCF0aGlzLnR5cGVUb0ludGVyY2VwdG9yc01hcF8uaGFzKHR5cGUpKSB7XG4gICAgICB0aGlzLnR5cGVUb0ludGVyY2VwdG9yc01hcF8uc2V0KHR5cGUsIG5ldyBTZXQoKSk7XG4gICAgfVxuXG4gICAgdmFyIGludGVyY2VwdG9yc1NldCA9IHRoaXMudHlwZVRvSW50ZXJjZXB0b3JzTWFwXy5nZXQodHlwZSk7XG5cbiAgICBpZiAoaW50ZXJjZXB0b3JzU2V0LmhhcyhpbnRlcmNlcHRvcikpIHtcbiAgICAgIC8vIGFscmVhZHkgaGF2ZSB0aGlzIGludGVyY2VwdG9yXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaW50ZXJjZXB0b3JzU2V0LmFkZChpbnRlcmNlcHRvcik7XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgX3Byb3RvLnJlbW92ZUludGVyY2VwdG9yID0gZnVuY3Rpb24gcmVtb3ZlSW50ZXJjZXB0b3IodHlwZSwgaW50ZXJjZXB0b3IpIHtcbiAgICB2YXIgaW50ZXJjZXB0b3JzU2V0ID0gdGhpcy50eXBlVG9JbnRlcmNlcHRvcnNNYXBfLmdldCh0eXBlKTtcblxuICAgIGlmIChpbnRlcmNlcHRvcnNTZXQgJiYgaW50ZXJjZXB0b3JzU2V0LmhhcyhpbnRlcmNlcHRvcikpIHtcbiAgICAgIGludGVyY2VwdG9yc1NldC5kZWxldGUoaW50ZXJjZXB0b3IpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIF9wcm90by5jbGVhckludGVyY2VwdG9yc0J5VHlwZSA9IGZ1bmN0aW9uIGNsZWFySW50ZXJjZXB0b3JzQnlUeXBlKHR5cGUpIHtcbiAgICB2YXIgaW50ZXJjZXB0b3JzU2V0ID0gdGhpcy50eXBlVG9JbnRlcmNlcHRvcnNNYXBfLmdldCh0eXBlKTtcblxuICAgIGlmICghaW50ZXJjZXB0b3JzU2V0KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdGhpcy50eXBlVG9JbnRlcmNlcHRvcnNNYXBfLmRlbGV0ZSh0eXBlKTtcbiAgICB0aGlzLnR5cGVUb0ludGVyY2VwdG9yc01hcF8uc2V0KHR5cGUsIG5ldyBTZXQoKSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgX3Byb3RvLmNsZWFyID0gZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgaWYgKCF0aGlzLnR5cGVUb0ludGVyY2VwdG9yc01hcF8uc2l6ZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHRoaXMudHlwZVRvSW50ZXJjZXB0b3JzTWFwXyA9IG5ldyBNYXAoKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICBfcHJvdG8uZ2V0Rm9yVHlwZSA9IGZ1bmN0aW9uIGdldEZvclR5cGUodHlwZSkge1xuICAgIHJldHVybiB0aGlzLnR5cGVUb0ludGVyY2VwdG9yc01hcF8uZ2V0KHR5cGUpIHx8IG5ldyBTZXQoKTtcbiAgfTtcblxuICBfcHJvdG8uZXhlY3V0ZSA9IGZ1bmN0aW9uIGV4ZWN1dGUodHlwZSwgcGF5bG9hZCkge1xuICAgIHZhciBpbnRlcmNlcHRvcnMgPSB0aGlzLmdldEZvclR5cGUodHlwZSk7XG5cbiAgICBmb3IgKHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlckxvb3NlKGludGVyY2VwdG9ycyksIF9zdGVwOyAhKF9zdGVwID0gX2l0ZXJhdG9yKCkpLmRvbmU7KSB7XG4gICAgICB2YXIgaW50ZXJjZXB0b3IgPSBfc3RlcC52YWx1ZTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcGF5bG9hZCA9IGludGVyY2VwdG9yKHBheWxvYWQpO1xuICAgICAgfSBjYXRjaCAoZSkgey8vaWdub3JlXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHBheWxvYWQ7XG4gIH07XG5cbiAgcmV0dXJuIEludGVyY2VwdG9yc1N0b3JhZ2U7XG59KCk7XG5cbm1vZHVsZS5leHBvcnRzID0gSW50ZXJjZXB0b3JzU3RvcmFnZTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@videojs/xhr/lib/interceptors.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@videojs/xhr/lib/retry.js":
/*!************************************************!*\
  !*** ./node_modules/@videojs/xhr/lib/retry.js ***!
  \************************************************/
/***/ ((module) => {

eval("\n\nvar RetryManager = /*#__PURE__*/function () {\n  function RetryManager() {\n    this.maxAttempts_ = 1;\n    this.delayFactor_ = 0.1;\n    this.fuzzFactor_ = 0.1;\n    this.initialDelay_ = 1000;\n    this.enabled_ = false;\n  }\n\n  var _proto = RetryManager.prototype;\n\n  _proto.getIsEnabled = function getIsEnabled() {\n    return this.enabled_;\n  };\n\n  _proto.enable = function enable() {\n    this.enabled_ = true;\n  };\n\n  _proto.disable = function disable() {\n    this.enabled_ = false;\n  };\n\n  _proto.reset = function reset() {\n    this.maxAttempts_ = 1;\n    this.delayFactor_ = 0.1;\n    this.fuzzFactor_ = 0.1;\n    this.initialDelay_ = 1000;\n    this.enabled_ = false;\n  };\n\n  _proto.getMaxAttempts = function getMaxAttempts() {\n    return this.maxAttempts_;\n  };\n\n  _proto.setMaxAttempts = function setMaxAttempts(maxAttempts) {\n    this.maxAttempts_ = maxAttempts;\n  };\n\n  _proto.getDelayFactor = function getDelayFactor() {\n    return this.delayFactor_;\n  };\n\n  _proto.setDelayFactor = function setDelayFactor(delayFactor) {\n    this.delayFactor_ = delayFactor;\n  };\n\n  _proto.getFuzzFactor = function getFuzzFactor() {\n    return this.fuzzFactor_;\n  };\n\n  _proto.setFuzzFactor = function setFuzzFactor(fuzzFactor) {\n    this.fuzzFactor_ = fuzzFactor;\n  };\n\n  _proto.getInitialDelay = function getInitialDelay() {\n    return this.initialDelay_;\n  };\n\n  _proto.setInitialDelay = function setInitialDelay(initialDelay) {\n    this.initialDelay_ = initialDelay;\n  };\n\n  _proto.createRetry = function createRetry(_temp) {\n    var _ref = _temp === void 0 ? {} : _temp,\n        maxAttempts = _ref.maxAttempts,\n        delayFactor = _ref.delayFactor,\n        fuzzFactor = _ref.fuzzFactor,\n        initialDelay = _ref.initialDelay;\n\n    return new Retry({\n      maxAttempts: maxAttempts || this.maxAttempts_,\n      delayFactor: delayFactor || this.delayFactor_,\n      fuzzFactor: fuzzFactor || this.fuzzFactor_,\n      initialDelay: initialDelay || this.initialDelay_\n    });\n  };\n\n  return RetryManager;\n}();\n\nvar Retry = /*#__PURE__*/function () {\n  function Retry(options) {\n    this.maxAttempts_ = options.maxAttempts;\n    this.delayFactor_ = options.delayFactor;\n    this.fuzzFactor_ = options.fuzzFactor;\n    this.currentDelay_ = options.initialDelay;\n    this.currentAttempt_ = 1;\n  }\n\n  var _proto2 = Retry.prototype;\n\n  _proto2.moveToNextAttempt = function moveToNextAttempt() {\n    this.currentAttempt_++;\n    var delayDelta = this.currentDelay_ * this.delayFactor_;\n    this.currentDelay_ = this.currentDelay_ + delayDelta;\n  };\n\n  _proto2.shouldRetry = function shouldRetry() {\n    return this.currentAttempt_ < this.maxAttempts_;\n  };\n\n  _proto2.getCurrentDelay = function getCurrentDelay() {\n    return this.currentDelay_;\n  };\n\n  _proto2.getCurrentMinPossibleDelay = function getCurrentMinPossibleDelay() {\n    return (1 - this.fuzzFactor_) * this.currentDelay_;\n  };\n\n  _proto2.getCurrentMaxPossibleDelay = function getCurrentMaxPossibleDelay() {\n    return (1 + this.fuzzFactor_) * this.currentDelay_;\n  }\n  /**\n   * For example fuzzFactor is 0.1\n   * This means 10% deviation\n   * So if we have delay as 1000\n   * This function can generate any value from 900 to 1100\n   */\n  ;\n\n  _proto2.getCurrentFuzzedDelay = function getCurrentFuzzedDelay() {\n    var lowValue = this.getCurrentMinPossibleDelay();\n    var highValue = this.getCurrentMaxPossibleDelay();\n    return lowValue + Math.random() * (highValue - lowValue);\n  };\n\n  return Retry;\n}();\n\nmodule.exports = RetryManager;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHZpZGVvanMveGhyL2xpYi9yZXRyeS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktdjAtcHJvamVjdC8uL25vZGVfbW9kdWxlcy9AdmlkZW9qcy94aHIvbGliL3JldHJ5LmpzP2YwNzEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBSZXRyeU1hbmFnZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBSZXRyeU1hbmFnZXIoKSB7XG4gICAgdGhpcy5tYXhBdHRlbXB0c18gPSAxO1xuICAgIHRoaXMuZGVsYXlGYWN0b3JfID0gMC4xO1xuICAgIHRoaXMuZnV6ekZhY3Rvcl8gPSAwLjE7XG4gICAgdGhpcy5pbml0aWFsRGVsYXlfID0gMTAwMDtcbiAgICB0aGlzLmVuYWJsZWRfID0gZmFsc2U7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gUmV0cnlNYW5hZ2VyLnByb3RvdHlwZTtcblxuICBfcHJvdG8uZ2V0SXNFbmFibGVkID0gZnVuY3Rpb24gZ2V0SXNFbmFibGVkKCkge1xuICAgIHJldHVybiB0aGlzLmVuYWJsZWRfO1xuICB9O1xuXG4gIF9wcm90by5lbmFibGUgPSBmdW5jdGlvbiBlbmFibGUoKSB7XG4gICAgdGhpcy5lbmFibGVkXyA9IHRydWU7XG4gIH07XG5cbiAgX3Byb3RvLmRpc2FibGUgPSBmdW5jdGlvbiBkaXNhYmxlKCkge1xuICAgIHRoaXMuZW5hYmxlZF8gPSBmYWxzZTtcbiAgfTtcblxuICBfcHJvdG8ucmVzZXQgPSBmdW5jdGlvbiByZXNldCgpIHtcbiAgICB0aGlzLm1heEF0dGVtcHRzXyA9IDE7XG4gICAgdGhpcy5kZWxheUZhY3Rvcl8gPSAwLjE7XG4gICAgdGhpcy5mdXp6RmFjdG9yXyA9IDAuMTtcbiAgICB0aGlzLmluaXRpYWxEZWxheV8gPSAxMDAwO1xuICAgIHRoaXMuZW5hYmxlZF8gPSBmYWxzZTtcbiAgfTtcblxuICBfcHJvdG8uZ2V0TWF4QXR0ZW1wdHMgPSBmdW5jdGlvbiBnZXRNYXhBdHRlbXB0cygpIHtcbiAgICByZXR1cm4gdGhpcy5tYXhBdHRlbXB0c187XG4gIH07XG5cbiAgX3Byb3RvLnNldE1heEF0dGVtcHRzID0gZnVuY3Rpb24gc2V0TWF4QXR0ZW1wdHMobWF4QXR0ZW1wdHMpIHtcbiAgICB0aGlzLm1heEF0dGVtcHRzXyA9IG1heEF0dGVtcHRzO1xuICB9O1xuXG4gIF9wcm90by5nZXREZWxheUZhY3RvciA9IGZ1bmN0aW9uIGdldERlbGF5RmFjdG9yKCkge1xuICAgIHJldHVybiB0aGlzLmRlbGF5RmFjdG9yXztcbiAgfTtcblxuICBfcHJvdG8uc2V0RGVsYXlGYWN0b3IgPSBmdW5jdGlvbiBzZXREZWxheUZhY3RvcihkZWxheUZhY3Rvcikge1xuICAgIHRoaXMuZGVsYXlGYWN0b3JfID0gZGVsYXlGYWN0b3I7XG4gIH07XG5cbiAgX3Byb3RvLmdldEZ1enpGYWN0b3IgPSBmdW5jdGlvbiBnZXRGdXp6RmFjdG9yKCkge1xuICAgIHJldHVybiB0aGlzLmZ1enpGYWN0b3JfO1xuICB9O1xuXG4gIF9wcm90by5zZXRGdXp6RmFjdG9yID0gZnVuY3Rpb24gc2V0RnV6ekZhY3RvcihmdXp6RmFjdG9yKSB7XG4gICAgdGhpcy5mdXp6RmFjdG9yXyA9IGZ1enpGYWN0b3I7XG4gIH07XG5cbiAgX3Byb3RvLmdldEluaXRpYWxEZWxheSA9IGZ1bmN0aW9uIGdldEluaXRpYWxEZWxheSgpIHtcbiAgICByZXR1cm4gdGhpcy5pbml0aWFsRGVsYXlfO1xuICB9O1xuXG4gIF9wcm90by5zZXRJbml0aWFsRGVsYXkgPSBmdW5jdGlvbiBzZXRJbml0aWFsRGVsYXkoaW5pdGlhbERlbGF5KSB7XG4gICAgdGhpcy5pbml0aWFsRGVsYXlfID0gaW5pdGlhbERlbGF5O1xuICB9O1xuXG4gIF9wcm90by5jcmVhdGVSZXRyeSA9IGZ1bmN0aW9uIGNyZWF0ZVJldHJ5KF90ZW1wKSB7XG4gICAgdmFyIF9yZWYgPSBfdGVtcCA9PT0gdm9pZCAwID8ge30gOiBfdGVtcCxcbiAgICAgICAgbWF4QXR0ZW1wdHMgPSBfcmVmLm1heEF0dGVtcHRzLFxuICAgICAgICBkZWxheUZhY3RvciA9IF9yZWYuZGVsYXlGYWN0b3IsXG4gICAgICAgIGZ1enpGYWN0b3IgPSBfcmVmLmZ1enpGYWN0b3IsXG4gICAgICAgIGluaXRpYWxEZWxheSA9IF9yZWYuaW5pdGlhbERlbGF5O1xuXG4gICAgcmV0dXJuIG5ldyBSZXRyeSh7XG4gICAgICBtYXhBdHRlbXB0czogbWF4QXR0ZW1wdHMgfHwgdGhpcy5tYXhBdHRlbXB0c18sXG4gICAgICBkZWxheUZhY3RvcjogZGVsYXlGYWN0b3IgfHwgdGhpcy5kZWxheUZhY3Rvcl8sXG4gICAgICBmdXp6RmFjdG9yOiBmdXp6RmFjdG9yIHx8IHRoaXMuZnV6ekZhY3Rvcl8sXG4gICAgICBpbml0aWFsRGVsYXk6IGluaXRpYWxEZWxheSB8fCB0aGlzLmluaXRpYWxEZWxheV9cbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4gUmV0cnlNYW5hZ2VyO1xufSgpO1xuXG52YXIgUmV0cnkgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBSZXRyeShvcHRpb25zKSB7XG4gICAgdGhpcy5tYXhBdHRlbXB0c18gPSBvcHRpb25zLm1heEF0dGVtcHRzO1xuICAgIHRoaXMuZGVsYXlGYWN0b3JfID0gb3B0aW9ucy5kZWxheUZhY3RvcjtcbiAgICB0aGlzLmZ1enpGYWN0b3JfID0gb3B0aW9ucy5mdXp6RmFjdG9yO1xuICAgIHRoaXMuY3VycmVudERlbGF5XyA9IG9wdGlvbnMuaW5pdGlhbERlbGF5O1xuICAgIHRoaXMuY3VycmVudEF0dGVtcHRfID0gMTtcbiAgfVxuXG4gIHZhciBfcHJvdG8yID0gUmV0cnkucHJvdG90eXBlO1xuXG4gIF9wcm90bzIubW92ZVRvTmV4dEF0dGVtcHQgPSBmdW5jdGlvbiBtb3ZlVG9OZXh0QXR0ZW1wdCgpIHtcbiAgICB0aGlzLmN1cnJlbnRBdHRlbXB0XysrO1xuICAgIHZhciBkZWxheURlbHRhID0gdGhpcy5jdXJyZW50RGVsYXlfICogdGhpcy5kZWxheUZhY3Rvcl87XG4gICAgdGhpcy5jdXJyZW50RGVsYXlfID0gdGhpcy5jdXJyZW50RGVsYXlfICsgZGVsYXlEZWx0YTtcbiAgfTtcblxuICBfcHJvdG8yLnNob3VsZFJldHJ5ID0gZnVuY3Rpb24gc2hvdWxkUmV0cnkoKSB7XG4gICAgcmV0dXJuIHRoaXMuY3VycmVudEF0dGVtcHRfIDwgdGhpcy5tYXhBdHRlbXB0c187XG4gIH07XG5cbiAgX3Byb3RvMi5nZXRDdXJyZW50RGVsYXkgPSBmdW5jdGlvbiBnZXRDdXJyZW50RGVsYXkoKSB7XG4gICAgcmV0dXJuIHRoaXMuY3VycmVudERlbGF5XztcbiAgfTtcblxuICBfcHJvdG8yLmdldEN1cnJlbnRNaW5Qb3NzaWJsZURlbGF5ID0gZnVuY3Rpb24gZ2V0Q3VycmVudE1pblBvc3NpYmxlRGVsYXkoKSB7XG4gICAgcmV0dXJuICgxIC0gdGhpcy5mdXp6RmFjdG9yXykgKiB0aGlzLmN1cnJlbnREZWxheV87XG4gIH07XG5cbiAgX3Byb3RvMi5nZXRDdXJyZW50TWF4UG9zc2libGVEZWxheSA9IGZ1bmN0aW9uIGdldEN1cnJlbnRNYXhQb3NzaWJsZURlbGF5KCkge1xuICAgIHJldHVybiAoMSArIHRoaXMuZnV6ekZhY3Rvcl8pICogdGhpcy5jdXJyZW50RGVsYXlfO1xuICB9XG4gIC8qKlxuICAgKiBGb3IgZXhhbXBsZSBmdXp6RmFjdG9yIGlzIDAuMVxuICAgKiBUaGlzIG1lYW5zIMKxMTAlIGRldmlhdGlvblxuICAgKiBTbyBpZiB3ZSBoYXZlIGRlbGF5IGFzIDEwMDBcbiAgICogVGhpcyBmdW5jdGlvbiBjYW4gZ2VuZXJhdGUgYW55IHZhbHVlIGZyb20gOTAwIHRvIDExMDBcbiAgICovXG4gIDtcblxuICBfcHJvdG8yLmdldEN1cnJlbnRGdXp6ZWREZWxheSA9IGZ1bmN0aW9uIGdldEN1cnJlbnRGdXp6ZWREZWxheSgpIHtcbiAgICB2YXIgbG93VmFsdWUgPSB0aGlzLmdldEN1cnJlbnRNaW5Qb3NzaWJsZURlbGF5KCk7XG4gICAgdmFyIGhpZ2hWYWx1ZSA9IHRoaXMuZ2V0Q3VycmVudE1heFBvc3NpYmxlRGVsYXkoKTtcbiAgICByZXR1cm4gbG93VmFsdWUgKyBNYXRoLnJhbmRvbSgpICogKGhpZ2hWYWx1ZSAtIGxvd1ZhbHVlKTtcbiAgfTtcblxuICByZXR1cm4gUmV0cnk7XG59KCk7XG5cbm1vZHVsZS5leHBvcnRzID0gUmV0cnlNYW5hZ2VyOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@videojs/xhr/lib/retry.js\n");

/***/ })

};
;